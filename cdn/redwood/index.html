<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"934c273c88da50e1fc73d17e0d2e3f1e5a0729ea6d36304f2103a875182b78f079250d7b457b1c224ccc17e4f4fd0eafaa5aa96a13a84f40749efbd7627271676b93a72f1fa61b05934f4961fb41ef323a6856daf716132a31001acd70f9e0507bb118c9ea6aa6e1c5eab0cdeb757c507cf9ede72512c2d33422162c2185d72ecb4b381e1b98d65c010662da55aea505fbd52f8a69e87b31591f0e5ff04e7ee02d77c9ae74b27c73f8cd50b951ce295a31f54447939fa0c0580d75f1218e3e2b6de15a3de1a61fe69d644ce8a7b78b4f963f089afe2b10cceeaca0933878f75ff2d82c284698f0e04f0a10d49ed5be5e56984da54239507357dfa8be524fd69ddfed5870708fc64382c942058dbad1b6fcaa45c7b439a6ba4e3b4d277985895d9f3694ee18d82509a9ea07eb7c74e116b5a111442c67468ea1807eb83bcbaf2ebdd0ca1fcd67049b91a9a4bb1d21557446373764e0e42a55eefbe9c952e571e72b03a4a60c08c0897ab0fd9f5bc2bd17fd5836b3a5c30c4dcd118ac14d293a80bc5d69239ea1ec382d98ba9bf558323b36d3806ff6ebcca7d8bb0e471556f593a9d12238a2a1afb37ae96f0143dcf77e4874b8a1aaf1831a85fc04bca42bc6fb8e5a7d9eb1d41208aa745ad8dff0e1fdc42a4a674008fd3ffbd621785f4faecb179c2f1d83b3ff94e0a8ef4818a1dbe1d0ef850e4dd4f18f474749d1a7306ccf983156ee81f0f0ca2d44f1e25ea2c1caaa7d0f3a088a6f1250f28f5d97faca15ae0bcc30542c7a1793aa2e9a51a8a6ac821101810b12d2e79b236a10dfc445cb967e3c7de224e5d4297bd592e09ecfa1f7114f010b3d903a5d60441e4ee2668214197da33fe23b61479378b222fddad1f7d9bf00d8e9054a3dbeba04fbb1291c57505f0fd40d28e183dc13bfd159d100249e2c71bfe7aaca84ee6e3b9bcc3c8a74a1b987593516c88a087b7c19a79e71b25517772f378d302da6964998a3d6b8f1af52ebcdc0c984b6814c1ad6f32ec30fde1fe3d154e4ca94b581ef0f2796acd1c6352ad08a0d56890ca3b3a9b3d14d8651d3a4bcc1c913821680430cefde42ca85b464d5f2808f0453409e8b1a58c884fe5d32846145fc6e4f98d913c363a62683f73b787ab46fc931e25df02e2f0bcb0eb16dc6d88fed0fc0999a688b471b764d7ee15a3256bdfc8094f4696f7fe32801b16cf16b90a6503cb7905759fb069e3bd7c977eac6699168d4f7b6393fff15866221771f3628c9edcb644cf14ce67b0b4c7f68907fa29e1e704c0aa5b370116eb04aa75e752435470c09ef71f5d69ee89c02fb92aecc55aa1d058c75d5ad0d5a1b145e89c3b097648b9802bc7f7a63305a2c62c033926e687e08e1ef70dc6ea1364934db54a18f0a98033b2118d408b7e70d1033a624b659ba4a2edc31881ce58dde45122534df7d4699d8732e0f9855b2d80524a5bcec0d5159a385042b9f872831b3bde682ffe0d69b144b958783daf80c78d24eea8f82656f673178d0e2f6d3a09ef48e414c957eb8823791a938c38320c1af47403e08deaeac53e84950b529a13441e456bf522a018cc1e2ac833f4463b6ae27d8a16ae2961e7b9dbafd970789718d5cfb94227f7384ca7057e75dde70409b4406c650d0120ecf25028840700079332f5f0529949e1c0e1dadd0ebcbb199abbac176898f6f83feb21032f4eae9c2ee80e3d6e9ca25e5fd6b306d6d64ef4e9128ea5eeeb052a43e2b7a716420dcf896ad6cf2de62e52685572909a7ec9f72997d3326d8bedb56576532625270908157cfd417ffe16acda59c1473580a789102c3ef913ce2573faa48d27662cfdc6f8bc4c802e734b95fa1aa6c2a1cc88710bc7dd64723cd0edc0806604e8fb87e869a149d2469c14d3b6124702e9756dc02a8e72b5dbe820bbf94529a27987a53413ba1c8a40e5e5a2dc04c36d71d42ebdb7d07bccf7a472ab2d3a6abdb6424b4fa36c1bba3a0f8f60c53d6327dc701c2f13fc6750ecf82be2b01f38c91735d688445534fb9415a1b64f6e0e124e6844b1f0302a80ebc35ed11c0da48ae482d168b41adf288b21dee856b1f18860d648e20bc5e87a660cfdbde86442e42c09ddbb2abe43904621015d9f099b2c19531f15ab14dabc48d578090246e697b6a8e4e4b45b3731414768f781b9701113bde5ddede12b5051faa3c84934b5eea063910d6c055ea4fc2e52467d125895bbf760ea5c577a989077a191708523a0e1ed322c9ffb5ac397692d8237ff6fb1831cbeb7e75b25a693b3e12070ae35c5258430de6a871ec29f7db071b262105816469ab7f7cf87f6b468885969e298eb393fcd311c4dbf47dd19564571ee9fa1bdf314cdc8a8cde674146e1f32ebb12b35c3ca0cbdbfb12914470ed557b8f28f2f80b88b329933281d93b3453a51ad4a984b9dae2a7e9b4133ba82fd2f9f34c5de298a7a743165e2fa73a43c8d7d44251889d4d5d24888dfffc5a612564b6c5acca489b9869bb7a73bdd815a985a79c2df6a6c3e7dfa7ae14439ba9abfeb34ac4b84bb3bc4b72730e7fa0b4eecde33070c0c16f1017e2d65c9957ef1fe4e71cc00dfc4cd037cd091316c2f8b7aa5a6c8c35007ccad003c229a0ac2a092199a700042d5226ab8a877eed21fc74e3c52b38b8ac5be0a17f9b717381aef893d162347e6dab312c7d9ad1f39a1a377fe4fc6a25fd7a32a4de3e496e2257c917a468b704e10b286204a9805227bc677568ddbba89b3f7b9cd2fa32f8b7379ef4e4f55e1a386b56ac8bb5d220c549524087b76566f0d79a95cbe0b03933e9354b8627d1890b2772ea7f9570f09e331b3103f780265e88684e13b3c9971645b2abcdb0e0f093d1821c39ee8b89046188e28d0573b5ad67ccaeaf8c993ded528e809a8b6564df7fd909a9f7cb63beea3c6a859d586a5360b1886a422ec86eba8e7990ebe391aa6873f1fde60a784c62d9a9108e4ce161498ed9e21c17a3941db38fe7c43910b35d2a2159f39a7cdd06027590cc90368f4c58edc272e6efdbbbb53088ead6be35b07b27eeb3c98800f049a56b2627003b90f0146628c58e7d8070be0e03e2bbdccefb8ba57c0bb1e3903e996729067718efa8fb9e270c484f48a7ea2633a23b0286de3922c0707cb3cb97dcdd5b0c5db3a664792a81406e3a962d3a7b68a5ce0fd496268bbf3b4495ea072de4bdf3445d8b1e3b35d292ee54dbb6e1930d541cc25cf08e40a8cc5682533b0df6e62d2d62979d365be80a3d7eb0eb74a307db061ac05a00047f798613329048c39d7dba20b87ded37837d896b659697464613fa281c04603594cd88cde741d6feb261b6f3fef04d6e6e7fc879660073c6f1da4a466399c7ba69ddbc534d1cedb1601679526a3448c53fb8da365a7a9ff882de03cda91e9f9ff5f641eaa24eac8afeeb1c343a256f5c7b4c7f7857dc9a58d40e1edb49dfe06082ac30d0879f9a63e5c0fd11bf0303de654fcb67ca8d2c20cf55147100cce84df7962030ad8c8f9e2d1cd5871e4fcf102a0545ff536ae1cb212ceacfd2818db11674cf9e61a187f222eb18a33dee1aa76b2a1d25ec61f6add83fdc563f33f104ae3e89fac11e1f0fb0e33f6aed90e46a3390b001482de1bbf996d6e3acbdcf3bd43a97b4b6817a84d72e248510aa9f52d8290842d88f953149d5cd26ca5e4cf7d65b503f919c05beb457a74eaef54b8d81942afe0f33e7e21e36011ded030f5d76e26c4a81f4d9c1fbf3e0d073f5efdb8df0d7e6c9618845fdb0e66fc82a853b9220fe6410b4246404affad80d553c6e3d66f92b62d31200141259088f4ba2b0906f184ea61e59fbb47937a1be2081b08fda32a5c6ad9af7a0a3f28a3e9c9a450619ae89427e001add3d3356a71ac085ca24f26f92b377ae089c1a63e0842eb3e2a9bd84ee44e29121815eaa9c65bdd9e8fffdff10774b44dfa50ba26874370a103ec45bf36043d9aaf302a501420f32f4397da1e5558d4f8b0f3ccd536e5919a6eed8c2310a7bdde098803f86e1bb4e21c0be52d2779a185dde253c4ae9d10393f72517d39b1fabee504b10cc78e285217aa7cc6cccc5e5f2dd53941ffa6a49fe75d2aaee3878325f2c843fa2284d7f0794b65db54942b75dc36f7bbc175457dd36994d9240bbf345131fddfb5a28fedfcb8dde73d61d7937babf58a2a3251a9ab8f01fbf53437f43a83ef6ccc7b37f0c403656f7b5d07ac0b45d599b648ff2184502302436ce8a068f84c74310213d25b4c080fa487aabfcc189b5d417471aaaabc6a52fa3da384d7c9028530cc056d42c4366cb60c309071f8a7c08b4c88edad0eb54a982155683288de8e92a12bcdcfc0d8e04225e391ce3b8bc736007b2200487598329d2b53f647b3c6ea3ee307e3cc772200f40db5f724cbcc763e21d246296b6ac0c4cc02e3a42313da9c6ddfcc08203b8e8ea5199fe2fd4b89327ef7c052d9ed5070393eea84628314ed91479b929bb84c47bdba6a6bf0dcde5004ad7ee0b3e97a46e5ed63f149b7ba5198432e4c913e50696146b3c9dd3e8f8ae4c3ac42fe26e4f06ce06e1c4f3292b8025b5368197a9b898ca60ba518635c4f97c72a2609023db095b241c538852f3d887aaf67df21657eee90f4ca3a70b5f3edbdc5548b14a3196a9ed291cb60d85c6af74c252eec361880630f27c6b8e9c15277c08face46b559f2aa8b706929fb60e4b9d0741bba53d8c0a400f667e3f3ea9e4fa05d1a3240f473f48b3f271bf6d611dfefb95bbabc8916c5219b980fd1d93e6bbde0aecfdcdb9e1cb0636dce06304b41c66fbb23b62180f6e48308615d28c196f21600cf88a09b9ed422f36d97a1ed735c42abe32b5a2fab02e2223aa8dd6c3a1055c740aa34675a5b99b1b1fe9dcd12106113d8e0ea438cf391b4f9309ae96ee302146587fb641e5ad6d2b2a14b0f4cef7699eb1a88390f139bfc03e9110b05e08bb526d693252639a05b11be324483cf03a270bd9bd6bfefe7c737c92b4ae85348fc881ad9b09fbd93d856248e6534ab26212193809dff894466f435ac9f804b662f0a6d6d37aa180476b94bfeb04a1255f804254742d479bbef8cd7635fa7b469a6131a4e391c552010f36c20f208056bc8222c4d216967e54a5f67311bfd278d0422871c6846b6dcad607a9e942f4d83d0ca9b8c6ebd02a1e6bd6d214d4110573f066632f08ef288e7fd4adec9214900826c4c97c7a6ebac8fd96a3e6865f5726c46986db3f79984232cabe70251610ba2e38e8d7a430fe9de335117dfa0548ea380b91619b49bb14ad7ba5c7ceb6957bcfbeca73d44e7f3d51499a46770d1ed17444abcfbb6216cb09d00026cfa2c4f4363283f6fc6340b80380f7d45b8a2d1a935df191c2ec1eb1cde5b93655dead05819991703e98bed4708e071c1d56759fa6d2b58ea76bb6c85d3c842266dafe2ec42091ff6098c027a66fe0926e60596a5e0d437a91ed72eb977ff662b1dd5e32374c8cf3064d1406227d9710eed625258351f0a6fde42b0ef42d93d217d6a0775e3a1bdc112c3efe5479515c019947e8bbc62ed56be1f80e81a7321c8efc6d6b0e12fe53b47851af36b8ae3455da9b2738fa90fc108163bc63e189d2e0bbeed5d7b9f5a41b8202703f6330e189f658472f809fdc0f0a564c4a7c7cdede6d3cc6fb25a8480337477ec94445c23f45b463ca2c2c5f6c166df8b19f2c930062910e3ef29cfd0285068e2ca0da6a8228d5c0b130d3491969fdab1245adca95505ffb46ce6af9a8fa3c8a3362068a5339a2615ac8066c3822d0ba2c0046d3949d3ab09702fe965452ad5da3d5dbfbcd5bbd35c1ea024c72cec428989d8001e398027502dcfb777da9d8accd27866fa5f01d579c1fcd4b7e9f1507c44276a69736db715dc81c8fd70843623777e257138b64edd36a348ca821ba464982fb5e52e71e567a82371d3c98932fcf0656e214fed0276b7f0220a627972b9da24048295bfe334721fb3b75db229bdd370fa771064743d17ab862d23b09b5060241c97e1024a78c717fb91289a3a14426b00a272f0f3954ed40517ca008eee8daf6bcc4c89da54c707e05946710ac1769e6f8cecb20cdc2bd0e4b8e87b8ae77ccb190ef560562fae6be6ca787972adc1d971ee194ee9432e9bb1d892effcdb0969ffd25ed0cc3d8666a2b931a67711eee2d153b96c63ca3f7e5232b25b8b2412db4eb3aea3336787e1d8e1415a3fc61cf05ed47085f799ae89c69ae36a9c9269a9dc8dea6221fdd9630f75d9355420733124c2496ef74d731cc5b32142c8d851b89b00f28a3d86b279a61e319750281ea62d302823058fe30639c95b58ce1238ffc4bf837ca7e7453a1aec9f82bf765e1ca9c023e2b575eff96c0fb2cdc385190ef6a485e4fa36cd89ec3c00859d3e12279e79f4ff9b4ce502b375e1bae429cb66f20309ab5c86420a39b01eccca4cb367e21ff7f590a2a35858e7aa1d6dd556b5ef9ef152eb5831a1ab60fe341286418c6fc004ce4452b45eea85de976a9f71d8a23a542fdf0113f6dcc6128d1322efdb664fbc86d1ac1a51a32fc487a7f1534c2e0ca37effff501a63fb24d39c5167c648fbed4b6d3ca91afa94a616c778748a60ef99fc1ab483b365cce1b438913c0ba9438863ec95dffe479b269b50017f80c32084c8edbe8bd70e3efb2cbc2e29229e6b9910f5742296f3bc592aace966f8b823a5d70294f50596cb818f4e20b301868da107b19b154a4713fc4f859764ab3c7bc72dabbfc23a024296ee8c5a70f31d84af41aaec5fbd638ecf8f55c57c284c3201c9e018c163387f21e88a3d7ade60fb05eddb6cb8493a06bf562ce2ef163b15d3878ebe1671658d769df27ec2918e08b62af35c0328f84b17bf1ba89e88e39dea090fb952330609f255b480aacbd944aee7731ea7d3c35c7c818f83993404f49db8b6a29a81c51ad5cc02e69e2ff6feda58192b158844b357636f4ab5f550fa04811c11c07ce303cff38d5075b834240d5ef130f5264c47937b6e2ac2516b2b7a21c9a78e29cd8bbae59528460832c4bb204475ef46f5b9696b1e8c25b5acc5e276b9c13a3c5d9cc0e6874e874e38c491d5a8166756d9704475062df54f4961c14ed5298b5338a32a2e8aacee8491d131aaa141c23dccaefe305b3171723ec3efe88e23fc8f826df495827c87946e3bf9eaf7fa2bac852e8a5f2bbb79a8cfbb47d23ddda47a130fbd96bc7e22bda978043a4c28ab828829257f6179285a08ed87128fa21293e152b95fc77ea6dbd1d131015232895d8df57defe8e785e89b37dc6ceb4eb7a68dd6c97df0116d2012436cbe22121aea020e6c6a202c69568e02dc0abf4288776ebeaf301c673d2292142029d9e0b21c0ab1f374611bcb5fca8603e0dc0134416c8c40145213cbe49821a892d1db3bdc8ce40746a8a0b91d0341d8ae3a53f4facc1bbd0a0942a38230d45a959e01052bf1517415dfd951560eb59737d0522879b0639d65d033418ed986602aacd14183ceca60ca2f2cc92cd702e56136f60093d3a6916a9475f5832ddfce798c741f7fb2b32b05024f63ac51c5fbf81742b4e4d1467ef0e82a44bf7e13e7b7d0dc305f50623e3c29a03ac086e45d6de8f29e5bdc19c71fdad0ca919360b6318be4a260d306abd8287d273ad06b107309c8aba552a875101500e1feb2bdc025f961f6ba034596765aff2859bfa4ee13c200ec1114641fdd7656d2eec83e54e8843f633bbdeefe12e636d0601d92a7c5ae1f2866d2024c379a2be739a1d41c212205e7d731da6e837f7663cc872fc2849d8592dd1ff506e4eb60a669e679609c1caae28aa30e0ff983ec5140e9680f9a3de9f84557aa9667016b6fecb2756f4a50a6d2281bc3392b7c65a7264adc46b23c4d627cd8ab84546bea234a5738b9d1f0f0e22b0d3dc09753c91ce9e03c2fcd1b8bff04bbc5838a7d0a67c4b9f36b12b3c9235b00eb9357f40be42de4c449f52fa1706f50e779b7e81bae3983cee20719ae8b90d98451e8326a1ffe2f43837e5d529d8099e455beac5dd7db24ac3d012418964e40db11a024073c05175c10419ed254d7dd03bc42f2910485eba8d6b6800192fcf2d95cac502a3b3a9cfb759be8dcc78caeacc7029a91df5bd2e09a55fe2afd95e013b492e52bfd18d2e731a1a0c7d657550e57bc9469c4f9238d3a3afbc08e8ee16b3f31358cf9efed1445ea4c9203633379b9fc3f79378005f9bf44e358a13900ff87fd7653938bb938a8cc189d82385c95c02a0775276b564013d35776d5291d48fc95b11bf3f7c2693aa2c15d99550509b1d8d090eeeed2fb4acba1e1df5930662c3011a74847ed3b6f77474551dcc8e26f4bb964011dab7e6e0301c63b760cb4a568011b465b732c7e24332af6312bf1a7adfd59ff743e1ddcbbdd01e1712e54be2b87b1608c32d0d9d3949195f733cd96602703d818e90e60770f37a0f5e36832b59bd146e705185c2829e6832eb070eab7d1e4655e371eb7739015317f00d94614a59743ea0ee7f3f2c73f7caded5f1056bd511fcebf223d33b81ad9ddcec20e73417cceffc7e6ac906a832194f5930f2010f0dd25f06e2ec90625c10b7b52b26bb0f8eddc02de371af0d59f1c1c1c3a9e233e3ae74e8ed5613f525a8e17f0ef695a84e5b77bdc99ca2b223c129d2a95eabd0fe3594075e28726fafae37c8b1bb2d194a6795a0c8faabca29b90de7693c2a0040e5866b47671a9d3a66955805c70d6741837f80323f109bd698d914231c17579f210aed0c1f76831d74a5e8e349e5226f0a495d1f50648c01142f8fd4413f1bce2fd2e470cd6c3bff8338efd24362ee49740bd18bd19b0fb628d037ed835973f9178e94a335cc0b19008b7bd600d5f086eafdd031024805266712682ef50308cf2d754a0f202c077b99a15a59ac54776fd2f87b297c3797fd9a18ebedd49fc289cb73f450173c220d05a5d5bde934d75549f1fdc92e8fe161a33c2a44a1538a20abe828e237fbf52edac734a907eabe1cf7c03859a55ced5b6504799b226bf82d76ead4f685559171036985875da45396864275b4a532b1891bff24e377e5260b5fd45a313cb073624aecd31c6aaac1b961bca0794ae360ba29811d17467968a1d916eb65af3bde0954141040d3068670e6bc5a795819ca866b1fb984c72f1f0c958864ddfeff59cc7a3558df76ae681614bc449252cbf084a2ed477fcfd2750356e6a026b5d7721be83b137b035c52027ead44de85d742466a335d085344349e795fd4b3a5eb3f49c2eb12cb2101df6dbf5174ade36b1b37745b5ffdbc4fa60e64408df3ad664718d0632bc0fac1d7adfad56a912de23f0b327b9e6c590c329e557aa503521e36d75c7cdf5ac910f678ae06ba1f032ee2cf5cdb16add0c586362fe52e3d659439bac42485bbaebe0069589bdccda5c26e2a2f01142d4210af81d503c5e6fce4a3cec8df6ecc1428f09f966dc75ef624c5b2fa31d6532f8da227225bd278e4f31887b4425f1dea9730d76ce1d419f1a8b81311013cf4dfd3a11570588943b56664456f33acb3e599e96b9f233210747db4257a3c47225e6679daa5bee1d5900cc87b514bfe008bfe4dc4aab7c7126fa6ce13ee7468fb6014595a757dd33f6b92e9d6b38151c428d79dfe29f32e9cbfa47f8762c0f7da83b0bcc24320b0c4072f05eade5a9fe0947c1de75b63987fa1dff7aac2f2729a6ed4691439536c47cc75afaf11e1896f54db6ad0d695417dda6fb943ac0ddcbdcdfc67d21ee2ea630c24e25bb1bd14a53b2e23b41e9327d8a01ae53689efdd96e25846ae9e3ebf18b05733622cc7aafe864838ecfe6b6a9118bb9f280f244dda0519ca3bdd46abd68e3e53272d7eb13c8da6031383bca98f1cab6c22d30f725f04023f738b027981a93324725a82c93756db6c75eb9d2463af4d4f12ae15e292e92b76319abb5b753e63627b1caa6f57fe209a82b827478cbe2166f948fc16591b0b4e801cea76ae8fc9dd8012a7152c2bc0a827a3172201b452f2e47265de757d934afac1bb693b36e9c07fa23e42ad2d6bb2a9bafc4b9646c680825110c9847bd6c6a002f5d276633753f16f978d02019926035b7cf9c510c46ce9ce61a8b5537a446f4fb256a807dcf3d0394cbd3e82302a423edf99393b83b611272d3e0bb9dff238872a5ec5eb74170f24ef46ce8f9408e4218b9d3cb943b6659217279ff535181e83b74898eff6940871a1820e50458743a6417c52b7de6508c689ba9245a23795da141664906802b0b1e52a3e90a077bda4b792c78968fd08d9249271a823a434a86f320e1d8c5f62a2e1e731b674dac8514498a44cc6b67cbdc3c6aab55020c281c6cae2734f6d0248be5d3d33fded8aa55898f623dd33e76699098c0096d639341c1d0ae3d3bd20a10ab1630ec192ed46ee8dd880ed4df00fc7d07d1838f50ccf8b7aef2fdc2bf67ea5d51bbeb277a61fc470633d283e47dc7a59fbb0f32eaf883b183d93b6d4f302127933338567af0f2ce23a0762e8039c1a525d453ab4f5eb67cc23611075d07e46eadc79a6435cd0e97d3862b8be1be4919900b55ed49819f1f7759fab8ec207083152c10de319f07c24fa8e01889f84e9619c0d31a34f6dbc8768c5da1c5703856e628eef7243160bc78937b39268b128ecfbd3ca2293489a106f0a69968fa26476b16341dbf0277574745d0e17e231f39ad872e92f875c5161418a0b6f70f1e0353e36cd66927ef46850ebc11bdb5f13356a445d3cee209e1dcb35ff7cd4e40ac683c8eae1336366969372f13b4a11243616e358eb595a9b3a65526e8d83e459af1ae227a8eb599f5001aa15e52605b2d7c0a450ad4d329e40de07cc28e82a2831a9e8ac14ab2cad1f0467fc353d475094bf8f3e41fab503b0dd92743cef251032f6edd631d112dbda40a26c2b92f2af4739bcf14f072f21b373f09508243d8115d55da1f85e0f4d8b1cf3277d8e89c491ca502c33bd106ace092b8eeb5a4e5be48ee187c2e6d82c59fcd6abbc94bba4b310c6e149daa1e364b09142f7e69e664cb96282fbc226557992e7ac7655ee4384dd843b397af11857218261f7abcc2a8a86b0e18e1a7b3e0abe1a16bf040e7df10f4997db9127035b390b76a9b1b92745f69525169cdb71f44080c5413fa2d9ec9d0c11d6dfaadadb692f43ef94c19def9cddb09d047ec59f37e2f005de2185f5e920afab452723f7bf8e314949453a27769b7788326c45fdb3e376cde5bbcb7d3f267687d05b5e98408ac6e273906923fe6d25f2a5627a33416206820978c1d3b5b5ae724e1226b52f35cd96a6e77c0e3df6729d92701de00aa64102be0928f823fd8a25adb09e21654fd30976702b627706298f2aa0711b340c86ed858223e9f7a60b001cff5feb187f1929d49c97a7990b25421a874ce5491313ef846c6c7e0e10da1599b807dcc8f38b1c91b78ed250baf95f8f228af8827dfa5a5186614ca4b4d4f42479734739645f57b17983c0d666417126f9a5ccc64fc6b2ba07ba4da949ccde865a167d3955e0a7e60d9455fc2f7ba5dc985396c9cf3f83872bd69880dd8de6594d2825ed68ac44a38263d97f10f04afe918a9619f8cb31dac81b3432ed171e677b05a091903c306d4b837f8db52e7a0a0158abc38929eaec53548b3043cda7ad244a8b6917cd51574d352a803fa703f4c59c4feafd6d45e48bea124b61e10470f1a9b75ffce83aab310bebfe05925528203df81f38dfb8bb02508e10d8925b182338e0c7a38b885baa3fba3a53c1d217ed9eeab973c50a3c0b8cfd774fd0016fe5dfec18fb61a8d96b3bed487c544bd5f3d863c693780a56e1c03042e6fb6469da47b37d54a4d16d8cd7a1efdbfc9adeffeee10ba104b8da56678e3806ef76b83e0ab6cdd04693e98ad0c735703ccbe085e5a22f9991d19765496ab24f72f3a3c6438dfa004be2678d781286352794b617f5efb8ed0cef4e2bcda2d47fae36567d4ef6306d906bb62c661eedcfef86972549066c101af0507d337e9646519cb27fd12ddf34b3e61bc2efea4d823e4c45f768be0782544b03330f888ba5c64c337b97570d6617f0e67f5b2dde4cfc38a1ee09ba4c15907742e2c3ccc04ba7e906aa2bb3693f9741fdd0f480b424b882e6e8de3c402639a19ce851c5199b2eb13e187062e12401e63b544411681e4d9be6e38ec916a56520d9831305fae700951f1d64140ad4999a678719f6bfb1c56cc5013cb4182ad10379118d0f9c1018b3d94244958b8e5444d2cf7a6dc694f8bb057bf8e3491c5fb6e42fa4516bec8457ff6db1209ff31f9baa85b0c25c7c4137b211d887985d18e03fd26733cc118d50a063b3ec6382e3f66b676afb4a79d2f7b38bce720b7abdc756caa165cdf61f19447798099dba90f8e59bcc38697831b0a7a4d19c255e5c87ba1d396d881cc6501b8323c0965c680be07d3c88e7baaa84895a22919cf3a4785081cf6f1bf9021648324912b6a8dc3b69e4c3c2144df1dd34c7272091ef2a4b4e09c51f2fa83672c4495686a55c6de1c86c86321a1b165cf948675d48204183d469acfbdf0a67a4e345ff8c3035abc57e2904a4c159861eb501142bc880a495ad3eed31bb455fc3556245f19c719101f0a600a687b26c7073ad3c8b2b5ca79e42ac09e567c598b30ee837ae96a566ea971c91c4a29802e57ad3e0976656532cce71afe67485a73371f155fe32f6e7c578236a1b9717fac6fa8ef7f834a9833bb9c5e68638b7813aa77ca25897b0eb9776e77d4bcb63cd01c448da5f54e6faef6d3f402ca146f581f557bbbbc134da1ae119352005b00094b8292700b1aadfc50d08876952fc617b1a9b5e9d063ba334ac087b3e2dbeba634f9f4a5e54c7ae54f9254c00363bee938733935c94b1eb3c21ea4a95dfe9df3551826864a3aadbfe78b825a2dfc0871b0366f721bf0b72993cca7fde1437f9644cf44ff02062dfa25683b8bb9d38763a87cc418e76d6401c07d1f5636f2f7c728b0af65a1c1e53ea353a479fc4d05e0b3143eee2d045ff0a29fad1535564b254b27be07dddaeb80dfef6958e787ac873cd4d152a7d6e1eecc0bc735c4104ffd168985299f8a95f6538cf562c0af7dc10ed36f7d09c0e4493097d9d019dfa95fc79dace58d2bb65e967dbf37f8766cc477f39a29edd1cc2d8bbe3d47243909b83311c939b104695a3074e1c2190cb39cfc21b122bbb9304112b6aa3357193ffb6a64d1a843024eba09a220d73ca79328cf57c1aa66077a24dc8aa7cc394b72801729d8ccbca2ecf29bfd4b398ec4bbba6e53bff8d108f30a19d856a8e33cfd6c269006f59b1930eb3fd5179cb398bf63f15412ef3abcd0b3e4a8e44b6edbe3005edef80de4a4905b6f2a4dfefd5582d3ac25b50817f257df313e36fc30346f69cc38e26f0281b65a98aadf6e8f8f080c98b2c07b4729e962df32a3efa4a5a195ddfe6aa7ec9d76fd2a1876040895d10280a54ae0fe528c572130276a3b197bf341410f71a1e28981973d7e1780ba663338292589c21d36f2045db17f4cf7a26325ccd7e853e8d26bc1a64faffb33f73f53970ba34cbe8b96de74469e76991d586de9dd1ac11f7dfb0ba10365dc35732592df479a075b2a8ade2a67a2b7e662d65e11509281601f133b18a7be7e734ead1b3d555d58ef3de100c38685d7d24fd36f29d917c73418e28332f907703ffb31518837cb3d5714cbd359259fa4d5739ad04ce9e823787a33e8da27ec9ede90df1e6f7d6cc8e834487d29f8d859211b2535a9d979afbd9fc6947014e625640ccac04fa704cbbf733cbf235dba740ed5c5f5f530ac110722ffebb4b979bc3cf3fa014258798d909fa99dd10606868383c69a73fc5c02fc985e3331bd09d2e5f16e94bb48d892594ec60af80971a50b909c736030bc759abc96a859125faa53465dbe7ecf1cc1999e407ec2cbfc55d23906c774e4f2013ac6735d4fd6fd25248dadd4e50ffdc5bd1457801588d3b2629b797671204e0fc2fc6d186b10d4bbdbaa4fbd6809cdfdf5f4794c03605bc2ab02d3e27e0c3a0711caab6a9bee74222ff335b01953dc796ecb425aa88fe4f3c166cc7cc3ee102228886da2d80a2a61be8c3222bb8597b242c5a57a64a18a13aa8ab6f8f0867ee97d7fa145f8a0d6040b0eaca483a42c1ea05cdf7dcf3c88709444f2c64705bdf68a400579f957e6ebc8ee4f7e9f8bbf8915f0a6551dba9923314ffa9322ba2d8e4c9a5dc1421470e9b1bd5021ef7e77025816457a796c708d02b78656450d082ac32d623d8184d109491c5c05c3ea8f358b73803fd15f2a1e733eb7b754bc54593cf895f97f879cca509890e92bd4f05bc3ef77978185d52c531cdd65127dbe4120c140463311df57744197d8695fbdfeead9449ab6e38cd738c25e9404044a3bb530afbe6512eb271cdd9980487e76e1c952fbbe400358c6409a04bceac51c83596e3ac0fe18e768a5215e3d2318a4e6cd77e681e607e4fe5f0c2a839f8450e5e09f8d2edeabf1da9683fe169ae97915e9a398d265594b1e493137bd42612aeb132c6d8d88d119c258fa31a0ccb4891a6a0ff1418f0b5fa75ea38ad825eae41beafd5029344e7aeaca207790c5a5f5ead05f46d5dd9a36100131984b3864b5b43f3bdd0bb13d33f8396f173ee31f9821cb1e7c1b254a6a889623020d34c3b03de18ee542601b6c782e119563e3b555799029ef4b60fbc8de24ed87099a54a62d44f59692447b77b820a59186239bf2b9be6040563f1ca40db1406d987e42fc0764095bb8b7a99b414aa3044f20aa2f44b1f3680e73583c88521911acb2e02e988f8f9aeeb4c5df9d95f4c5c44112478bb2a226c053a817b5a4b06f5059bbf8a4feb06bd03c23084ce0ff394b925c0b89850bf7594f7de5fa39293e411f62bbdd31694aea9f24aeb95e56d4b011d4a7c0777ac82d0d06b88e19932927314b7329a123edf7ef50dcecbaafe5fc092872e71d0776b79f22c06c68cf6a133d145785edf41f1ecaccf626fd8757c081bfb143d10ec2767c4c737c000b778ef1e185fa6c2bcc3163bacc5fc31cce42af7b12b326a8737fc2c73abf7b11695c91e8380197e2d34eef878b24764b6734f40a53f85d994961942f3f6a23","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
