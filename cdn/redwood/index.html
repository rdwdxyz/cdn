<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a09fcfb41d651c152d887653e39025bacb575e75bcd8ac98df1a5a65eee62ecf753d6644feedec646377ccd6c8d4f85a0daf58cc8da50a8f6bcc0d21cbaccea6f0adb949d862ecfcdc0995607a3e7a2dd5e9aef2f681e0bb441f79af1baf11b739fec4617f148dd8d9637ba7a12c9f45332b08b40f2eb35bc83ed2ee7498c2018af34dd18c71a5136cac98d4e2791f410949af70a3a34c8b0500bbc3e2a292d43012b90aebc06125284fb7226f1284b839d6bc2d3be5bd9903874037ddf2d7f54af3e1c20bdc3f59049a455b7a50ce5cfe2d7754689a99529569e089e39e214efaa694f800c98e87d601d268cdbe59ec20ac433fbac03d065b7a63f21adc0295246abbf702cd977a5b636329e5128be18819d10fdb00959893b721a878f0d2aa417dd463d27b4e81e42eea7b1925ba0f99ee0813e7fc0fe8568e1d00869f555c51ae624a4e77522980ac9f23d8a8b066ec6844a15cafed1d157624e3dc391b7b623fc02f085e3e497ac29ab13ff1aaa6ba99fa5604ed1417df72533f9a20e30698b5944736d34263f72d207c74a8aa64e14ef43742e0c051fcfea6656b0ce1d26eca03daa68c22c3c9c4c637ad567e4805ce9b7afd7b782c2724f42c77848ccafbbb9e63b4e9064b8bdcfe8e54e36e972d3f7ed5674699ad070426e035ee738f0d22ddf218b2ffdfeb4bae3c3bc55e6ed897b8a2ce17fcf12e6d1078c377f73d017c0de484e5b7d66ed3a608dbe72a2af61bfd27c56bfdbb2c4ca38f86326769ae8be80403b32610f61107f8073933dfeeb9a49fffaab29918e7b67f311a067b25ccb1e9fbb859173c7c35a3effd348d6f3f85bfe67665c825991b6325bab43e841cb9083bf964e78119b9105267159115269e07e1c4861ba1c2b0860c7ac1549fcc1577d34d5be5d953d36846fe200ed78ec3083e2097fff352694195f4f45d04f4fe25a21ef65c05ba0f0efb1807760eb2f90d03cc7e81ed64ed7611c2d227c0f986648bd2a59acfd070478bb0c48efa59fe531c4789cce65a6a005792367e0388f4f85163ec7fff5d5a865aa9286414f7fb303c6c99d6cb7da0e0e07f09c85a1556b94d93f7872ecf23512de6f9bb1178226ea2c3d36782e6cc37c7260960ab10c38b0329474bae9d4d18b50375396636c5aa4e4dfecef875c7ef2bf0a4a5b577743fe71cf2666a39c63d0e7422bcb1def2bd027464fd9c5e6086deecd6c7ae9d6439d0ed86cb78fea3baeb309237631e3eb6cfbd40ada982e32b873f01c4ac1a12bdd7ed1cb4e0c89ec9e312384ab18ddf881b7956af230c1f5b8b4155e353bf16cd2a753382b7a3225e0440b5aa2d201d147348ecbf0c65e8b766e6899df67631102db1f63ac6a292111423cc6c6b9074c0b1c51637bf3f1f8af8df66eafb11a7aaaf7c7f0e9d193886d31eb89d2bc592f4e19a8a4cfa2913492b49d1a695e4904a224332e409ff59b35f8ffaaa4385ae53633f579fe93ccc752f961f5c5dc1cf8d8466f4358c16bbc5023b6d6acbabb86d5e0b1285994539fd3018ecad67f85fd8e1cf553bad75c5bd5f3e91f7e6405e9cca987e218877bf7f3e5dd853cc63836038c85d0663d95a9de95011b62721d602242236b360d3938e039a3883efa1d4907512877421337d075bbbb43d708e6f42545bc0de6433bb90de51ea8aba24a737734570be491cb2fc86de7675bc35349f30a831aecc6efc210622489ef40ca385e4d1ec67bf16f5da26affc8788e903a7f138134821b65c789ef2231b1b1b134b9b2a63b5e69cf99d712271c7f6341975562fd99635c2ca279710a3631eab1ada263a3977805a10a2e788e605e83cdfa1ba579dd9feac4ddabd400ce919168ff0596c525634c8e2e3c2d6a1aadeb3c4ffe44a4cf052172929ebe0e5a56ad0453b1b28c6a9663eafe75f6d55dace84281e3a265004fc6c5275ba0969867dd0b30183bcdd8780a3f0a69bed5d690c4d1152ba95fc77ae3bfbe2add96a9773fcc374c7ee85124b56ae41e568d2909a5466451781678cc192b93acd6587ec3a8c007b4cec088e045c42b2699dd5497594592db7dcc30c2fd38ab11452c3f0668206f8ba87d93b35e5781af539d7f0b678ee9922a03256679452c6626cf89d0e718dd503699b5855efe6b2a029d66ff4ed0274d36d8f8c0e01bf8f398606743f0c03f79517364685c84f393549ba80a290bc839e7980858b6e1b51dcad70885d9987d2203286d1e274fa5c97cd4f7090d8573c9e3b7aefe7723ee327fc57d7118247880d339fb73a05ed33e62d31b05b07180cdc06d3e327d7c6baaecbbe91f5b85a6cc20fadabde7cfc36aa690589db9b42f2b0da89546cb6e9d330d9c596941d379d262977442f4db940bd9d0957e9fc97daa0ad72f1e9c96546a5ec70dd909346a8c1fc8b8de358a937b204959fedda0957a8d7a7ec255506ef7109dd0a2a1bd451f320b4c5b00fc443eddbf647e3438f8f405342d36839bd8fd57e480697111540487028495eb26a0c91ccd9bf113bb9c4d0a70726c25f726d1c6f359d43ee2f1cf24a87340945cef64de4438ac81dc48a424d976e195c6bfc898c0678e990f3ad52980c9eaa3b38bb65325afc1fc80cbf731eaa4273523cb4c8e7a65516cc00ddd61e890c0c6ae9df42dd87eff74453e17a29e954e5b44640e4e5678a9f5397d90fb620bafab11f90c04401bdd5ffa5f363744eb3b30bd5e80375faf51324079563e9f7bb90dd6c60011d7998ee9cefa67a6f03629966ee1cf0c948a197994a61be478476fa97967e40f858ebd218120e26f9a20a59a1183ae06d98f9af90903f2fe8cd0b92900a8168cd0b5bbc0f36f9b8b833724b758113b631f05239fc356e9fadd8508541236e04a6b2a3d317b56eca1c5a3b18d853fe4427cc6cecdfd4b434079c062d23b27b56dc74fde99dbbbbefa8edb603dce5302a138424e8b96ce009d455b9b0a26838e8eb04eab3a52e60017b1da7619e8507e3c105cb915e8fb265aa3103b509d3f9bd5dc7a3acc90c90c308075e653cb79553664ee45b31e8964b1534da16dcbd8f97d2931c88f92f577c0740ed5b11685b6d93b1832a6ef4cc4c56fb46997ae57bb8a1ba18ae129ab742c7f3e8509588a77640acf096ec02d5470a49ca77d77ac9368b4f780340526cdefda712b604ad03aaf35e0b77be8b675ea5db8f4cb3f5ce1b5acef1404cef190802b629e3a1461458d5f27574ef3ffa32ce9cea279b65959045641f3fef07e289cca71ea6c6056c9c4d7f99681743cdea006772d87d86c10c7a559ceb2baa1448e7722193f22a096fd83e093689570813ee14d5a6b8b6b0604e0b53ad271e2ccd7ba1feabb80911a4796fbf014ad4f157b08d78d40f395b111f9a2083ac96c4c3b533eb5cb97d29b60c7bc89e0de09ca3efecc6bdd32b13aa02d0409d4d3939349305d231c5c9360a20c9d8eb7f1150e27fcddde5dbd296ff9fb5799c4fc6ccff0020f0f7bd007cfc0101ace3907e3db399a82ce9464595c63f03389b0bcda804339617cd53260b9b5bd11fb45e841d738f0f5194af0f0e3ab8b5ac908432fedf82d07bbd4b715975258c55d048094c9973b079b8525788b43ce39e4155cea6670aee0694a50ff83e428657a8bb9047c48b7322d498f56cab2ef5272402fa8cf3bae13f62d1f5e4619660b2b7b2351a1a54966eae8ec54e5b3c533d714d71ba0fd231a6a9fdb7fe29d2c6c8ac339e54c9b6de97779ba792735d3778b7364184fd3c232952af28d4f5a287caf30141002293ad753a0ebad5c7b6fd49f8eede5aaf290f1135c39a2a9b34186a009b708633c4f91bab7d3d99ac1fb7200db014f0a6b22e7e8f1f19626f1da42cc9436b81e6c28968a1fa245eb159d2604033e5c33964cc7301a0147f380f0c34335c06b64aeddabdc193bbbe22eb2ba7b23f45a94a3b43565e8f33c87d1cdae1b7265ec82772ced36c60e1558c0c5cc71e114cd9391e533d94b0fa4de0ba366c25a54d08757d2327a4a6c91ba66d719aa4ee054d97c73cf6bbba9b729dd8a4303c82579e41772b75a6611931bc6a9278d81aa44878086ccad7dbd75688a81a2f662e3b983098fa68a78b541d472b27b6944476745bb7df06f66cc2cf5f0ccc381172757229a0de34648a68083e6f952a162b2ea4a1cfda46605b2b02414f536fd7eb8cc9b0c4fa33c6d7838f8dfd12a9c1f47993cdd7a3af1dc0d140742bde5d43a6a1df6e5195731a107a7cc4ceaab0a6776223c935b8ae4d70c5703bcd3c466dae56054e09332b74623a3af102da0e03f407b337d4055fba66df5ceb1cabb679a85ff5ce9ae315513c4acdaf0058123ff24ecc6b5ba8bba61d0a4ab5ce923872d07314aa670a6abc0a341c7609fd1079c45c5de60d07d1c4a2c96364f085ff3c586406819fc0b519936cc534f2bc660a879efcf61da10c2ca1d796ee36ab7eac651ecbb8557f9f6dc02cf11659ecae5631ab3ad78192cdaa23dcc8b4f2f9a8607e9b29eea16378111e83c22660616a8bfe1c53cd274e3692fb40d78b0e6bccb4b931194930a1b2914c16fab07e43b0d9614ab1c327147475a4c0981d745117f4176133d85304e457ae4c46f1dad24b743b9ce75151d6b7091dd050ba4daaed688db8e6f5d678ab7c468d9ac742a29bf21ee68726c1b2e776a21e074c398a74db4c6d4c282c023c08ae635a60285d60e5ac92b6215e70486cb335b6f2df0ecb91ddf0f37d9933792f9bc975d96c4888b17f5cb1d050c0288ba30c8f007f089ad5251dd75967fd984bc0aca01c8467cca511c0730a2f07c376de94132486b2c2754d6b54dbeade122ebf33fc99ff0bbcb56f7f4003c4f499a3660317f82fa1c1f123dd59af780a49bfd2bce586f3c7ab6497695887f3d0186ef5dad08da81c59a7102d19248a03c0c40de01fbc39c9c589a8531dc8a83af831775f4ca3f57eacb502494c1df9bcb6596b5ab7c989336aa8966011806de5d21b0ead00353a5af51beb7eb98fa4cd07daaa52a18bd6d6ee19cf68f95de122586a92fc31fa445abce873f78219047b72f1f98270d0102e4aa3954440bf99315b796e169f084c35d5d37609882d037c124380c0ccd04d96ab7ba9856be8176153b98e5f48112604e5a2db1072639dde260b46a69d597fe0384747d200be5de2d85ce9adb784fb9e1d7001c1a1178f1f2708fb6e2cf067317eecbdb70e4aeb463bc4c6a76445af8f384397ade0ad7bbb3540815e8267898a0ce910822686fb6b1f7d93f7da90d0b4fcce0934812dd87cff1906a5f9a8667799f64f3acf8c179e815bfd7ba471e36251e4057e2b277d224f015e777af02e394f874c7ba5da00a30ab040cd464d12c3a6e6da0da0a12215caf4b760075baec801c90e63c5ee039a4c91760915b6353ad7921e5198ca9506193e9b8668c33d748bec3b402a668e74df7739d2bc09295f1b06cfd90324e95b869d319840c3c6bf0eb8ba0167a7abd28e981016cff027291ce182a7f72bc51339c2ad4c3b1efc9c08fa76a4f8bca30f94ed289b32fcde84db502bf8ccaf13cccb3b6c83d5da5352602d589174b7c1a1a26ae333b5669a4e5c820453a58a8dabfb0cd1e6c3cee2904b66bf8d781b411a0397c3b5edb2de787b8f536f7d4e2911b4ecf4de54609d21026b376ec991468a6d131a914a13c18d873078a09fc8e64aeab7ba6302f762eacd6e36b1aeb4a48f767e9436c54115e991860c8f995ba48c4fc0ec2c0292f28e64160fc7a91445d14d95f16331f6fb4ad6a9ee64a8078f6f06df7bf40c4902b5957a4a334d79340c9395376114e60aa73de83eec426dea2a714d29d2964a6efde8b1e5cc4f857e367e33f84cbecf57e2bac9938a9f1f02fdfe515d5641ad0ffde775ac13e9d7ed57889e4172c877c80c7d64a75b87ae7c82e26eebc1a220506b96c53325cc1dd0a46de9382947747aec2875fbf7ebd64cebcf1c34962866c6de10b66ea2d91e493909455d565e2a650c90e9f6a6b042cf402af3f0c9b99752518932741a5814049add5a658916fd7ae5d6c404a4c3e35a0e99e6af7de25f69ff0187a866e51890e3e0bbd5ea36c96fb7ce4031030f49dba98d2ae925190c0ad8ae11db1336faa27990094ace187240858a885342183c5887182048e383137b00968ec4f91a89880209a247c876e8d359a6cb48372dad1e0a703b8dfa77b11cdd1393f195ff3b8a44a575169b694da322e627ba890ae7fbebcaf2b3d5f1822a74807bdfc3361690e3b048aef87ff4eea8b8052d2410a7b0af5941615afd38faff20642673621a7679357c27726974ebec8f3d0e105597268692855a8a3850116a989343c1de2b212eecf21f571f984643c4bdca955816d8e781f5b20c0b4953919dd1e39a12f4bf15fc7c80d2c7641bcbbe5446be7014f8b678ab21007c1b7adc6aa5c12877bf1b98fe36e1b365f97fa3a6e024910f2a09108fb1acc96aea36f7af90f09c3d18a3e6a719c2c93b298bbac4952e930ec8d594e7d04bee01c7c618df5db842ee3904e676054901fcbb8593fc1b3550385e73f10fbf85c5b28df66b3b32019401ecd58985d76731d0f6bf5328249747c67af18cc60d6a77d36fd6be7064c3a677cece499467620aea4321d68619b6c1c2e76162877f7302bf54c6925d655000792ac81c99a59c83327777267bd711e2df0b8f95ac537f55778a7508a7003ef5db14e5e2f6376354920e7bc4e82ded8318131c1e5e2f9f0f7305e75ced1de833f10f48e650c5fd999f6fe622621287b82766e978ab91fa4e60abaa6b13e3ca6254320ce8d5d96af2163006a463e2176459eba856eb54cfa6f954db8762a61b23aaa2f77e5b5d7d65792a28125251011adfb3e58b137c4150c5b5b951c8df5ac32e34c20f56f9f34f36a955566d3c52affd1f385bedec109a2ac350e2c2f92712f337a70e0025936f6bc9b00147d45fdc8e141519ab48190927b045934b16659d6265c95ea704368a8d174bda4d24dc4d97e127fcd35d2a4c08fcc73db3de5a609d868ca06b68a55475b680b636d1002748da96ae484b683afe2d49f56b07cd2fda92aaa7ef4607f3f52f2ba051398ceb1c8608d4008ea672dda83885bef38fc564e00280dda66dc6bb26f9f24d398a5fb5d5b66c7490ec59d7c9b3a9afca8367017680b8c7f7a4c071c009924abbf957e82e468dffde3b90849950084520841cee7e3c0b2d1419d4ba186ddad0df8afd344a00e6c563266aa382c27e742d9061096240101fa3939cbfc0d3f5ea62fa1eb735716abbe45b65cbc18bf32fa435daa63f38b842637bf07ef7913a89ab4983c517b090f70a2d391cbf730d7e59db348ae06ba26bb033ae0bfba90434d00cdb14009bd2c5b50834e8019d481ca4a508803a2d5a77eed8df1d778be96a3b697ecab6cd18f4b7530c2c2716259de0dd5869e167f1aba60d5120709f580973dd75d468853646d74ecbf42f87332044c04c1ffd156c40f5e8b604583b3addb488562d9748283971dc530c7a051ca999291d958ba7dbb7a69995807ce2bc0b738661568188a2158b88b14c3c9361bf2ae36e1199b9e95acc7d06dd6ca307bb53b7913e4d4730654abab518b68c310cd2eb48df832aa5f4502175ad5681b35b3eec9909f820d96543d43f0ff09d96827d23e27343c360239d5c8b06ef0c91f0dc5e51c83bef4b2294998fd2f26008612f4c3272eaf02fcca950ed3593e084f5b98e9572328a09068d6add98993eb27470dff8c1ae61b31795c9384e7c6664550e37fe5a664a9006c1eeebcf80a0534b5ac38816411ca5ebecebbeffca821d7e02fd1fb393f210ca4909b9d8b9d9d781bb2f450451f3e519863c8c23a1d2d53254ba3ab58bc26c4a6b10c5f57dd786c749d16747a839aaf876d47cc7501db18b856306ce7cc0b7d6af55968627cca7c70ba73dc0473189756a355cc58a241ba91c0d2d0bafb46619f158913a80eb6c1d0720ff6c93f284f3edd6c860b9cbb04989d7c79c1bca6e15e92ddb9f87c6058735d9ca6d0c6fa077ce4bcd0de33cfe87978d71d318d7d8c36e65b42c9d46a2c219d5f4403155a00a17ea58488a9bf33df4579eee12a094e44c2cef3209b0d57735a739c8318814424afb163bdf16bbacc646311dc67ac2c15d366cef2c8777f0968e2fdd9f00344195399b7a404da568531da757e8d1e1729beda65ad82a99524c61b67783c3b4814ece4ffe4bfefc435442083d54504c38a169062d9cc61773a8f619b06160f7ed772db8031c19922fab821566050c8b762e4ef8b7007dfb435a63497335baf95723f8bdb2a67cbb4e638f684c7384daf49007b9d18fffd8e295824bfae1d9b694d8526f354f29fe022c98879daf6201271b81a9449bd82a477328c0f133aeef1aef26d87255a0b4aab5b8562157ffaec2cb76fba220cc3a141532daf8ab716897bc038ddd12d40a6c798202ec4e29c0fb8ea0894695368b86e8f63b781a12b71caaa19ede3a84df84b0c47b6667e8b28a2ecc0d9c8a62076109a1d9e5c6c42c8ea8518814b7e6ba43249c8827757c5c518f1debf601325aca8e629ecbc9320db2ea2601a60ebdd3e1c45864bcbb1be368c0829fc1794b54b953954afe225c03009d3a8b0ab07bb4b78e49054281c180a6a6fc03640ebf95b873835763ea62f5483f2465c6d2a7b98253fea1107ba323094aec7d7282cdc171b44cf1e0f7b7a354ddec98a6af4584ef1b814be8d82f16af70c45dcdd4540d788572dc96018dec938abb4322570805513ee8268ea3990a173b4b19f4f17b168f34160bf0a9b9d837aabfc70dcbfeb184bbc610f09b0163f1228b5efe3beeff2d40dcee0db361aaac94e7e9961a8d72dff99cde9abcf638e7619a646672ac3e30e1954d43afd43ec46ed7f2f8993164b101a85a1727ecd36d4c54db095ec4e4e4ac562b8367df437ff0f5c9030fb1934d0f6ec24731f9422753c1c35ba7e0c3d4ed3ae8ad4082f1686c30a712acb1a5a668335e48e5fa500c340b008d70e60da06aa92fe44d3c37c1a16b14fd49c6008497463a7896d830db0608799d791074b2c29ba1ecc6c610985cb3955e6f885ad1b14e90c750e04106f81ee7725316d8e69b3c3d0ca0131561881e6d483832b7ed3b0d1483cbcf57ee6b9153ceb662259d5f5df57175e4e24f6aa1e34c35b0783bde9372ad630d35443b29ce20be983bf70679db207d89cb04fba7b3738c7424dd6de8128d2cc990a7aefa5a153b4b175a2f950bd8421073112511347c5725983980b9a7895481f627e8a9cd6d8fc2a714939d9c143ee2210653007117582c05c5d12dd2964db3115b8b4d55212a31662067df538fca7c5b7cdb6d06e5ba83023c8a08577a207da18e04c53482612b3536d36e674da9d3903d2a53906e207f6082673e9d3bb948c754169d0872e2e64468455cbf218fc3c3e98fea1cbedf94df8f5c1816c3acf173828d5110113f255899387fb03a855f722f4ade967513ce4b5e30c6cadac9757d1ceaba6fc0ffc13e42cb37ffb3d5e2367dc675c5e67d94fa19d636dfde05c5a4367579bc8e6d4efda866352dc6bc4f7178e6aafd918ea2a4584ead75e84d2cf9f2e8d4c261a94a468c8e956e106edc12286e96a7a16228a00b3381c07829a59acdb3ebfb6030a90b5f753aa59ccaf15ae3c4c311e767ed84ab09ebd09572984dc07384b83e472b3989b6ffad96c7a1bd44517698c18fe4e44fa6c522a5a42642912b4d6eac0c0158867ed1066d7bf05f6da806987a3e34a7a9b8cc60012e60df40fc286c6dc14a372d7408ce35ce3345d42803f0452d46f15e6dbfb83d2ce97898b6135a34ffd5ab80a83d5f1b7904ff4119139bacfe27543c1b26fd76ad354fb163ec659af8b190544c9d07eaa6db635830c6126cdc38d5e7511f716e6e05a8bcde2687cbaa770a8703ea525f2ce7bea033629a42442c86b03da42f1b2239e2bc37b88506987df450c535bc82f1e8002bbc7b24c1a642146524d299ec14143bc4308a48c1541c601b7560225925f6b8e86ed14812f1d22ca5729da9e5102736eee1e6e1aed8db364c26d58f8ed0b08556b1f4f24755f85c282e0d872c61b516dd7f4e5f902213f802f32105a6d42dda4c166bc8bb0c594d5aab966392502fb5d407b6416c50a39411d06524447c03fcfd710112e489cf69448563843fa22ed85c1fc8e4367ca5cdc475097762eae0147a6182c68eb85040c62c8f7cbf1b4f8da27d5d45f34ae134185217a893db17fb7244cf737e904bbcef8d76abf62dbe86a713e60bdaf2150b716b6fb5c5af566e4bd55facd2d262b6a652fe10ee78b70266b685c05011ca3ece6dc1ad818ecd200f521e44ae58ae6300292bf83b9ac60d4d1ee96f9e496ee474681ba3d74d03a1fe9570869c74ebeea0386cc7a9d134951dcddc6d6d85b3a94af3dc6996f8b3813185926a54b47f577bf1d0b79ec1df300ad8fa2973be71e1cb190211762ba759749be223e73e3f66b2ec5cda4f6367f03fbf63f3f8c5e1c61c11febf525961225a8ae535163a9c45a79e377d277fbfd900f001f22c32bff69eec98a8f98ff9048ae9ed08978d9fc69c516cae8b585d6df62798386d458805a02efe35e36cdca070fef17925d9a961dff40424ff9b69425e3041dad637e8df50cfad76aaebfb06149665329ea16caa0a428819c9472828ddf33931d3727f8d42319aa51b95855773cc92b540cafc91fea13435afc004af76a230da2907bed01cbe8ba54b328a027b06ef13327d5c4fef7e812d098ae70a13d941577bc95b06723fdaf2ac06d2eae653200251d808cab49cc007c1267d3cfe49915d562c95b865c91baa15d72b8d8e43936a39f4a763986d802fcd3f67b684d62abb6c1d5e0110dcac6c265338a0f3e6096206e721f08dad78041be874199fbd2bc38f4a690704ba55569ba79fe72300d633a05aa3ccac7439eb708129b0113ca1de2e4422278007bc111f34b0e7f33c589b75cf297024a1fa83b9f879c17bd828811b4951d08c94fb67fbd02e92311a57b3ce2a46f2f98ed14b41b99700802395399cfb256ed6d1498bcec6c287850470b2a39f49b65d1c638f8e0bcd9c68469b7108dcdb07c3f4ab97c54cb29802533bc5a2ba3009d404bacc1d9b29fc561a2451688465fc23b04edca5f5d0a523ba96d78a56385c4f45c15225bb6d308e2905a907d8d60d1e1a52b6703a9732bdb616e3ab9df7902b64f83fdd3c547c0051955a53632e0f3408be737b05425f755b86d9a316e364aaab522c2bf87c0d8890c9703dd7ce3853facd49ff1b9014632bbf6d35910f6bcf9b993949565ddd6a0eef951bd0ea014fdbbde40e6ac3f58ff967a297a38650b701c22f8cd811e37cba1f37f0f64d8c31f1390ec719b3ca6b36c4033568a91f822923a18597067918217c9bae229e2cf3af93048cc8df5c5d33f926b90083a3307c6ba4e621053dc213d0c2098445d169a76e9c569c5a5f85063da8748dad746a7f121d6a2053f66d469001bdc570b9f93192cc6ba35474bf7cb6cdb28ad203e297ed9d6ace16c993dc849822d01609cd3c777ed78e9861f8b112971d04efabd892e0f2d676bb67dce606f7c4a07b1034ae99e7e698bff5d3a1f6a2de8956f39228ffab3697f6c1a5594bedf429209cedcd9844dbc78254a6220875f4044ea62d20b78c214bdacb21bbb8648beb1a3ef4777b2de76c67fc200e938022778113a8ad6dbd4d91ec15f5b29308edc0dfefa481c829b5c1cbbc8e9010fa6915f2c5184f9297e9ed1bddcb78f9ddbd6480ae8a6b948b93f982ccdcec07eedd646ba64c15681511d7d95ea22d302642cfbda19cdc711f42cff93a07249d2f50e7d14077896550d9f87c83418abd5ef5416b78efa27f581b7978dae711206f8cf81801487f79caed98edaa7d672aed562780098bff2a153f4afc0d35e826e0acaabc39fbdb1e5f40d537a54bbc18dc08235a939b1b018432d629ead252a6cd7c830be1b39a6f1155e98d8ae529bf2a10cd7fa2ceedf40ee55c942b9281c8d97f80627c6506afd75b7baec38a0ded0bee80b740b1c5e00fc12b9a281909fe7d39cac48ff412856280c1e94e0b407be39c5b96e2ee642522b8f7933e677c9a4d3b2cb8b8833bd792ed3f78ddf0ef84d7ff9d814d13f8f0bda3ab81db34d80837ecd5ad0d36ffd101b942fc0e6d78c2016e50bff07549e63626da6b0cea3871202953ca99524994831e30a878fa5eba182938ca1720541633e8a6c345d8b43aa79d896321d2ba52b8857d6b3baaed70c1a5a0d1c2535799b8ef18471222b27a029ca444dc8f6bf69b58a465341626376d46c8f1b04d68c921e375ba2be4fc3472088cbce42d060cc1a4a85ccb3d23c5e3316ee20e4ed0966a11082295c018017d140340784b2cb5922ae5c523e2a9517abd955d68cc92a88570cdae6044575e7a4bd02d4713db4327ba4af07ed56f46d926b234e4663435ba19f0b615b542578a349c67677b869e17740f3a6ce4b5f9ad586c510f525ba38b07e3169c9b4fd3a7132ca51a9256704b169a0eb30f8a951f3ea9894eaae89179a49bf2a1cec3ca998d367b46b6625d3502eb266466ea563a82b8dae1c692f4425e80d3882057611e66e071f44ce2d04e2de3325133494a80304681d6e8ebfa00c09f4e67b30c9716aec6e02769e84a7ad8ed55af6355165771c9a2d61444ee219ce0579b303af3ed779ca233a8f2705751f739d1508bcd548cd2612695a6ff1f0f04c4a6b609ac933a9c1d04ca11a3fadba2c700e5088952ae84885c0e495660c4387749cd702bdfb44096b5a364a4171636d38c1a0f92272cdd6a071486a3e384e438820005734eec9ca90a9613c4328670cbd262dc429cbef162d3e72d79937d003d2240a25d6e5499959e2c6b1b9741bd55b45e7a9c316746e64853f0489d805fe05603be559dd686773fa235c2e30f76c58abff7218a53636dbe8d9886b3ed80beeee55113f12926990de40c5b0be9763175164b687f75a96708b88be3dd96a3012d16960606d452a763bdcdb1ddd5404215e4595f63babaf0f494b5f218f6e8075006da8d3a6b6715edb6edd06bf4f1689fe1ab8f694f0688d370a55dd25b3f02908ca5450b4c4d848262546e4e8cca869384323a97aff0cfd32ad641aa9bf26691504bfc7e80b3e77226c2daa79ec7de7a70005dcf8f5c9bf37c1f3212d49b0920bc99c5355c9d1d6e66907b295d8b542bbf3b41e5c6c88ed5274b8506b615cae5289bc271489ac53477387d61a40cd6fe4174d747f4a12b4e6680c91c95f1d01e5eab53e4efb98f0b7763b715924822cec17e1b9b3e79886c20663e12ef238419f6d63bbb152fcd458f152e6bc981473b42977d05956ecc66af1e8be4c29aaf6498a6fac813805ebe9a591af862e544b6efb48d4c3021b8ec9582ac6cf55ee42c85c3e9272aab9fda86782c3db1ae099f40b2b202615e88f77f64b8c15360bd4fc0a6b0d6b755401854694ddd30f226c9ab166258703f246106892c6294323fa9cf4a93fe8c003cf19573501f80d17e360c9d373d91c4c83e17cf62ddaed1988caa084b46f49e0aba29276e5e3091c2f50da99e60019d467b6ab208fb19b77a1b97f7755a09cdfd52256f60ad6bedbbccff308b855b1d633015c87d3d6fbc432970945b802ce89bf66b388aa00760f0f10c4e287079b37e92e221afe896deb286af554d532eb004daefd2df1dd4122f831a582c2773b09bbc2eaaeb34d2e785065b1e637700921034cd073bd1a40cd2b4a1f208bf8598855d82221f8d38d191f0ac48286e5b4022cfcddf0b87da38c2e56063f3e55728392ef2568a33e9eb8e601b0493e199386c2516d09f11ac26f26300d416006f4f905d8d116a69b465a455f745889b46eb54b56011309b75d5f13ee4b974d637a71a88e95c2707a4f072506f43f8f1f5ecd3d544aaa2db230e9a8f3b612f0be760539e018fa45b16b705dce0f43945787c8fe0e0d1f0e1cdf2e80b00d158d76d8413ffe0ca7391ff1edaf5ce290231230cb771254c5fe16bcb309ff988822a18c60419c2086059bbb22dc71c2cbf95c8779760b02822c22d1f6186bc099969629b0df861652566282cc8d6f81663373c744e5f8460c4f0375265b1dddc1315120e57a3b7a70dc9e7dab7f5bbc80baf1ec782d2522e7ae97b07bf6c56f45afceb0c8533fb4d382669a336c19e56a86ca8a40c0bd5e46b13c7a345deaf926a4c64075e220a10475560bcec4bc8f8512a6dd0c747425b1dee18db7b1ad9e13d095de7a62b77d00fc1d69f06252ab4b5397ad5b18e4689620db8d961e720eef390f2969e3d5affaf874d76ef2190595c88678b62a5605c80f8affb139408a9d2727e4759d7f5aa0104b940f58c4f2c40c2d48f365868582981d6e6c907e1c4af06e3b99a5787ef47b287b64bad317fb7fb34e3bca32ca5aebdf53eef494a851fe57db58d0e55f42d64caca2dde2a8887a89cc46673f2d36747a1114e0c8d88d3d5cc68b4285fa6018d84e42ae35a123e65fe6fd2a2fa8d040ed7519a6cfcac3b29e2184e655fa4bbeed8d4b474dfb586468a4fbdaf34785b8ab2e6d2541f4bbbfeab0f58ea5056a9ddbc64cb49f45dd24a2a82b6538f065c1b1f06a993ced54e689868546b3eb2e0eb4fd6126707bb0377437279a037491a6d3471f4d794405769af4823f272855674297cc237c28ac9ce2415b209cbdbb56cecc77ee121643528085c2b9c48ca6a2a28b0d7a40b484a05e49e87a6bd9858b385fcd76f5abdb36872d4fdf54acdadbf20bf51cdf42aa669a5f063fc0926be51e0033d87c0f096e55b24f0b65961ed74611a0b6614bf1f5f340b49685cf113f6ada5cb060fc3d49672e8e88cb304b628fe3a7d71bfcfc58041878c45785a07da19a7b841eb1e902630018a5e1f4c023d76abc209e5d9843d2fb8ca516de94e5ef42a728b67ff7e16c92342b68d3212226d4fefbd17680a5ecfb34ff722dfda1846393c31cd22e25571cf60029e65c361cc07935c39714b41d8ac9d29c3bb0edd902c93407952aaa8d1c45cebbfe0d5ebf461856da4dce24b914b889e571832a025dd8edb63c8f132883820d30384aee21dbb6cd5753a01f190ef18a919a939f33af3956becca9cdc84bfe1d19a8056ec43d89a44f0abbe0b08955983e76230ba6a246b4ab13dd8fc39218888c7ba19ebed07dd4390cef577130904612e8d35966cfe8fad29a93c97bf9286837bf4cee5fb9bf79d491ce2195719c59755d24ffd1efd2dd440966820f7c938e2ec8ba35fc482c3b66cae6ccea46ae3bc9e9627ba5bea0b44ab43b8eac6e97b9cb5c96bb86c9b834dfdee3c43c9a8b2cc1a78353c45bf76b0025ea1cb04b0034b2ea53f8a2250b03c659025d8843db43028386836e5c8f4a7be82c3e3431122ebb745bc8c6a022591f3578f0db1acae86123da6a45df4d20d27c226533414319de33ee95dd66d1ffac7691215f29bdfef6b61eab3cb5365b64ca0828e6f0bd175bd05defdf16c85c9fc90b6af6cc2d93f190725376e63b37b343953af2c3bc71cc0b1fd5a5948ac8b29d8da830b83cad7c7b34d6e1425ce0923aebaa72af4925c27a6a96d8bdf8830bb67b1b8bc71c462c8875526c04b686c405318098bb865d22cbc74266cfbdccd95da30e9a8c24a6da61966495fe34e33a407530816a374763da8e88b6b7f1243872080d6d3c84e57ff0c9303b27c224151cab06818574cfd7ae6039bce059def948a6f3f5f8c29c3100915a50585b3e093c30a76cfbeb8a7b0c3395c75f76bfa6758a5c895001cbd5ef5500ec0e8fbb8250ec6b0e5f3c07d3375190134d988383a60b033b62ccdea6ad1592ed9d353199c5124aa1954f96a7e182c1a603e03e6d51e0577c625d8fa5e3c0890d2f5e89de5f814150f15bead66d9a8153b185475140fa2d57608d1a658022ab4caa6ccee6f8ee98769934d1efe096d8906e469bb38cd151e1ae99cade905753b406f1cdc5a0ff0de838c105e59fa19ca7427d5b1d9f02bddb09748ae334f0441feec841bcaeb4b63c92e3683dbfcf183e151d1d31053b59a4417dde77786775734edbceb60d64a9d220f3f094ed3c082876cac087c6743095199dd34143a5966100cd9e4cb770d738e507cd5dd8b07902a54f0733c080d407cd580ed353c7cbc730e29261bf6bf8f5f7c61fa09fa8c368b84621f1296abf6ae483c73a9f1a79e1654b31a72e510faa7f9b289f9d9468535f568df0879050cb86e3ad9a151e3af598215be0bd9070094e3f78d5713f18e8d8359a9e575df36534ff42477a4c4b6c8a147d5f219d0c05c8a47d7802aa575dc442fc1751f17e31e4a252de2157013fbc223584f1ed9fb3d8aba9f0ed7dd47ffe6df1a7c60e67d79df5882fc310e654fa63e452311638a9c8d9d3334f196906a06d6fc31c74e9a16eeb6f873354f00f953573641fecc44b7fca12da0e9128e361ab4c8b975f524b243aaa06c0cafb1815af9d4dcf6ad9adab1f84785d9edc8c614f13a123c0df818b6febfef761a27660e978fb3e426e09f37d22fa47fb08d2755908d95e81a945a450c9014679a725721d1f7c7e35ff34dec1b899bd22d81e781ddb41ba9ef15f50610beb3d081fe1be3eb7e30dd83845adb8fcc31ecd60e2c34df01f353a19fac317e7d269769c25a1f982ead69190616fde3430c481d1f904e090aa92904f052a03db0ec7c4bfc9621d5059e2d3abced5201a30c0dd8814494add085c54dc04c5e5aebb793aad85ef3ee87a38ed6d00c9cac547bf23e4a859e54477f6779f584875f78b4fcf4ee70d249bf1db32d9ab5e66bc81bd49bf9ba185d14356acf4989768eded440a627a138c1c2e3a985b15041aa70c0e3d3c45946873ef8a8dab1a9c4ed97a539a886cd62959cc662541fe24c6ff159a2336684b774c441fba4a8ad9285ea94add2baddc6d34aad673cc6af20555c8499fe345d08a179bc8c31faa77ac3e8d948a1e9dca982350638c6da539f62224c5e09c1cb18cc24d3ba235ed3282f0b4d16971c727b9c564571d4448283449a7992e7c481699478103fb95b72c19095a14444c147c4492bb5c4c85de3b7076e21a0fe4fe44d10673b603af5749aba299d363dd0ce4ed05d5777a77f901f5e9ee118e77025679f5df322cbbd5a3c2f8135540a2784279e13f1969af4a1ce25aec1634b644a7648203295253927ee6b23158b2a459857448fda91d1c33ff972da51ee8e9a6207987851cf7fce6c71b1de6e7ef56e388edbdfe09f6f02e15dfcca50da7f80a481bc10c1d9d35917d9cdec30ab697fbee4661251bc9e1f11a0715bf070c095adc6a8be07f356915b9e80ed3bdd532919045331290132a833ed22da37ab6af66a03e5e38eed2a40af9c978e23e058567d3f60b9a7563f778ad232260d442c69e5334d5b4657cf67a3984307af1e83bf741cb7206d7fa707bf18d71f26eba7b664fc3cf745869232b5c04349c5ffcc4bc67c50e0c5986d783a85a40a3025ba6948d011f4ff8bc2a80fb62f07531c086aa3f4062b30badd4661adfa1b5443263a14b2196a8d783d29b7c897f6c5252fb22b614f3090f0d7e828f23d0109b2e934ee1b08a3909f4d5114ebb498c788a7e40055e9b35d99355bbdde3fab7eee0dba534f7eccfdfdae8f862641cb59269718cd5fe6457ab275a9746249462390518a4d3707619c226084de36f6735cdeb3bb6923fda1296d357a7c1ab9da8695766d1ae307e02cc5bcb4a91d28c1fd0e231d822cf3cf6b67774358679357734eb5ffb329b7437fa6dab905197537a2bf6239b08b8f7105b5033ae5e1bfc8b547aecbc72640e0359c7c011096db9f2b920e2f4e9592c2326f2259a177c824bcc58aab5c4bf2ad6a1284539f0c986c3dfea151be103ccbb09edc5923c3f435ed3d046a14d407b97af7ef91cf353d55120a85aed71deba49569e84f11b0b712db7befe75229fece67865213ac0caa56f205ca6b6f9af64519c50e4d5040734994ba0770ffe41d31e5348b7ca0ee1a6a3530dc69ee3d220bb14daa862c2e3142ece83a846cdf261d978eaf2dd9dc6ecd07","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
