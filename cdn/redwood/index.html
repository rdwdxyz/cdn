<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f10e967902c6c7721bebee5301c7c0e801a31a60322eb070e8e5e4c6818d909ce734477ffca2993d8a7b161ffb68f3705bbd0028bf22a3a763fd5a00945792af001ff0feabe76dd21dd509cfee04fb3dda70e7b5ab9a85854f64e7d128ec9ab2d4075c5593622362fde21e8b5fcb158a430b153b1f9a9ffa0c8de12331205b53191bf86c7b827a4d8febc0eef4c507dab8ed41eb44c63f04b5562f183c7bf954672366155f9d3d4022846f385f6ba2654d7a889399ca1a1ef1d282a3303c8da6e78b04ac241b8a5ccc3ed1d5c9a543cd2bc4baa6f9c3925ad9920a41cd75566bf03b82aff42f9445fcda117b6a6aee84d220fbd57b55b972e896f8510ad91d880734c8fad6227b73f9a239ee402a31a816ec54fec8397007e5c2c8002906862cb2f96db965a0a59e3a5e84557488fff173249ea5ac144bf68173f0c1136450e50cd7f5560e9ee7b301bd5215cbfcb778dbbd30496fe9d97712f62d8613e62b45113509bfd72cc539f713b88f6cda959d93a8cc641d43326f72b7ba2b3cfe5729e94f16e3bf1353a3a009c2779cc42fde99324f2fa2ffb2118c34a9e83a27e6dcf4b4982de711f7c6b138ff05068dec4f5172d2a8d09ab041762a9c766f4d939fb7625183f47b653d07a9fad7696f44030a34729e48ad711d45adb0461ef679162a6cf9c94ffabfe2bb3a4df6e70f83317e7aff0a29dbcae796bd0a97858564317a3c40f11063352956cacc097e4b7dcd2d8905ceaad2f149b3740a542c528283e6eb4c08cdf3e688d3c9092c393338e24ccaa63e2e472c34ba382fa1183de834152517289c013eb27243fa68a996b54a9d35f63f1c45173de8cb87572757828759ba3e0172aaced9ea551e243bbe246757529cf8997497e10682382b022165f0db8ba17cd89dfcb44c4bef5df30c6cdb9446862e590a81ca2a222e47f00eb0db36e3ec1b8cb2063d1621e032fb20058e15e0572c5682d99e740164d233dcdc0552bbc1f52d4423e97cc41255a1372c4b8e6e6c988f3d49d0ce4078f1e0851402b7c7620049ee8310ddf0a24aa4ee5182d926bf4332ecbf3be84edb3e0b38fa14ff450bdcb87e43075d0de117cc72ca3fde9188970238e1003ff5a55a075ac3d4130240dac5c4bcd68df5cfdef87757b1baf8bf1384d94b7d607d2f2ae6ebdc205667f6e19f4ade6c0940d9bf349447f8973d34d565378bca0082cd9d5aaf5737dd5be3d07d552568835bd22e6ce83904b705998a526cc1bbb2f066ea16b4f84b0c79154d423795eb8a50d1c864bd8c183c7885719719fa26078d7d78ec0fb46f727ba24557469925ac89a36be169bbdebb0df8badcdc6273070702d42997dd403254df0131dcd607a20ab721eb9052edbe51c41efe8faad222e70aa6628a4581bf284a8837c0696a9642efa1309b004e445751a1efa0623b7ac4974f85f28e486d4078905e0fb859495312825b46ad8b85ba36e629646f9f5f6469419ba1582f9a7ced3bcfec7d5ff40d2acfbbce67ffcc565ae98db37904a2be2f9725e78a7c1981d485b43c8a17d5cb3df7d03b802d1154093aef17b5c479e133f1e66d74d962b89c2fca8272a97ad534ded1789168ee10bb3d2b19be1d7af04a8509e57fadffdd1f42bff67e139b7c5e84483c4b32dd6b45c05c6d3809149052351ac3b85395ab47fda558bc2b96804df937d96fb889a452b78920ef0b979cd56c18851fd540a2b81ec7546210fa308b023854e2efc4a0c86e8559191d683109f84432c06455cbfd080886bb4d64568b41968fc2547d660cb37b4c07900231d0bc508e6eb3ef4e05f99321ed63f00c5fbdd89596c56a8c938181f56e2c8f5b953ce1631eb6c1819b3688e500e54f84907c978e486bd0cce4a10ce0b241df448a005de97f1bf05e642b05b0ac2b560c85b3e46df3d218f299f4843089b03fc661229fa25cdc58c048ca7925daf3fdaae8bbfbb34167dec1493b0bce4301d04bbb9984f50f2a5bba0d613c2ff40284293a8b7f11b631ba61cb5348f0b21afce51ac7a96edf292584f54ceded2bb563699b2370e97867afda22141c93ee38a2b19cea5485c3aefdd5299ece3d68ef7755d40be41e7ac9a1c33bb96d7a3d3b9edc5732dcf8cf14b2b128e90bfa42ae981e23cd29d9065e34b9d712bbce33d174b0a38f910f4e6155a4f9e050b8bee1e5e6b0046b7047655e3ec682dd19f9c4c1de742e3c70ccf588b6c0bc196192614ba2bf11a3632c3c4380b2a5539e35a2d5222f2edd70f835e08296b6115c99cf1143e4dce718103b23cf875806dae5ebd08cd59bff3237a39e1bcc058394b4c59d1c1fbb228963c70dc12f1ab277293b6887db76273cdefe29612e629f686b105a10a01a8937284b971afef9148474fef3f4d1ad4cf3d9397bf1d6a26ab1d0514a914fcacfb141df89c3c2cd74ad4436101143a4400d354caccd2f34c085c78edc4857611de11b85e32f6031eb077cbde8ba36bf8c0aebf49cda5960245decd73638304e50a6e2c3705479df3da6e0402a1a86d2761659cc907077debe2717c00f5156f15c3b82c5c14e7f5a9ec2187ae90c2ab27ce2de0ebd516a13638426a449f50c1cc9345b1dd541693bf15bd7930fd664637fa28286f380ee75e718571c4c0fac73857558d0f73cff8a09f109cff8da27bdbf6876e75b932187b0cc6394d8797862e52e71ac5ceb74615aeb8f6b367d800e5c0b84f8c5538afd7a5c36114da086f086f9e5e756141435fb49cc73f6965747ec42898883d71854e1530ed5ea9cf47ccc8da1178d6ba61da8121735f98151f8d67f0eb005c2e2b2683d251d7a6de741c602a2c5590eebeab11269ce0d753a250c1de50d4c9924b36199c56c3c68c2f7f7679e8f361421a826169ce71d446864ffd30b16bf892c3d662569a13ef8de984eac367ea29b01b0f9a0ca50a77df1cb24beedd9b698215a56552026e84db5be0c4113436823e8bb739818610fa3f563427ccc67b97ebe582e6137088152cca2acb28f1bf3e2d5aeae3e2cea6ea0551f47a9a14e64261db191db4db64f82ef90cec91baccfeffeb6c036810009ae14b187c9d7e064de1eeccfd0cf5aa9535f18101cd905eaf77d57ad7abb1594abdca343e3b502758b42ab5cc5005c5082badc7a1ae87adea9c19ebcf440d7c9a434462d0db7f058202e2d67e2482965d00db0f4fc3066ece25f6939e4e27ce57683d9e556e8675571fa8295d5c9bff10d376e70af4623fa7b89980f9dc5efe446890f851da0b6faf00d7eda124aa2baa095158f234b4aa323368e41b5f9bd0903f3500d9a0290b208f2e99df574e2d4cfe35aa567bf9eae5f4cce9850c9790597cd78b6b627b844cc73aded1c695454f9220451cf5d0d0364228d8f741ad3fa1aef4566f035fcd815e4bdc5435827813791dec0dc14bff77dc2304ab59f29ff4d6bbd54c846a7099c98ea0ca7ae48cf96955e3e03eaef440402e612da1970c6cf99e842a2796d8b0a01d7f561c0520d7794c9be994e28fd3e413a8dacfd82619bc26ba7174136468054a1ff7a6d4a3416453b89f9e3b3fc8a4412700dc9a5fe6988d59b07d897ae7b53ee20f02a084fe7cf792531b93348b08bebc697fe7e680a168cdb8cd14c6dd58a67d794db8d7c9275b1071391c957c07a94fe870ccd3b36b94ad82cd19b33514b12c30796c705e42ca14b9e36cf83744e7a8f6210df652802b24289757bdea74811149391f1ca6f300f84d31b96723dfd44abf18d6e460cfa4dcd56f55e80183eb6ad141daa8af52ea11c8fe54a025eaf93f8491337bfb086bd25b8d6298924dad27be11d300f24559837bddba93f8ed71a9a08095d7fd7d85742bf89cca80f6a07ae479eee831cb56e0ffad1a5c8858f37f13341faf2e9f6b050ddb0485c4d4ea0c1ec246659bbf1ffc5aefcca8206cd9487aca806fc49d142b9b7863d0be5f6c140f7c89b76ab58eed4e57da091e256d9b9af384246122c6999c274670864a358fc142a80a40e6de717b49bd3b23a4818e517f628367fb96c1e26eaf9affced8ddf9c844d4f6a210da7c03d1ceff0f2471d6d0e32375197a084f838ff80cdf5d6cfb6eed9ee0233d99f0e23e0f9de1a787eb2cb50c8faa6cd8a352919dd51d10044ac72164ecbc898e156fdf0774949d68ae25ae81b52f797e0195cfddc732821671bb1ecc186cc05b86e03b737c3de6430a25b0a2e296fa90ac4980c8a28f17cb3debde44a6c125e4ee38eaa0593292d39eb4ad3534708edbafd3b97b63ab0806e58212a4452e09060c2595b368f0d7026d42ba0071c3fee5080a1d93320b90e1a1236faa0907761ea4c06c979bdd71dc8e0d84ab0eb0728fd2eeaf36f3a6fe7490d4e9e4f67de4080a4e5c721bcdca3433be9327406e004f0b987683f6db935b682a2ee4df040267b0de85d5035170c02a5cb9ffdb53390c72361813f2fd893448297d0a12d446b3b9a71d61659d9c43ccf5c36033cf2f0e0b8508d8e86dd5898bbf293dc8b54fe6b3787d48931816e0c4e27e4386eb30167adfbf7ccd6e7f857b9222ec73c639970b07113b39cf71ca9aa6aef437df5182567ccb746755dbce614431a80daee0fbaf2a439ca34974c43137355694f796105c54921884edb0e1888a6813b7e1510c674d2bb4a6afee1e9af47cccc7452375a18a6f04c1929c0cca365bf172bfe15fd423aec9238c2c81616b4025059c50a596cc24f3cc3618d89b62858dafcd58d567dfc26cd884634e1f840ed38a61a6beeacda34da76182131f6b99c973442c035f1e6add8670ae3a8db4ddc4d80b579f3b7c40a55da11607554a8281fc270da570cb2276560efaeb3add4fabe811cde875368c090dbcf05a332784a16a0b2aaa9c8bdbb7d2722e312ba8c9654d2c36f2af425467caae4f32297ad003bd68fb427651a148c97c475fdc56558ff96f45469519bd326443cd09c9eeb2552fab425edd9523b29cf6eb54db859fc9bd8c7893a8645d70af6a41244d496ab7fe9fa4ed5df02524a2acce2551f72cc0333dda70fcab5daf4a03fe88acb25b92e1bf5d8044ae771f41cbee3cda8313afda885b37fc303feb0f1af56f5e221c6f94a0cf674718f9a3c58aead6c3d56073a7f69b5ceeee61c3fa6e48760b59c59596a5094d4838beb9d95afb6a1ad82ac2e321f884634bb3d92014e79f0dc7f737509ba6ba65e96794666ab0163621ce3e996c480cb9dce90e302b81df82f461713f1c1a6ffe79df534211d23c0482a5b15b6e4a01532b8c3636c54a150fe5e6a2d185dbcf95b0e31739860d765edc20ef51258089d2b198b5a13ee48a2439517ff4cdd842c2e798925161aeac32ecce9f391b26c882f2ecf428c8ddca25c22569bd70b4deb59458b1d57f8e4500c3bafccb12f71e198b897f18e07957d79bc45878fe310c29326636d96b758211dd645f7a47b0e88a5ade30768713e985005564a1e5c6e9670c33145b36cfd1cc41b1b252ae7d9831d515e9326079e07d2500564cdc2eafe901a7ac89d165acddccfbb2b1d2ebc1777039e77236ee337d8c04137854f7355770f1c56fbac0c030008c3138a5c44627203a6f06a315b6ecdc56585accb4a98f4b29a4cf7c33585b53f2cfed6e0212809124714412aad5e06f4121f616c7dde6b50dab563c0b9b9db715379dcf7dd8b7871816822965dc44e760e9eaf8e2a39f8bf877fa0f3da747163057eab0cb01deefb83a2ffd8865fa00e2c7ef3d49e45258774382b0940c8bbb0ca97814398ba3761bc874db6dc3da92b58cdecbeb83f7b8dd01be277cfe7e0ac21e782e6ac9834ca7fae09ae4401afd7636679614138aa350303c24abf88b9b1f8bb517df92adb923bc634b386ef936eae9e181253df67737710e6f766d4f8fdba767f422188d2648e6153f5d3a969448db26d035699636710bc1dd9b11f59a561660af930884aa9529bc612e7b03e250e4c0c4d4ea600deee4d1f69687f7a2f1c96ccd05a181c3a162424f21cb6275ee5e459d6a31661c58a22c62c2e67f1df29218d7c8547b3915c7981791277991abd9fc785687f69b6d0d453e023c0d0b6252cc59e14bf5505e83dce98b6ddcdd149a2b84a9eccb9ab099615f3d3cfa103b71e23a5921e9a58ce514aa261658a577d4c0de3222c81c8f032ad0335ccc9c94f5816020447e23e39e3767c42db935df3f94d7f59853a31800a9c179642c61e1ac822690bd2f25265374ba312642045ad04ee46cfc863e1e282f3d2b136eeee00d6043080900df75ac90e877f97ffafa31d13bdd9642faafb076ba8679a02033b643fdfa523cdc8a5ea7a0270af09c2d6b7c404b90940c2524b88f3c5059bf9ca87e05df7c0b6b141f1f1749414e150da476b6d457f377b17d278fb2205f54a24a6f73f25db1eb22917345b955f7dda87419c8eb3b59ec43c16cb8a1a1d3e604abe571a4df5129613eaa75d17ba1d0ae1145a7fb1689e6121c88b714eff629b6290d8a6d573b6b33937888b2f6d14f1ff3614b81b02b6fd67b999a0c90a23821a70ce7dc82f5a252b01660108bdee961e3ac3974db9806d6ed8000b93174ee987881702a253e9aa9f4eb8f87b2c25a8354f13313cdbb6f81090064fc137cfb123d069649f30dacf4fa6629e911ce8491d6147484ba20baa1d75f0b326e3b83ac924b6307448817cff5a3d7d79eed046aa21e76cd7c3eead4c0bfebafc9c8a69f631789819418bdadf4c1c27b5af7737a890c6cb93cafbceaf5e4f229dab8055e9afd5765387231a34a45403b79b07627087f98690a98ec3c923823376c1404a68af9d3da356cdf1053b05d29090530b957f642100eba6991d792f61f951f3f025e84deb5da56dad1da775e6f86bebb8888dfc9980f74f33a26e5b6492c76771ccbc759a4837d0e7245fa657c104bed2cd3e9a065febd59b99d6239f22a46f29fbde4aff58d6b0e74c1d863c372a63d4e25b42ceb7c6bf30fa6c73208c82f3badd8a4b8517471031646b84e37dccb6d8d8b5bb650a621dc7e1117976a5404dff4e8e0593e29311d9a99d7d5a7b1eadb6168ba3b82fad1a5380c1624fba8f84424aa798867bf4f1f7bdc27bc90b15e7864e441851963373133eff712a50107dc25330934a6c24ef6cc28dac4200f67a3bfe8250cb7465fc2ca9b47434eca9723329a42603437d83c7595a27ae91bd9995d142930c9f66e81a85917f8c921b1a83ca42709ba6334630869d2a3fabe30875f1c80f9026e68841119f056f6cac0629ca446856e753ff2d08003957d4ee24ae48f6f6a6b7d54274a2e0158624049a9cc46fc9f780bf261849f9a07a0a00973480e99df99a6b93268e94e00ac77b29aa1b0c4221ddc3beae480c3f209d77abd93f7daf106720145bf19addb13abb2b46db1de5e6639283513f52b6f04cb6fbdecce42ca68197f7fd3745192c00df066259f640c1b201727f495b81fedaf5c10b4b2d71e1ae5e49fb58255108ff9a868816a43ac96b2c66ad449d9389d0a321f95c3d3f1b6e60a25c7f4d6411d333a348599d0ce97e669a8f2a57a11d5140cc488cdfefb399e9bb757ee83ffb6cb1b37ace00b65b9044fbd1bb4d06945c0910220f8a9e12ce2947ca9c380d85f44cda5f31e31ce6ad08ad4714cc3d6bc53dfc7c0e38be1773ffb6240f06b8d126e4044af49e3ab61e2ff74730a124468df4793465d939557832ee91f151f63680563d0be664e180b95644bbb283ab4902e8e72d8a5bca62448b5f01ad73b0f3d3c042a4d686a56a22b64607c98155df26eddd41af986a707710cd006987a01dccd9fb55656b4b9ffddb7165073692d9c8cb77d7ca59f477fdca9c762616dc697aa04c033883ea374aceb32e8a14724740bb4cb68a7bc34436876075fbd397d471ed52e61be11949bdf9e4864d22022d82564b64fdf48f1926becdd8b0595e47741c098a2ba2a9c6353059914946b847645ddc52c6581d27dff738c1eab38c8cdc3ac49de9fa59d6a8a3e4057dbe4d16b7b172fa6957fe5c289358af076c180240679f623660b5d94b6caa68cc6b167d8eba30031ca8cb05b86f0228a38852ebab58957e43bb8e92023c5bf7facbb9995b17a128cb39c402b980850f433db47e1df798ad089152c1abd23a6d3dd681b141ea119147ccdc39cc6e4dab7b8b3289a0e82b9534a145663905e7608b4e890dd4bc435a0a3929ddc60bb87228671789e8f3209203975c3281e02b0db1da9da1dafa289ec90ecba3ab17a402b2f06eda5270d3fd2adca49097e10c7e61dc09859bc55253e43173dc591bb86a0f5b404f3ee112e10daff3dba3acc38459537a9a90c49d6db06f5ac4bd626ad447d4ed0aac1eedc3c8e3f9c244e8e8cbc4e37f5312712c52d9116892279916dcf5293f14d5b704e21e3dbfc868df5a480514e09055eed839a571bfa081a6b5a06ab577f1c2cf3dded9f910f02236fd64e149e081b974ea38c35a0471f7a8feac99c79ee63ec975776f542f87ef14e8b6757a6c89ceee3b131cc27717fa39275c0b1be9124f03ec4333406a0dfddd66842755093b395b20eec66c492ab0b1cd04a06e9c0536414809d8cd5ad279c0f8d2c9d0f8e060bc3becbe759d80475053a4ef39c0a36621746fbf044744ffc01ae85a0d3f1ad954fbdfd3efc13b8ae484f4a72fa5bed21feb45708c02cd1e6dc21f44774ecae263ad8f4236f5642606abd7c9e534d5dd35c4d7ce052377d69a1bdf1660bf7a35de35848bd8c2ac051a0e805c19eaece61d214346bec3700a8e305570f51ad08a35171d04b2419a4e104e4b186fbb70eddd4c83f7a97fd88a44adf1154898a5563d872113cca0a305311397a4c0f44fd5210d4f41de369d3908a90a146aaf485aeff7349063fa60e4d447e1faa21bfe01fee0a58008cb241e176a3093d66062ad2abf8a243c4eea9c86f0edf896a66203ff68b57a70b74c781062e2b028c001edbf8fee751f9c5ab008b0894b337a6a8c66dc562c7c6be73d85f8681ba294e173e7ed0cc68c70aa35a9a027cd9fc6501ea0a37c2f170ef27648397bdd5fbc1bd1d01048d886ffeb5451975cd1663ee4fd81a856bba553da90a3fc0e0198d07eeee894feaf4162b541eef0f219f2064f62f607221d2017e60931d4d52c9979df5b3df73335c08c87321ce8919ce7d3b138032ca39b3775d17ab3436066d1f47359f4ae751ba454581ddbf4246ef2675a2b6896dca922085bd07c1398d571a7e6dc0e885ac69342217bfff7f21da82098c5747e58fe896bf20eaa573500fcf9e2629bf38daa0d9d7ede1b90b591915faa8d0076ca8a2559c117991851efcdac621a2cc09df99ffba82451b681a464c79424babfc9d7142e37268f5b8098b097622df6199f44904916272b99c5c8d7907604d449809f66574c53eeb560b790a4c3ba00ac58eceb0fc8a672397539e52104e97c1b50559abaeb5ca7a4c884975fbaf314326241845f4c77e6b6868227463692b6e251a93760d7e379a5662730faae7ec47841ca571d2e3167ae94a96b510e366adbabb8db2cfbe92903dcd8984506aed26978e75083425cde3e1492d119289879a92af8c686f33d64f4f61a61e3d5fefe3edbb6a0d35d96bbb867e0f371b60c29bf38013b943cb04bc492e70fe74f70c79d5044ab06fba0c56788c52d09875575de51b0890fc00ddf3df048255d515c7d49af8a61cc1a5e1958688b796d525f6fa95661b85317ae5737e1a6943c9f69cae2d4e8d33b4454bb8aac210bf27b922090f39a01e43619998a50647f99d58a84f0f37cf02f2a34679b19edbd18cfa797bda0e94980490018d4a9d7f75b102b4975575b6549d6918f80b1831b3a71095b1b176beb91bbc681f4cb0bda33fb5d5f57e2784e9d3ebc613efba0abd2290a83153346d442a1e3cae1404bca4e77cd1c54151dd58001a972eff8a6d0fdc324b90830362e7f4545029f05112309a6c7240dfa87ff64fb901ddf9b6e872c338f220f8481f2156f87f69d5ff08714ca4b095e482740bf4c6c9fc1403dbbc07adc1767102cca21ba07d192ca9f9481a5a5b8df5ad73a4ea26286d70e3e4d3860f45af60ceaa833dbd456f3bb1cdd5cd74a8456afe7bb0c96dc885dbd3b954c1703fdc790f1e09eabb5593c977390b83fe8577d9c7a331499407508b564f907894b555cbac169efb4e4afea2274a665b946d92911e42f8340d2c60ad221fa4fe07cbd88b78bdcaec1be17fb1b0edcf27a2ea4d6d71208f73f024d64a60e9151c6633cc4bbd0287130728aafd67caf1aaf26eb10f0c50cb193dd092a0b6ef9db0aab165426d53ddb39f4c770c8226c162f11e7c931ede75226abcc19b0960768a4447af47258a320586d0d6ac72c25e9e15645d08d2ae416482aaf96905a90470898e19d5bc82c240f667cf97f85a5ade9156c86f2aa6e21ccc44c11468d00048f66b72345f71413f87e276e0e102e495eb05acfecbb77ab4960db3d68495b1ccbd94d3e1c5a99db86e1aa15aad33d94f90c59a3046869052dde8298f9c777d5762b1b71b22c6015118148320a9a22c498ab29f091851001e6e775a6c5314b95582c2982788f4bb11cfbda51140fa95b3fe48501aa789c3213579c08a842972f1311d88371386f57d133e9c077d4003b4e004f57f0f8bec84323f5d82fc34f8e1dddf052732ab4c3b9d628bf17d3b0137bcd3297e351e16beb5807788ab5ebb7d59159a4748d173961c5375c6ad89cb7577d55ec1eeffe2aa57c4db7738684ce6c2e30eb6a3e1770877b6cd75fd99bca09d5549ae38bb01abefbff0b1ff3c0caecf407ee8aee69c88fedd12d1e87b992a2003ef162d2a8080c7b8f7204612dbe43d241bcfbf8d9d14430f437d3348d796f67c4b7efd9f2c61234e686ccf4b62337efe603d96e2e8dcfd98629346102851edc5aeaca7c26c860a31eca72cb155c74e9759d4e8b06ae5b6e5a51eba58c5d67d85cb2712002a78a4e0a2606765628ea7e871c16f2df1bb3b6ede29b8068876b07259e107e574ef92c2984c22c83e22d6255c899993a6e0bb04c603a97d9918ae7fe9ead10993e6bb9fcceb714dba8763e618360084f23449a315f03b644de6dc70bee1fa7d3a5da1844f9b4f6ddf8dcc7c3148e26e11adbf123dc241b6e7198affbaface8216229484292cee9801c98c56e5c526a5a544adc44066670172674eb9fe654650feb75df018e8353ec728aeed79eda330541c67ca87ff0802bcd202bead62c2e2e58ab9c56905eb2a1a8cb80ade89428a6fd6d942d712e72380df60d95ad1f3fe6c8fedf6a20ca24a7eaa9f719fcc49e5324d91123c6c544ca5b6343bdd7893b2deedf612512f22e23e79453025e847cd1601320b67dd87e8863fa3ede44438b2ef62a475541972934dc98e95cd87694909ce7b1d3e70ad49b4f7aa66dc3e44e172a718f6bcbf22789f2b7fb8ffabf8b239cf6799742f2a0580c706f6646283154e3094ebbda51bc3e59d669e9daed3d43b26fc7f1315d1e650648ad4bf82717dec86546a234e0717c27c0fc4da7595249f0cdb5bc742abb4f8bc7d1e36cab687124266b984b381e24bec76058346ec00a7a7bca96be85529edfd84825515cdb311e681bc2642c8d17448af15dfa46046b77ec05cff0a270072833ba108fa801c733e3635b688e222fb839dab84d02b8b09171ba2ed40395c1f893a7efb7e55d55e4a70a874466747e2121a463de92c9bd7878f498613be47db7200f7c9673fd0ea1ebcfeaa8cf31a6f96ef378fea15b68b60b1e42bdb9e9f6dafe86c16ce77f26274ed1ca4d8c781a39617eda2c82d08602496788ed41d9ca9e3d8965a4e2a9cb9be7654f4e7a3871816b704c5870e79bfcce37f5421de91d3aa373dbe2e21f23022e1e2927d3f7576f148561e68bbfa608b05ad01716d5fb4da0f156be43ba4476cb5cb9d980807fd05c6867f880e63eafe0112c22efd7358f2ab522467379c10c8b282dd14df7558c14773ea38bdc1ee276be69ba9be481737d178a5b9b2d16c47970e8a8ae78ad42085c11ad8984c084ae4f50bdf30968413719f7a38166f6104684e092e0e4d1c834d9afdea37398c7f79c9f49c89fbdbdf5533786f9eabce6d617af05b52100733213c29f0fc27eb7cc15bde863da22f034a266102b78dd1969cd77cde476563061c819522f483d5c52c7fa12a08a76fe4c751cabc586ac0b30ebbba9ed2c0b6757f068739f555ea33af2c5a75782d7de8e6804febf6759e88fa241fd03f3e905904bf4caed0633275cfe8b3b206991622568bec2e72e938c8b8c6ad2430f97cd3cf4e29ffe92c11dac52b74e497e9931cd061f7858118fa16072fd8338779e422bdfa223f69b62e47a9be30f331c8c8850ab51b0fa98d606d50ad0d6064fda93f06ace1165e93b5388a3d20b282d9e3e3e4c3442810b1e420e30bfb77d59b74f5c7a133e696db5896829bab97ff2298e4c37603a066e128fc247e667c7201e78a8074b8d5d000b4b668add027a96ebd5845d6f2768a3f587ad8956c2ffd0378e6f904d015d3ce666143fce0b11a3b1f29ffb3e4d01b17be4fb27be2910957d75e2275a7f4936d3ed5fef709014dd098d0dbce39852b700d4b354bb81fa002d86f18fd1120f5666b787c785cd6db1ba1735772f1d99e5965efc0eae2fcbccc1cd3cf41d5e28a64326fb9c37c7ac5249c62b916f937a3733739f1b43cf1d538141f8cf2d8ddf7acde1ae98aeab69acdfb99d7930d8ab97453f61b8369a6ad3c1277778b7eb6367818e1c5f1aa0e786f3a2b37da442cec79055a120da79abb31db1c5a7e5551ee8cff307107d6294aced52b7ac5f4c432b9a2e45ed7347b2735da16d204b49bd2d6e9293d92605dff90e6f44e2263c11eccb9a31f9402ad420f29054016a9600a5fe1377847a07ec191be6f6ceb1c9a59da919f58d0e3ea0519a3e59009285f18445b0cd5cda6ab9cdadb832b595fee59aa8ac19d9ddfe868e4cbc447c5d814a4a6223a549f1033be5e9661b44cf74252374adc8e7b8021dd215bce04f815e2193d43923b9a845590a4d640d9bb321834ff879e9ee20bee0341c9bde6404f5d6de1328eb9802ec09c49c48a80c0c2fd619563bd31b6693c7088d3d30a666ceb86a46fca87f46cd52634d6731fdcf71f1d6bad98e03e2a07ebfebb20608152523cf2319454344ec22922475b2c3fa4e80bfc6f83543ec65c85201f8b90cd2ac106b1e59d6037697ce28faaed340047ef1d9afe5f6f7a558d19c48fd8d429f8b4fd9e370448841ce3c39ebc4314cc215c5d4f80e17586daade7f80b6ceca8dbfc8243d78e01f781a72342314413922e6c42124d83cd40b5ab693896be10f9f19a04f98f3991fd36e690b0c0db17f33110f7507d428fd1dd60f50b5e4929322729fc90cfa9d1ab4c3540fdb2aa9b8bf993289d33b8ea74888ff43086434c9e1aeb1ac86a39377ebaa29c47b1385aaad336eb341ae1cc185978d705fb870945e9a11e082695c489d4e6a32d0e9be9f8a719c00bfcfe4e3c29b193ab5af840cd1e0b8ac08961a106823e3d33dbf33a728d8499d34050d8d555832b982d35bb2f0dac765c37cf1a2a4ae6597ecf752a7f9175e41bce247519b52e523c998b1e743ef9a315098f1a07ace994fdc7816d145cff3cd9c2fd785624f89912276adab6767d937dd6ffcc835ae17a3227401f3b3bc354b05be89658decfa1a5c697afb249077293e5d4f6d257a38e5b460b118bb8fb9b3d80b50309d64b7292261a3954304cce3bd2587fc692c66798ebade0504562d9bccc7747cdbf584cf3a4cea64655252bf4bf95ea37e78bbc5ad0579331cf67d9682db58ef33c2a8aa07143b9ba5c799495b67133608bc1dae9c216e7596bd31281de94c2a8be447f2f82bc7a821702cd4d48be63607d3f4d77188d61a8ea1b5829c0a478a8981f2158cbb13da98f22fb3f161d9d4b7727a561dd3b0f3795cef0d09ba403050c736084e8e3029acc689bf6365c700330935521d29048271f05fac4ddc025798683b43981d5296b5f8da0efce037e1bcbda19803162c13623a0046f474ab0f661e5df3823f8670b002ae3c85dbba41ed0482f639f715e31daf31b5545bfe5576ef82f3c55ffd5f9ddf0e440286691c65f7b2534e4e9e55beee5e68b9c97e046b97e3deccf5854207019241f474e2a43fc046a34002ec2400f3e4a5d80a3368b850b09d62ad7cf7b20f8208f67aa7f53cbd0adb60c7ba8a667853302a76470fd63d0858ca54fc7a8d5a9fcfc7f0eee919b22049bbe3f189b82e7dbe6a2bb7121036dcf9ed8dd1acc83e7187d615c8ac3a92b9558bfcd4a4f9b034b882433404b096b809e75ffdc7f72cced68caeabdb4ebd48354938dc5f3d95fccade6728c4e1e941db4efb88cb449471507b42b3a9509f252b176d033888efd8c86cf33d1b5874d0eb4397ea4b7248112bbcafc554a0994c09e63d80acf3c30e4f7dcd54294bf5c8050b064dda761df388ea36137ce51778d03a9f737b9ee1de1e14eef6224a8da412b03a9a08f70ee9b58eadeab0b47537ff4944b9d2bc2f8e1d2c7bf4a58cc7543710749b4b7720e8b735cad74f13a1508158d4e323a411f016e49433a79a348e9af0a1059c62aaef8d0064acdcaa89a985ca72e2583e9e3c54589d6eece9bffac3909288e5823b7f9afe0d2cb76e2e7652d099d690778c4af67269d3a777af1ff414e028f78d51da3e2e80288d44a32b9d7163677258dcdd4b23774d501cf699e4854cc813f06ebee6e07827ea597e19b3b790ac0bdaafa60adf4f0fa4bebdc23cfdcb862815e310195acc4a756276b779719ab9539ae6c7d545b88ad095d1e57a4b9f8449e6bb64b788b1d9a50a24c8322a021c645385d34deb0a184feab1d363c8e798195d976167849a59ed9451c9c117e8e7e2f5c2b9f0fbf0b2e3004b31e07124694bb36a7a04718e2ae86b4d29fa2e55d585ceb0d5afc9a552c24e9c4671e0ae589b249f1cc6e0ec6caebcc6e9ff13c8b5d379e9668cd4c3622492f289708eaa761ae7734a2ead4d14ecfe0f4bb34fab216b029a59fd44ea0fd590397a38df7db5ed2414b06705555fb30bb0f8b3be4903de912055fa1571b15d6f4a1348aa2097c76898dc90e2b57dda2b1570b7fe63566d8e1d4df3db37dd806b78eb38b304012bf441895d0580a956906a68c5ac01439da4511a6c711a2dc152967917ccf4128a928a9e6f2ee87fbad223b9536bdb1490d33708096cfd8c97792115af5a89b249143f00febe378df369529d925c0289a530e4a98a680683b010283774229ec302e2212e30fec17a8e63e8b90b287ef583e11d5d01d468e5843e668d7fb377f5b89338938acb406c7d4f7bf6f095c76de0ca8da72bc0621a893aad1fd584759f48680f39604152e60fe5e8e16777cce265fa716b6423f978bfb31d87e64781a7a02ddb5e974945f219a642287cc48706c98b4cbe6a49828bf775bf751b7a1866e875ea0051b4f6f0ddb1a932ccdfdd27b95c2173f3ca3d671620c819ebcd4baab4f677213b2622f0d35ebe7fc17cbd06d52a60ef6d759ecdef9f7f240748422355546ca31df6118a068e37bf1bb72b4c449b185cc86028ffc9eafb6b6dc9b9b597307603265c92174fee026fff6f5499248788b6952a9a386c84c1b8d38cc8e1d00e4c1df6b1bafdef50ca69942dbcab1efc3cb8a9fdde2dc33639aea78a5e91e1f2e62a9d4e06d602b38994cc77be3d2a332e01c8d0f80861e64731fc927f9ba2b9f77aa389d79aa21b081af84f5c3b32b6e7c67dbcf0c326dba614d7735f298c9b61f1e9bc7d8af96b3e23b3ea63faf42de1d0d9a30b003a5443685b637c8101fd65b0ae6d898e2da2ec3f3140a6790eec7e3be8afc8eba7bd91f5b5101e52198215c667e91ed70ad95dd66a694077e530c4b780594dbd610e759b72e4e81b0d511f521515a47e1515fb5c9d2379027c101e5a5078337a76e03ad120c1a4a960ef3fca45f5cb8688a7b580f4c1e2cdf6e999dc790b9e2e3037acde45309a1e53f0e2b7169d2b36bb3d1239c37bd5460d334ded75afc1f712be9342f760905420df692703ede1fcf393cd4755938a286cc479d80c14021d19b50f70496bfd9f91c15b03c1eb68630292748fe0cbc364a9000636d923a0da17eb0eb55203fbb88f98f76467fb5a482bfbb74020f46a583038da9a6ddfab705d2682dd38bcf96fd045a3438786ae9cdfd5cb5983d3f0f90b594fa9ce9aa30b43d78e3083320921b9762eece8d135a18fce0fba66477db6b60f99a812184f8127e3a35b2560d2bbf2cf67d566ecdfc1d6b16ae8adc6d456ed79e368767c27e221680642e122e6ca49cc34710326fbd8a52be30cb60435740a2012f5e6f18f2dca2aa1d377d51910b95283db8810d7943fc5cca80d615bb4d3c61304adda3de4bf997a0329c56a33f4d65ac7941e70cee83ec409a1c536f8f82261641d7857df9b83c7aa2aff0320adcc6b07e78344aca928e62b6d5c1dc214af42fe2bdeaa1a970a8da8240e99dfaf3aad85c039ddcb818f78eab0515c2308b90dfa607a04a71262ca544be534aeb1923f86c65d4b22f865f180ff90400e27a46efd7d797e171c35e6806581967eb28f3c1bc51d5d6a6d0e3d99bc35ed161c5c773e9b352a79695a96d96b5a22273717d1d043db13d6be22161f79908049ef59d2deea20f6b685464f4ec128ef55720ce54d5cd6a819689db85a7d1f69b29591313043a3fe84e931c407c850ecc06a9ada996427cff37678e3397218f006d95cf8ab6a1ecdc57dfabbbbf749abfb19ea52f24f1d3c612ee491821c7ace6a01ab7036830a6d088a853e1072ecb8c7242cb79bbfb7332ddfb01184a6c308be326fda38c3f0782b418c02038aa70bfef19cbbbcad92e521ef244620887f56dff6a387367a2c97e08b40eda0740b55e2d9de4a67257d3769cc038e544293d30644dbe532b0d3daf1f178374c3d072c4ade0ecdf36d83862fe748417f6ae0be40957c058b286795873cc6f62c48ea349fad080559e9999e70d5ca686eaffc85df326c306c4ab658f2a74f66015a566e8692b729e841c4ba1182a96bdfe86ef581f75a3ae88d8c7b8f52a4c4623eac21d4fce6896d8009729401b9615a0538bf009c05fc44377d563163258c2c821fccf8e35e6e881a2129db61c6c11d13b40c2d031e5bf45bb91eb0251b8170f4399b3e8dc0be5835f56dfbf8096ab09fa4d151671c70647bc1b9a0aa05d561b1caa7d813693f8de0ac6011e04ce9f9dd5ab2977b24562ac4183514c8dcf922be101d7c2b0fe9e13a473fc9e88f145463ffb8cfc7df268539fce4f9fd2ab6a53647e33d0ee5b133464cfef0f2d9231a4bc0b20233d039d3c2a800066891b0eafbf1a67369c56b6b9561eb0273b629519861704c164efcaae5892d3bfa47d734d7d929e7ee03718e220e56217f4c8923b73b29aa4322308e3c51493642c09106a33ef80be9604144938fe0d5d823420d2cd06c93e0f4dc081ea07dda7d3a4df62342f6e68c6984e62b12b07b6679253d33165b4f1d7c40a01ed293be3586c6b8c54e35eb286b90dd30ba6a2dcb2073b65fa613855630222c62dd71eb507f151131c57360dc254e471d5b26be3feac0f5327830cdb2ac33caa6ab24e32a09011528c30420bb1fcc4f0ff4ba2fa34ca37a2e5355868c371483f3bc169b28ec1d16e6f9aad04958f08e53c7358c5913a042ceb154f26aa7d3980db0faa34a2c91ee11c2336c93599c0e2601000d8c6bde7250b2ea145c155cd3171d4c647f09270aa87435a94bddcdf4a2cea89c6a9d8d26e12b7ca1b3dc01586714b6d0a80b40700a87c1a6354b96ffd1d404f1178fa70c5c33741f2f5306ce4835f8d4dfbe39e0e30bb9fdcbf27fb22afbda668ccb1251b7025af0d96c72ba2c55748914a76e181ef7a51505e03e06cbd907aa0b57235fea3dc15aafcb77bc3b522167ec3dd263905580dec68c6a59f07d550c021c4f8496759ab1b540103a1abaa2cac12e571fd44c3a2e857b3f06f121c58be79bb76cf3f57d0ace9469ab134c870c9ad8f7f7e8e627e7121ff66fd94e9942f53546b3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
