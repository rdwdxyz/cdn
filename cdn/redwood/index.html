<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b19992919ecd32a71a8980af9e107b63aa42fc85ce7248b6bf779e34b487f3ad57745dacac861eebd50d260dbf18b72e59736d7df638fb7c151a416f9e294f6f7f88587e413af8c26df9c51d9e8926d3559075e5181a7f13f75ef23de05beae71f8d8ea671fabcc048994ba9db44feb78b3e3a81a9dec6a48bf8be1c973eb62aa4b15ace3976d53d77d15bdc9070812cc421d76a83d534f7d4b11e04fdd466aaf9a95cd583b15c6cb972b936f58eb80f490cec6cec2b270615d22e350bff90b80210edb700d04136361cded3bfc49356098728a598f1a1a874d4853f565aa3770f40b90fec6d604b5ea2319ce2341cfc3faccec61061752a7220986489ff66568e2a46cc4d537a34c3deb4effe61f80d69a51692d4d5ecd075435b5dbead9e8b3ad058a1fa82be7fc77d201016fe3d079c7f1e5ede9db79976747cf6d4846a5622b694ac33689e51cf3e6f81b168105dc0abaaa8ddec8a7da35ede42034fca2baf38222ea51b7a4b2b595963a0fd8b93791a92aa397a7a06dc93ddefd3ba93efdfab461bafe36cd39a7a90b702fb3e1ba2ffe48a2f54ba1af63c1ede4f0faa3a619ab36b9b8f7342770bfe897bb1586c82e53e04943393ef224dba96c3a8db5c11e0c1b873a9aa36ef223b92983a7664cdcee51d8b77248399871b8f710278e45e8a3685fc64237b7378e5019f58ed4892e26a0b6553a42c69e40aabe0cb8706da9efbeaf6aa437a54df79158d98c05e84da7bc286a9623526e8604e50db763ad3e71c5f1cd14d2fc028065efca22beb734173bebcfde661af088c7177f564d9899e83fb0ecd21a2383b810e861c7f94879003b0acae04a114009667c7fbde9b3d48c36ab2a33516b40b94a45032c2655f5c376a9ab46fe6af02b74bfea0d7cee05e4a3ef91a0508b98ac4905e1b282900c3a784b455cded965a2f0ad9ec343156dba49cde7944db25845457ed28f66275a6f626003916caed79fdb4c68b86441bb7f4fc5e00a4e5b357bc1c0cc4f5126fcd9b7238717e5c74dc6f4f10c699718e89efc4f9152aa0b07b1093c86eb9729c5233af5ddeed2ae3074fc989b07092ce181d6723fdc9e392cd64a329ee5788dd454a31e36ef23461cf016578cd27c4f6a100678ce6cd8d29a4a1065276058dc7c8f7023b88227f158d58e2bc9d0c6dc59c033269af19348bf41dea8de77fa61c9c97dd152c1f0c16c8061f851e7a2d6674034e474d053790736f2d3864c48888f591e6eda1696d2ce9ca97f52d62ac880dcd5162fb9fb8c3128c041859b493609c217889876626af8daeefaeb68ab95540141392320d93099005197fd53ff11a7609614ff79f6ea5db10c1227d4efc5182e6ce5239f4d43bf40060c12dd0c4e5294be8aac7cc6ee148e105f3a8ce8a71363321ce27a52014bd13e49b46fc6c1d0b05fca8a30350374e7c3c2893db0650f4f91231951f7187512eb395a60ed09e7743facf5abffcb6743694580e1863c3bac30044ea9e645a77278c6777d8b6e6dacc01f92d8b0d23a1b25e92bf21edb7a2b14e9e8d5e01c580fe879c83d1f5690f853bd429f5c77abb40c9017628f81a620423cb6bbe45125700d2834912fa9a5ec1a013d6f0e6ab54f1acf402740410218afc0c03c599e44d50ffe40aac7007c6576ab01a3675bc7a80a041ba922631ddfb8007ae5effe849ac5c8a742e4893ef6adb84e581c6cf367db17c9d3c569a8932c8bc29c8e932407b1ba74545ce2b68d3d397f6e833b98551b3abe39ad9d5d7f22db11ebbd5c7cb743e86b1c928f9dc9da8505061c937f59e9da565143473d851bc0ceda4d57b32971ad2a26c18141bb37dba6a4e0c67b1aeede310651bb48852aef3606ffbfb35892074e50231162e48e1371757fc8249f6cfdacf7d572b47847407da3769760d6181b8be76797ce800cd56bf69a3abac67d78453e4741220e8bee0850a1d28c52f537bdecb22b08d630e561641ba26a0deb1315a80d753cca6f79c8c87608c3e721037d539a7af9874af394a4d2d5d2bc2ba43379217dfb2c33db8f8e5a56cd52ebbd8521d39697da9026adf57a7ab7074aa0d09aea4cf3674fafee5c5902f4a8ce4f5719800a26a9c6e61d52432dbe35d804ffb269a7507652b4a964af4822a1e6cf0b6b98bf863fa4660aefec654f7c1cb674763adc992078ce0f45c87f16c442bc0aba9b02124c7eb6ea5b0fb78d3803a7d3db0bd86610af9ebaf1b912569d0b2b70db78f7f99802121d8ca3897542957acc54ca852d882a68da4094347f67ab285eeb820d4d776ec0052f4f34fea3501fb532497950ec7d34df4fe13ae28cec95336a7dfd9d1a27420fbd149ddcddf0e192bcd523ee0d5856dc17173f6024067c03363657e490066d96d54e732063cea0b0a71f845bd279f4b94a41b26c966a4fc96864e4cbb83c333f81ea859c1ec46026ff01602e795626a024389bd495d0a8435f1edbc507eae80c370bf62768f5003336bbeb8e85cdf3f227322a15267d0e0932ba430e721402dd78cfab1d84e6cbf92809cf6aba32685d8b7e92dbeb2d8627baaf2f34d19e2db20c29cde177874153a07229c91f33d4fecb82a1b162da97567c42a0438f83e93a88575824fa8f21c83fd446c9f9743a4acb05ac0cb686b821ba41181251f4a067821d473c81da0e4b40ae5d9c5ce771a2b3117c6df015453e77db919763c81611bb46536c6be4a358fa46b2f9c1d1d2718e5ac680f5d3a5a6f1a8b965ce6feb70221c2fca8956d2b89903d23fdc7d7af31f9a916490b328b14461d026b3ad389997ee74549a7d4c3563f1ad332fd84cf9715cf1cd8543b21ff7ec1ed26fd87c9542cbf821febb8163fcb407311a6e6899e5e481ef1fd3870cbd2959bfd85a925b9c199c1df6550ad37123dbecc5e5ce3b47b1b67bb33a5697006086b99b2c318cb6b89ae5513e8bdf2c107e92c44ee9e49030d0fe5d7cd6aff4c72ec0a802d6955131a99ae811083de933d35d21224e87b905e22299f7423d78391e0dd1d735318b63dd3ce30050498ead91e7b861737e950f994342d30aad8c221d288e6bfae7c60f1bea2ccda1713800bd91cd5db59115eeaf48a6819d93e3d87554bc493a6d4c36adfadb3aacb06b98323f9436304ed838ca5e43ccc5c2c9eb730cce947bb95def50958eca5c72662758ad49fd150b5168be70c88973855412b6d620328b67190d7a2f9479acf86472aa5bc347ff2085ace1a28f73b54105ba05fda912c370e28c067b1626e4a2d017ecb62d82a43980e208a8ba820697239c3aca998999eb8451dd70351243d8f002243e67a56a7d80f5b0e1f58589351c38cf138e7777b79657f861eaec212312a7d137f2614aca393ea8c42612bd6f3225654c1b39758afe742a129c0065dfaa01c5eca3091bcfe24b6f3627af60a84265db2720c0a06077faefd057679d83502be6d04710c8038eb160eab4b0d5fec58dd095ec5fc66937e0af134037b54bfe2d4a8dc1a8f5a49381e646921318c60df800c8077c1a30ad54da1b72143529163ced2a59d0b2594690829e492602c304bb5d359b622771b6e16b7c85e6ed7b79e160b944c1cf313ec3645b083f9a93ede399f94ff17f35c26922a22a272c65db4dfad1292df98b99a84a5061dffb12be544b1d880d8cbcd4d9051c193f23ff926f6d3d074c3431d9411dbd85cb84d291ee8c98d41fa1c708af8b5b82e521e99c303a1ec222cc333cff287cb0d70e5b2b7ea5b9e1b59ed0b9933cc1806f068054b7b1279818d5ecf1ce1e9335bd8de2578c6adce6b9cdeefcb4b22a97a94d166b5a478a90ac6bf9e6f8a6c8029ec51ccf9e236f5d68f44dc9a655d3a4f944f79754483e938fc36c19d066c23fcd387d7673343ba71d0d56c3c219bfbf4d010c2995fa56463c48b061ff83159cce6b41d61850d03e39a2d357c60181405259481b7f3976df91b90bf55b195c355941e89ddf453e25c2624e87bf0e5dc565fccee3ae642612256ac859f840b76642550dc78003b77de2d623f89e5561344ca3084071052dc20b729f0938be017fd73d1ce649ade05a2372eb5bef2709af516955e3c3f5823c0f99cb9c6f403c5e52a7c59300c992745c366c7629707ed398629d68595924bf53bf42b03f088fe8f9a6deeb80900d9c0bef7b3573f2865fa7021eb89cf5197e2962ec6e7627d8cd883ee8451b95e2b01615245797105c206e8ad32aa8d6d8bace3f6ef57f29c29609bea44c5401e1aecb8aef20f803b79038c020895b5c488780f0cfcd0821c1cf32a282320b21e2bf698d4143ada4326d1901a5cdcacd4d4fb57941ea197bc5a58b78f810eb3b5f9f82ab7f488a12275fd895a90e297176122d9f7399bd11810785f0f9f6477b374c21ba69750c95a281005c429b7b6a9a26cc9578675c7326cbd383e8677eefcc4615ce7206d3779301ff206ef5da1ce5acf04ec97df1b459adcb21fc2852e70042e361e50f79b30f71da0d8603be38fa8fb5b5147b947ab9f9fc10c6ed6344f9e4f0e39c4b90ec7ec6eda2bf91600e302ca85091c2a396773b45d2297a797c45cc9de4fa9be8280cc3853712a43d66a038fc60bfd847cab0a75c9d274e50a68b4b165a2c8610fb7d48cb6e77dc7a0564475e3c948f2a8605f814f514c320520721ba5bb12e45615f2d83d72bc61ba117349886339986421e3b84b1974d631f67be6470249d78eb2fa6535f8aa850301d930540698ed74c7ea252b88395034c7176e515208a21100d0432459b0d449dadfbfbd3340585cd89b59189c287cb2eb297588a2314841a4b8152d2a41cbfce6518c98e764810ec44076f81573469a4c18bfd88acb3b5490bcda2185cca0fbd993a6946345e2dc5fe6f5199053d984c6263348bea18522fd1b12cb73385c6783e0540724c6c2289343c6396c4269b5cc8eab21a5f1792b1a343fbb52397496fde55776f39c1c62c72fd68cbd1005d251d0607a4536b10fff111a50add5b6062b81c9089ca143b52e65cc324550edfe2adfc3240e3f5fff67c47b0593dd0af640a0e825a2ecb3c78ead90b063ea55f973e7622c7ab55fe5619e1ddc262aa4adc3e4b68e84a20fc922d1d5d56be6da8551be2c9215678ab3273092c31040527a60837c2fb5a8f2b2d8a3ea3dcf2546ac735a0f0a9b044fb384eecd132ae5fb4a73cbe25f3ae3e4ee621f833a53560e2d75a5780a55c460f4b61660207286b2a6173a57a4443616376eb5c2c473a419b71d8c49b0b17b614d768994ae6be117f2f2d499d4dd8f2943541e2cf13cef782e62318465d94fee02ca307f7113d714bcbfdd0feb091cb98253021ca94041580015d1dfb927292ef9bbade496fba8df3c86292aefba574955c93f0434d77e8a93fabb2680dd60c6b3a15bf2b1ac3585b04fc97e48ab868004d5e8b1da08c982a73d12c143bd10cca35fdcbb772157c8db94a57aa18c131aec61d77658971ca74d61b5e9ada34613a069d644d29a17e739629c8f5c84e702d3883471d242d8681511a5d7d36c6afe8611c31fcc718088e8930d0c10fbacbe53a94118ef0f0db6ad6d6c25467566268b0cd9c6b336b33f7b29d7197e0db52ebc330f1fe6f1445e77deccc605f4d8a8e6e72c5cca74747edb1848eb64f31046a99c3de12c66d051b01ccf8f157ad4c1f1d37420caa25a0d1a3faa543758e69282b2e37799e92e2025eaa8b742e426dd8d920d012a5ec06d25a9cb3500f16c893536eae456ba3a449fb080a3033690a3649de5fef305f46f0af3810ed251a2214ec1e25773fd5a4996c9894e5de2916240fd05188f6a68de9893aec62352b56f7d41a8fe3323c26cfd366a5fe33d3db4754228071160dcc97a88a711ac0c7585400275a1a4b08f9c2c1371149ab3390e1ae02b3c122b727ee71354e1ea0d2f8a0a5f5e3bfd644aeb72e3c8835fcf656c5709976654a6f4300f2168d99c66eff7b5b79e09bf5db1a4928e8be2aaf3fa58c2a9e20686b9799494de7a232a8597382d955bbd8d6620fd2e165fbbf33c44aa624cf33df759eb028fe7f4ac3594bf26189271e7e172c4192a653596f056246d708eae81a9b9875242ce78a6d1f71ea1b1a56ab51a7d0bd47d8e648a7b5c75d95503ff39660c0b9e50a4c53664bb4fd7cf06e69f87010db3ff4f06d8dcf779a7817b16c7783c3f8d07b7dcf4e1936f7dd05967f66a1cea8ec5b0b4a70fede6156189b4d5aeee676f14e5d110b143b26369b498bee8f6aad968c65811a232065da3eb2b027948322376d73c9b34553cde93023feeb201023042b04d7d13322df3fa4ab75a3aaac644503a63dcfebda1171785f92fcb22b3323ffef3c43910a7c9bb8d6b90a8183f827b02ba0e53cf223253ac88b5b678617a754af0be074f8c90364ad60920866ed2574fd9f24cfa9cb8306d49b337d961bc904583d1603d9a5edbb6644080bfb84bad5cbaeefec8cb18dd8299ccd324c394cc74d7d99701151ebfcca106a3285f2a8327eb43818e4ea75a7d86dff147acb5ff431df51c69003765ea06e5c86fdbc472d9687f2e92921a1bf07c2be5a6ba62b9403a4e077e8ede2bf6b9369e27e942e71bb6c49b49112db50051b017a527a4216211c785902233b6befc01f53d57f52a611cb466e1ff8d8a03d22d178bd2f181abff0bc630d81171da6bd4848e0ea538bf4ddba9999df37a4051422da0925713c83bc1f7581a78bcd3600e034ebf6f0c3ac5475c5cf1f6ad58f5c84b07773de5610407c2c1cf510a7ddaab2e735b0c413a79b136212b99f0c2d054f488d520323c9974e1c9f9d5cde70f5ce66f3c421418a578b487d5fa33df33500366e32a1f245d7c4b1ca0e584778a08c3e2750bf16ab8c84a2659ad4f4d0227b3bab3495cf22b2655982ec46dc33e08effff26be536d01ba792c2848438362a23b5c9d2be41fd56f275f956e4922073099ce624e609a36cbf97c59c35a648a8c2252b53476c0af258e2d03317f21ee289a127a04adc9e162e27cf36545442515ea35d8326e23e17caea97908d1fbfdb9c7914242fce73cb273940bfc3e2bfbf554593ca173a7da15693cea9bc10552329cfd170426c704324767fa29222052a070b2088dee6a9f3825762bba60ef1f36ab707bf6c81e614095e8eb4e5fddc56f27fcbce11692500cb40b82eaab641a82e132dee5acfdf5e8ab678955a92dd61af7a3af1f88e1e1349f711fa533e88bf38a6d09a0afa49e6de1f32ecc54a6100999f505214e2f4135a49865e3cb0d6a088fb81a07e4dcc308e8f6a34bd2d78d3eac4b818ac1c8d37357b2f2f3dacf0b6d41cef8183b26edb0cb6eac9ad4bb3305b26168008ba3bc1472a79846c88863e4d9013b5804d95565175120d1ecdf30a2c906c752b1ec55133291ce48413fadd166a89a2de2e5edcb6a38451b526573c2066395a94dcf097a8139a5cdef4b964cf2d4bf4f7e2b379bb7e200e2175fc59763d5beed3c2c2c877ae6569898883040868b47a8a12003b02776af8944de395804518b077b60857659f869536e4332ff55447365aec9466dabe61ba37ef8ea60fb6de7316ee61cb839950757cbf5956de7d7804e15134089538ff7c45d36f5de10d6467f8b4bff6a95fe59f80966a44ac94809e0115204e0973d53ff24a0f7a4d9c030e10e10e93eae231f67922918b5681e5290c7a8507a92f7d8cb4de7523e127ab6e5bf292ba159d0ada2dbdfce2c1abf884f509d77bc0f44bc24c81d8c532fa46fe3188ec2bbf45d58e8d65df61f27b63c84ab2100eb51c7c50f24020ca148cc94175143729b06aab201edceebca7f8a0ebb56761438fe93c2d74dcb71810fea4d76167976c12525fc72a701c348db88fe318290d69f9c6631260f5a370ff44ddb23fe4b0625111b8fc8a2dc574ed96f6ccfa82370542f8a5bad6ff98adc58c0571dbc9b58180b2a19a14d2be43f5bc0ea130abafc204cbbe276a28791f484612c5e0f08aae14d9fa5492e22d0e0ea227aa20b3dc658b5f4a28f75f107c5ba0c7c9e93fe07897a914b008cb26d57c179b909a93ea38bdba707f20c4bcef61ec971f2563f5c365f0238a15b42f1814b6aaf90a9b57179f7bf4ebebf23d3779f7e43002a7cb0dfcb545de19fee76743f44cc403c72a0e083093f3ee6e0d1cfc855c3061c3b2c23b6602e3721717ab6634f25d1529dcff9d46e2b6a6fc0c74bd09eecf7cdb66515ae057f44bb451dc896f1f61d415c4d037ea131580d4404d3b7e8ec91d728341a4388ab9de675bdc03ac7a3551a34cd6dc3adde18f939508ec173a7fa75268d62e8feba8d07bba5e1ce722a6b9f1b74fbdeeebf302fdab1438403a64db228e37d1181863617feb01c55333118f56d3a94182151f59f4393b10873403b075232f496af0ac5b4a2819521e94fa056e2362f2b936094cc19f7fac1a74af3ca2e88239b13da3f57c8973e05699132583b16952635f87b02ed12fb327bf44e60a23a97605fe61e1c4d373b7dd1dddff7cb996ea40d3043ff9ce5cabf66ab452f0107e03c1dccb4ab17e8e4ad19f5530a278e05d6a9c2a6bbf46943bc192c47c4f2db518ff86197e4c99d3ca95b33289e8b6bd4a8ee8042a6f7eb2c78316a3080b439403177952fda0055f68a5324b98adaf70d0a72f745247c94e2189dd43274c87e1098b6b79c78568a3e6b1cd7cbff4697f4c845ff6f0b34e986b0d8c92b8faaa73f2e63f624ebf3971c0765d066eeca104fda71cd87a639df2687b49dc7197d63205e97083059e4df83bc0d54f46c108e6a17cb1813206c01a01b12cd1d98ce6ab73c1b884845401a4b748f66d7e22ae3d2de4a5f3c1b4eb7859e507915db1ef9812f9de03a8d48454f0721003bf11cae54caf64405f26ed11235bf25576ca23212240c2cdbd26a30e110fa53aef77ba2fe42fb4f76a2296e4b52bc386e8f9b03c193a97c91b482a76a3d1ed8c25aa7b6a80a00bb25cae70d692c4e590b33216ad4ecbe5561cbd0e22db4f25ff4693342e66b223c0b077dcf135a805dc29870aeac834f64b7c72520e052d4b116ca8a7b4db1c8763896325130061625b8aafa848f66c78bc847693c8e46706ceba5378bdb12e6b9898441c60ff8e4abb74d5a32073acce656f284caa3a9bb6cca3f4d523436ca55585da9416b9c889c37f9c8503c4bd79205282fd5387de8548885286469e3c34bbd289e4d9ca11d5b78430ce93e71af3762fe7eeaad3440687614bd70ca1948106f27a700783dddb5942a32c7099d138a14f71f1647e2633ad410281c6cc36331f3a27a65168ebff5eea73bcc96f00a201f19d0cc3d0d3e0500807d8fd6cc35046369b68ec92e8df3a97f31fa85edb232d5939eb05f789ac07cb1b978acaaef0086fa6fe8e16a8b6b8ec0e5fbe1f3a4e6b35dd71d9f311b07ff25cf51ef8c6fe3fbad3c780ef67afc7a674b3078efe66312d9d4ee3e13bb1bafdf9050de6c2a6d296dda7177a70c3458f0d743b229b8b3e31386f657c2f9cde85963fab2846c18c8019c84ff2203aba395e63172267c41be9bf11bb5f6abfcee3e0399586f9bc51b2f5742d27d5a74a2a9f9e877b8679971c15c515e58be31dc97bea02cd210921a7a6ff57e76f46a93cf50a3b75dcce147c0392380138c51a97e856402fbea644e965571233d5dcc99c1493f37db96896dbebdfe16c8ad3b719c4ad86d354329ab7e0d1f400a3939b303d0af849ac82e85c8efc0dc213908006d1a84e8fcf40d7c15a92946374bc676b8da819754a11bc0207c6ca036a97e39edf51ddf784f119829576a3b68ac28752bcce32bda54f9089304d4eadf59bf9ba68623eb3bdaeb458c5199a3a82537a472e001a68868e589e81b0e2fd522cfe738d6e7daefb626fddae1ccc29b83d0602fe4e4cef0c13ce3ab1706219a442f2a834fc02aaf15912ec929132d6cfb5d120cae413d389ae109ed40ef2a6ba047d85a88e326930a58e2839871cd6c3bb32791d02b9173092861faeba2edb3623fc1e7d4a9a496ae524f63f38be08b9af92a0f686bb5cf66bcd033f8356c11a8d8eb165481e41d740b9898561067f28f1cce7e7d067f2dfc083af2c56562215fddc2bdd9317f6eb342fb2f0a304ce6f1afae262654e1f587ede07942873a7261300ccb01b198d5811a418785936eb15c743f81fd55bdd4ba023c1e655335f92ab5d910b667bbef8635dbb09cadccf183da9b3c0c0b9251587db16fa8ac019419d213442a76a3fba47ad09d61476cdcface38368fcdc02404419c2804a0eca699a493183bebea84e7d46f6bd6387ed06c5d5bf0eb1ab02c79f117164703b39f9f38b5dcc6ecce7ba2188eb3a8e7ed4893b2e4d46ed786dd405f75f2e25f70e70dd0a3489fb7b222e729c50cdcbcb74316316d4614cad21a43452f08ea65ee52581f02084aa456bdb112ace0fb3af8c521eb9b0f27f04a4eaceb8a7a1ee28544eba02675e264c5276bb451fc000dfd4c161fe26b6ab935146b93d1cd942276ac68b18fef17d5f6a8ca927dfb1b8ec9a13a0a9f9444d73a30c56dcea417faf2e1fa35ceaca5f59107fcd39fcb7238cc05b94a054c939e4e0bf4af33168d4636c58b07939cd792216a51fb367ce29b924d8c9fab6994e46aa68cf0584a0962fb7898cfca94addb8e0b7b94e55d59d283c8f1c61f1682d3ba020fd2eb182460c5d11145ac4570fbaac2fa6330225e56ee17125c630c2059c7234a95c5a8f63a00baee691dafec019a9893a267e9700a5994c84e7df5feb909a9144285aa1abcba77ceff52a942b530d8f2355e9f43dd93e2214e48026d5ba23716e45406db3fb7896d42ac167e0a66debbc754682d6cabab6f565b37c36696131f37bd59fdf8ad094a2687c04bef6a353e9a3a1fc99fb336d19148577017dd4f237aa13022757975310de8aa12c0b8cca7f4cd8fb06c209b06d0514b6dfcb2650d0416428f996520fd605b44adf2b5f446954d51994c435411edc982b04f8ac994f41406a25061bc826f74832220b92911953fabf6fa54c18db4538a6535fb19aa52ad0898e8ce6932ee81930d86ce3e48046064866fac0729c468e26883f571f9bd349c209bd5d3094b246142060c026c9cd5ae677619b7d730b29d33c1525986b2ce3738a2db920877b2546abe854ab6eb3980b9a1eb89b15e2151e10158ce53931dd818f9de86bf125809bfc7c3766146c31b9a3be70b09abc387909a2b25af9c65d7416a69ad54d0535b28c38049dc15baf341bf9a4bba3e5b2e559167324833fccc29dc46139688fca2aeab53277d047a0a13ae37626aeda9a2f248985ec6b7a5ea93ab980f68516dbe986617d55ed361738c8a970e78f78f41bfdd176f07f3f2e7fc9c540205c95ea8c20ae17900635dff117f4e52044b51be52daec0808c8787e3d317b4b3e10eaff58a344f4f4518835e32fafece1d4fdad93fe4a3d65ea8dc49d79f30f9d73ac8122b343ee36ad8303a49f584f972d1d82246d0a255cb008a61bb514501746d13dd5ec6e6bfdb54788fb68926c605cd09259bf30e5329ee9352c4c9182624e47f0e1561664d44719e7444b7919d82ccb064f94a0e7db7d1f1b2d9b5c2451ffe643079996589da1d0511503a9664c6ea5eaa49fb783b6232e23e5e9a6e0e8c0284912a2fa3b497f1d265e22adf1321add32261b0b2d23d393a9c60cd78cb029fac8e1d983d1c179c929178b2b7f8c625f7a0e88798b07e545116817974001a45585dc2958769da2784872cb4762628fec09b346edddaf18f29d3aa28ea7b6bf2a3c719503a1923eef26f7d50a06f950857e1ed875266dbfe190ebee315f4db12ac8c220eddad4946e31d9213a4d92243fb2b742c0ccc3dd3a79eef128b20d135a76062646af82b2811567590d19b53231ed8decddb16ed9c66e31e87f4fdae481a92cabc2db335e06f2fa8aec072a01f90776e602fa8fe54cc309427f36551c5ec3672d603a168f5ffb8c3c5011e96d46aa6f1bdc51c2972f13544c5454d646b33a37dc34344939a3813dfeb90cbf76bacfc93d14afa5f9065bc4eef7e50473a842b6875e7f6822ecc33eb4b3288b8d504d194ca888e8293de90da36110dc004945850353608634cb93c028a09cec91f7568c106faa1141add3f8a2fcd2daa4a1755f25219004d8339a2625d828689fc41dfcb85f673ba84ec62dd27f40c88fbae59380b118999d7e5a215024ee0cdea00f28c3aff46512e7412e417eff5fcc1ce2a77a27217b8f7f0e850d99908cd8e2ca90b2c0b0abeb83acc8f9be021795531ff06cd21e3343235fcc8ac3dc189988fe9c6e6fe3019842c8a412993b853d558a715eab84de6513af0a4e33de5db46dd033a46ceb2b518e7df418bf84bd9d4f96879b3d61557fca565096070d59b926c70cfd9916deea8425d90bcee38b90050fae6e394a9963eab66883d5b67595bf83d788936d11fcbc2736b730b8b0b9a188cae109c0f1dc1c4877549fe8c420198d4f1310d3e111f2037c3374cdd07c47763759b747d3726d51d8eb41ab3be1e3f439ca3e30f86e2f8ad6328b66ac5e9be44314e8ef3aca15ce897cfbbd666d541528138b2cefdf059f1040d6a0b35ada0549a2239742ac7fc8ed8a6f91e447719fcbde3c19096f1d42d9c580c84770a6ba7225cc843d489f931fa06fa920344f70c6b30d28bb1208db6abf8673bd5c5982826d80470b53c09ea177ce6d2a35265050067768087e5bab56707cea472eaa1c09ffe65ca32f7ffde424dc33786d9da18cef5abd25b8a379dabef486da1bdadb9f6f1a666fd689cc761c17d61432bd0ec7768f968201b8e798e516f2789e615298f265005c2a8eb62a0c503dd35b0d46984df79c0d45f730be77d0bec766dcc589ce429da1f9ae12a3e0708669ecf81e1beef459049e3664fa00a9311df4747e80fb8fd7d247fd41487e77dc69bd0a2df070e5ddd5fc8444e25935fcef50b34ec5425d883436d7a9c88c8774eddf65e26619e5760c4b236aff4b315f8bef71ae5862b1da48ecf54393cde09ff448c8450eb0acaa01d3a29671ecbe1977e66c9497d2f0d9a01de157e340808bae813638c3223e2f98c6a2b400a521e8c882693d9ac12954daf36a0e3e9d8ca0d079470623925b874eb8964935814594eff0d21ea6b23b324b8b3c9a346f1fecc1896df606f71ed74de7e05408830659483473368d338519066537e763d01dd71fbdec17ce5bc8b9d6ed11886b574b291119fcc32f2da22be3d18fa7e98fc39f7f16c25d3ee6cfadf9d7d3dae08ec5b47a1be41044435796082d6524de367c9b9b72e8c86f73c2a8e997220d2a3e3f318cc7dae37c11f9dd11399974c16ba60f95cd1edd8c88fed4b1d5ab119c808339d069adab0859ad391b605e8704ae96823536f7251177f5c08475088c47602c787050c6eddf095f7e900a0096ff16e1b4640403bc35d909eff14694e5ac8e96c64b07e86add0264404c14ef90bf163b79e360accbeac8113adcb6f2855f36646f65d902a4bc1e66e5fd2c1d8d2f8f9b45147c6bb003e93263aacec2dc99563e460ef8052a8a85d59f6864cf4a969c99f684dda73163864898c124f0f7f2f7d0f50c9dcfedebfd6de61864b86653635cf22765a4c0990af8d0b21f97df0696731fef92d245262f05b480d76163b71aa0d9bf02d0199aa5c1bc80e7cecd8413554d917d978bbf73d6787cf4dc7a797c2871e457773033e508dbbcaf63daecb3ba73c99bf610e17c5410e0b1c8562f70933c27a7a9b4e32ed07f1a88352fd4ccaa926401b4be4f7d485243166a3a77e53bc3aea9b764aeeea9fc1cbc0f4d6c841243b4163569eac5a58ed1ea1b310f919fbe254e1993aa10a5ce0420dcedf70bca55d8c3ff4b77d04705c16e6091ff0a08c326fa0d583680833790e53ed8b7ccbb43daf6cb3f882b0a6f7ebf1d471ae3e42eda24eed108abd0ae887e00af211cbcb733ae88c52b419a9e2d7b47ba4766b8c1da3442165031a8d489975cef1c811e64a007713e273c8e637b777a0766f88aace08b2f3e11aa695689be588c238e68c1654a5d671d182e10dcba2e5c17c02e5fcd532b38a314f207a02721c1b908276d92f8425328c455e1fecaddb07ed0a4faf618296a7eafeefb692d849193329d7f67be67e02bc556f65da3e9d1bc55649674f7486e0a6f8f3f69e3145a392166c4ca4fa5737165e02093e1c58f734ac20b481e61685ff13aad5d8ab83a6dbc888138c6d7221b7cdd74d245b6cc2d918cb280ccbc6e3f7abd38ff54b7988b5d43032337b022ec70fe7a4a645570dab17e0669d60309067094cecc49b799de8191dc318d7ab5f51f9a4ef72a4ad8e0411e655477479ebfcd7efb8784bb9ca2be8873923b7d8fc173019631381151303cb70e1666ed5d208ed09e28bceb23fddd3f641bb55bd80463c6d74236b6314b104f84bb34e63b85b697c16470ad70a2e22cd2fb3720e997018edf382af7130b44efd98926f2e60b04e3ca1b0eee3e7a7e8795c25ba0186345464b8bf83dffeb00e79c692e4ab266b88dfb36bd1ededff0523a3a7a2d16cc3b672a1c9090ead5caf3c7587f032c9cd4764e4e50e3ee16deab0d4a3d7d9f5a913086f577a973137e2469902bd6ede0b625b11a4bf66bac2ac46409c81b5cc414a65cdf5ae94908c2c630eac7b1d2da527f19bf82d6f95c39325462963cdcf1c74e80658d4cbc126f5b82ed3b559f5d82f96ba0dcc054b5f07997cbe89db979be2ae8df6bb68fa60fcf81d755b197c74f6691454c0d8b12995c488a1a37c42e778849fae891b5c45729532a334fca6bcbdc99c3aab8f6ae3c21248aa2a3141f4b6f6bb3f2554746754642e7e38baac9c21384ff3907ebc9aa94a89fc7609365ef2fa3ef0b5db108bdf295176a45217b483089370c4753d4e0da4b3b6ea78beb024ae9ceb90fb4a5a03b570322a1ab428bc62cc899cd7be236ccc2d5f6b4068433c1ea0df4a2bfa79d82de3eb0d0a6ddc48549007ee8d5dcf41725ce7f1e10e86acff51a03de9bba041254151d30dc528512a752d379c7c598d560f671dbc719626633685ddfbac64a6821d7e5cf3d99664df8510a3143d6d91dc0dcd7cc8693c5d3b384c66d0b9df9acfcf16b632e4359b43f10eccfba7411899e432ec4014eee5b3b45365954dd25242e8b13d00","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
