<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99c27a85d9118f4064e498b690b57a6f7ecf458536d361a5e184beb55a839dcb864d28325bd79cb91183aaebafa28c9f66f5f1074fcdd7812502080805e030d12b0b36d0cec95643214a6f0241a73f6df84530e9d3c46a8049071ef245eb00a7fb01b1e795f3ecfb52dcec01576958ebd6ce621d9efa790484e7bb3cef722f0d5c59dff48aeb45cc8df5b921f9c65ae120c85b19f24c01e1f38e0cd0751de03ac8b12754f2d09462dc3f90c8c2214cc579262540336a345581cac0d013188a6eadfa3d7b80b47d0aef78481e87536742eaad82e7839b3be8123ab6f345322c43324ae696737f25c2bf69a585822c11d39b530dcda6a9504b76ddc6a0df8d1a8692b22aa845f540379a055d52b01c25f66663f6ab271c8b0c73471a72297c5663d007b1ec9d25445b4b806f7e939eeea2186bc61489ba1ad1689308d83d4ccdbbdea2235452fa6986ab0a679cafed1140e6920b5aea51179b1d2b5880b9ccae7a7387f18315f160a9de724857caae7c956a2650c11b98e685797c9777b1f1f29e3966e33e8b1df88da3b5ff60531c8f4aaac5a6e9eb70c7569fb569972608568d2bd235f5ed3ba31e61ccb535ce5e91bac09b6e92a88bfe474d0cb58d29a90200ba24f9e3db3562a4202e1c838848051a14dec8a60e179cc2f2e631dd8ef351d7bbc6a8763a7ea5f06d4b3578a9fbc8a9eebe8badae53c072d6446bece83f3adcef5bb38de552f9bba0021c3b35d79fe1174351c557fca6761ca291523bbb28d9503e1b2dbff0d17dea4467127de1a6fc1498b0efa8524975fd1941df7e85185b2d030a8c3f336c6bd25b3dbbfe327bbd8814307d97f71abb8a6dff07397ecd8819828af2f769c970b64477cb567cbca222aeeb599fc96d47d020f3bc8a3bc480034eea1d81af49a1f4290b58c6afe25215c1e5b61daeda4bb92d39619529c5c553082faab7d7648617942f1075740cd288ba8ba33c5111f427858c95a6835247bb61cacf5d2f1eb96ffb4366b589675f7cb39fac2743eb3b62ec6a690ea950a280a54f815e0f76954551a8870618b437a2aec28c714d86b2e0423174d51fd8d23efadf9acaf5a04ecd7dcab47f09de0306b919bce885762681da7751151f43fe7321c1b98eb1803eee7d1c09b7d10fcabd05a33ff0467727d4ab548eb4f44b4db6c01c6ef8f6c18fdf4d263e0fa09afd0d072c759cda8a942113182981a8897b1554b32858389090436391e79fb28366dbb6ab5d231fde4d453692bdb82ac870aca0f8d2f4fdd497759d603a859c9409c82f2438cd1150e341d95aac3c119d3ceaf04c610251c99ac4286d05dea999880d00b902aff9343e0b7dfa35eb17dbf780f5e74a962ef73f5e523d8f7a1d1309f2b16fecea922518c05b0550cbf1ac3028a0d09df0dbd4f1e16eca101e764bc52524f72f6b596cf56cf8ce9f7b1dff4275e0b12a38500c8fc8a6e575f1aaea3d4ae8e5fb4d5aa2f358aaa880f84500eab80cf3c692d1e8eee7456c69f38ac0756ea0f4895d9cd2427df436f13a6cc6ce78eb0de64bdeeef10fda232527ee49131dca660391177479fd96328476e3e6c3081c82a568f9eb89972285ba400c322d9ebfef02c9a6b79c8b3a69b08fdacfd6e2378828407ae90f2dcc96beddec9b5836dc8531a4ba499e370fcd54af73c30347cfa831f1c0ae55c1742d4272c37cbfcd17e6ca6dda4c7f19a9cfdcee5522e3acfba9f6633105371c46f488892e59f70cb9de64a2b430d42bcc6f3c9eb1b22394d7cfffdf180e068a5df9c1e1e5f26c7cac673c9eb0be01e13fc80e19af888f4f9d839e44f201b73f526b8dba73c192b745466c7ebfa145788feb34606f872c6f0e9acd4eba5f8d01be8f2438f6a2e3b0c095cfe19d148a1a59f943d3bf6e81d99077c592da06f32c2d94eb30284ba3040574323680efd81af56754fe8f5ae18fe0cdba535ac46c99eba7814151f38345ec2a9eba444de1c1374d7aacbdb85ebeb24dacbd9531c73e9876eb87813a4a888b80d5977525cf553cbef041bf19455bf2725756d4f45fadaf76e3f1c63b463cd10fc34fe71c7b27d96697104a9d346460e2fc8758b9f49cd185286c4948d53932df708fd16f4938d2020c9c4a7ae90a2eb33776ff3739e2f00e48361455799a8058b4c159c28c36d7c8afff0cd123c0ac27ecadeed096ac8d4f0369cf977a0ead9e3a823056921a956e3e1f2509df2ed8f918de0d1124cfad407423ed54c47c5c383549fe2587a6e3862af9dbd478abe5c89fe1afb47727109be61cf2a6afcfc10b229b19b711d2e127ddf52c185a3b996eccb514bc6053d8467e078604950171fe7ab6f1b1d42bff8a033be44b0d891f2aeae435e111474c50e3d3ed085e3934d6f146c89e57f582b5c1a656bbda717cd5e5dba6a37e144aabe1d77385bcd4dbad6625035cd5d89c1c29a065be0f2c5d6a217150867b2f5086f3a5730ee431d1b05c55cb1f8c1ebbd3434320c9505a595dd3ac6eab5b6b349302088d7a7a0df2f359fd88a0a9c8693716c5545fdc6b33c7ead68f0aaefe09b43c44df47000b233fff94a4972de4a8036759015699b1139292529b05b91ccf859649a4745693c4d2e5485571fc0ebbe032eed8bd044e638bb0aeb99fc3aeac254f5927a8be0b5e07d930e943b4b6ef206b767726c324b2705be5ef92b63bf174bdfd30aba921c46fc35e6c8bc2de5b7a6a79d7ae90500e9cc5389994c1beb782ae67cdb992ab46c306420f153469a351f2920923343c51c787c390a65d1de880495f6e87500bb0e8bedfcdeffb5b2c4869e46a9d9731dd8a4044b91359637af4cbfe34e3d3fe6667a9a522bc662a3ea8f839154add37befe373c4dc6cfec5db6fd40bea3f638e88b59e7525d7d579d25517216ac93017b8874d65469acef7e55643e44903e9620311348a7d8d3d27fbb4d5e309ac3a9481504778f9bad29bb2e2e35b69df11a89d6ebca31eeade128cfa5eb7debd75d4bc6a7f8643dfb7357ebf706b2e4b1a0b8148c34956198078d87cfab6d98776b6ccd9d368767fed6201cda0ea371c923c55af3fad68a4e9923b2478ea4526c314fcbf2e3cfb9ab7e033dd5dd51c363ef586f1e6e19190bc5d5eebcdd021644cebed759bf3be847549afb99dc4070185a68f03464ab11bf2b592697a8b5483948bd1a65b663997d21ac584bb3a7f4b987679886ab0c6777ec68f6ea37d41610e9a29713778c3f0b722b8b2c746b4e7945bb4768f717054f52de485d11ad3554e9952d544be51bc94eb00da956e2f2d77a1e90cda369b7f08dcc9e28dfb61b507a8fb2e72e383880fb3b870e8fadcd2d58e89399f921ead2e7372a9709b22544ce9919cd14d662f2b88983048f6d8742fdc99261756b7ccafd34fe241e056d324ab64629b34f6fb6e57340a27cdb79e630f941d0f2fc4c2634cb16400d643316e659cf5eec6c6ceb240a5a999b9b56b382861af7616286b868847bd3ad99611542e9debf297826428ce5b20b43ea65986cd844ca8689b8adeea2138b15b1ff603cf1703b9967e20469f54df4d4729245bc7cb35784d4080a4ddeca363a784827f288e0e4f7caf78eaf4cd28964a16011e9385fc4dd339c6d53a0a278c7d86f6358feff2dc5ae4734c9d3f6542245cea09dd7637c893410a6959310496ee891bb5a38ed8688379c35fca1782b1a5a3d8771633faae686054bd6d7877b9ac07ae21ef8e9a6e3c969f93bf371e71d9cdb397b86f82a26041534b6a4064ce01aa3a41ee1b5d4f1981dbd5917a52a938d5848613a2d6e672c558fc7ee962ceb7c22e218d08eeab2d10154b17a7daecd9c9479051ce4fd84b9a9a000947ceb204e9821bc8e53ec0893829d81eb7c71a343d06e0d81dda1ace857430126ccadaa8f482c3f1bffe7708c6ecb3782b36b79ac8641da5e2da47b02ba0f2e6fbbd73707f85fe656b970ed3d05b6202012e4817b3cc31b769eb9c7b96b06d21bc6a19b37c19e5df2ccf35930250d4af90654405ab746446a015f03311bdb710360cd111939333fb8322ed024a4f81554ddc6ce00cb42535f6dbe0e4c65022387a9e74266ed96354456774e48fb6d8c3eb7e06aef31520808400cb8a15f2bd19de6f0d5dde57dda22b0805721530b4b08d66345653eb286f5713246bf082355321e56bd23b6877596351cf5661f39ea3f90a0b20d9b332977e2fa3f85468cc695244145d7811ab2e656ccc804d40acc26a4d945dd374ebac39b7e8d9df3c2f4e6963146aad5f25f4a050604d3e4d2651da44159034d1416e73c139cf04aec8c50f8bf46258c06a971ed6d42d7eb0b2585463d569be50b84e36b085845ded3562a8c553a4dc836dd5ad06d5513f858aec75b8a42be07bbce8c9b9ef0659fe38f107c28f472026f4654ceef7889360096bf01970f103648fe724fd875d6650db90f8a0cdc8c94ac78e71d4101667d8a0b8be23eee8cd0fad3223fede745030957dbf2367d89373e68797a4f3348360edfa3f1f609c966a1699277dcbebf3065759abbd5d92513b98d9ca51a8666528a55a788dda1ed95e49695a94949dde943d0796ae0d740597bbde4b00f68e9d37edfe86b87f2746be2aa44decb87a144ee87be9e9688b70957a000cd6d3f42fc16df62101ec51eeddb49eee5d403db762728e4fe6f67241010c7189b1bfec0c9d498e5c826ce22a289f2b9ccbea3e774d0eecef1c693e7608c841a0c7be959afe39bdb4d5b3cf382506e15f6275a1f38208695055608e3a9ad693ba002abbf0fb864eb6c172f9903fe741e2c680f4ea0a1ba4ea937d5f7063663de371854179f14e3324647173fe6ec690fd52a843498790ad368b5aaee88d4c9f3c8d353ee20b6e5dadac249952da21dfe35a83fd8a7b3fae93b60f3d676d89b9987a0e05082240d1ee4f585235d62e006136090fa9e408a13e33ca2ba6812dc057ab1ed10c6046376a28b17bb1fd90e0e9ee70b003f9edabeaf4b2cb961bb74623316360d89acae5da5d1fa23a5059a891678096031fe22556088369735a27cc6b3f7ce0dce54b6c233b72803f2da7581109370e7d17c47fe6ce37752e7a4132ed7d487a0b54435db8c8cac024687241474d1995337034d60ba170f61ae9ae5bd60c3d11c15b86c228955f41dd03604a63b8ea08bf65dfc018968d67295f5d406877cc0d7171becddb8d661031573efc6d53a31af6ec6b916688218de8b79c68c6054bf9cf5d21ea778821b7476ccd841b32ca86c1504bf163fe777a86e2440539429925795ba44f3aa9ea4e5cd7ac7ad519a7e401daa04735ca4c2478cb423bc7e56a097037b0c36be3a8a532386d45951067de69f6bee1706369eb777de258653e0d189c06f621f335f2597a494a13e3d988c07dcb8ae4ee05ebe1aa0b55c1b211ca6a585228138f1a6201dddfefab5e5b02cf5a7403b4d9a60a6e24d28af43f9c10de9f44866ae7ae807ea67ea6001c1b977bbaad12634677ecec67dde459eb0aa5e5e6e9baaae8718b3718b1f7461a4c5ba02cda8c64009bcd448d7e50830aa40dd97d7287c23a060abf7b960c0cbd01522e8fb8fc1c75a5ac40f6a60b9c3d17415907cb6c869bbcba2aab08885a95cfacd05106ffb72c218599e25be9e2aff9b4cab7b0d9900f9fe4232892a0675a8eccc1f4f0499c719b3542544b5d6e91e64a381f9e6fd5b3797b6e73cf621344373758e15e355be0729d6d51ce4b93168dae41f0efb37b79ff00c89ee73ccf545197957b8fcf80b0d5a76412be4bda3eb7bc123785403000587fc5353089b3ee01e1b0e0feedfde320364841a53ae8f80c694e18f08590c6d3f1029fe2b112563024c29eb7b14778e9b649655b93b832b623bea1e9216cf058f23a1958b9f5c387960355afb17b66a6e11de5ab85309f36141e312e9b0255db177422a8979e194fa9b709eac3c454ed82bb1ca815f9688eadd1c79f5b987de38440f062e093f9f960d616b3b918739b79779621d01c7ddacb6804f750fad00bb83bb0c7c78111c3656c245e5088b37bd32010109288c22ff42ca70b731fee9e1cd1631ad568957ae22f107915a3991113076e5d03e421620ff9f7bf23418bed63431779c59673fda1d41c2a527e90442dcc6d79733084300490202cdb0fae04216ae011f8cdf277612f3e4c8b2923d4415c8dfb17210f59c4125d849233d3a35a5cc43c5c9b671f8daf8c71a7612964268b63d16dc3078c3772cd360cb6c5f079e8f51ec3f3ee11c8c4f61366329fbdcb508acd139b07b18ca9452c33ff77032ac127f0daa8d0439816004a59c07d568c4234a6be646deb2d65a46680528fe5b05c1f4b188f8a4d22ce681dd37d30157f158538fafcf68aad65867ea5097668f2dba946b16dcac9385422718cb5dae651d27cf63080be57a675328aaf581a048c4650d2c91f26406783afb1fecae854fa922d6e561a7ff566c882a91999bc91a92e22d7866ce967d534edc4870d8d39cc89bba69dcbfbacd1d375a58f09c8e1d251c9d999301e5c7d7ecefa2d9bf467d0e1991a52ee88505a7ab8a6099cc985df05fc76b858b2622a78cd6ec0ad3974ed9f636ca4ded6912ac5f4046502b3f3fca96deff51a527e5c1d6624d352a30857ba005fb64b992a123aa660e197452508af0b41583320128f3148a5a4631f90bcb3225a7e1944d26f0d62a299ac6c1902547358191dc3045bd4755f99467b3545d0b8d8078ec5b93dd263e5d05dfc567c01b4169192b928847d62f7213e3b7a24119ee29b5b34f533966d8e5d80a726eb971150caba465f1465c3c0975acdb6e97b32cba9de97461fe114a88efe8514bd7d6945666dceaedfdfa7c0fdb5e28354f8bd258acf685580027d6e9652bd1137f059ee0c0ae55e13a001142950c696fc8685232567ea66857e8aab7feee9e8c9133acb864a3fd0db18379c9e468bdea12aa2b814e90bf4853349510134383d665a979d6d8ed058d05170fc67835cd7d0832c472c031f4d73f89ae6a792abb4c198d9d6968771555fedd8b809a83ce405a6746d29512dfd1b89f379c668a9b708cc809c62dee56a05c408552d6ed41992e5c67f728b955b346749093bd4b1861bcbf25c832d26bf926b33d550662f55f9cce92d3cf5d6b8ef9b889b11216ec71244b2674618d2ec17e45f7eeb64285437a0ff01ed8dd55eb72370ec81e0898d6a5edee8e4b950b070398049abaaae5bbc8d8f1aeb54d78a7c20ddc67740b80b9089ea132cb9223498eeeee7ab1cb9872b30a374451387b87e701b1af0b5e362744041f65b543456d3561bacc9ac83151fbe4654a91fb4c3ca847fcf4a42b1728e298cd0961ee0ef527528ce1f4819c8620bdec2949453956d0497e9226f0589e5253f2ae22f8632ad6f826c3feb9a524def0095a4c8d9c81244768dde634b0be21ec9ce0f76f4d5f989388b0bb632e10394fc8ef47ccc0a2fbca25ab9a94db09145a9c5905367c5ceb0e7da34921d77fb87c9204f7c78194d359ac3640ae5b781930d33d18f78ba04b3c40e3c3235e36b2a2830fa71953f38193d9a1ba493b9f6b6f19ce40ef909171f6b44f2f4cbf2f8a859d5b6f1b3aceed2370e723b0a35e625187b5f9261f4bea8d8c9fcdec073e3d62db069e443f6235ccbff5e2edac0d4fd2c41d032aad70432c82fda9739e9ed128074f4e627ac9b51bc18eb693ec32cf06e282bc3dbd4a1568f6aa738e0e5a6b283b0ac5f9409c5cbc5ee667b8102e4a7bdf9abe29e1650f6a320cf64bf0703db0ff97278f5f6f8c9cd29dae70d33afddc31f1e15a10f5d9b01185e9605a67bf540d45ab84caba805528152821e006a3a7fb937f656764335e1e149ec322cb6e18aa382b4d640696dd5b54284003f35ad7ddf40dc9230839fc31c694cf19ddfd7d9aced00c773d198aa36bab0ba5051895db24af01149552081354668272dde5e7c757c94bc9b2b671844b768ebe421a783e884c05c102ddd9b48398ddf56465d5330a343b77c0359d1899d558f0dcd7e4f070c594311ab9b0a5b728b5919e74239daa10818ea176311902082bf5bdbb8c69522214afcfb188aa5bc7481624652b24aba221760d17b4c1b19a87e5bed6432e7577c338b14d670aa572da72fe3e3264292e5f06c8cc250b14ca6b65461c8c75d9dd48544022d2c1e73a954c0dcf9a0875262f395bec9cb2e06ed1883037b95b656c0eaa8bc60250fa90b48195f7926ece9df6fa407cb234c8ad6e8f1dcd6a2ee91d3a4871d25658151c8332a54deb291cda6f8e99970c1ed6fb12cb6b45311432e0aada66963ba360c76dcef4d1b012007faa6275225f2abccdab98487525ed571ef6f4584e8e4f3acd765d3135ae694bf7cd6762d1da7b5ec02116fc4f2f71ea81e76184b7b3db059adf06bdbe90c1247133ab6657fc6b4c557873f7ff565c875dc6f463bdb6431b5fce2e54a3efb7c4cdeadc7d08341758098e0285110e4561763f356e9ff621d19560fd05719e2c4ea665c9e8083f071e6e4160e6c939c228e7fb90cbfc478a0ecd7eff7382de5c9b3d78a74447f005431407028f689bd60fd564e8ef6c2d1966ea76f401b44508904e64a6010db735b28be8a9d70e3b665b7c01d2917ec03ce8daebb1bbdb5bc30dbc7bcdea665a8b7674f84b21b7d925a944cd45c297588a8f10664fed09efccf0c23eed3adcd9ecf54f37a3634fc9d4da44ec3c959cad7787deda06b5f0411ef7ab2ccd7220d3d0d3007ca136bfb1d1b24423920354a1c5dc6536085c9f39bc0a8e2ec282088d709cf83b324202241c7649d223e18e0082b8177b534634098d37ccc104d03c08f18009797648e5405b18f431c6acbc464878b315f6836a1f0ae1e7cb1a9c56a0ea4f8d76e2d3a1c14fb0da88110b8b985709548edf3edc63b4c94c9e5957774e6ad89b231c167c82e971203012c0f7cf6d634e67dd87928e35a0e3aa3ed88ca052a34b051b34d1c0bfb048525c37535c9ab624038bb2ac0970b58d78f9ed6ba2b8031365013b37cffab308536109329b1bdb1e553f227461f4131cceeff62715b9d10573c4b8ee9b9c2f05c1029df0a4c13607e4acd996e4bca93665757a4b9d5b946fb625b9905da5904e87756b5cfdeffb626cc7284975025e121003182b40811147d8e9d3e8d93a0552a0b5842d47d54b86b26c27d2cd18f68229e601792e8557c1b809cdb81ddc4fe702127497737d5b8b3bbc7e0ce8c5a0887563948f961da0636022da4e1441cf473cdf14ee8412d6155e3ad70cc4591e7b5524cec1a55ae5bbc7971612803bc43c0041346b8bd75d61ffa725c3e418cba5b6dd1fefdd9c3f83f96241ebdddb108eef5ca975949965469d7bba31fdc12f8d9b3bbb801f49b5c2c67a0e098e3f390a0cff4ea2672797e3e76922e9e38cfbebb08de76a0d12d416f0bd0b011f7af88d1fbcb47a548664fcd5dfdbcd226a7303fa7a38e5aa78d72d14f058e4d3f9ac424289f923c0357f192fd848ed96c8ddab286d6073ad1dfe3630e599f9fb3661c620fbe005939ac4185b584f4b5f24873a8d411eb52d6b090b5cb27542a32984a863308f14ad43b68a4c6627129d1a6d7f911b22e1f3fbfb015ee78506905271d6983094fbeebeb860059caf06a278f33d149ba281e343fdbab42603aff32152a91c44a11409f14225b03bf8f0cb8b4b31309de6dfe6fcc015bef294764fa787afb451394236c7d4bc60f172895618ad175f9effbbe600a16d1be56aae7eff6f7e84ad1c016b716adb8a9197e5e1ab0f3b73e19c830bd9ad8f196c2b1654c7c18f5c523224b3bcec77b15ad2d259f25ab1b04c37663181d8d671af7abf991242c21f9f1e9dd5f7532a1a480ef6a4d48b729673f08c25784ce6e155038b5f129d626b7933f842afac4913d32031234e5eb3042e140eaa1ed9fe546a87b282bc4d054541506e6592621477a286f625db2b323467d17e9a4b4d9803dc2be02e140a7022f22cbb08ce4c0fb378e102338ea233d5c61b2e019eeaf83e8813bac9f69b4cd55a0ae5fff3bab44ba3ac1cf484d9d34f3447e1831c1ec153c37fffa975d10bfa38945d75a498ce2e096d2b75d682799dc98d86f2f8a17df92143358519d8257337316037ad567f5a6bbd7a58c1aa5400425d2dd483c9072c8cebf1dd9bffaae09aa551006bc57f2e2916df88ab97b570c2fd25d0b19b20347d3f4781d36f6fd8b9ea67e68e5b0630ada53034149ac47ffe8ff05277ec96f26ed5e07424d79ade3c595a3e63bdb952a0ca5215ae60a4c402468f66889a35c5fed4980fff41530252972839fd4b9cc3013d97a955eae46c5a13514799ac8bcfa36b4eed6201d5e9d1ea2ce7aaf897ee42340f8555f2666692bd0e11111b995d25d8daefda1fface168e6bfeda4849c5fa922ea2923691e0b6890f1b262f6fc4f2277c5a9c7e63862f42cc39c6417cc634be7bad4a60b393290b1ff4212866b3cae0044abacc99ed29f9c0795010f8188667bf7226c882c5543c8b560a3c56b7eb3b93a49f268d89670d4c1c495dca690fe1bb80c56b5043004cfaf0f8837d5463d8eb77ca1c174505bb86c50a9afa1db6ee183e31eae4b7935ab60f7ec5343f046ce5e65ee50b45c51955ea1de243dac14e89bf2f128ac03788c5e9852e46d6d41f1e4357e9ec3f4d2a36c0af509b4eb9b1f616c6985d9d2cd8b0c40c47b2c021f90d9487084c73b0ddc259cbccc75c33ffedee95ff94071c43406ae9d8ff53438962f4082e015f44e7b9dee14076f77bc90915443635ad8a85958bb8657fb442b5b6bf8aa039e57b5980ab5498bda85738940e8fea30d70a754f8c71f5002340be3652e1bd4778bd07e4e23759a9cd5db78b2fdc05eea2769e530f90170eb802255f42a7e29a49c3ade85746f70ba4a738398d4eb98370465a3010df3ce982c2678d9b08fad824546fab7788ec3aa76ed95b27239eea41b15645f44f851ee2b573be4ac225d039853f9453ea8917c9a7b9b314a3205f2084c844f67a19986fb83d84abb26367d1cdc153bd3f8c62773d11d4b2c476df01b41d0bd45dc9c024bd7f71d2b9d6e93480f0c8462efcb8329c1b0f5d9999ee9e663750804912a54f29eef433074b0d6197675b5f4313aa079e7d100a5e3dad73ce147e82619881f3b9a6261ef019c8741b63bdf70072a77ad658e19b722515fab1eb7df6a9f7ca3543e450424ade073803c7155b4aca02999a9c8444ead60da84f3b6bd1f2b075dc11d90b312ff7d35326bfac29b273b96c92afa33246168e5ef8ff4f3817e9661f18a8edfbad23d1977ff507a04540ccd65d19ff50fdccb77bb3dbb02ffca456d974ee923ad41177dc795460c4e1a692e449c2cb4122827b5aa3d7560528c3b83de81c55f8148d291cfb1adb5c4b2088ea970dd93a1542b4427ae8af7874e28ded73ee455008a0098e73c74d3b551d646401983a71a13a487a73c9ddff862f20b583ad0ad45282715db0a56dd6ecd20facfc057e95d906e6809a87b04129292b9f7c7a1b5f6db58196304f62e9e8edfbbcd1bb9615e02437758bcb2c3835698a7657e71fc61a0c904c3364d3cc5e283399fe31502a7426466118639ce1b75bcb0a389af6679a8d321159018a540b23c7225ec4c9a248f1d0b16e409eb55a40fc086b4e2f9b5f237592aa6685a03f1b44b2e6a8999267d262f8a9f5b3c34bea04ad59d4933d36759dbe88557c4482dfa2f817dc8932ae35855fa27e622ef9cf951cae181a090d0888a4cd99c294e8cfe620ed6ebfaf5a3dda1ba579a5c1ba48d1d52213829aaad995c28cb4ed981d0ed50bb3ca6e0b230550b63792d792a8481ed86ee3d2166fd4290fb5998b082c98c665e5427c84fd27cd9c4bb34c610e0f34e04a04564bcf74cc4e5d209b5197009b335999ccd0d59921c2d87707a5f9fd85b0c06648db17dc868eef1a6ed2f89e84c0a43ca3c7dd77aa911fc771df26c568bf39cc5658afe6de638d5e3b6ec5c4fa3b1bc319718e3d55f76fad7f247c97630537248f9fbd79b3f4b8f49da7ccb19c09853fb7998307841f5a0090d8048244723675cead382c70c57214024b035385f6d7057b1ce9761cee7d705f685693787239f715d56b6e8bddc761c894365e19dc39babbad14abddb8787439f86e620e0053e70bf2c9f1b201c1a1508afa8bc2bde40e5d073e5595cd29a11a726b83d56d71c7d7ccc175258afa5ccc05795b9ce63edf9c6dd5e609125e2b2fe9796a90061736169faf0eab8fde50ab0afd3588c101bc375860f7b7be341294cc0be570b4773a2c94e9ca7b4503710717f97b2e6b8e53437f4e832d43aab42550f26974d8403af0bc772c5e800be26174d50e9fb24ece6bc53efb3f98195bdd673c59e93e5eaf6ae40603d49250dcfbe2e045220d4a0d3ead1f400f99e635f695c0633ed9b795343985b642d639cdb88c531a9c9bef7bdf01918f05c014af64bd3fe9238915a09e5a2ad496e8940fd8d0c8607b914d1bd6a7ed54c55f2d9822c0835710ea38e8b73581c8138f91e823d1b0da3278f0011a7ed2929ddf5bb2b921a0c7b4fbbf9a4820e5f3d09f0e6f027526bf404e6bdaf45a82d9b6a8cba2998b8025f1ecc6343ed755d9b31dc4103c7f4f804ec16430c3644e467151d68ab39a2970327f90d487d40abf11b47410c1b5e98e6bad7e182c34baf19154233c8ead4f866d63b368424c9b6897990daeaf61ddfc57e30f924b4d9ec2e6fe3fd0a49d04e01aa2d62f2e6ce3d6c83eb173a00881032229937c25d86f9e9dca5f02fe5b07a5fc9b08cd63ce626a4594fa7c0c08da82a3df2d2e702444149cf3a0026886857d59c92cd1bf265ab6018bd2e2193e93fdaecf6d28b13c04df181658fd3cc906978ff659232f0df829b1cd4715f18047885d02eb7b469783e1aebe157a4526f1730c1e816199c681aad9a56da4aa02d269c3fe9d1193a8e8d6a7db43275fe01ba2beadad11158f799fc1c96f25c8e3558ea2332df06a3f1423e59fd37b34cebb8ea37d659ebe1af2d1e3801087838d4703ea1def834de40d7e051ffe340b8f1f9a3fd459415f5d65fb4d6bb2f4996ad5953fddff06be4730e49a11788855ea38d2b829052eb5bb45f6bd1ae3968108bdfc4d82ffb3cfcae61e0420d3ee3a827105a69525b87f2b0034ec14c3498c9888f24262b78fb54a379d25b79efda3847ac5a1c12382890329a1a3fe5e21986b1efe1166dad6153fff8b7878fedacbb5c68a18d5ae8b25306ad40788667f7598f1cdfa47e939cec96225d1cb2b8036a6c877d9639dcfbed3e0e0eea1451ab0e617c16a5d46a86ca8856bbc809cd3c4047c20eb6b9755ec0b31bf96de9a14ec778351999f08ad4d71e15e86373f9c3445b32b1de0e78cd39a24e1efd972b9a23ec23bab6619fa242b136bf269efd1da8ce73b8ef777afa39bd1e7b8b5c8fcba437b0adee1d9c5fed76e5724211164d512914a20048c2a66f1d4e176b6e6d5f13134c3d17c042376e63b74c1521e34822631a2edca381bf13c95141db50c4ecbc0306634c2e2dae01a91cf414ccfbbd55fee93d8fe2d1dbccfbd1b87dbd17d88f08becd6b3ae4ccba3f89ffbf26a155308a980b0447c0a58940e223505612f1974faaf3d1b7b2a243fd4ef56153f37de084e6c3f9e8e61fa8edc47941ca7864d0b210e37114f6b02a122e34dbf9db52d11aaa36d594bf31b9cfac3eaafe127a2b2e4ebfb934bc915be90e79ceb938caf8df5edf660701d4b0ffc23f42b26c7829a5e1734ab5e85f60b6839082a33c5726e28628c145d47b6d0543666041634597e5120d38f19c6f11f28d42d891997480a36e0637ee31cbaad7221668c8a8b8516f340da29d974e0951030d58ba9d73c0cd6a0ffecb2cb2a203518096212e2bdd4feb4759718c8508b9c33e1070fd09a3b237a30641bdc37e98e86184497da7fdaeca05303d87bdacbb61c18b6df00dfc391d542b1bc547624fe8bfe2eafc76b657cd4445f27e344745b28ae772431d4712aec886aee4ca96f8768279ed58dda4a35561817356d33c9841d507c25881398be02acb269ad9d1c94471866ead3316bde1f49e24379d64b4ecbd958063dc0b3e3598d3dce04c53c33fa9caff3a23c6ba3b8a7e4fb5c1eb59e6d9bb5a7a1848c8955e810b7928249a4f600c14813f2c0d2e938b878a9c2c4073cd6f066da3a6d1289d5f844b6574d7c9755fa018e6bcae0c3a3752c716f0998976016443c2b9037d5e00584ce8e13efa471c9dc97d59b6b03950edc53b7dd74a47c19a222104a8e5021b935424521f3b6852061abc245faf2efbf06386ef2bb0c0ac59033ef05f1067a462315463dda5a7140517d377c408e220b9f14464213a81ff017fd9bee0b130fb6906eb0b20f567bde8c6397e8931f8996f4f9c2643ee2df536e067611355b76f4ca31a2f9d5676ea9bca4524ed464a15785a4f127f8ceaa82e96571e90d9cc376b353b0a1c1cd773c7416952f300e9fd0b7be01828383b8c2a8118cec27e3e3987f5cbec2506bd6b49f262ac4f942fc2ecf8707450627be6b1f258a18942a884ccd810bf4dbdd646e54ec1e617c80d5ce0515be6d24a85a04df78b423e6d35ecc1c7567f968998930552360382e9f4856242ca2653d7c378a7d9e1d375b3dc0fc3e4724ea13bc9739ab9cb9631d76d2713b63d39f95caa10bf48a00c64f2465c4aae049db3c856ee02fa896a34becd59625e54e9451da3222ea1d45e246e3388b560c3a2d380fcc11ffb668ae772b00323db39381e9cd0a7cba5666edc2d752eeadf4bcdfd2372333ae138fab82adc2108f6e38239e8019a0c835a7d5b230719fa7feee5c0686251dc0c447dbbe309beddf12357495b5c1172db38cc0e27aebdff7efa2f0b8305f9251aa9672fdcc3500bbc827745ed0e4974def734c87502efe18e11432293b91c95e5acb94ba9de2708dee334b77d7deb8cbf2bb7b48842f6759156373923bee8b0b770f11f061dbab4a9c1e3c2758ea63c3c17310b6f122941c7354dcede73f3fe3bafb9ff6072b83542fa0641a62c431fb51aac40200dd13298e905ff1606b9b143e8d232439b22d59df8206b7c68293f950127698f1519a684d5aea49ded8351aa9671a4b629a2d70389d60092fec0b95c2e512698eee89b733d505d0004cf2d64534904e4b56303870df35ec3dfc4a921ca83f221e341807506905b89f4a6e6adc95810487b1936985976db2ce57a7e3e5b68d963125fc625ae82c84447c36a6d8a90c24b0c1d5dd2d23d413b1bea9a5f10c990d649b0e147c12ce14f9a877696df603c1ea5f849254b2d6fdf528a9c7c296bbaa8011ce034382f1597440f836f8f440c5230bab9f69b82be5f28a5676b0e6783160a0eaaabccc1ba3c502c1c46fd1d502e886e34b5dda616bcf8c210b7d8fd77332b012901e7df95724bffd6574d0175b59a72f32fbc7488e15db88871eba0ca1f1fc11cf10fb042ecc2f836c76d2b54eaeb73fdc4f28dd741a641a2a8bcfe1567389d1e97cf198472c4f3768178207c45d112aec799772f58a2062f0ed18919c58014fec171c51a672d5a2a18f13e8db6763aeeb51969020e9c4c0a263bbac69a26ec2d5136c43e6eacbe0f18a172f28b903979cb57b01cfeac4b5050c5158bc2cb0f1ce96d43148e0c40b5973b1aaca97b72bf826b2ee83b6b8119b426add7c6a24e05392c5daba560d7a210578eb32db796abb1bbbf65b9605357bb39259bd7b4d297f44b9cfae075bbfd19c4f0b9677f30025f996f4b662e15ccbf141416453d0c6171a1c1604aa79bb31de5a22e62e4dc1ac823e71e00d17d6b08236dd329cc4c433f5b7ecf0270a2159a636a0e3e1fa846f7365731c739a297cfc6406c136db018cf6c6288c2cb914075169f1c119d06a4e096daf686d4a75b4bd4b32aafec88ea384d824d0039439e05e4a05a55a64d3ce4cec9a7e5f2b0ffe276b162549a61098eb45daf0852d0c428e999ef4e93bb744ff3d6fd49ff1b3060e1c68e3148ae9a5b036abec69bdc98ddcd57878e337d79957978c61e051b854d9b503aeb9020226cdf7421efde6a4d572b7c13d880f1cabe8c37affbd47d126b0ce1aabb60da0ca775f3574150b2974d4e1defbe5cb9d7b15a4f9e570a5cb406bcb2c86898a0d01c892c74246b7c45d7bf85fc0ffca93c71785f7be53faf21fc201f545f47bc300f45c75f1ec3b835faa1c3e66dd719068b96a4cc94b4880a1b52e2f7c0c5e657bcfbf835331f24414efeff2b89ae224d95bb833ac88d33e89552c4d1b114c65f40269be8f5143581ec2b54d80f17e29481fc87d992ed0c281bc09776aff4261aa182248cf41bd22e2c8a15be8bad92c104d89f66d4cd660721c0526ea80f26df2925c1ee80fed729709e77114827ab8ecc6857a81dbe620bab24fedb5b8e5fbd95a4da2bd1f1417278172e455ec343b5573842c1fbc5d181d7f8b916f8d023ef7a16dc1ba4f2fd3fa3293398c39b2d26387b2240f4f256d5bb9c9aab9c4ee88a1cfa4d4bcc2080ec1dff78b86825eab745bb1f6eb13aa100c7559382676e535191cb27fe428b7f1e17ddbeff0da630cde9e63f6005d2af9d45ed6550a86dea76c31ac9141d0f62e66e93de9dc97d879f505e3c659cf0a2433d18c9cfb2655c2474349ebbb883094573b66cc9f401e96bd4f6b8e2f9357142af48b30c062dcc323ca1ad4a162f45b09adceb072e3e700ae75890244ff2052b9a08a8cb76294ab4d0cac592fdfd552f1c7b52ec00bcb612501db2238566d9edc754a74ff1b86a72b2610690d5487a459a03a6da36023d9beb95a32919b94ad7d3f235aa930469663ed8e9585b00727121499350026239e35bcafdd3062ef97c09843546532d01fca5217692740bd2a46cced92dda3408ad3c3ca05b076943c421a8916e26fd46144bf4bcd52fd0a56fc0325416f6a4beaa6018525d373e9ddfa6faef3495bc68e6424016518223ca2734da151855f4b1bc81d78a477c06f2d18155e6d3c2119a1e80db4c8f66b3869f2c8c9270ca854718d95c0ce743c2fad7f99cefde37ff7bd434f5eb25d68b88ad2c39253864fcc169d589925cc9879028fe06209966b53fb9b8dd3e3a45bb4a6dbd0ec5558f757f92bfed25422e3233c6ed78d6363525c4cc4012defb7f071f63a5eb3fba8fd511a485bb99c4d596a0e46cabe4e9b615e479de2888c109eae783d65bb37150362a4338800224b187e0ef74f78d4222280bdac48a8cced0af588ce713aefd6c7a33087662992ab945041b843bb671ef40b2e6f09a03db29e6f8d758a0fd281eaab7caea9d5aa7caf16c19dfa70c81423a0a835104a20574f741159c3beb314b33b5a3e0ab0ffd94e7cb65da6ba61653e5c6ae76afa2c8d3d3d371c5c39c94c6e6da736ad11c798e9681a5c01c86a043f367cb8c77c8aafe5a54d052ecf27b592e188f6ccc1cab3bc653c384c7988d76d63e4c87407da90aa7e3135c5a9d6fa4d1226af68a22b4b3881cf36044e2c0313941703490352dba86a7e0f15698f1fb2e0d4246e07bde05562bfc33e879c120ad17ee9c86ae94a5fa922ad97739e26c1b53ec9e6746a63dec92c6c658cb3ef48b02918642812370105243cd27f58d4c9872c1817a06902760451232c745bab94fec9b9a39d8237804702782b1c88a8fd197e5098a4e1adedebd1a7ff637b4963d3874abe97c439f2916d88173547657b472b68697f271eaf0c81ee00f5715528571347306d03e33f0ec849d014e2536a93e931441758487026d9058e7994e27aa86da72508f36d27514487be5a2984e814e81ddfd53331f50a27e2fda3dafc35ea5907ac69f3162b689244dbb84d50d42c5207cdc14baf0d1727f2cc3bd25b924fc3c3c7087ed69e006d4474fb91406a8f6c2c7cc9de1fac1fa8375c963c5a8be86e0398ac487dd3134dac09a5d3577510c9952815bd0939eb7628eb7ccd4cd3366ede0dd7e5229a6003ba7e902d2cb29ce61253e443214ed03b9fbd08d659e8fd1bb04586a1f55a3f726f04515fbf6bf39121e14227454c1f2e7738a83b8945b18b06d89ceae929f4f288f75582357b53d81085f228fded","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
