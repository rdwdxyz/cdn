<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b3b80107d4207449b51b6fc65a62e5874778683467cc6b8859a676093bad1b01d28aadf66668bea95a62960ac62c7175169c044e17c240c105ff6bb3b9766482b3c4c14399708a18e6abdc6cbee67a99cdead4c136b9a10b03c4d6caa39b3ac7e44a1cffa91ac246196732fdf181458773ccb3a69b97e0f82529ad190498b75c65f8a0d9cb13ea54d583d96ad00bdf1949c3adbaf31b7c4265bc0090e78df0e863a02ca0229ba1733d845d44c79baddf8c7542c1166401417875497be0403344abf713ef190725904818e914b8941bf932f633c46a67ab37150b63b48578e7b4747c9b5a165ecca62635599c6d27aadb977e502414e1675ff37e861f8e6bf5378fe67641f718e9827ef081881c172e00088d64fbbb2763d896ccdd2e51f8aa0a203eed7bd106f51dcb72235a96faf20745b50704cdd37df292b6d52c0d5d0a6438df430505c272d4a62bca79c47bf19497d9c43e17dffeff0915f086fdf2871b5ee8b65951f1f23950ac52e7db6e6e066321b061b2a32e95dc27c361a93e9393a6fc62d0b32200cc5a9ed8e71b2b58548782b79f8744931d70992b66bc5a62c6be51b4c49aec1be9546644154127057dce0db1ae76bd6b5f74c7a407adc384e5f57df1f980a5f3b58365560b88f04389870ce6f1170283d76e61918079a94699eaec33a5922dabdfccb8a8d6c236a4fe9dedd3a8385f5e01946093ec034c02663c439a48447d0732c37637d3110dc2a1a6e3c32af76547200fbe1cbdb3f984b034f9adcf48a0a8536e2506f401f7b99fc6209b79c11be3349f5f5660a9baf9daabd9b97cd6c1742731ce4c4b82440b79f78865352cb646da6810f15ea6310813d13a4d345f414ddd63f3c1e67624e42fe72b299f5e3a9d6d11ef6f3a46c1fbf2abaed2549198aa264b797421671e545aafcf2f794f80c8686f8415dab0b99ee819edb3ad36931fbbd355367ea9bcf5e27eb27470bbf2c50c20674f9ad135be47e740f3802400638a39c02cbdf653b18372fd2e5543d38df11753d6600e70011e8ec28486525dc47d639d4f141c411d4d7260765af61df52582c39c19933e7e2f94e3e678410d5e85c604d82966adc5220ea477abfb6fe8840301c8ef562a5f6fe24eb6fcfc51f80a256a187da2751e115cc62bc33afdd7e04cd8c720b3fa6cf4209df80f8ee3a39f74056556f0559aed6c33571be63cea23ada9ddf43f75b8b3f7e8ac468303146b4cf39d15bc4f0c2790bece7e62af89c6932b97a318e33b20bf9e1c130867dc596aecef3d21a64fa6e7e629827842cbef01b989b73af2d500045914662ea9df9b6e8bd156b703e588c7d686fc97896e3e27001c8037872293d2a889995ba1e53b5d8142034ec8bb38544344c73cc20ebb83e0bb4221fb286f044445d50f4ded40a53d1f717b015d8281c148be392b02318fde361bbfc336b8917b38604d00c82b0e8e59356db84d89646f6abd2652f1ec77a590a3cc835d41ab210ea26c1c3acac09fb72929715a8fe7b6d08aa7dd068d42cf86008fa859e8f189123cb0912b7582733bb0fea86b264116ed2086857f18775e7e90afe08dffa421d26891c2719eb5ac6cab1da5d9e75ea2d304288e170edc701e46d0d72ec3e9e789a65a1895749d482e5955237d458a89bcf0138b59b94bdac148a01ec8f2e1aa68fdc0034d005ab729fe0db60613dbee5977b097bd3f2ae258b371b99d399689b330a2de5bcb7b6c5cf31fdc5e8db898511cc4b474280ec48084d04aa969795b2961f00e57143ad2a0e77ba050078fb7d880096d495340940dbe82a96a6a004df212b3f26ca854bbb25d96cf9b194b179225793df06d9d71e5a45d0197eb663f489e3b6a0367e51878b771c3b7a303b403def94c157c6fc696b02aba2da2ff42477ca0c94fc99eb200e2eedc95fff3aa535dc0e7f6fc92ce31daa48d72038a2619dec8c9ed85ceb644eedad7af2bf7f7f15fde5dc0a0de0ac886a3e490d3adf88f6800f04532d51732c18b72322f920ead9ca49607cd6b39a1c84ea1a37b1d23bd8b0aa501c76c898296fd2644c5b8c39e44cce971d96674b0851c80aa98087ede4f800ffb2132e34714faea3627fe6588351e4a61e48329a1633f86050be18143e64ea7bd9e093dced56389abe182ac10b8f3ecce64f797c66716296b2c3095192b7df8c96b1e05a5ec3be069be23376989770ef9ea7aa24205cd64d43936fb0a86bed1eb5215b30f37c61d8539641506c81b5b0203da55eaa2275901cde604d60b171ee37dd1652f3e6bf572f0620a4da31d6122394b9bf4a6daffd8085614380628ea18877c4d1860a23e41f2349e3e46f77c2dd1649e46af5dff03ba79784a5aa31cc62d55233dc57f0298874863dd89e2e788cc78f5015c299782a100067664985f8246bf28cf19691ba7b52ac53fe8ac63b1027ef77efd268067736fbaae30eccbd7e76f8582de987d5c65b617143fd7408659951b81930bc279b826244fe90999eb29dfeb4bb30e6d589b3aafb12e244c8ad45f77cf8a451a6a4dac2864b6b73509dd5de5c53e5c09ac91a679bca4a43f677f3fbca1ec72bde89a1d30466ceb3a2f8b919029d23fed41b46e4c68da0fc572ee81dc34e5dc2e6a5f2466496baca16daa08b26609149d74364aacd866e6e03c6882b98811efaaf5529876784700b203868ab969f170f661a8ff5e9c9da34c02c49cf1b3f6aedcea20b8eea0947eba9da510897e2922ca66b2c3e69a3f7eb621d4dfc2da41bed3db80d57ff78aa4f17876eb0f0f51b9c15848e2b9d437670499fa94ebe6e0477e75ca9726657b6c2ed1d9ae9addfbbd05b77f29774d2ad0025a5f5382bc9b507ba0c23a6a2b48f7eba80b45f3143d44452d89d07af9c49b075315df5f9c17690ff28e29b97925d45e706b306ea2f142481ffd58e07f3926e3dfb4a0aba1d98fbc643b1c33e29d70b9bbbcd23515de4513c2458393989fe66a9308b991046419f250e398a9ba491b7f7f6ecb627496218251c1f72fb03b66cdb26190b1cd8857b74998d6a4563448dec5e90abea142bf43d05e83e4fe9afb74147b285795dd526b3a4f8d40d5bd1a6f971b58701e9ff3a38ef52f82e6c26f5394a35738729a1e6e43b9e77bf0a919be9817076e58425525651f0b2ec0143ffaf15a0a3449daf14ac6d41576aefb55d71250b75b6e7ed0f5ec6f96baf05a2d5cfb1bbb17322d18b6c24f14eba57c5879477c0ac82f4243459083b670078f93a5174ce6334fe86d103fd48f458980933775e99564a101a032511916ccb3990bad67249d0961f5a93c24d01a8be02041a054a15de558202e61e88cf90acaee0db02ebde9e6831a4b5e7f9c3ec27ff0c96cec52d9d4886490bd0b4794e078791345444a68b0842233a92152e3cab4e59d596270d2e7cd4ef9f6258cf7413a2d197b2c63c6408c3ed7fbea372a53c8c93c698474b57f3ba9e681721c8c2fccb8798cb4c3c6a8376c2f41c71a26120906df2ce7dcb682ac03fe405da784789187b39c4126697d73ad38cc782ad843375bc603b2ce8352fc1e11f68c8e74c325acf41716223d2f4fc398ed46997f92d6eff8e4ff6ad8831a5b51354737c20ddd2262266a50486e6db8029c83319f818e1d9b73579b63be13294dc893fc0444f1340dda40bd4e171079602b0a02e493ecb0a3cc960c6bf6984838ccba4a57f7500b1ea993a1227b0dc756994fab61543adbf7c758c674c8529d1d843709b13020958a3c496f169b68119f9272999e73c940e2487cf84c1019d5ebee3faabf88eb082b662d9742cbc77bb738d9a24b72ae6b13fb234cfe11b68b613376c374902075d883b2cb762132c5e70672108a4cc7b8e63db05251f969b5ec3ebba6cfb2849423dbb30c37f19972cc5dc9f6cb907aa5d6c32b411bfa30664332fc253f28c4e7623475f080e85a16b57185bd88d5550eddbb47681a2a348e482f7c8d37c47edc1c966487cf909134fe7333133608bf8f2b71cd46d093616586f97e965b5747de09524853af9f48d8356d2445f4fc7c66203743a612bbcf9e73f867cf25f9ae802e8b8b15e2020bc68e4ae7546b83abfc5cc406cbf870d404e9de9d5446a90fd908d77d66761e73032f1787581f1cbafc2a5769c764632ecd8de837210007535e3f597e8bef246df04ca97d9ea02cbfe337adff8dd3c095f82852bd5a1a5d28fd9aa724fb54484dab4af3e493391601d3c5cd593068f0ea0ed82b0e85a6489a64ca02ec858ffccc2dd197c47fbde69782d2936f2d5a582cb773c951b8f64251b9efbc39a0336042b4f0ca4be5d549b382504c9e127e48811f0be84bb66fc7c073140d050d82a651cbd20259e499a15fcfd921a9034852d79c5ccbd09c74afc7f92ed17cfb966fd985bbc3bcadca35327be11d0b64562d1b25896280940997f498fb4d5f38c6542610aa224e38f1c09097a98772aa3a7f54d01de4dc5289f4178f07a91e8860e0fb2294cca971409161e1f3ad7caca6f195ac8aab8dadb1f806df9f6b626c45bfeb5508cd3d2549526a05de515724d0bf6e11499b5efedc8e748bf1b0578e0102f62aca03357d3538387afcdb6637c4ec92d42bac4f59e738baedad3d6479c7bf2209feebd5e13ac61785bbecdbc9ccf4fbe5566e43dea815cea8356ecc84456ccdba4c1d91ed1278ecc48eb956764b321e6c34e08c2b9f2e50b08b21c9cdb2c2a3377a66ccbf5827c90d81be6e537bf77a45a719a6b97c8ff3aa43a6d6d831a326897b86feb67afb27dc8ecaf6abd3eae07a3ed780431c7b835887c61e438f8901dc5c0f20681b7679bca721bb47699e7d6a0e373ef34b5751a60ea224d20aaa8956bca8a86e38254441d3446155c769cfe31a1ee19c07f93881953b86fa4b3ac5489bbc6a3d86df32d07b8ce3c3a8fa904ee1cc55816dbb5b6c9a4705e310b459ad327f8a3268b37dfc986f23ef54c9ddce6e0a17bdf25820d42f803e98a24912940b098092c2b856d477d4216c87fb6e5a00adae5744d7e25886a15070c71ba2fd3dd9447746ba00eaaed70ec17816d24b127680d506cefff0c9c2f3e6fa5e9e890252a2009470a48a5d55e291381e35d8a655dff405b981a90c8cb32d2f7a9007e840e37dfcb01c0b53f6e64fc7c643873a74033b819114498844cc4a32208b11e7058075341b223a6cffc7315fd192dff7bc0d56b4e2ab53959ab52078106f82b6126497271b2b8d4a03f2f4639d687deff646ada572fdf7d494e8cd6c85bd1ca6cc0f159133b4b83a5a9562a65ddf0fe716462c1c3a3da0e90ab898878b35642ddb30d51af07d6f46faa59cd01b48e2e80f70988288e593c8065d666a51c4081cd31f0b829786f0d1876dd88612272bc1ffc188b372cecdf6f7496ee7336f80aed6383f115a4000aa90e4cd1f44e582141c7522b7904693dfa9da1a4256c5e324d4ccbe29c86c75f3fd47b5e7063619a5c366b5320f38cce1e2fa7e42b0d1bcca487c4968d7bf21dc478dbe67b6d701a01955ef5575f2db709f04dbafad712a4024b4369ae0cf817ff4769741153dabe3af7dff1df3a3e1805f03a97ca8d64b82f7cf9f943ade139f7d5f49e92a89d782f8d07be27ad6145ac0d80baea68527164c18b33738c239b0c24cee92dca4355d901405389c1fd319f559410b292affa716774caa6952461914e242a21014f9c006e1a4f65e038077c0be2864e18c832926c32878519c86033094859718a8f0c7f6c9f24af22ed8bbeaeb1febf11e152d76be60992e0e6667a05eaee9110827b39965cf02ccfbe0d67ac42814ed851303a446a4f7c74d39da64114d2a50fd9f0620963782790e37896f32318e97ab9d9df713edb72f53e99e94d0b2a1df23a6811ccb5eb116668f2cae810eee230cbc5ad196e574a1be00a8eb48d2fdaea101848af958e0ef0961c93f378a79ba8b30541b0ddaaff6807d19818b9162c65f403c0409ebacfa1d43ff655221775381cc06308965dd201c598cd08eaf147749a04330077afed58f4e5e18844fcd18cac0f33ce49576b29803e2ba0c1489bb5187a9d1c5261dd2f9bdaf40d6890dddd46139470cb5f3d85e059b3c6e57bebc23c83a350949f649aef79f07576ab09ea36f19ccdd1c9e1aea342159604c1cbbe08fc6a21adb0088b71265bcdac2ab30c4cb7809489bf6c05956c069afe94c9359ef7cbf85f75157c1dda6ebee430658262d2060869cfb2b40f949f2f7ed9d9f135004c3097dac2a2b570a07323fbf6140362e5423c0b3e2c1044166c1119893c2614e6f4eb8d9ef80a708028b72aacc17a46db415eb030b1cc42dad869a6b9986773cf598f9394bfff1e905dcf78ead808e01014560ac93a41861ae9b94963860557e369e50f84b3daea1daa5e255db4634c4bd951691022d161dbca80013fa13b628db56222fd2921281b31abfac6327dce8ef9f7f1d9b0cbdbb0dd2851ebf285e909be193d2511e6701c1384380fbe9122bcb65142df7497f06d417b3f4eb41fd0f2c19cb96d080b7057b7b11a63fbcf948fb40a92a38009d1680457bb69a66143677eeddbe9dc29461e28aa5a2e1395bea6b0ed4dace0661e3bb5c75c574bdf080cb839829357696033cef675bf0ad9a1f54dd4f6c6ede3cadfe2f257345e9f069684cc7b4e882e17b9d02feed3861e1d47abf2874e4bc563c0eb8ef20e7d5b5e72bf7e7dd41f9608508ab59166d8ee8ae6a2d38e27265d40a23b04ca223d242db87ffa2524bda508e3877380d2d995edb89db4b467eb36c8d052a2d96a7e5c82577ae4223a11b4e84194cd367e3d1a27b8796287c53787af9fd4c5e401df179d53343dfc0bd80b70a068afcb7e23632d331d0917f319a85a15b7a862efaf9c70da3ccbe53328c10a59cfe1e0ffdb342eae57e7f791df68ebd848e2461192ff0114be6e873be137f2cd4773a64af48efd47ccf755a8347861314a6da92c93f15f44e965b1a70bb7bc641354c2b23fd4d4345877c40380572546ab40e7fb337727fa6fe51bc9333fd6d46d2d02e595476e5c21c789009b7424fa53421148a5bc20325c223d436c0e909275b9cc64606215b5d66e0d28eed6677acb3a75ecfefc2ad2088e3e8e1ba55c41f70cd96e5b7bd31dfa1f4c55db2b982ed7098ad9a59b71b231f12864f72945440b8e59fa0886184035c0a171b0b24e5de50c058550d6a591c0ee608144673589e85048ce181619f851b4700e8ec90a8b980783d91235d1283fab3a6cf85c6049271c76f0f390e6d895e27d3c6872c7ed6ebad445294a1c8f9e253761063d0f6e6948cdf7368438bfeb55e7e6ee25fe9223ef472ec37d8c669d0ec20a2e8c490730a83dc010bc3427ce5a66754a5cbe33a1a98ba217684df5baa5bcab20bda28746fd50b1e0085555fd3e6b2188e3ba638dc9e7007fcc6374180d73b06c90d65ade6c963bb0cbdc05a458e4be6c831759e058249b9da145730dfa3995757a0a01a0ea645457a1f53dea50b699124099534a168a8da2974af66a21ddfa06204ddd2e4d598acbc20e9bf4252c642640648fdfafff171ac105217aed4679d1b621fc4fe47755724ca2450f601111691eeecea9fbd133ef8b3a5a5ee21166af72229d52469f520fed156841cafd9ee26a04dc1d60012ab72d1d721b9c8d801ea5204f91b96128eae3de65f2c8c1f6f72c01a994427d1134ed28e6e34e19d69107019e837f61e7d6ef6e2bf2bed3d45d583bd9b06ae11f80cf7dab6d52ec2e218a8ac0c300bda49828d917ace71ef7c3bd334997f18eeb439f817c12ec39f15b90eb9943a3d33391a2284260556037f93ffdc793f7d15ec5802ede99ba1a0b3b164f3bdba13317c7d5d3aeca8d8a201d67d12403783c4cca9fc4ab51b740337b0d6a151572636def29934fc4ac8f048230f2ad6f096923186760f5db4a01dcc3534fbbc44e8f6a9867c6356a94a6419f6714dbc540fe17435f81a6d01ede501ae3cf37104566d530f33511786cf1e3abf9c859684095acbeed8d2a3cdcd7be075840e070213d1aa2cc198a5d47f96e8b6632f7c5776ed66c7fda24813bc5f8ced5400348a8611600311f68c83622dc54117f5c3baa6088c701a7c0521a26d296c56d5511e8e74c20f0d6247a6dc69ff9a81be896dc2728d019a5b684e00cc3c349180a3d04bc8017081f068625765245d16b488b3bec43cf54c2e561d7243a09713976aca558ccc0a040ec23621ff8f7f14ecc68e14dfc04e63911be2e59fafc09ca6b4b50219f9aa23c91c73da0371564aa820e0334c64a19467f6cbf497ab81db5bfec2d13daf18c66e1227e27407b33fbc0ba012a98075b95c15fdbcdb6172106f0dba136544f07a05d9518e1a637fe1df21de9a97aa561fc406d6168dc0c2ca613e1e7257abf09e925abada00ae23beca52b953109f9e50e49c6af7f51110f96a97fff63b956e5901295b2a571af0b77bd8d280c5e7e63f4f5367809d17c1d9fbcd9cc34993e16e36b71360b549502275f04be3660e8ca1e48d8ed54944a38343e5d2bcb147a7deeac4b3df048c99e7acd5ddb87bb08775b9f5754570a65ab919fef1c9624d17b850cf578e1a2f129e58977b36e8e1bb29c86b167304695094173d624a1dbf7186fa33f060c9786db88327e86e62023a0b34a2ed72c9e02ca5600f4b7ea020cc3660b289e09fd23d4ddd5232c64239c27e7eda8509533464f563871e22595195d28cdfda97f0c0d96e2d0bbf49d6f166c66d5b25a29fae2a28b7a12be81e1a6eff4a70a1c9ad5e628aa6de3dcb4e8adfe8c69b8707b0cd407cc0cc3f4e12898fd25a668c8b8b5b97b31b4ecd8419df6deb905617c229a072eedad1070d9ad87300e5c8774084a355ab574a20fd8f9f4e520f75973b4f0760b41743aca524e24f58ebd8e50d48e9b240be18ffffb2af0c85e3b740825c21822cfbead1fe05b4d1ec67b37f8798f8bdf74bb73c9e648cbf91bfce1f12e25849596a810402c76daa6ff74a1c43979f18c9768b82d527b21b2c75ff25c7235c955128322f3f14578cf917ca71499c84ed9686b523bc379352ed7f2d313a849029ee69127d907b2fe746b53d1b43122b1e139ebb3c1cbaf74ff6391b54af083bf6d2e9e155b4baee8b2d10e9526fa8370606157f7fcc9b8b02d6c9b24cb003d7ce2fe21a1ae902de698c2ce4cb99b817d80d989e99742b5989364679a1e2bd4ad27686d392ba9aa5f6967a519b165158710d3d21962d517c5c1f304ff775d8733239ce6eb643241931d461f81de7abfdf22776f8985d0dfd7d918f7a73282ae7d2a3b1a5addf2507893b6aa2f32a39cf57422327941974aa515ed4702b5b794e99f90b5e7805f69bdf66dfc473674ec40816964285f407c30d45e9c78e8c2479141a1c8991a29334bd5568d75a469374915adaf9f20bb9721f909f5d76ecc828c71d4c769a31bd44dde72846ea018a5cbee63409795626f8c5ce9e56246369b67bdd7570742b5b40b8a5dbf57595ef8b244da71c7889ce1a5e091a0e22cbbe764b7dc311f0a4f13594f2783e6a28d39bd7ccefc0d3de6c28cadbb4098f10de9eb044bde31e3bdfd4c43228a86f3cfa8b4a9333d28c8835513d4d9aad6491845ce8e234c0f2a92a77aebd869eef2c353a8fd5d9f30c0e2e8137097898db3e26b3df9b0832615c40faf889f39661009842101f6266f185893d206be972a1165db2f365a47609a649ba78b8382da77233e94921b520f2682def1f3a68a1cf789b2eeee82591990ed26a0eec5b8411f2b4d6d7d2c03b3c48535c0c0756bd864920fd19ceba8b574088de7b7281c7241f0dd561c5176bcb41ab555a40e6530d5d1f664b1efb59433f03e37fd0ec75dcfe1ba10f445cfe149df25e8596ac2a4d6a1637ae80f5685adb085b1bc0ee40debe8c3bf93a79f8adeb6073c4a5546d10c1f037bc06305c5b90fcd5dffe5d5da2569fe8ad9ac6df391d70385ac9a20e1f9a11b6e61b7b003e29bd6681f73f605bedb89c8ebbacefb7355946c84631ff1c43fde3e1acb0a577632982ad281c776ca7bbc761c06780fe787a63731e2ce0a130fb1f907ff03a570c0500292f54f95375633bf45bf4a639cb792572769e5219350a6c4c11802f0d3f5cc92edea25ea5ec9b4b0a27de5d37e052ac5c0bfabd2486ead1ba4ddd66a2ed1fe5223c9b842d47d59a1ef34c65c06d9abfd7231e1e4643ecc688c6fe7f75176bf0b0519492ed3f5435b77ff8077efd998e1ae4a490328cce117e603b60ebfee69799885cce64bbbedd8e10098895b596f0b6ebe54794088afc817a8bdc4c59ec7830007ff1e0c3934f46b9eb1ffaaa7a8ff3fd8944796b8f9a18320c525ea8f652c2af5bad09865717971bea8abae362e98758a8eecad853140b53078462ab75dee2b359b8bbc01ab1f74e8d5a1ba387fcfa0f619f69d0a4f1f46fa2a85f25f5cb887ff9f2627c94a7be6ddbb52e804c3ffcb524c017bdf7d7435916eb50150d1de66134724f219ce3b743517678393491307c212f9ca0f1180adaccf2d6d0fdc1fea855000e45c9d1a20b1cfc36b63e2bdab2e25ca88fd431edb65f9007849ef7f1e1ddd060f874b92b9d8fa39e777404e9158d3f7a8acfd70e335a50f934f45996f3503fe3d8afff583343cad41150895cae470378658bb2020be5cb05e9f3c2cba6601cdd88ff4b0772451b664176e0418f04d71525cb03bb0093d5dad103dadf7bc7ddf3b753c9e5b1a74f46c6e39e70dc74725e2f5320c9256eb34b49b49728accaec2cb6e15ccbac848a6e59379240cab00ca93bd70daf1b66d29edbadf8b363915a752d0992535eaf631fc7047f932030d83bbeb2d4ae1329fb5c316831c54038f4c71e5fe612655f7b43a5ead25ad5b1f983f2fe33f808ec1841e739057fa378d00e2f2a3c88c1955ab69a1998f9899d39e1a2387f1029b8f6898e5719cedbcbada4351313ec0948565fa14d182d9c5c9015dc2d3aa5fdfa051e61ff26506667be6280d3ba6eb2cbeca9716ffc4876590fa754741b4dc6d058dbf410a290a302fd657e839c6f58939d73259d0d0d4aba58ab7de7c1676732f06120cfa8c703abee1a49ca38ffd94f1e40723f8dfefd33dea05d74a69ebd4f7e48930874590dfbe6a10f4e70e09d27f6f18af940eb3b761e35c91f83f9d78568ba1d1a99559122af564a0ddf06b68312ec1efe9363a77b43f65c3e1b00b20cdc3470043d87e78ceb3b6808564532404b404abef14eaf00d2d7310b43738ef1e0dd5d1fb99bd17db59c76397eac3825b9f73f558ad9090dc1283461bb10fdcd4e5ae5465742c54b0aa171a5d77238abb9aba5a8d34f292c0f257a6afe5260c5af8ab66361d6fa35f1cd5f8c945bdc612e9ecd5de1a31f25e5c034b24bc109157ad1428d7dd717039b5d34c0ea2450776e7ff6fa50c353059416878efde07ad95a1242ff11b3ce900b19ba2da6effd53174a35ba543cb566c900031b0f10d4cb3d27eec2545cd8f2f5e7043362fdbc386330a71fe518f90aec1173746d3212b9ed856874075a64c8d7c3b9e5f9ec2e4711244dec1bdb4d8078baef83990acd53d2b693ee045586b5d299b05c572a91f7a2c9964c0c664f0c05127b153f867ec43b6657a64959a7f7b1309c42081e4988637b49de4ebce7417864c66b220a15c24c516f583858d3a7b2f4ff69d6602f36e25d96ba5ae9a0fcc9f1fd9501f26dea0e4065ed3d40503c3d8707a500e14f2288fc1e8a0522a5b3b9de754179a763b1adcdd0481667283e47922fa5dac2c36aaba9b0e03242c36212c847a79476fe8824206cc229afe3197a1826fcc00ef012be4b7cf3bb094a01c33acca6f32cc68dfe5c9c6b3dd6ea105de76b099e2064ab4f61db43621298f8a422036f1ca997e37d29cf2694bafdf2c8ce3cc1d6cbecdb287cf85896e5c0324b1c6a7d72d60ab2e88ce64e028444e91460828e0f7c08bff9028a23aed921c54713b43988c53744d63318d9fac4b1767d752f2d118cad347b2b1d73531706a92f92f1c7b12229d3bbe514312ed658b8e9b30babb0d6d0a0a50311445e5f43851f56c51b4bf5b6105b51b54df0fa417b29765b8238fcfe9565e9bf6faa1fdb9454bba11a96bc58379492aa93f5f15c35fed43656861ae6bfc9d03196e24383647d389223742c8a091aade35a1ebf859e0a246c34ebcfb73d6e52f4316fc9af865975de7230f6d11dab9d1e92248dd0fdf0f4dc7fa83dea53a68de0b2fa303af37374767e30bb1abe4f57435d1beb8f64590226a7932805b66a9710878b9f79f1b9be66074570392ec7fadd1cbdd13aacc64eb9b6e26d8adb26d73bf0341edf6d9bfabaccb09ffc93dbf5d5b17be091a5521f14eee115a7439948f4d1dadd4063be40ed01d5ae2ceb6974915b7ba1ab38f94ab70622fdd079a3ee6e612deaf2c58caa6051bd038a743afc01b6e9fff2c242f3d6b7a248d1a35b2badb35db4625a59916f41b6cad296ceb068c99d72278b86c6a51f46c880b39ff42a52f1c01a01961799ce96a6b84160fa54479d885d7720fba9151cdac25f49b8bdb17aafe567db5458845d5f06aad57fbb9f51f554d4ae37ad9d0290842404aa11015d8da4a531cf2d5fcc8a441666daceacdae34332c6a39a12851270827d8c1ab611c4a77cae2eee5d25d16d3af9b7b17902b3d2c2af708e04d2bdb30c7e5e8e9d6111c6bcaf03a20ac3afb492d81dc320ba2a6e6c2fb1ccfc1c54a593411a034551941e83153cee7383aeefaea091288b490871712eddf5b2b05d811402f835d62d9ccb6fb30cec25aac9d640da7677c1df5f90dc8a7157af682625c6686b733ded93eb225291ece6e59efa007cbdd6acf3fdca69eab8277937b749656114981066facef2ce79112cd01a65edeb1b22f6dac3db003db3b520d5a5b39b8b86c4a398f6c24afb21a8d046e87a8b093e3ecd1074f18d0ebc68802aad0c19e8942264a02df5e9d3ae75c160d7a5d06c446c4a1a2648c0d7ec65fb07f9f29378225feee31e8203c31a85bb8d8b21d1fc64722dfe9328b1691a192ff3ad6f7b1cd61190eb7a65c0d250e6057f564e76a1c39558ad59d86845371f93f498487c33c310532b6684fe1bd1330f0f2f6a48e13410aacc84157aadd19f8ea3fea87692ea34ecac7b18460476708735ecf7b4430e9e7dfec473761eeca39d8f23964d511a7a1e8d3ab1b7331c1785adcc434b92551af534ed1b129ce61c8b27efb8f0f5804aacf354a97cf545ff0eef9b61ab1d9551f8e2d67343d3fec612b82115ddf0004d9419c552f1b3647c76abf8c75af0f855bc680eda880d67232496bdd45a25ad9ef35c858cbd4016e6445bd2c02fba0f9609af9a9c721ac61da190a4504089dd1934011ef1b428fad34c4283a141b58e6b98faf0936ce5ea7a11d76c6360f0fe36b2d9c11972523e7ea0df1f94c4d86bc28163e0dda6f6c57f7a741a1a6360709825d27702c9827d7e518cedf1e52ee7d2b48cc66a5fc89b2b4e05a8353f41a2d1fdb88728c7946850ecf414705bf5215edffee3d1cf11f918c18bba8087cd5c3f816fb1b850668dbfc5e892a627553f1d8addc128c5af5b7271d69447048bbf99f4ed64fab1071639d49d68cfbbb74be52c8aab70567393f6246f75966ec42d240b765b91b72338d69e070203e885593b89a31d5528d216afc7834aff38c4440f9f720de7ce9a224818463e7bd026f75ce15db479f694e202d0276a6ad437621ebdee69280a2eb120cf82a7944d94b017f836c3701d27c72f7266ff2dea2703c7f320845a4443661baacab9a52ff7d4bdcf315e7f945439215a78d346558d1f2234e5d9e494a0a33b61d0ce4f6f52409ed5871f5a202437a305a35e9c1af1424e7f56b9649a3ed576701c279fba423a179ec9b78a0ab98993c42b541d84a94b470f1a7ffb7e9363cb8a8428165f85097b5cec2ce2baec59193408cc29ade0ddcfd379468c053bc03f9f0bd18a4bae55b4ab5afb805bb81017b36008efb27bb302e5448d1c7a97b7dda8325bc1134de2ca8bb295bb1ae9a859b6aef2a92fbe9682b5e3b728d08bbb1bffa9ff4f4884a61ab4dc82e44878e112dfd5b320cb820743b0b5dad9cb33ac1a8de33d1f33514888e6d9cad9678dc3ce433f7d77b9dfc6788c1030f715cd664dddb044d949b1ea76bdd44763e3a96f24aefc3c04d434864ca41dd1d6a9eeecb29429e44c29d4eb6afca2a27095675c1d2a6f558e07cd8fb94f9ff0a50ffb87d36777544c568a1b98a1cd9271f51ca622678daddaf4f3961ec1920c545e0ac708e83e44ed67f81f5a09e25e6840a186de4ec84c583f133a39b1de8052e4521bb08c7db60e57d5cccfc7f7a78657278dce5b1d28e15e8d15c221dd3e010c9def011d391e0e9cb7ea0a4d3f093b7e16cb27f13240188804fedd78f307730ba5e117695d65e16d48e7005605ab7de989dc1aea586694afd77bde73042152bf7a1f77b07595267d847223cbae2b9aefa059e2584055215c9b3fe07c89871b2f8401b7f6c16e5d054fb07308cf0c78b141a9cccac4a9c1ae7efaf152c0b288ce535e58559bc9257ca27f0bb1c1b2a6f52f9295450228576f3abbf3bd2fa4868fdd4476287c81022badfd37ddfe516eb24b42f614a42cccac9e76a2efa898db1bc231a6d3d502770fbb956daf72a520a0117819e02655b926841c78d57784b565009d2f4676a15da2f17e691c53a914ddac30db049550108ffcd7238e2e9b8b637cb838b3f364fc650a36d5d1574411e5f51494c9e967442898a3b9102e9422700bd450d53cff8a19edcf163d1bd5b258e0e51928956e9e765086e1601db8bbd0600ea4fe31bd3fea77cddd04af1df1e2342206261914160b223a15960264cf40d80373d3476e93cda713175ce9513ebbd7e526d1ba157dcc12899ee943874d895e9f5f9296979cc36612854586f883edf4809496599434e05736f07a1e83589986b6939e26f7c9a623b7f870ae54cc54ef7777c0867c62a891eccc8f9810736a5bff7246a9ad5155151a915449d62f476ad054974a4d099acc929c60ae0187ca8b33f2e0898567c1f327c91d1321f726462524d697b0c33ca454424c6a0c99d01d0149d9f0556d992bc551ece10369fd158846c811cd7affa307e144e273cd8327dcc2e22684f26f531d684f447a77b152b97c186661a8d3a2bc00ee36b0b043d5a569b1822d9f7a9d3a3c48e3e8ae6ee5e7978082621f19252e0e760e3ef3e5670c61849dbc58c7c30b446d14ae2193754a3ce4e78e25c35caf0e879b163aef5dc50854a1b4b7e85009a8c798271f650baab79466259b9dff767b7bbde148422e15594dd1124b41a63d0d536973abad9b550ae21468031fc0ae2c8e8da03170be05c419bf11f334aa537b77df8324320a71de1c2407dca03f8288bb366beafdead45ab5601d071f0e60c95da043ae6a66a0b6e6db1037f33beeffb38392b9eb9e7e017882ee2fd9ed72111a91f67570085f1c8dc1c0e626378b187b69b658cf2066306a75733f79ec1fb959a0a3b2749f8429d94b1e385f774e3cbc6ce4be5e7547ba14e704ec6ad90d34f54cb830d7e76538b1d12a86411ce5f82ed4fc82a076028f444acaa7dc9d93b40763139dfcefff951b40c5bdb1d230be5ffb2257cebb9371d0d267e0953f3a9a6baf31a976a248b60416b323cdaa9cd5eed56d4112ad84a3f6c7a23a616e6ab972346896b572b5eb166dcce1d2936f4a5194607efb14645d87cf3a35cbd16d3ead9a657d60038d559e304015c00ada48556c1ad0226831138c71952805ec87c8f8adc510f60fec466dc8b388e74bdac32155ee9d07b440ecd731272f18e4f37b203b1c3443b85c99124e5532d2899819860c012c8246512464b129bbc1b220b32fc0e26179cd5de811dfa5425bdccd1c53edf792b6b365d60dbfa6185525892bee625afd4b2d84325e5c7ebe820e00a74a103cad9908e4815529eaf4e09f65e1404f98cf95a9cb98e23ebf995c158dc86aa195cf91eadb5bd908c1959832c43fea6aa71e566e43ff5635a5b8120c0ba379484de847417c237ddd6f76b59eb2d6bd1c8b39aa5e38f9f7e7ae5fcd929040975a20abf35cc94ae01fc345b5e4d6f64e090a78d5ac65d1c295e8e4b0235657b604d0d32c64121ab5e317533c703e273d2559f13b4131fcf811e518d426ea8c95257743a23b31619b614ef474071fa0fdcc10c50b944a9d64cd944fd5329f25dba2b8c0734216208955ff0c46d9dfae40a2e9d794dd295fcf485ec960ff1e4826bc4f82170b54d9a3796a9c5122553a96e89117de49c8de1306fdfe28381f28f06699892800d876d378361b17c8d6337654419ba5c8b89427d13b0846b1e7e5c25eb8782fa3ac14d458c8540fdff64e6c3686e8308b2f9d2df87a0e6307ef538cdab9147ab07305dec9c0decf1f22c701721622c80c0b81cbe491ce2115b0cb816fe08682038487dc795191c5f9ada2745cccb6e1c400d5845651ea890276b9d543ad1b7f6b61b35c353622c5ed5e3c00307fa66380b334a59389ce612b82c8bdc66ba4b64320fb1bd1712dc99096ecfd12b4378c6441f2a405f5f9c1ad49e01fb17f2990e841b72658b8aba8f8025573db5cc9ed8fd9e6566627a34558cc78a492d909892346cdf07e12d41c1523f00e01dff808dd1612d16551b1839fa518502375799cca46c583b96351405c52fb9e6e17fb0ea3867a2ab3cecb49045d1f2e4bfc65873aa955ecf88bc91c81e0740ebf339e34fc49c3b70060adea19ef6f98c0f431626dab85007d92bc04fdfa80806d06c11f6ef9d65b5d53c0869bbf42ab9e513b79d5f9752344ec3ce3d5d6c36c0662f7a610a4f080a71839f8f61a1798e9a7084cfd0b589f6a24bca85c523a17f6db3205eebb3913bdecffdb4b10048992d722ab6301d846668f45d18e3396070733796176e0f7f860f1fa534fbec3e10c5a50e1013b8fcb76f19f16165d4e148253ac8b75a0239f440b27ce51207aa429ea94c2c2394efa5b93ff5c9bda99af288e2717ea3b8fa1b758e1059a313605d2ef469572088b105bf1b0f9c5a8c40f13e0aab685dcd12e88ece4735c83363f7067dcfbb2062b870c8fa110fbf57ddecf68c0bbf0a9e9c45f2f5b7c03c695962073c8e91fe9b619f5309bf7823042846fff2afae9ebf189b024f9428406a886535ed9904f22182ec03b832ccc9109f0541c2fc41907792d17e82b7478b865c185cbd7a17b7c0d0ebe273c40e8efabcc31e5bd5111ed02524192a942a6c7e899459cb7f18f400a7271b8a9c40e167b41e0e53fda9800bc508a3e0095a46d1190c71916ac365fdfc133e42aef8fd25abd6ac752dfbd3e0df39359e805a9919ffd1e297217ae58a895752aa0ba1dfeafeeaf67df33ed5e9b68b9561dd663fc390a7d4d30069925c3cf3f9ce2b01edbb22d7973e4aed95e3da668ffd0d308c692816028bcfddbdb9267239a90cad07c5e2d403aedc635779abf6392fa6385baa92a579ad031da3a201b16cce6fd2f1ecb3c0589848973c881d0020d67ed1ecf229d727f07fae574dcc40f7e34da9b032bf9ecdb1edbb0d6d51fcd5a80281658a57688a1301dcab6c0b526ea0f34d79bdbc59dbd7e5228880caa8d3b485dcc3df3940cc4c22f6a29d0e649a6641df9040f5cb454022a9d4e254a7ad52fd328dab24e2a516c9ae29053cd524abcb6408ec6ee0ce0181b2d507960e77b75c21be54f64edafc3c09cd65c80dd1175da48dd6ff180c538bf4c527959ba8979fab615ab5c50d0af59260eb2f05969b1a2c23747820ca9bd1a12d19bed6ab557e3355c7bc51a80a4bca9b0d568027f64e6ebf704bebc64b07430cdacf7842c9513f211d5d8ef4ae7a596172511c93cbcfcaf50a5595753c5a612353b365e6b5aac84b9fc399a924ee91544d6c1e9a6ee436a047f6123a7adf9ab1a8937705bf19f5cbf5cf422f5734d6b4f47a036bb94f0aeb4fec573ce3b8315c174d010bd0ae1331a915aa308e3de37f5f7f4585986cf682363170dff8c0e2fcf0c785ced50bcb03744974c8f1c05e292533dad909b8e03f1c0a09fb0325abe1e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
