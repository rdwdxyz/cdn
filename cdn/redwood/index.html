<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d55cf5820d44395d9c38d7883c39bb3d8504304c197ae3679c38de2ea3d110f609be954129c15d1b17ee6620b3dc75b9a1a636186f8d33ec9eb338df8c57a7ca84aaab76c35c73cc23f0d7a68d652ce73a0a790524d69b9de33e93c0a23109486cf5f34e3c707db9e25890fb001cfb43ad40852db0146b8a98a1dd692f1c6e5dff1ca460e3c5e5421cccb8f6840138bc4753067895cab7efd5e6265dd40f256d8b5b3aab040550560682694f729106036fa99fe659b159447ec465380d0fcf2210875b59308f090b858654753af6abb5e4ca5bd9ae3be8179c9019cb84b723e9868b3156c7943de058c872e03d22213769ce88c1b93404b4477a7843eae9811b8fa36b8c4e39f16bbc681607cab1abbf7fa01bebcfe1e749170c1ce94084b1c0b8ed7e3e379b5571a19a6f4382d6f1946ad9083c116d8aa1888ffe020b407e69cfabcedf41f544f4a370761fd49ae24e700fd72edb6db9770544ddf61d0c706315c69b531b35bfb3ec1c77a95c36dffe4f07780300229751210110a56915413e376ec0e64abca5fcdcde64a88f0612a7f8ef10e8a96957e15287e811868ae640d4b3f43c5de917e6ddfa8629a25dcdf77114cc150203ef4548550c45b5077394fb2c44a4f5b89455a43ab34f0492c8a59170d6a2df4033a43dcd311bd48287cedb6798d08fd5be291949c89ded07383e62dd250644419f710ba2570c9119e8ca03ccbedf5f635be8e568a7d909bc0424368eaf5c1cd362c347d0d1683e07c47c92fd26fd1226ef9b381614508198eae94b8aebf9a92a25d5312b51d0038319d42b1ecda4c281f459bc107c9506a6e6bcb92082ef3803102b2b093fd581d423b0030cc26234b711810bb6f37711afef147a37c6396e3204a7a6b5c69858dc92ebde860103497d0ae13a797a19adaa66bc821008785f5ab254e0ca4839430eef26946cad623458477948b6492208c2b2bc2152fa7bbe4ebb52453119b3a535a544d10fe131d1516139288f22adbc1153b5f63865804e595db958d4ade629e359ae4f7fa6a9f22eaeb916f4d59361ac11b910fc869b8ba0b1d93c8f916f04229b3145e42a591bff1d7979f776bdd0e7cb4880aa5f0811a2d9b2f622715c0fb8d83726afa43c38c5cf8860f84c38b01a99661bea182ebf77525ed2a0d8d2d88f63d4744a1b3658c9f95d24bf8ed572ec96bae855c7eb4d01527961edbea73d8ad42a44f22226f8175f6a81d871ae77d6118a4efb515a66465e93eed991a28b28e393e3f8a408d0fb24e1e7d1345a92b23ca00df82a89fb57edb7e0315e96467dc7c1bf5845eae88511402878e443ba36ac9a9af1317471a84f1d664dabec8e95a0f9fe0242bbd4421bd375cf011b7d1ac8f560001d8441226a2f0923c7d14aac93bee7c4bd187bd5c5f160d17f1a0fddfec5282ec692dea1dfc90c96c769eed48657c8adcfda50755119a60fe5daced73785c380896fb38ddd3b4870705018d3c845a0e1a0ec56f54428e06d9bdac9dbdd7ac10f6d6bc78ee6ba30665c64de9a9145f02c00f23c817a23739c83cde65ff3a175f22003224427fc19b973b4084910d594ae07e466272988ae4d9e1f13e4b6aa2121d07e6c548f8a4b04be10309d5ce394b5f9c1af49df98d92c7abcdb34d6176b3fe74678ba93028dc60ae4734823bcc860957f26d79d7c1fa1d9ca7955270fe8520ff651112b5bf14701cb1d2b2a5fead258238c58ebb33fd46427a96c384eb0eaf12b90d6fc230d9fd6d94099907b2a41826e106adfe55f79d3cd7a4c290658f77b3d3484eb019845a9790971164eae6e00a8ca39b146c7eac12a3e06127fd0698ba653d6a572364161ae3d318bbf7e33579c83b6f13b8353445c2fd4c47dc0839c1932c01f90314d02205118bdf15cfe6b9b410f82ae9289183af4d28108a379a3bae4287fff1db9ed2064ccb65de1ef5fef2568660281bee4ab46b1ead5b6d72d8b58bf41cfba17fe6453f93983179dd0f2b029f99154485d16d35be5929ab4474d790bee36d06876ab15e2b8b7363cc651268c364db76518ad9867242544e215c37e9da5034aacd45a6086f893e16043265ebb876b62ce9e47551663e090b732af5b1d9ae37a987e4a43aac05b8e54d5a0f91004e5cd0c9233463e5593fb78ce31ad7f679322aeed93154616e841a38ae6efc45bf79d3ca19f4092ea67140abc595f2a29c48b288ffb117d0482a14336abbd2ce0c80d7ad08089b49b1b83cc60c4e5aaa1522e3dbd13da2374dea7056f7097f69c1aa6b81d62e6f87e358b72cf63c43c959aa9c078e155e98c426949c638a538d69fd0903b2b280915db9e861a64351effa977cf2a7bc28cbfa146ef420ebff055a22bb832eca6cd4df0491dcf3c6174d75d5e45c8154cbfdeefd5239f88bce4f065037149588a9005ca469f7e9c7ad2cd65d8fb93e68055163987ba3b982451e716b60a7abd8a01e016af57c681bf46d280be5eb845b3e773a1514c8491d2737ad76172abd65ff18ff2db87ce8164436bd8a39ac0011450ce677bd7622d14b46dd0ac08e5834dcab12b3e898611f4eb5e3f21db6f0c176eea5be60a931d6783997fa65d85bfc9eddade219544f629930bf52e7f427ff4a563b1b14d85e5ad95809e09dd437aa6e468ca5402d27ffed5b6aa0d3966ea20c9ef1ad40ce9d7f2cdc4d7c820b9018efb3a3c6cab11c576b3a6df0eae21010d72821a67f5924415f5d21933a04c9167bf2f734643d028a683c97464ca54d29640de5d294179e39bebc967002ac09a7fea8ade2460fc2b81605907b07c25f5992998988fb65b50fa23ec01d71dcd9a437f5dc0eb25981191de3a21174c1106dbcecc4e5f164df6e78f02250874fa4aae8b96005572ad4883aaeca7076207a6cfcb2b59e86e4ef1da56121e5a6848b740d5708240fbb4a9aab36eed228fb9c657a25f514bd1d8fcec05db6ce49093972545056b134496c984620b6236962848abe17fe67af845c09443c3dff5345ec0686d261bda865cc09342e38d15f0dde305a69f5e77edaae84080bf9951ae28b1a627fe48e24554d8cbc75995ce9b3c9e8d71f9af087622b8ba590462bdfdaaedf82d34413a37306b0e9d943ef84545aa8650d77c536d170e1a2e44a17809179b043b5d73c8523745ca2b37557f1b92b6dffc0dbbf06a04bf5121bb80aebcedb5d30eb146c9ce6e1ff3b5ea2b62b2562b1a4bda8d9d454615064d1970f101f800eb47656d438bad58f58e7a5fbc1649cb00786437df28520357a0fb7bab0366945776eb3d6fe377cfcdfa3ba3edbc18fcfd5c568e96abc30eebea198c5f95973293fb52ac5859957c950fcc401200f4c240053accbaa53d8731610f5605913b75d452b9bc11094f50a42b290b41a90723a558ef04b62e62aeb8f685d03806429c10a23ec92ae5ab633438ff452c049b86d03b007ea6312b5c09280f74ceec11759e4871b1354e519c3db0e40c325d2c5ae53ffab3bf35af80ce762a6bf4fa2465e18f7c5b697ebfd30fb56fca58b48587c5d2781f7e89a47e65c39da5f1308cf101226bbb5de42f5caf120cf222db1757eacae151b0271ddcfa8c2a9fc2d1bac28ff6fecd6e3859ea0ce3dac874b3cdb31c256b4f8c56ee02652b66cad09c388f13bcf1a87ff157b4878c656f6d02f4c7e13f46d47680a88826af606994295faf1fa163e89bbf59d27b4810f00c8933f8f08f3e06123f17cd818a4590a99901cec7bc461b7e411670372b51b986639c49038e7c9d0b027cb0ef759e48626ee053b577f8cc4b47a56ba3a83356e4ea7733f388c1aa191b286ff0fa3928ffa231d6800ffc3c51174af566b773a975b4074faeff71f3ee17bd4758c09f8339124d76cbd6eb8fe6b9bdf8a4168459bb94c8d262132b2ae5056a539eb434fbef991222f92205745f6ae3bf0a1233549abbe019d24bb74095cafae85c49b3fe0f3c74e32befb34d5298640b10aff22b60a5186db125ea58e32a2e76e995b69f216098f9c5dd559982d8a50cddd4d103f8a8893d23536f6992f1504338b7fc6140cbc4c2f69909bd0f85e0a63141df564ac351d7b094b4de8fb2b2573cec5a74a107b2ecaa917a676330c4c25f057b31d040074c833f38b896f4427ca545e9905e3fb88431597b7e5f8c8a2a504b71adfe27286cac2954bb1601cb15281b22b5de9a96a1a16002cd62dff7fca92f4a9be637e70f6c0c401cc98f34a9cf81770bf22ab32e7d29c4af0b40927840196df3789c3934fb98821f69a7fb7b73e271c1324785d4b12a931131f8eefacec482811492ce1031bfe320ca88cb05f378042c43babc1c64fe84b8de63e57d2e94dfd6df16445b408794f1d4900de2f426e3414d7d37ec4a9e9967bf12f32f3970f491ed81cd04802a8f85a30ce1b6b80fb2d87a3bfce436937fa22f048fca1bf8b614218fb7dc2b0c94b2f781bb66c187b25cf96f177d7751f8009dafb3ac47fe65fb6fdcd4422e30b7b585cac103cd2cfd831e958cfed7ffcc3b4991882c77184eb06581d88a223c6e1e205ff3b1fe14dbd3ec005686a7f9d9ab80d50009c8ebeb21439b40a6207eb94b9febef3a2c7f3056adac9c774bd735495d25bb0e2d8f8d85d528177229bfde0b5f6c3d36d4e3e22bbb4ddd5c2d4f3fa1d9162a2c8eda22286d300ca29508373726a1b16c2a60336bcdb484f14a1738462c5afe95dfa1495acbac75a3ed54df6e818c76b6888609db7e73b2918ffc3e841ae75b8f41e5275c0721242156d768ffc68c9ee57c824588c815d088b1b6995e97a02581d762943f16672bbc891ae8982942d0a3c6fa80692d5800d510e9fca74f514af04127f873a2ffdfa1ae21218436d8d23772c495bb26ab9cd34045b890fa6240527811c23413139572d7ef839937c38356f6dacd46ed17bae22503afa66756ca1da8adbe373c1471e77c672e47b2647ffa632b303091b1393c2f2bd1726e6d38cd50c98ed124fb6b5a178940a4894a92849b4ac007f7072d192f43a1c2c654dc327280375a09733b4c5c7d51101d119e0465bacc2cf0435d5f2a4d63ab549ad60c25faeddcbf57505037ca6b0fc84523ed58b1b7596153d792a10113a8a195a2bea7ddb164cf183c7785c2076b5e8a3d016029ead396f67128780ea4ba4b737dd8286ff7f825ba594e65da0b634d1baebf80e17ef89bca82ad501e02bb12b13afb5df338dc0c5a8a9d2d2f5c106fe8e11f5caf9252de1ac9a251dde6d377e99931466d85cc6a92fedb3e50ea8284a598791101bd4af4fe7cbf93a4e47459589b05aa921bdace977f8b69f102ce7064ba99cba84c396da0dbcd623c5aad4c2d3225f3873b46eecaf43e15495cda59d9e71d4986d6812895adf0cac73fdce07d995994d8654f034fe76a9b0a5301247d7048ed8947bf7f64821ef6754f8ab4d83064e3ff7cdf3082d766e4ef1ce0c0daaf2a10f41daed810aba11634320e8e84ccbe8b22a3820dbeb7f3b16070d669b0da899a9741a312415e15a092f89a6438d17a63ab15ceccfb6872e3a9d6bfc7630d897e62023cf654fe099a73f42bd09557948105325c686d03a449aef0b094d5e4fb69a479388a5d1907bed23234e38b41f26ecb286f7d569a9b56ed9dc0451911dcb8f00d5a7b9b88e46d1469b1920eafc3a475cf0f553e2d85c4ade358469123b4bd19d42cac0ed9e90e934c1f3ee989299248846b640996aa9fa2cb70dc9534bc2385430b636206e021d4edbe3cb594fdcd4219fb91da2491079fb86e1c763a120bf31bf83e91d4a0c57228aea0df22fc5400b61d8691bbe916c09e9cab247c86c91b4c767eacd1168f06b49b49c26bc39833a98243f8e5db81cc3ca80547379155cbff8c215c202efa5de31a2fd21c534dfae6e16fa13ee960a9aa6b454547ea9ea5643850a825506fdf91c0ed04130e36760a1be56a71df9e76a8d1fe8649d8f4abe17606853ff01d9b8938a0284aec3ee199520f6faf61643d2820b6a9d4b1c52c7a6ce3205b7e3c2cdb47bd4f880954a67019e1d3f423c825ec6f480635c1045170dd9aa1aa3a4d6b594cd7bb9a9761418f4bd24fdd90292d03f44422d4ae1cef3d88076eb37b66d7babb50b9fe0a1e3b20cad82abb615e1619dab9cf559a0d908b598bed264f125166b33d119b19761b5f09aa0b75b735b05478aed7d10bb9b698cea228bd356f891f8deb9216ca5671622ff5005fb600930ec33e9841502dac89b981423b4d168ac9594f53d9c94e7d11556b54fe699aab046ffebbbdaa153825a44f9b37de861c3bbf98e1191ffc76681dddce9d6cfecc0307c47c112f33b670929723482af81388cc1d5995df4ede05a13482c5226609124cea706871f5c7283042a62d1cdfde2d117dc1fa3976aea43a22c05a31d054e07c38ded1c448af3c5547a57bce7e33ce0f012014be270b6f0364ee1a6737f90296eb5fbe8a1cda3ecd3d7967f43755a154aba12fa477d46171711588170713520fef1499e1c39753aa58732b7b17d60e0b1711b8473295494b776ef93d3ed060e422016b7279b377f56b5b6e7040693d93619e88d45669e470bf419ce1b6516bc8743f4892dbead4e43c4c9c7cedd1eb6f6ba69676fff6ef43cc8a043c91ceafc284fedefe8e1f54056c281967613b03ab6f96f8d3df336f0462760fa6b514d75c19bd654499f426720288dda7c48d41202a1f2511fd68603feead6fed16b05137f7786f9f2c6e02b697ff616244ae4729c1673c1bd356a035ea95373e051c8732ad36db800b76178f94974b4c20eddb5b7297295152f2133fae8e67d76069286d39679cf9ccd3b208d9bc5e5b6fd0e853598688082320c7a70dad50213251da736c9be3ff6e9a7a701027c0b032c70fdd318e5bf38ec6e92695a8e3e97cd7aa666150adaaac22f508f2047a22d350705077f1829e8054df460c1690c49421f68a1ffaa9f77be594bcb804fefef985a9fce214b9747ce8c6efadca108db8daa055041d4d6caafcef848bc9980a3eb6bedfa3155e0cc342f404f363c0d927b29cc8daf466c0a7f5140dbac15e2135bfeb0e986c2a75949b01fabfc41aa2f7a118b189e1a27b558967e07405483e99b8a1528e049a3caea7599d1336180d00fe5ac126a11159808e8c915258804f5823b7a6e114bcb064b9e704c1ab892f344bb13d2f121e46c13d47d89e7d2c5260eabc2a3bc135371e0a385924143b5fdf056a2cd671e5931cc18ba4a51cc87f0eb40dd37109a23e5a5a08fc1880bce82a4a11366c54386cf7edd2ed76910d2ccff59a90f89314005c337fa1ec5984dcf25bca6e4a4be7c368b17476111ec9e89cd882bb7c00fd9614291a0fa4a81590f9773f2500ffbe0e21db1582935e5d60eea5a05853ae79ac5c918fa876e1751c11ac872e860bc358e9b91053d9c82185a2ef5e0e9c41e69f194c25daf7592ebd2dfe68c0c4c65afbcdd93e4e92f0b0b5965439b269722a32129add13bbc8919743f53d4d6b68b580eb7c747b06ec26f06f760023a5103fa6e2c3b473ea4dd618287ab0d96f0fe0fbf722a5a4bf75e7f85b2d1a3ea87f7ab9a39b30f2bf1acbb8bac4dd27af72b18f09a60577d319cd15e74222e4422ba2563893808eb1e0c8c0f419c8cf29ca059a2bfb04116d0e585140c8f4704c34374a9a7de0aa505103a7a05457a4802cca8f845864bd9d73dd11e3069c32d7038fe5f2b610c974178ea77d9f934f2bfc4877a5f61fbbe6ad0ec8f65c061c3701f38403dc558ecb53adcbd0f8b178c78754732e166d2c88a9e1dc360d42b01bd9d30393b0a3457016d13f7417b4b28f0d302dcb2e646f7b6e74645b3412b5040799bcb9f6460b05b170c008c463a9d37d7bb89ef3e136cd0934cfcca9c80dec34d44475a70fced285b9c6b58de385c993593afffd349dcdb50ffd127a0345149c8ba8a580636d308382a7af425240cc9f27caadee3aa7279ee0290becd9e9a90ab98cd0fc4959b85f5a4a293fa8b09a91d6ec8ee382cbf15318c992443b69621b0db69f16184dfc51509246703c0d75a5605bf19903b965dcea4b3ffdb1e96fc85c6780fe5e749056badffa8a4b8e158a999de19a438ebbab851d43bcf7f64b3bce6af8c97fa01b88907a0d2a01ccf5f5bb0a8be0607befdc30ced96a6698b4e2b94fe7454c189c74a616c836c978b9ef9d6f13301652f1d04b3c7b82b381a99270ba41a29c2928cf10d7cb9118548a6cdfae52f7332949aeb52da7b26ca1e50ba830f0195c06403ba00a5e415cd28cf43b8abc583b931fdc78b6228fcff51ca5ed88013378c0446ecb5ff23f4e8073e1f22f39080b0793d6b04bba695c8acf6bc42d439f03b6293818a31fea9637e33a1d3220affb106bfb6ccdb08c2e3f72227a3064123a17dcab3d0c3743363fa5acf52af95b89e5a30c5113b0f4e5cde6494bf488f368f96717766e29bf73ef826de98101ac7137bf5c464aadbd24c700096f18dd1b1df54bbfdd511b8d35a57ab00ac8f27851f80cac12142cd39935f987c6f63e8b802ed1dcf76a526d714554c2c446ffe9d28aaaf8b208862a90d02565cb75a8260a4b9fac209495dbccc4163c94e71665b4302126d93a030655e89dcfe9045d40ae85da8b2a43019fa2d612bc83bd21b1d441f8cafb3d92c03647907eec5b5890133181b9a10e5299a158ead3bca10057a600b405a819e12e0277b2e96bf48418d8a7a942964491480dc3cd34603da3e7ddc19d5171d3b7fdf3ac626eed0101986c6865389766e98547ee2f10c8d5cee633c177e14d4da1c72508cb8ee59cea22b298b2af2a79d58d233a520e5f1b10d627f601fedcf5bd5914b848b7bda16497cd0749d44bf99cbc8046d4d92de684d85fae65ab55ae2c89865b0d0cf0c1d367c696e98a9fddc923b7e07700c543febc0c8e5c36b00452062310e6d140b647001da3f710874fdb97f7dbd387164c59c4faee20bd9a5c961a7a6c820d54d2d249beb53060bcbbf827b99c661a563277168f6a4324ca4ccdca72000ad2600f77d4df69a5dc5de1e53e1b0ef62f7b442bd0b483cbdaf850dde261a03b9153dc1bbef5c7145727bab83f743a7aa71d17477f219c5277462c6bb01354b1ab1a78b9e697f7df625505aebad3c2ee6468a9e24c176cdc8ff8996f292207b673158cbc69256d46685ce0088329626251ec9173afb474ddab1879ce1429adf5b0c35078f47d457d33ce01442be922ff0b13bb44e82d857fe4fff5517ecd90891e6f8c2fb8dd05ee363328595fcbfef004be27e883e977ac598712ec073bed479c32f4c2f50a298d2957e68cc092c487958c38a513be9403662b7f0009f7bcd06cc4124d8ef439b9c049dda0c4cfc336775b9780e2712536f82a76d87cdc46f3c24fa058636658095c618c412ff883043b9402309e1ec6c55bda626d7ad5ee06410f8c5bcf01f9e6e8c96a9e60e3e6b05ad3da223287e9fa8195535636ec044b96572a96a08781bc50210d53d94ab63f4b96f5e82e6322e390a83494f21efa26c4f0e7ee375dcd193b2dce22db81d7fa3dc2c68f084948eb02bd518baa297d46222e034440c3069a3bb34f2ff8447bf75127e740c7f89a5c5d510f5397510c5ca0cbc072a7c8243b5c7e32847357721a98505b3a81fdd3f15fd10dc9afcd342ee04b2a297326b6ef15ec347c8dc52a4f21640e56f9a3ac44762406c8e9b86e57c907fee765b8d2a15cb3e5845433a48c37f8d0f4497d95cb8e40fd2fa6bb0c1ee62d712aba3bf75e7acfa076e0b025191ad7a47e5bfefe41094ef1c738aa2db25976b3b11531f4711f8b135407cb2ec2f2bf3ba824fd8f05bd97ec05bc8a437522b026a82d47f06932197f7e07541d25f4436f1c2b18e4edd1b6489bc71f7e441401c6555c7f9d7d7501b60d039ff5d8ec636b73d0234a12ee3dfe221e452acd58797a0ff4c26566d2e1ba5f670e275de36a621ea3a1f839e647d589863d2b0485e06556013cccd612a74b8268f749c2033f9eec3498cd6bc4185a127e8be76498bfd10c9d5154a1ca4df7c6871752f61e360ecb37c3724365607d4ba41983b57c670c147d248bc46c3d085696281c216c4acc6a5006390153e0ddb1546568cff32c3b2c3c41520c3efec3edb482c3742cd1d63490527b511ec290abfaf3a6aae31243d9fae2f27d6db177db9cad1909ed193868e6df31d820593ab9c7e529181602f5f1af43475c683ce2f233b8ca79c40e9a1401be73bff64bf46f554c65a141a09369ba31d8b4c8e784182824085e3e9a2ed17d1a30f3db89a68b8098a0d0c8c71f462812b19a5e1c5e39952ad0c931a2a359b3d2b255c7d5d9ef10918aeb537318a4bc74502e5bf4f4b4b0bba492f7135ce71547adc1c02fb2d5a318a18ce1928932717bea546c41806a577e55842b9fab0d69ba6a101f94375542ab7b9339cf32c867b21560ef45c21ec03208121d275a6ad8708152ed8cee4c83decf2076380242f7eb33d59d46fd70411b4f38af830374b0a621153e1331a6485dabbfe41e7e4b8eed935776364b3ec122650918e73473a9301db34b099296c549770c3527e9cd8571a00ac29c98c5ba866ff0d600975d337efa4a62555ee5ae457c91f9aab1b424329f35a4c5de5921577a3cbe05da9345f75508c18fa45185a21bf017f724ef512a639e96db5619abcd771bc663145e19d7ee9d6a9f263bd25a3f0ccf706b0350c0a42974eb20081e6d1c76e60068c73dfb1b1c32194c82ae1ccf225368cddd45745664b20ed6c7d757f4262d1e4d08ce7535564129dc7da5ac784455500b69ffa393f32ec398cc0b9b86b24b53993d776f00527ad98280eaa0d624808d3c924843d5a4812c2eeae45a682ab2b2214bd5c61237ed1b033dbe09392775efba01f04173375c446196d075ed6df9b8bc933820eb05f45f310be5da179974ced72f070bda4de8d8634705cc99bfe1a32148be45e4491ba7aa1af461b8e998150afa7a600e61287346f2919b8c071dc5884e233cfb4a54b0e88f5dd0c0451b9b02217f0da86e06ad7509b33ccf17f006bf4fb50315828ae982d0cf1bf82d2e7c3befd5e713a8a973d5763596797831b39f560ba72a8e73b5092b184fd4991e792d8755fe8ba9e732d60bc81dd67b3b72f97577dc167d6ba4803ab45be536796af905acfb43faa6824080236f673d5f84602b0c0f8713a0930a9899680015b67b46112d99253400308c0c74355aa92bbbfdcaa131d6b5f565206cf47abdcbe43fbde2638036e8947f97ef80dfc1a9ee1e17aaf9dc6e608219f0bfd1c6284a3c11a2df266accd2b0eb33fb81968e5d7c8d61f6a0e34f4aa0da913887dd319fcd0997f1a844db4f4066e364206b9447b2cb33283bf7678bd1913b50422df123e65b2e4c0c378e847703688b360031a578b7b590706c8ff91da04b3ab512cd97d0821e375155ee0a96a37867a29895c48e9f540625f05f153777a2ca883967ec46e42af5bfc20c175ee7af6519f28d95c876e757de41b669c72e58ed2373a1db22b4bd6fdc31d22414a7245605a3a6e4c391401bbb443b04d74443321cef03c9483d6b129a71534c34e71a5434b7d8edd3d84cd5a21ebeed73e5098d612ec0d89208f55ca1efc24f8f4b8a39b2c24ebb8b2cba2b0e66e0e74023bd026fca4a27b46f7abc00609cbae320a45baf03634df3df6acd8f2e35eea41fbbabb5cc1f819ffcee8950b816108ff7af6a9375b685f55678d88725b3ea548c4ade7f15e159047b62767a00a6d54d2a6396330b06c99c89c7c387c01efa111361be15f556b4f03be7618e89a69b0b2b1e0b476b6df0ce386e68a8c888964a8382e94106e0b6223ee093e7ea391ce2eada6c9138d7d5c783a0371461d422acfc197e9c3b1fdadda16ae81ad622d39ac115f699afed308bdfe5a2b319558ab93d18bccc942c4df50ef83094a4d1078af0450a9aa11df017f22611ce8cbc1ed7863d106d75110a837cd4157b5fff6b2326953ad452ab3a936e733dc518ff0fa2ee7a133ddea73e35186eacf921a1a23b11a018e83a2885d8e195ed9ef6ae2153d1d719d1051303ecea8444fd5ace3084be96e809248bf77db179ad93d9c254232d46fc7569553b6c0cfffcb75d80442853ce7b49c49348acdf38b0a4672b9032ffa6babb94dc3878e0b62ef589edbc95d507fd9b5a12dc740ef1f1257e9f2a356d6d58b8d990c09c62c441e99ed76a987fde630dd42a8afa30982d6315fb27de136f12480a57b8fde35efcb882ab187b761b08fb06fc95789f46da921f1962ea77a2d6439efba1c27bae8d2f7b0640ff29c33d90720578361c33ec94a30336d33fdb83add889d6c977d684649d1efd37140043a8d68f5429548e37ce90851fd0b399b704460b832fcb52a05808798308ce31c632c45e369d4d06bc870600167a3a0ecb114a29bf1243c0059814bdd459f6beca969646ccbabb3a9faac0ddd97c970ea5ec047dd85dad188c45204dbd054c3d9c4d71ca9df26c31d9e7c3a14411c6fb489522033f6cb558f9f85f3fe84ec5f0df9b6bffe6774e5743f59ac84c824c1f0b30e9aea6c70bb6804ed165b54961059ae34bbed9978e79e8b511f9842e044d019365e5ee4a54ec6fbde8706a6ea40a015657591d660086e5fb9476cf45bde9e70ed5d718f929758afe5114affabd3103ae8744fb10efbbe5ae8d3d3993f56687e6eea57d11baa3474a431aef5e9b4d68bef5229afbee54565b6aaad8baa1acc3a7d1d63245318c1b8ffcfbb0c6fb0988c3447297ca9cf6def15c2bd48af41bb76fcb4d87ff30d8a49dc93b8eda84421d3e2f00a20d08e437e64421d19e9d131650aa7323d64ba97d479fe212af3499e25fab305563fb81a7b1e4c0507e2819c2408c2cef21f20a603debdbe13b778c489e567886ee3fa2fa615b322b6148fef6d3ad5ab93fc7e35531e37c052f44670bb1a75c2987ae73ad3a6a353e183f2f45bdc96500182107f2feb5b4cf5ba541f3de25523950e87c77e274aaf43709bc915ab0d8038bae10ff0904ce10d8919b531e2aafe813a3e03e54fe604c5427aa0244c4f13d45c2848fab755fc215d14794a0e0942d4560aef1f896432787c0807b2afdce2c1339450cd88dcddbdd6bddb59ceca6bca53c1a9ebbc40cf5fbcb7baf5f6d5c24602d6c2cdba4cb8266909942572a5db39c7f6678e833de962c75721d7db47b801133fa06cc2124fe4f278d0a758beb2ec152c2638b122adf1d8d2212ede876b4d327584c6c9753bb1405f14dc278d9af7b4cdb1823e97b424e2883c67381732b66f0c6bd3a3ac49d9b2f77368ccef9217ab91077ef9bc94f62f0763a6f4f568a1353364c3b3645db56299664a5370f17f01ef583d73296590666b6e5c4407a76a594a86fd5d4cad9a81260a1f96eacd0b6040cee42e985c3075756c853b1fe2328936594bded2b0e3c77f69e27562e91dc44e22d6a2b3381f9f7323f84c52c65223f19dcd63416af050a2dffac85e046b24b193347c2a816d0b275de2a093ef3baa0794b3c280c172a11e99f40d52e4134353efba79f2e9d074a980209d6a44ac5ded2847618f0db92976baeb9040ea5bbc8c1ccc3f89e3f7e3e7716f84924e8badb120826fb4ce1b2b1b470e7bdaaa19302b81d21192060b6ed10cccb19d8efe9879eca500d0e34f96bf5060db3b20c7c573deb22c5dd7be82b1fab633d46291ea90a31f0c5eae087c12cbfb5429888a8b16d1d383c770591baad83f002d6cef5f7b26c1b23576acac2ad8f9456522a1cdcea16f846b7b9d34d4f1ffb3bde10818c3c336b3f955015db87a3f11793fcaa7fdaa5b6c8aae035c64dc6423251f723e3c57eef57b6a94506e640836d5cd09d8202f90460deb0ba7f9799ab51fd9789856036690ee50b4d613667a70dfad0b33a445ae9340bd4c4ffa57660d6b59da961411e6d689d55c20fb1dabe353bbc74d680f08acc99658f77bad23b4908e0aa5341e3983b333caa655cb0ad3e5339c6fa3c1e7fedf1ff244e65693fcad94e4d8ba834c02370d852da15993ff5cc4b26c57cf7bd17695823f6463830683288eeeaed4561170a33a717f026abda2f36f34d374646b57c56250efa9d26180f9f900917f53f0c3a8d5d7e2060a5b19a53f79178b487398cc83795c4de8535cfa337215133114799b00bf5428e0c4fcf72b0e504814c86f9d7151fffd7a0500da2d00948edffd9c3a37a5a13cd60121f8666325936ee3ef4e46095c90b8d260b9fc32ea038faeab24aa4a1eab95c134b826ff59f6f6565819dbddc99b50ce87a9449e7e1f9c8ea04723ccc33321265ff2935f896bdbf7bffc433eda67aa658f79345d5b44087ef3ab930e92996d5fbde6d7861488c4cec2aec6518ad85e1ba3fbc953996d3e7aac711bf8fb2099c91e88c2ae8f230b82d3dc6af47e893a072946e9b2f2c109bc233d67cc70874ec8b856fc593f5712dca50119b75296dc2cf1a10f07e42068e607b9ae2d644abc2ae9ed99cb1e319c5e51d2b6e28aaf4657d853ed6d8647921789288d39c78a6258e64fc723be7d10e4bb8099efe12035f7091688d889157371ca748a7a4839f2c48f0df78594ea70e6b91e1335e659dfd8c7cd997911a42ee58c7556ec3f2aa97129a0565ffabc953d5acc6dabfa7869b52aaa473584433fa285d932bf61a393e1b2a3299301489b017072ddb47981dfeb56016a08e04a2fc6168cb8856c3401037777f3e75c87efb6ad07eb207d25abf7140b7456b94e264d1f566291649eaf393442abc55b13a66ce785dafe6953d41cca7e513ebb2471a6034eb825674873be93b1485e84153e0db38fa58b45e4b8e0a2be9745a7a368490a0f6169c24cc55ab4b5de0f2721ffdcf006b601b5de9d04bb1cc700f4f98b1897536625feea1e3d0c2e79a5b23840cd84e7494070d337b857f747bd0d6db4eaf47b6bc618acbde9be26c45a38103dffa0fd5ed8bf3bf0dded42606e65827338302670a313d71d6299ded8d274ce1c701a00f2b5963e69990b2120efbd8f9c523117a9469c0cc5de0a1bda8ec989966a3bb540eb6f5205f054c6b6c9446246c8e52d54890d4cd68ae8fd9f77c8d22d38eeb0ab96e6b8b4d9d4d40cd4041094d0126d663f45c527ece56043070324677a0163f04f5b07307d441657234a4da4741e0ac5ecd6b3a7c7bd63a9e10532548ef7bc56d27a91393c9b768457ffe94e06400135a3252f0596fbf5ba7c52920f3b49c490836eb5911f3a7f4da72f609f4ca31b16a71b3121bc17b7493b3de026fc508dcd4be83b5daacd65d8d5325b8c20fbbefbc60aa4436ca5576745afaf4e34f22d4e4d7c41ad5f7bea6b9ee6187b5278c210ec3b2bde876f9d724ca0e37188d37d20fbf9dc7b0b01327b528dd904d2b5f95a911a14578f76a9c696325221869470c1111ff85a3fd9d52358e10a1f2b7630a1e73f05accaf69010fefe37f741bbd11a3147b08ba3a2bc804edec0c3dff2cc85ec4e3d953a2f6011eec3a9c2718f31c4363b1520ce262250564f717a847b9b5af3544ec9af681acc02f7180b1010113b7f2b65e5491f1d5efa78b59dcaf9602535bc9518f7edab410a035305eac6ba25d52a75892616249e870d0728752ffd8c0c41fa6c222016fe093bcd5d432efb8538a29698cef9a2fcf8d285de66b0f01d1aa41098893f2d78f0af4cf90496d43b67ca45180e6961a96e0d30724789b4e9b757450c9a586fb008fa711be87c228d6275e08fbc21eb0c564fa1de79d994421ee885c304a3af21e7dada04c4994bfbafcc0c74dbcd8218ec46b088a53cbf1551b4783c622f4f4321b182e6273a694851cd993ed2cda9cc97eb56c67ee1ad168b64ad10629fd5e495cc5a1c1b6a158cae3c2e0efa7d703a3713f0779248a3d1c4e6ad5081e44635dcceb448e0c5e12156d9178ff74af16d3bf228583610e15ea139fb56c29c7434f53da53cb95466c655305409be572b98209ee7959d2decf1486db3f25b820a374b46224e43944db4c710683b7a686cfc90552dc83e8133ecf85d79083e39eaf4dabef1dc24cf1196b349bf37cf83a0483b8265d377c3403dbbee7a1351a854327a3978e8bce22007ed3c33ce986f6957e97b788d5b8410cd370f6dbc5c622ec98899926b2238ef784432d9adb2d1f1a3af4024822c945d13821e7ad025e79fb078038ed55c9b43c216ff67dda90a0caba01b6fefbfa799a17405b65b3da1ed93996035aee6bee3cda29d0f96c7bd238b1f961990da3c5fc0ce7d1e4f040946a90cb83c1ed9fac9d229a4f7b8a8d235ba209157f8314e7b1621f2a67016581dcd3d16a1cca4317a835a077f99c801b1c5753eadca01a7cfe694923751154e03f66c469777bbb333db3aa16c5621ba7f6fe7bba290cddefd0e4dd0d0412d6713e26e24f5357e864cf7c96e8e37dc7b0c7a612804c540e3ec6e781327584983ff823549890e5595ca5921b894ca7714b6e90e739ac12341111b2b82043c41ae6eb96e2469dae535be96d8856bc5ae5c6a5ad8bfeec8460194deba1edfe4ebc89e3807640a8d6c335a91486eecacd74803fef477a924144dddd8d34d6a292d633ae5465832dd3d3d58e53e04f7c16a0169c07624f8bd624e80227f5434cbe15cb86139b290943e30e4252892a8068ce03079b1149785e6d6258eddfda00e2d35e9c4be5c481c70a9f91997e0400dad195bbeaef6fe70e0427d386b63f60aaff2f0592346185a024580bb70b77c585b56cd8ad52b97d2e89a1d0c71222bb3ea91c8eb24b4a9337d27052daf6e7b35393387a88da7ff16767b541a71aba8691498be1b023df35e1919b2fa39cb26752bd621b3531fa760e05ea235f2d57662a9e683d1260bcd8558b03da6498d6f648ac5db25ed0ca3bab56bf2f4075e99f6f5041ee0a323f430b255fa62e0aa2cae582ac0a02f28f31d18d04055becc583033a78457db48015f16acca770fd166ef5a98671d8907559978f07ca882890c85a51af6b739767aca30df5969df28893b9dec56eed9264ae2ffd10494d02001c95eece1d42979cad09049369f537e9a9e066f609935beed5fe1859909c7207229c1812bf6e9a4ffdbc19ce9f30a402a694c979ec0f99000be5349e1140d6f708de983b2b1688cea09b97653e9799c66de8ef41a05c35582b16ad3f0e9cfb7f252d0f30bb26bc19c7388f4ee90f0c5b5ac7ed0bf80c7cb7d47b94313ca5469685c83ca1ea11a8c03c25fd1759d6ad56720903631040d182c3a41ac1bbba0c633035f995e8501794b12ca052afb90467f0312812dd41893b2e4af33040a10c199bd777b3a341bf799a2d14a93e878f53808f4ac0536db3f50e94e9ca1e339ac78039a0753ed6f0668394e9ec36ec4311071649dbbf7cd8ab02d783ef34663aba58e5a29fc00c63ea618bf49deaccaa0c8c5322e4cb86cbac0ab7dbf9fc871284567dd542a214a3ac0e4c2ef2b27a72e673512142f5b6dc9d21decb699ca3c71ffdab4005ba4f77485273fcdb04921524a853ae8b5daa576e1f54117ad902a64405d4785bd1ac019721d6089588daccff66bf24d82887d70271fc54a3887525bcded7f9491e9fc8524e7603f72fb76f189a04c87a8facb1b58f539ad5e82565a360a3b3beb64e63900f47c28a6d3b2e2010ca6bb27d23b8c50bca7bc7b010f353f905656fe59d109b623578cb8235b491fabbe39260931b2952da418a3f5c59135cd947f9f6612a217a550ac3c7b4b20043286b96d2efa9f8b3245eeb09ee59e5a374c0b8b42fae2eacb7043af04d0df2b7cbebb478ff4ef4223d72871be6e0ba81514f3638875a66ff3610404bf41dc2771536654c6635b8236273211fda18aea45b57bb8e9025fb37ac1a65f583746b47575d1b3faaf8fc46752819aa8557efd33a14994b76f40e93431ad168f04ed1931902d19372f3d2aa8877b81615f4a7678e2f20174be8b16e983677d3234176f56443b8b29c330212f4bd46ec984704f533b557b8f14d0ddacd13900292946366e562053097f58ad27e5f56b00e5299efc41802ac0950b93cb6129737eb443e9879988338080f29fbd190ffc46647e1721a8d53","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
