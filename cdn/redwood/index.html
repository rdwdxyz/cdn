<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5af4c1cce3f8ec938d0fd4ff9ef92cfd03ac80c14dbef0e205a32fdf1db6db0f3899d7d9ae8d09f1c6e87507fe9f419efaccbdf5254940ed55dae3efe9f784c84734e449aa6abdc9252b00878ee6a7db6e731dc0f0adf5153ebdf0490595beb39e21e0991eb247a5f719e92280ac6cb20c320318d44ad8b81f485399e8fd49523f51af3ddd5c562b46ad623b6fbd344a5d8263bf808e1071ffa09a792a1da4fd2401d3b312d0da9bc0691b80072108c5d5253cb9c16fa960dbaee3987b1fb33ad618e96e786bd4432b08165b7f87b5e91e1f30a483e01c11b98560a291b44d65a3fa57f915a5be3a8845b4b0d12cb31db8d029c0d293240a303c25a4b95089ce91ad3a564af9ea30f9617e7dff1dcfa3f1d40ab533cd08c8fd85878bfd9e6064754c2e698be78e97e5c20342ec62459369c539430dbf7b7834936fd3b95cc69643a68d802b5c83eee3e45478e1bea942124bfac9c06b7b0e5304a4f0ae28bae15f2c36548884f0700bb78ccdf0addf2a611fba863aa8f514eafaa6a395b8fd932adac4eb16bce04497cdfbc145ba937841aa46252197b9aeb2d87062f3d46c3da79f2382da2388008570fc580d7a9c1536d1f67a7f58cae9b612c77768fde62f76df703fac5c364fc1c2b69825a2c4e9cce867a762b14ebcd12c21d4bebf6a4049c6649c38a56e1ad82c40fa6101dca055a7c5ed50bca56c409f1b1d8af321dcd476065a326081f6d0b311163c0fc33134f382bb5f0f4b5761fc4185ee45f3b84344ba5910d733f03086d8161d01af8c04c4baa703b22aedb951566d498883a1d8c0b6095ca6fcd42bd114130ccbef7a9b5c5882b21b74e8ecc6df6b0dbb6209a3f4b81b0bb0ccafb7c05e8e61a43b80e12703c047fcc92c181b497b406bb65497bdea750ce17e4ae0435c0dc12fc393681978ed161b6af735fe27ba35b1c8834d9845c6f1478eb3f2833820945b9f93d9395716c74263ab93835666a8fb3b527886fcdf903a51f8eebdca96dd7b806a1b8ccb80398ec16a7e681bb8c348f01c3c42ee70a0b4bfd1c9352a22e3cfb1a624b89a6d2e2a229ac94356201c4f546b89c6429af98c890ce3d0e69ff51c6706478402a0b57b63b7772254580211c3be7e81b1e7ac0fbbb7143e0bb5d7f221816e389ba29567f831a893c815c4e6fbe8a2506dcbbbc464b989414abd615d976b07e0619569ea3c3cfe43a46ddfc7f3ea70a508c94b08b3961ba386b0fd4f7067c9aecbf2a4ecf8e9fa91ad4ed1e68753ff83992e35696b48b63db720627a223d77cdc5581ea971e24f2f3b5ce2e59f41a0a300aafd43384d7b48fd570f16a490aaafd84c11fefc7a911298354be6d23654c1c01f978fe5fcd0e683d5a66ccca8fcab4fdf53112a6be9a1b53cffb77e5221ac8be498c9cc8199d711cafb840e934686934efd5c478f664161f25e28fe678a9811bd170fecbbeceed14de3eed1b2b4e67e17c33a5ff62c28215657997f05460db612574f7e2b067f783036a836921a479ef090383b27e7beb9c34217aae348e83786b1141932010f1e35d814c5bb13cfcaeee36c18eb74eef5fdfba671068d9b3a2e209827aee5bfb9bdd1cd72a476ada8b6925b04afa7019205675cfbe958cc6e2142c8bf925b96722df242695fb0de3248740b7c3cb9affc98d3c451916342a11d0941ff888fc3d422d6a1d58ce71bc4c785778dbb9be571e9e87247df2d87f342064bbbfbd46bfbe28158bfd9297ea7284ffc1e77a340135d6ca34149b689e7f15979bb881cce726ed4e65200961fe07a587a81d3b923067286ff32aad2206e6199a7becf1f9dd5f99bbdba0e405d5f27c15a97a738ebfc45a4b1923e5de4075a61bc04ffe9f40146365208e3b4faa3a428b3be9f83f123891da0a937a42a6c8e3b12f16247d86b7ff4d7e4c33e87ee5eb9e842e0daad6f6db442bd25e27a763fde9aace65b4ea7b67ca647fe615eb19096154d9a1f40cbf7fef0b8ab653b67c8f5a0042fa7fa53b9dc069628d5b0a31acff1664b3c546ad61f906d2d637006ea4ffb9eea38eb235260acd85e9f599e0b07c60551612f5f79801f5efe34776ec4bed0ff6bdc5a7a624ef17dda24f1b98ece9718ac78bb39d1ca5d29902b83512b1e626691e7bf0e6c3126080352d2b553aa3053f27eb972f21582aec61e11f24b6bf5499f8ed53d539bfa3fd41cd6e39f9c89923eecab55f7c864e936ed6e904c0be887c16e38c4dafc00de6bf60e4a7b7b5a853c44b75ce2ebc25dcb84f8ac2503d018c6fd1cc4489cfbb6924cdc55d1e5cd7dcf9e94021d70b24991e28902ae4b2336f9605be08477c6092d07eb02beb3dddf2ed57c86512eeabf72032b023bdf8b17b1ff21e933a6475440af5243f0e936fb01b559ca5cd9efc5d0ab666bfb84adb2eda70da57c71f3c5d74010f7c1427f04fcca5c18cb1c0312f15a6100734f9fbded8f8de88431307dd62379fadc2e53e3676a03ccd34b8823289aafae23b4791e806a2a76422e71d5ae922ae307876deafc20b08149e1417d51f26eec919707fb2962e743623ee0ab841a012bb064dc4505492c16857dcd08853a85f296a376c13fcb53a094c1c283ee8c7f5ca9a9ad06db7c0619d1992349dc913857d666146586af15c3d5ec5be1ba77b813add443035243719adb2eaff2203a483d6386a05c3b8f6d3c500381e7dc7daef761721b448825ad66276707eef677179a8a6f4cc889f71dc3dfaff86f332a9ba2819840471fa97e4591af86009997ea4499da54ac3f5fbed33a39bc9bfc9040d592fda98b4421b8b788442ec6014bb1d28f689acaab4281764285de3b6036869f0b256ed554f01a40f11b3aa19284528dfaebfbaffe9b17774104f5c8536f1dc5b1a31168e19ae849ab312b76083ee2752c9f21c807a739976603f20e023dacd9ffd079d6bfbed71d2b2d83035083b2da7919abfd23ec4c502ec1efb74e62ba7adab1bdae2cc51fdb1c27d9d7c5c1a06490cd95374109ee459ae704156e52ce903e2b17549a200334a1fdf733e1d4fbc036a4ecae21faa37a3f9fe2782189812e5efbb20efd0050cfff2bfd7bc364933dea8f0991245c2a1552f2d6f11d10ec4cc31da151d375fd82ec82b906fba2af8af6b6269699cc5679562af2d7441087e0b5d1594ca2613997e45ed30e5a5c16dd9bd3bffa3eb5d4d77f2125c0f3a66f4a912f2dae0b75a2b91c6c2fb94b55c4bb673a8fe7d345a4629a9e8bc3b3fe9eb56a098aee80edf50117e6c88f9bd48b7d754fa3c66740850f1a94e88464871c612eae3473cdc6444ee3e8f4902b7f61e8b53e686055772eb1043c008469acb700c22138f056050313c0ce1aca434a6a2fdd031794435c96a52c4eef804e990332605c3457dd12d7104f000d0b0282a1ed310665ebf7bfd9edde3c695821e3fc9b0c6f575aa93aec048d58063c4be60421945ffb5eca5a53168a0d67088a726e3750917c6a54d8c3cae9190a559121c1901029a581a7f0bb782d68e39ca1601e79f66695435f12a87364e0ebe9c83d52a0cf1c35f688a7d04822073c8fc01640f35c3a43d96ea1b6e42781a2ee075e5db1f555aa6da934ddaf93f30eac1fc0a7976f1a859330a0740995489805d5f48570b01ddd114f2ce5c3e2e3d8fc8514bdb4f57477a50dee8541bc0a04c760844a32dfa235fcc0b4eebc1e4954c73180e3c121b33a3632b854f9eda26aced22e4377f5a8f9404852934b2912ac7539750dafd67bc31f2f5e6f87ea64d319f887f6146056541b61c1e9983ed70b9b2241dd9321e5a795b3c5c9b8f7178b95ce2c7bff30565e743ade3a1bb7e54c073bbedd9ccde964dfef37e5a39df92ecebabbbc7ddc9498eb5d82259782c6927ce94a8a1e7992b4ca5cb1edae026c17bfdd0b7838fa1dd170ceca54383c00a4a435e156ed87bd84c4aaa9eabd53dcc4407bd279707109bcf4b455a6a90fc2f8a670ffe27b02de179de5048cbc213e0223a8ce64b32c833cef890760cb814c7159d027a11bfa1b7ef32e60c8d5b67273a7b52f1a097d97ce98c60079db3be608514df179a32fb9ecf33599cad3d9258afb2fbf130f3e100a15488b8ec99bfe674a590b24e5ba0326f3851635b89c1bf652add68425ce41ce8d0098c559c83a27ccac5b16d7458b7eda9b510254290ce7cb1d03f4c5dff83ed75fd20308ef73bae0f7bc632e97411903a46b90f5b20790d9a3f902aa5d147df2274733d9c2ae21bf70d4d3389a82d3409198a0b4b9e1ac2ded043eb267f1d24d2297b9d83902de37bd765740d651b025c60696402d80d9025f142ef4e3c750c83c1b98000db49072491063b2404c4e8a5bd5e84bd2c4c0ebabfef1d703119dc13e05fc8b6b723a77e302e207a01f77da1961d60427f893a873b6a52fb8e7a944c4c627b92ab13c12165f3e585fc40e44fcbebcc1cd00713142c53b58851dbe7319bac6dce99c012cbe03eaa510c59403d986ec761a7fc429e2a81eb85a5aea772f7737d1e9d70987ad498f262c8328a7aca646627bf1c6cb5c0cec1e0080d1eee912f53cef7a6f2a3a88f54c90727cc1ca7bfab77383b2fca426e367d672e02555eb5f5b479257f8831ba864a826987468600bf8dffb45f0c01de809ba2258ba3cbc36e795adb166d5a3d21855a1b1530123947bcd7180d0fbc84cd8efa84be03b4028d8f217116e6ce54dbe83baf1c1b6564c6cd95d47e98337df9bbacb408109f0f4c8ffced8adcc87ef6e8263128160e8d4c6ffa51ad7335285203d4cc400628ffca313a493aedcecc57dce7aa60717c31b2bd9206aa17a942779a3482015d6192d8668a53da8bc0d13ab085921d7316baa27f35df212240f8eeca74b1fcbfa013e72fdd1a3322b521edd0efd55215b221571e46485cf86a1b0f3547c9dc76776aafc8303807bb575f1fa11d76eebd90955b1e6e73edfb4a161a23929acc7e033d05f750b24e99e818e46f0f8d92ba014a7a8b314fec5d9e3f6f0cc81287dbee08e81c1d87d3c15a128763eac8d8d34db7d98c833e51b26ac3117f747b3328c9169d57837cee635ec6870d8b4a33137f06a79434be01ff409c53efe5ddd6934abd48b92374d41009ace36c6e529e24a030b901196b5c4075c3eef0149d349bfb5077396c184b7a30f28ddb592df3f120ff9fa125e75bca0f3b35eb6cd89a74a87ff87c14296bdeb171987041d370eb0d01b79cc0e5c8b44a5c01ad21140ff5d70b08b93c953dcd54a588910d7ed1bbfcc714e71ef72890b73a70498b58e31c9de4047e7cb5050870e66927cf90f9edd1f5aa079b4b8ad9b690e2579095a622d7c5a63db85a8ba533ee6cfa93576a7c52030e662b099d03829103cc037435f257b45000d0425e2b10537a1196123a679d470dca736e371d4684430372c50c2fd72acc389ce4f765719ce2b07630f21e199f6bfdb55513783b9dee46a9dd5541f99876cefc313ce74b4e2fc7119d30e6015cc66ac31ac884137977c50d8ed2cdb0f8df16d7dd4502fba1f2b4de9a9e2ab33b3b4fa4e9e60eb609c32798bf7a4e55bb36cb34c54476374387fa86cddc1c0d2dcc540c4905f219284c5215c11c3a35c4a2562ef03b056113913dee180a258896a93e373dcd4fe0f3489cb081bb92ade8768f938962959a873b3313bb26c85e9a4b51d51dfbb277997ad324e4515b80f2abd342ee6e03fd18fac37fa2ef55a69c9d3e118633fdd7ae4354264e5398bbb10c35e15721e2f2233edb26a4e3804bdf6482d04616892d8572bfc8ff9e12cd2c90209fc09df85691e08f1949a1698574fac7f4fdd867ea2bc371e88d3f0bb947bac271ba1fd60b9b0668884e7ff68c5bd9710e87d0dddfbc1eac3534db76ed8e4347253fb1a7038af95e1980cc9761a21be70f16fbc864332e4a5dd21f240c8beed01ec94ad0fbfd0862c73bd525900916ca114551566773cb597c54931606cf6fcfe3233ad6897256b665a63e3c019830dea0865571e6505f181435be2e16055b8ec9ecd0236cd07c56958ab00416812b290e6147b84f8c9aaa49f6c729dc1d91e70bfdbfc84a2bb964e5cc591073883720f09d4275fe1a012d5fc35b0e20fcdbedc806dfa2451e5c4539797101320e04a6815558f4fabb7e3c64a52e3e1f966b7fe859aa0d885bb6a55fd4ad0e06274807d613415697f14a0d3171042d2667a8486b2473f3d48fd91a45ecfc984e5b37bf9f742df08f4202ec42421d8437620650845707332fd7fe8e1e98f4b03f543aace11a65005e7fde357681a3d658ee455ece3084db8508fd73e3e71325ef1e072b0847f01597502900786887ba14c834db0e20ba5a5311084062670cfc496f18533ba16cb27c8b59bcaf86590db9cc5694d408920047053cff39f2466391c4dbf3260fe81b48434b8d85c9e5519297e703969931c72ab8f9d0e54d9a282a02a7ac48229154dab5997b25e8c2b3423457ecf19a9a19cdc3ab744aab4321120431af2cec52d40b41706a52675ef6e8d21205c492868397f4a58a06ea5d7648ce316e2451e9484fcd4d9ef46aa32bff7eea92532ddfea076ad82efb14501f8ca6f8cadb9572f54b07f155f16d78353c1e641f2daa6869ddf74b740edfbda724a31eb06110362fd91122260902e75ffe3c0461b0e0e7443b8a233ccc6bb6fb81800c9521455ba04d4ff2b207d9f4662bb4fd650f16093144428cc8ead7d5ab9742bf036b63de462280cd4f0ec70ee94e2fa72df1a7095f42e853725fe51b6fdb481ba51c55468bc643521c3d4713a8bd127e1e52cf75f8fe5ee13e4a9eda462eb007497382ab7b8e4b9884eb599c51975fc8f6a0203037a7ec05466402626aaaf6e966050065a1789973c0a804d5bdf17ebec712a79b6f2208a9b31e1da8ab738a8ad524228b1a32d268b57366eaf154391fbd119b76efd98ebbbf8b5eba2775e7517aca236318b8480b924d41a17e878aeb9a82b851013e7c720e77cc36c32e4015ffa912d204ea6a0e862eadb0af22c5d7a7b3e78749dddcfc24d8fccf2257114a63b8393b0736a6de2e8180a347271edab3444a555064f0771490eee5be3b94e8c802bf06558ad47ccfe7ef0de0c820757c3530a9d3bd8e766cba1fd8b9b01b10c3bafc5c76faefb094652150305938119b8a88e4bff72552e63226be578418d8fee752507fe4d065635c6bcb5ace6d9ba0ef375743878e99d861f1364f8a84d68e258110f13ab06dccda5a4db79e5fc8df838d647ec11b3fba97f3083d760179ccb1885670ea10b0dd6039cb0698410b2aaca1f2d2943b80783d66d2f6baad9383d67f23e8d2bd640e632557e0e902d13d6cddd0b1135587286d4a1b309e406ed06a0c54792dae0b9d4288f47805d2a2e3cfc2a2e53acc4d92128b71cd1a52e1c90d078bc0ab393e559019a16b51ac20126eb6de96c834ba9185de8455dcf4a4e9f7bf173452f13c3bb9ad87ffad70c0785aaf70e2ad993651a609357661b78bab70926749c1e0d880ade1f36b456341ca891abaf87698e27d53984122d86197132fbe23c32e263060a9e19d8b55a7df1d7e4c664624ba25edb785a3a357ec977b63df51fa1955a0005d77b90871bff11c0df3ef5d951ada2ff87e4f274b4ce6829b2e86065c8502f92f92f958323ead07eff8fc1ddd47587a2a4fff97d5e3bd2f531c2f75b5766e66a93078b673fbef18d7ca8022735fdd2bb8326409e97b24fadc5e53b1658558435d4b4173c2c8260d44abfbac2b4cfb4257c3ab41fec5b2560ee0b968eaac20dc216002fab6bc95430b9fe8d3eb5df1a8b14604b20553b2f20f5300049b2677a15c72318674fbf0e7dd16373adc7ed98af55d4fde8715f73cc8b0fe0056f5d30211b886eceb7dc9836b3c4afd505618f46be9d82d3b86fc83c20df537fe4d5dea1cb824d971f474324c5489f9d069acb0f56445cfeb05ef1dd3685e4cbc9ac34c96ac1a13e135889df4dd143d5ae7764e4cd29d3143472f7827b73f00fc6302285d8046a0325b59f87f1daa6393c5454e31666adb856f642db02d39aa951fb2df793f0153d8c1448fe72dc621f8e2a4be111051a5792af77bc55befed35363570ec7191bb0fa0d6c697261cd61c983d45fd96a34f726862de551c1d2068ed4c87986e87fdaed49b1d1bd04d87f1d614415485afa2b6d86063201296092ef1fc491072de7a804429240a34e1c939064ba10f58f51b880ff415605a7246e35695108fa8f6a29eef739aaffcec5734f7e6bd85117759309f93d93854bf84eb33f72c51f72f8a1357b7341dcbc9df7deb48450b202e61e89433b80911db5e78ae0a620d208091163b1de63b681baf6085871b354d519465e53ae33303a2f339d91bf4d5bbbcfdb45b9b7dbbd679e01af311efebdacaf751003cd820e3187117550abe3f50bbf71bcce7e6130e8317322f92d1a10403cc128da18a1e8100c8ae6b7800502509ad8f4d8604102e51b9521fcd536860cd3c414c87dca3e45dfd6a90de3e0509a7b0ba1e3253a8018d4f9df85db93540b30fa61e5b475063143d772741fdb4fda4d0aa6ca1a70da04f9be59a8faab0d6576f2899c6ef3cc7d666832f8434d6e46e6afceb4c629388b99542a5eebd35294f5d220e37e46364b73e15d33983cfbcc2ee9ec005f191a9fbb2c54e1756f845c044124f15aa516909cef414fe7f9b62d0e24f6ef0cf68f4a0e2ff66da79ed1181cb5eb4565e1f503dde933140199d0938f2652e2f25acd26a7c4d77a8302b18aec80413bdd4398f91a3abe051aeaea1cb25c01588ff68bd1b910249f22819885c77db8c869f20b6cb4b0d6f9c1d358279394592abf48034f929b01e59649686cf59a193705f307e3fe20b727cc66f6bd534764d1bdd28d6522e24b5df1ed43aefb3ea40111f0cc5ab56c3157437e4045e94b1d22ebfd63fe22d64e1630ddc4cf67faff62524c42fde0c4008c5cde831e1f59948421254174a904bfccf312e110ca54a98f84bc223a13a49a09ef6e8db7e85ce730c98658a4d704e72ba166e7a6b7b6da12b4b772db4ba505b084ca7969176a113668e02f07fcfa8c51cfb79f413938688e0792b380ba810000c7df2cd495012609836b771c1ba6c3040941a0cef8b80580639c9c29ca6f957a43ee07f8af88e72618a079db72eeb46f33f5f53110018b9a5ed3dc6aa6a10d2c883d7b79e9c08c1702e0556afcdfc4062ce62950b48d71ee57cb59b9eb72137e52c8b376c18b1c3f7e2cab00741679012b3d9dd0f3f905e8f8d4d703356cab0bd9aabdb0f3f72e35d1dedab2c8ef738a580794796d178233e09b5a1eb830e4ddf9edd2eb9315e635f08575479bc4b6a09c1092bdc06abf50de2cc6cd7f3486842b67f59050123e6ccf358c36202c99a7433c6064752d10f19bf36ff72d5c4902af81e4d85b88fb98ff97279951e833eabe348a9f4c7518c8c560f9ec53ef37c7bf430aa96b6082003435290cf1c90b41dc2530c23261780e29581a0231b5eba3764f2e71198417243eb52bcdd749164dc4d6789a4c54786e459f5f0ca7d276da0a47b770e450f0fa674cf6748442f3d07f08e576566cbbcbfe9bcbe135ed631e680cc81580a2db794b0fe59c2fc14ef5f43831d5debadb87081cc5a9908d7ec356662d81c951ad5346714d8440d90c49bd7f8fb74774bf4ea64836d5e69f447aaf7a6134a0a92931693b2ec51aaeeed36dd5ebe3373dfb1d00c2a3ced3b9892edca0989dcbbbac3f7c4c180d491465592db4ba9099842bc4c14f08f0c38d51139c385db454a256d9b64d25ba99aaecd41d94c3ac85c0f3a5052e4578ba14973488dfd212f0abe818af9bfaeec9e12417b2aa4efe32c7985047d7dd55587940c5110146cde9b474498df7181a8339b2ca07e56c7002bd03d047ef6a1bfef81f8e8ae65e6d51ff695815fb90f56536c99d23b1e09ddc897c3bc88a2c84ecc640df4deec82f979eb84728b43f7f9a76e1d796f9903b3c563189f4861396c4ac095f192390ceb035f6206235d95d9593b837ca6597e3fd39f790e9b65b78c4ecc5e00d532492488d7fe836bce3c68d7eeed399757d24715f779cf607e902bccef142b8cc8c9cec29835659807f4db499b0bcc813e71e4a35228d956ac5ef65225a94dc39749e813e6702e8b60bd8c36016d67bc7acf9b78b12c37243a750f575e7f300255dbc7817e454cfed37530c47dc43384ebcc6f8c15f292e5508ebf65b3fe812e97097545012c0398ae6dda59cad3501f4b53e31de2c378528e54e125ba2bec9b61bee873bf655800bdc24a2a0f16d0e2e14d197b5666d7b4a3d99bdb98c3d0ba8bf57bab2ed8bb6bda045281123e500a121463d57453717e4591f3f6e1f7c042646f977af5d773bff253937283dd2369deab70c6eec86ec7560a8f8cdf37ae7463bbe46e14eb9205b8fc11b0a4c2187d670bfe73c5913527e630755cd014d9e394c5a7225ada8a8fedde55820db61257ca96e8bc9cd325441858e5be2eae687b5a07c5325f90bbc13725c7145f5e4a36754b53a7ab8c62c37a16f89f4a15134041bf349f12334d87b39ec9fccb61c65cf327da13d1eefe59883d1354e66cdffbbcf32bb2568575b3ae1dfaa198adc1b337c627795fd53848dbf4509bd5d50aa766b07b1d2dfeb5a737222cfd97fab34c6e4f752126cbf103b75bb4416ccf6831c245b2a667e30adc9f4d118eaa4a6e91064926fd3c1b47694ad364c58f72ff8e3a05fa17a8229c258a1cdd13c223843d8db2d9796d492eacc05fad3c53dc3dcf05803ac233fce56dda2361d066b5ffeee02d00527e9287093bada31a1e304960ee244fdbb6c89ee44ad69327c516f2666ea5cb64808cbcc55c2025a75c129e5b0f8ce343c21ae0642efa5dac2353ad7872e1002251a7bde334b8891aefda32b80a5e5fd127a7c8b812b888628d8e220b6943d324e8da99ae57b4345f99cddfd6013996978dc00d021aea9c2d614d1c533d5fdff977a4b12274d67aa9457a6231e701b4340bb7ad20792f9441f04766071e23b0a8422858f9daca6d038dd4f1ec219de718de1f3330c128ca70860a051fa1d289377f59e2668f73f854eca7bba62da9eaba4ca64fb9489da0fa7ce834a7733237b6908a8aabb6ad9f2396482b2092eb7461ca8f39f0af089973f954f32ba671dfb79301a2dd56feaa7b0ee54d74d676bdeb8e821e40f6b4f38d3075c10f46d52a0bf4df1f4545d352e9df3c25513c30a3c6dc9ca5696e9256ca144b8b3c4b4b1e09ffd1be057a563e9a1bbb8b175e03bab55d50bf83a008621a16215aba0553cd5c81bc04b307df0e2bf81b046100b42b4d463274c1249e2743159b262ba25cadb21bdbc6573058c9b7b054dc4fb5f018a61ea95c196470805203899e3579ec3e6f49743b7cbfca2c79a86ae5adc624825ca346555b30ca702a4e7ce012ac7bb8439c634deb04551aac890836c5f97a00804ef76a5b872080992f2d615e77de66c78ac2ffc6f7c8f097154ee14e65117f9e6f32317d76fec3ea243a7df5c93a3cbb2f93b2ee58b1383d7c9b09116633c24089b6016bc12c4199fd21b5f1be4e8b1eb8fbc17602d195f2d5c028b02b40e8b9c94076fb6041b7041caaa62b115ad0c7842390432cec0f2608d8a64dad1e8e99e1a96e5920c9f430c03cbe48702a71e902ee8da04e9620a69f50d030483d2df891db31511957be4ea172a9abc98b588dff2f38caba4e53e5c239494285ac33c581fa10748196e65daf1c8e096490517fa68828ebb81271cb00ac7940e6f93f63910d0b3eafc3704cb4a681d6491a67c594ce01a2884c26a4addc23042c3ab3e163990ac9826dbadc3c95600ddb251c3e12cb0ffe23a50436c863357a8eec239771266653e740429df53639340eaaf0527baa27f6b88ebbf83b89e9a139a8122f917a33c825bb9d665e03ffad1400c09625419e14e5c77ea98ea2e97c92622168587a8897516e24decab46de3234741a88d40ab1d1ba8aab36cf610ad6d33fe44ea1fcd1e54c327a9d59547e50e0b30b15ed10a5eda27e27bc48ecce6eca3565a20b3666e14e7c94f10c41f4df8bef63fb07c1d8fe7acde923b3984f5139624e8837e16292520843f408a86ad29c1456868220d8a010a5744861d4e854d910c487d16934ff7471f358766a51eb4e4247d00aad1cb0347146e1d1088c7e0ddd1465c189462db218dac6f36091cec81e80d5153868c9b94044432566740ae31002d8e4cd5a3d761a9304ca0c38a12a0c864b141de5d7c28860086d2b9b474708435e02206c2cee7c9e51cf51250742dce5264dd2b44bfe6a8a8ae46d0739e957fad70494f5f9878949c8183307bacc389d0a63f151c2afe39bb9713d6fc84b94d423364213afb50b0b63cb506aeff370eb1e5a98b923dd0d59b7faf54799c6a66a2c9c354ba0a8de09ad615c4db3c1b90a8a179aaf0fdc60073a5ed8460f42f3df13d8073c24ecfcdd6b4ce1deadeb833628f3b156fffe57d0d71a8b6ca62bfcbd91155e99d8c5bc6add14772813c82c434c16f3e93ccb71bcefb1e143ebff99e5e4f140aabb249cf3ad680f406f44eac264006d5e9eb11a0ca689ffc8d8574d984d8da94b415e22fe630822932f5e2613d0c7f1c7cca37e176ec77834f32d85d2ddf6a117d8e529b5e980060b646a26df86a29fde786a3af7c0d57c39b7f9d8fe667f3a9cf8d6dd9841d2909aba6f31f5a359050e420203bda3f2bd5949281a79e915c0f0488c5c85b3a62a8e26b4a64c5d76eb70e6eda1163beac7981af83a8d8a557cc716d51d23c0304678f00d05626d07966d840827089ba523fc3593622cc9241fd91593102d1c7997bff969912a16b65b366b7f25264bb1354041fc86922befee31fb673a719b93d4c0ad5755e0a830a15e3ab494ff163bdad843a79b093c708e8de0f8604065acdb43b08712fca6b3b77e30076049ba3d197b0617925261fbc3df97ced352d2243839f796fa12d05e1aa56c4756d688baafb3a70a93304a5cbe08f4dc0cdcabc3e94d1309b6a7af24768577d79d9322c682b88f4e5aa54a0254d4438d7083371901d96a7e3a9b04d7b890466c40b1e78cefad7b7a9a09ebad544bb1a4fe45742998aa9963a22986c45cf231940f92de98845aec7e820ef8dbe3c9bbc5e49b30695c4e5dede55c3d518402abab2e2d47483bbe70d3582f79ec6bc6ac9bd7ae091d4b75417877cbdb639db57777cb558174e0528983444eb91d93ad9a1bd4f0cab3513448f07559dba8a4532e4dd354fa4b839ee7308e6fb9b0bba2de28dee352026be2a835922eae49f536519e6cfc26a63b57bfc84c232070782dfef886a65f9cb0b6b8d71390e0912aae58b2bf9fdf95f870947fd48a944a8958bfa54f581b45cf61deb75301901a2af6a7444899f7f4c279e563710c879a2bd8259198abcf9fd41f23cdbceb5d1c0dc567c93a553011b4fb1dba1bf9acfede0aec80046909290879aa0f5e12168b07636819a595d91b0ed5119ff96bc9a19ce5eacff4a05fc2d885f62f0d8ea44c26f773c26a0849e487043bf057dff4f164fd3878759bb6b98daf04a9163fbdc53a5fa4d0e3c1b37efe82e17ccea82e931a5daec97818ed910306889e7ced66400aa846f021a7c0412264989ed6ce6949ef39dd49f8ab325b614481e96a6fd334c5f28d69f4be607b35b92b812f6b0090cf25972110fd4ca65926724eaf787b79377299fcb053ca0223d84c052e076b22e128cd4fac33560388386a8fa7a8eb42ccbedeb5c170cdc4a58cee3d2820421180de8348086872b81d45f0c90f73bd948aebb22d3f17dae3846d9563c75468c1305f86e3bd511875162091641b31556f4b4825dddf69491589b98766eff5e5cb26645bec42f1742f0bbff9dcd46746d5e25d460d27f8abc1d97a1579711746f0fc13ffdbaabf0c962c5b7b8b36e2ff08f8e724401b8e6640a00d247ea085f2e58a8f76ad3e2d5e4c0f70aa666af150506246c9c3d0cb788355ac26fc89857d9388b9a01d09a6abca54a1a364faf002a17ea71b1e68d2960da603212c5d52ed245120e37598dc9575b413db9daba6d3feaae01f0fb9a56241d81de87421e2f355135e5b5900a8d8c3eb61009a680af135fb874d9b9e6579ed0fd01242ea7f87753ae196ce1c05a26312fe23fece06b50ba2af3a56cdb321b00cbaf1e7d88116b596219b0ef319b29452a55b80a023c51266ca756e65f5c297f53ccb129fde247bd638ebcfe8eb12c728997c1238e9ce470b8f06009f70f41dd418f21735294eb7131ebbd05d79ab496d4294339242b4301ba0e96c48eda704aa2febfbb062f1cafc2e1ff56bab6c34be150a64adebbc8ebd598bb45d6d15a524a00d3bceb3cdbfe28a427778da5411d9d9f2974fa097575d4f8928341dadd3f20c667881c597e3c5fd70071065d5c7f601b345963836820abe1df55d52083d1d85a35db699f8d5b9c3f11a310b9b83c086186899f90e37a7a9b2750ca02b1f41313d7b35d551e71a005cc55cfe716cea8264e64ada18be2421b35b543f5fc4b328612baf584ecb5447b17717a6c5d6fdcc9611568e2cb83e67b6363537583305f351535ac239586ec69752ce844f09b28abf30a8bb9760281b4a1145a2d57e5ae52409e4920201d0be00e8105c79033f7b4c09a34fc89ee9df9350f867632d22865786feda02a1c7aebb1f566786cecbdf9933a503fa8ea9c767d546c7976e627143c149f526a3a960d8d79c039c1383599ffb6fd5adbe6e50e3ac713033f69330d750239ca6710532992d2aeca4174749c8a5593808ac1a6cdd2d70799a8815ba69515b95bdb443bdf2d8976441c3e2011a0f9a3872c97e598afa152892a6e127f3546a2a58de212353be211f446f65c8bb5bbcd9f4590680e79c759e3f3634fa7c2d7bf20aafebee1c78c9721b2864245d7c9b6731c02611d1809f8c49b330a7a77214ad1357c992cbd16acd6a64f03fd04f5d1006773e613e8257b8bc863777cefd899b52dfc353845c8f3ac9c5ef7542405b49609bda4122240d5028bc3985e409c71697854801085e57f39264bcc1d05945a7bbbffe10411dd16e670b5e32d3254ee477275516fde7cbff5be10584155b5debb5055f2764b3e740c1a6468b07cdf01c1cf736811e73b4f8b974fe20516d8bcbf3a63032b73b6f026b76df56f80a3a8bf8c4bc27be487dde20f90a75151d75495dfc99871524403c41f08682a0de56b8db403dc3a41318af24a92031031e50f1719af6fff72550618a94128fd8b913e3fad20f41b7641024d5bfb157fcd589c4f5afa4c24c8c89b04541e7eb4aab7fd64612f919cfd787bfb0393f62534a605c7826aa77a4397dc0c0f7186c025e48fbb19d8de58b48da938ab025974c6a66c9906b15dc120b86b42c5847434c044a70ec626ac8e4dd1197774d8205b8cbbfcb0f1675219cfaa247fc56f509277ea9c02faee9f78e7ad9bafd0e23d1a01faada0fa1be369cfa7ee4622e18aa9b4b8726ee5e1420a3229be0ac66e6b43b83948eb8bb114dba760f9cd2d9465ac714afd31c48b1d48635c07118443b3917c848217f8d63a139bf3c07758923fa02debe1161f9bfd30f51ca85fb3c28fcc7fa3fc6119cd7467862b318c81327080a5a64629d56ca9d0a7300076c07b069cb4bbfe8120fe64aacedb911644a774eaf88040e21bdb49983e8e6ab8a4d415ecac76e3b6a41bd5759e6384d4b5658bca7adae74f87f340ffeb5c3a533a50cbc027b241275536ddc4d0b886fd0b53090f938fafd04e5591485c4d8ec2c2f2ce77399a6a5dfc66d1983814b17aadb48955420e2778c85e56af880b5b363ecd124250431d10a0f85f607b4ae57e16244110b2033b32a81a864dae20e999cbe94f6d40034c81bd32d9bfea0c0e586703d44461b2fbbb662303d1bdb834a4da0010d45b5d9ff234b05a9a5175b9b5a614b2dc48179fe809b2d7ff48a3103fe33953ea1ec74eb629706f50ec2e376c63f06d013bc4b117195b46270a40a2392fb5bd59fec89d94ed0064f91821bfcab552456da682c2770599168b6929c16996c5394be2f9378c65f62c0c4a57e8ab29c5b42eefc7e2f14245e9c32fa683fab6836501b566591a270422fba3e192182f3f3d3f24a164fbcacef997662914e553bf6f4f06e2770e5cc07cf491aa36f89db1e9243ac6767c1bd6c69a2121d80d73d8e41357fa01168cb3b1f701e0f9cd506ad32df8298212b0478acf466160cca66f37806ef2811fd58c3cf2b268d6adc3914f1613eb6f8391bf2b47dcc7b37390b45474fddc6bfa38a490fdb28f67936967d5819cd301808ed411bb770f94c831bf03a13a6e20c68e3eac408dbb682551e3e6c45d3d869a199c0a356b774dfa1612f12cc72671eb199bcc673f3da10158e7163be438ca5bb0b1b8b2fef06683eb90147b375a017c19816a3247379fd46e8237993f8fd1de0f264f97d2f77ffb6d928a7896bbefc6a2da461ad1065504c5af1720fd28c4873c94c91f3eab06e8909f2e1b0e04aba5eef70a9b99e95f5a0f2dd57fd1d63e8ea3337813a84f5f5a63dc24c7b7728baf8a1a83ce05e334360838057bf8c9fc86ca407f4e5c9b772052b60c9d59588a44d9063fb70a0aa6466a78de29a5d24f154a65aedbfa95c863cdd7abb56c844b2983d8a0f0e07ac0967c6c49bc6398f34ee7c7d432f4d2a20b3907be0cf419a978bd0adb8e6ed320d75950c60e9f0feccd031abde4203210b4eb4ed69306807881c8540d90d37d83645f65c8c56d4246e079f7d8de685acedbb0943548de5103700242b0b3cddd27d17877aa178f571667b5bf4948fe1a8b75c403009f09e2e6caf1ef3b7218b01f3b129ec73e68d17aacefe5f664f353da135515832912a530a5f2663681af99a4b9b9539ed9a314eb1edc47f8ba9809d0776f34af4ef29a380fa584605bab85c46b47ad111ae3e4c3dad7d88706dd190628fb3a78935c9b5f408a819e338ef47c09242a81d7a91deb9d72af67d9a9936e7ff9a2218448e5dc62c8f90215f52e0b9e32cc1b5d7e00f219feeef7f901c7edf6cd22439b017b976ec12016d19303eb63f29ecb8fd461f43c4ff348689babd576595de8efeba0665b56f403cf4293321ac464aef67654ff888d0c55b2352456bf2326e351aa7fbd1ad6386ec5a456be5b0c0763c87e7340302d63bad227ff24408682990b182f8087571d62221d09e64a9b46a3d20791050bc64cbc49c51d1cea513a4301a7682b9895c89ce490489106b64506e5601781962786c3f935506ff161843c2b99600a71a7120e2f499892e12a88ab617bea400526c354670186b06c11242ff231f55b64d19b7a1382ea570fbc731377bda6579796a3a002722023640c78f92c563bfbceccf6bf7b3aeef8fe41cbc0772277c8347fd1fed70f40d0efd0047f1067a30525f6622e7aa2de661707951dedd0fbb42bff65320fa03bf1e0f86978a9fb191571c42ab92c51fc96ac92875fa0b1aa3383b1aa362b1582fe12352db2edf1d990574389e4ba1ec6adde7a2f524465947a9998282ba2f2c61dbeaa9d616e1da224b719d8f79805c439f6c3713d037968beaa32b4c4aca03b9ef02f54d7857a4781c8e35955bdf9f49a1e6a57e5187c425938d59914d599855cd8e1d9ad6743457bf6703571c61cabc58bcf6de404c8fa4524b2ef4a9d29dfc5e77932a9cc6c42f0bcbca4205bb17ea326539def7fde7ffd92262ecf199c7dcd087963f8e1315c8249fc9065c56d8e56170426335368f142d0f301087c9db8935f2dd9e8049e0b18436f89747d3df9e08712deee1ba7a46e6d8da755d041ecda7de3d0ba5c8359028274506d7130601b4947a019298ce0e2635fac8accca23189331b4b7909890bba21228c52975177fa2ecbc73a6505744e70adae900f48d8c3774848bb8f790f29d9ef6056684583455e7c11e6654bb7d176ed69c261d2111d17bdde8fe2b6fc3fb6c42a9b90194a7e0adfae056c27ea2bb986e6567cf159d2d6ef83e1687ed9617025ca87fc0970d49146992d59b56f9555539c1b3cd3d315afd0c566356161f4efd357794faee1a645","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
