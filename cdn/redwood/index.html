<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3526c2d15bfae1234a0ea23c2bcbcb07f06449a955d8790114bcceef48b07b8f7bfa47f82860c41b1d19c2b3c5b95778c056c1bbace9c5af286e8fea9bd98523aa77e2de2eb046b57f6629bdbf35b0f0124cc61493ec58f734dfe4d3a9c31a6e7b81b22ccacc84d2913350d4535b9ab7a44952a70d450ff3c689edf53019c8e7b46c3af3f73ad78c9ba1466ce5d8221e7c852da9a1e43c0bfe03ef4b566819b63bf73e1ec0f1dbe6f710db7f45951bc026acedb6031741f8cf00b60da406d91529e877b7bc6e1283a1ba52205745471962bf3738f662909e7cb929844a95efc83f1b025dc60311f6855e16e994623f7834e383ff419f1021328bdc8ebd70c80014e6bcd73908a73bc157f17f831d2e4beee8822a9c698ef437abc5737703733c409d486c45ac43e8ef071f847b8cd91a4f85d0bbd45833e833483fbaf7478b84397d68aeb937f72990f6fa908c674e11d9303eee1d448599cb8d3793817989c3ac940df419f74611d7c416e8a3063789769a96bc418033cb2e6ca27b485f105d8f31a2514b331218661a5003412b4ff787877187e92a6e6476fe947739fefd61d4e6a0d415c2eedea52c46a809bd2005100be6e82582159317e858b17b1c1986f6f3ff6f4727226f2fdfb516cdf62dff1b7136cfc069b9f412bfb2a9eb00ba21d28f354220dc68df6a317f98005a9dfd3f44cacd9b2e95f62a8fc26edb0244390bfbeebd3430d0a7ca9a02b4de6d73c7991ecc58c9959af1f52a72f43cecfde0da09d84af5878745ae39a4fde510f5cd5983c6cd332699fd661284d03dd69af8ef8f65ffd9b4d058249fa9ac0b8a95b8f05a58eb5176fa4ef30e81f3293f12d6a896656820baa37a1922cfc7d6ff397fa6e2373d6c6a4326e37b6e8cc3722fc7bb0c92f2ae6d6be045f76bb8c4b3980b65ed2577e2932df328e86da7a187c78628cb6dbeb1899caec3285c646a22c274cbdc75df28a3fd1db11163b81f3186d79196da3bef2a190d14cdf4d1161b1e44ac376ae0f814cacc49b54d6c175e16a197ad886b967745e8b62a8d262d91762a99323801596b379b6fe019ba829c4327ee99c609e56809869381afdb6c934313c23cb9c1083a48dcf39a7ac402f457f10df3a1ed60fd095b001538c87900f1f0966a5af4c0c8fc7ea5f8e4069ef8c37b5510a80e30ab99e9ecf3b2f26b6b2f494b4bf4c11c7bcbf427931740d7d850fae4abded912d12978bd9fc93929e9009165c625a11e666c1db6c8bfa0d553773aba0fb8688d847f0f16f49ed0a23dbfc19d2e495cd41c98d8aa03c05416703948550edd190594e2bb3ed0a31c31749b0776773ec82492391093a6d1f8e9cd7b5f99d7beb6dbb6f40b684003229ce6128715372a4649e50199608ab414236044eddc532b22690e55d429df8b03b48eeaad9315d4a643168180ff634b017a4f298ecfb0e8f158e3c47b12fbfd669fb8d6afdc193b1094ee768d8e7dcd159fe0ed701c7aa536e0f6bd6805602a9ab4d289ff396ac74fb559b5aa9142f14f63873d69d18d5b3deab53b8e9b95a552c9fb25fff441e2a6cc226ad51dd2908d2b7bc254b68acc0fea81259e8d311d7dd6807c3562cf9d750839813d3ed638c6b2b0cb46732488e1538af1f1cae6fa5573c647c3605ebbc341c60d5288a3be65ff1dda0989986b76e6e80fbf62b70853e0bb6c6560160a070910c850db5fa6baadf8fb7a795e20d7d088b77a90a15b83f008d5df48d0131f6a14251af7db3b6635057172e43c7e7f0754ea89935781b5660e48852c965beacfa5ecc8813bd9e59420bb6c28c57b11ef5aa6dcccb0eecfb55af21d286a6cfb92f5e2a2ded22433e32e7993be84aeb68d204eed8c4f2be79b33f0e95872c146907308887a2eea84a43488fa3806acac805f999e857a867406a614ec35f090189e51b01d3f78c1810a9dda6879411f7aeb2004f2b1cc6571a66c705797c9e5a06cf8b83314a49bd4fda4c29ada7075d07c179546b6f8c400e4397e2d244afb56a01e5c2b0a7a634d6aacba35710089c26e192322b9a7a34517deb3ae7a4eb1eac5769bc7d465a9e6527b190f072ed732cd09bdb79dc49eab0901a1e3bd54c9bec20711c0ccff7a89f5682171eebf69333835948d3a827fc275db4c84315c6fc8c00352abd79bd9ff1c40f963fd0396e2344fc3dac5754bef5648c3d1699af39a7247908fdcd680abc0ea9ad2d86743c442e1b3eb7162ea330d602f142a08f592290d7dc382b1714933217905261901187284a78d20c3ec276c238ccab96721d2a7050ab2c603824b6e50e2660cc4b21923c2427b1f314a9e78f09660d28e6ce865b5e26e8b91106e01cf35119b83f0da69fc083cd2727c3cf1bb2e00d376dc9f5fd27c630cc5363f497da676bd8b5b9608a6615c77ed21ad4a0a76cd582ac53221f0d83df0c284984c7c668f961f53768a2f0b6c8dec8a476c99c66484bdd631e3ce0b2a16fb3f527ee0e3c6b50f5f9e9ed5af9516e8d2da0e98d9be3f5544792e34b4c6ade75b0ae2989c50822e7f5f82f7d1e31e04f56b1a1842ab8ca867db29b72461ceba7e34d95e415ad25c176f165860bf61d4b4b2a127cce4437737a85a9345b0a95e9886d4719ad75b37910c05045a11c1801603d2b072ec315338de89b5b3c81f849de8df572a1450c33d21ddbdd511ae1707b02282030824098da104b9fd5cabbc8719b5fbbdd413ac9b466cb65a889af915ea4a5c5b4b8c30f2f05b3557d0c1f8ad582df1965105230bbef3eeb8d1922d7fe75f628e6caab2539a1c01b8dbaf85329b78800b422b54aef75bfe7168a7126fb62acbcc1169cd50328bd337552c1d0043681ab912ae6c56ce0bdc130ddaf4e569f59bfccdf0311e5225cc53c13a78d9b3b24aeae229eb2698a058553a1aacdf97f4ea33426027914a6da0bedd2c29f87e8cc190871f7b0093e67b2c338c7b9e346680b7c016a5e6ed2413fee9908febbd73099ab98f02f58d43739aa99566dca5ec76181c321e28a4e9399b9bf4c8995bdb3f3cde159f2349a149de6046f2402535127d15e90a3a425427600f3bdda06e6391b21e37c0a44be741dc3750dc8afec2577b40433361e6820fd271a4e7b8cf7ffac6dd171df14ed8715c8d0afdb33bb137784fac25482e8f1f340b4c822e375caac441f9b9ae189789f34e6486ee6a363f55c2f75cad89160ff6f5ada6869f24b427597b58af0838d7eabed54e37f7df9994e1428550e98252f8a82e90614588345fcc3bbd5a135f08730f3d9fb9a5e91bd08daf5730acccb9a92ff45e5c77782a23e2f4193609147b4ace5c3405093da620468c7d044951c92a81cd46593bcecb63deb72d9a5ed7e9608c941bf0fc38e8c3eeb487dc6016472f2421e68139c6ca9dc31f8c52ca63b5cd5d3d4374d033336447abf422ee438e90d14ef2169b64150436a7afc9c3897ae28f42f60f20f7c31446ee3e5817a69262eb78f4119bece1fe2974136e8ca154249c720efcaaa6b5234cf870d2e39e265de2cfeeca2256693f44a57fba83ed9eedbca860bc97398aaf1ae674debaadafd6e131963da9e07b489b0fa2197add04a13fd8fc8bac5d651ae35cc2705e78716618fce15f62f5fb34f71e23815604376454da48b2b7ea9783d2ecc11948e9443be458ca04f78e0e517321b9d8c19b005b2b0769a0c2bdaaac8756228bfddb396c6e0cff0c9fe250472361ef7549f263b99861a821450f61f6b19e46606a2b995271b0c209d53113f367c944bbec3e59b13c9dd5c19b593d6d3e645187d81d813d85ba633de5ede98318338c69f661b623a36e9848d2c854d40fc8aee82c71591ec0f30df78c6496d0a97539f6d7475505f273de9a610570756eeed9498ef8df60867263e756dab76ba4ab88184d7e8281acd3c3623d5cee92db06aa70f61904b7aa1c03b3a5482c4f73373121120b6470c1ecc95069e21856aa791b7d6f00074e61faed96bb58cfdcec515db4220e592a4026e66fed126b6f6d1acf2271ee6556f56f6b417e049b1b5ec28c14e8e1c8825648d813be42b9e542e22b6efddae1d72172c8009a428bbc4bf209274c62cca5337dc640fd07f3ade66c4434be7632b6a3870572487cff57ab6017b018fcc8a958a1d0b27ed25ff147a77ece5bb8794e3ea7d0368950101388f08cb65a2ebc963074a014974582815530a418564fc0dd9f875521af6e78a314bbb20baa959936fbddca5780163894d8224a8fd93777bea7ded8429e2f5db486c18378ef11a82779e9a9d7f196fa8b25a31e99011c7e520cc2b6dc905c251640e39c8dca16d967f10149a55eb6c32e79f44f8100bf1f184c4fa00b56b1a074714bdf7cbc6b759d6666a407a65df8698d8c1e6c67a09bf2a8eb0175580d741bc76a09791ad39b3c511ab69e2d1f6c4d6be67c6500486a79148f2cd698ce1c763d0b5d673e568237403675d85e1f10ab6bb720f9998a57b90691cb066a4973d6ca254cf970cfe62698eb2d7deda4ee45b44fa246760045a716803f6b10c1e049a14a34a8406e59258d4c3ef9e73e8b17db4f5271e3d895faa3b0ba88b1f14924580fa6a8176119b68501ecc595fd2405c7b843e64442d5ab089beaf38dec48341838838c0c2a2cd510200e3b54fce2c59ea529ed9567a0b00cdd9283af8f6f96f2ecab487906feb8bcbac3ec48f9d2130985d10ba38f00972edd4c87a1a5f689a0cb41a43d1afce63c03a896fee648c625733d0ef7461797227406e56cfd1487490e91e9df6ccde7736fffe47696ee939613aee12841ced812f0007cb1a934c73c315a7344c16d69b7cd5e10b1179fe7dec57afd70959852377f5040773e840a958c8c2ad73195fbfca6ff97856854e75ae4a7545d58b4cfebbea0e0f54fcb4a1137a58630af1e82459b543d9ae5fd74e8bcce0a6309e50d0ca530e142440188f72ccb7fa06ae610a36eabd004ba6458b5531dcb3ac0ee475234daafba9c1f1da1d8bd4c3cd69cb99894840cef4f2197f370334f08b0672a1bba65cd0c8b3d183ba56db55c568b7bd2f29e51759a21cd14a062836ce1b693c830dc041b448862bfe901e580c0e9f25ae18f1c5c32325c67256549d7d33ebbc9a57658c103130e10d3a5cf328a79e12c6241061184a6843c38fbecf18cca30d95f0d8c9cdc74162cb829ffb175df987039196d5b17d0ea2904277941f600805389dbf3f384769961a228acc3fc89bb75f962fb9f32b7cb5cc9ef42662b314169223868245a9027f57b659b7751b631513db215f2cb3cb3581aeae57d8426608b163fd1a9a2af7d052d5e9bdf0bcab019f4d7c6d9732a04ffa108c573de32c6619c58191effc2f0ca25627eaa7405cd76e3301746b10d4d3b01f53454eeb497f61b9b41c97073af59c4ae22353430c4da946d2dd3cb1d1a26aa110095410cd732e7ef86339e713d53d9d480cf11b87b8c1ee69b53b8e7404acdfc524fc2be41fb2090a6ace18d19c4d927a5ff9fd04a05659b6017d3c674bc6e60ae324078ebf74f139eca9c1a680b81ccd85ff9f10f387e598c8c15d2723e066aba580380125e9cd9a2265636bea3ffa5649e2f05b6c00e287ec42cfc5f24566889b6ff995ed912fc8a8e92211d566b8cf4f95dcf63f886d1ec560eb9aa2a9fa8d2b3a3715498d2017929fd5daa6626b86b1eb79c1763a1b7c8271934b27e9f15f123648072bea0fa3d5fff78064799238a99a0e0f6c8e320dd423bb2a3c2b55b83b3c017290ea5c433bd1d9120949629db5634ef7b9892cc88e3c79b0558a5b76e9d66fc0514905d5ba479847a1e17d5eeecedcbc995d12ba1c5fb00e56471f49fea2d3a59c16098196587214b088f46951be537c399802eb85cfc31a6b32765c0dd41d8aa4f680b1eb5391fdb7639cc59009584e796874f541ff168ab12adb61c6c357027edf86bee6de4b95316653e9ceee9d009703c42b7b8c52643131577eb243d99d2f7e69c80ad332944ef8a8377c50f1a6c99d8c4589072f3f5785c417ef2feb7fb5b28997616397953e9dc9fd831a17075ad65891dabc3f4ec3bf4a22117726b10b4309fd8f73aa71cdf07963a3c8155aab5e9fd1b017b8dd98eb7756097bba5da74e8625c28f2fe731c8ba5ea92acefe33fcf0fbdc09aa24157436ff1be3c09f80720d38f47a43892442e48cf5ab2c9846d2a45f39f413764ebb24ef68f751a58d131f6c5ab0650b234f02113fcbae60d3c46f30034f48499b62beb1356b240b783cae1f648d7ad4dd7eea049358b794b6eedb7c3bab10f5a41520b9c40b6ae42704ad92014e966b50ddc9ed08cc41d0e0c443d21f6ad24be274654e1931facbcb54c1a5f48a14da7d28a83ef4a4ed659cdd24faee20d66f02b473c702fa186894e9987fcceea02b9b7838e7913206c086fd3c20f9901785d3dda1b460de8f74dc4f543f1db46440146dfa2b35e35b3b1580dd7dc1e1f18337ba87d541a173e597a6c2ca9061e16e5e19eefd4304e48ea3e5629d8a2b094d50c8ab169e296cfdf23faec4f0c084ad618ce1d3edfff5b0f86a1de056960195bab9c99ef89d1aa076ac7522301c0112e45a40ab71b849ec27729ddcecdbf360e813a2d9da19686b778187de7238cc2abaccc22e68fd32f154bd272216f7d535c8bdf35888201b218cffbd5a3129d597bc991de1b77ab16634af76b24ef014f198f858cc17988d2201ade161eeb8241a0e7b90e94a56ccc8866cfbf9da5991221601e68f7a8379bb25a1d2f18f913dc30f727bc03ebe22d80147ce13af6a6ea088b2ceb7192b21eb62af01d09442cbe14776283a53a3312cbd54ea8923aee0d68f8fe302cc45608a283f7a6ddb9e49dbec5f10903953f73f501c0a4338fb65ec7c9c11aa2c8217b07a5668367b548ee953174c728d053e3d2611abe5bce13d0d3648047ed31ebe17e37014c5aedff8f05eaca2476e6091bbfec29a2e190fd5b5c04843cd11df40079764ab01ab764917e5ad066d8443659a29995461ad960ae02cadd7bd665b4eaff7a912427a1ecffd5e1fcd8bb3dfb2169e22baba2b056f6c0803459ab95c02dab7c5d506b224de3736955d716d6c56d064f2bb075ee84fc9a448b535a2e90b41ab144eeeeff60502d1c13d034a93eaf1b02cec74b21aaa9f901e8625a8b5003f41bc45b0f39b0cda8feb0cd4d8b158e57ddebe9c3241eaa91c8dc9554c24df8eabc4e38cd14b81dfb3cae14bba046ab5b0ca4425f2bf90cf1cb97aacbd9ef6d5312160ed668e6be9d3d2935338a46fbdb562b906a97ca657d6f4b793678f7d755e4713b0a11f5d094e1377d89e35fd1576cd227e6c2e1b4a47aa50655ea3f41746b44665e10fdf4acc75a5843d8c4e73af9e07a3d44350f7872e77347f7529ce67216e82c4e3fd9178822d26f052505e20394b6682a5ed488e331c87103cd9a301182b08d2a5dcb81014d8e2e1923826fbba79761da2dad664fbaaf86ce1fb028043e0bb2904dc94303fd09417b09d17f581e2f09ba9324ec1890cbd41fc693453bf48f4f2add8853365443ee65816e6cdc2f6e62042fb02e522b79e4ec0660e11ec255addb7786c3866d03f1106fbda62cd6ef42b2f4297a76383125cbce77db92d6ec270e00cba2fda5527ed80901cf36eb79815d7504b218c55d7cdf901ecc6139086638884a247cba794ed8329a9aa4f68a2be2ecd0f02ceedccf277e3b56f1655a47f29026c984979d7acd5dc287b1a77d076b389a2c699b76d9f0773997998b2836f19df4286b89be331699882d7bdc6032d7879f6313d7cf7b0b749a84da4de30507cf47394f3cee564db676964e34a8360c000b6c005d31bd70b5aac466cab545ed69b223fce7b369883ba108b482f824069e1cec4d4481cfc25cb358962b17abef965f397db813495c306e53f63976820de9e0135d0c4908874fc57fb633135f98a2d8a64028240897baf8c24bae32bf687952c7674b9eb3e785aab0bbaafa0b971f7b55dfe72516521c0ec9425178b69c6ff1ea39b89d4d97ae3611915945b75b30713f1cd6c642c149949d435ef4c5a39de00a3511ef5bc2057781c6bd1ac4e3f5748dcdff1ce392308634c1b543b75623c9d71ee7aa5dde64a9bb228f4290385eb701ac7fc607e95e1411ccdabed9cfafbf45ce9267e60434ab7388896104ffb2762321191be9dce0d27b66aaa211e368a9a6bbf4d15081f394f1023451210d13eda6efa030d38949af0ea49983bdb5f47b4ca5085c24dd9aa83df0ebebe799f612b07b94258431f0edf7749698b0996caf38876f2b880afbc971feb98ceb2d4e5e573e80c5b8732ce33d3a9f412cd5c1fb7419f6f4c0e630bec7d2f0497b725ffa0f9c8cf0ccf5d3edb848bed6a7c1534d6a6c4635a45b5b7a420f94d40748d945433c5030327d78b32407f5b2a77264b360aa44c09f0f29db0f9d6ebffe622c8d64651bb6368f1a446f2514368c5a3d64c12e6f365cab03f1fb6b662e803cc91a27ecccaf43f6ed98bb99a7801b1e54e41b490229698c14bf557fb7b702f0db2ce3b3d5642810f9db7c372c80910d79e25dd9df18da65a50bb4c23c3474f414d503b50ce18c506fa95b33ce1a8e670043817e21afec18c699437e825feb4295bd1cacde2df506ead3c3f513c0652d2c702fcc590bf204393e2f615016cda800594dcdaf0b6ff7d1fcce7122323d155cf0be14232001ce9cc230b47ff019af4a2bbe7377e6dc7105f81c583acfc13b5125898d633af9cf8f01f52540f9fd0deb6b1ab3f3e67a52ff8869b0fa1e92493f70527dc9f22cdb3fef1d7bad6675f619da9c20fe633726c9eea948ecac2a733ada89ea0dec8f4a5178d285050c1e7fc207f51903601d1ce60bb3930c41a32806f182c040140454d8bd3b71a7041ee3154770c96501a9d0d562e718626d2c8b0773385c720288dab2248346affacc74e437066713292efd89bdd95d346a228e3ed46706da3270306902119ea2776082c5b1bfa72b4644b5971ab37fc17ad83761f035ec6e9382e2ac046ae5b5a0c50b8f06e95c6a31668e12d62a6ccd265e55de8f8754858c759301bc3b2b4d880dd1936fa44f1a1d6e94daf70160e3d27f0202d3188c3ce2d45a1a2d9d4b7164d8111a2008ea4ec0ef39dccc23d3f3b90599bdb578bfa24bb10ff80b79056349ffdfe2627832388ee2ab0cc76b16baba51faeb733b6ab393e7e02d0d2cdada82dffb93438af924efa06822fc64ce7b67c77795f7f34a2ae202f71b628aeb34e5305eafc31c9c3024437bd9bf5c54d95da40b6b9fe973ea32a95a06a31e64b324d2e783a78e040ed1412793de6ab1ef4cde2a2c5455d5d12e66e17339e4715a045c766e1a1876a545b01309abd1b33df42904964112c3d7a28540ce2d13457c238502189af7277edf92c4a50d308d91ca34c756d166fdb36c8119a93386e7f1c9c0250d306acd559b6c507583582003bc32cfe93cbef0d4d5169e6450f63f0446e9b1236f72bc404bc6ee728e73bab690b6a25fe4ca174d0d1d0c2e62e950594d61a16f7949aab19e5f17f7bf7f4eb009fc7fbe7752a970dc0a4e7c53017c0879bbbc58da0c969591557da111f4103b5ca1ce3b61f71f30a137ef0acb3595662dc282a06e73e91d419a2fdeb6f7c0233e773dacbcfe2ab0b86a29faab4be4b3913909d0bd13dc02c5a4d19439ce1d64406dd8875e6d0bc3edd8fc83821df767ef3113ff2fcb4460f3be3db8cc9d83a5475d8d8b80984c3005b02265c8c0cc5b3d9a951a6f9f4f1eeb68f3b2897bf7614d04c7ea1266de0aca23c060b392c62efa01b3a59c5fcfb21f32ede48bfd6a0ec5f6e4dde1ac4ec168a8b3643dde4443d1e590caeeebe1e48fde8e846e78c9e1b763f58d83073d4ad5154d4236f5255ae7b91e2323993491e35a3f3991f9ad6717995275e2ada3346833f9f1617ced710df2b23a3b2224c8fff415a1c554990be1cf2d5db297edeeed051b3361605c1f0c6cc10d7ea79771c3f623ef9d3694f1fd6678e3c5da08a66a9725fc75e0a700065a9cc67f66dd717d2ad43bb58bb0aefc5655e3767354b9f09260cabedd9a8c8ec7f097fcbaf2ce0899979ce9908d4af3b97f69284c81330ae358fc732597848ebb37ecd1f36bed628f764eb3f0f7ec27a3d91d808113820814262f527ac9b9214193913c2aa33281129b26fd96b43c6f1491be5390f242520834c800f48c72319c123256ce064cfefc3ed72d13975dfd1c64c1274ca3b872f0c48c0ce4ae376134d45ac4f0d8770409283e53fd9518eead20a982345aba54c0f699483566b47e07d8c8f2ae8446ab4b4d5be60385b8fd25bcd53df6dc1d697e9757de4db09ef50f21853bb66363f45570565e3178fda7eb47a534dcf10cc78b4bf15e91d4536be853a867fc97a1355f3c494800d63f96e156f2e88e8ba34bb5ed5485f997f67b2cd6f974552c43c4d737978b87e68ed33b3daea31d94740d294cf24118238b62eac6e574d3b6df0b565cac4f0197da8a01eb4aeefbfdd63f6253c076ccf33a832774323aba08110b83b77828436ff1beb5d00b1cc983a53f3497f24c81a9465fa1de64549da225e51d7308140b25de92e0f452d383d36144aca11b522c12d21797d5f45aa35b8a7425bdea0dd9ff5ea6e71d3f2b68d6283798da5415952e255576bdcc742561daaf828097029b3f46653d067fd24792ce86ed3cfeaaea35578cbe6c3645850600fd95be64a9ef482c4c281f60a25b73defa5be7964e15d27fb8fbb8ae8c5d4fde45d74b45948c72c24d398b0d55e5a9d8b05dedc4a8d974d1d25c61dda4a54d3961f260d80060be39258fb74797084fa221eba2bbf5e8aecf164a5f9fe56ccc6cd99cee65b4d3a76bc50f13c59479822086e208dba364808975968bdbe047b0a8f3713c2bd5c26dc8e077423a9bde7b07f1d06c8e02d694d7b7a2628121a6b7fb5c969b01b4e091f2338dd7d018e6574597e87acb2002bfcd8271597d16a3ab3e0ce08d7b9e9c5c7ace2f18a1f5e507f8d5a9b889cc5391e6792cd674374f49cfda7b3a6a32604fe07ec5d512ceb5eaebe3201d5e1f1410ee9f90da7262e3357290a566e6ee2b457aed36bb1959cefec2c9ad19a5af437f75142aa559c5da77e55e75a7fe6d6c16a397918c1c6ab81c993364696192a72891223b2edee92c6b42b935eff7824108eb33c6c152ba314a9498190a48278185321b29ddede566118432e83496a179b4967f5deb30461c0565d57e07418aed2e5af650fb60db755cbafd05e989171e379edd05d96a91119dc6c434eaa22df881482c94aacca414c137fe165584e537c3ac8edb4d06840781f4606f22072b62be9a793efb6891e3965c3e8d3de2c34a84fd95226e9db402e09275ccbd39ae38e47c092c41fa68455af377560ad60e9465ac658933a945263240ba855cd427854d4348c9dc84f0013c34d4c7bbe94f663a0c834609bfc792212c32c50172ea1ade677a0f01de449de4a328b897573c23625b255545ccb79fdeb80c0fd0188c32a188261e0a0e25ca5619acd3119ac45f42d6dc739a96cbb1445b13df312db64d890698c223aae58f5050fd928094d7a9024868526b410982ea94c2bd3bae929163fbabdfa814133505bfd056a720db8564a78fc1d5b32ae37991c87bc9101252126ac9868a76838de59a0eea1d7bfcc1ed0a471243c4fc2f7cc19df5e3089dc6c53049e277e662447da43aadd2ad1d7c84d83c967225754470c5e3a28ea9fe55960ce5f2b3023744fd5e2f0d299dc912362210a5af06ed5747939888addd0b1a8c59ef619cd5cb2b94d99f62d712e931fb1b0aa69e888c5f579ca4483fbcdcf1c79400a3f5db67075c3f63423bd5a52c5dd852a45dc657193eab567962ece9862caac9cf4cb7fcfbb3e3de1079220f4324b6c77e42521a328a694ef45a829a63546bdea56a819a4b697d189490e29b7599669463e945f614c5b6fc1feb16c23baa838aa5ef6c69dd127bfe236e04dbac4b839c8747c24ffc7fd14a8de0dc18b5ae483dba14f5bbe6400334518298fa76dd5ca9b7b29a33d1c1a6d5d9cd3a09965091d264379351f08e7af89ab5d4f2b2902239db3a2501a849e9037ccfbff370e6dd18648e30a1dad0d4e76b18e7ae4d6c73df2d8286ae5bf3fa2f2b381a219bc4bb898bbb77289e1096bbc948b02e7b7ca5ee9361a16cafff6f8892a64b4ca3c778c977e34474db51dc8a6796199cbf82985940ee6fd5474132a5715bdf9bb06e5228d8de80c0f083a76532d3be77aec09c0d867db0156113ea32d78482d0cb54ed7bac1f8a01a9d957b33c944d902ed23b38e71544d9972168fc279a0cf5fc01f20ae0e5971ce125146966bcc17fe7f7dcf7aa9f2c3aeb3c38359e5cd39d999c07b83dcfcda7b8cfbeb5172e614e4564fcf53e6886ed6b4b27a51083795e9f8389eca91f38a02c0867dcb1f2e833567fae5176f871d5b90e65353253a5d528c4b084384e90a963f34e29e7a693e2c69d1712c892004cc17bf104e833d77d9338e38e9e03c1ddeb8bba568e816228d4278b3525c38b3847ba2d70af8978d98e453fb414b65d0fe989975a06672957fff80c2e1ec7925f4795c7b37fc0edb9ebfb0412eb42f7de7ac34967b638aa64fadcf1c05dc4a51c6705cded9cd04d8663cc434f7c601818eaa8e1e8cabf76642eaed55459bfea30b9918928348b6dfa7b11b3ea043987d1722aad67c87a5d65ee376147c6b9b94e32b2eee80831ae1053abce740a5c88cdda493815c36b1d1fe123224c6c78760c5ead44a940760998472a743baef7cfc2d651c8c45ea64235f4245ea518278747c7bb44a5b66706182be0c0ff09e4177189b9c35af813703c978b70ac9446bfb5356e2cb811a30b144b52d5b0cde571958a5012c93b01ca13925904a47abaf9a1d5529defed6b7ea76766a2c67cc65d7ce8814d6f61043727983f224845d7f63c0a9c08a02657f2e7838918fe99405b1938d18bad1468fe63243c73a3dbe1aa46817a4cb8ae6f78d02f3ae515acc7dc5ec3f507e27a9ad3a6d2dd63cd90dc674ee3bbc075d56161852a663ada42a87756e9d3f6c7c99e5e84fba062fc3e0850281867790a8d2bf0c7524a6043bf34b491eeec58c51ea78cd059572c4105e693cfa17a838fb5924b60e46f2cbda071102454e314527dd2e8e9c672cd9e162b985fc63cce9f4f2321b173f0bff54c9b6b587ac0f8bcee04e8a58ce319c380c9db1cb80d42cfcbf2e2748f947682e3de4982754cf27d6edb65e337f26e6c665443d997639ca3c195309441fef3a74b6b9286727bc59cb2b5bfc1ff936c5f1a7cf7159d2326cd5ef18b12e024b0ec2acc4b1bf2b7001a704a85615424bcbe0a363917785d3df5311475e43382fda1846184154aa0782c51b10edb0d36e14b09a6a47e6637673fa9496e085faca4415601c4b7a705c745daa2d3621394c628e9847c1da98491212ea35321863a004def1abed21e65e659db13a36197299878f5b7d9c093b0cef3cef9534713f6f112fe7798f440f9b94fca5c38864b32aa2d8cdd232c48931c66e6c21d8a32cf8b89a95d1733912b193f7ba9f16f5a54a9ebc3973dbbccc332f04ae3526deef05a8719f3319e58228df2578599c55c8c4e9378dd970d4f0acb6f5265fe31f301a40dcbf248866b9e9245b0d8a0ffe73706c53e06a09604933c79be9878bb004f2b38153c24f5a43e6e9084bcfca26d0079535f195ec95d8fc408be5e1d40aff7466fcfd1825582db63d1d3fc854c3000b15e289a95eb5cef40dfb174091c16a9aec69637e816b9f49c2077dc510f54af7eb0cb344ef0a219f5adb4f660188b33f2a431645742d15961c15a709d9b1456e602e8e45b1adf913ad14217a54187d95eafa308427916709790af132487d4b4529878cbf2db392a810a14faf7e10abfd107f992bc4fcb7cdd6a7ba00738527fd4bd6b3b941f365bfadf9164876409b4a0e75bd77a9fc378dc05b9643dedaef6017daffd524d32705a9928897ea91eb4cf72fb77c109a004f8617955b5fbdda1a9c335136a529e500b4e06e97c781a850350292ca22803f5cd054a90a90eb4e72dad35b02bf95528cedaffba629358442445982e1962f909794fa10c528db5e9f4faa20453693a96d253a67c53148031b7dd76561d96e8869a46e718054aa820d0222bc433d67efbde84e57272386f72b1c92243e016daeafa75c53982a5350aabc8d21c5bf07cee70f0c28a06e7ba3f9d0f6930ddf3795e67eec4d7e36ad3275991e10dabe6b22f0a6143d5abce66d345fa324162714cc2e0c5e66bf636c4dc663b4fc9e70975c056baebfb12c533d66544544d0cfc8f9cf231acb8d9e3e4e13acd5d4a6bdf1f57cf60d72245645b4d7b90de1650989661b0ef9341ea8b00b047c7f22e6aeedeb9017cadeaf9b0b514d1edc6c0cdeac85a1999e89460d7fa628c4e6785420bde46afebace47ff9b58a358ab2847f296c16dfe99ae279cc3d300bd7b8800fd352cf4d958a12e68611ef1b44e6c9e62ddc3dd563a88dbd2c1401ec8071c6f08ae7b035e24fe9280be2d8bf01a7db1bda47e06cdfdaf787247c4b409418cba5ae79fcf397e66f7d251615e640e067d675433166cb82fcb3c8f7019e3596d26dd8567511501d1dfaa409b9dc5f9826c3f916e56b57c6c7071d680f4598f2d22783d43dfa1f06129934d9cd83e23a26cfb57b98594f85f439bd3336f9293528c1bfbe47382b567529cdf4d6f2d79730448bad8b2128cc057025f1dd55f2a0532dd44d343546d3e4379462241d7ca75ac89f104c4f6b60936bf464ae60b0790da8786052bc213709a1c80a58cf48777a51ad1dd521f56fbddb94c81ef15314209f797b5e11f6894d8d280f7cac6e6ad51b79c914f79bcbbd1cf29e6f97785b02d2262085ff32b560370e29c9ac46206842c399d84f5913ef0b50ee0410f8a76646af0725d6ded18da393df660204b2acc0dde4e638ddcfe3c5a634cb8c9007957fced002d067d4ab588a769123b1d86f5438be60585954cd2c86ab4d7858d489d77ededecee8b436fcfc70bd737657e6308463a09696064ca1bca9c7246a58c2cc60e5e10f49a580132eca2ef5a32ae74058771a0cfa923fc5a12cb6e3c69bf8326b6d7805a5ecbe653e818cfeb1aa5c8aeb43bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
