<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"485b3948911b0a4fc5293952f9834628d8e2a654948df0007b8c8a4b7ad658e2ff75144ec5ab907050d1eeba31d843a0f0edf8619f68d6aad61a52503ca3c59c7cb3a4bd4e0000c800d15274aa9dc30194e9b979bdba16b2d1906ab42e333f43a030d0dde130eca633a3b7e05e70a240f62f09d495e3a3251dcf2894bb5d3b8821c8c8b330b64715a2ab565228ad8824e86097698733df70f4c27b7ec13fcb4ede1ca1ea2557411a7dbbcaa39ad7bc8b48c0ec6d6e420e87b4e6e3a7638a23eb8fde5b92a33d852bf8ba54df125dcee785954abcd7a6bfdd781cb8154987288156653cc6ca38f802577198115aeb61ee8ad212a6a9fadf1f9e22ed7b1c8d91a5245a5b0a28694f725419880a1326653a8ffeeddca6cdb4a4e46b04a2f5d61a2fd4bd96811562e3364fae8d074227d7f71bd00a76faa350e81c7be80d5ae0355f05e03ad1212e6e63ba17936671efc38b73b51603c11d153b5d53071077e7c4cefd7221379b7428b1ec14d3b5ff874e1fa1a7d192ad58e40b9759cec764a521b1a48164d2240ce5432608181ea31762e6cf0f98007da9bc6630130502dd20dd1667c5deafc9c573e38cb72b3098e3be5c50a1ad238c2ca83c72c2a33999e2d4a409ccc59c19119f34cb2111d7c8137d392dfbdfb5997743aea8f6abd70ae2971dd302dd27f03f0892a70fe228af3d6fd4406ebd02222e157d2d13cbf9f2505905cf3ff83174593d9ebcc235b2701020c4ec0333d0c8585802865a5f6c4686d21e97af53084250f28540ee361c7a3009b2b98b519e4747c935adfc66b93e7c6fef9a065e2c6205540c3678602c7989ab84a86be25db9c4b967f4755d9cc8fd214972673365c98b87b66604e2dcf4c5a8c68f90bd04c47f7f6b212f44dc0e2ced2fff6cdf6e1f09dfa5207ac1e98cdf2916ab69ec33b7d75b32e45eb616ad5a9d8fb86c1b3f1ebad0a31a55a9dbe2af38e612253c98786b9931ac9c0a6fe0aae7f02dd5136bb7da0c58815ee3a1b59e86733764526cb9d793e70ff0e5d9b73ef6ba392987813809292de9833339f7b20cb6568bea15a4a16cfd57213ff430f4b169ee2c9669a58f15f693c3f4ffddd2e9079c3b4278a91f85ddd583174ba54440700f7d77fd8fa35caa6125ee918388d488f932720c3432311679b6f25a4e36f1a744bb2f4067f3a3866a5f1d9631dd6510c3d3444237ed481cbbbf2127b07be3fccd50774202a0127224b17e463ef1433fb134dbc6747756b216223f551d953a7359e4f0124715ba23081f6280326194c163423d0e52f5d3074279632978212573ee5c694dde9e1a2f4300f3c28dac15cf8585016419c8380d5fc2f03651ac27cfa587fdc9d46b9258c9ee05d583ca6810706f94b0f080a97acd54f5725b7ac710769a0314d12dfbaa201214338363b89a204323ed01a8ca3a32778a2c944e8786b47f9e2afaa0169aa1114330718571ba325835c83488b6492bff2b745fa747d371d23d3db6eaa51d68f616d2230f9d1161339e707f993f9b36bf4ba8cb7e5e206eb8b6fc10fc8576fc7c1b30297e4945f48a468c10eaa1d8de4922aa4de405339d109b8bb82cb7c3542d659ff50046f050c88f2c65b4ea0626f1626e2e4c58161a31406f84362fd6aa071724b86e11d4f46acfb89366123558b7d64fe04e97651f8f6f76a0c1f41481420d4ac0940d62550bed14eeed46b919b0e87e6222e60d7aad705906ef716d01a4cb5f61ecaa70df48c7d08c592ebf346635556c9c1d86ed996d933fc8dc4e490eef882c6c70f32c4130d8d2caf9f5acb35bf7f3edd9d76fe94146b8b4ed56556959591474e1537b3bc3eaa92b74ad62b76c5054f1c3111260e67ddfc4645f270681c0ba3764079c6af1574c112f52273871e11a5b3906387315f7a23ffc20a314655246022571e54c70516f4effab4236fe21adf5111285cc579c510615916f838298e5f4d77af713625a02fb9e8a03d60ece475e9ef5ac949d54b471b0cf6cd52e6281e90eb7a0e8072f0530cb19f22b7757f9a225dbd264d2588b131c4ef7dee153a8df2ca14eead580d8b6af91ed403ed8daa85ff1ce16665753fbd13b216448dd45758e1b30a20b51de863c9eb65106ae2effb8aacfe2015854bf5de7d2573c7e287c1a969c2a641ed8405b9c3bb79ca11c98fca2548dc9859f47a13dec973db01ea5f9c304cc0ffbc4f95467e4d7ca8510bcfe80cdbc037c101ebe6417862a975186f9ebf575c1f20421895f16e0540bae38c279c4107b7f72c5954d31528074df234027141a4c54c82a4b4dab80a62b6f955125d587c388f155a51103e43d510fd8b1790117b14ea641f23ff887b11bd6cfb092b027c8453fc0151c9e1d1c6b16695efc167f31f1cc10ca0859ed4a03dd55cb23938e5d870716a960c4638f2d97616790b3d6b89d99be71178999e861822179d1c6e1becdca1703104da26bb133cd9ed431f16e9e434ec7b338646b06042772e4ce4f57f5633c6cb0f8b79d414658465f6e5f17a84642384967cbc9528ff40f79ae87ad02d5198a615880ed75424c5fd176c5e86bec29dd8beedcf1dd4382268c1b32583205b8d3f8d4a803db36d255b1c7cb8138bcb88c36dc188d0c4d16f4728e3e7fbb83a7e6a2657c9890e0159e908eafe0684ad095a9552b88bcd4b2b7df78f423c38b6547e3aa5e63fa595ca12fdee2de6fcc944c0cd34d345463471beb9714ce4f0f4579a8229ddd74b5d1f87f9b0871c153a1b50fc0cd59f09202af23ebafbeddaf44e827ef5c8e101a546241103361b3dce0489c53a834d43f071447003b28e88d1b0c3ee91cca9b761c62ca59bc005444e28490404407e6850cb2694c54ed889e3187d63b03d1325a2c4de4971c6969596b5d7aaa841fe75da0f7c09308c0a5c4748bda1b248859de236fb22c37ac59117bf4d813704452391289916685b79c2592c00f2d6e6dc009083dfba032f89e729349d1541ca9b7d76d9620a63e1fb6d1aad7d58a613ccf4f59779a930a09977cad76ed954f31d41f4a173b454939e4180ad244375b2a7aa180df0347ac3c5ab72ab7d8eb5955cbb2e1455080c57ec0ac50ce058de4ceb17044496b6a00d2c5762e5e6367d10ab8dcafefb638e6aee780a9a72687ea6eb6b385fd538ea1a0f3a38a020fec6058a5856151e93601314d4845c22f8581265b3802dc7906a63754e87ecbd84869349efae59500dd1649a9e220ecec2c1b8538d2e6ddc3e387b5d8f7b4fa04e017f436ce2d0e000477fd2f5f1c79dcad64ce7fe454564d60c9186386496d7b2c03c78d1d6258ccb4e3dccb1f9cebb23d33af5766235083010613850a71fff73e81f049ef04a0d5a1439cda893667e1e99308e190e4a5fa0a27788403699ea84e42a048b04d6e7a6309b8efab5469d2b0120b8def2d06d9016a917f382710d854db96a027f08409b68a9b9e462e86d50a8316eb2b0e37f2f71e40d066a666fe5b4412820b5cbbca7f0836325e91ba9212e47eb261fed62baa9e1d237c9e06d9641f70b81f54a7a339a3ffc30d59faa6ede04ba7247fe72bf5ecc418bd9b8aeda6b4e34bac09cccb238251ce5eb10bf90f17ad1f0117463180bef405c4d0f73199a25271475c79da147074aa081e9a206c4343eeb64043f709e52aea618f4d8352ad4eb4ab8a37e0f7334a4d01402b9c53198dd5f99b32e2db688da7fffc2d300fdfc8062c694031cbeb9f813c8348662eeccb2fa3d88e0330d99efd0f5cfaf224626440b5b5be85944904ba4c15dbd22c73cb151007a55f8ed3708e53133612444f67da18fd2573f543f6021fdac75658a3a038773577ae42feb0d00499af6a1768d7559a4ed538d2a6a1b1113490c45b1ded9f6adf6c857e45942bbfc4aebaa7c37073b68bc7c41ceb5c25be4cc6ed722f91fb4d759c0f9ce1b13308ec34fed0e5a3f6972c5e858794c47082821c4c936f827ba4fdf2f667b3bb661d27b51a6d96299f5c25528d6966c618cc9086c57134b0600a1176fd3dada06778264422d716cf39398a9d232e1c18a4f7ba3a26c5b88b9544cb806a242c88aa9abc2f1fe4a866321789aac4597c9f44e58ba07906288a313ba2252ce8c129486855060a2e1fde37258ee7b40b3699456ccd25f35ee682bf5b99cae7bdde8dae33ea9a5528fc14ceb04bad980aeb1d15eca7a3262ca5aa314af3f9522ad45df911a04f05c9a513a4061ea7ca226c6902a75020453264d36515d70581b7b1f34b09b7fd0cee926878980d0582131da722130056650af480060c5c4644df99cdf9518dc65f977d569e0ff902b5b2520b7b3d1caecf3594b5324fd7e1b6a9f2a2bcf2034e4d638996bffce2cb96bf559f614f90c512718525e74b39589b3bb156c0be0e15f9ab71dea3a0890a12462f886449c7e4df592127d4054c65c81ca6a8a3aab47325585331a5fa42953fb292c518b028193d735beb5c69411ee34816d83376dcbcff95060535c1351ef631e01b99731f6c93c9927b0dc740ba974cec076ac421e5d5f2d1fa56dda1509c0774992b3047871de7f1136f4f21d288d5e6ec01068b5c7c43aeaa5b80c1e9e8fdc8cddce34b53547d692c05cfa2990cf86ba8163054ef559e557f3f15e32749470592204b71aa04b1bc90a380faf46d84995506a779e8fe7f53f61d6fdcbbd8715d7a674890c51002205ced06d31f2753a3b4bf95a8a29601d7b9be6328d98cd5f0515432dd0e2904aa8957595256046790159bdf572573221a8b7f6a5a91ea013356da8958144dedc59aca3257bed99fb3140c926283b70a5a3b4208292dabc50d53073ccbd5ee23a7e22f5ad30dc294899698194f020d8fea35ac263b233fd36ddea88a6056bfbd840242e59d7f8017ca366bc57616822c0c20b982b3762f68385c51f58de3ba623d9e808f92bbe2cf69b0d0d474f4b75103a1a414d12a80084c85602a032d63501d57a8fce0b979a395dadf785d4648abd187985e9c922730ed2178d9c401f6d0c99f5308d016b6179e6416ca5df72851d4f699913d57eb813d8279a5b329cc28daef28a5d9198470a0e3d98f7c288d4b515714d3b7b0253e53cf42c78783f370825de296f7b5508e3fac5094a105cc31f48769dd954c185e962e6d49b15e0f362e5f217bf1493e4d46316262ff0eb2723a474e478af7795bee982ee1a61247fec010f4f98f61abed9835de26c05cc46efcc9d265f8041adba9d66a76b1b4d47d3cd2f0f43b13dfaa7ebb7cfcd98f79bd7ab69caed1ab20364e2ecf8aa0d9378672bfe23c43dae890c861b1472fd9ef2648857ff411f198c2129c1f86665d0c4acf855f1de6b913d1da879a05cfb977d8a57dec5433a40373341c7eecc4283947048e2929cf342c8b5c43a7794eaaa0bc6233f84928a9ae621451c0e745380e78f6e4ed42324710f92d60c5d3ab7f455e209292137eeb39f2c815b8d7e7b48084283aefd5c22c48fb2b77269b601ab7c0cc78afff71912d46316b170495f56d05a84131862313457816cbad37f0a5b2de350904950a766e11a9612b483ef85741e3ad510a14699539f46573142f8e09976b74354f5a1952fa910a93fa912e6b2d17980438f0149dae3325cc320200a51c558dd232bc3ab33ac303cfe98e7725f68f1078e69918fb53cad9e649cf4802f33a6f942a3154174f55a8653cb99ff9a36b5c7af8186539608a278b72b64c1a0463bc1cfb2f0fb2fd7f3329ce7a2193a5508a8a1e19640e315162e98c14011d4d749b822a5af3b0bcf9fe4bd637411c9c85f48bf6ebf6d6b93c2efd152d50b571420a933b13792b0181df5d3e9516c3d23188501dcaafe2fceb470faab43026018477e035eded562282dd53d849d6289ef4cfb23d52ad734fddf3169f3ca9f99964634cddefe2b337472d8e04ad0988e3d207573a5b130d2b9e338e2f1b2583c4f742def4ddf01a83c971a6d4413b6927c60e5394e63910b4f2e423585b6ffca3840610749276b35e80db4721af63341b478b18da7b26d18193c22bd5a0509cc3df2a014fa3c50c2a949016b5ef265fd328f4b9d8e2ffeffe146711cf8750b6e83332c26876df044e7d5a050c262345f3a5f38d50d476f1053ec1c1a5e4a9b18093ba03398672c17bce4605fda450c340d290f9f7b433367558cad53852b80812ae04eadcb06fdda5e8f4fff98d38b234a2313789d94e3a16c4eaab685254d90ee7001c8be405c82d9da065e4798b7e9984b7e999a26aded98f974ecf7babe72585007c6316f908b4fc24121763036570356e0364b72a40096702e32c58d2702cbebe78fe4e58efc05030f9cd3b497be8c06848cccffed2dc36e70c1edfefb4041b988e79d2dae4fff5999a7a1da1a2fc728717e6aca9ab9a49096dcdc4f5045d29433a3db47d126804060d2b0751e0f1039fe6020a953518a33c2cb5c99b3081d6d5cc39a1aad3c81a90985bd2e6868611ce194ff6cbf0bc8f7d6e1fd4f378d1bd45dad54ad8844635b4c71e99aa0231eba74e67140d05a4030c418353509df2aa38dade42adf3fb85052f2ec127278b3f7bbc31c98570bc95e2cf33e5b5f78844b8968c4c7fe212a46b3d23cd9e0589e0e984e7a8ff68686af713b8152038d962217e0ed697e85d7241026c6f2d1fcefa98e20928f23012876a3490dd9735deac5e288b7e4e19dac0f16a1257d5b88bceddf02b6641fb3391d7f22c97bd32cdbc669e2f5168d5b6ed4d132794b1f38c9d3d368dc2c121e6c48ca84dc0faa7b14e2507d25f07b7a9248a1920ef3fd7c615d8686e0afb39ab7fd24b501e455f687d8f1d144df2df62e2001f18408470d62902776372eb78708ca1d06c855750e26edac127e1cae5e3c5339811c05351157b24a794285c02caecfa4f5066db9c413a19b05f857c7f19d56ca8141493fad2378bd98e708168c2aae44b614f76679819e6fa32058b0d19ecfede8ef719be1551d575dafe6fc6645590db078890cc6098aafcb2e8bd40b0b71d34dba2beebbd549c4c0abd4e1080df8efe343a95044bf6588a01064dade905ce246e722ad9ba222a8ef39c47cf178e93cf50288674d673320cfd119475aaedc7c81eb1ab8ad6e4414f13db040bda4424214c47f07d62ea4237026c324b54ac4744726167ff43d5bff5323694f3d9cfc5970cc9bde938ab43414c2a094c8087224eca390c97dc03127bc87a2bd3383f48f41d12cec456cae81673ae2a601b7e72aa407840d523e3c5af6f4e433dee166a4916c51c916ea78229694f65625cc2b2b542ac4326d47f5d45ecfe883d58548dfa877c9b1af853d119704128a46462dc0c62847fdf5f35f416890ab8f7b15c9a74a2dca2e1ee06e30fd1d3170c2d533dc47d8008bcb8262d7c79a42ca141ed7733a2035614e3995b07d573db1660818c149d5b4b3d06c16477a933fde65a7df27c574fd68b96051e9abe51b1d089353f378c067c79a10a9d0ce9686bc413a54ef1f857738f468f8a97ce47f507cb4910b07723181d36cf7c533a178fd187d70c158994ccf5124e1e49c786e28d164842ef5ab18a5ff8d60b7f48097bddf4f5a904b0f42a00468b9d8016a9cc29c860e1aaaed4f34cbf313313ccf726785959d78f8c4ee9456c88f455531d13fc595223762b7c00f0d47279fa98cfbeb192d9272b4ae810a8ebb8b6d348200ffb18bc633b1a3f2429cfe27fb5a355bbd742e513175b7f60234dad55ab2027152850612c4a6fca0a434e47216ebf0c2cb91772b46a90df35fec0302fd5428c01957ad0be56c2e1d13ecc7cd3b80e99ea73a02782373d521c629e0b41ec2a05084f05bd788baba40fd9a169505bb68a29c4e48559b98e411b413297a9994f873f12f8b0cad46352d85af52f1181864118a450cdadb0476f80c287d0564d9a7c60b5f9a8c3bd8fa08e5bbaf33a33ac316e762b4c20edf590e2f83dd200227bfbbf3bbf389d4f28fe5030278db5fc3e948fcd88a302bd5ae54178db7f583a61f1c0204e869013a7d32bf6f3d843a9b56ac5da09d175783092f95e3d14334e84bcef75af7bd949a6bfdb84c7356117db246a5b67923ddee08129b145794f08905cfc66afb3e43f027dbc0a956c5b90b4e1fa6fb4015e223d33167771e7856debb50256ce9f48ef4825f7ec601f1fe1279b266c298deb7825ee51ae2d58e0547e4e2c92c5421701db16a153c7dd26db9ce3fa6e090c60f602d073a12ee68a0dea5ff89819d5ae51603269951f2356d9accadf4fb3b3eae569dae9af59a1d0ea386c2bbc5b5ca189066990ea3c92f6d00b6faf6d9a00b24f193b3f7f3a0170bdcd92cc909babfe2f2b9746de268ddeddc3fb97e581ae670f5e50f6f2a3485d62822656452110127eec07107a157417f8175fb41a7c0c52ace5141efb843c5cd78c6a3391a57e1c42af7ecca56e445d4df5fce1088300b26826dbd6756fc043878d5e6566d2647a96be3f25416a1b73cafff7725a1bf93ee41ac0c8459bcea66c41e49b34c46f66ecf90364122e4c65543510dded1f87a341971e91bea4957055e87fb43f0553e4808e1bdcc5ba03148b5743c1b84bcf5afe72a7af6cd604fa52409b8cc4061e1d92177d11d2fe7e7c22c26951d105e0fca2c0e6cc0008a157a639c3fb6d2c8d09e873bf424cbb58cbe76e21830824e7850739c04691e7a5185b8183fcb0eab786cf5c0928355e04f03efd30528a4056a4e8033cbd1caa2fc9953cbb29941bde6719e65f30eab4f57bdc44655582fcb4ebf460c34b178b87182c50c9b19062cb5e7e7ae020f90c7a5ff5b4da65b0722549ed980803c104412e37e13ff075fa0e66237f8ad241f490378d949b8244adf1d8567233a87af680dfe53446d3e05a2195ae57a90ba05d41c3ee5cf4be89e9d153213d544061a8255ecfcb4d49859f2b4cb67f982749c486f96d070fc578bd62cf84d299eab7c79528352316dd1a04f0336a935c33b6e97a59156b4869314e1eed1d993909026139a0e30df6271c80316babf41cedf46169ceaabda8d3b425b0fdda42fd7a577d49c3b1e1f0a1cf5cdca0f7d18665bae43b6e6f3e6b69575bdb154e8028979a37e912b04bc38a42245801b0828d16a5d17384a71eb04df793f5fa673fd406ed8cee0c63949ce35965b07eba7554dcb3d9995b682563830efdd08b99662cbe76e8a8399cdf5e086c4147e0854979afe4c5c7cf9ce2f09e26ddfb6102327322cab40c1ccff754dd63b0da0ed56e6d8ad26e307c5d9167076ced40eacbe23191b3857d1b80fec841b6110fa71889777889b84da9d67bb02f14d93c9f01c447c5107b2e9b9c301281f4c7adbf1b81c9fa2ec0ab999e06b62aa51e3805dd5b279d332e51269fbe59ff956169d958e56a8bbd9a4283d7f6bb171d3175ef03f43fee5789750ef2da56f36d26d97aa0b395e12028d44a0af76e8b114d62d2e6af2cf7334bcc1ccc5f86353ae5b9fb3f8e0645fc9c77361091c187b392aa49eadf722ae3b38c245bf07f2aa00740ee0b4bc1231d7cca02b1ca5de5a77f425c8eb2b4a762a972ba077198667a7c064b36e467494f8889156d940066785a370270e80d95254603ccdfecd76d0f969288ffcefcad3c2bc5f747231d25a2b36bdfd0cb24b1f8e4f77816185f188dfe2afdca2e772f3ae9934db97f47db9aea2a7fa7f29c447a4ec8d16df2ecb291d13807978d78eb8eaa289c0e27e4f83ac7a18b4d5cdfa8f91df3dae3271539040f4e4156f0047375f81b151b2120934b114a708a4edf6b6a3b9be2a71b358b1956cb2adc3c74c2612f330b24dc8694c78f77fcaa236574d1c55d1a0b0654383a097cf3ac0663d7c11f568706bb9631be834c19034eb32cb303924a99cc91153f11bdd3da81f573ef0b19248061878aa72bd98b351e20c27bf050732f827fb238e9457669140176b3b59b58b6bd68665d45e241168cbc69412108619a9cfc59998fad8d3d755c7fcd79b1ae19c9dccb9e491ca5faca0ec719d5174d56c52e4331ceaa3a1d039ac5aa01099e7615e57f4a8e30e19b776e41a2b77507b8a9b6f28cfbd78c12ddb1a561866b1d275265a9b7e63eb092fa276b203e6f106bf4775cc2c4a977c79f29441aa2acf2c41822a53abdfe049480c85efe0c0faebf62c7a4dc83ed1183ce16bb5c8481cb0ab8ef2f18bcca3120c77510711a5dd1b70e85a7e8bcada9190eb192179801e35fc02121446d9fd2d232799b971e3c04250f13671a1390a275f0a44d3c9121c6a73010828d6ba4e4521b4602876b51e030f4360ecb93b340a3f3aea1797450c7f548e599b18b8570b2f9b7ec8e616453d477174bffe34f1a6cc93bfc29c3cf5872b83841af5dd59b71247ed6ca2defa0879241ae6a9415423ee0d8a1c3c19249212db4348692cda69d5e946fa79cd20669f14b3ee0fb85740c61ac6a06686e33145a27b36514feb8ebe9c24f81f578d7df1953e2659fb3712df4d53a46deb2d2e089e7dffbef5fcf30fb2ccae978be0a4adbb1f4e9ce2e984a4c25c070f9d10274fc750afe1facc0884ec18e47c5e4a4499ede13013734cf9a3d48197c379eda5c393af5a41e9dbb5e4a0d44427af0823590c425beeb2939c79459ebd4b417beb7d9e60a98357a540642f30afd9e1530778906a48a807ac5724b5953111e5913ad3e5a79f500e584a64672667e371bfadab1cf4b997610289542bf02b9559abd7b550c30ae04c90df18001c3f5f3fa8748bbf109642abbb62310e74062442de2e74a3b41c2d9754452f1c2503c9f94e96c09d76961412da861dbdc061bc077be935b0c791bbacf10c170784bb23888c0e4ed4f12079156ef9f6b79429f3d950e86d179e626e49241a169db58baa4d40200f6e1eb72a0654ae1ffb6dc5051f03138ca7a6396eaaba4118ffd389bd508370f75ac03241a0cc14d743a87be963a9b15a8f9e37b3df7e987aee9230e6ce2bb221f490e55d0d483d39045ea14a7a1c82d2891fde51cc741eb50d9804d6b5618508386e9a6a54960725602a04c33516b2864e2c0ef31104761ed73b10afc1c48d6ad06b6d184ea6570c89eca74e16438a6516bd9cef7d85877d1c782f14fe49e71ff3b6af733fad7e9fd9f5087b859144f07f1dce9d191d2fdd4678a9216fa1174b6583c906e2c79aac342893d0210d9e2e71cef1d02be46a09b99e0b3acd029b06467ac7663dea6ba3d70f3849a3c9b63aae25db021b8a47dffde0937507d1abd45d955ae25480d0b520b79f32856461c6e438ef0f46e7c5c27dd4c116181b62d2a4a9d1226e2f5211e200545f441e2eb61ee436755eb323fc58799e61662093848f2da60d2960148e54336bbcc3b163f3412217808252ac3fef11c4ec1eeba38d0a137def6591cad3f1393ff7c6bf9b85220d1ff3c20bfc8c36683c8cc8da099ce878f4045bc5042f37628409993435d0a3523a6916f426150a4fb457e4deb45a30ecbdf3993b9ab13f3be0dbd0da5cd33e3d01fbe554dadef51198434f4d76f2fba0010e08fc5ed9760d51e80b4744e50b2007895df027378be08762cd58df959a62f4654f2b2a41b5a042e9d93dd691785a08eb7dc3d24980d2eb089cb8fc1f9ed9494ed05bfb42f1e37120df3bbe060d2995efe1d9c679aa986bd0d81dd12fb22578d5fd70f1c82b2b27617cc3203099279ff943f7303a111abca8d2a6111088c5a98f7326b4c544e357a3f7b00ee4ea41d9ac1100736c31ed7e2f32d620f6618f874190b6b3c3f2ba369513784dda1e5e649de7c75a1726a4f3968dfc40c0d57c0bae13588ea267e83a4204afafbdf21c3996bb9d8a31e844ab9214832cfc8d4c65ad73bed622f2206184ad370d73ea5cd8ba3fe181f534cc9e205265dee41458cdb130c2f779d5a215e04f7c60cd8ae4dfeff9eb35df4efe1cb4a6b97b9aac5ebc0bd344dab7f34dd82f0906ebf354b77c6305fd98ac166325c5948fbf088385c8dd5d0e786100b422f16563e9910efd77c8b4b0cd89751897363e646cb4804be170a11a79d72cad5c1fbaf87bbc61efbd64792b0c13c723edaef486feb18dc944faf977f7b80f23c07e0d702d709efc79d9e6ede691326023be156d24024833a3a3b51370248a25d146ebade3d3ee5fc4f8f6c02d7c8b7c2d96b342b9440ddb8417a757a8c39284e0d5ed4e2595998b94d43b3099977f62d99cb954c40cec00ec921bfb9f6c983e445ce6eea0fbf4fa469ac19c935dba4608d5d1b78a97bdab7226554ff9a0f8e44bf638ac386e3204b5c0f745b8e563999b9172bc175d86bb90c94316baa90ffff1247e4975090380c34c5f4523f28c7d831df55f686983dbea454d60018c2dab0d4b805c056f4604a2137ca1b51676b747c30425b1be4cf8255734139745a859a5fd01c5ec791b2594b88a64f662a0671023c9fbcb2b7df1feff8fe248a8163474df94fa18e7a78bb88162f28631ee37b5b062cd66f4c20fd1320ae0920971e5b06c38c0ee8794f1cfffb90b95200b6b52389ed33b06c8de98a86b69e5f4c3263843dbed608002429186d15d38dc9313129bb840fdd2cb062bf71b2ea8d2bff9efabdd4b1bb855f3e0bac113a146ca8da49a58a3b225c8a13fda25fae40a499ea0a790e101efc822afe018976802608a297c51816e054cc181646fc4d8f26807753688b67eb374b0d1a4247d390d4b1145154403fca79b57f55db8c1b502b706527ab8f63539aa9a0ef56cd77c18072a87eb6c963ac3d226e46b1b22593face08d03bc7ab44d634ad3582163ff08c6bcfaa6bd68a53b8576673e6288777c37e31f7540069021caf1e8c792a2683170c0413b1c47ab38ecdcc63b8d7f60346365fc2c5d357526486f2716b97bb77a19aadf40432e44730a2cb322bae273bfd013642afbdf41d4c3282dba6a57cf69d69749a2575027967dd50c41ab8ec0007d736a5e98809b61ca2f250a2502aa734123554ea8b8b458ac1ef22646a4a5fcc489bfcab8825d3e4e76d57735edf15543d25937f08440488e66810ee87f196ee7f8dcf4d1758e1bf9fb525e18bec3e2353f88d1996ad82d2aa872e7524bf397bd2e5b9b7715194d11683fd08152ff4690a54e667465f60f26a72c0a2a4d039f938381ca55decd835a87421a77e56ef9a154e1e0a198fb05ae295e41dc2a0c2809d32c79df5eecae03cc8e10dac9260f9877335ad57b07ae789c53fc2ea91cde35d701ca76dcf8ac54367aa2a3e7d8411aab8b3b64c26b898010a9a783a029ea0b84c20286e84c67c64d318aa66fb1e89d37f911d77afe5cfae20c7f5aa02e1cab4344034a8e677542ad8397816c63be15666eafee137223bd76d5427f34005494b19bfa9f430c314626e7daebccaec2f2114e27191fd91301bac7bce962267d6b61de5d4794cd1449bb50befc20ffe435e2941b6a3e1ed4aebb3d351a9ce530229648af97ea3cc5c488cee557f1aaaf844090f8c1297df43a7eafd05d16caf1bd754d41f704942cf770a1742005849fd0441bc4280b4e4d9fd8b534af920a050deebf56f4e43873504c8a629112e29593cf1cb516f6ab6dbfca17f4470462b11397d2b28e94d0a4991900ac4d3d38ecb59b6f4cfaf9e6a608207ba73da22d77587a273465f3150304fb1d257d0f738b6c78505ba6daceb7b05cbfc602c138ed868daac770c02bd57a2db90743dc1eda3f0a816af4887d224437f176ee4dd2e4cb0fa38439eee8bf2ba68a3bc552460062608dee07f8c8dd035a2b78aa4181517ed804734be1f73bd3be9bf7200f8ff5a82c5a78a3507b66f8cacd5cb595dd7aa9d006defea50f7bccce2bded297731483792700bf738549d3b6fe3f46a48d9410fe6d2f5570452cfe42b129554c7e05014e28b1defd89f51936613a5413dd381b1fd648bcb3f7607f0d72b1e66b24662c069379c6f59667dbe046dbde255517e27ee5c65d3bff22fb668e31cb786f3ac9aa64f750223e6bf810137e4d045ceb10e4b5a6067d20d80e3bc146877ee2a54d4aa74d6e8b6a123ccc46f9cf502cb70e10979077d196dde7a27e7339bf5b41a50d975b9d3db49b98905794831050f2703696802692a817c1411775ee3e5cee3a5fa3fd26173a7ee0fcdbb4a4ca4d7849cdaf27b01db8e525e92ba1f352ff58ec1bee65cec9b62311c8f3245258f7757e32e9cd6884ce0c71789acadd15d783e7d6c9ff9d33a68cf6859fe5773dbb4ef3e38948f328bbc2b57940bd7818b243612c7fe4ed6e941a5732c173f30ba4c92d37a42f5d05c915f1c5fc0949267766e18f3cc9fbcf97b1a685c6b52bceb205129ac6c7c2819ae0549e364b207909c8ce67c91d02b5a3e1a5ade1486f464ff15dc9dd8ef0f1c47b01231804edfdc19baff780da5cc5c5f156afb075d79e114655d4b111676ab9bd31cbfa37fcbfbbde56d189e4638ebf18f90ed6842a765b7051b196ef32b94537e0f03de43552c5e1fb5b40c8a591f07de137476ccf6aafbd30afce89a52bdfe54fbfba6c70589ff901947f723d5526f6184ea314b61fdc358a90c3c6ec90bfbc6bce0e87864951e4dc0931f4ee2bc7a89a6d6e21b38c199fea24c06ff3ffe60a988028ff79514aba64780b571826d6cb681802dbac93cc6b3ce2c74a23e71dd6286957144836cd54da7b3fb6c8b70d1c9e43c117e16e7874bcf7ac84c05f0d9e3989083d96b2fb00f13af38a1c0700f9b4d8aa92d166e539c1a1628898c17242c4df98e68a98830973c801b47f81638c1b6253eeca033775b729d1f17b17d0fcb5031bb5ce926ac55d309253dc8258e3d617ec53fef7659289fe9860fcdf4aa023a7f8701d224b0ce2c7e557741a2b6def054c63448fbe09f0e5121b9b52770d8086e91c368d937c531efedcb451b483f60addb1148096b3032e0ae88c10167730289391b32375f259cf6de1e5a8c970cba473c1016e14eb84512d814817eb36f305320f16b8d674046c410686d4f28b0011b0e1e9a84c1000aa51c7ee722f01f343a3d122c4b299b7063e19f32ba79faecba9a86032e5d47608d478d596a1653aee88d63eb715629a5228cc193703e50c7dcf936f6cc163b1604d0775bfa25d7bdfa151fdb69966beff4ccbd27322c7ec14fca1648eb8b332f2e48f10e9b2117c08e08d2a9ccf0737a437a51c19d0ffa474ff83a22d4e3b7c05276a192812031bdf5a4fd1f760af9ebc2f15d65543c976b15bf795430079772bb7c1f28bb82ea7861b193af15fe9eccec5d4bfdcc6ec02d55090cb15914922a9079ba3e091dae4143b61d43d8f541b0a2fd61d1cbd6cf6bfbc043866d72079fed0d1d1e5f57ecdc42182d4a1afdc9790a547a5577376a74126e6928b8809901bf5728c25c4d9e48fe66982ac72684b544b604f35c17b5adc5b2df88a1889cfa7ece6ace60a1553d7a9b87b7cc99e1a5755efce593738b1c7da243725e4849382a263b0872d91ab44b999df020aa67d08f843145b2ca7484fbfaa543f49eb1dc9d840f48de72d09c4a7d11e8006c0d2c17fbfe35e3abc3fda5bcd6336c652bd78a2a075559db1af27b5cd8acc81d8a2a6ec2af327305c32f712417b9244a25310718009bcd790644717ca39351e19255e09bab0a1cff8a1b60134735fef025cb5241b333ce51fe2655ed84d590fe620048472bc0fb75f6758517d0719bc07237a91814521515ca3b8332be22d8d4bd21810ad9c262687d2fa98580e6277aee87165facc46ab5f3d7d3108718c80a74a2eeb16c9c157db2ddba647a73cc68ad49bbabef97333c6e1e5029c9068efadb695a849b8c2a95e958413227b88c62a5b386e17f4b8ae5353fcdc797df33b79ad30532729728e6c64276364fc6cab408fa633217d21ca06d0865c9d181b0f166210af80595a16b44e6675a0793306cc0d018d379bf29301ccc4cae6691169ae08781a5d64895785b78c813b0349922d511313e1202bded6d7e955f0fbdeff19a3fe04911e9691eb3035ef087bcd598dd570d589efbe15be909cad4e560cc29f33fc9392f3abc399bb6ebca1c5d292ea6fa26214570c0dca8e4b2f5376b31334ca867ccdab7af9613d1d1e29e48f57f7a51ee2b21afca212ae783bc5c52d78411dde0f53ec383c2fb8ec4ab569be3a98d2f128655b0d0dc9e829735fce8cf4c94b042b8a2017e9488495082929460e1c73b8cd6e8c5a2a87ed8bf2ccfe259fc2c79ca7570d597ee4b7a4b04611671016676e448a22939a8ba1b6edcb77d12ed7339ac78d73b7e6481fa7501421b600bdd59e0f240375d0532dc2c2b6e33c77ec3b2c9aaa1c3f30e32b3a69e99c1f81393bf58fbe0eec7c9018be48235f833988c47596d872fed72a98ed4d923f71e3901e4139389c1b76d3bb77b944f0cce930cb6c7e3bb36a6ba3c3abc94d280cc781a4994e11115ccc21327eb7da63501234ae5b4cace4509bec465f25c938fd9c665e9c6964092216573bf267293698d47d362de9dbbf6f154faee6b323a71c8e12803bfde9531560c68ff6fe2dffb836e3e97cd4a39cfab6a7ff626e7e5ea4b2beb0112ec3ed22b7b8cf1f5acb1e35e50707ddc95e00fc36e4bbad8cd451586dd5cc39b7434a2ec9425cc47066047e29a016ebfaac4c4cb0c761e90aa8774c6623b4159ff01f4a41f0d2645bc11e7cf6955cc47e074c7772a53ad190dabeb9aa018af9180051ffca6d17b2075904f32ab82a141712bf7b94eb9458d3ab150f5fbf9af5f7b3b97524dcddb711c273e2b0c3a57aeab31737741aeb6e5e9bbb307ed3a99f1d324826615f97d59e543ca523e222ad0a6a24eb74554bad7b31d6ba76adadb05a99c770064014302eb1f4e9ea0ef755c1e157885ebba6da8e9bb5928c126dd3cfdce970fe3738e6f102adac240735ad6872d799c1d4d6bf636f0f4de8c82ce89a1e247364eb0db2fcc5332e32b10ad6b855cb19e210b4061900b21567bf4c6a74384bc0fe709c26c839a30be1d737cda534d57398c7c6bde32fc6614a3613179612fe6b01fcc3b39492578f77fb0aac5c005007a7a34ca0cd511455522e3683346560e9fd09cb2fe1b297557a91e2e7d37be96c6eca0087241b3d74de3f9f5a2b1d43303ce40a067062a2b5a6c89ca2b99014a571b5ace67868d34b3eef306b03f849ed8594c7eb8aff1e347323a4e9988f40d5f3a1575064999448678a19a2a6044c4db280780097c7173940b702a22aad009aec2f218f622324e3a86a8a194ec6fc5b304124d4bb36942d961c9e31581ac0034fbf67e6cf1dc9cefe2a9bd9379918a99d0459a7d3868595224434f31fa2f3c2ab51ce1e973553aca22e20d8cd1a72e510ea469a1274d112a3571dcce7440c114d101b91f106e245205542ceed067159b03e15b03e726689453b40fdba9fe1859226a9ff8b830bbe94beabb4bf9cb3e083cbe6c682c37094f5c423dc48d2a5f4ef10c37fa42eb6fb7278f6b14bd400d26fcdc660f3ca70fdb7048c89e7ca0131bb5dc0f4d2abb93d39fc70c16af5be78362ba69b6edf02a481f54593db79d9a48f7dc75240e00d4ebf6f3b193d4675ffb804f646dc5e03aa49fa38691e97ff8bb729188d4923f00608a82d7f231fecff1b7f1cf367ba130b53b0817308ad49910e994ae04f74e9136d244f6ad5e53c92929ad178f517bf78680453f84491787e2c68dc94329d4e130c28285517a60fc7f95eedb8f9dd403700b80ab115c52587e41618692a853a07393429f8ab949c63ebdf8703dc6a1f0ac89fc45104f00a61ba29b01a6305dae34aeefcfcc5ff0009b16ea2fe6eb10912d5673b8ce93ed04fa16124cc31a4bcc6e9ddd37c3ee24d1cd0bdc0d632c8a05da121ab6262694c446819129e474ae23325582fe7277121089ffb4dbaf7875fc58f79fb292d7648f1121f9751a95625ba3a4c90d755b66a988dbdcb78d56b4083d6b199d0155448b71e401772538fa63cedc95f50d29f0e9e82a2ca3cfbb34561cd234489ffd4fda87709f22b95e4cb4efe445d0ba76960756a47b0fd36125db0155f446e8c64099540c18036c908911be74047a6320371d89ceb210111d22ac0d704daa476fb7684e79a4b987f0e3810f469bcad6200e3815708432dc4f6dfc08755e9f062ab43ad8b273f11aa7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
