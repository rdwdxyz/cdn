<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03e7798dce3edc8b5ace4593c6bc46edd8726f1a94c4d5af7c62743c35ce436ea83301f12132328f914e1915b528ca6fa50048c5b1006e52d1b7fecfaae920c88db8b6440b9684ba4bbd6c3ff88e4c8c0c66434171c5ccbdd8f97204154d0eadd0da2201f4b95dc2071638658c8310d5cc49f5f476fe1560851de7f914cab37d1559da932569e44240113207036e74bc497e94e9216bfec96d016c9e234689eb6e1d4823b629beb796366b516b0253222cee873a12ac879c01fa309aa47a5cdf4b1d28fdaaf7434cc882df6cc2a4257f445675cf3527cd7529d4949d68628ffd8b064e984f10306d0e73ce8c0703a2c9a720720f212015169fe9541a884a65cc570322586e839e77be097262ba0069f50e590a497dd395aceb9692293e4e007d4334df06d20db4234b86579d900ac56ec252b0eab172a71e6a743a98d9aa485e59a5de0de8d40b02e956cdf991dcb8811efbb7434925873081b352151841ae4d505d94a4e5771fb453313681a7ca65530179470264b2e72123aa7eb672b973b91ebd9a494108176cc864f6c51202fd1ae33026e1298a77f9f5217de252b48c5bbb8108ca5ad089ce36ba7e2b00429439e78b0c3d64b419549806b1249a878b38c67886732c9f0b9f5bc82c13a5a694f8b49bc72564260e5ac891f27bfd88b8e09e4726cb9b4753dd4583eba7d8e85d1fd57399ab53ba0396af42604299a01b2ba8dcfde6675024d65cc280a7599763c655899c351bc5d2ffebbd7f1c8526becd69eb20e354be62bb13ef60024fcfc04e8931c318f07543c027a593c897a2190fe40c7d0d135a575835bb5e9653565eeb1a9f52a05a2e6892d10e9362c0de08a7d6ece3c79bf37079bb1729daa25b762442081e31bab3ac56475d75e0ab3dced766e9f9ce62ab6845fd022355ac741f01175c469c06da9ae89a8f59aa6d3261a81ea6a6db7487b8e359dd229ba15b1b0097d9b697e8b5a46783578fa655686d9cd077cbd21ace40f0a3056dd74d309476bffbc14753b1e4b1a9a5d78e5c434b5909771b37a7d9ba83fd38b8bd2ea7b2aeb296d8e5faeef9b105df233d68506d2996d66b929e646b0acb4c57730f753868ff8d57cf1f0137f89085d1cd7f97ceb12418b5f336e578c58f1bca5dfc537ddbcbc7be2fd8640134e9be957cc8525b17c2c22c6646840fa64b9bba8acb1e6ecf3bbe4e4f1c909e0c7c20bfafdd4500eacaefcfff8a05709b2b9e40b793e2de14f00f5fc7ad237a8c2ac288111ba517f0db82c44f02b3cd59173271e23caffed9bc430fec34e593048e746fab75289ed9cad34ab3665361e40a9d16405703f856119a282d86cdc48613e3b9078e71c2448393bc01ae742c14e0b3a658bbb4e8a3724a98675d8e7d9b1770619e4dbd1645eb708d140ef99971baef722d1f8efa5a71cefc6c65c244d700999443b6e1ebf7293d655a628cd5f477e3492b2f4f643ff8cb6d98b69c6e1d2294729c621a709562ee36bb8034a9831dc75dafe6ecd2fa20c3c5a7d643151c3630b225534b027615bb4ce83831338193342e7508b38dbea66cde1108a32776e7a559b4633304d5355e24726ceee3a2ae626325fa36c2e305eb3793059d5f15fee32a27a57fa676ae0e034d0cb4d2d3657bf87bc636abda9e4c9a71b84b494afdd03d0216ec693d500e17c8ab19291a1ecc9e8408ba424f63fb242e084b64e3dbb48c9fb13694fbfb4370663387d797c4317e6706cfd78b161bfd7cdb4edaa1552538c6f111146ee1236690f9cc3c7c00ea054e2f890a575687c426b283eaac2e9357044be3d859703f17c7e480ae369644b99883391e160fff497de6e81961bee087cb70711b0b75690833534e4b6c82e06899296bfc46b8b631c5363b760e42d8d6cee7a0567c101ba9beeee41eea5910a25856d60d8b45b9050ec4ffc417601e78a17681662cdb9eba54992ebe95d06434765bfa552e5043fb9cd19ace869bd95719f0e0b2b776cac5f90782fd228a736f036a85e633992906b1ce84880161fab679bd8616eb086875c489100d4174ef35b787d9fbaeb6015eb866906cb335e5141a4d612984a922cf14f0e26e143c5ccb063c641d9f5bc34f1dfad3f19f56f92c17f7cdf1fa9e4bf9d9b186be17104384cd465e73997dc5a63e9929833f4ea6381ab861694d0200d35c4402d7edfea533b1061e240261be680e14952bbab712c0ef91035a08200b54b404fb17956c4af7c12fa68f9f54e41eda95b6ff53d3ae3922bacdcf474c412dd4459aea820fa7c04133db4393c10a8e32f390d60237cd9ff806fd4a29af2ceeebbce47c1ae8555a23eb87f2c33f79dc5851acc249b0c6f32cd84ac503d15f0d4b70b3f4a88338fb6a1c3a218b0a891b48979a9603d608d8a70c64e26bd6c26996ed1b94a510da1ebabaf2ca314861b774240e8370f27e5ea328651e4f9971db78b9d79ac0885df4993d488026822a9856a8b1558895bdf108d6a0cd9fa30aaca440d8b84b0a5151904dd369441ff3f3b0b2f6802a352dae304b4892a088055f7204bf80b222c97011740f88eecf7da1c482ce6ddcf22c3c57511c9cdaeac73ad9e3cd8f55d9f2a7a8e0898e40ebb8a689c7aa2f8c0e41cc2381add5fbea49df144d4856c675a8606ba4738aca89e79923801849465fc3b79880e160cc5a007a7aa89ffb805b98f2329122b2b9f6b65d14045f3db4ff9ff9eb8166f0d67d313fd847fe93e27f906531574460d4443d90c1e5528f3c23bcdfd441329dd5a1ff003d7c0a2ef79a45d08dd26da97b880a5c091256bbbb274f3ed4f78054dfcb7e5b508feda7714ca116ab6c461db39a147bcef8cae1d5ab1c4072c7c42a1715cbe29d05ddee2fe91f9f4ce63a85d3591c846aeea2b065fcc705cff55af3d978041f3c400ee7f396ecf6da31f6bfff66e6d49e2eb7f0361b0730ed2c44200b689260d8800867e233f0a4d30b518833774f4407b65be4258916b3b310df60ff6adb5d7b0641a925610ac069c4909f80bbfd60f95228ac2152b069e9f26333987d63efcb72577b0b17b0348a1a1ad1ebc4f904e85619be8057b2b683f8c6067e130fd05db4499e572c8d88c23eedd7b93bd66b54ec6e0da02374fe318535bb3f05b525cc444443d58eb02f873f431989aa890b63d4811dfe11ab885d20c1f2fb4360c27bd65e7b1dbe43712d9ac91796edbe65b08dfbee5e0e1942edf59fe0f57b8be13ffa769f9ade507c79527fb2e8e85e2156b3a7231a051afe16ceca8bb205d463a1a8c10fdf885bc6d657cc6d1b8cdf862c63b62c50d03e5b392bed9e6a026787ebec3b48a5409789b7a39d7f6272110dd8b30f95c5bc62d26c770ea47c3f3a494e2937bc9aa63dccb7ad689a8f2f6af070921a8f1104684e6bb4fe87b25b82c8a3ea1c2063054b9d1cd4a6606937e3108276eacc7c2a7261c4f751bba74e6d0da189132bfcee97c780f454501169083c10e2eac0eb3abec017872d303e0c770d89ba1b8acd670be2564130e28c3eddf88e8678abba86fdc6b87940360d8e231d92a2cf96db833aff68dc8b7c74d30824dac0a5210cb9944bc3b1aee7882e0b888c2db8cfbe8aa99e5b066fb15838dae2b7f0928a38398d8861295f49cac78a8fe012877a1134e9b62785440056d520d330555d7ba0a390a2c4fa4015d07756122ceda1502f80d819dc4b67f3165db5eab90fa459916bc2b0aeb360c7eafe95c6f7ec4a3fc565079c560e46cfb6070ed9a189874bc3ee5279da140f732500c47a42b9bfc95cc965fe79f5f9a65cfd05f89b6f9e3732ba8fcb1fac4508cd01d0531d61495fc0b62d30187bcfa2783fa48ecf9385acc7710ff74183b7a689f5ae760561393af1e808dd0458ec440997571bab8784b8e9dce889e522df34393e085e5e0cb3667999c5be63aca264632ec93aa823993e86bf3e378d0e945438e715b4a77a3bceb386f4a27647cf80ffa89f431d6473bc4c213c33c794d3abad169f1f639bccaf8fbb8f78f2e3be590453aea49ac8987eae38c68962bd9a160f88c02b083049dd1dc4e812859a9bb6f33812640de0b3f8609348ed32912b5d19e94e437342aa7497d4f5bc9dc058de1c6dab6a99bf54591d6cfa0d269c3a11f8a8f7fdc93c327da672da49cd9ac90dfbb904ee6f03599fe2ba26b83b91ebf382b8f9dedc25ef1548f390997f41aad8d2d93c8606922021d4c4b3dd883ce62625e3bcc308597b41c3d7e79f5931040c30b48179f8e590e74b7246f8f140e60a055a7e970c5e35ae9ea4831c9d7c82824a3b8c17a2ee857db6dee5c3010419584a51e210bd54a6e36a5ab5cf75db60fbc1005fbeaf0aae4e3268e0fa1efd8ce9b502c53095924a66505a92fd9b816482ff30a20571b5a672eb8e46c980c137acc5c0f877e73736007113c72e46752e0201b127a51fbccac7ee24f3a23ded8bae1fb2170c16f03e1f1a80a1b9e0737e8995f8e40641b4b0cffc95a6672df5df02d2715dba01cde88dd37a28f3ea8ad6281fca484fd95544cd9bc8700d1729d642e4e0f98cba75b945533c3172ec4b8e0e7bcb661975367321c42c0a7ebfd09b7c31dae874121f6d748e7e9d4fcd968323e2755dd4193cf384795e87e36a022eee03ba5568f49fafb19b0e14df46b33228b5e41fea9051ba4231fdb95b066babea9143351da91c56ce6ce63adf1d38f8e4380b44e3264d166251225f2f4df265ebf0f0e6303fd91ba2c1085cf5b724a736872d13d4f653ff339526caa89dab59d74643f484e8b7f95dd4290af91bdf33dd8abc9deee9008d377ce158fcf4f407b7a85112f9a78613b646711fbaeff4bc3ff7801aeff0501e7dbbcc46263382b00e7c90440c9c75620d8b24a7a7ee87362f047a921f0e4d4a28074d24638e3c5e731bdd7a884757caaa14539b8a6c6cba35667d2a56389450e0c5e4652aa8c87fda430e1f0cfc02c16916e49e7139c42dda57f8de93ee65c9e748f2a89f84d59692a2bfcba1900be3d298625979e4be568d355091860c18e58e45501f8eb845cc9e6cdf1bc33c3c57b50c96f55fc5455220bd46a3523084479f90553af87442a5ecae97ae7ca961df520b29b76dc88d61f00c391ab98a8b25a0f483302b044805a4f26cc1ea0efdb957d2a60e9ceeff8a0513ea7b55f14ded03e215828804e22e6456126a51d1afd8eba42c17d4c8ec3dae69056ebda037b452117326b933f5676ca8693c44024833a3f36ddb682a39c1fb2cb9f998a6fbc01f28932f60be3a94c23608f47899bf7c702512399e0ee4cc5fb6d68a12ca17cd3df48df427eb421d14acfa7afd90045ecdc693cf38457c47f84c8f8566562d1bfb01da75c6b135d06986dbf22dfa3428fd0101b12b4e5a85a8f762b861e40e35b5d8745eb271c5dc023eeaf5e27cfa62c7294d0ee9bb9a64dbb9fcf9512a6dbcc66cf14e5c1c82554e2e2e8ad3a3a00d2d612b21f3f8f19b3824760d38b0b0526292fd7c387e4ca42aee3bee820ac5bd4929997b7e2a99f1f33c6aa4131e4656e4fbe6b6aae4838617d0470e10243b49c57140be352d16f323888c233bb323dffb866d828427f19cf75b90db0bab373c1523148b75097721f8368b0c4a716b74b337e92155838a67b8a364a2857f4e5e8e7207067b9971205478ae6280e021bcf387818945bb30a17ecae927880be174b06af817e35005a4b3c1949c8402a376a87d7bc56bda4649c67faeff52da5cf2fa4146e4876ee99a590f766bfefd1bfb7c74f1f3f40ced1a9bbfd69cfe1b6b3f3bc5e76661676b4aceeb24c856f441687a547a0c368f71d38e61484b07a513e80232e1f47c5bf0ef1b432f568b6317f1edf08d00b104ecfa45517646ef69a2902e08d16938fdd6d71e36f5a9821e1289ee80e4910c1ad2a4e27ca7000ae2b5281dfe585606411972c39f3b20ac35f42e3bbe2d6f8bec3340343865b7d9ea36fda33c0e79f002d217bfc0464dea7593f652815dc5dfbe0c4dca090c7bdfacb9728d45973b297acf4c33ecadcd9b105e0f9a20b4163aa19f9ec578cec719d2434cc0abbaa4e65d5abfaf5ca7c23d76520f80c89f9ef8585eef821d1d632f479d45b1c003af4915aec512bc150d9992b719b91c5f3263bbf3e459108ee1ef8cf05744069b25d8ce29af4cf4e12b016aeed9524921254e60e381553fb481de2d2de016b296c8be1567655ba1537dbb470ed3949a333132626d8ec66138ec8d61462f4b59759212d8246e3aa6da56b360f89939a7defb66ea95edd56b31fa84ca5840d1c88aea9de6e2099bb861ead7ecc2fdb681596db2da7477c2ab9ec18199d4f28a6545e32c684c985f247e089710037f0dd09da79d82e6d73bc854f0ea48ba873c6db204aed858154e338b4fb6305752a39fc934f5975f034daf5f7e287758740332fe05a0d9e5c96438d93eb7cdac0e212fa2d73a5804c17471b5dc79377aa4a8d698910bbf0d9e69b6c00d0751ec7cf45642857256893c9fce8034b876940262bed2788a891d79ebb3e9b731f05b4859a0eddd97901736a40a4463b8635de4c8dbee034f56dd1a1109107a2a1836df9f74f4499a60a3cbc4974b02959393b3127d7debd7af8e0f1b3875868682e679b4d3936de21b92735b23999d95c1421469d4edf93b668a5574170c9760656fd153e50cdb4916416e8caade45fd6ca948f9d3fc6d7e4019fbb142df3722967d28023d3709236f7424dbee421860e5fce6090a9bf910ec8a586aa1968c5c9346497fc522efd2b1844689718112d3353abf63cb4b6251eb601c16266edb70cbefc599a5571aa07fb780575398e6e0d1d15fc20d351809ac39b98a9939713d0ee4315a4dfec74f3341dc1349128d05c448033a30e5f3f729bbab5dbbd3120ea8ed0ed8152e53e1a32a58b186c95128758b78472d840b051e3f1db9a39430d7318ef5a4bec6be85fdc854b6c6fcfe5a43584a75a4c44e50b41b6e30a3b9660518e868a936b426968b40f22505f5d883406715488ab537d31a864e6e5d60fa289805611421d970976b4c9a0163889539d13c8a436aeedfe7b82dcd5ea6c2c966647e5e1cae46ed9db222431f42a7d8a357cb813f2d556751b4ee4cd4c66c724cd394b57f1206bf5279f865fa1720e39646a98ab22f0c5871b2dc38c8375eda17861a9ce362b086942f778b947a4609539582fbae9bbc44405437381f606171d3bde64c8474b9e5750053ec7da19c42510297dd3b5ef2a30c79abceda2a40ac44e7d334a473884d50d883a99ee7dc2f23db6a5240b0143fd2df6d447c99ee539930a68e9ec4cbf6c24c2e243d752635b11a9fa3eaf57eac7db2d07a10e32dba84074a312bd8dc3bfeef40682eaadf196834ff5c6e1fa4de7b71d1dda4a4609a5319cb77c7eaee8169c0d1344d645eab04d561077f930cc97f1ec905ec709d426ea301b3f52281a2ebb4277123622c5739a61bfd3340dde3d038bb37bb9a6b122b96411fdd228af51d3894434619de875aadb8745af518ef47bf89f9251b36f136ecec4e1e7c8e2912fc22fa1f80e017d578cbba9d0b4b446839ec0f26a96eeee42c8a62c6ad6b3911ca6e01246f57617e6b8f952712db1c9ea980c73514240efe2aab0adaf195105a96bd0e5fb6a23851186ff9539e0982f94509e5052c4b8211618e27102fe3106de0fa0d2e63bcf294fedc81ccf53843c749432e8d32259d8755694de3af456da7f62a8b15fc153d119f78b1d426c01bcad4903a0616a614ba183264e3130c4a706b68a855fdb06780348f7d868d36702baba86d55e83ccfb2e80e3d70facdae4c26a5de461c79d12b932ff3cf15e2104d0648e03b2c4973260067d76b370720cb90dc18c4258c06f10a1434e51864947a8b12cc0fa6f562b80989ee7882fa7d86295a59b4c7b1d6dad0247a93dc426f8d7f6c6c1387d4308e5332477015e49febcc5b292060a01ebc55019bb9bdbe0b1ea56b737b5a8c244794882cfdd01548a5aa4b273fa5d773c6efafba4dda3166bb9c28465cd83b9edbb061fe82d668cd1446757cc5a46a9726afeed2a442cebdcdc1ef005ab6f66f4d2ebe9bcab7a00dca8473186f201fdc70ae02260e60f5efef621cad8d90d4f60a20be0c732cc4b48c9aacd445512b7beba6526514ab0a76c5108bb485f145bd681eaca406698b185609cb4806eaa6816e9a38a9729550adb4f1eab253b989f0570b9256ceca779d664e0121a456ca88f302ddba21acdbaf78cf2f0a50a1453b33c040247c72359db383a80be7abfdc02c85e70d31107ebd44001e1d9b5860b0e626144cdae13211a6a5cad215af3d3a94e5a1192103598499e2ba69963e5ca5761562d16049c2cb17ae29f4f2be64bb4d14bf560f9134591546d3e2ebd4cdd7d3578c80d4c9a374fd70f6e4145ebfddb3e0586d8faa5fc8b39111b3ad0b9ffe0a3ddb2d83399dff5054b611804f195bf1cdd84ced2fca3ab751b756f32244cf9d2fdef8e920d9f232cb62bca2a2efe7d0d352893ce9c0579193e76efe5bd7073d194aafac8d56d14ffb4bc203a9778c15a6d6b47705386254013fd6c01d30222bf189f62be088ba7738982017a12362c0655433e56b25ed4f717ce0bbc2166d5b547af99449a38ec15126661dccc125e5829fa4b43c6191a30173cf611274ebbe3911eb6265d6d8f70b2cd8b6d854f4e79aa61e8af9bfb46ee6d6f9bc01e6cf680fa5b8f1062837266ee4c6049bc0acccbbcf40a5afc10d54cb35b794bb3e2b375ce37fcb41d4ba07aae2214c8ccd4fe7b19e58ec3be01d2d80e83dfcdee7d443e3306ec6b115323971f3d9172b997faa7158f297b48048d75d823f8c2e6eda6509225453801dc3b4f1a334662986409da8935d761ffda0155133dcd91230c4b0d4cbce08e29781f99d0ddf122d48bc3c46b466e99b42014cc47711bd1d046cddbe3f9a4e1355b0de1005da596634b3571c7e791d9218e017cfb12a7d4bb89854707bf404aa696d77d9b44fda5100633446cbe717fd415bcf1392e8e2ce8d39010dff118e29cb7fb8c82bd884776ef36cdd844dae07095bc7286f4384627f53f50386233d6751c4222fb1d67429ac65f25dba8717689bdd92cc9652b35f1bb7c8e8751c9f0c456c84c6b931cfad328395c940f1648f21d13ed90b35403079d3668dbf169e8ef7b06f265afe70268298c803ff4e31438d4c106786dfdfbfd9b2eb7ff5cd8c96b4361168990f771ece9d0304538bf6e936dacf78a1454b5a97678b12c58394ef6b6db9f18979814c24a2413c5c384c3d978a5450b3d2a3bf3ae9f4c7f52a6e9ba8f3a0962711624432a48f8b81bf20aed68e2199574ae4429cb316250a41ea51acc429368c4a0305a412f454e73af743bcbe5b8c36bec2e80e839bc9291d6fef7eb198f864faa37a0aa660fa2f3a5db17afb946dc59dbbaa4e79537aa14ce33d014c9bff2c28cf4c43a7a299efc1e76b70dfbb2f82bc0e20b0aa5e26c594549f13553586caf1340932a3d0b42c30b26220473c8227da806ac31b918d22e01e675ce0b31f2a9df450ee9c105d8aef03ee7ab3d5ae20e7ce24ca36f8c310488ae2a24e5163f140a2112756d4ccc1cf48299ddebbc6bec964a7a0e675c9a11a0ac184a7934e4f6153d8c6a28677a49a02ab59e75cf993266e8ce07e8f91874d11eb79eee457f9d59ecd1f436d4c2d4a807fae3f51e4f55530ad9f74786c40daae1f8bc1ebeda614dd7c02f50a75800e37374057668c395f237d5834e4fb051d9b5162d05cfb2ab33edd156a6d43940d4755ce4ecfca7fbf95bb4df833e4b89356a1a63f9df77d67864577ccc876d5fa35b06276afa0450a40ac5154be43dbd78ad4478024fed7659f1b8406e7534c693f5b44d634acaf009bde0c754d57173777be28136ddf6afa4d5388a28edffd97f8b5ff4b3cba342bfce881977bfe41efd4014832f0b66e4e0ed46530f50488048c52bc0e3e428aa3854fd0d4d4e194014006aecfd8dd984891eeccb912be96aea7ab8b42239562f5863a11b6b48f3b75644a98309abe898408373804baa57731a427492365c637b8641bb2119f04aa77caf2cb286831afe2c50d91e3e073fff9d0438ab8e45308847fbace7fc5b3ec6161d8e20d2686c91a0fb52d481cd70e0d876ce4c147e13b3702d4194e817d7460fa41f3fcf991b1adcbeefd7358bbcea3441f6260cb339a53831735ac3e2fe41a81acdda4c80bb1940d813543f758db500166cb27858ad71f3795df633885d2fda60bae96cc644e0cfe0c8dec056d3eee225fc70575d8320eadedccc791f45951e8815be0d8feda49b7fe971c2a738495573b4e2a55f2732dcf9fa9dbd670b1edc485dda1390b54a730a89563c65f77f4fc056c65d1fe516bc99736256ba33f399530521b8978d1acadbf75e279a95612d37a2f449b681ebf60194309bd845b0f1c6ba360a9cc6fd9dc7a9ccaabd25df2f60b34c72549a7432306ec607ccc71ff08cd52803e08a944aae9c1a0f9cc1fee0ed58471afdeceff5f8bcb2416a0d510248f02bcab9242d3a186234cc5bad1d79164f1d689fca49d912e590d8dbfbafe7b72bcba524cb87786e379cb68a0cac29bd9994c3b83b35c55e3a0e30852a374837c53e24920f20fa245bf8011551472db16f66be4e5809ca13249448c330f7159cc203697f3b2dab0e109bca5ee262d0183e92acf8905fd3d6139480b1cb23748cf21ed749dda0339b49c213e8c7c0a885a698230727731425e3005ea056647d4335361e094243e5ea5dfbb4808b74497b325d01b462830ab3eec5fd86098b90e1da7b36bea3b1fc38f7c13e2d87f700606a5fa5d0ab98e6661b00a6d409e682a36f9602f54faacac47bb5bc5678007b2874989cb8912d404c190a141e2e321e80a94aa83c173eeaa66dbb81228eeff54dd96aba3b7cef031b46f2ea82cd2846649be36392397c65e2d52a75151b89a35042446ee03023e0fde0f4863dd334cb6a9ac8c73b0757a45ab65861b7d52387a87ed330306aaec55a6821e5b8c7f02655c727fed948669d64676670047f7ab0a53e2f2c0efbc4b71212d37ef8006eec7fe8e0181568e1fe189c9fdcc415aee30f5dea2211742ea740978903fa355b0e0328e91b1266e64b7e098617aad2bd02dc379f9b6b1611ae13c43a6d76e29c0c52754ee84ea554892fece07e16eb882300fc555dafa6c534dd9ade4c5c9ac12720d83981cb642b530e65b304316b8c44c3916b00f0afc9b8059169163b90591530e9814968489f433d9cd73901a09187d56937f86aae57ec1166263267c8f45e31ffb3717f5fc90376ac90b3466308229a32f7a67b1f048eb9d082b798dffbece96966a94295daa7239ea413bddb286f6f1ce5af34f7c36c25d6147da4bf55bfceae7099efe558a6021d259acc4bae6b94e30a5e92e7677b2a41f6fb0d4dca2f7e4c872b561ab191f1e7eb2f023ad40f70b6814ed8ba38f8b7e463d0768df9b3bb7800aaace97c939ad84aff5b8f5309606564af86e882f788dca52c34b3e34bab9d192a1ee1097aeef275987ac6ad06e0516c2e1aec784183a5f971b4aea0943e7349929552143f9a538cb5abc161ba17d3cd2febb4f37e058405da07672efc91824b99301bb7625322778a9dc177adbf200385da30d1d0b46e3b160a3d4d95655ee416de02d180e44485e642c612dc1a9c73d32b662f60eace0427c804ebc530cbb79e4c12314faec40a129b1729e0282e3901477da88f1f42b132a43a6da1064664a40776a76697a02f0d80d285e05594599cd1b0c953cccecf87bd64134037eab0329302ea832285943de6d41353113d8a6df9b5ed0e4fe441ad6e3f93dc8c6acf40c2caf3b7b78f030abf065c32ec24a1a4370066c8816741d134fb96cd44fdc5235dfbea37026c521c7ae623188cd9f4af3f5fd6d28ed44b699fe42bd7dd9154c39f900a3fc99c030baa36918e610f2959257925e8131d4d5bb9de815d212a41a6863ebc57204745ac838ef666f1bd6fc35f3c2d8bb545446d4222fbdb8a6a66c5d7a25569283d5a3d19b439ae4666c4159cce7f9f024692c8c98dbf3c5f3ef875e6fdf11b5985287b3bd8a4cc1b8af6b05895796ed97fa8ee472789db9a2aa97c3c2c8c43d64cae87adb7ed4e4093f2ff2cbe0fa06c485e59b612df33054570a88e0db9d924436309a0bbfcd067ec9db8fbafb43d1ec6d396d4c950999ebab953f0d0537a885e0b120ea86b99a4c4fb30f8b8f80c1a8c648a941806faf7b650e679bc8c0f1fc9c2f4536b4d4e14c4a47f9acaa2d15a9f76af4a422c91916ba07564d98cc1a131ac585cc938ae1fd27d496129fb02cf8435ad1f551b772b306efb5fa01ae38a9870bec2341ca48ce1b2abbed77aa185ea418d18502209f78722315d7b68e9375c03309fe4f864ee4e4f2c4aee10d664a42edb3a01bc464af660c66a46de7fa40cdb689ef1f31632ba54a4ce4e93e659b69bacb3ccc15fde0bc39e8974aa6817b2913f0b8413a30b9534787b5d1b9773f3cd36c47267b7512745d72e59b71e0b7bdb70cbd0741872aa84f7421060a09c76ddaef8cd39bc7b5c7dc2cbfbe537f0f00a869dcaba7dd0bc447d996d3a359e59e8118b4d55dea36119f55b645ed93f73ec596f37521f41fd94211571684879a3db5035640734ed36eba909638552524de1f884d48790688a3bc96a9b0d7640126e9caedc6580d82393d3ea0ac5b4f89d30e7c70534288e969a2de80bf587b9a6c26034ec77c58214c3fb6f6c811a1b1f288ff4bf1b361f778bcb9fa4c2ad197d4cd0f5b22c5b4362e6ca61083fdab54b83b3b5e610af7684c3ed2d42e61155e9abc88ba055c23db1d46597d33c1b231e3681c61f2ff2ae0bd88791aa4d0009c8abe9ee827ec34baad2f73452d1cb3dd663b64c8fc9fd3864eff45ba15013759d7b80a366f959eab59ff2eff1f25d6b085fc8520e67993e3e78ab913fb358e4cbe6f9952776303612e32353149daa9aa38934c7404f7417875ab2a6d005dcbc935dac87490320814585d26eb5797645e812a6a6dcee31ebd63891f54f63944ba8e6c2a74023bc41e63d2e916f37498c4ece5cdfcd95c665184ccd3d3e167b8229524d94f718c36a1294f30313157d547077c5ff920da758ebfe6c90315be043d1bd395224402cc95b84b29380ced788a3eaef4b2d9b557c1c7c4517beee0d6ea7e9d85a76c7ff8df4616b8923510034555b12522f46ad0b306a389d19084d50bf2b70d2330a4f3e75402558d271b47bb6da86835899eefa7c5e5647d532f4acbf511c1bd8ea1da162aa50bff5caaa459cf8503b707bd96b4965aa516e0971a8e6864f5302f0ac42145091b5809c9df53f921473a2d0d1ea0ff8ec6b1848f951091919ad0bdf6b2ed4cb75fc05330faa3e8d288b91c0710ccce47b12f05c20cd67f9116d256b4314588fefadcee1c432a6a3c30824a51968f941f98befa8e03a492f622b3a47c4e637758b7bc33e80c1d5a5c7c1d29336db6b7de3773cea2dd2c61667731edce12df0425ed141d9f3f012b6125deb69fcc019d646913f2e78e3abb7e710f753162451b96e4727db241f94614a1c5ee265d3dddeb51089e2b346519cc4011246c6c6ef7990359459b804abd8b2a88f3c242d60e768fceb39208be378382fd713f15b1d7b6e5f738cbc0273fd10550adb15eb6ee16b76e1c1a6e7f8342065d1ce77985ad155bcb986f881dd9ada7a75d7558cadeef408271297642ab069adf4a56eb86a8793e7319b062a2811e6099cd3cee19a4936181aec7e9c34626b87b654ecc5a2b6a9e2d60b8b0da9c2d77a478db9c87055a9b6d11ba0eba62653036f79fabf1611663b755a0c0f32bcb979618c287101eb83a84ea151dd98b12a5a3344f6fa3c71d8e7448cd3c17496f7934cff5db2fe9be8be443386f6565a051e3c8e6ed80e8ad272bb06e947b7455efbff73d3dfeb9791cf874a9876c6ed8d8b1bcafa7cb59974f43b949ec50bff2e63c3635a307e540bda4c42e7f40469630417762db837c86aad00bfbcf1d9f7c5fed78bc18d28ad2902f7f79ed7eb9bcf061f9475043c43230301f734d374a5c7a7720518871232380f8f5a3c8b149f891efc0a6f70fca3d3539871f4b9b557be09a159c296e85a1db7cdccd01d188ac6af96f24042a4e64a671443e2542b5ed311d1cf09973c320369110da4fdc60e022cb9008500b20df4f0491b2570a034a38f5a5ad5b94275f5b20026bca56780badea077c2f78343e1d50294913cb09eec49c3d9b9e7b75317da3538528285d73c69bfc8eb217b1b38f2f5dbea493f5a76e54ee340c29d8e29896ddc0dc0f1a79a7f7fed2b81d6426ade9614b95024398152f88d1aed6cce4fd42c5a1383322bab710f6be6184f0f49b4c2d810d83439f7c345ba2e075e6b967434349af49e60874216a258861312e1a4204e592f0a9c6e858f56f9e9c9661cfa1b2fcdff2601963ce24dd335ba7095f3795242a83afd248b9f32bde34f51684c724b95a60296cee2427b2d9cacbfbc7cfd684352d19f279d6588c7c7ffd97f4ae2bc9e945c1d3093e0be7eaead656cc9f425e17dc2421ab0ab1b49e6c64e79893a579f6a488160a9d59db12d24d328c9e53960c9acbf3d2dee7c598aa6fde4ca58d7e1c101147a46f11330bcf65a0e5760c2375df85a7c9380d69271c91b506a3d56b77f374ffb5cb83400e54c70606295f5d90bdd3d597f2426879aa504ccd6b31a01c28475d1283201fd2fa737d7b2e172e7da639cf409cecdba9aaafdbab541354c3c6516aa427fe13d9d204242f9377daba9b09925b4b056f55e47dc302225e560906c34c9d0d66b6852d8893399579061c68a928b2c7bb5a7b35ee39d067158660f2b2ee89c6c01f2f6231f5b0bd8843a2e5f222ea4e1fb5167f76f8cf8b1c8f2baea7c4849e0fbb67afc2e2bc0ba6469d2ba8d0e76acee55581516b516b6e6ed2e915041342b2d48833bfda5b375a9e0ce61b0ab1a902d7476231dd54987761606b662febcaa60f8a5c94b73dfb54a407dc7952d20b85b6a7f966c6c998d919c3f2dfbb2efb5830000852b5d86c89431cb5f2e049ba8b36925db4e2ee12d24dfc179d1e4aab6d7efa8fd37ae4ae4a51f51048d9394c16a41c2b6762780fa9329d6e83b843215da769bb77a8791690bf83472a59570c4edde8e53fb49e0542799b494647233ead6bbf237fc6205ed38cad74ddd749b29a5b81042622b7a772eafd3d44feaa84ba281bb38bed6c0db2768d6a79442603bedda14ff90c587a333716fcd64ca1b39e738a6aa3ec1a7e1865b4067d94ecd2f92d21d5a35a60a967cfe953f69d4e019441f80be40311db128e5776f5dae30d495f37d66b93370763813d5e700c4566495500c8f2c9ff1959675d0e90f7a29c38b1c74456600102fc4c2f00d81f62f95a145a04499d5a76b7a43f9f3df26590f7d12ede1851dc06c77d4458c2ea4e451de35f034619d5c2d0da71e0b58466ae3386002bf92c636f9532782a9e9fde321309d0aa77d4926faf9493dfd44a807bd5151eef5a27c56c4b2dd24f864f2499a83a567f06717726c71fca067b7c1840c4c77fe4424a3913a4e81d699f34b015529d53b2e7aaf5f34579f23202e46d3375f3068efc1da920a13e49afef39576e0c24c6fca030b1ae2e25200057216d8cbb6be34ef91955cd7685bdbf197214bee86397fca95a5080e9892c4a0d47fa59d1ce1cf74e060ea5a0308d2cd03d57d0e07f8c28688a61581b128c71a1d4c70343dd1ca225086cb30532f42d309067f773a25ebfbc584a465851eed04a86d6aca2081cc8aa2e408aafe81798f32f5ed2e5288198490b2aa26c5cea32cdec7bb3819720364383183bbdcffc6553371ceb87d2f8fa040cbcdb443a1b1b1485486ec0a2f0d768ec726254452ebe9cc4d8d0e850e3f35e550cf9998cd28f310bc485608f10c2892c466080031370107aa88796b7366f89da5ead1f24ebb887e19e1a46fdc8fc8e20f7b7f3de551ae75da312edf7ca1a918c4be45772bc3f1f58d96710c511e8abf419b555e36440cf565e3a0b597ca8f720d368dd2ecc8efe361ef9cced4b81901804d5d7f5c662661a4a2a0c08e6d1c79a425c1c7842b808fd22ebd794687f7852d1447d4878401b4e06d90a7d21a6913fb6b76f9abbeb62e72d52592e5ce86d8d1e2271eea5f6adde13f3688f3d2cc6e5b16db26be282fbd80627255041049e2de946df606d46df7f72ab2fa27b7f469828262fcac0ade4d95bc8fc2d53c9a4184e438641ee03254f1bc9898ab2ff6870160feb5a5d8770381d500254b86e1463a5d0fe7a14060f36f53ec3542490a1cb47c33affa4b2dae4686f13078f5814a2c2f746bf6068185bba15bf646adf6b31453adb6cc73e425ed355374d98171ca69b7ad2e61c2539a1d26dee092b2eeb3952658bc3cfa3b04e3060e6d2ecdff8dfbe0f5d31719811210c55ea605cfe8b8ea2693b2dd0a268792504a705ec586613f6721096ce08b1743bb55c5850751b2e0aada40f83f674f2a18cebc696ad8c44449be63c2e5c139b18df60ed3b40747a7a63c92420971d0706c9fb67a4f6c42e669d991bb4b480a9a109c0e2d7879b7eccfe46e90c3bbcff549935db915d516853b2c1e282ce1ac2aecfe412eb4213e231a6be9ac1e0a64867f99900fd5790392f06ac10886d62b4a761d40cf186597eef556139005f51b3622b2bf2842295146d2fe7ad1c7b9ebd6770a72b0050f19a5ad5c72c3ec0eb5af194f15926e7e13c0488997dde16dad263df03d7d51896635aac9f751f27a5559ee0cb2cea513e5c2d0b6661b90a885c837001b23812c0c6395dfbd2bccecd2a0f6c53d66854b6a305314a0e6de37d05d1ace7490e04a3d0d9a7441bf27b0ba403fb997c0c4be9baee674c77107fed52317659abe217fa5d82da5fad405fd933d036a6ef2a07888bf2576414d6341774b7239a834fd0dc33dd16c34e1bba086453165eb76f7e08a5b75f764d0f10ba391269dc4170df8e9fd487b6ea24ecb4737683bbf3583cbbd2b0a4b2f3a5e5b74b29124deff024a13ce46fb2a45c6e30aa5b9be30a5bdacf8041a9125b1dfb11e85e5bd0785558d9f51fef0820e2defe275ec51c2d8fa1044179fc33abbc84f4438778a47877c8f41eb98c81f239e3641017b32724ac47ea2bcff17be9287d1901896f46ed4243143a767fd91b2772b320d1b854a18b0c8b98a3cd9c796692a0f7772af96a619fa4bf4f02a11288ecb20b039ffa2d786cd16ebd16cd4ec0aa50518fab12d0e58f6f6bc4088541dba4dae1fd443223ef3dad72dec34e8c190c695042411291a9f7ef2def546fc955c5b0692f531458b5af226a034aa025899671268d3305c6df20b4cf85f40d38f27fc4fcc4bc7dfd7fe378deb4bc3ae35c4ce60ce0d75b6a60425a82f8520ff9cfade4d926f363eec912d8892dfdadb4f62ae12fe8ac38eebb3c93523d91e5a1d3e0bb342abb5bc17486fcab947db332b2a9bc201ea220f6d880ea5d0463b136c697287409dbf2f076e95417583763e39d45ce8e5b5c311c244eb93664b824bc965380275267883870917c35d899febb4121464bdfc73145cdd55c15439506f7bee52c5c00a85aea68d6b9a20f89f3cfb7c95737259a4d90b5f029898b5b306ab02814a6859632dd840badabb70d005714bdeddbed6f4afb1281f859c5f2009b94c1afd7e152fd4cf8b9b8efdc0e9b04a7eb1719c989f9290cb50a54a18a22bf63898500767439e65946da9ec5594192aae985a8c4ddc4bf20a8cdb03aa50f98e61dd1fd487ec908a3067bce0b38b0bb3818a7cc9acbeecdeb4815652dc9acea3b244bd926c584b3e02a9b91957246dc12af7f40f199881d29c8badcfd31905ab2031cf0ce44977379c17176c33b8d6076d9ccef799f1d8f40f97994f66bcc4ed1d49b7360ed134caf402ec785b02571ee879beb865ce73e5d36ef6b362e571df75f5d3179da6f8766e89462ae05a1473deff03115121ed2de4a475302103c26ee5fb2d7cce7b933f10e3794aca01d3ae831945f9de2ec7282984d6f72906e4f72d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
