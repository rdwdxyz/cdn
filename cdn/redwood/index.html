<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5821c1ce75ca36b866fd10e799615b7c48e5942ceabfe9c8c05e975ca6215d54245cdffe6b0d9425954facce5cd663292032bed642e787ef6fdda99130f63713022629979e6707fc067df443151abf3f11b114c1ec273e4dee3e9a818343f5d2214cf450906d0b37463ebbebea86d2694b33fa39c8b3b80d80f420a46aa5fabf94f9f6b3fbefe0a4b01719e5ba7c77212d478fa893fab0247f5e59154fd7923a02123e4f90c16407d76227de6f9e9e58ea9f4179d22be09a5730ad3099a961aa347eb8177b415261136a7b35b718ae0e615f0572f06f58ea736e038b3110af10133b7b90716113f6d3a6499f25ebbf3749cb65b434ed0a8ed5db775fe22df49412bd1527d7bf42586e4c6491ec2f7c6ad79638c6f5a774882033b58098a279cdac6bc5dec422bd9b2eca054b1f17d19f88d861df60e2cb27478c4c0948c1e87b8a383af813ef3d45f08bb1fd831e38cf522268c9d5ea524d07b0857312c9c3d4e6c2f98e92142489890075972d6abc463d8780a76e6854f493b21c974266b6245a918f4018c6eca20d2d53393a06d14696e9f7e488f294517dd791c653bac40f80fc44255abc3d5b2abe9c59a6125d3f1fdc057f1f55590814a843334f79f3e6d7609b46b96ba514f271c794094b5baac6e6c47a2a8819925deed0bb12eba192913e03a8ee21b8978665196f652b1f168722ada6e5d840cfde558d3301962a7045406629b35d8044278fa4231af1750c10b58618b0780b96ec916bea72ef6898ba5b1c4c511b67704a07467fdd018497e47dfb51d064dd013bcf3217110a9569aa8bc8d694c5c01525c05669adfaae25133bcc617f167ca16cdfcdd2e6ad15c0b45f133dc0ff3459f2f3f24932ef4224d1e35d15d8da26e42975bf874fe31f3b2b680c028fc7eeadba00849bda220618f5fdb8928badfb92fb5453bb760fa3ae84991d7fce3cbf41b9b1a68dfabae4939b2c10e6d9b8f07fda16b8a73a559cb69c33b983231069004a3487bc737aa81b47f5b56800b8c333a142b03e33b936a58af5fc4ad92d3ddedbdb633a1f1970ca3a23676437834453f4ba43662c5aa3895b18ffd63e04cff92908a45cefc832bf39f2e4ce1fe0ebf9eebab0f6c753c3d35ec88bce0a9966f01e5bae8970d7a59bcaa0468471523d14fc0442e900552344fc05cca3a5163ba250612deb38aa57810eb0c1b2e4f74ddab6ec42063739aae274fbc80ba48506eb0e1d95ae7ccec3ba1d70a8bd5d018277205404b298e3e97391bfa36022bfa2c8d39baf37ff292a3fe990fe4d30c6dfaeac1220530ae4ab1225349a22cc24eb5574b0d93e20fe56092ede4efee415e246941f23ae8b68a6879ba3692bca12b48f25c8585a3289201a8330643cda99e0d6d656f1250e2493eef1621f4d7020f824ead22d420777d0cd63662964c2c90dec3af1cb2169daa4ee61a4eec975acf7216e2f7a6478bdaca3b364735f833f82d23b8f89b7f24f90f6c30200b76e2d9aa8afbee16a5a1c33528f40d4ad3c86c1c2db947663dfd420410b19ab47a8098680d33d3ed0e9f09570b9685ebab35676d5f295ef5ad1e8070ae7b37baadfb1c920d101b2de01dcdc051e9693954ac07476b2c0d19f4f4ea4428c17319d7526dbe8e907701c649bc526e95e1a43f26d5434681066ea14f748f0a911da43b1e6728cba4e4c6ab401c5436d00505197be7eb81759d727335de8f7bb1c63a07a909ac4be5dc5a5739517a4d67cd7058e98f9cc105d623b9bfb3b1c42c77792fd906944491fc1650daf02cb829bd4df180137432f910ff1f719aa0cf19c89d0ed36f25bd5ec8c36edb72de2f870c5245ffece345ad30de942733866e63180a1c57fa00614be41f0e16eaee76090c7246e060faf03bafe28c7e53a848cf9eeb38c1b2b95403834c112f9cbf160bae9c35f947f5f96859c61b693849869f517e56bd39efef2510dc8ce469214304d93be68fa160f70d476dde1c8efb9f72be8c342bf8bf3d4019030e86df162d0e9230a78b865bdef841d33f149f04edcab87aafc0cf8c88d8e01bc56f1966011ba72c5bf79d512f89b15f7a2fec470590ca45e26014dbd5dc079e4de81b963e08dfc109f4ce83e0aa77687c9358dd741280b680d8a67a0b26777026106062c1fb1e39114839455bd0563d393b2c773bd1682b103725a516d0a6530896d0bb5dba1148433a748139d6b591cb89ccd7f1346c07f8db150db3c5d0a66126228e974d8e7d4878798347e93f6b31b6f7ad63fa4a0fe9b3aabf85a95bec5b2ee82b991d6e6bc1cea5a3c4040191566b40b170e107cc93d003ca134560b474c2aa73f93bd9bf751b620569eb187579af46687b81cc55334fbe9d5df065ea3e4a8b56481887d8006908f08916dee24376e51be31926b2346f0eb8c0318cd7da516cd683e3e66a43b525ffbb76dc15756bd476124382ae6edaca439f3f27d449f3cdd7a9ebecc812668f04c52e14d9ea239b741e7fb606f05ecacec7e7763cfcfc7396eb417ba3f54f5c0ed3bc977180d3376ed661a5b63d901348e21cbbc8448f0dd7f9e6f5ccb5bd727237b97047cb2b2333420a4686207b6e75d82802e8e6dda8090fb87e11c09eafcb342e7bc40d7e4fb0e8fc87eec551eba19ea7a9c6323ed6663162bf8b36b4446bb2f4159dfb3d4f5a2f9563fdf9d944a2ccf0cf4e6ef7864519018550fe19fe6caf5791acfd5bfcb32148f16be6d0b0d533055e95e9198459fdbc1e1ec5b999d8cc6096cf39ac5c03531b11a230795b54806b436c84ecaa4a838d5f4533e9e776932cdac1e7c6634d7d2ead944b1764ab762cefaca7a66dfcf5b37ce4bab1542bea5e24df40dba0de054e551882d9565968ecde9b5c5f4dc3d77ee0eab314df303646a006f4918d14bc024285846fb030b520328dd48f06279c63602f62db7b0a47ece1d21d4466366d253208ea79807bae69949106894abdae07ffb0efb2eceb59e39a9e21a7f318d5e493a8f1ae719b57f9c7bf399019129b45fbfd11ace59354a3c76c84f366b0b487e3253fb98254a589ce283e5a2c7b450de21ce154ee0276478e16d41b3a39942df895c65c794943124471e92b988b7aa07c5edf93d1034ff0fe39a96d3805874fc1184f5c1017a0033f1eee02ac22520c22e8f5c54bc296039ec966a99bd68caf8ad6c105bd200101bcfc340c1508dfec6dbbef71aeadb3715c0ad8c1b7632fed5521774d3c83b2e4443a4d0482d669c39c32bb195f2c010a9c05a09eaf73ed382c43e1250f1c76591a30e523156cde3d5c2bd872769078ab6ab310d35b93288bae2366e9e48df319e915f5acad14742cc8a102c32db5e4d04579f7acb4ea43554077d3e780fd902adfd08c5defa7e95dc5acc4d9d98488e19d1811587960f02abb3a1b3b80b85102144671793df671837794ceae658b6f830a3caa7c7e00054073333ca32da2b4fbad4bc6dda132d65a589c6c3643617fff28da758232b043a6847039f61de5b84fd6393213415fb94d53daba3b64684b0ca290813eaca8ccb9c284f173d635a212b07e2d0e8ed00409b85f818ef0cf732d14dc5db20a9de6d9efb589a12862b4f104ab7b2819611ee43fd1bb9ddaf6529e702ac3bd01f3a268e6e9090d9d65f3a4c60bb5b4893ce1a14bbc255d984be0f413846124614ba4f00562f047b12a8a5d0348e34565ee1297ec79d6958e382771c94219f2fd17adb10c4c827a7fd5c8c45e365902db6eda088f309540d6982c38f41932d7ca5a7b348fa300e3909de97451362cbb54756b01cfea95346f37dbbb88b40b068750a28c6962d58bbc8b6405b38e45211dd1cb26d54efa499941aeb9d7109bac98b3154a8a1192bbe60ec324e3c69d792465ffb7bbe2e8704b1681aa2b5893c2910c8a0f241d8a7e7b3899bbffcf7a53bf66217b647781e929e87675a14c1cda0b6281792ff8d7a2540d9a2603501fc7b228d84a5f5eb958c5cb9d6e7709ede3b6beede43df38c013ced0de2918a3b7a807bae3dc78297294eef74b89233bf3b3bf60f1e67aa1c2e41482921a758c2acecfab278416fd2ae4fda7100674e45cb8ab92a7a23fbcd7579e40bbc86c7eec79d7c17ab9c15f7874de05fdaa94083aeac80d73903568c278e1019cd7d2fed393ce09a3744f16458d1d6c8278572afed46792ba9d63d8f28d9602379d82c8b5a5114a78251318fe0c247d9c9ae9bc2889dd2b235de92b27dfcc59d5d46eb8d7179e65cd765aae0fe90f383a57829ef03a44147196bc51b0e8571f4b4b052b5ff646d9f3fe09e472d37c81cc475e27625d38bd27bc3474df87d6cb4fda6d58bb4c418ede1cee19e268033fb9cfbec24a1afcc45ad3bcf404ab1cc4b8065f1fb658afa7ac16ff482f5ecdef97adbc3c0a43924fe42390b826d29486e319599f319160cce65fbc5c36adbe41c05424a67257d4f5397f0477f0f57d3f67e2def145e6247dace75af5898420b6a3712e967a06c706512487eca7c011352ac9730e8b73c8d5f08b223583e8a248ff7198924a1af8781686df0a47ff825832d83ab446a600769b5d8a8897902b6f5d42a279886ce4c6ae3f25dfad660f7d949146dc79cf575128dec92d68c39d338779e5e53e3b4a96494f583831c91711650d3f6b2d151ef2d9d49abf1ab8c7c5893ea29784a62b8f4a18745185a21572473797d901bbadcd30225924d60e08f3ef42220df0fb14b09d2faab27048f776aa08378ecf5fef0e151d51193673c3142f75ef79d8a7c2e07503ef24d906bec72b42e9a1ec036cfaeb53d6825ee71f162b577209f9fff3a7a501c8b2047c46da4f096ec8c269ce66628ad39e3a6d3c15687726c18f9a6c2388717a7380d52efb61cdcaca97c40395cd56f54dd50aa362de10855229b7d4b9ac12191173962ff7e65bee0b40ce016f81450ec59d9e2c4c9257601e14e5407aaf7122d451b522ac42fd6d0a4abbe272c4a3e2d7d9d84447c4207a1570a6267ec0332a95f9bd70f319e6985316e854856f707f2afb7375546efe4d14da9642a2cbc03823bc2436507f4b259e1e309f84713f1c15861b2a9ae7c945211aaf346a77cd920b50697dd7390c47735b260e25958974bdfebea4d62347d6faff496c41e2c2d4596760fa7455668f488135d4c235a71ea3be250b3ec0dd049fe55ecdc0d67accaecb624e8b6931036a453552214552b3970c3bb40fb95e5c136c8ad0a85bd092ed3419c04acd6bedba2a7aaddff39c5f253769974c5aa0c1e90962f6c2b7f391b848c22148dcb279b4ea74cd22128e809022a5b04699e63f069f3bdf41578862936e512482bf62d77fd24d7107d14ffb9ae9b89f9f0e726991dc3d1c5c877421e5c4b93805f12c550ee6c91ba568b285a5b22ebddc387515e559b4dc233ba92c1dbbea39aaaa70a3c3f221ae22bb0ea26f5a9a524edb17f34ab6a590247ffb6e252a0c6df331350b38cb08a9dffe193bfb66b043f78ad99d5d359c7ba7e4440422c1e7c65d49b83159aa128fe8b71d0c87d2d08ab2aafb6c1d0784fa9f3a4115a79d1aaf4ce5a16834a102a34f8d231d781ca673f5be8cf6999ab3d857ccf49f65c4e3fef3747d4f4956ef2fde23cd0f3b64e9245b5e0100cbf9f4223a2a6aae39865591330a03d9072110339b9c284412e667c095fce3d93aa5ae7591dd6eec4c9e93b8633930b94e20a37b29c36dee5dc19d8e8d13bd8dd66cecf32c27fc1f3b5bf6367c33eba927e7b12b4e73cd88ac518fbb865c5913be6a59583e3f55868b14ba12bf735881cb9654bb560afc7044817f0998d728828458f023f8fef976aad8cef4f8456f7364859667346b8c6970c5ade81105d4e1dacc2874ab3da0835db29ff32cac50b00bc0588238da830512b3ee8a7c905cc278d807e6d22726453561e0313cde37c455464c03be67cc81ddd2839a88ee82f63649aee93bac38725eda6282f9e17934ceb73d3f681146a566ed081f971b72e7005d5a1e22c702a8c94470a01953605ead597a7b93681f772535fd4c0d4dcda9d0c7ea713215cc5d859a8f229448edbaf012dc057ecc31c0791136ddc99f3cb0f15ff4c6acae5c7b63a3e7a218055102bd053a85864ad7599702b3ae2b26877a8d6bce57ce3281ea8354750390ddbde7656d05e69293c5e492fc5ba74ec3bedd119fd69e4da629985a27efe7152fa90aa4fd0dc652ad509a2a930dac2243388e84b78ca754392552ae3035a4ace8bc7ddd0f677d6669e60f2381b9298508bf7a16a8fccd5fa15ce13f6e03636d9779b5a412276595b46eeaa44a7bd1aa48e833b80d1a4450be2f99d1ba687c2331d4b503471a6358b88c4df01b29d6817f8b476cf86aaff5a8568417a1b8f4f80ebf4d9ed530976603754dacd5182d64b6b37d5dc2e98b85524a317c46d0a46b9d063d3dfe302b5d9fab66f85f05896e3a0222559416a4e1316e8e24e3a0ba60712b88073bc12c9903f5fe935001a4ddcf437e35888c528a609e7f6a40387f66b8f8b514874af3634c3967169c43308f594f55318de987861b4b76ae7f8dcb33771aeef4ff4bf684417b256d6dda6ef8cbfd331952ae723949e3bec2278ad14021c9f598b40a94db6b272c79bbdcc10d39984dbc52fdf6909b664a29db552b84d499067f2453ad4ceef350a8e2bfac09dbefb0830bb03cb45337b262fdfd701f6f5ed90622eb65cf09e48835d9b1a94224b7a4f090fb5d93b1cf86a5fc8b66473c672b3dd0eeaf8b4cff447a023e2e802dfb0062ec60755083a35c9d274cb94442a048794966a4843bb8dff17bf93d33f921cfe18bf4eac057d330dd86b8534c2f71763e10d07129a02eceb1c43a5191c912045d99f26b47f428aa50f56d3be56bd7f4e11dc380c16b16193e7c4236d81b31673b40fa36f3ea8bb4fdecc512bd80b991e58d5f1a28409c05832a4b63c558f006e8efe0249c5c755969cc23b14a7f691990f69539ddab25d8033361712c54e915f3893c081b4a0438c210eea9539baa22accb8f36daab0e0d80d79f5504ef69625bb85129d66fb7b58f4b338d0eec2b7f5787ddf4e3e09582575fb470dfd93034bd8247ac7d125250c3f381a9fa479195859aaf82e8b95ab1c441987d353397aec294685e5bd5237d03e76fe3e717ff3f81e8b4c8f5ae72646068579785d84c09001502350ea4b14d95fcb022d477ece983c39596d44e9bf3390d0bef2d827a8cba42f3adb648c74ca32ebca0975238e27d9fba8b189112deeeea48409704e48323be172afcdc24b532b7d1bcc9d215ad65f6fec0377789c2dfff59f2c089f8a72ce26a75efe310bfee08975f49d50d7f511d0070fe86e19e8820106baf2af590858ff0ef68768ad76aea2dd36eefd8cfd28f18d918aa1fa68462eca70330807adbd3755739bea018abeb80f955e13a9e1009ed933343f6d4f02a964da6091c79e4c20d0d5edd25fee61c396e192afceb123b7bf95cc71423d165691189fe89c038f43074437e83dc9e41a70b8464518e13e34dcde4acdf16ddaee6083d0c94a19a6af2e47e23fca91ce670db0d7d54b0db487739606c55e331e1c4ea237fa21537bf7f2a14f5238cb920f86747bd382112f1d026b3bfc5209c8b1b3dbe43f13c719922d046cbc4de7887228da01ce7bceaa1bb5f45b1079ee0886863d141ae5ac1b5b01f3acb08a71a7aaa569181f543d19e40f510e1897b94bf510d28b0d1872a1b46c0e240d602b8eb021a9c88b12ea41a98de0ca5812dbb75119591e74e56c9d519d57f67193f8bab6b46c1f941442bce1a6b69d4908837362bd1b725aa8ff19fe89343ed7a770938881a5839051a824f5cf0577974d99dd6bc23b12cd961d5b5e1042fe3160cf2540c0cc1a1c76cef527598a8c6d065b636ad5d2091364f67a3b06f6ecb3ccb6e99dbc0517aaa1413c87f4f9631f22af47407b6d8743dff1d8fd7f7dc6b327a24536baa858da66891560a8a99b41f81f94fa9dbe6a8181d61e08ecaa6068c63c4bc07ea64c9e1cd9adedb214d92b32e5d42eedfb288fbb0e8c712161c9253b89a83423b71b0fa4e6b280172757d381e5356f957e6721ce9c1c7f328b98bfdbc2eee9c6a4dd263204af099c683b3713367cf3967302a750989ed0ff1c3f3e49dfa589865f2bc48e723ed00bb7236b8311b79e1f6f61550a4e6d08f067fa451d3afecff4966a62193483d877978abfd96ae02430fc927b9d0cede427129d76f7fdf5a086cc08d4d17c1a353407ac6faed2eef97f3475f5e63b8154f7f1321cf46ed90a23336eb03ee437049d5e7e578684d3bdfcef9abbdb3ad4e74ac679d5f8fd2fe42f9c21ce7ddb8681d0f2250467d23ec14ea527c86f133c869100ffefb39b66c8365b21c0b67b5dad002252e7daf5a3efb3ac4a7725640f643da9b4fdb2ed354ee225619d249d52287f1ed8248942ce74b752057ba2ba648e59e664abdb4fe3a2745bde52e1262ef3859e1f4c2fa182c9ee709cc4155f35c1cb528d5176c3ddb9521123120f58f962c98a8b134144f997bc5a48a3f59d0a6d945e1fd0aa2b759b2ce9c58c65ac6a96bfffe5d3df690b90d518439e15c3bb24c341e1a1153dcbc6e21f9f5880be1e67c8edb2b1bb4925df26dac7b48b9251448d94cb3f6a4de66242e134af508716772ac7c8be589be1d8cf52703bb5711cd9d37e3b514a23b3abf474827162dfc2c1cda0acd710b25285a0a1befe3461c3392ee06aae3f3058795412fa27d77111ecb327a160f541d43d23e3ea6db86f264b0a385297a38f3114ac60eed415c1fcfe13e71c8d2ea032553e09f7abc5072b4f7685c290e4e36842f2b66fdbf6d0475b0158f24f01ea84abf8ec5291c5e9dbf350017e86832a77cf5df1e4c64352b07a233821cfde7bffbd3f4da5ed541efed53d51645918298f057e1664405bbc1b8dbb1c23ea132206eebd00b501aa8baf6a88e7188071fec26706fe83f1cf0a0cb0774312e39d728a0456e29c1edae0dd6e77ba93a18090bbba30643ecb99e02e15000810095007110da9fa04d0376e0dbe67b2a05615c2719924b3e37b00d740e6550cc6def9db84d7ef80ab7d873b87a8ba9c445577df52ff9f0b6e762d2016b844868131234e31ffbea42c3516afc0ebb69051cd8b4e4a5d30550dd4fb43bc7c111acf15144fa94d2baf3bddfd7e7276aea72b02ea21a458b4fac4198e774ff4fee2a17c6ddaa166f471929aa33abd45e430ebb9ea2ab35bba0e57ec6dc529c1b3c0ece891d6e8c6098347ce39c2bdc1460a47301f93b83063545be24beb8db7ece3b503e83ca8941eb91d29a82a940aad44c986a01f4e37587f25f2f2fb8b602eae2d5ca937de0d128b560d04c96a336b7a7f70ef19a0e8899d6afd04f13ac6608a6874a1b945a69b767d31fd7ee9d3ee0e18a9c4118a2bf8bbddb87ff5d0daa0c4da3b92fd5d88f50e06ff574e76e944fc6f807641959683a58173e0553036a1fed2a4917309e9bbdca869e184dba5c2a95d0c802bb5ff3ed73b4678159a77c1472399c640d10a278c8e61aacdab5848e3424241f3ffba4a6f7a2b577505eee64cc87c38c8513450d7b3577f3bd64be3d69e9046fae9d7f21b60b31769f59696d9ca621ed3366bbaa75f0f07561ff6a7183db6740262a97f36c88ed0d06d9eba8823ad887858ffea99a55db69bbccf458b554cf1c607494fbe68d55762259f017fed58b4c6f9ffd28ca3792227d2e7e358ae7106f3af77ee94c94eb4b695c6c0622d3add8189343bfbf89c1e9b192203bf09ab2e6cf375dff7997db8579dfcdaba2a93635161706cb5261298c8cc41c5ec64e7007bc08d06d49b07c0e35116e300d294eed24f8dd39b8c8e70f265741c74c581f2dc5fa76b4c00336647754b256b2a72a490b5be04594d476b32404591b19b57f19d2456ce418e5ab28a575a05c471004e93c4b301e8b47a7e2abb428439b4ecff53adb19b8a2d94d91a22dc4dd15f23325096b8432f04099c8ccfe4ddb488c6782ca68b18bd4e7e391d7e443a1a67c8de88d25b681ea7b2d4a928a8a4a87f967519c2773a7d74d2f35e8146b1bb2bd041392f9634fb4930512dce24a7e91c0958bbba97c196f984782648ad9f8bb9d7dbd7a9e8af95d6ee8e941a17e90a7c733e7fa4478279e49b27490d3263a54e8ee8cae68f22ff37289ef8fb4b7e890049089c0be72ffcf58c9739a9b52e6821e33ea34917c6b3a1d3b909e35c403f0f024264b4320698f7337ffcd6d29bb79086c5fc408186e0219b5c0d0c49b4afe564950e52221c63444054794163acf00d96970ee2f82a5fd1f430e6f9e328beac6f7848543985e56d6ff8a4318f7d825688cf6625ca687a6b36e5e9d567eaac2163b7ea6b25a93d8640241dcecdc8f0d03a2136e0edebaac2da55654448ed7008289fc22cf01a4d795e2a880e03b9a7d04101970ab80b2e69dbc3ce9751354962bd86a8214a5778bed0a7684f9ea85240049e45ae08dc8974119d460cd233773308888ea056790f34397c159a1056d0e666991dfa9f801d2f1ee0ff40ccc96ae2c15d14ff1adc2adcbf71802ba1f6f34003e77610a6f4e497be17b9a382444a477f0224470ac47f7a5daaf379ce2f7f596e04d9cf533c2751c63a40bed3d2b28aa2dfde3059380074db86429c23886b0ec45e63e07a9b3275d05df21ef2f083b65dd9d09b20f196993cc61282ab86c3add49bac43ecfb88713d1e1b9671fcfde2d881945d52ba2f5bd4d79f3d70f3ee1e8809f8b9b91ae1f6279951bd6e92de041191c95a2ce5a7b21e9c92ed58b8cf869130ba6016c9136389ee615b0fdb423d36c0a00f669d3618cc10b89ce7c8e50be08b13bd304552faa6526977827b779ab6c8298d5a6bb94c073b287fd42940df7a0929a695a1ac8594fc83ddfd027bf0e05facc051c64aa0c2c2f655ad586a10730e40acb6e10def963da7b2b8b5aaab9949cb1bb54b7b9fc88bb7606c5dfbadc9c5780d8880f15238619a9685a9107e6956701645a8fedf3416b9db185142c990266893e9d209d4575c5c294d8e53ae2e0775ac9dedf3bd1df6e890465828dcab4b3954a4aa1d492aee8c2aa09d63134d06f408b7c448bf86f3f96dcb08ec3e6e4ca238fce62f67ee14668e58e3d967257a0fdf1dde5d7acd565f46e824187d3784931343917e676c3db8cf9faaf20dd6aa1c4fa922dd8efa720fb6a0281dc0d047336377693798c6139b8100f40dc0e94267ef0f2bbde9a3d9fc3af2855ba12de584807526705f9953359c62e364c5e2f7f59db945d635f7c500eb449c809936075aa8404a33720dd614ce01476290e67314d19676567f1fb3b281d9989cff9c1062542901226cf15a12397f08806dac34a6d58ce3cff55d4d42535c373f2cfb88ea6ba807f844bd6c57fb0a16d745f92c439010b59cace851e3797bfb1586d8906a537f304ea24bfe48e6a4d88f8aa7d5d3c71239f1a36d5c6702d8be2584bdc6cecb507980046803c2829576d2c3ac7d3845b80e022d63c1f87e4c93d1e716d63b7e0e83e2a6ae15dc6356e29f1d9642ef0bd857f1c8430b9086156a3db08672ae007c207c1520ac252f0018b15733cd8bdc0c125f7b2b3a9990a6a5d21cc5ef3da93bfe529e1382477769625bec7906f7e08b07dc856a90a122197526e4af1d145ff4bfabfaa96cde7ad75de6f1b90624e378f8eaefba68e20db0a30ff9a7600409b5ce6e23ea0db43fdfd6a1b2aa3e44eb90a5fcc170148a61bb4057cf61b89f2f3afbf6960d3c3a8ad8550c131c31b400fecd695bf05283ee54ffc258960bce6a0c9ba348dfe03bfbfc8b4a78cc1d0797d22db900d9a59642f7b85ade40c07f2e71edd04ac9696c11153a5bb228dd1649f10cafcaf2d764b5e34b1f3294476c66c5099c4867baf47aa47e3684a633d970ce7d4a994865431f24696f6dc93219f1d52407f27be8e4d8cda43e838d609a601eb04a6debcc83aca4efbedeebb9fe51cb8889c8b360bac7eaa51a97f5ceeada2fd9a437d9bbd711f09aa54f419eead96811c19ed19beb9777617714e36567c317b55093e49eb53a99b6229e38022a125389758ae881e1a51bb39f68082a9adf6879fef24a1e52d86a0d3e465c267d50b0e0d98561092ccecf9f475a7bdf135e4fd44c1b7a79a0a28c20c73e7126c3b8753a816067c7c2825efe6316d7323ea1d97c7778a0eda60b3343e6eccd1b1bade5e64ecb91aa0e3c552b3ad09ee7750058ce6b40774fadea94643884fe6773e914237475029a81f51004ebee0dd37e2b3ba0a6ba23ac8839b2a643be0c2de1a7aa3a4cc82fde080aa692b61ff20063918c9902174350ad9533f7ed06a2cbbf30518d9c96ad5bc4bd0ac43dd0b53856a75638c60f04ac996f484fe9a8dee8846073bb4aa725f5ac643160174868a7a214856843d362f69ae29906a2d37028b940510c5ab3fc6361a092081de4274ee247598c720c3f0a8ad805a9b8bc671abc53b6c2b4ae26892144e366c20072af60084e9cead86b6ab70a629ce986fa15162ecc26f532f4ece774b4bfa8a8808b655d6e4bbaae62a87c0f5b7c208d162a57e825694719884bae69d514fe5122c1b36db06566bbfcf40c17646164daa5f1082eb9d81bec7c0c544b820957fa069159638f93e21ff1ad5f6501153198c507e4623e1ae4a7b53641be9bb3cd8ab6db6e6fb54aaf83cab871138ee8b0c26f11f865fd27816ec0e93ef4350d86f93d3301665a5a047859f00cfe7f2be4b9fcc60329e10cd63cdcd3a79a478577f5473672041c365a0899948f7371c67df4b1cf084e319f3b1d90865fe5f9116b1057b1b7c3cff74929d5dd6550757e357ec2951a7418dd363775f9289d71a81e0cf51f0a24fef552821ca2fa3fe857a4496a03656cfdd81bef8eda224d0913263f5722b2d1b3721fa9a54d2451745e85bd4fbfa6251916ead3d866034a70be63e2bb0bf398c50e7520e1a4786c6f4462ad2c55d8aa3de80d5f025119aea3e0f8098975a5b0c0c93c808b791afccc9107f6b7c82de243e1493b17a55afb9c9f1d35e18f8a3d641d503622ce280c60d5a1cd2511f200894310ea5433266ab330c57ce1d738257f91963ad8b933b23e31ff5c00dde53b37a3220e512d46f5c60ceda1800d10cc3ead15dde3b0622c8a18c84d98f84bb62f63035e3d1e7b3e2bfeb05f604f604ae5d9700d96ad677a9d542c3241d13594f5964f7a5870f941549ec4d130a74fd60b0818221ad837eb7835d32e59de220af936c16c69cca74e68e5461278b15b8f2559b9775a5b067697654cd0ebdc1f7a3fd08e2ada062095c2669ef7f610c984eb2a431df6c7c39846e8c36e88388c8c69e76313fe020fc210a45346578c9409087b88480ddc931713323a5b1a6ee7e6d909e55d8e810bb9e1e6c1ffb241f226d4023beebbf43f25456c69e4a549bc81e3ab26ac53790438eb275b2137c6261e330e2ef696293e4c3cfb15ca0a82653eb0a5de42ade2742aecf553bec1887ff14f72cc6711593d7a6c8e298fdc96bd901652f478e2378dbec2afee83d34649cd4e65fc2a6445fbf6d99ad98168dde05e4d2a59a87a16d8f5e21b9a38bf7dfae482fee3a90c4028c25b2d6f7c44eb404df1d7a30c5c56ab906dc4dbda79500888c8d69338b198eea072e917fe9a1c5075be919ff78d2384f4fec99d2dbb7befe3643675ce15fbe6b1b1017071a1d48c98083bc102211e2cf9ec17e74cd602a215b06096feb120cea31c959230c404964c012ea986d589be26568ca5cb6298fa3e02a61497aeb236992e5644d680ae5d607f2dab9206dc2723adaec735a102f7739f6b6a4c784af9aea522a6b9ab4929705f7e6dfd5085a50ade979bb1d3f61f408ea87959003db95da77d0e5cebb663eac9a183e6420e329195af78290c3550d1863ec1d048d0d7efde8cd54955ad10c1b6fc85bc121db2f2f0483207f336da33d3b720e536e36aedff31031efd3d01edfef99141b32578fbf1df9c794ab79daf260f66dbcbbd7d4b14a1878cd9dd9ccc0339c29019e4de9fb87a9f7f63506e3a1b9f06f391d349f319d76cfb7b00af7ba1fd0dd3a98fdd845abdc4fdcc4bcf929c2d0f7e51c99ba06456bab1e99d04a33d675d8f15a2b17bc68701ff8657ed936e8ae014453afb6332054bf6ab6476eb648ed306e65d8932f52a8d6b70d09109b220b816b998c9314ac6c7279f59ecc731de84fa2c36353411c1e9bcb5fdfa25dbb241f12530a1ad4617efc2c01d502db4510f3f1659cc4c0e9f010d82b606abe0aa03ace69aa1fa78a83e84088a294504661db1591cf0c8b427b3fad0c66d9004ae532fa567b4589c451cdc79a15daac743c9eca98326b1783241b3ba242e4fa200fd34fd4d15f7424241f8d9f1e603a68378011597f899efb223ed54df9b2cfd80a57d477bd43dd86303ed04c3e7c7bed52b5cc50876790c056f26f3ec3c3203a86a574183a0748a3758c2813cc5b556b361dcafcecdfa0c983565776cd9aab2da0ddf8875312cd86d537656abf54b607f637de43b7ff0205fe2602d399f2a240e857931ee1124334df15e135a6be931cb7e3be0577f8b997f120db7f8204c52133a500e807f3e3ddd88661505d1c451ea6641176ffc0689352e1c6ffe2f2ef414c4638faef4b4f8ff727187df854786958e042814f726397a27571198548d177577274d5fb3ca9d24ba4368cde31ee21576c499b00833e16cb929ac727d42749be2b94ecc2dc0530a4cf50e4e5f7d78f3b7fd83f14dc45d0f1296e7c1ef12dde903cb6c6d28b430d279dd5d35c186c5910171f031bf8393fbb968645a137f4eef0b37353f7d31db3fb95c4abcb01939b49e1ea7aa110b8863ec926853e5084cf862a196a357e4d2bcc6f59861887f6bb472f56d9939d0d5336ddaeeac3868f065920c8cc15267a63c27b5ce36d330f94387b248bbbcce46caf1adac82e7edd987adebf97e5621f21ce6065b77c8792aeef61c8ae9347aeab562070a7b632e2e962ea80db69561a8e52969b90086f5cf6f58893a63b82157d031533902935a1ce89612070975ac4c2c7e144fbc71c8cfc1a478045525edd7f8771d978de783a00ec24deab231e116ea17dff388e34a470b02e45adfab752bc049868494f21966cfa5a68a4c4f6f6bd2abb1efce027a3aa0235527aebb0eaa1a97a369c5674d69296b0ec85d3d38613bd1dfacba22aebc857b0efa0bef19e39130ba741e421ac5de4c400d722f76820786ead5b10d0eb94cf88073a5fff3d8e247730bc98a746ac7830a17346fce9bb43b865e6b3b54df7a9284385494249d03ea3e418f4210479a4f78a2192642171de7263713b7473e7ebd772a5de32382d62845d59ac4fbf07e8b729bfe3c106c7cb82b95a51cd95b927c4594176ec570990ae2acc3c64fd7192cb1b1478edf65f7c40d05a08ed50f6723e60fbee28efa7cd9ce793854d7bf335c50be23b8cea36b35203a70837caef23d4619075b1a7bb754e3e042b7226f542a4837cc3777d7381faef8eb05cc4ef6b26b904cd6b9b431cbc26d74173e0528d8f8da6e871e3a65568576c45aba273958ffdc6525a9e35bca4e9615de6b07a8cfa102c0d4804dc9b87588b93f3a0d42f8981bfac0682d9ccaab84b6bef44071c4cfc0d4c2170fdebba2af4e41ecb03ce0f129e634811fa78fbdd60d9a2ccff2362969d686560f16875a167cc1ef8aafa0322f3cf971e0d673173e4adaf5b2744d584dfc9aecd691117b4feb28362b531e6d6b2df83b19bb31350965f903d69bd5fc6b44f8f591461c9418862bd5f45ce5de3cf48ca00a55aeebf6cbf0b0b058c82aad650462cbbf0fe40aad8396e51079ad6b1cc1e22a450735c8989af2db33ba7604e23b470884bc6eb6b2cd96bc57c16cb9f2c9e5703640e2e4c7827c9aa30bfe6512028b85a3956852192e474ef2333f84480261b2afc1c0b8ebb26b25a39d0f257fa9744973fd53bc7d879dc129b92083769d7a9bcc4bc2415a6e80cefbb33eaa35aab29712f05a52ab4effda031f008ec8538a35399a4d1ad0ccb95d084ef4c7ca61ae307ac80c037c3e22af10f3b20720513efb79cbf1f8a2c1ce5d400afa4fc603517be89080458f365aae2dfb60759f32201e79fe94fca26d8120cb3022cc4ee7f3382b98c5cf1bc188197470022df496a9b196f70e0deaa1fc342ec4f9748ff5777d8460b3988d52af27aad1421edd115f25766411ec9938414bf87b0d525fe5a46ba5852a28568e3a33cc362d6f5fb26e8f05d0f46cde2bee1f5561377e8fe0d1207471d7407397d95f3f05393d4a3fbeb7b2bf10c491ba64c2ce83a6cf01152a7994e616b98328f30ef162a0fba385b04db1b614b165ac4de7283978cdb636a39bc3a20e9a1d400a5257b53240825e8199c9c34e02a56efd9354b1616fa7c82fe7abf9302ca49b7908f5fa363fa72e88a5889df26db9fb205dc6252343685513250613662886d1fe1ace7b1bf2b53553ffbf75bbf0a17d169f555e7dfe320d28d3ca940d2a38c410b5f9e01769374a5e24110b183a76619686ea7246847d69c6abe0cefe8aa55dec3e41e578f16fc8215533d26798bbbe7c1d887da071b3218e3c91226475f50d7dbc4dc2e9384da17dc93e69c2dd73fb0afbafd6cc63658c869f5461388c07d503d20ae2354eddfb4ec20506fd03fff004291f6d7bc051336c367d98e368f4140fe4bee966c4a01dc31b061f79a96991319b10934dd5868e11456b38473dc7223034be57d30f0dfd5bd4434142f94c1920f1acce94e813e0ce437f74b55b00a3bf415a95774302cb33fb5b51737262ccef1b4eea35f633a82e1a561e168552432796e229555823d5746b4938433e4112a99157fe56feb31a620aae1c20219acc86cc967ce2e6efcb3290aa6618a62c4acb4a5d8168d9fec9e87f9d8ffe2c0cf6b8ad4157704d3792e04259268dce0b76fb53cbca55f392cb5fac5d9fabe475d27fd9c9f480d027fc8b463f7410a9925a8892ac31b01dc4a49cc08a78defacafa61f6502b492b63da12ae22e6128fc5661627b9cf9dc615a4d062d77846cd501f5eccf3b8ae44cb3f67b15f8fe2040185953ecdb30824212578f86a83e53aadcbbe756682c4044fe345ff087461227be7d600734bad336f2309d39648a0922c1850c3101021f1934f6964a74c0dd2fb0efca39858f1312146c05d4288f8834f8321501ca8c2d137782d9f697d1e8786446798dac2e0cac8b3074a6d8dd63953f7cead82c3537d3458467b43f4032f7a11700b2d91078173892e90fea2a60f974513cdd187427dca0c0869c87ec33631c3b135111f2dcab13db7394321a3db2f37ef588b406873913380606c5c5b0188e9ed81738f14d1b6ec430f48b12e08f5311d4276a381f410ad430b14e03d456c8074caf17eec3573a014d17f1c57a506c1f5a4336d368220a57dbabb12932c6872fb44370052aa6e45abc5720371a1de20974cb8830301820fe40fe2a10e591130768f6c930cc6d61cc565c40e782c2f4e21b65f464af7a28a1170dd1f19fb3951500ffe2b865f6e1d7134526390c1f5f78bedf5e482d06ca0284c20d577e85eadd489f6717300e04204589049c353e98285e2b132150a13992b32e55985bac2de43acd7d2c6600241083f929b17d6966b6822fc24f1686240037677ee7b6ab3c65a2a18a9b0c951d81b470bee0266365257eb4a44e5d1183cfbe3261f1b5977a3b38f2d989786856ab211965f234ee3715630c1c424a262a8697449d10822a6eb5865258da15667fbfd0d24f8ef6d60b19bca9e3ba7943314127b2f15df0ed7857579c9196d1611ae51a796794a0aae247b57378c1a00f5c80761d07aeef8f23474bdb9d4e2e6679c79bed49a2546121e4cabafb894c9095bad9ece0378a206e2017b728df808cfd2abaae779109c4cb56f5f4ce3c9ca3bb3ca09ef2ad87367bc8776dd50df88d4af7effbd1e17a0faccbcf76a2c04076ce312d68f48654b498880972f8ac93030a27819fd98180467297c3ff92dc3604958a14abec82abf7c468787a14549929db9c11894c24a235d9c7b66f2a054b71c624506015f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
