<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00aae9da037560047545894ac2e64fa664287280c51039fab55c514562d2b229c9bd878361cb21439c7bf9c4c66d4c038984361cf02c96b9a858347c1f592964331ebc78e96a622805869b84a81600a620cd62c30289ce43735209503b567cb952ee592868a5fbb16a6f19cb64c7fa92b5b66fe644e334e0a8954b470c20a149a6766969bee654c65865b5bd50340f4f917042845582716b19858558e06f23f1a52c12b0bb37577f6d3857171a5f14d5c4627c620439d57f0230bec568322cfca1988942b1ed49d6e29ec58b254a6e93911e91d33a5743c9be4bf56e78c47878b5d0969024292f50905f5d8ac51747271f93209d63c1758b0ace75b458d46b9d2d3c6452aa538658c4a7b98727d7a5fdb6f615f921213b729d22fa3bd5f81934a46e80fea3af2ced6c04c97365ea71d74318c6fd1c79c661d9d768018f5b74b47a0eadeb0f709beb3dd43cdc3e17ff99395b510cc7db5ed5cc9366dbc079bd2bc316181ae45c279e8a291e82c3003bb9f758e2335b854f637cd55b65c9381f64409e2c767e4419e43159436e3d3ba4ea6b802ea75834b995100c66a2e369bcfb1883a713ff6ba12fb0dfbba81e4acd9d1728235271add03a29527c62298f0b373512d1a9e3c6f70a9c3bc8033fb29641054ce684978ba8609835fe448e24ab59f20485f88dea917bcf7862c21a05ad04cadb13323aece437e1c02ac4bcdd109b82d6b2e1ee7b97a698ffe437a7c84edcde5f5ff4de02be3d78e477517744d2285a41c97324676c631cc7fece38841f3541d9023843ad11cca091ac7b483dd177fd1a52de3c400fef2d3685d153df258e721b6df0023e1fc3b4af3a1800a0d7be97960afc955e2691e7b32a64e4d4de80fa5cfe60a2a42c799fa583c9c8bb70428d0cf99b1bd3443061e4c5f23908d43cb2795606968e11c1134a17620769d1408b724d41942d1b6e51ef917fb80024a66a91dcb4933d5cfcfecd2a43b50ca5ca1e177448736179f04d3219bf96bae780e9cce10501bf456e25b1cdfd375d10e05457966ba0ec45467f1cda2af8a22ea4a4b03acf2cb1061963394fcf2a6489a9b0b5f5ff398676acc5e664718ea41c00eb42ae7eedde1634416fa3f56aa7603c75e24c2ae89bc89af687415e714e95b7d2f9f630aac4409666f3aceedccacb4b73a2aa96dda131cd696e0b6ed7a54e988de32e5e1fc84cd7d425e9568c146eeb25fb0066d04465cb72d3c1da9c6deed3130417b7003e2e6479875f8c8b42c11859f69e16625976319e1ea4508d6145ca6056932a100d04229cf0bbccb2bdacef0ea69bccf3c1b23bfaa6657961defd87b4c16bf990a109759cdf7e3cc844bc90936c7567ba24bc860694db970344b0b2ecf35a168d5bed3999b105a5862a6f60a659467bdfa49267e081c08c0cfe803fdd9e5b92fe3bda777d3d69b72b38968f0ee693e33b03ca493d8ae37435dfb5cc178793869e94f29961e150d28540a4fc3fa873ef4a1d03a0fa645b9563ee93ef07e2e36c181f0c0f1d552e183f5e0ff3da11215c803510330b6f3067285b3c03326f1eb514a5bec51ddec613ce6a01b8c9f5c3a1007e868688124d72db3b92c2e4022cc2c2820b8163d084bfc774e2b218ca245efa1142ecc08327f265fe7bc7f0e61d346e9d54935b6c41ae53e3d0ef2552077af9d0566999375940185689e8d428f1d6de06c81014c9f29f557a3a24a29a11a6fe4c4ab84c2866b4de3b03468510c3198a349dfcd5565aeb4c99b0a69fe754451dbf4ab0e8362aaaa5de19e195658fab1ea6ef5478292152d702aebbb52cf465afd025fc9e49418a16bfb6a82e4c2f9b234c5803848271bc3c99a37b266c140df43907ca9fcab39d150df5b38f3ee36991a37c8240a2d2058e9fddf889733040e8fedb2ffabb9cf47888bf809fa64090aacb0bbf9029ee2db5c4dc45fdddef45455dc1f8aee08c19f36c7c55c931c4abc4d7e479bae761920fbab3672144c0dcb1fdae7ae17ac64da4e2fd015f46c7c024eed9e5fa1519b2df1ec1b88ff2d700970ef568238e8c14bd4128278885244814c657485ea7941d2cb7a0e363f0ebc9c58eb6a0ef267d3a74631b97849aeb34831b296337440906007aeba898eee6ef4a22b33997f75f46d2b52e719c1953e62e2b0a13e565be36ed8d87d05ec4758817cb1739d41b5bf4f973a76c4d0ee62caeaad1316a549a9b548d08188ab7437344066578867f55ae8172d2817ec5c13fd55834819f1c2bc2d283be36ce4e6034fd410727b4e6aac51545052de3e0e3b3895638c60eff2ed4e6fa25ab6b6b45a3e90eacc1dba62eb016bf69e407e90020aa09c12bbbd4fe9ebb7e89fbce7aac1cedc4f30de422a5023b818b84207384614da613dcc6104a811b1e17dcb0f33b5993912c164d599cd1e72e0fe4ef81227d69c1d0374add107d276bdeaaf00bdbf7222418fd214ea2eeb98c0e415ac04d87dbb9c0b56c627c52aa4d2769dc3d2828a811fbf62ffb7bf31d72f8dee636b61f18835fdd7a8ddda433918f99eb1d56b5c9e8485f1a63b9cfbbc455aff30bebfcc03960263d6ea1a48633fe6031ed8f09aaee709370ac154d225856c5e6e2ad64031a2120b72271517f07b3e74502bbf9d8242635491768fd3d5129ecd2e19b292837de4f56d31ef2cc4205587c0210a31db7e69e0e60b7096cc7ae1b16bed71c8a35f05aa78d33cc38eb4e0890fcc8953e51016fe3be16cad5812234d83cf2fb9859a66bb90f958648de19eaeaedd9175b02d09c683a9c8a7245997143ff3016c7fe7c7b70b020ac8ab9b7a1aac4b73771ee712c4452de62d2909785aaec5fdffe82d42230d4c74b55102eede9207a048e2bf22c4982e9bf7e1f0ba4a5ad1bab413e71add5826fcffd4b5d2619e9d1a97a26e12f137fc92542fcb0da7b24fc88e1735980c3b3f14c7d8497e2de82e6e9b4fd45ca6f87973c75eabdbcc643a5ff3409a5267b5c5a2660c888ea801eee984b59e5d8831ce0b3efc85cf5cbf40d43c338ad7ec463cbf27191f085d8c7c971255b4053ccae6d22d68eb1dbfa0dab40eca1e553b4921837c1f6fc79df388241e1e9db467ed384c74e14c255a7bdc2632f249b498f184a827c16550dc8e0d1582f9f90daa7f92f9343eb6efc7ea2866c4112728d36c438e9b5a75c605032c8c5934cf84ae9b55f65cd6253d65f51eda67471947b2db457774407bc819cd784ce3b284a0ae5996ea058c7389d9db2e01586390dee7ecf2340192ef4e16cf7b4d51c69e13e78e820fe66071465de7ade1356774ac545d7f1a5383a043a2225e770c7d21abcb888a601a4a9e6df0336d6533bee1f2910b263c02575372d3506cccf36091d0850dc5fe9f7df9630e6a4254ddc504bc9146d49a6f1c07352838d5796baf414f4df9a31cfcf9192438781a4324b699ab15772619633229a8b1a6728ba9cbc8d64f83327f9a9b7c824f602b199418d6284fbf0e87d4a9a9b1cc7b8a34a66117ee90cfc87764c3650044f1a237d2381908aae9175ec6fc48b1322d1a490d0f62a7e4c67d83d864c3c2b168001107ad7a5ea8a5aba4eed4cfd542fb027e18a46f9cf5051cb6ebe1840b56a69e67cf3215a9cd1cb54f0af5b69e47de7fada5f1915a4b830b92f71e26ab3dc7958d25b1f3175741e6393d4466a1aeb800e2d2f1b6494ead090f2b145b7a53613509104a4a98554c28ec6d87783ed3e3051d89917d68c7663a2a39d5f9ae89146117a7c5ea78c1795323ec965eb06b04ebd03093a162766f87aeb2ed6b54ef04b4fcec3ea1ec1cc0fee4e13e591b485f516232f4229f2b97692cf167aa99a12a179f2afad8a2a6962b2278792129718d3246b315382699f6908bf10f48cad1d2b2b5c242bf6d0b11eaabe93b633ccde63e357fcf9a32425822bde5486cf84ab0a8501dd53c3a004131db11a599ea6413b0c8c11554868028b00662e646966bbf89a68ec9aac9a8b4941b254f31bdd707406e3e6c92b9f7e3eb161e46ac3a36e8c37c50e8bace9bbacf6dc582913cd3537847fa1125f76cb9dd73d7f3a3a6d503b7ab4912afa001fe49bbbcd12f0405bdfefecd16ea17f6a9df38917a586e65bc8965559c10694b754f3407684723f7c53600debc85cf7f6dcee7ba3469daf1c3f90176809466c8ad26564d6e8c2680b1a12c75dd1d5c9e01316e2d7e5184029c9112a85b00a402d54df2ed1c4d1cde45853c33b6f762181b5d247aa3a23ddac2eb82ba6239a8b31631769d023834d79be28d3471a7dfed05734cb8293633d696a3d1e566aa397293544f8404b6a9bb17ce493eb34777daea0a38cfd1a6997f28445173b8c29e2d443637d3a8a6e0c6ceffe6c988c05704bc9ef82cfce56594820762b5ed858a055646c5034321b3f4bee4abacbeccfb65a9740d94a64129e4026de2bf7227854ceefbfcedf2d12465365ea33cf97ccd2435f5a342cc85dd9fdb15fc248d3a54fc515b3f9e65c4fb1d339fe140e1bffcd59cde9ef504a057de4536115b1ee7ce4c008e99e01df6e8630300219f22278299e17c2c4c713d9cc133b3d9bca445866e283be1101bdbf6a577d6c74664fad958b742defefa518a36ec246cda4335b9d332a435cb27f233cc055560004d42d58b57a2b432da2623acda540d1c2e0d49850c125743b18c157c76c0c4946d3d642ab4f68e24bb3e6a9fed2345584118f169193e8b913c448f11d6eda6068bda18cc5c8414af3e0a473ce4e46f57927664fad943c8b05b18fff7449ec17e9aa17c404fd72276338955cb312800a6bebd24e4c6e4cf22999045c9dbc7d926a366fe9a2b9e2e83be4ab7f0e341734eb69762a51f74daca6f7bc7dd7223ec7b0ce2eb3b5747b4e697d6ece7f113bc30847113422f6dabfa70f81b604dd36b745eaae666a2a6d8416f761b162fda4c10e3a86edb3b73b3544de4738ea5127b8c267d8eae760157c3bc522e3e92742109accad301c1126ba1180909b22bcec056836e4815f99fbd57dcd53512f4cdb302e480063dd0fcd806b78ba8a4f312f5b3ea82c0e07eb818c1d6652006cc3c8f39c828b2f87922607cf5d36721a4fc9cba968f09bd3c482049e2f247641e02218490a0e761ac4f0bd6199484a7acdc02d473e3f842db671009bad2a85cdc3cf7d241cba1b70f7dbf55b8599fe823cd6b13e52c5494480e0aa1ccd74625d8b8c5cfc91146cf2868cd6eeb91dc87fa97652aa9785c9a488cae8e55e9cde4e209f617e6eb846c26f66351e1f05233fd2e67507e7b801797d3ecb520873fc3cf744a5e30545b900320607b752ca9c0f8354180f64fa221cdd6cb296ad7e8a3375ae0f33cc73a82c40135c8db53fab80cd32e9142ad24bfce60ec6d2736948730b359dece3825f9e2ef080338fa9af20bf70bf53572cf93eff46daf9212ac6e944cb177e9207779604674e30b23b05c2ce40c1a8bed4997bdffbee66e1a355b29d6badda5d97ad1da8a64d33a171882a9a3225f39456e52ae3e980e4ee54628d665f8ab0265af2f9870117dfdbe2355f5157c7fc8ca5aac4025bc9f59dd268ab7e23c052d2aaefdf4925471df00e1ba009d89d7130168a728f149f4090e91e6b157f199e73b10c55557df6b9600ccad0467f775531311c82ddab4f97e1a59da1f38a329383f90645adaf9cd07d3bf9411c4475bc47ad6149d9dc85da58d7101e5ab7b60f9d360719a4080ebaee3952098c5d1cbb3f14df4ecffe83ae0a97479d338da5179fce6fd028de81a9801d2bc07bf9299f60239ee1544ac2d753fd044585ae05bce958fd05ece5feddf25d6bf8b54ffe1c59c19fe68abc5d907bcc6b26778cae67ae9d3c90675bb700f0fd61343a5a32a81c4979137dda0c86ca85d8caf9ad927034d0a043c18b5a2c45053df2c2d87e7300bdecdae3aa9d29cddb5f35068974b9a5860207395e066d7edfb71be77d887acb618f803a90063079ac40887fc27d59e8a537f24098ce54117119652371258607617305a56f98d69fe5875a2e16b5148d450c11ce14dfc9073b282db55e73404029943bcabc761bffd4812176fe0cb01809b0723a6101ab576ef512ca3495a068410c2936d339f9e148d91288219af5e353a70bfcf04300237d3f110178d00a9ff3e2e3da14ad7f403d8a258e6c3a9218548f8d0f8dae791bc42d2894eede3248cf8270f8d4dec3b3748bdc2b1f16c83eaf5bbb20a5f349d09decf01b2b691a9b72931ed6bf6178c7834a7ca8c8d2f14bbe89f0c86569e058e2bbd6f4b058776241fc4ebddca767b3b924775bed6f57b0af969a581a062150aa6835d794aff7e45f9c05a3c7487149df1f5e56b8ce6a20bb52146a44dda2d0b874a9506a559dd50d2e595e2ef4b0cf47660939347e8086703470d384a266bf028cda6e41f2e855f02e668684282623f51bc5d782727f6dcfbca23ffa44bdb633fe69f751a83656eaf8fe688b6445977ce958e36453c1094fcf31e3700c547e41ffa389d590ea78e30b5c12eff793497ca544f6df5c8a34b1801d3ad3b5f56d7e66c213eb4c5cb32a9279c2b1a8ab215e80b5a8ac73faf21319e650819b36f6f8dab396a20b5e1afaa112639edb91e5abd2bb92b2c5b73c9b31615e51acfbd22d22dd57abe7a002e63f5e63eaab85e1288fc081373e4b46ca57dbd91aa337bfa00ebd1ed488b8fe761578a2ded2fe6195d394e72d2409b90e13215d0cef70978c265c34232e65e316b33bd4f674746ebeb7f16f1b0b1bab61a42b01d01741fe7da009f8258c27d451c61c7d8bd0e140f2cf9d6280ab90ffe3ed2869c81598cea532daeae5ea64dc8dd79521850cef63f9d619748689df9038acb542c06f7910d09016197980409b6b35896e06228126545364b8a6da776e339c3b1ff696fd105aa9534b017e294b9fe993a039bf49cf07207448b5b714ba25027fd48963d4230365830fa4053257fe2aee1e471893ec348dca9d46e86f69931e2c149e9576c9a3dc01db4148aabe897f2061d2c8908cb2b0ba9b3e2867fd63683574b2e80e7965e58e94831169c7ef15d0bfe326a9457bf8db6f8abb250fcf83be3e1c773f809bbc0b2472acaa8d2adf480634ccab8f565f2c0a476acd9df4024e03e6e156aea1cdefef79cab5c34d1c7285d7c3b75d2aaafe3518c145a1ad8b145c66b4a22f2f48489c656ad52e64a401191f9017c6cf27957a02c8e6d5e34d3216180e66119753f8b65b19d1d8d8c8233e14135a7003981b2b342608c4297bd38b137446c95dc0feae621f6886c19f4e33e8d778817fb65347ef990bb2702014ba63b43f1b7552487a51ef60a9dc96d5dac10def7ee71565d8bac9781cb8bbc442a6fde3aa3fdf8a65caefe32a13614b2ea1d845e9c0883159a476f2c28fb5e7b8f01e41a543a64f9922dd5710fd06e27ae45be51c24a10d567e8f076457d8992ae5ea01ba258f6d21abeb8c4ba741c7d85bc3152cf3bda6302a063a1f4807d91b015383c59080f6d3ec91acaa4c397c94ce838b295abdd1af3fbc6bcce73d728bcc8698f48afbab1e537af73dd237c6ef17ebfc58944c12d6df18791f3cd0649231dd39437208b9eea5c35309cd74ba78deb5b42d65a145755a86d09e21c1d896e51f5ea02facbb79df8c3f2406a2bdb60feb53e219ad7627e7c309fd18a63696c1d78bbc8314d4f797c5eaeaae7ca822794c3f2d60fdbddfd1cdf68020436e5840af9bd53af406081cfb39e32e57280f4a551f60f9d54190187431d057413f0efbe119af39fa3e0fe120e5590f9b73fb54882ef2cdb2061449e9b422565d849a982589f4402afca679a0dab7a2399ee8dab2d08cedcf2c5e2f07516b5bb8e919fc1bd63724be197a6995c569da4ea8c1fae4d8c1a96fce30a4bcf19769885c511b066480ced131435d3b4f0e7e67666c59a5f7e650011b967e25da63b1a00b038e903f89e09aebdddbe33b0c9127713d29f1cb4e15271b227ee4531c9ddcc75234dd5d1418498210ba054aacf04a31857bd496d51e84f48cb326443c19d4ef80f9b3c550d62c66da31ae0daa762b41576b65ef5a82cf4cf8c9e8659bd60144702e35c158c09b432aa175fc20e57c550cd38b1ec7c74ed4c7a35ab455f51d0b378605d0e5f30e55f3c016ce7fa62eb95e4826d356ac4f346348aa68593c2084bb659f1036977a6816d1d900fd02093370879d60474bcf62cae0902ecf3e8c34aec4f2e1efe06613eb20a9f36e438ba36f6b6a46d3cb1c657e64eee07e487bae0824b9b3a077dd08f360aada126b003eee5757af3610db68e0cd2e4ce4852bce096ddfd1612832b374db718150cb3c30546ab286da680c8d5a727f7496c095b7e9ecedc78f0c2d226acbd0c7a7330cb8591402553457be32e9012a9428c23452f84fd5b2626573a1a9ae83e50125537156ed5f534a2e1ad418d028106fe1b8b6f7bcce5205f06c19a39a73746a964e7163b672a5b0da0d014529bc6abd2ac1a02a051dd1c4897436a23985eb91d878249568102e52a36f01106c0c6bf9ecd38976aeabf4b63a73031b8c774bc4c9c3a337df0caf4db3c67daf3fa9f12c07c333ff59ced7ff93986f1f204a6349ddcb34b641ae5c5e96eb86e61a9696c31f357dee8226f4a765807bb9b85d580e65f49fa02342baa87ba248ad9b46e2394328d6953acced6801cbd45cc525ad78015791afa2180d91c9379f9830b3a834f9ed0db5d0421d5636c3f50946dd65462279c19e2b5e180614826e3375ad03a102d0dd71c6d8340226017eddc61b9c9d5b60d6bb984ac3ed9557e175d187e4bbeb30dd4c92aa8548a3053e8759cd1e4687be979cd1b6180c3ebc4b12a1095ac2bd0e6d8a1446743678222a0e0ad456b773708772c51a107224d46e6f9521ae5ea53d3f1bb201df118397c22092031169e8264ad9d73b9285cf796e9854bb366228c578e8a33fa792c86424f066b0e0247e454f3b608034c9388d613e30cdcb47cfb1d6cd8a9da05238e2d8a1e163da081364a1ce5a7381a37e284904f432899586b48c2934f7906b909b30914121d005a9b7aff58d067d157111a046e8c2cf86352011ba9f65fa88f5a69bbc5077380bb38f3699226a2ab2526b6a2916202d40099ea85374a31e56a510c9d8fc8b4d376bceab814f21aec7a49f7e4144e9cfec5a8c0ce34070a729b6728ee1db0d2962e47c00c7d9091a6d72429c2fb70647ca8e574d715fb7c64960a250a6ab339e976c74ed3a658429dc857d325f83602da536d981944fe5c963c03325d68d96c56b30054beb5d34ed9af843e9949006bedfee4fdf27bb38a15c7c3374ec0880aea7c342bcd6d2b194a0a7ab16c4bed407a3c05b37b9f1f89adfe1431717592f0b077a1728e18d5f901395ad2edadcfb18ac186a5c3380675913527d45ca8ef87c775e11cc611a2daae45d1708cd670544e98a31fd0977421e26dabfc5e0062549b34ea308e0cff335de26a1ae0b858b394817df873f2f4d29315b17d0d6c928661351b698aea12467571cd168e7bbc3a191056c6b19fc15063e251e8759856f7ed844e532dbe527e4eea76f9e3aece5b6081c39160e1dbd56bbcd88564ea6056774e34844a72f88458be22ee954311444175bc054c16a0635d11ed114781f7fe8c630abea57562943e37fc05fb934c5faaae3da3b0d134db861549e2fdf39ef7fde84620d48c4108f03c5c946781bec1d7e91b63cc52b65506ff493c9165cfb7f065b69b7102c79f8e6a6dbd02b6afe7eddc41013d81dab0bb2b30fbb94b4754acddc631daef32f672f48ba4d9b6ce67ac2c2a486ef054d9ef6f1d384ebbf8daa143326c2fb35da7a49340cf4f9108b5f3ba79fb14f5b4b3ab947e9357af9163f41c50c655ab49759cbab86f6b133b3b851c42b7597744086dfb08d5dce501d684ffc4f141bdf9b8284d605cc036573f8f405577a35d9ff02fef69fb0e9144766f5f100298fb685e65e8d0654ed7f2c3f5ece87a9275315137c27f1b7a0e768532947e187366a328116f2e28358d6173011bb016338dc597dddc14f43f64a5706f8cb3c8b0c86d5bd48c2bcb61c0b49b442cc1e0159d1e411091f89bdd85b1035fe4753cef88a86581a4b4651b0a93190289c966cd4afdf9ffd28cfc6212bd6df8da12ee4648cf766671b1079429146a8f229046dc364821438b7034aa047011cba06151820a29337e72404da0866465917cdc7ee80a1cf5f281317101cc838242e69dbdc134a89c36c6fa2a478eb56302d8cf9ad72f6c10e3e220c3a95b3b2ae838af5c72a207b8f261351364d1ef610c31ae099d61686d2dba21dec1f8696857869b554d544c3decc7e40215604cec9b951662b0e8922cb1acc2a6c4308cfc2f7678587a62353d489283ea1069ade28afca0e86defcd7acf6b7e4865effed5bac44219f2ab4eee679af2b7e41b708c5ab837aec47f146bdd392ffe0b8ef707dd827765f209dfbd52a4deb8d109af09a7558a72edc7bffb0d038a89b17b265b86fe1952d01b21904bbac27f65086fa0ad813057bb9287d4545a82fe4e737973bb15840680df73af13a6a81f284d5073023ed09dec53f6992897bf7a17fc7b0e232490f24112ba905804695cd4843d4dc877e8c6d1b1a9f0c219f613cdf33e5f0e5a262b06aeeca31398c2104c5a9ad5a7610eb00ae13bf73815bbef6e3100a7795ec03bd59bf8a5aa606120efa9e4bd31dd42c30d08c131e1823cd942d506a6a004bc60699a0b7c79d96171fd9dd3b8ee33ed9b99f781c87743aa819d28a225aaee670882a9c3607932d6b42f92040c35fec2e26668d7b339d5833d910ba40cec69a2defd8771e7edaf2419bea9eb6922eec6c6ca41bfb3dae9021cc1b2e02ff3446146f641d4dbc4db9740d5af4dc6989b4d4f25ffba13d8e3489a2e363719a99bed3328a347446b52dde8d665d44c0f7b0de25efc2a9d0cc1a5cb7ecd1cf91b56c574ce9b908e5e31a03957821e33fb7320ed80a6a9a1fdddf55852afdce597bb91cbc1f3fbb94e9e79a48a5ce2d68b4186753122088cd084d30a6864dfd413744d14f9aef85676fb8538603c8be064e9ff258ee311e46998e686be16718f70b485d18fbd43156ffb225f9c58fed67a3d54bc6bce3dcae4b48a5caf34b6ec2044b500c9a32c2e7af4ad22912361c4ba9d053dd54ffa8da2b90f1f2626bb4d5a314147b3a4f5669144618a657fbb36acfa554239998ed6cf73b7fcabdbfadc350339f05669edfa1dd55eea2114121bc4c0b8f5a5413ecc62240b0bb69cbbfdd8dd27757d4b44b2f0e3e8b51b271a076eab26536b3bc163e9b8f8f7d036e89c7e03b2b5f287eea590431344ea7f9b3e57e423950cf40ef2c8d88cbbafabd8870327e44106a97bddee61d4767297accff4feab2e98e43005a56eb89937f1f30c03f824f058fe8d19d205d86529e7a4d43bd172a2451c7712d36804adbef04b91d203aae87e1fda079779002dd73d2561b4d559c3bc9b4d4e04f71f1a4acff956becbab72b5da2ae667bab6005039f19c6d9fc7495d0488a2b821e43424917187c902e2ba62fe869dd379238ee0a833002572445a0cdb24cf1193a600ae2f4d1cb80b2d71471fac0496ecf10df07918b7280472126e13531f9e0e0f6e4004e28308247bfd4697014383b542c7c748776c4c91c4a0fe3653ddf087c8923b4df0034ca8cc1dd8fdbab07d0ae2712dab28a2f28c188f7b37600aeefada6e2269e92492cc4a32114a21e706d29a45d4269dc7d235adce630bbe28570e598be01570debb97f701bfd455fbe97363683364fe866a94b67d3b61a04a2e403aada5f3c2a74493e81daaeee459c9337990ffe066b977dfc4aaa29a758f1caad7f6e5863e97e32629584c760a40431be908affb54f03af38f3e44c7a8b322396bd01ccac7c0540944f0ae1c8e9255868bf270727bff4a2dab7a3a87f4e85bd7061d4c65558398dc5f15608f7165de8a9968033556069e875c55aff3c2143e796edf04dd6323835c6a6ec9e02529df5b11083a6723b1140793e7143e8726c1a0b8a0433fdef0c4647d3c4102052daeba2b6f35bd6bb9db6098257efb977b41f325036c3979fbae04e5fc8a35f0a5dd2bd8799e88d55398ff62598a2bb95b94bcfbc4fe8877da4f230d8ca37c92747afdee47648869c7ac82ac8c790b0c6349f685d1a201e317fd4590d7685197cc9c67bcfb93e0be199b3cc29a9cf9dc225aa9cd9b5d5942c7e7839d0a806472cfdf1fdaec6a3cda8c8f4b954f56acb968fc99a8627f49d7c37029087cb7813aa4e7320719f2635ba04dc963aeb2543d2a575738b8dfd68c42a9654d5b5079f067fdd96478c7b961ba8f36db9bd11d912ed289734e6d816d5d84bcbe374676d9c07ae07b18315c861f0a41b61e95dde7558c1b6790b3911938cde89cd314b33ea7c2992b8e40a48564cf2fb843aeb46f8f66b89b5319691f78848fada4a8a18266bfd921025dfa25ecc6dd23ed4bced6bc57dba4dcdff38c7c47591ba72187b25a877ecf46f87fc68d0ba211d06a125f31ea985a9f3f0be81b1258e2f9a5f7dfb716a116c1a8c38852d66238836df8d956f8cc6a6cfa63d481f1f325db6f4cc4a0873bba7af98606ccb09e24ba7fc11213930a4b89756deace008ba44ef30d43667b898895c0e81a5e3569a2857f85522710c32a7ccde14e371f825f96077800cc0500a9265c0b23a28c26f0fc5441a386d1f7f99317c638bd43130ff833f3072ffc7096c4341dd0c7c619342b65ccd1aa09c41a122ce335b1db349ac335475562c8b3064ef68c978cb4f49a3314ecc060fbffe80eb5f38815e9da29743d89d107da9b2d811485ece7841fcd655a9e77ce1ac1f67bc5e193ab20dd60b001554ecdfab51a3bd748a1ba3fa5d7d77291c1090295851159015adc652368f98cf90ab5b7e1baf033b254da262e234d2e7b0bea7bc3721def86f589a19a5e40fe73c8a38e913c96517ce0f5f984bdafe6b4381cd6ae8bf098efda3d6205f48ba47ec49fd4bc596448e55ea81755ea174e4d196890b122a191e97d51033cbae2e45f0a8bf800ebb34a0758a1876973ba92aa03df017cff7ec21f52f0bd025623988b8fa67dd2935447e27ae5d5e6c371e994e0406f6f9bfae318752c6bbcfa811c63fe260fe11abf49f0a440e1610355621611d63047d2ff64bfe3e80adaefd6f15680bac7b0b38a74bd4294f076ce76490d363c52ec84bd8a70c57541d8719f2ed9d94f1faa5a3287630b3f2247fca8c4fb00f958bc095595dbf5295058f84328d974f38c1f5cd71443d4102c3c960248e5a939a0f0f94b67fd385a8c470f87c1b358001b7a97d2682f72d6da45e989da6ad02fc5366dbe141c8646c5f771d38cd3dbd401f853ccc15c36ccae23ca131861fa405121ff70225407be2d50ff5c12b3b722d0d3754222838cca07edb1241e49461f36a30aaf1cf945bd6afc3581d25dac1efcc4e6f0192dd1c166b15f0299c2e668da9f74613400ac9779284f02151bd472131e7f2f8e22050588fa08fb4801bc52ada9c7617b08ee79602166118a47da308b4e38be6781033715ec9bf99864b48889d24b725d4732548b9303a5bd8e42ea5f1c7f45d216e1e26026548df5c7a5e9040fe6f048ccc73caa51b7393ca83e81c829e5600126dc12730d5d1256dbfe3fd8fc030bd0bfbefd5d39c37165b1e7fefbb14df0ef0b83f0680affae81d574abef5bf90414a0d7f469df200b5089ada35e6391b40f0d745de401200b232c0d285db9f1b17bcc8c8adbe3fbd9f1c4fa72e6f644ecc69697317cee1b3b5f49c965a21ac29ce0861272e6f152fa85fbac1de85d2edb780f4b47068660511c06848d0d8bd8042521ca2d9bf359f39dff50a4f6d1279bb6ebdf09e34b9e61add4b255ecd69bfc307e9bdb9249b1cf8bc79fbb341cf773eb29894a3c03c533c036888dd1218f938e9800582d53a1d372532e634e845cb8393e8612ee4e120b8f410289a24068f838ed06e12c3c524b5821d8ec40b0f50a49d839a6c52267a6242e48de0415ea66bd7d5af50d571c848a84da593a6146595c5d052a9326ef6173ce498cafeb1ca0218ec857986edb82a7eb12ed58b2735ffaa419454ba9012976623b196802fcdfd865c5282ab3bebd4abd48be986ac1779c7b8e398d829c210a6ae1e9b58d97d805e2f3db76831b35a6ba2edefae0e36f8d97ee3f4a9c2a7687d99d71c79e34699e8002f203b258b0b8870a65bee6584706cf255c2d0f5a8b083757c5cb0e0729ae3779e1e2590880aafec3d53217a383e5ecb96c25f0b067510e79128e1e0fd4156732e0fa0f6817ab5caefcaaff236792199260938f1ff28d3da335b1def1cf833a46ce26f619ef0e78eff2dfe1bb448fbb7d0abccec5eae079897790bf093041e8f0b23a70f7b66dc69fbd871c4135d5de32732f48da7d31dcdd3f447cf455e654bb7f891dd7782ce267cf831f6d91cda21f1a96cac0feca3d37558d220187075d397732d50b93182c894abd6ebd831d88ba0933900fec6c498de5ffec0303f52a99bd62cf6d57173215a1a6c0dd07777bab07d560ef6b798daccdc785b8c5c47e5cbe93b088af1df1f79da2e24aea2718c4b354f278627780df84f82c4c88cc12dce1fd23495e268989073f8b4801e3f6b691f9d9929abc274644fffcff33b11064865c2f84e9778e2fb55ebca26e94c2d4825e63687c6ecdbadba9aaae4093884cc58d03d1aaf58c4df14da75ba29ddb1f81e7363097bffa70bc2652d65bfee8f67bb3576d7327a3b6cb0c3c428edbea7876b91f41fb9eecec953baeeae10cfa895457a6bbda0231ef792e04f201b1b4117a55f9cd1e299b512835d7ede45db61c2b5a1f6bb46c311d2d5f4c3f6d6272689772936b0a205f4975814bedda3e30a30114d2b4541b429d8d262742f371f306d59ef5427516ccecd691911b177ff57dd11d0eabeef43a2aa8d21cfaec35a72b07549f24a13a54794d101b80ec0c94f33eb48ec1b31f97a8b740929b12c5c2d12d72346a83d7eb2021608d24eb2d9f5b558fece573705686e958172080e46c44107c9c2685f6fc8ade533e299702d6c3dcffee14a44fdd6ba8816800fbb84f7fec485de1240e038f35a959238fe26c6a63d2705b91c97202fbd2212911febd01e712682ca9082796a2ddaf324","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
