<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b14b7fde8d640e0b326d76c02ca2f10759e05949825ce54fc2e77794689d3c65d5509629758f41eabc6cc760c1836715af9b23486c886cb2c12145b1aeeaa3ecbdae7843a8b7b972b0ba0b65f8d635c2bb51e27f08e482dec1a03046c91d27770ab0d2d015490363db778b1a88692fc02004ae9380b5a121cbefd1e3a09b7899779c80078cdbfd0ac12a7ee4d7b5f516fffd147dc9dae6eb730f777667c3ca1aae000a782ccaaea42cb958ebaba5ba60db2fddf90aafa438892143a7e1f10df1b111f3fd22ab2e7ea36a04d80bed9865f8398fcecdf3341fe542760fed5608f2e052f0ef0c54e750fc8a01d433f0d945048e5ea6867eef7af2211d2b73231bf5b29e301a9a7e46883e06a8d87827ff91087b8553fe015af8beecc0c18cbce39fcb42e68fc4d71bb00e6768195236be27744f1a6266d5635c297eeb0aa56e3345e1a8a6f38c30ce7a83a8cea43ff9cba055d47735a9cbebf8276d5155420b3b5d189e68e96e757cc2ff65bc7ee1476ee5067fd1df0e5d6029031a6714870b75055bde0a7e1f0ab069e7267526d1ddea56ee207ae25057ed83fba765df012d4a96c1c64ad777695b823310f38c68646f0b161e43877325d32c117335c514f46d691f8d3924e811d15b530398178a4a5aaa06595c087e9d76a98169e5583107c78bfcf2d3b24ea990d4a722a7a17249d6a0e8ec01970f0e3530217a6978407cc5d438bd369a492942bdb4ff33d73dd56a31c5f4fb66d5ba238280b4d685a2eee56008909120254c548aa075c5b3dcd3af8114e583dd6906aad0d1d4726603d712e344200466dc3d9cc55cbe90664820d308424ad2ffe062a693fcc94b61be9f24b6362d91e567b297b6f9ce25f2c15fefa9195abd8b8060f07bb689d353dae16667f5ddc3b4b52ba01efce0a9f39a6939c51854aed8fa2ed35ab394315d9cec25d282f0a0ceb0a8303fef1120fbdf2ad15dffd45837cc5e67cbb679aed49795720a2b561233e27c1c98b080eb7eeff07cc53362c804473f400f9307a1fe2ef7562e96072068393b3bf8139879ca8b5f9a3759686a29655afbbca8ebe6a95f54e86f69a3fcbb5ad362efa476d17f9cb93bd26af82f511df7cf6d5487728ae783c1f3866e0610859467609db8ef04ea09e411f202ccb351a5ad7480c0d3e9ae2118e461907283e07cd2258043874cbb90a584293feec4c2a9c55a515165c1d2908d563ce95f7f7877713b2ba90a76e8a71d8e75eb687bcb44a0e49ea81274ef7ce2dd736b9453e1950d89af2eeb16384c7bdc71be77ab85130dda042b2dfc6254595e686827027d91b07ab6eed60e742ab0176f7e66513c0b3c9955f53ce29d388e0866231f079b4de7d563f2fd0acccbff3db1f7031239cb6ddb3ecd4332a859c4486a09c5076ca1492ea6754fa1e6bdd505cbb3225d315309883a5446721ceb023fd2856ff22a6170f800175e108bc5d6c0310bea366f65c8f6fcecd979663480d307681e5a4b24d3d145269f6a26016009388fa6001feee1c42754380f635a596142f7e1a46483b8d6c0dbefaf1dbffe9a84f4b77f3d67fa291235fe292d6c83b088ba2904f84ca7bfa0364bbe8c2e37c508ba716bb75844908ae65afa6924d2f13e03e1c3e91f428c7dd08cc3fcbc03062395df8593b292f8f62773351896ac30bc74615b0d947f4191d5cba16650ca2e495231cea1abff88c4a446814f2347cb193fe0ad25f67461750fdc894386a0e199d6491e31500ce9a95434a29b18abffc569685956b4b0c79b0091b323a2733fdcd86164ecbe4cd6f4dab656e10c7971c07889f6169b162953e1c74f59c20bb74f7276c60bca9ac6dc96bafb6eec8a453ff0e86f9fdedeb5dd1d3c364061d86d52e9e25ec83d64f9a1faa37751e01a4d99c213eaa3333380220463cd02189886ce342a67339012bb5ffa1e851fe4bb23c8017752c4382a43fc047495b4c18d12079ca29eee65957300316b034fe39965f804b305d2d0529b96471808a4f56e09b891d670f0eff3af6a25beb3cbda5f25828324857413066cdd02fe3e8265a0bac1ad35c9d55ea6f05b7d4860edd39a7d783d27b2185998d678d2ac8ee22288f2e87d4bd3cde9453544608e7cce3a16c0d3002dd39eb14584cc59f9ea8fcc212a67777802411af76a638ab881fa1b2dbeb92d9e9665f16346fe250ec39b2a044956943231107bf1fd3c6ee0a54bfefad87490f323b6cada86a9c413f940c61ad5a1ce141c929b5bd3f9007c963555c844889452dc1799e54e5d8485b05911727f9f2b89e2a211e0081c69bdf6f571536a7b188e8462765aeda5a12f50ae939e690138b86c7bf15670e6625d229b04cf8dd2aff791b9dbe2a180b9737760a682376271fbb81e2fe639dce6fef63bee3cfcb77c41ebfff4c5c619203204dce81c0d7d16e26adc58ceb2350dda2af495141b79d1e17f3c3cc0d76d56aa724a9a09dbe9406da478f0ce98141328c06e82e59753962b77b6584467d94edd08c10917c0570ae15e6bd0dfe9ce6a6846b7fbe4a4248ffa6ae5cb69c095a1e5550d59c325bfb38ea861fc1d48afe25e74926a3168e64fbbc9a0ac1277604b49a004c8f8ba5883ea5abd9a896f6080c10b0665a8682f47253a79b1fd8f263da6dbd79a74fa437ae4e38875dd99c42df2b48121f5731eae59937d58676602a06bd80de0499185ee2fe2cc17391e08adae3a5487a21aacffa6ea37ebb48dd3825c7319d1719d9b8dc3354353bba96088ff44932387c2315d7aa671022999dc8ea323b490ba8b3a02b05b97df76156fde8eb2db59c278f4f0846ba4166459d15b48d6a36a3138cfe942d36ea7c541c6a77ffec6bf7e247ccb8cc291f5304ce891acce6392a8f27bd34ac6188047b1f81043674f6cef89e70245d84c798207e6a696b9bb7b27b4ba11dbb4780aa6b59c34f15992c678fe56057e733d5014e7a3a08e1b9219fa971083d0507de0efb08de42c733a6cc9292d8b3592c1aa2ece725a24d481e02aa3bec89177fec4154e2450e1a80dc8fd06c2edd19b649b407eebacbabab693f72bb7abebe1b1c8f9cbb6045e8727b136b86674c5a656f794dee1625dcdd7f1feaf54c30d23872ce6dcf415fa2f4fdb695ed4d89fd249164f2bcc088e0342760d69513ed5375aea10a47540553402f09568e728d6414ed2d7c2b80623bfe5a3cc688d2da9cb9bd564d55e68a805ce4f29489f0abd162e66cfd8550f8567625ee7a919a8029cd6215f6e22b0cf8d0905545b095093ea38e66161b465da52b426c0ca09e6006064c55f08b1ddef824cd39ee9102ebc702dc52fcb6bd68b6a39bff56abdbc2c28a38ef93084a6ce6a40f4e6cee5810f70baf4faffaf4e55f6470a4f1eee8aedb41a568f90962449f5c47104fdf9228cc25ec46462f5b0fc76d2b44dff058a19bf267a9c969b50d8aba1b11f28adc7915bef090a80f8a4df33838640f66b7e7965ae9f66f692bd94ad0b15b772deccbef4f4fe3c74c7a8b814a5b051f5e0da1e16b529beb4a85b1efe8b3d3703e9de0edacfddd0ad1ad426cac72c777dc9d84ffd25b1a2da9d8c316805cf40e2edf6e9ff0f55e544b46a46ff6665da7d6e04fee35ed65c5093d63d9699ea7a822b66323697d245d390913f1b11a41c131026b676dcf0056f2fc765f0c340a20ba8b869a6999e23db938a385f070447a4a8629eb90e1e0714a396bf2566fef8a89c98b305de885f50b0800b1db2a8de1c0727c04bc16c087685cfd0201aad38d513cfef67c4b3f0f7de7abfe5b90ebb0fb6a21d6ab4b1d49cfb6fdcf6975df34fd9ef8967f5cb4ca3f28d838c15f73e8af6677e1e3e2e75733e96a961049ecf2a20a9db83e367b7024ce8b7691225e46d26bfbb7e77afba235feed2d5fa2ab696fc9ca0ee0048611b57c9834fa5667b6dcc02ae8375c463e38318d520448821d7f3a51fcc6952365ed8ad4012bfdcb54686c5aad1abce652e615a1332fdba3dffe3a0a1a4efe31845d8acfca2ec8ac19ba4ea0667d6446f541d1c0520592eee70ff00d037c5c674415683f22c068d580d9c4e0148233444513f29812dbc31e235c1a36c2108ad3807a3bd5c41d0ddfba61db167ec20236aa0fb3c610119726e1651faa5e0017dd8634a7fed3e0e7cc88562a640fd71dbe80ca50a2c4a40992696cf416ccbab824643fd1ab0cfcd90ca0be06fad17e5c8a702e35b7d353f197438d1c40d33496a608ed4af4eb2e1fd944c9457aac112c2c1ca88d3e3ad5851dc3673befbf85098ebd1e1c3092f5223dfb81acb97f5da69fc08c5e5395523ad406fc62d5ae4cb98002ce1f706bdd84c17b6d24dd8aef32078852860e4c7d91312341e42539add710037b50b3e09984042c320b133ce7f3649253179f877881ba7e3d79f81fc81907a4a0245cba6f400959ba7de80ac0e7af13f695793c6ed9125638426ee547366e49d3ac30f6b29a716b270df8b50d136097f49d2baa25769c8b805f0c3a08ce57de59e2557b7555ec0095d3acf6c08bb2e82c6d035bc441b5db7e87fceb8a13cc89782eaa9795433c2543354cf91ec2b98bf91bd678b16cd604d7d47724c0244b0b195c031cae97cc780d9ccdd1cb4f572ce755a2d1e884761f7f651d2156853b5a416c1e162c910d6439572353a499649c400545a40fe79bb2438145aac34589acc6e261cca79ab9df7a2b7f5dff80aacb6d56ded912740a6a35132614ccd4301c36f264c0d81dc523b1daad779f065f3a06ff1ad3e3ac02dac3f09dab3be70d6f6d518c3f200a8bb370651d40465c37ff7d1eb61cc8343f4a0291de1548ab59f52d8952f2083f38321735677472a45f467f34ab58afa94792f7cd018a9f21e95e0a76ec9a6b9c523d9b937003491a9909700503e11efee451aa0fd0b9288a9d6edd37b391461ab32227a1b43044aa8090b504aec3cfa8422ef8789ff044710a1fc252de7e4d69533fede6fad1ba87c9d34ca58f87bd61ddbcc07fbed47e4812c1f9c4cdee4c2dec6cb9a51bd026878417377d969d880f3eb02f959c1112e32d86176abfe6ccfbcb3cd45c97697a50549c0252ef8a80ba327543437c95bee44b38eb68b54409756b8d3cebedce176c02cd6db5706c6be735fac370467f67825f3b1277d382e6e0f61c8bcb083f012883ae6e86afb216ef8943c50f712193a8f1dea2b85125e3f6cfa646986ce5b85a81d72eef3f76b37c74b0924aa747309be4c2a22ae25c3865164ebc4476f618153e2092364260cea9e77235a885282ae310acdae508a24f8d9bdbff0cd1af62391003abbe2967d7e7174b475e12b7487e157c44fb80a8d0f4f5e23e7c04bb2e6e28bc4208594b15c37341544eebf9d91e36b4b48f52c0b7bd11ff890308c23353c4ac7acc1385f2569a32f930b08f112264f18534ca22d662013f9936a31e7ee667a17e25f374f65093116e1ac2d79ce74cdb1516ce7a4c7710b2f5a17715c0c93056e0567d1c0f8aaabb59f3ef1eb43717309b8f2a621773637a4be979b7c80f9f2d15e2c01eb2ee153c5d772f6839a403aaccdfd7ad29dc946f7f6d2f7b39cba3fe2f6707d0ae22da71db56bfc35507f13a4262c6dc36025c7b371bfc3643ea81369160cae7768ab21d75dd655611de1ed170339f4633c22b99c440459df739c424f38f36438b1f512d54c394cc2bd518a3ffb7cfeda335df6afd0734714fa295447e2157e9ed3fe4a9c58d4c4fa1ec598c59e64d78ef8d8fd88f04110d4feba90f8e6d44ddd891e4343a9c912e393774a58ceb0238d28698dd012809d8e48c2e56dc5c49e59a57298d6445759b8b993476048312758ac3f4c136ed4cff218589b44724490a4cdbb4a9d9fba05d082d7157429ccd9911d16588550493ae6f8f121137fd7d4b2fa79e99a66c0ebe79c5bd1ed4c35e0b8473b2bb4e27b02731b6dbe44896b584e4995a146eb7a4e24056aab97d19ccbefdd0dcc9149f324ea41e60b1ca0fe21af4d02f224975d45bc36b39ed1e06f7be37a1cb11bc656933b30f255d99b089c4179e8d1c8baa7986ba5727c5575b55817b5781a5b55d6c1a88658d758997986a7b03387cdd586b85bfe5f176dc55fc2ac3fa2130c5a146a0a3cc301c97332548dfbef228e7eedaab49560b2e7a27c421231d36b81ed25d2843fc72fac7db788cd436b6d17c18bf38043de4ff46a4a7098265e691709df9b1745a713d77d511e7c6ba20627c02e34f868f225ef90b10bf7a4bc3fff33b3f683870000049bab7ab140a036c8690931407a9fb9f71bbbd60872de8e63efae07008671b5f504b2d190a625d021f3aa4ac37c2f632e4aeb81d4e042286a5596d2075f7f980853324ab68be6be19543bae97db1a3bb564841915bbd89a5e719e898177afb536066cc2d27c4e6749aada9656ac316c4193e74a7ecf45d72e9aa70327c2aec932e2c8b32b88ed63d1f61493d887dadaaba025d4546386775944a7fbf807967aded4eba2ae6949670f966365035ca7e77d28d6aa67db2c47d11808d427f4767b25cf5d1f32892bdd6dda21704d5fd306980d46db8f9cdee2a95b8bd2c127552859ec9cd6a95f972aaab240aad457c6fd1d2e24e84aed3aefe84bb7a52ea33bb71eb08570d854d89d948e84adaac87030c5e05b59128b4d62da141f4fea19cb24bd830df474661c1f1f14ee2c70404aa2c58c15c59b5d035cd06d351459894fe5a7b1443233b687b3f540b66bdf4e392d17312dbb2df065f80e986948bd42fed181397653ffade928fed74d5806f0416c8de17de4a747441030b0cd1a0a633a94586b2c9c9f0c328eeeaaac1949067c146dd5f728279f0e29db6fa0a5196e418ed4021108b8f938380f4a81444a96311fdbe986da0d8b0a5e046649b03b8023da3a2b9956b05eccf0f4434a0a4c1e8174db81665e6e1a1a4c2edfb243e33fee18e646bb2d49fdc97f7752cfd99633a724967dd784e295d4a93c05ba902f455e9d70dc1c356ead75272ee45a593c03be11ea13f6cac94f483a5be319f2c6b0bc836be45960d41367f5b368f3978aa8c8e14048e3306ec637b6fed5f093bb2b3d590519ff469507c2ac0834d444f3388487ed01a1d7cb99d48487eacde85afdfde7e94610e9fe8511d75e705d00826024589abd1c984981b10bcb88360dc53c71050f0f71983176f05a0d26a0381c842021cbee3e450fa6e2b584116036c8cd531e769f1141f7a72a6f16a8c110dcede7f9a5253784f3d5092081f5306f60b4497b753fe9cf5171ca15bb1fa82ab98bf5171f5f164db85c8bbe16c682210831b9835a73cf1ac197e183d7d7e71728efc85dfc0c099f78cdadd6257cfc5a0ffcb982c70cca133d75ac44ded51668d5cccb4c05b56e5f4776b3ff0b00d37a94535d95b4e00a3734ee50d340f771091564f4e8ccbcacf3a7c7b0c9e887636935e32d57d8fb8d05a22d7c3fece1631ac72e30233c4b8470a002c4aca56050c2e7050ec2f448408618c7834f912a09b8de59d1f59bd39ce4b917ddda555840d9d799d5da709ffb40c93e958777031810a7e84715fcc1b9f78ea6abcb7cc71ee75b9d444960398938d89d9da472864911068af2a82f1175ef5d01737b124936b0536d4bfc919dfa29e7b161e78ec745536189b087f015bdee3243577e60297a7645c305882be2e8339e3927a234b37b7bfa826baa793cca97ffb29089096703a75f65c7eb7d492f449a604195716520395a1cbf96c19251d6142e21bc6329d74df37e68ce7978574c7015fb30a3734ab4cc1b3346118bdc7ff0cf7afe2c866fc7c5e7e42c47558d5f7382e1fda1eff795500da2c4085391c99af91d3de857719edfb0c6a3dfe47a5a6ee680c4f596a28d751f3fe7051389113ebbbdcfa59d8608899ab42b33f06fcaff1d1483fa4ac3a00355fc07352f7e92318c525c572000cc50bf4b7099fb44169cb8974805b686b7954c078fb8786923a53f4fe13d55060edee14cbf3861d14c92daf6e9cd04088c991ad72b14f56a31ef375b74eff162d824b5252eba1dbea14b9341c1dc21333fc7f1592d88bdad1baebc44eca020ef63a05857a22c7a1a1d4ede501f20de2a9c5645bca586d423fd239495224eefadb4b4185857d5d487078d6ef2b15fd41290e36ed247b039df83e234b9272dcfb550f03fe8f36e11688d15af7d321d9ea964171b2992f64411dea0defef77e6396a595ad07a8b4851ea308f9ca5e4215b9110126b70d8bfb7ee68a601b65f1135066c1e00940938127d7a9eef5bdd5e227833c4d32226f89b459bcf61bc8036c289a343a6144f895e88b4cfb4007e17314f9416431920c98d65791b55a41ff86ec3dd5bf7e20f8d4620cc93606565de957aad5f21c0724f6a5b734783109af4bef84f790d2edad2bc792fce4c0b6c87d80d4db92d366bf653015d6793eed1d21212f85707ebff61d26a97eb8264216cbef78e7e9f68513a9a9456785feb0e6d7a00734d7e3bb64d4c31db76f01ffc0bdf7af567f1788cb604cad9949e54c6269f4993110387f24e987cb6df864d909cdea77fff7b0d6f793126c81886b2e5182dc17a653e264fc655b681ea67af60e5c510b75793cfb177db42861ce9ed28946df04b871032cf18c468b91d57fe11f922084bf08d334376a8b985f58af494eda68d5e8e5c266a0ae699b0ed60a503932511093c7197e9519eafa0ed6831bb8cdf83dc1045a80da51e44de1d0910c07c10a84ddada8defd423b9c64efbba9aacfb5783f077f5a896fb50ecd505a554aaefd36e2ec55cb568a5187cac46872452c0e3879834938d8d30fee78f8c8e110e614c598d276095f81ca2e9709e5be581e18a9ef1d7b40725135e0a6c7cfdf6f3803130d30609b7b5c93f83c7b9430fb2f011695f3744aff1e9d8dccd4597757a1e55871ad6d4addecb98a3088d83f5efe436e239c8365cfa5d8eaad3df808777e9ed48a6a43c0aa7f893dc43a92269f0e93fea5cd129dc6234204b40fa74fd1eb82e3dd4abada02dc0e7eaf8e9b368e80b66edc9431bdac058d04bac6cd118b902771839875854893ffe931ab8bdfefc80f2ca1a524116d4f67751727a32546a5382a6bada30793bd6c5c361deb777156c1269e90082187ac96898115b5ce11b34b6aa9d5602e9b79d38d6dfbeccd1a246fc197753ffbbc7fc06560387a56c117673affc0b4533d1b4b607ca940bfd357f8869c0482f9ce76810d005811e8514cc4b44039776884bf4a03a297c3cc8d435a685f64ef771e51b62a0c1f5bfc026a3e120ecee56044ecd98112899087826d0f91341c3b4345f91f3b201585d5f89b64aa25a9d30a00013765f52c1b13596dd7a1858ba3f71b1fe71da45c46b1c4c1e3bfda47c05dc2141ba60376f47fc7878f002aad341bb0c85b1312f99972f9fa9b243389dff7db8489afae5726227727383096823a5803c06c6e2c2db27df799c5a983d8cde126b9fd8585a3fc9c2fcfa19c43f6037ccf93d33c2152fee26494ebd5d7f7179b9d7a693ecb805fa16de8f5864a7b30f382c673c29e4860532bb8df971440866dc77c8b5e14f01206adf6a5f10464914fe0ef269cf434e789f5d5f33fcab3cfeb8eb512bfdfb93963509086c3fc1d651879842e6ac62f053b05d5dc1f470517414ccd4a8ae49858052a2f3a025a8920aea6b1294d4ff5c30a4ed5211abf4bc5b51a7b2516bcc84761d8515393e57535c5401b0e4469d4e9dd36a0a0832c989409a706b4a57878937310b8bb4d8c595b347980bf29d78bc6d766ea965afdba803e5855c1892dfea22a8b070cc269a4800c0b1afdd894cc54c55aee49948191b285ef16c3f60a61c639f3469d80a6406a7149553e3fbd9bf1f32aad8b036d3603b9f50aae18daf28060c40f614a9df76da6208c647b980e0806180bc23a60d12bb5dbbcf502e370e41a2b780f22a0a6502d2393563e5ee5f6565419c0ea8217adc4e6666288dcb09021631ab719a3a9879b93f4dd01d833eba816953ab0dee662b73adc85bb58cef90171117d79bde54bf6811cee0f3bb53e0bb738341317f84e95acb42af8c8bbee7e36984c1c2ef028d14e457db9c68206e4f2c2f2510674a9eedfc42bf7a74b39317e9d572299da2d0be4cfec8bd3a3e6e65b6f7439124bb5a65c281420b8055bd41f3cf6ef14fb8686c9e6b9399786db9e0865129afdba23576d98ed54700e1410c2517ee0b1b828af035a13033eb3b37fb6bbe1f018cd5bf141eef9dca1f8673c9289c31991dd0fcdfc9a30341db2fd388b90bad94df0a62574a44d03e732efb7911250e1803d0e225e7a17b38f7eed832c4fc832742533029dfbdf00b22f5aaf8cd4c3c5c264aeda2a943758a46fac0902b705da8b4885d5cbe019c05de91faab908e76a44478136280572a7d4129666d3d85747637f8cfff335f53889a878cb458cec3637869f44839934d66230e7e995f65cb27a02650f8ddaa6e5723b0c654de75c98079340e3f13cb4b560d1b9c3855d6720a41b68238c0fc1423afb9d9170fff66705d9c292526c58ee83bd9786f960322df40fbfe7feef5f9bfb8e9a16e5ab0e7f96763bc4faad475724a2a612f501be8e8335dd3417e61b8f2479ecb417c2aafe171bb650431fb21d00b89cb057f4bd61de6c57b8ca4d5fc890bd3b422bf8a3346c91381502439300561b638dae36e52b59e60ac2f30cd1c6ff8263aa5d407d4579dc10eb459ae3b696b985cdf184c3164ac5dc722a34a1720d2addb21f4bf2a468759103f5ddb491e31bb55c4eb04715296454ab5e9e26bf58736ca5d66442825db7d79495a127c25ddd36a146d1feeebc4cfd22e5dcf9704de7d1c47dfa0eec84a50c42126057d94a15d77eb90206dd87bbe041305cc5a5306acaf811a868da2e0bdada56a21cb933799cef6b9de76b174f24588ab7e91944eed9959c7e768c095d69bd6c302ccd7c62cac8f92a8e616ec06acd329db5ded37c2b4cf84b10f7a4dc305c4a037f3aef69ef2b98dd8ae6d8c137ee1a3fade2f7e5bd8ee1cdcb866acf597d86dce6599d972a71b2417aa5f7abac0067b609372cef3e6db9e43be2a4ceba0d3d215d6b7e65ce021fc567d64f3e4bbb07b5561fa520f231667bb44b976e0bb032d7775ccf858d0b5f8373f2727177a964d0986202a67cb7da33afd572ae49edde116b44cf0a5578b7d6e87d64aee5d2e6dbc24cc1cb422dede49826ae4e1068819672b9b1364d64aa5f0e01830c9251f7442e1d48e178ff695ed900441c25b43a80eaad03deda278c0d5ba0c23aa34133fdda091c6120610943bc30722c433ce90abfd97819b4fb4a704487fde2936a42fbddb59a6631f4c9882a70ec97d29bf0b85d494fff5acaff29d423c87fd371f0420a9a400f66e7c52e140b0a444c4a380602923af4ddf9d591e155c2d16c27bb92e1da81af7629dfbef314a558a27c4605d8d12910ec2a266f12df22366c8d3b1468b67e8d141d1ef7bfa8b2cadd7e75709ca54ad28369b174ccd2d44ae3a98cc0a392ba1a83e2dce23d2bea4e67229f2c7516efc6c19aa575c2936f347bc587579b8c6c72009455db20761dcbfab587eaf4ccc97083c560c1c3ad64009e8be149cd30eeffdbaf6eeb314b9bfcd5ae0699ad8a912bd65baf6d1a1eea986d748fd7fa2eb8f662ab5e533dfa603796b847b604641c5feb22b133f6d820c2ffa7cb32586cf32ba7a46e3d612ca69de8e1988b47c1ebf6691a491d857a8b40acb5d530613f24470dddb3625c6be9d2d9833ad343a3bdee92af573c58729adad4cc3e233e15769454480066ced9de0e4b974dacd34bb78ff3f4c5d71afd871302737b7ac4a1b03369fc6b809491a5c7356f4a24475d9c9887581ebc6324a0391763d990a82b362209477254582b00b9324b448a6afe5ddd42bd742637d3b56cd37ad7e95b7d6e43cec836a98d5f4079f1a510cd58ec56a34c7244833287a8514eb74aca3943ec906d3c2ef4ddb6ad88745658aee80d6875ee33461c3c1fbf3ddb602adccd9ff1a5e4fda06b0c1baa240db8080de9ffcb84ca30aee0f622c4b5f964333c0cc9752c9adc1f55bfaa80a4f0a1a1bfeee58842b03e1bff9653c2a2bb2384c282bff7436840ea8e6a1845efca74644c97493a7c274e81ddf73380547e0d1bf628bdf7b64bc95cd3c9f0363e9ba8cef52d3c3edf56640e464223f0f2291653550cf3724ccfbb76924567a0ac7913cef3141167f14aec813cbd2256bfd537cf7d92c256f93170c0c242f902fcf868c43f06d1a81002e5c2fd63f40f3581f05a0a068b821219a13dc79f9410dec5b8b98d3158377b012d7a495a1c18e64c0d20422ff411b5ec1296d0b5d34d502d3100b2223947a14f3938ed63e89b367a28fa5fda1ed1d3bc465b0a3088ca5229212a3f4b849cf9d65ff34494b464f3567665557dc21a893a6ef957670f4df02e02490c72a537288aea69339338fbaf4a462fc453a8938f834353feaeb1214008febb646226cb7c90c1940dd127a91729349b6a1d6a9fe4d11de67436d5cb4f36643607ae7117806b0569fdbee7e960a4e1eb0ebdbb2d80e844c82950c604cdc91f3d060a940a299ec8a3406f14297223bd7dd7104bbff76a8be4106afb8bc18faef5805c62c84cc684128fe7c54f85392130213a504a8269701733d09fb97c52215d7d4ac8eed91cd7e338a668c96533f4fa48c7b06e76ee487056ba10602fceb114d2acc98878c4f71834e78b6d97d51f257781c2e223272215813a1de12c29d0e934c2eeb577673eb685c9fdbc0f9d713b374fb194d3cf0cf2091c9d32840443ed0615f298eace316d3264ea79738d5df17834f6651aeee0ee27d550d61beb0371c05a0c7f7ed61dc8327dde7416b15c74a3113809a9e71f0702e1ae69fcc327e2f5ec9c9d362827a3d6c494bff7fcf7fa53cf1a5c975a10d62add947771ca9beff67720bdda2bd816389d74862dbf916cb6f58d59dfd5c3620a84ed6091c2b9a04b82691e88aec3d25e13becac257086113483e6acefc6937c9d22b209f2946098d942c94d79fd850b9b0eb728a1354b1d8c5003934d7c9aa12633246d13b9971eaaf753516bf2af0178f57279e3ae439a37e990ab3def143f8fc0b79e536efc3b020746c453d5dd1ebf2886267060e2c2d42ebb7ab50bba48bafd651a95b64271e5a080f84528ef93406583473212445b674309edab6c6be4aecb855b4b6aaf76f7020bad7a09c2a8a98a27f5d2bc6c983439857fe2fb55f4acb9c4cdaee8f79e5e021cf462e6272d86b403482f47278e69e38d1a1fa643522c42876676e88c0cf6b0e2b553079f04d772457de0950a7a396591ad786356ab852e79fc1d0882dbdf087e03a57e87049aee41f32edde59d28e918b5bac692ec24d3645a6ecfea801142c6fa6af271615486d7ddda1bb2b37916bebb22ac54d6f7a578157aca079eb37f09ad6b98b64ae4e315d4d754817c217d2dd8cfa9b6ed9cd372e5263b68e9715c1d8738f8ede76162ae4c93b3ef82d4ba9907e9db34b62cc4b7a0a9f07c8c49e352d5d74064e2f8791f9782cc05f25528da264f28b4f5b4f41cd2252fc90558ba0318459f27b4a2ce9f4a98b95dadee7c6937b4b279883581e1523e86d06250502b24fa8ab12b40abd1c078da7467f0f12acc6b4eaf69c27ed0ad3b69658f9f3e307d55a1d4975adab385599f142d77d96838b49c58c2389edf38afa7f9e2b165fe316ba76e9b27f3d1b11097da4f51926209a147446ce0bf3f8338d3885a3e011d6d6f01002d238e3ca3cc0ef45c0d1c98f8e6e5d62e6330447d03338332fcb9b807c8d0a33258775d45b4df6e23770e55b0b13c78a71bd20fefef50de4e2f71389ab9eb2ed70770b17997cbaf69980f9122f70a0d5d3e889adfd8335592f7e2ef5e4d6d7fe0f9b422f48fbe896c3468f8e731900db0520bd23f38776723673b5d8de954fc8b5bfd190980c672858e7573085dacca049e87a75fbfba7e65cd28c82cd086603f5e289ed98e8cc5f1d94cff16117358afeba11182a63cf954485321b9915030d201e12741651394b48075ea411eb6c3ea00f1fdc64bcaf08c4ca26bae41701a47e88fecb5cb81ddc9673c3de2f65c3a8fae666d0cbf821f2ad2ac745f1d023bb8e238f9929029139736872145e7acb1b6ede8ead9604a55b65ad3ecc2242da81d4f9e178ce7c203ac4581af5097323d32b249f43d7b12c0dccc11b030ba849607ece1a22885467a5d7c9bc0fae8646f6da15a703c815cfc4c4d3fb3297c59597735ca375dcc10108792a7a49cf129992d450d4799ac6bb051cd93ee20538cd55257a00f65d261941dafcb592a41f5e901d47f457a2ac29890d33757b7b2d42d5e25ef5886d1cd189b09b6e34115f3ac36e0d932b424e8fa7fd9ed05da587893257efba843c3c5390fe0853dc30532e1e822bd8241489af2552b897a87efa52a6c705f111b4c4ef8d020c798e41b39cc646a541a8aebb3171514822aa95b0fcb4826cdfa3de5dbcdab3ef1f6b68e57a2c11a597ec405ed4c65da88e86287af31b98d4f7d0677e96e6fa91dcf2de11c192834d1fa4b01eb7487d3ee45ecdb2e0a86998d955b433ad562834cc8ad196b67a29ed10886e418b0df0593512632e6a66afdd8cab369fca25eef3a2099c54053fb6466d00194c8499f7df962be00a50aa521c4192745b09187029eb1ee6576bbd7724f934abb62af1a0930e6d1efbb7bfeb7e615dc5123b0eafc9520553fa60d2116b0e4e7ca8e2f90b3ba718eb8fd4219e9f3e5dee9522bc038de63a4d395626f4059ce8f6f426ba2123f9fc791dee761525554c5eac683c09932376f039b6c17eff4922bb0fadcec3828090264f3a6e7d710bac111dc8e887e43a34492e9fe0fd085c3c4b1807b3de78d27f98d066ac4007906ce5dde8e0d870ab0cf9d034c463782c64803f2a1796f67d11edf5d09936d7d1f26e30b2d508fe876371a10e14d553ab83f019fe7c419a0545b7ff4717966ecb1d985127578cea271dd00f5bae8dd5b39706afe521895200e18ba718548943c0b464ad70565910dda549f10dc6ae1d30776c69993991eb148d5d1ae5041b52da8edefa38620a7781e3dddf628c80fa80a58b5c3d2e208497376be34ec5b5b48037d423de03a982cd37d77ef4e13e43e1a078af49ffa79c7b27c50b345dc54d4696b0189ac2752a2656a47db87443cfaa605735ca98c22f4a1eb0d14ceec36a641d0e741ea29d0920ab690075acadc35cd376b3de9655f1d218c82b8b3ca9598870e679b5b2340802deba3897d51cb267c7e6acaa4c205f20feb6de2142402d00d398f86a416f1213c8a0c602db280c91ec749d56320f4f3d5e980d71497687685922e60bb4d184a43d270768c545e2ca11cdbc48b3e167c2f41ac6bdc848b25d4edf7939619eda4165005433fe3ecbf5d65a21c7a1190f28cd12d98f9bc21dac31b284fec55216622bc25196361a50769bfa3fd6a29e0915a5c367ff7ef58dc9e6e9c8a7f8c03fb0f0b145f89ee87ac6ac11b30bcdc40a7c174a2ad9a323d11f89dce35ecfe23c0a05432e9fcab4173513ab42cc94c24ad7e8b36564dac1428f0493a4e4add0e7d0fb630b5503c0ab60d968f2e8df978cdb75f4fd2868fdd3e0483b7b7c74ed95585f83c3add099f37ae326e07fd0c16fe7349bcb3f35fe70faaa4920c78979a77cc5aa081e623236cb56841eb5545c4191a96cecf36f9893f52fc349f9ddccd2fa57eb4faaf3b6c9b52f5208ae863b0ee65e0220d8c20ccfc9cdab586702c18903723f41e8387939cf861bda9625bbf4d77fc706fab05cbed83b65dc48252fce871ab01db91df295149ea3182ca08f6a43f1f1d6077ab9f22b72dc67f8809ebb0cfb24be1d3e1b85776cedaa7b6e7f7ef6973f19c54111e77d03a43dde0a3bc918f82031a5730b6924384a16fb0deafd9c370c1f036c6ced7cc6478389ce2a3ed3ba9171f43d7a9637eb7c59c945a45af2d241770bdf0bb6e1082d0f64c3f01cbb602280f73199e58c7386cda95440ca5914d9af8ee1314fc5b388c536fbade13b99d52767314447c12518af228a6f05d751a509761422eace69983b80650a8a6f1e2fae06567ab45cbf0b3fa84deeba8ddf75d8b2b365dd2a8cc87019f5671c864336dd90b0019b6cc785341de688d14d72f2fcb683be5871822719adc135e8b8e21bf967b943cc750f333b26e284608ae200c2aba7ee1be015f66f19d051ee113e38c4cad8f73c86cf7cc6cc42cdf5b872d5951da0b086f464cd90def6b7e41b48df3f309232f17e010c2b292c603aaa8dece6bd35b1f2a520faa8607c70cec7e31b2dfc4908b2285fe285d4e5a3a1d22c573dd14625617697e277969ec5cf82d30896c1dee1b43722eff192120e5a9cc3b6d403694cbaf39fe9eb989fcebfadd3954e79376c9768af87ac6f978843609b27c164b935bec1ec46c6484ebcbbf41e4b6b230d3b0de328d1e245c81326b90c4ba90b8bb4f33552214dea4c6833d7fe1bf9d22230dd3fd44d84902c23013607a8902dd660604c83edc14a5025384fdfc89ffeb642e09ed7cdf2f4feada0d47a1318fcc69656c58e7dd30ccd36c35759d2ff48b9120320146921ac6ad5e02b75c37461339770f2a78645992a2fc4037379fc2802ba62264ea02ac7310763223a1af2b65f779f454a4c418445e583619986207db8380d5bc880e9255f02798888c8bfcbfe039fcdf67a91cad98171212bd17d487f346c090919d46f448f90a832f81ec6ea714ba844209358b9713d7bebe133afed0a5fb97af2c7e0fafb597fa2564024635e44c4001c1dd90aadc79335aaa6594376adc0ae40b17cd8b64ad6f7a00c6540a2f41e0ba84c80eb388cef1d2e7edb742dbd4c1c536c98bd6064803a31351387b8eb752d903bbd2bad35959486c3428f565d622bc2d5eb2c1706433fb0be034536cd37440160313322c515c840493e32791a8b8cc6a2eb31493f8577b91a020cc6f51e996e65b519e8d04bff3d8a0a89a1ea3a8169f1244f6edfb86146005d1c508b7b2c7e5a9075b30f21fe9bcecf4a7b963113be9c019c54708007c862c0e8dcb9cee67ffb6d3621e1947bff15c6b9c8818a5781d241be70aae9c1c23262e351e18ecac6662c189caa5036ec4b8ff2f75c7da3fcb2db33debb9c4e14952247c67a39a631ddb6c172736e86ff432a4246b8c4ba1d9961597c492c84b7501c414a89b1f6ef28be7f4d1768a7564fdd8e27d6f4b7919fe6c12d650119516fd57090e918856d87a5a8bc5521e99f11bbc02c315011422ff01ae20c1fa36e98cbfd81ce40c72f2d010a1fb494fa0d26e58a5590fcfa52d820f402e718428fb0b09db834819e45553687952852ec9e577bae0c335aa9d0e76921d3c8e91309302f2e7aee4837ab3500805f366f5c9ef362a6e3044d48f1476eff995fdba205654fcfc579ac19e96633a76b7f9540544706db4b2f20bb75781aa45a0e0e8645b0dfd198c81f47a767c6ccfa5b3e308fe2ba62510f59ff698eacac33e0a7de7dcdab60ec4908f413accf9fd4db9c3ad61386944be7a21cd1d91ecd62dd5191578860225c1ee853b506c2a3ae529a11ed9ffc4af62212a22be5adf0c4566ab125c5867f25222724746b57c837ad4758c5e05e783a90cff8033ee54d177689040d3a00e06a86cac0490a9efc332431a3ddc6bcc9051c9c63addbd4859f17ddce30a4af7581ee373c591f78eed54898175f61132d9c248e416843fc38319d1fc032a039d7eda350770dcec760008bfcbd7e544ea613369e353586d87fd944c983745b46fb6eed12ee22ef222b78ab95f99768f1016f6b2f0b2a827f24c3d0ad759fa3d4b47081e3ef19fc3f74903b8ef434218e1d9f8b8e6b308a2b990c1d526ad50fbd4cc414b50e180189d55e89aca49496631dda45d0a924e7ff4dd72389f7d7eb4b84c2969593e14c9a41a2750aceafe84442e650a1034dbb5bb7b9e4cd55d29e7ae0b0578ab342978cf2e57922307575aec8f350020c83d48b785efd4440b2c46330ad55549adbc4fd5823927ae1f1151ca9b5f3fee4c45960ffd9fba78f00b5fa2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
