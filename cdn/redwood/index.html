<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19ce70ad962b32b9a1bd35a68b04726e6c4a9c0499b25306f81168cff8d0b1a9fc207282c9f1721aafd4dcf62eef4ac0d1010fe179bdc66c77119a7e715794060877f57a6e1e4c8b446038ba742a09e16fab9a6c161b0a5caaaa008a8d6a4c335405a2ecb304752faea32274164af7f99991109fd42dd44cd8f35a62cfd9cb1fe904cdf3e507e3b56a4ee34974caa61e2167d69c675d6dc822ee439636f9c7d3706b90c702ccf14800f406ebd1575a9fea2113db80cb0892b286fc9d5a2fd9792a885735e896340a08de94266934165f52475392240ab836e239652ccf642f24f5a4abb1641a006b396db7433bc66dd1db620467f45ad88f940b4d3711e5c1eebb54184240c50e17c375c60a6a7e360d6fe86ce43ea9ab272a9e84c1dae15114e82af2ae130bac7710e2cc593b2d5757783ed1dcea930ef38c02e7ac22ac9ea8ae52c9332b81e684b62f4dbb2b9d4df6d22b1370a1e56c6e15c2832fa2d97c19d53f328fa96ee5ef374a25ef709f70080ff097337695abf5187f7989c0e47c1addd2d38f43a10777efdc57ef4ba98c65dad21fce228d508a960653ac9b13467aab0a803be66df1df3c76b22ddcc59876500e2704f1f4a9db2e784e2d6a2b83f931f0de9d0e6c65d0336f28ba7b1027fb32b39e21ac8b7300a94406fb5e07585d4fed8aba490f6c9e63f78080c0119aeb369770b0eb2cb2a623dda8eb437e993e86a47d3a43bc813294c3aa914cb4e508ab94d498b295c71ecc476b98035f3b1a4062c833ab58764f9991e2065ebcf92dd23103ca6a8e7cd5ade635b803b301878d677c0945b19bb7c358fd9c8cf92c42bcc5f1c4e850a6ee0a23e3c9f483fae70f261c23fb535bd34bdfa8066c4883bc4cb4466a0797f9751c235cfda16ac23a6210039aaa4a4f5949cda5e8b178805e3d98069438d881157c81790ec814f2eedd36cecc0f80cbb6c8d740b09c1592415322f39fe10ab98bfe143312b54816702789891e239c4adff8ef8725087b6c167d6c688f98dcf2b464e229206d5fe4842a9802cf6996bcc9f55353f70f11a4dac471221ad70db8310e8dcc9857802c97095651287eba7779a2de65cd7844e371f6a4aa7b5963391e86aeb653595bf9b4b13e415c253dfa7aea31a9a13e41ab1894a2bc70ce8d25531da0f09131cce2e43da2d2fff972e2b29c7601a3c56025de8b85a3ab1cee1b0d1ad35d3fa9d66d38b03e4d58695e18e6ee4161a55b1c94f93b530b46891fe51fce30aee67a2a29e5af84abfa269853ca6bb67131212e29c2f6708a83d47940966fa339e0e4f3f4f408b646a3b12e96c6254fe608e782c4d70217f5da5279fba4b2484875d1425b057389dbac74cb40a46db5739ee3fbf85f7ded9afe070488494fd6aa9f166d7127e767126b55193582f90109377cee9998090e6dde7da44a2a810430e23f00ae6576eda384bbf84e5af1487a8c3f6632ad6b48e385babfac716d5a10488727160dabf6a7eb3092098d9f36377aa56161f6f42f859bac5f01bc0d6b532570cd9f8d7219aeb65c9e16cc7e284334be7b56a9ef262db8ac0b9f9fef5cdb8cbe79e690bea2f646ab0773261019edf746e5b2ede357f3c5315fb2d6c84c9bc81e1c2b8a28206c16e2fa61488399af00d37090e87a161630bf99a4f3e7971249abba5ac95076185d84c2296993adc47262a671d015640027634520e4d29b1c23ed5c5d5e62825045143c0f478203b03068c69fbecc946d36d66bbbd31984d46cac3115e549c53c92ba9e5c766d8ea19d2df23a6fd8fb5e4ef6ebf12a7c5b0302f8b01a9b010f3ddf14aad082a5aa15e6002443b346e59a567e1d83b9669a8e04f9917617d54562f45cb71d896084efe3120925fd20c3798123530da94aa78bd9dc8a9968a0bbd7f565c2f67ccbcefff300294628df209433f696f58920768d279c4ae30b9caaa84608d9990147d8dbad225d98bbc6ab4c51e6680df446c50dbdafdfc273fae51d0a65690a5b05431cdd8ef131b4b9d3a51423e175c3f976b47546b445412e3d1c3368154cab6f3441c8febec5c741a7ad17f133c727d2d6f453031dd4045418fbe4ef5e9e0ce3dc94bd2aa9988ebf7bedb9af20ce75b9f4ddc2dd42d4f99c617313a937c797113b4fe9a4ec3a4f5052c4bd56c648b126d214a0f83760260b08b147992c6681c757d3eb43e1be4db7314b1c8eb63b531a6af78bcc10a9aad3549881036b47d59b95c9926c9327f115fabbe54061cb1c2c33c0a87c59d50a4d9902f2ce78c0fdbd2c729b4869840ef9794745e379537a50e445ee49438de1d261631a88c80c7ba77ad6f850a8a2543295263b57ef77681d32e2c7e1353ce66837af391f9fc8566c7e5c0cf88858d8f9703697bd499b5fe706bb1c3678faee6d34a798b830da398783bd44a9a9368047b1afbab307bd67782620aca350866b83b5cb3dbd6d31113dec607f3a16cdc44f5e29db1e55b5ad1d15b14f2661a8b56bd9b66aedd6d3e8daf6e319f041d87d2d73020c6e7292aa6f40756497c9638689a3e12c7dfedea80d95864c602a1bdbf874d5cd05e72965720e3701ea1536fd6ed655a885020e03c119bea7e27e82fb4ae8acf1530ee0d8b6c2b64a3f2ab05598106c4d77b866b70235f142a4c2c17354f3d00bfd4b8485b4030d2e58f157c34d87e3026c2614df956ae7d772d504be15e32bd59e1f4bd875156eac51c8bd3f8697042df897f8547bf0277eda150047e5927f1facf0bebfa4ece40b491244450918d01baa38674442b0adc6cfe28c6f1c75b2dcc004c85fda35be70273758dd62200c69144c6b9d0566e0e7b62fa103795cd472d49a133265b6a724cb2cb3f8a9dcd2841a7fc72312359fc3f93cf6fced3dd2455c39926ffba04f9385ec3a4768d811c38c8a3195393c672cbdd9220ab626d8708db794198a84d50b45b7323e343dd0da2774daf442014294f15af63afc56489c5a848fb9c8a6403e773cfe5300b3a740743f387e34f764578262ab907a2637d8521304c5c9e10ea8149b594f2f665129abd1564e2dfd300b8105e371c2cf8a97c6452ea36d48d3e3b36e3cd11a71932628596b6ce7597076783928da47ad8074d53b2e3eff49f743d6d825bc18b44bd687ba7fb524459ea4ced2f9c4ea23df98fdf114d8f0693eabf125038ea80fa0083e07331a23bda52866ee7280bd66eb00314b790b7255c351ec3e7421fe1766f68e52bd9fa6cc4cbde4616599eefbab0451183db9e2d88a4b906f0d793eb084f7e697fbc3d479a0dc55d93bb20c54341c33f7a05a903fef5e79c94141fdb9a2295fb946dff8a61d61afbf59688925d98f46479dfae6acb9a1d2ede32b1193d02b2dea3634b90d358a3530b28796dcbe5c1a904470e91256c9a476c391bbe0dc5b961b7b80c35de3e168c0a029e1386b53d012d0989f607f52f55d5271ae8f7ea7b993f2df213e01686f791c62821643c45538c7209eb8ac3e8436497b1ffb758ff2788725a898ee478662a36170bab580320f4d2346153a0c94c9286a275304a4e5eec33acdea240005a83a2b47891f42290301c1492c5326672fb461b0bc46171b90c439014c1da493e546e54321697312d4a546dac983ab154190eeb1b52ff07ef444f29d83e3f1fe552e810fb4b656408143c18e7015b65314d6975af99c8312d14a820a36cd866a3f39c9256720456d8af46facdbc8aedb4469e79a1956d7b64dc2261751020077029f4481a37e57a7887e19056cf126614b785f3e08841d2162352ab81b3a336e5613217277eaef737e0fb294c7987e2014db7abdf69c1cc9c91d9f60db7314c7de980dc2f6bde64d351c86a24bf47d15f821d147c376f81cfaaee7ad7d09f6ee84433fb84c1c40c42790971bd84dc4b5790181ee3d3b2d8335734844b27b81f4880470e3aa1b42ab299eec4e4beefb1c02f0c582bcf68d5a40910d47c473f7ffabbc719406afb35e9b4995de5523b2f308571a9db83750001a8707d8e6a77940bf8c75fcb2462f5e077a47786c17a2921c9ba3bb60b6fccc54a4f344e7b39b74b93bc5c01f2b5c3fd162f787a31a29a974ad07ed8e42f1255bbe02a478fc2efce6f328d6bcba3e6919337ddafce98d6880f7a833113a47045a53ee9a7cde4202c69ba13902cb9dc0d382eab66ae1faacd551bd9036655e02896d169e99b9d59a68d0174ea2664075cf8a14824df63d03cbef7e55c9be29881e2e4e071f21c6789ad3fc3afd0be32fce45adde849f9d1792bd399b444893268de632bc7626cf841d7419daf7f655495be5493f5115fa6e098a2b3bff799edd6a7e3c7542a624c8f75fa5caa1d9977e2ce893fd60661b27feeb04f4c4a166e2e207d3674212e2ff06493452313be7abc724ddc07c14bf8bb95d51b77646818b4f953511ae891d951884b2633427d6e13c8117cb00943f94987a0305c454524e6fac5f8d5d8d4d63e04954f44b12597e9222cbdc0088db04afeaf3dbfa92d605be445aad3201ee3d949727885c851344b58926bf132910821d690ec8cceef2293bd3c533b74aa330c1606307a0cd16c872cc08070525ff995c7a62fea6b8687f056cc83ab9b7c5d082a84faf786cbfc9f86c25ce04fb9d07d720b1f35a6e8c23dafa42e74962c7cddaff97b1879df193e9b25bcf4175cf84f617dc319c41bd47f3ee8da18e56ae5b14663c6f070dde668ecdd3867a00f194757e1b83a10b26f1070e6b467a428c82131471ca60a3ac1cf2856e55c9d71f39c661338168891552071578f3a6a14da0b5fdd1ce53fa4a6c2ec0dfa38c175812f4453b7d814c985687d1194efeb39eba6487bd49bb62b723b581fe3f0a83eb0d8d113854c55a03434e73cd04c7682e2ed61a015834cc69a0e59dd5ec86191726de0d0f8116011df68242b1617a86c6f577ea99f265ec0da4b7243666bf7f0d718bd3f182790156479cdeda650f68a65d773487fb476d11760f21843a97dd97f887d264f605424e6edbf2fb631db6386b8b3f6c6b646bf3bde68617a925bded7d4db903d4849a3bbaa394cb3dfb25b4422cc408386beac9af9c28edc9f43aca25830b1c632d73b546936713f51eebfa6ba5194ebc5bc83a4fd158939d2d66a6c7562d11caba43e4cbf4ffbfc6115c62c4d5028b3d476ea194359fee19d819a1a34ec20c55b58802ac9885a2fe2e795c131884073ae6abab29c3e1185143f2aa294e52ad8b9f051842f3c74219e32adf0a700afa807663b24f1da7d624ee9b36d7e967de83e413450d7924609145ea935a5d526f12aca107179a574589c746ee855f5d716f83ec5624ed7df5442c2dac8d6556cbaef608948b393de9d5c28eefeccab2c6b7c92ff29ddeab6ca312a9e6c8cb916bb4c28a2c37129fa466601d72340642262f1aeacd427d2bb239199b8afe941c508b98a8aee73d271e9fa25940c82a763a8e2d17c451541cd685ccc390cad8a8d0da71bf6916388b7c86f8cc5fb09fa778ff4c9c271e0498a7093b99046193ef39c15609cd104df52636680bc94159dcd2e0c5f4fb09be46cab0ab833ce5daa04c51a7c3e86defdb43d0c3b1af26a0573599a781f7d54aa8f51e82f7a2bf0ce99aa94476a86352b2da30c2a404bb5f3e68f35c54cb3c03dd4bc47fd24d4da73dc8a5a652723b4213d1e0fde47c2b438d5def100d39ff636ee3549cca26aa27d446aaadb009c787f91764ced7875ae835cde7534173934bf2861085d8a694965b1f4ee57f6119c4c6392a9a679aff94f10eae9a55ae2f6242009104eae0d29edc9c8e6e0dd84b05e091bb10fc3bf205e5e6ffb0a0d1bf6ee4d6bfe713cebf1eb58631c5ef072c4746683f9537d00de156a1dfb199c3406baa62a2e785ffd4b51fb343a42858cfa3c12dccbd5f598102e97bedc2c7a873436c17e672acf36e0a4ad04c1ff3e7aff869749101ff5a705e6cdbfbde0fa359710a5978ef21fd9cf675dcd10656df1d006a1f21605fb613f5471d27ebc42accb7a9bdb132932364f8fa281bb6dcd44ad56d28371a963eecb072ba3a3fd5d6c0b3f5be2df5161a4b7a251e918d03750c0be433d5b4bb8c9a3185865c8a92d70657a7d4d005eb6d4d68f0ab4a482c9fb628e829f7727d3bc4dd7f04eb42566e8767433d228466a81cb6544f3d68b1fd92e8cff0727c389f13e6a0d5ccd5f54656f4abc5bb0c0c080390fba6c4235cfcdb61c012cccc4d82c7520b4e4e53669ad72883df1796678eee0100ffd8751b81586e5a575c6eae53d29e95b58ca687fcacb91bff8395ad8c096bd9f6f4878c2f0c917e0442604bb5e6b2378b91de8f62ea79f5d86e0b7516820bd12058fead86b37742dbd7dd78e8a08382398008f186465cca87a59e9c28486f03dcafbc98d56bba812f8f522a3beeae44e4a6cd08c9dfd67e65459ab059351cd0c071656098798952c4d23d435c85267db38a4ba4ccb57590a4b935ce6eee34cacd68f09fc6f07351c20abdb267c0e821b3820a6b0c81eaf286165b03bfa11f34d480c520b977b351f19b0deef8f923b7847e3124800f30a9c5a7660967588ab624ec38243a9da3f792601d34c67ac240768d0373cce7014a560b884dc89ff00f73cf568fce94b0aa9ac4c8a68e29f2553af68d1e9448e2c458243b291b694bde97c008f82124d049a27d4ea3a33b448c2e0a7ef5fb5f122c061befb223e917af6f818a59261c883afb05451feae494e69ee633cba69cf8b7d2591955c9c955f917909ad53ec6e1e0b75dc43e79a23bd5c5107fc7be76a79ba2416c25f07417ae6f88369393a31bbe90c05b97b416797a03bfaae7ef971864f12315210877f554f595c01d5bb665045e5c2117bbe09ab2ad44bfdb4b1ae411483897734837fc3cf27f89c4f77a4a15269efb4c8d607dc805eb281773460755f0e1d1d3de8137e4eea5f6fd121da451fa9a2f55ad0aeafca3f53b4561136b8bc0d40954692798982276dc6210cf8b7a1b6ec6c5962805a4436a0f0af9999825802aadb92642b7db64aaa94b61eba7799d5fba65d6092e9a2a1a9d4e6425f20185cf7f08041dae9acbd16e0a2e048d25748599b9ef020f7cb6258d187f4296af5dfe563efa6e7380aa9d3fe2be5b8e7c02e8969023be1fd89686ed8f202bd80acc77e201dfcf005c71041da4bba39d370c4df6536a8e79d45fac6b5f33c3fcb46ae51f760e3e83b9982ca03c94bf4eea08bb6809dbe674b45922d179b0fba9e17d5a821ec01bd24fc2896414064a837b01c80df4d8932bdc0d32adbdbe839aef4994e03222466559b7af26f285e2fbfbddbdca70f0bba1032e0864adc9b9d2ea85b33dba4006eefc238a84f1e2e28980d209e1686d26e4e5401f9e35da3be36da379c7ce6cba698abef19daf90489dffd95fa72ed0114237e5e3164833b01fe9500ea8b37252b213844b4056388750761f80afefff68aacd621e25a11ff76b3d17da7867fab1deb8b6f496bbd147ee91510fb22103784bd129f18d159ce5ac9ce9ba701a116101f4049c660107a611f4d41176bb3f67fe0f77cf413f9579af08de9defa669c9289abccf99426d0faccc9157cabd0e0005d10a36b98096695f966d71db57e5966efd887f96e258216b9e39a752307d251386f359ac9615f5f8034ec56eaae25df11ff38b3d699f1f2215900b90958baefe4458c3ddfc0f22d03ef7974167f1743217280813d8b94dbc348f0757eb32618ede668ae98266a713a2ad3c0a170fb74a746d7d45f72ecd77336c90f259c69c29baf623019453e680a6a0a79bff9693c7c4e14099d52da2614556c8d93443191144d306bd2ce5fd16c16e0e49e11d6d75981a70712b88501da951fa28822f4572399d633183d222c784b850cde3b3b5f177f46d8327e21bd5132d3a59b364ce2cf714243da8052b3e407febdab3ffe4a4c47968cc44d69aa3cb3bc703f468d518d73cd728059514f521ec9609739e2b6ec174348900e7338dfc7955cbbebe11ecc871421f2b76846bf36ae776238a5e8403632796b0f8b2ac0cc6ea5a14f3ce1961eb749e871af9ff8115babab9590f2bff1c2afd6cffa69ded4a5cc8a25cbfb143f46d43020f522eb776b94628cd159d06ec700b3c4cbe2b8c64c3a2303d2e905d32e4c9b48860aa5ae267bebc3410650b8e8ec46eed56aacbc13e5f425f76127e5497221e4abd564cf5555e16b34491f454b1f1b212a0186c5c64f8cb8ea1ed5f034f40c61299e713e9fbee138df070fb4d180cfff35c16826a743e9b2d0caa2f61d756967749859c2150e5b80a4acf2762b297b33dcc434b811b3204abea5433726b050fedd3ca9266d7c04276d1da7421ce6a2132d16fe6fc2dd910957d2e81b212215b95aecca852a709a412764ca12a43f50a2227f0166ec2b35056c8437327ba2b48c2ee83773a38fd10f857f52b8a4be5f98a9d59eec12e6e2ff815c1da8cd11980aed26fc40cb4d843c83e6d21bf4d8edfae81546a10644e27606526f5485a4b98214f2c801303cd2fdb91c0156e15deaad554d481469ade9b6e572ffb254e993239354f0e9bceaa0708bb3cb27b2215214bbb0f1e3e140604628648001eee4471b906c7cd8e1d5d3bdf140c6f7fc9c41fad7c430a996fff1018dfb6f300d5fee8562eaf0ed803c5fea0726742edfbbd5393f0329cb5b3073f545a9b08f8ee9c2df8d8d945c9b4cc94438fac0c9520bf42f9096eb7027696a3f97b44baaa9b1d30f9de8063a20cfe27fd9dde82f02949610528fa9218139890517411b236064ea34333402ce85a118c1a30b8b9a761d91dc178fc6a2b22b697f8e9e61fa6a4abbc36276851a5949af9e1db14696cf388a56a3bdbc5a0f991190b17667ef7d26237a4e1128c1411ac91b005477e0693207560bdb9b9ffb88632f32f8d762321dc763c39687b41161497e06ec7a49761876085dbf134baa5cf16a0ea697922d063a7ce94f28fbe83ecc1680de83fa8e129e74eb127b3e127a545c55850fdc31aca49d3071ca649fe0d1c76bd7cfaaf2e6f4aa69092532a448156ec60e0c3b71fc75eece1edac944f4ed682b34c0300f98b989873fe13dddff96259ca3c6f757d83b08c74956d9d0e0ed822445d9f7831ff1bf4c4ee81017255005dba090a6ef8f0d0fa9af50d5020a60c9c39eec564237b2864defceda481ef7169815a63681c33a4c62afa0ae7e1319c484b6042414988ccf45350f64d2607d2db3ecbcb290a9ab31ad78cfdb98f05fcd81d06e611274fa3a217cd13290aa1fbdef0dfb577c8ed72cfa719fee6508aef425b08b55d6959fc8cf314c1b0a8d228723fe52e0804cefadfd5ca210b189ca45e7436faaefb6dbb40bcd8ef5b2f017be370952df2482cf353e308c757cbdbe25e61cc345cc7c2ec27327de173a55b44115d4150924d949c6bdd9b15572301982f7cfb1fbfd0c39ad5a20a31ee112d900f7677d94c4a3910cfd2860c2d4f772bce0af4f2ac98bb9cba740c810a7b33c48e8f295632cdd1c38b74a11c4cdad5cd19465c8f7ac2c69ca24e5625d42a18519ef851dd970cd8d68c9050484ef4a1f36f86f12060cbafc83ca3813c93168a931eabce3db240807690ac78d9cbd6719930f1bd47a7b1b261ced3be4c194b6f4e00cc66f16b10db5d43183a1a0a522ec2884489765ba6035aa79919491a14f998d95645d3838898dff7ed9513800e574ca9d492d119065027e922fe779d2c7df8278e3cff48f7390d0ac0897d4f95fbb32f1ad0ad4c3568ae7d0f8e55a0dfa01144d60d3f922ed8eaee451198ea7f4ecd9d445a84d18d8b533dbcb3dd51236b81d8d2eefa97654ffebc6c6f03b7e885c73c6a8e8e74e0820ddb54f956c7cda677a5b8db84e17dc52194a8b5dcd4c219a5f3b2a9c85c96d28d7491d820d88edb5d25bdb321d9f2f75d7e0cea73196eedbcf4d1bbe3f6ac1c38c97ca3d972f15c48041c0da90342af7396d54d8f39b7e6b1706534c95d62f82e82e6894cd029f0fe167a643da39e25d34a7cf263661f8e05da217d35c393480ac7e0d3ecb3bc643cb95b1d53ba608fda9cacc54b324b27a4c94a8f0c7c709b9d2d3352e7cdd82e31878eacbbcf0a581fe20e30b7e275f3aef4c787294f7833c2a16b1eaf4cd26d7b6c6334643ccf6b92887322f3364b6bf20f8bb73e5456801deacbeeeb1b19730069a244239c5aefd60626524e107e32caab1d19fd2dde056fd9a282052c36cefdc3c358815c80c217d80b09949b15d94dc97184a8c189741218f1c849f3451ad30ea65d23654d0f31940f22ab364f86dc75bc94d987ce35e7aeb49d3e578d46dffece8cdc3ff82c3c0435ce0496cf060ceaf6eec17dcd89472a6fe1048fad2ce492c07df10d07b2800cb849dd0d56e341713d942875e1178ebcfcae011200e2bfd556ab6021b654effdf0eba96ddb0e9ff0e7ea96d78d0325c5255e4820b5c794829bc4394993e71652a146598fe737dea358460f66b2bd854acc9332631034c601a83d8db124edfe688dc81f1fdcc22e4a7cf0c5c50ecf4cc3024a863a325e10ddea261dd02f8f77341137f29181dedeb853447802ac8812fa0b5db640ed62d983571b6777205db118068ca2d8ac3a97ad5abc064011434ad291ea411f55378dcdd7dce8748b484b8b6fff09814384d24d3812819df430e7c66d2319e4364772ca1b2beb40d003584edb80b979182cd9efc92f30a98e5688107c704d289bbae0558acf2d26010f8140df9bd364dd2fe47b4f33293469286f3b4fbf1158220ab12ee03879da8df13e3479e2ce52303e796e30807b43dbc390bcfbac65e2a02f34bf8b2714f392d4849fcea16bdfef5ac497b9e368c5f9232637c3865c46f3a9fc1e5aa41ca2f44394d88eb8bc8c26ce4d3aa38c2c623606c143803eb9437f991380acd34b08c51c0be4910d6acae1a07bdc60befa1d1ddd8b5aa353bab9cadc9785e11c7bd5a9cd51652fe67fb7df102fd8fa6cf753d1c8e7424dede2d2fac30af823ba9ab93a6144873a228d092955c63247052acdc809d120218b5d582d0895112b73855e32d81a4561002dd8c7bc0d45cffa79628f0e1ed60debd7d418b5dbf29fae09beb6c87553d9504b66b6b17c94cc9bb977673c4a89d88375d0f774fe0e9dcf46c78e52f83f900d5ab3890e49f7af7934e484bb4e865447672bff2ab0c4fcb0cb27c5b961f8f35c7da00f628b2ba6b9fde9922665f39d3decec7efe7dba3835d7ad802987ba21aa0d97cc44dbed69d2401ff5856faccb9fa31708f30ceafa059785ad56bc178834a8cb87741487f3cae909a2e4c1f8f877ba3297284831dff5a3fee386ebda18359dbfc7c83f1c5616731cae826218a1c66b7e9718f4ddc64a616cc093dc40fb38c447d38103d4180860d35ba330906c2e6f7f876abaaa13f261dd0be599faddfe40cbf71f876ca071663bd165d4ee4aef165d58b8159af3e91679ae88cedd742cc3dabb0b81e109fc1e208ac6a94e225fe5cba9c5f979621059a7fc419ce6131eb1a811cf441000623a7bdef97e5136869d6c16e25fe2d572dc7fa2de7837c6a937208d1f28e53a818dd84749e8e99f722f9a71b06330a861b83ed8f20264c41e3bc84e843ad40881d7f01884e75cda4ce9234868ddf1942a1897562f3ba7e18c585743908261bf9d3c7fd9a71b55feb2c2d31443802806866c4dbb18dbb123225ffecbbf23f34caf45794ddc1c50f939db05172302ee698f5db406c0be906e3f32fc74683b22657e2a87b3621d4ec7d9be4324064f36a37acc155d75b0df43c32e1ce221ae95ea09d2c5df8ecba18e14424bbc83e7af94ed5d35c7c5b0becf1104a317bfb8f025e6c7d2903fa08faa5f527a88416715d843194af075a046c731f4f76f9cdfcf9b7e90010275676737277b9fc1f4f56ccc697be6e1323f619c645075a91819f835677eda1c4b0fc37bf5c49cd4bae44fe98dce0a3cb8e66b74ff9db06b857ec76f46fdf2ce8509a78cb34a040cf3e791781d92c925bd3a917287ff983f6f590243e1cc28c96abd5ba2dbe3e8b963e5597649f392065cfc0ad040d5cedb775b933396f232107b4bab74a32a0b096d77a6446282f9b48a75832a279a446217265735e256f14b25c008f0ff362c7271448d59ab65ff7dc15e941555ee15bd395b0daee53acb4915534641f7f92d9389c30c016581136331847c0efd8d01e72702256cc421134db80e33fa6727a0b3de21e74040cefe1de45d6e2af1dc9d20aec5b36d728730fa4452d099f29ee3a7c86e5fda8024f8869f5cf5aa2f645672d6f31a3ff1ae6c8578578320aa7c2eeb773d3345a6812be323bfae72aca625d7cd60718bf55753af627519afa3a1dd715d6ae93b7f3133d38927e7dcb240d21deeccbcb46ca213731fb01c43f6230381ffa87c2e210505ab15c6aebb57c733565e5e6e9ed5dee1ad2e47e3345cccee579e19fb132ddc792a7cbc648ce323c68e28b0fd70e4f1de2ec187726961b9ac869a549489d9f1fe4bc18cd70963414aac76c64611be1221972a28d7c579bdff95ae155ac6e5cf814462da1ecb55f73239511f47f30344d711a62310e208a7d7e8d3a98bfd21c9313efa8ed768f737a31a3f6e7d7184ef6363c54b50ad5c250009b0fe69b64c15e35008a3a6888cde046310e9ac2a9f1dadd5845a1c55ee0de8652876a33ac3793f4babcc254f5edd6b7581081c3b1482952989781f66094ff0ea4da28a7dcf4bea5f9fcd89b409d913f5a71a6d78829dca1403cd1e8bb70acdf4301a846c6f586a1367e3a4cad9b8b1dcfb34ff736b0819c0bcf04f8abdf28c4a169bd836dce7ec7b2059570eb446bc24bfdc59e1eda779d1d56d462714db570eba7d3ad05cc5241d7b38b30432ddc20cfe053de5f6b538b7d90d84c51c2bb95e843593da16d4e9462da2464774b13e9fdc6f1c22e4e249a9e2bfdcd999e7a55408f419219f2db530fdd7e3b94b2d055be975966ace8370bfa2797bfbfae95f57534192937c50427525ad97778f39467b27d258a65ae0fe8825d8f3888ee5ad5ae8debfa3d94176b6f80cbbe990d88128ca116f90be2355dafb8e130a0fb10da1838a391726f49081a1b723b27a48187ef0dcf70560a492bb552f7f149fe198d30b217e7b324f4d85444b4a24aed659d9a5e65de88be8bb3120ca9ca8f34a6e5fc5026b355c10ad590692bc23a4b58702359b6cf89d962b0ecf6a6a69e29c3713cbf8a10feeb8d8be39758c6c20cf210d6d6065d6d45556316fd9391622b9d32773b97b70e47480b6cfbd0ac6927469fe4b4d5a82dbfd70dbcb94879b07987cfe56dd5ec246c2a646bd2f8eeb1f77a964747c32412d2691f36080f6106a830e6b3e1392cde1de7065679d5de0220b2bc5e4323b93cd1aa6b9af8a7e6ee0ef5145b906f56c8bd8ba6e1cf52bfce3895ea6d0842e33754857e45ca7c2b759a6f80d29ba9bbdc644d222c2ce442743ad3e1fe0b61b20c8f384dc9fea9787f8a9d2fe2579f7d40ac4f46c05451906b593a0e9a9480a7e847caf204d965ee6d56adcc23f7e7e386551e8cfb062e2d35b50a7bd45aba3b7ef1e20edde99289cdab56bf405e5511b63e49dd24c4f0c0c04490ac3fc427f70305edbea383f9ff8443d87c0b0caf95f117df63ab2927230f80bcc50f2599504138f1cb222e3dcec4308464094de830edd8880efdc686b3f9d3348b2aeb24791fccb827df00a8987dbc6e28807a377aad974ab49287f0052ed838782119c9f36b8e20e4e4af3e25f5edd47e335d856759e92f82e44a196e93cabc3184f387eed74478fef3fcae6b78168a1ee687870f0e0cf2a40a42350400cc2bebb4e3786a93e6bfa96433bab2b06cdf16ef3e442cde76bcdf3bad46a928f78a400102e8bb4c232652c2ae46549e202876a9c79554d5628f57977253323b3bbafbdf3891a12a5339a16b019083d1fee134ab6433fabb0d2300f8c6fcf7582a449cf719bd2f168d2a50cb87fea77f540d092c24e3a88cdfda325c55f5777034011ae57e5b49de8bbc00f647d66a6364a6c60016cea635df34252d68bb1c5b51339d99661ad84ab4975eb5c76e0084b929312e715a7af160a010b1277a44a989c10d53ae303e7e24c106df0e0f118b3a5649d285b22a72d4630c3f791159cdeb332c671b3f515f4ea6c8d5f0c991187b34bb58db546106279d215db8af0becf5311b9da62c07b1d73c3a4d0c72dd9f36375de843f12b9c92ecad18e2e690a42b732851b117bdaf3f73af35b4949089b0ed0d463cfdd1920724a247bdd726f00545631903fc52d3c8f669634eba9d0d4e292154b86af061df03cecc6f4a59151bbbd3a66a8ea3ea344186fd219a8910f8c9f680788c0b04c0ecaa182df8dfa6b2744a694a4dac9b313cd8b9db07a68201b2b937de823817be5c9df0f78b59226b8e87917ed56ab6ec4aa7e0b2c3af67a8466666013cd4b5849346d7c5f6c25ce24bfa6985a55ff658dfd62228224c7538338b55b473cd00d8f1744becd5e62a62be6f4c821d5b932d702e6a55c087f9bbd3e480990ea9b7f63a6b8491acdf122610cc30a23122ecc3ba703a56cb2648d95b4f4fe691ec44aa4471e4832c3e587eb539f79a6fdafaf7ec249b9aac97c6ce638352bf2b90c21e7354ebd7136fbaa9220c3c2b1f3c759d1d9f39c883bb65f3be47edb2747481afdcaed26079f124b123ba9f86fb300d94c2beefd8d4b7beff2a1c744ad64e9daf4fe4c8ac6468f0634c6d38cfb6f0aefd12f2af08b50ed2fb7caa9dde7733def497dcd11bb23ee31fe930286b1b6073d252712353d60bb23cbe2da679cce254306eb30fbc5b865683042fc5dd5a565294c3dcefb0f777c9bbc14e9a07246ac3878fc79b26869a09a1b87e5a52e725b3c04ed64c0b33d9da214b0c663fa39da813bd81a199435e775a7212bae60d2cc80429ac854d6c81ff9fc71d8d6b172083ad797b9ea40c15745601468ed34f3d5b26985f2486838c343b5b0991f0118e735a07d1c0c93a53827ee7585b6f065e6df300a7f7e7000afa967e3bde206741992896aeff307ab1d460dd5f8733b44530586b4b321b94e417427889366ad1d13a532864eb71639d2a2f386cc677a865147c4ffbe3002c74f7596e21a98d0d59f5f0e5fd6d34c2d4134c704ee37028c2cb0b41f357e17dbf8ca8ab99ebc03dc2055eaa79abc7504d308eb1b77f774f178ee09611a825c328e765be53618af5bfee102fff5003cbc5803bd89d452f7be93dac13901db9bfab25137a23c66792e754e3c50d1e1e3c920198f8d21a4736792732c39fe9afccb4265d1be1efabc1ee245fee33057521edd57b90c8e9fad907416ba84a0eabdaea44285e0244696a647e257b7b24b44b5783b8c0cb981dc84176a026ee23e3ddb87b57b62e77ff7999dba9515b23bb64b36f500bd2798da879c4b9e48c39ffecccb1c254c7155b46d7ecc41a56a2ac69cc112f47b89458649d977e5d5b48bbe3b5a3ebe350e5567fd805fc10b14c901758ff7f8af47ae52bc9e49477d28257729830829cf1e42ad8954b2ea758e550b8f696f80dd65b01ac0cc37e954642d1ddfd6aeb9af5ce99609d4021b3a4683076e5467d1c53139cff4eeccae5ccf5a85ba4a652d76e6df2db469aaa47d86ee0b72ff1b14e05a92f6cbec8f4f7b47e67e4442c0296b732180dcdae12a7fd9cf99f5d0ce42e125647a3272b62f4688a0becf608c2c30552a0ad27634c7c38fb9416dc7ac737c19fa2a33925085cfaa0eb943557be5d82add353ad360d4cde21c798501426085901ca0c14b5493d6eecca7e62de28312c370b61b5df8be90cb1ac1a8532f8ccbf8f569d822146087354ec03a9f8c4753c09f3016b17e90ad21e55133fdc72563f29b43cd0a86545dd1ab4476b47945b64fd4a1122df5d25df1016ff893658df578ca763256a639c92ac72d1014a4000166a71053640f645c244a68136b2465df8321aa323ecb3da9d604e09f99f0fc04439fda10eab724cafc9722ab64bdf8900590db3c2573e5fd36b049e9930869492cc4fd58386bc2951d0d40fd370e6723cb5c218ce6b2560dd0d599d8141a93d6086236de1462be9caaf8f7d43821c590b1aa91c47966124bb1333a4005849b63559975dd1789f17cff9f17f844cff6da61671ce5810267ba9abbb6c397b96b41ae789fe714c2c32772b525405b8c2294d865af20e10e0aa4b1520ee5d3a9dd3e886f559231f93ef8423dd4af8c563fdf5cf4f36e3e0a00f611f2b7b213a1865d027c2b2e1a65dfb4c930375e8469805c30b1ae21d2867f53899ad7abf3453f3a7799ba1345d36c312ca9a38282c5e6851f037b5b9d87346f87338e7930cf6d7491b8a0ec2a2304526fea9359049b90e100eb22a07a5435be48860886d8e626eba61939c7c5c1c6238dd3b9308c6897600d023d6526d301e3e6ac169ce6cb30e5d3b457bda654342b172e8e87dfc158769b14de74a77b0d59e087aa7ef497a0bcd28a0caef384588433b22a7416dfc54b763c4d8d2ea40ad278d1fefcfbd62189c9b12161ba32c4105be6a9f1b155c12e00d3d70d54aa703988d899c601a54cb70773baa4ad3eb0067249ce7b12e1f43871733ed1efd4f1df64364f82a39979af2cb0911a59c6e838bade2c6b2794e616aa3dc226892d9270f990b848614905adecc9da413d7da84723221a934f04aaaaf1a41a1a509fc022208cbc935f1ebf7fd1cd1fa1addbd12c7fb4a2e8eb60dd83b0e03b0535d35a99a634b8f469da2cb771ce4a9e23e5d43014367be69a6a1d2bd76c594c8724cdaa8113f53edea2aaa9cefd606c7c9d351f1d45674506d8272ce28080e9ef4539d2e6d1c24e92a28b7b4e115c688eba999f0ed8f1aedad6324fc2a5494dbdbf7b94553273a8e709f2f950773249034de9618a5b3a263953c872ed205599f3edad547d166e091f80eec844fce359a7b316ba2c1548c3fe3767bbb51adb78752cab0bcabd63233990ecbb13e4688dcc0461bdace750a3fab789c599867136950eeda59b80819c9cd17c97c11a5667276757e40740aea3c4b0975d52ed728f2c363af9de3714b002f0dd623f4bc8e0235ef6564bd33a3ac07ec81a9a6186fa5fa1afb86aff82a7400b54f41a02203da184c9f45cd30123051ca0c926ce1fa26eb72696172a204102aac2f9f63b8d3d0fe3e0b9f4ed98584be90e1a8fa0cbcf8e9f03e05ccf48e87bb7f18d309a0c603d5d0bbbf11f58c8ff6c376a6d16d3776a03fa3edd783a25020da6342f0365d65b0d921d58804d73c578c0c87929e6e1f3fb7cb7adef8260e57226979a986adf5a5f04f4c6878498e3768b4b4f31dffd6bc6eae0527fe5c30091d489fb0b39ed690c61708492e44cd959adbe9fe9f27c79b37759e8e6fd07daa6f5c9bf562dfb0156224a73eb95fc4336cb2dd3392b089e49ca06b7c94b49153d11c3d04fd1ff760a98e9158edb2f87072c81fac42d4074be4f867af80e7680566e3ce8bd0039e4cd53ba18c5b729ebcbab7496f3677666dc3635c066b9a789e8456e8bd1e00bcb1c0730781fbdc0b88946ed625c324fa6a537bc77fdeba635b7a43e1747b0167ee3907e9b67f5f3dba52009dbb5a3302d9971c9ef37d1e7f240431439f8ec64f0d82f0ff2b398ef37dbf800e50ac93eb372dfbdab671e7fed1a636b922e2555d29af8b4c6612db8e26a7488c7b8855fd0d6d8eb4c593da2e982a854c72c1e85f33aa84ca32cd2253d91568f49a3524b7acd5d194f1fc2025d16053ecbc1f3684e146e144963315582bc8ad7729fa466343027395fb37d72fefa557d7cccb3dbbc0c6368e449da4db20285d7ffe136c1842090a9c3e89a40e350977b5c41dd49a1c08f188d618ef649789a02bbd04862c9a4d70635db1e83be50f67c78ebfe784b8df71ccfefd776c9519c2c8c50da98539c5b3233a5789407f8bd63f8e96c050bf2afefba14072759d8ac94155976e65913a0e75f3e7126d555b5bae3dc85d098cb04e5e9a4742e69380629708b1d727ba8be8ae56df5ec1fd1546963d15eb9267989fc9068c3dbfb6d16a3012d648ad71e6e6decccfc1d5da7c26af0e9d0e95e57242b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
