<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd4740c4eca8a95c6e7d58f43ed6232e7ff660306a3453fb069bb91f814cc15b4ed0a2f72d898357d527035e2ce5a9c08d1a30274947157f1753340143b86b4a8336c49e93cbc0fd49542ef6437013c03c3e9c8e7bafa277cc6eb80ee4484ff962b4479c2dd86900944984f7da90e008f6b1103deb955667c3a7d122b591cd4b571a91e9262fddaa5b6597e1f906896ed3f8a63153f1f200a0d5e6d6638ddc8f4214c8974a0dc376c1e27e59a77b5b34b4422d13e94cac145eea93bbdb1608bb9adc253cb141f5d0e95cab842d8ecb289aef86c0f36981bff6891c1e6fec2001aeb980bdcd58b6363cb6504f11af26907dad4b86883e6abf982b27d81493c7281fb33ab4ad8cdd9203858202e10a2efde0cbb7b402079e9f583caeef60ba8ef5b55f48233a6395baacaa1e721f17e57ebbeaa0cb0439cd2555582e0221779a1fced87e0b0c9065df24662173a6d6c0876aded42a154f77d9fe8532d0d9512249529028f354cdc4ddbbb37437321be24e7b38f261706d9d5a231e5f154b4ccb54223c37761d0653bc54b567fda47e97c0bd43242e5a791cc580712fd6ad7dfcca1b47b403a195a257a307f3b6f5259c2a714db008dce17bc27120694e0794bba1a44560b8a6ef9b874a6be2d793212133532454639689fb0aeb2d452406080c3ab93af8060a9efe971b7332a16a0e487b76261f62d8c6d41ccffa8f96a38994e092a1405b41e93ecd9a63bff1c1c93a3266ff05a259f6b3f0d9a7294c506110bc7632c4c358b127f50da89b102dc2af81afaa24a9b027bbedd00dae7c32d771f6116a6ccfcb5ea447c6da8b60d7930148d7f6a30291bbdfc715d2be1e54669c33062f6e8b6a271a6e5650840e95f67165bc6ec10c67fccfd14333a062e5afcd2db40a520b84402a590624eeb61a19f19d97148d282e4a6f0faa6aa732adea7a19c3a240e17d174a9563e62f53bbcc99139850d9b68ee3b42758b66c1b3b2d55df2c76bad440e92d6d680e97d0e48ee01f8bae5297b42c1399e4b5e33f47de3b7815ec386a588c6696484482508ae2bd0e9d9409dba85bfb5becc2c1bc1f80a57838c1258078c6d0b71a1babe18e93d36e5459c1274f7a62810e9d4dd029577a9998610a54996c466bb9ef225ff19dbce4826f9c4317e771ebf5a959ace45aa3defa70335c3eb8ab7e901b4c731e9def1608e6d3b6dd27f6e92af02cfc40318a86d514aaafb3e1770e6254b18e392fb298ee7028c1e66c467b5e7c32136fe159d0e8b53adf224f6a08a208792477010f3ca054427380388627c38f6bf61027b0a26f9bfeb7682a4d830bfa2425408dfe8d790410b236983c9c5241921015f5ba7c2f2eb70070f8f016f344381bc489d00d9bd4efd73e0e984fe973bc3ba2539ff945076ee88a0ad918e78a08e468f61948853bec8336594df76bb128d572c2422d387e54e60e126e3be7445ef6a708a41e41b932fdcf9043da647426f6bdf08be4655a149bc3da489a91c2d6a88a12d831d39e7ec10557847b6ff8d599641fcfc2f73acfd1bbd2e6b8bb74dfedc78f7397e03c342d67bf960f6337b5e1f622960b6e66e2c9c9e7d23328c5e703dc70063750635d2b421622322205fce90eb6f5f50b15d6177faf185e2e9e4ebe604e2d04ec30065ca45d59a73f3c3f32018b386ef8bed2d10ce1d7a932167033a06266c4aa672f62f040c22c9a822737d386457aeb50d59a7409a9da9317b20eea5915662ca4d4701d8e3625cc8a139df496066eb37009d5be86f9e35f5a8912e99542cdfed7ccca425b3f5a393b3868849d65304f7d2d6d9d41f595f4e79b9905843342ba595e1db33109cab6076e5f77944ac39f5090d7a603b40f0236ce1777f0fb7e3cb756ae8b1c53a61634e12c8ccb0074b221a594493a6eff7c73e7233b9d8ed44e9e2ed7f26ae6540b8ac4042a59fcfae02a2eb77102c9afa41a28b2a54f7dfc4f9a8315cdff39ac56307380b1551f40032db3c4ec99508b2aa806055570be4d96579f47c80cf84d0f4c021cb2fed0edf4be441175e4909f5ee6c0ec284ad1cccff0143e17c9d70a99ac3bb6b226c079fc1619880a75070db2552cce3d1e791136d27b0addf3127e130cded35465983be0af5ff498d447b90681738aff9f89a05e9ca548648893ada4cec82cd2eb1f67cddbd5299eec20c26db9b821c2f6f85401fa881cd9ae7eb0ce29b1185161747e6225df94eedf566d8de8032f2c48c12f0d2810d97d2238f70e19261acf743346c8c9e007379b2ecab3e38dc92c83fb1525a1979776bbb5cd91240285234672fae64edd1d458e83a9071a8d3e32b9779238c07456430947675bb37002f75ab3c237818e11a0ab865a3bcf8f0b1115b188025e79a71784267409fdcbe708a7c28c512641922093695461f644d810ec55e75b464d6666d64117b895fd2217d1c54af3a7e614088a30c0f2a655c15021b59821567f52b091e7504d873f858647ab641cf81b446a7449560db3299236b488bcac1525ba57cb51793b0bbac9f9f91d2e610243df46602a7f96a94d80fa62fcdf20f2b9fc418c75f342ee70a83551f6f926bbd9e638a2c5a38fdbcaf24dcae055bae75f27c44a2c817c993bf08914e4e8c8ae1555eb02efa3faa4b7071e91d447b014396ae897f2fdc8a41f9f4c5566c0e3a3682d20f80257ffdb50189947077902cd9df3c883d40fef7e71cc470de62f3e34a724529efcc88201b554cf1adb796c12f8f2c165aa6b24c158ddf27fda4659bd76db28206cb0bbf9db333dec878ae296a6ca96d047e3cfb37e872d922210b3597625ec1e7fe3bc4543cd932fa4ca72e4599faae57dc1b73f6ee54e8cee01cc0f3e3a867ed391c2ac24dbd077af058fbc6182d4d9bda1b8f3635b1d77ea68d98d4f914ea65fe692d202dfe2d45c8379da6cefd0bee12a95936dfe5bbfa8dcf7f4a6d10c282281be7c4d3b33ea1860ea0e576e1a2bc209d490afbca9d6efd5caf62565d313d258c00e67200288de395ef11b65108be798f6fa789ac966b8724c661e217d1770c4babe2562e9036a42272dd12c9371f91c49423851216cc333ab97d20036108e555d850518b4601f09fac4df9b79b823e941503488df899f6bca62ff6f4e5f8e552d9d5bb798560d7e243e867275de9f1b3c1e2ce109daffc73bbf9ba0807306ac98c9264f5a3d10433dd6d3dd1b0fe4e74e6f327fc9ca2b821e6db438dfab89eef8ef2ae32d59487509ea96f1d39bdbd225ffe870848d36a61499f29c9e18ff0ab7328aacea1990c1f7840027b862ada997404ab5f715a1ef925181c2188d0dd99cc34c80c43d100e098911d43de599d168f9763325742159d8720d042099f8c3b49d401872c6dfdcb767922f9d3de6f3de47d1a996ac948508a87e96ddcdcc707130d3dec8f34283b0db3ec30d31a3b297902a7c536dc626055ace6711ce3ecc5388ec80e05ab0160ed66bbde6c6d42a452b5713d9f0afb4bf751db914d3eb7020cc3039dc376fa92f75ed0f7e424f6c22214c51067cff0673363745bff470a3f24eed28ba48b2d0a6f30b5b304cdfa7881da236a2e95a6b17ee7e55f8224bda4052f453faf1cb2aec98895ed666c5cc6364a6367252dce1eb9ef3fff9f19d201d26a60834bb15469f2f334d62e957b72ac9472f1e8a89316dde19d7e6400c1ccc0c50cbc07cdc8a782feb08ae10f106a56c382d032fd5d1ae41fe21dc77d5855ab20320f2fb02d6ec0c78239900214c2692062ab3589f78fa5250dfd5f221f16e89c0742b7c761c86bfa195ab56906b81eed9ec1f17f13580d332779dff4508ede20f5253e94978cc8e5a34c7bd5cbdbb559f44f543dd16ef284baa7a21df2856eab798751402e712669ce462b036f90e04ad9c0c0ecf569d6e712119dc7e3f382757b11ff9f691db043dd3b866be65a863712f24a193a3a2789428bf19ce3de5fa21064a677a34b50e33173166b2e5a31da5ad4006432d7ef06ffe80d8052cab9a87d646fb7051a8f3ce5bd4df8c5ce2d22c4e8479ef6ff216a50d578ec0f33704e3dd5a884ee7b3c423568278c4f0e7c81cd61c274b1a5057611c2307404aefd04daba4ab23af2e37eeb09bb7d32a2e0ac1c7092f782a0272b02771c5e44ba720e76af3357d81a03902e130d59749d326929a8dc731f51eab6457050d6088a6e3291d2c5f840818005e3881c29ef238dad7cfe8fab26bb5b0a707d060737ce4719bad56d3c91580a7a438e9eff7e2a46e0f801fbf3ffae1eb625810b4f90b63c69bdd967a83fc9f403993b5939827d3352cf40259588de582390673d49414da81bc15b1a3f67be8400986697b8ad49f37ec2bdf99d93e96623649bcba46d1655a87fd473f682c742bc57c6dd9af9413cc91b20a74149a0702eba62a4d185a10c1f17f5a555d25404ac3bb289fbbea4fb806f8053ef71d918a17a8278a2cfea822a6c7eb07c97fca1a13fa85cd8e0eaf4a0ed4586c9427cb91c1ab4ad624f7192241a5db86adf731a8568909faf384496845cd4385ee5654f66463ef41e458aea963ee01d06e5fd6e548cfb7f193fa1cb55ca8e0794c6585deded1fa9de4bef726536681ec6217c11af03ea8244d35436171be57ce1418923945d4d037c0845903f3d3b6d63a543c860852cf54fcdbc29c5e399b930ba692b3b411920b0c71cc61cf55dad4b61bf8a18c66915b64cf3bf5930f10b6d458ad5f6c0f53774bdd762344f8da8a29f652e1b445a6d71133533d59fe90ae637d90e838f7487098d472d4997bd559d48dfd3c5a13b43b6006332572ca25a60eb294c5c6e8bb8d39a32751a676e5cf9c2f63d63a16a0dea173143aaf01024960bbc7c954535982e2fc61c7a8aa5c869386517583c648760f67b838125b3e3581349b2dd7728cdc78c92552b1366b7501aa95975e2ea62cf0494aeb77be68219e69e227ba55363d9a7091bb72a3033a30d0d7df8e3e383800aee529f39194562dd3c5d8185f78f3472bcdf9718eca696f212f72b0797667c6eff862862bc388158c8bf064cd22c9f55694d7285fccf464f0ff7946f4dd3895e0ca8d536e556016787c92f3a029f2de52d583e5e6df393dcf0e0df20dfe7ab0c10767e9e5c27fa104303e981b0c729d7d490b1a1450f14920713429d71e24d600d6e941973615234b011f219b14c1a3e1613cdf4ac262b1e543f1b34a4e4919478ed358f4f3560bc242323dee929a89b0aff1335211c1fbd68714ced4468629ec02bd34926d70dd80fad837f5fcf844c1519f8633531bee5f74dbd8d4150a129fe6828a7d777d84d9e1de459a2e3321e937e509cbfaef7f3718a6d7544f87a0f93f209cb19b4cc8fc92f94c66ebdca3a5785a8fef8985519aba5bc598f7e33f242df1884412cf79e70ac8bc005fb7de21c555eeaf3256ebaff2ab2ef141f4fac6dd5652537f6ad6c60d5f2643c3f7d7478511c477fe5dd92ae0130665c9237275aaa434f9e6806f9b891251e06bc0edb2264bd2145ccd689e1e517c95be9ab43ed979b009ad8f2f014404a9dd0f13ab11857fbf5b973d67e6d32ba88e90336abc2bd56258a45cc801baa39f4703ad39d1a011ae86af0ae0e7174ad4639f908eeebb5689d31913bec024863a1dc4e9387be12924e4fb999389521884b05f06d4f38e0a9411d011a46738d470cee583496d2160b7a88e56b05a6a266eb41acb3c854151ab58ba4c28d821ae43312fef210226fc37d070a5779178b4792430d679c2f0473c01cd2a9617e3e4897c90b1aca59b9071c8a506f5a489796bd2925a581f9459a6cd14600c322a57e2b3e4e1ddbe9f2387372abd93bc1d006fd6f05c17b529ed5a0660cb4884dca2afa7540a0f2582c17a438df28000ff9a9df6c184d302db75204651460749fda78bbfd553cd53e2984e426cd7f010367b69c7dce3d283b029b69ae6a2651303444552e91c14b761e403f6dabb7f828fd70dbe6ddf2a8f29f3e003ad545f803902babc2079a2367697bed048c7c3c3537fbc45655127d1246f0c245278c715d26290de4f91b0633cf8377c92f161117367920298bddd71f0df4b90ca21db5fe82773419408bdb6753081bb858f460b149105cd3709a8bfdfb05284c170ba54dabc69d60ef1fc6df1683f4b6103a12aee8563df62101c258c4257c401ef7bc580bf8168bfb14f99b68ecfdca20efcad524c5062355dec0c97969f5c7c90487516845a411c2aae34e4af5ab60074c66805402d95cfd405d171e5860d36252333383c54e0f38d5cb1ff5f1b35ebec1ccfa21214a6bd883286274594c7e80b1b3ec61766407415dac51030846a1b2fdbd56a53b7db5144b4dc4d68a912f3df84cc9b30ea4938a86645bfe99c44bb9e9ce1ffaa60b2527ecc306dcb49f3f428d951195d00ba7c99187ac7d3e1a45a9bab9fa0457bbc4daf1ff81354f492dca71b7210da9dae9ef10e49a67be70c981f4cfe26290d2494cc0a4e2e75efbbd6338a60c253f3c525ed8f4d091363faf408a14f2c17049011baad69ac98a97085ecd54cf75dbe86b777fdfacd18f1b68d7d1a1dc450f10162ba2da4e00ecde205bd9326b9922ec03bbc0b4568e8cb9a29b88b830153de9caf7a651d0247c02e2c5227a05b63172f1d7e447b5fbfbe09534c469d19ab7f07a37e711ad24cf3d470717c7ab5505f7b26505387325c35fc11cc9ded082ba1269908cbf8e2eb51dd6d2dc6336aa251d1706265887e861b32f0e22350a495ce18e9769a952bded740a8a2ae625e6268b9b8aefc0d38fbb26b1e614c6e27a3a65754c508ddc05f6e8b87421a4c59736c89ce71c384e86e6e7df12690a74600db5dfba558ff87698ef1c24f334e326fcf49e50900e48cf4039183a1251f053bb78ee23e55b14e361afb15ff4547ecddca10c164f23656d907ce0cc162660a392451c8a101fafc0e3dbde3df5c13c45580d982a18be83d48deafe3378f7a09b46e1893f4d0df5f668d7900fb727fbd50b3a3fa7fc353546af05c85f15d0629992e485a2aa04fd1e93378412b83a4aefac0a5bd06681717c810c5d8a8af9dee6c5587cd30d64bfb548a5699541a6dd2e96674b9dd7b17bf2f1de8ab45e4d50b2eb20b8593fc4135b7934086bda1aee076cb86285d24a384f6b8dbb7b3ff2f8b31640f761ae1450e221bbe1dfaf856d132c5bd1bb144ee77c82f9a186efe0d9ca750d43d10112fad60ae4891018cd57ff40b58e81dab442194e112fe1ca5720b392fa96ec37075b419912805a5b60664f57af9533065ec78e154e4f68d406b5d5b6cbcb65108915d5b240c9d721a517894240dfedb05daa2f8220e9d67a2aab88cb6ba5c4b5659dbfec6695b923f306f831fdfa91729f51e3625382487db54e6302d39bd2b6550e3f6c0858e95ee12bb73928ec0a39f4dcfc99804b3bc7ca6ba833a2ad0d6bcf5ab7240b492dfbb0feba4fb3af41cedadeb5adf41bceaaf5803f14f9fb102728e7a5324be959dd7a19d65266f05fad8f4bfe5ae5e377f6cde979fd29eb649a722b2e39941aa46e644a064b1dbdaa36db131b3060d26645b17b868549be268b61af8bc2487e5f32ce9b3eb83a8dd61ccc00a7cd06e2f4beed5bb0a5e23f0db3fb63739a7ab9ca7394df923954108d6331d2c944744ccf22b630d92b3b82aa288d20e322b5e6d5cfd2ab01b97b74b278fc783dceeff9a38d1417fbd2fbaa31cd2e3ff7b7951252102664dbb5f3e28ef17974c93b726a1ff525d76d0effd446e75b80c0ec923b2ce56bc6c88f5c59fe34afb6de6e10289cef916ab9fb90eb3f5576e6e7557f7faed7368ec5f31960b959a5d306b99c068ffb5cbda1ac1e5b7b2d6355b17c1199b2c5cde7cfff6225ecf36418b441812928bcefc6bb576fa673ab366a36c7e3e852a6e3c19884704264b461d787c27c25e980f98f09dd447cb4619c2419b4ce6ae892562d55ef6734b736a7bee7d595eda661417b7644da106c42792e738fa0122165f660b8871aa80d26e58554baa47340910ea4e9e4a0ee7b2d36f794c3484b75b4b6a09229aa830888cfa4fabcb92ef0b1e45380d3364b76606497ca330c289e15659934c222a7f9814f04a74e58b4fc7be41279c680edebd805dc80203b76b4915bf7a5890deb4206082d4d1128b169468c09f15e055544cb97de9b36793f417eb7710709c2574035074fb1fbc06804399379b0ad53e70d303398d7e3d150d075125865b647a32f3fed9292205881623da5c881365c577d62bc2345c1cc7e22247ce1a01481fc311dd2cc3788d9160d6a817c44f79e7684450f18126ffcd6c1f1b69200229d1b23b330a29fbc3cc470139fd7bc596345fb01397600e7b72370f3f72d2085d43f27779c427a5062bd63bc46909ec93d42846cceed85be20cbd5931a814a06c32e218d3f67f49230aeb7e2a89f8f8fdd544aa7fcbe7fe9804b35179ed31356849ac58df0ad48761e1efa1d654ec5eab2b47f10e93f8814a2ffdeb42a28918a0bd323b16074181aaaed6aa6c0514b38f06bb6e7e7ca86067ba5bb6e55b1d8dc729e7d40872a61b4831a1fb5ce9e7f6a3c00cb32a2e317fccc518fcf4e0f5541efe12583a14ccdf84b5715fc180a96788af2209f58f267b742b094e999c86f4a57870ef9e2328054d1ff0fe6c9b57e1b0d054c8e7097a37f956c6df360d32fba3cb2a62749dea38d62d5476da853d84f4f163fbfb221f58c6f5b87f16feb987cab489ff452e7e588f33e002c0c375ea6b7fe5c3b28c597eb4542d855722fb1b8c47f7ead39816519c660b73f682d116bb26280f98b137354b60e575498247c9c9650503510231738f27666d2aebb0701af1ba4cc92249fb4bea19700f5f3b1a5449202e884bdbb467bbb52bb369ec47b0f0db8d253713f8cc354bd412cae023866f965a2e9159fa0241ed72601e9c538b611c994475a7375c92d043c47d132714a5ca83083549f0b9b16af4bbc86898bbea5925e60978d31849637e908f73029863d6683e155ef109ae1bbd68a07c11049cd94a6f77d3ea828e458566c67be845907d8f00d39bc7ef2b7ccaf9b6282abeef66a43d5ea1e5459b6be5ab623aadaafe94a960704cb1912ef34b35b046584062350aea5044b1cbfe0adc242420394536ff646887e69a4debf11f6b5d633a3a8fa0366cbf085274f30a1118ee802f9e0d56061a02b6779653acff42c819e9ec06f6b3c1c22682d6fdd47cc1724d00ed5ded5bf587ae98f65669e8dbd772ac8d8805ed47cb68f30d8a2c698656424d7f95f87adb4a05951b7d6749af3a49639796518b22ef787d0c053e773ce764f924a4ad27a2f7f7124caa9236bd9babac5c0817219e8d8a986420b7855fdd3e54e0a1baf5b751deec05d618b9ddfb1ea21802e2b9a76733a871f2f81f806fd5c49258f9e1176c90bf8aafe3c1edd45cba8dc7c6b5ceb823165d4d5f2098060bea29a6cd841968b499e893fa8bba70e94d2e9b096ca25d3c8c8e7526d20a113a445669ec4630a37bdad86577f26216e054a74ca58dc01dc030a319bfa0d0aed24bfef1d9c2cf5430ef3f3e37d2f8525b8232a9188a7a00bcfed7892ccce03117f7ab1b2db9cc3552b2c3bcf56adb84129af75007154cb6521fe969695bba26e58f4186f759425eea780cda90039b9c117eee3751f31c8cd4aff79e97724a1c86e31b46201e71fa0d6974840fb5916bfb3cb8ef8467c0342d45785e474f1291c9fe73920cd4259e0c2d1bb502613d1662dc6daef35704a560aad5a3c1f53f79579ee3720c91817c1b48b49d4ecc6ecc02f34566da35692c4b8f5a3eca7ca771747600ceef49b13e6bf1f73af061ecb5a4c272d4e70f6fc8b4b7e16e38981f2194f3e567bdca5be2c368d9babb63d84bdacdca68eb30fb8f974d454603a552ca42541f2d864ebc5258d5c282860c0998bf6cf770c97c4e8954df97ada6c2dabe149adb810648398c592430efd6f618d75f3f7e46f164ea5747213ffad78d3d3bb9628995dc5e9ccafbfdf98389cf5156809ed695e10c86ad8232bd284a9470574e0f4e3c00426a992600a08c16382266d4e7887474058d54df591c4dce7c7cbb8ff5c4800a47f06ab46784674a04fc7d91e48b2283f2406ec46f4c976caf4a600badf938e981077b121cbadbf07d4fc9e19d85f3fc61a58dbe64301f8c0a63c03b8e6dd4bcec908c5e993717b76b4c53f8b36fa2346f0e8633737acbd873074eaf91d962fe33c9c9dbcc94b95d2c16817c43055e277273a0edb58083eee1b8331cf515a39909903dc0beaa8dc6a590cf034bc01efd2c5f8846d977a1567e4786403aae61352d1381764379a11304e0d5ed4410228d34b5be2d2e5df86478c16386a4c44b6eaa834cf42c7f111f3660122183b0ec391a121cd14d0e1b050a2fcf8d66f00fd5b835cb38adb01c48a76b3e42ab5a295d31374fc67c7a574e58a7967af0834a5fd07918a028a601b279b3d3f82388fcb5376f481e96d48e51d60bf6803490b0eeacafa4e7e685a5637ce25a7582ef28ea017d0a84701d4bc3d0376882dad7e81ab32bd3e6c4c7f515bdb28ec2bbfacb1f5b25c437bf6d14a781e276201354e2e95bd805eb2c63e142645a8c19a52f782418089b036ce88538e78c1c9e7a82d576bb8039456c3d7827107bfa56d5c96bc4a0194b34e2c2642c99b998dd6ad40b4991199c0b85b7fc40e64d439a947519e781729c3ddcfff00bf4eac36813f82228bb33bf66b88e49872134b98d6797105f20efb2de4fdace077ffdff9a36d877176648fe1fb30fa2de7ed97fd4c7bb635d65851ac804cccfe4c351e4947fcb385092acf2c8059bc455d00eb7619b9cf671fa3409c16337d85a1be2c9412803e0613b93b95c8489664d303371ab9fd64d0d7daf99855f9ecba8e6557b0214bb3331e1a6f3fb0062b3c899e8c5a0e5a00c11629824d6b375ac1cefdeb28c7d5a247be5c64760b73a2e2dd695b464a8865c93ba45c9c3f241acaecc45656b8fe0180a9f3d57ec43c87c09f8c6093be9fdc53eaad0efacc2b65a245185e685834ee9f2d3b9084eccacaca97f07bec28c5dc40e0accd04d4c668c050b667f804a208c35bd658a32bfd880fc732b28d26f804270136d0dcc1061c4b2eaa835411707f47add8810a6bcb8ece230406e48148da3bf3196452b1d80a2f7a920ce6f120bb3736f6fc1348502a52109758a3b7a4909cc9986adcd3a912e220a26bfd43cfce2dbd2ea5a73ec492c78458f8731ae03e92db5d0fe5f1e2e0bf7b220c6c1b1807772e891dd3402b5c10d5f6d35128f8e871d28ec15335b3ea7ae459105bc626b02bc1249eda35daf70b85531b128b9b032a63cd3557d1c109b019b18bef141b55a88903d4a5d89afaa57809c05449cf8cd84e09b6625cf80085105ab8b2f2b50d18b2faed1b6e2dbdadbd4ff83f9ef89ab2c28d31c2dd47b3f9faa85f6df0868a7b69892bd6f273b61a3ce3b593d0e9597818c0b117f7c19f94f1dca4847758a883293a7284b4c13a4467cd348f3aed3b465175bd3231066c49e0aeefeaf913fe85fc51f92dc538fd8938c9d81fb9f6709777f93ff38df7205765db5e9dfaafadfd9164ad4fd6f037f9af2e7613844c7158614cb88747d9e5adecec8eeac41f0bd0699acf1bae903704ac3122b2b05eba7ac624dddd80096fbd203c1977d29e2f92b92c752f35cf4afbce2b2f109146c7b1f221424967e4e7fe77b58234da8d28deed689a8dc1723aeb693be0ac6d7b2e1aadfa93060b8f42db907b3acbfb6b605a23599c7e1ebb0a5e60f3d9b9c499f3ff9a8cc63f586bb19873b1fcf2a218a4596a0c5290683f83e568bb0141d5895291e5f1783b1981eaa60607214e5fade48a52b6c1b0b0c92a67dad5596a87cfc856f916aa1a3f1cb07bfd68bce2e0e58b8c6084360baa2a6f8ae727b0aeceb84db8fc200f5c33c45f9cd8953c840e86f388b0625b369d8faee8b17c932f84658847f6c8ee3cab5158f321ae785725a1299f80f90c1e3513f9dd2cf6c9f44a1c38c7d3fbf3f9bff4b7308938d6626b2cab5d72baf814b875fb91ab161a9bfb7c465c5216c6461910fdafda05c08fa29278665e581c697345d976d444954d8d902e9dc66a69d2b9e4c5b60ef01aaa74d66aefd4e9153eb3f958951ce70b11db92cbc03d7f87838dcc4ca446f328f8f106258e5eaf740f0fed818f86d5a80f0c2e7b238ab11675bafad1fd578ad64067853d3d5cad2fb8eab6b80db22c182483a5f4ffbe968c4782781978c346d628c25cdf9a6d05ead1726a0f1e1e95943235c3bdc2157b8b6137fe4dc9b8ec16c4a91238f7215d9bdc1b16eac2bfe27a68965f2ba53c0fb7e9ad630e7bcaac73c10e93f4735fbeaf4a29ab02c0adc378d90f914f3bc212cc8ed17ee95fe5920f5952d6edf46c01816a9abbd222c82586a07dd0b716615e0f4f59e29a05abdaa8531533e03c9bda0ab3d3bfc6653bd770624d465e8a48773664489edb8214fbc3943dd6add6fc936dc6d7a558070400bd82ce89fc15de5889da766ee509d7afb7ec652a9f74858931918d98cf1b677fb9b096c70f0ff13deea1c056807d3dd11d80013a72ad006fc6f1593f1a2e52200fe3b9b028afa455cb59bcb5fa60316f86f2b5b11b1621344706c5746147f50868e85af925fd4663bbf2ae668957222b65f9c673700c011bf19d6bf0f5cc22a37c24950a9e1b11221b355ad68d1a62691d59b3aeea7595344c934fd004e714ba229f064f3ab4efcc7b79d39934f772cb4235c3b7fd55a2288d87311e45503f2a7c007d96d89bf3e28cfcc6131969ace3efa6a881611c1c7202778b46f756039dab057002925091ba336b4c745c49d82cce409e0cff548b956c27dcc810e7a6dffbbd0629e4e8c78013806aacca9ef754389bc0ee4df02ce534b1318b1e4f571b4bbdbee3a9b15a3c8159f03998791ec8997a38f640d74bcf3cf6a1ad8b710a28aacba89b7dcd2227a5bb9ab7fd317cf97170b77a73660d2179a3544c609aa12b8f5397da21bd18ac9bf7ed9e70b215cad3fdaa04a3b1f379467f7f75099422a46e25318892a5f3717e4430164bfee1e9436540ae47664dac215574c93ed36ab88bdf5b439cb355515c6fa8b37f92dabe7c9d97d5c8e3e7d708fb867282dd9ddaf079542562b777997c666d14488e9f5d5a548938e03bf9344787da5fcdcf5685b97987b99abbb6c59d6a987520f97d438145e8c57eeb3ac336e0e4a9f0433c5884505d965c4ef0fcc6423ed3bba59fcaea196b2b051208e898aee4033af8363561638b29c9bcfac05f03f8c7118ce62567089ce73e2b646e94e63d627224b3244d31e0357949d482ea0a514714824e151a6bcb5c3b3fccdbda045c45c52b65ad803908c5dfb973ef20b5f568ad015ed18a3932eefb88934040c004d9fae2ee4f7a63794391a3022086b566ac5cc15196616c117196d7c5427a1cdaac98500fbe2369b908558f7820a68a145cc98c88811c722283287671381ab515bd3ce107f6d08a1e1d510d0d8cd841deff06b5fb1729d0c99f85f538a9df6c7983695118f449d901d258e2378e52d0fcb66a62131269f7f44cda5e9f236f52287380ed706f0022c9964bd1d97e0c0d170d78e60eb7ece836426fa21a433aecc5d67c0739d3547a0bedd1a80512202e6470e4a9b624c8928c0f3b8e9784fc3116f9fa108096d79de67b6cbba4b0a30502f9db549cac6924e8b58ca81a4e99067bea006229faa6e5ce4592d849ea47924107bbd8dd68ecc610ea0d4361741eca908ed00f3a65246e01bae23f6da792bebeb4e4df2902e20fc27322e99b7d0d4f8b18e8d7b9f3a771f5af8745d4f83be1c8732a08325d2b9d472127e32d079e8ae726acfc33fb80753bf205feb9feabfa15b50152fecce76d2f218f3d4512f8dba4b6dec349311b26b7cb67ad52392c0552de6cd79da3dfe2decdab1ef62f40af5e33116fc57eb6f26c8dbe2738dd73f47589edc120bd5bafa6593865329f4ba0a7b0f2b029b87961958150cc8b7f808fd6c9c934adce0b307f070c491c95989a4e2ad2b87d9c19c4d961e4279374b2c282e4be913f214c5e337b02fa225c172f79142e2c0dc3baec8bb8afac9f8f7a42cf7865c7a430a7aa4ab279cc47da9c625d1fb60088d6e3f30b2495b40936367685f77f9625496b8b4e295617a3f1b053aa93b404e3e91a19c983a8bc7532aa22aafe74e12efd3706a9e46e6f03c437d171483cfe2d8861903c8c306682f2c8e6d05600fd87c53046afb1d511e5344ab77d7d822d539a2480da78a3e06511ee6f746f6f8ae47a3829bab39cce4465f60e9097dd26490cbfd7200191fca820808c95fa027565c79a847e24746feb5430e85cfb820c76c9a0b3b5e64b52955dbf26bcf2dd9732631c7fee4af28f1cdb6dddf311760727cb25f434036099218ca34559fd4077210dfafdd3c3131cfc1cbd520a5e0c2cc952113b13c9976f17080933ab7fc8b2294b9f17468d4404cabb780f27a852049cb6da8f9c47ce90089ddb17bf3fffb7af65d333c5c7de5a16d4f84640d828fd853c5fe8ee33470effc9cdbe8fb95d226afd81ff7b1d4ff6ac34db265b9cc11613b3d7a79701bebef91149be34151b8e246d220e7e63ab6bf2ca74443ea3890e483350d7e1275f9a54c395113a0c8652a4eaf46fbd3e7001ff3bc13bcba690a8d3f452371c20a38bf4c510b45d3c72b7924324c123592856409ea155b5a66865a3132a91dc4bb65c24dd6e4857864c5db3c5e98c0ac24454ede09461c04419d91d0f610ec1fe669bb94512b65d57d04130316147ae26b1f3c4b2103915871869310e4815df057e3b234d44e7ba9441df5daf52f0b3bb55e418156139800649ab42f8c9214bf4a01097912d730864f09477d177299dc9b7ad6c66b1d620bbcd460c2a3615046008aacaf1ecc8d91c16982f973cb3c6205eea703cdf14db7e96447bee5d5090a6ecdb8c605415d7eb07698a5dcc95912da83fab677aa673a7aeab28326723bcec38dc16739855d0d9e8495141b2aeb82727e085ce1d9b0bebeda4bced2d4f4d0111b8f3f6a1888aac40875e5b45a7d2e9ea660baf56b111ee1647a56c382eadbbef7d5026048306820063b134ace2a084a32f85498c4ae3b52abf59ee8d9c5244e7f2c1f66792da53be8aeecedafca3faa8a121f51ccdf491c72d7e3499e9f5f60062ed9eb8e9350cf864eb7c688e11df138d6c2c3ff0e95c2977f10f1b4b48cd0eb796ab6e6dbd482e0576c73bb2caa26bc916b0ec018c5031e8db068ccefd6b9d0b62e7596bb5828edc23f8ffdfbf4709f31abb9c18ca91cbe2df69210db114aa76b39116d9f40ea1bfddc231108d5b5657d0872eeb861490820065f40a7ae57cfdb54e94d5db7d2333774f7bfd38966afd44af29371cb827cb0724c6b7d8ea6990ea62c33a37529d0c424c2b5f584cdc9d7df306246d6f0476aa9894801b058effef38b24a5041e07588bb21d2409afbe3731fa715ab3ddc6fb6e1b1bb2f5a19d1f6bc8ac1b603de1a4b9225dfa8fbc8017c148400b48750543bcd3204dd966da9a2d79b6f43ea7ade759ef4ed53e7cf52cd2d1f25192dd9b7b9ec782d6a1defde2ae7167667f33442b748127afefce6418fbbd4ac975769cea1030fdfecc93d9ed321f56b230037701943308cc9c94035fa2d377958a94b42ad82741d144b71929a55101d5ded453412ab541b4298971e9ad6b28ded119d5887b614fbc0760d0567c15e8e15c7a80f38709e033ba6a1f9fefc6bf43f8e641d8d9774c3692cef5f4aa0c00bfc1de33495ab47a9d5886f1dce088ec277df03fcbe417d5fffb565cc0f42f15a917feb616ad49b665f570f1f052e8b25c0e17caaf4feb6b23fc12ccc2cb94a2fa7c631ca74b76dca7a9c01717a16c7e6ee2f2b37029fbf3ff3ccbf2aee3f65d089b9b79cf0ec88f84dfce9bcb4aec2547508d42c914785f84e12b761a9afbd195d3164ae2287a7671a8833a3d6691963ec625782153823961f051f7c59bc71191a5f713678d2951f8bd0ff34c0e6d93ffc9f31c6d0aeb8dfbb36562a50db87ab20c167bb88f96106d4bb191377c88a2920392d0e4cc9235210c74a55e7261102439d966a6311f20c413d1b23cd9aab239b489bd5426f1ad3e011fecb4f349d8725e8d803667272afa35f942ec425e2ffe850bd1a951ae750784c200a1dc4eb9b6ad042856f8850fc5e50ac5fc97658660b35e41a719018d6182eed8a590745e49151e1c1e5f7a6559a20685e184238b48b1d459aab8e224f1e8bd6a206483b60482d70dd4235ac5ba504088ee4e154237721a91fe3952a0c64f61b50967ebf5ff39309cc08d365592a2e29299893ce6c722044fcc04d9a4fbe59d496f8bed2e3187823cfd768b5dde6c6fcc8e80ae7c050394fa99a38b08a82b7747873e1d8b5dd6fca18ae2483d22e0d8afbcc5afb956f30693dea829d090496ee78ce0885820ba951097285fc5367d49a835afef546a19277e84b70f7dbbebbc68c76996f001d8bf082639831b143e9313792573dac4b9653e614171dfdd6160542832902ae5556b68124f34cd9464b6ff4105f66aaae8769c27b815f8e7e1747561badeb7aedd544ab7dcccaa7076fe521d558e1a48845e40e8c58eafc36fa07837fa47beb57775bdbc9179e728a2976fd31209aa896cf9196967955b2fc3fcd7376188dfed3f714450c06308f21f151719a01fafd350c4444447b761fbafde14aa15437ead24fee88ef8a493c733d020967964b5fb7536b8fd47de8743e1a7955947ade1935a2350983b9fd9cee27ae16b42ae468feace9dabffe3411dc7751678c0db5a4c00f05f731368550212762297864e19a89419f94c84763dae57fc47264ad7aede21c951bf889c282d1165d612e881e6e6df4c56a93d105213a4a0a5827ba578a6c3b4ea0b125bd3a6c638d554ea72fa4903365efda08eab5c5c0d05dc0b6cb9ff2709c20564c189ccbbf94022330442a85b97c7c89426bea92eb05a1500358ab6d8932cbec0c8bd7b623e59f42b102b50db309831b65876022e51e6c9a231c8ade91769f4f995de99945b5ad57fc6cd217c576ed1bcc4185c4a078699e1b3089a9de7df5da6a77e73282aa7d96a11ed791156ec899dd2baa3ae0d48ca29ad41eab23a4a2dfbde51a8331ec5902ee9b282fce3b9cad21cea84601248fdbb76ccad059caf4ff42ad83e62631fbfc893c251c37e8b544f6161e53186a14f570b745a699ce578735222280717b1631ec67c13f23f567d0a182c850dc6eacfd00dd9f4f5e06a172317cac19a797eff4c2796e9179a1cb12fad00825df255d82c989b90730ca817c7a94fb4f2d3808b2c79ea51bb50c1f4985312140e9be5f4681ce94425a1006855a3901f5941b40fb20dd96a3f8c66a6c72486d9d13280763fee64aedc7bc73c2e747e0754877af2598ba7e46d584d4229832ea50a283aa8302469da6421f67d50e71da19ca988fb3876d54c23d73682e4d8f8939c47ae57749ce3cd35e569c2a039b9e656a4ad1ce734ca56f970ef0d8468493aadf2ef405956a1ab5b0be46c9e399a61af083011c0e1a2faaee14e08570776eb684f018b5907b69e6f5577183d88f0b21b9cad3d6d4d523694fe2e616bf36346ab74955894e2fc1004bff60b5fa4cb685756be2c590521288e390b3c060e5420002d2e3e6688949379044045ecddb20b3bde28dcbe9d3e773cf9fb2f2758ddc228390e27859c7f00d3c6afc18659ab6e47f003327747890dd5977d6964ef84d7e972772ab9cb3b8ebc29a43604216c3b4696051f7624951852342366a9be4b208d4f40c0e849dbc611433f6b6de2dbd4b9019c15fff4a488e531868596458883a41af9cd16e865a6c8865aba55c4bb9ee7f7282b4dbc288ef1790f7829aa037b83d104cee5f7e00fe8e33163f1a0718699aff19cf5d019943bf90b917b14d432791d21f2f90b107cece2bdc9ae5a42d0528fa0425e56228fd038fc7ff23f6501472d987583c14a23dff045051d13ec74f9e6a7cbae0c4a987be2df016b5b0f2f17920a4147756eac9c0ae93c95ac96","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
