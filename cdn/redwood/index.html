<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d8a4ce80e3f9cf698c84de565e0090808f373abf2ace049157dc6f241f299c144eb4b5739dfc94ce6341d8d0f876164f59b70500120ae2cb9e74557311222e02809d2e63ab64d39a706b50cdfe28fc4bf8b62814157586f5cbce7fd66f738966520ef5a067021a0f0eab37182a2dd389ff55f5ca8953beb4a3a107cd88f1b02cda4d8ad3c0f728a9a7b97c72d571c4fd75666fee2a9e3c2eb78e9b11c5e6eeae76cc12a3d0f5bd5101540aae768d73dd8cbfd36dbfa6f634fb3f3147f85a38fca202cf918bff60225f519b2e7027d4e734e48a6f8723eb1c664582c75f423c7774ce0f1988e89ad773ebca5c33eb8e61fa1c7996ab06d97a1d4bf54a36eec0fd2726a3b3533612231c8feac2214301ef94b9314f12319f16183c3969f8d3126ab40aeec1f86d3f2ee6e5376f099dea3c5b0d8f604b22540b81f8c234c39baf4f247baf31ff5c43e091de2ceff19e811df094ce12390fa5934d0eaad73f796704073c0aee61598cf24fd353c86f714d3c2b9f726513415671a4103067a9231f55a4c2e44ba8f5dcf012b1e28d55ccb4adcc39910591414e1486112054eebbb21cb5197b953d7422ebbf9b14a785ae0611d009ae0ad737821175a1eda10c42721d1c6a436f1c04e6abc6070054becc13ba20ff4303694a2b30645a2356320ba155ca5ad86b290ed51cfbdc60d79543fdee26aac9f0ea10b20825f3a2d40dc44abe3bd78d2fe0f319e4e47a013095d9064f0be07ff67ff0f504489ff4ecee36c01c7a6b41b1c13a240071c41630afc2b9f7ab49b62d4190892fc7ff09f2d33150725ee30493442bcbc1d36abc7003fde9a7ce7449599e50e32aaa194f8419b476d38a6ca1956376fe649c59e132e29fecd1e88e92c34ff7594e2788748cdada7d85442b934975f6b8ca2120b38a2ad533f9fe0554f700fe7506c458e33032c1618f221a146304dce4824afd5ca6129ad51ac8865a87ae5cbd6548551f23fd818442c304d432cf81c8a70866a235cee320fba27fbca83cf43536fa465911b92799362c0e78b2739386e74581e87753bebd4cdd4c413c9ad7a15892803d5c32c0f746549a83a6447339656cd460330c6cce61ed11b71c9917fdd58ca69b83d75778b8f82819c242bb2532dff5611a5fa7ba281c6ee89556532f5d16e157923d0112676ec3a4186a6142fa40628a0fbf8d35d3b6fa19b58133773a160ec65a248539f3def878e8c1936f2ca0dd7a1c75ffa059ff7bc98116d2ca247ecfa218724db65db2a3589dfb181ae86a810d3c8c8ccb671e7c4285024bdaefbf4f5412b2e798ea974231789a6decf437c94cef25c6e31a3f7da9ba5c9f19450c371e4580abf699f92c5488dab88b1f0d1e314cd1a31772e73191da852869704697442933801113edb605ee4def3e41f5245686f81775aa220fec41ef4bae5b81c9014f72e13ea12171ce9f9eaa43752a8874d57de2d4be2f0db47f8827892fa4f90cc1afafecbc2aa3d6a48e7ad7fe38ae9c65310a382d24652384f26ce7a3ed6a5fbf0e4f2808d4fbca977c262ba728ba851bb2f9f15d2f88be2f4c203bdd8b81c4c989556f94c08ca21c84fb14bc6e352a222f045942a7d9dcb4c4c1907896b8be494928c2cbf32b081373d801108c28550e2dd0a20167dce6db83cef21f66a645062bf69b43fe6d0578c99b520d753a8e57ea35b55a572a13eb55e5a144a8d32a6bc68e53de56783cae5f93518f8679fa8a49eb31705b15a70a1c8b9967d1a43b1359ee0e81fe9f2efa2538bdf581d280d074ca0539150848f105830ddcc1bf3fe86ab7a42f7c972d02c1a49c6a15bc6d8b308f8566e8009ef0506549d2d8ea30fb8889b5ad6425123c4c1012cfe471c1b8a2620b301f6f6a271d05f24073ae2f14c209ce4a1dac261c6a213ddc67eb07f6d3123cd385313069bffae9692a5e9c1ddfae12bfe6bcc34f0b19eecd4095b59a338b871b836dfbfce54e904aaa644753ec05ea81bd062922f09ec30adf702ce65da453c5fe0d370b2b671eda19be01f15bc336f9d637a9967df72d4a2334384eaab855067379cd044968dd5d84939aa40b5ad9fc8fefd46a47b35ece686f52dc21c8a484b55954408cd00a3d458291cf03286325843e58320df369aee4ae0f3c1d92f5cc075289585047611dc57a2fccb5acec141165e78eadf3212c2afc8fff929e640eea9c5c8a92de84c3bacf337985395a252a92651cef428423e3502762d98430c4ca7f733bfae0017cfac58610f55b971964da7ccc17aca13f14abd4736b9450e5ffb3981b49da02b96c9644130a5480dc4a08597eb764ac0bef8c08c7703ffdb1abc4e8df7f864fd80f212cb2a88d43cbc84c837152b04ddef74fae850ee92645dd9d54dfdd44bffb36a7ab5de0f2ef92a4fbcf0de8879294c882183c8f3e873139b4bcb2c21cb6129dea9b9cd7ea02343ca2d12f9d80d52bdf049b2fb5fc88debf01d160147db91096857b160be9c0a4518878a763ccaec4e5254cb16ddbde803354837b409ac6c9a239043c403e7200e5ce8332c1ab2d1d2809c227eff9fc71abe248431bd7569cb901a62758ac8178c30d710d0edc42ddf9c99aeeaf8df21b1b4c1ab3cf262b3ff5d0dfb17279b721857187c2d956dc7eac7d6cec487528228bee91e8910ef0ca5583cf0580de99c51924b0ff03a289ba392945eafaa21d4e11de8985aa41ab3bd5da3a350fd05a31da129fed3556d6a1e450c9c0b3d00b5a5ce3482f5cba44467f0a6b91a5314a2585b018ca1aefba7e4609f21084c902adfce981754941775900b3a7a6fdedc209c263c51258e8ae0e9d7b652ae3292b178ea35735715ec63c5f30b127b7451f4a47fa611905fa5f3f4e92f005079e2038b52eebe746bdc8deced0c29d8903301bcb4b71bcb8ff06da23acffa824ace38af15dd80b92e77f15f55fce1ae1b97ae77004833babbcef86ae6999dff61ef3b2df67f26b46c9ab3de92929cd2e6795bec4ab0655bab9eefeca4e887f4a4c479804e8e950f46754e83f2996cdcb9a03f071db78e890319abd8203aea6fa1e2710f8ff5858cbf4b339236da2df5df9ee2ff4f8631731afe24d2397940bc0a9506073d480fe841a380b2d68d528592cb10f27a9630a7d56ca0b473a54704b5c579c77523c0f6d77baf98f3ad892834321ef0f3512aea4afb3f53e2fe35d9172adbefbb6b86aab3c930825fb5cab4d9906d9ef31be1ff4ed71788dd7014cab4499f7e9c31797d2fe292f7e259a85e35a90d330d4ab00ed8ca117727950bfaa54e990967aee7e644f7b6ad73e3f8094f91b8e43ea5b091ff007af3a81812dc788aa93a06671bb381f4db3c326742777db1424c875c602d8c669b56f4be324ad1d1fd6d590529df08d0edff3ea4d39bb5279b0e8142c162084891a3ebd2a2c7e8f6755e06596a6341a0e7e90a410713efb8cec2446993d8b39dda4696491a869e8e0e114329abac763262263061d7b886db66bfbede2b542816f741e3615eac810b007c8ea29ea149757de854644215ead771c0b72b274be2e00b27efe179f077b0ad5a3a4064acea606aff8e29d6592e6a95ce1524a937deac46bed91d1b41df415529c97ab29fba49aa11c7ab41e102150bd8b929a5965fa177ffd3c4ff4e0547f4cac650cb63441c0cbc455a83457671dadb402d3f4d84ba69066f690750b62ffe39d8b9ebe9a7f715a183a60c87ee41cf7fcd387be505f1f8b300d1d21f409deb563dcfeba449b780d41e14591fe15098904ba4b6169066cb11285e077c7a8eabce1000a6a66760c7c064a4c6e11fa9031ad2bb39b24099e5e1a5bb5862e066ef51dffa37c6f63ce6d60aca0f27ba1f65e868be313f1399d9abb0e85e9d947bf3369a4a282c661fc280d70c1bb41c4cb080112d9f80e1347c1b3cd90386f2bfb8840104957886af5c312f013d683a26f7845e82d0fa69ad38f3a50c9d88d9773750be8234bf85d4fe6b19c96ef10c23470bd214c82aadbbcaf45ea0723332f3c4400c59cbbc54508ac621107a0d9d7bcecc1d36fa25d6f76e96539e02341b2239f5eae0f916e0324c2cb1faf506bed870b5b62095740745f0bb2984761c25866172c0ed506c8985508fb51f862400fc994d4fd3e463fefefa34955c7e75672d5cafad53277711093f40b3c947de61d2c1b3e235c1e7b7ef26cf3d72646f527c23e27efecceaf0bb21d38135b18619940e9a2c23e388528098b1e5459f3172b06eccbbb2b188088aaffeaa8d26e75ac44b0a056bbb19878b2bdab98288c5978617f6b03ec0ae8c8def4489da67a8e98d96c7661b9657e329615b4179451ba6d3ae30f81056719bf23a693e8483637d1acf002cb69e688354d6ef465f1501a6c0e8ed7095c9c6274a973aa696378f9937f0f5c8674b595412123e55dc8d7a6a670048560b1dc2ef05f898828d0f9c06a8f3397851e8fb342430ed5091ee9ffeb9ce5a3efa193f52aca90b467b3e2b3355a3ced9b1d870dc3d9e34a7ae4323218857c70f27d9685b9c663c0f50b326381f3dfc6155c6c332320148e73b2fac8610354ae6ac6de7ec7a718d2752dc89ccaee7b3909219398932e9456923c6b36125b32819b38a12c41b7f6707ac98be661a8d48e10d4fb6c3e76cffadd6c83c99d63c35626df0a0dafb9504c64e828dd97ff39bd25742018e970eb25357e1bc74b66b98b81155afb863db2d3c5c959f09b139e12b4b269f3bdfd734e883309033cd48386befae699d35e63b1d285dc36b0805d81484264e88ba4b47eae130433441fc5604e232238a35d8f3581d0f73c748e1f7fa0b2213582ea39558e2d5449fe4cfb04cb1466e64d071dfb66259259a821aa50ad4b218789343750a827d29b5a62d52e7eb8b87b1ea68d42ea07c2a24e73de63f94f5d3bc7214c0e905f68363348a0e8ffd80d5fc189206ca0e4b6f9fe49ab155ded983d7dec215c7a0f05c76fe45e51f75b94f9d7bba7de89af7fdc5f4f58c1f24a0936bfb510e88b37f630c108966bbb7e831d755c6c08f6c6b3236fb06a942908e6d55490d2af70aa008b42cc99ce21eb72ed32b3f3216616d5e700c81b469c6c389fd2c74f136d624b9210497a4a4cf0be14d60e95765968e2709d6f65e7aca230f2c9c48e3143434d3d5bae837b2a6760c2e8e4cae85b34fbbc9b139a19dde8b7da491aa1a1ce6b8c68476c32c17ad9d38b33ba97d0d267563d759c2f6d0ef1e4fe22981592347356864fb44438acf1d255ec719549fae5d21e47f263c52a8b3f262ef7f9223b5527d469602540cd620ea054e71006bfabceb906bfcc540100d9d433ac8e6bd89e4819a7ad8054823146b48061c9686826df650c235ff163a1a87dc5cb00e303ba2e1f716e07736a46f658be6cd06a825d6354826758cee71da35d00dc6d42196a1574b371c9a6e91435e50febacf7d9b04a2334bc8b454652179a9090de4a05920793d2ba4528ed078a1186cf32213e1ed8d5aeee73feb9e1252d97aad5683a7b8a466f6172184071b9def3c5cf6a065e51481e97418295979ed492843dc0219068b9437085ac8ffe6f1bc290403c498d825aa7091a244139c8be5bd71639e6d09620b315c05f02f3cfbfeb39d54b6f214988e6ef111f8eba6034bee9531dfec4fd9346ac3a4123f87ea9618bc88d8d265edb5ce6cb6ee2797f6b0a5a976ca5bd5eebb345bdefae5b77491af48e3bea806744e2a673a00f2536879ba3020ad9b21ca5476695e2f224d1c9ba98c35cfc80d197c399b76ec913c3db6b7cc6675cd2e3a85ad93c580f1bdbf8f1f541b9ac2a1476306301218479c6106318cf4301bc1d13f35929ef97b6a10a7ab262209d4cddceb587e66fa81a7d29a3bc9f7537781029bb24ad2f0974eca6183eca873f7a0ac6c9d2e6199fd684ba09b0f2ff159bd8920c165a2c3fca96b213180043d5d391bc7d8add7bbd1dbcc1a2e5a3a7807024bafb98ed15c512dc32573a4f00bbf59c44094442a90ca69f097b27f3991aea1aed08d904f5a0f85d4c2da9d7ac6843ff62bbe96f4e7fce114aee25426ef6abc1154c287f94aa3a78766abd10311c8898aca6b3b21a85d6647161dabbd577e65f69b2b5133579ffd8281c97ddeb6d0db49de7a7f359c12c3904c907aa27487c9ef56334b4fbd91f3bcba354d879be1581e64c3d3f713a8c4daac752c3e7c5e2c3cad8aab42ff81a5978b30a97642244335f7e3e6f379c3f8c59e214f9a3b1bd4aadad127fa20059ccce2e4a004a08079ac517c7163b28b54ee2e4e7449ac50ca686fb701ff120ec915419d23488c3f19289fd341cd75cecaa0edae867e6ceaae353bf2ce7927e00234eb443b7a7523807b7c2c37bce9c9fbc02dc47d96e53fac0bce38076f63fe18e22911d9f43435c310f2818c2310e2f2d5411d6e2cdaed4fad6f941ff6163343d34a75af64f640b8611e4e5b6aa1eb55c55b17627cf304b925e4c6032dc6a7ff94e694f42e28f7fd99b86922a7187ac69c18da827b786341092a61ee50547e4570ceef462336b82cdadf8878e5d6ec38228d51d4408428b1c97ba256b6342502b73d670a939a9ae3a95b4d771551d6fd0f8e349205b3db4b06efb1457d91d9d8f132f354e7a9828858a161d1469a3f73f32bd993f25057801826a6d226489810f56cd12501bca16cf954dbc36d34e38a7d45f486c545b2cf793ec47d324277edf5f5076078589b3ee9b1ed663e9b8bda8cf60c544c9e995e3bb71b9b34e5ce862632cab27a9b582bee4173f8bebbb757247b962a68a27336ad2ad69d9eb99c9b9e4aa60c76cbd4961b3b7f1cc1e7cd23c470e0e51649fff37ddfb2898e60217c917edd9fa7d60a1c6d4ffcb120259ef2ae072a65528c3416c727694983563bf68cf69373c1be44f96c520070abfb72d893183895ce759154ecb19c1a3fa4c6248f8a9ba8dd96a9c2dbd096a50e5d0b01a905c4475a9ae9afed7d2ac315e2f50aa34edeee0de613c0711dde1834885a9983610e6fceeed53f667e0cc3d3e06eb8145bf781c22c1c4a1c6c321cde6daaede60625fcb444d78ffcf125c30c37dd5b3b1fee7677a767cbd0721b6f6c92a051de453e655624fbf9f8de894c5cd0bba7880fe206b8d344f623c04f2d58911cb9e6c39b76158fbe79fb3e470795b175405d04aa8cd7be220d0c92b35de56883d6ce962ca951ced5ec06e1f74b11c2c42c9b1401f5b983906023f39e20813efe9c47544e40973e854b008025be5595bae3c9e3cd7b15be5a51f6cf5454e36b32bc322a4bcbcf2a232cde67a1f6601fce9556b138edfe32b02507f4ae54d5d23b729a2c629ad2c6554b182de8e79027e94ad30381d1fde2a2dc32924cb21be37398b717667a77edb73c5c39f2905c36afd2277474e09f56a57c2435113ecbdba31d1396c6216901e4b3b772408665ee45d89c81abeac673495a631c34c884f37aa28a4ea69baf88c376987e6d3dbd5b744259f40dfe770c0ebcecfb00765abf894848e812474dcab778fe8c8be3e8b1e06a2db59051df7598fa67643c35c1c19f9023bb7cd4d5eb3ce05270d2e400222ee06a2037cfb4f617fd7d885d833233064960121ebd7a08b489b6b3ae1584da778abc7db3d03269c1c8023914cf7fec57348636edf8d950ff9b2b85c234ccdae25ba955736dd8f8118b03860e5e409b862c6121d2e111a4aabeabe3f5a9c3cb2506c29ce75334b05a88f9e99b13476b3522492cc8956f9c4290b84c3c1a8f0a5583dc8cd4b6322307fe000bc55f129db4f351684c3e60b00376a07bd02669bd10bc7b4def1cf1e8d94d7e1007c5d02934802e08f2a9821e37d116a13096d8f9961b82af548722127aa2fcd7ba4672b17de337122ddb63f76d1e5f3dbe81c7853dc480d4ba4d4212f66edcd44aff888146a854b515af189dd63597f1db6bde6ca5c9d1298ebba07d9c0267c383c5bfe2c9b307c2bc5cb2eb86a864c9d59c78163d5bfae7678cf7c7338e6d2ceb439a98c1f34954abd4440cb6db380891a53b82d7d82c3a26272c32979fa07fd66af6417cd231d48e593ab62f91fbc4654abc926b853f8aaa3e0b7c349ee155dd0b99dab84759551be0e993d2cffceee81f41660b6b10488df0009144ce2d6d9eeb36ff68aea44d085b3ef28d7861b48b6437a70a78e7801123fc0f40afe09acfaff7d63c97169bc1d640ce4c36bef214046d1ae298dffb087200583bb4f3b38864b123cdcfbb328c43dd3f24e3adc390dc6631a253c691d67589cd7b941a8db8f8d7659e91f2d6d22f620b21357b8bb61da256dbe1088b34c9653ac3b29f448ff9985edf89548721ad408f59a39aa957a7bf4de2284638ba11ccaa1dba1b75fc9ebdc8a5875a9cf991b9bafee05ef0b7e5a9ec5ec8b9ebb828e002e1a666ee9a054a6fe79cc648e1526fcfe4cbcb5d5539afee83c589becf7b907792d3d6eff08248e9bb02f94334eae09bafe1fccdedcad08f93fa6d8b9eb03bb6ce2833a929d2fd92d960c5ed6eaf3bbb75dce4a484f50feb7c31efaab226c300f7abd8d99eccc4ce180e971708c36083939c45412e2fde9fe7d217459828bf4d8afe97f82a456b14cac574a6dfdc4439dcef07e4fb7fe58337969ab645614e31dfa38516f9d4e1f1eab8338e7dc0cf2abb2e990573ce95472c7ba5b88f7fa0af87c516ce6b54ab36687cb4303e6a57452f21b9e73b70200e96626d16ab8a270dec0cd38a3cd16098a422e8a0279930878f8ca50d7a3f3f7831265be971e8d5c3454b74dd8e7f98b6a204c3d6b59d8895392513231a1644c86ef3a837e819a8100cad08099c465b0231054ff1bc55c9a473feb4e804ea0d2132d799306656eef5c46c86b6e1740975cab5e86be1088b768644842573bda67673f5f326423382aee6f84cbba6291e2f2ea883e8bf0be834a66f8fb24a276833b6b290802b3072ab7ae1ce1d15cd16b2206bdb2896612ba415c3247b4e9518b15dbcfb6fb11c46cc13bb9ad5f8192b620df3ae1a8ff050903db27f9274e071cc91c39f6cb31963023b67442c952a175406bab3dc204b30addd6f8ee7ad74d82cd9a2be5b9f3a877ace44c78122110293f331f0ab7f8b4a34f5d8f9fe458c2361acf08661f4cdd4c1f18b738c9d27547b184d74bf3787ef0721662982ffd3385c9615159d0aab6e8ae21a9a21164ae8a60753ad8b8a874e191775fe322fb0eaf4303bc00c24c20653b688d43c99aa5e446d155ad866a966e3ab3b156f1da8c3dbb53559f8b48137c19a68a062991da8aa709fd1638d0d34ad8ed2230aa2ba76b2ea13075d17fe393f9c3019e13d69c2b8a1da91c36969bb4f7911a3cf2bb35933ec3b3b17fac27f5a0cba43e297a70ce4d53ef86e09587a5c898ff54b8963779a3d6cfce5c95b082258a9e195e9f2811e85745ef971541049affd7ea00742a57a909ba3c45c68d7897a1a1ed0e2c88437288f5c685beb05e045b65c2bbc3cfad590e1ed73785ff032ae96d5ac1743c8c206e3c4076cd1a0ddb9fb025b980a05c7b709d78adfeb31b941736a01742bac9b3df2ac4f45b4bf3b4b091718c0d5efdd283bad100704598660f1fb748582ff45b06f2952039a69cfbe6e097b468c29505ce02339da4e5d2366e79c5d1f1b461ad885bb3dad6505f543c017532c5a6cad8b7bb9e59a0385700202e16c12015383efe03d958f578348860041278c44bbe555c174e3cb3effddf64ada3ebfbf1000eaafa8301f23bccb1de4aec7935a3fc70892781beac3b0bbad11ab8c60cc062aa19a223010f39c281e806331eee8820f340adad8e8d44e9d232e80c689aa89af9908de8b8593986953ed201f53a28349505a9ff9debff7796732bdfcd992c19084075e1f61ddbfb3dd5aff47215feaa674767b1d13d89d4e1dfc46ec7b4534a78f762ac3ec1d725c1aebb7c3be99ddb5d2ff957a1701fbe9ce97565a88f11395d2923d46d72ca1fd6076304d0a2c222b655bf7ab318a2ffcb3ff361efc12a8947d6621a2fb5a34693a2f32d6ab72b76d676551a3baab08c02192b18716e62bfa09f4e8ac4c3c908929e79d2f614ec1b4d8bacdfdf6fb4e0184e32587eebae6d55039814018eac97769101bec201156ba00fc65c8ea4d5c212d5b468392255c92703869f4c6083746408fe6b872d5962f7b60c0bf73e730788546ab061c319ffd92761bb13f0bc0dd7bc558dd9e9f9905d950eb4b7865048aae0c7de1c828cab2a23f5ac4424bc0444dd0eae1042b4988a104f88ea3705f64b5ca129c1772ede47effbd6205ad75a65c4bf0b95aa61e947ad000ee5033248fa07c4cf4b97f249d6e339012616ad76510cff1b08d7b62dd62046b4858e116539cb0cf89ec1490fec269a5a77cb24e2eaf797da70acac7e32406806e143261368686a4cead82a71cba393fac10b058007eb247392737a12071402448d83ba31a9aaad976ddf1ad88f3ea82cfba74bee3a8f008e8ef843f0361b00feb55ab0e302ef9180df32f8d1b0b4173cd1ceba086c3f537f81ed6f082e51c5b062c2c665b89adbc3557d24a24dddeb02677fe54ba270d013f4717cb281b86ae4c6792d3b7a9b43c73f6c6be408b6918f813dd9cefecac7f224e72e2b9364ff7c202d513e8fbb3584ac82e7ab2a0301a92146838f1e669035a5fd8f7162bd568652af6df745816e6259200ce717cbe049d3d9d8c1307b555b6a8502a382e6aec2fb629be1275e1a27607cc55da924c672896d0a12e5197f02b40bad3a34d46f300b8d1df8aa1a554453900a8fe1ef2f653d032c4ab0f83e4e3815867efe16bb026bd5f3aa297f9cb9e43612a86501a6543096bc408632235b29995665d35fe0f5a14bbd158cf40fd05681bb8e22f434d3423dcff67c0bc428e3a45d9a34af7a3a6d0ed6d83914b69266e3c30f4b79858fa9663d3fe06359d0c0e08ebcf5cacc9fba87713a17e1e6ac6c0943dfb0022393de03e21441a8947fbdafa625e89f462151857596a99f6fa268ab30da5c1cdc3d066ea52973c5051cbd2e1c5e74326e72e417e3fa668fa0d21af1766674518f88598380a7c0e752c94d6aa3eab85d3f28998fa2d5fabc88bc8e32fa84db2f2b6892738a725ff0399f29f036422715cda44c4d5eebf833bac8714c0c4b8d9d71f0c2fec7a2854476aefe8716a40d955ef547cc244e40bb525eb2c8e61a9d394931d258b2101a8c967a1dd84877975cd7739a44c4337c280c233a76e3d4d6f712923a7ef5a745152f99e05200f7e4ed089ffefdb62195bb6c2d6dc6897eae22267957259f795a74b1df39ccaa8d8c50a4f1510e5c720b50b75663ba9cec09cc7a17bec6a984474a607e6eff02e9628f77d212ca05b8e354bf88b8abad74fc2fa53b286494b30ed9826acfc879f733c20721fb0e5cd5ca6c16b08391710f0f9679df14c8103f41f2ad976eeb8a797242c0cee5763d696bf7906f3636d629c3e1e8d622b6f2bd2b0efb3ff9f1c02476cd01377adfe8c33df7f6ce78be76dc96dad14421f733b56789947cc569a11bfc846b4c29d9e14ef53aa3b215e782b8510cf707501c0515195d890d9824f851463b8c618a87a2b58ddb7ab744a95645957e9821ea5100385c883b5e77fdcd1a28bbdd361ac613e40f9525233a6caf99764cb68396f03db437f30c9d8e42d0eca9aa7327737aefeefe5ed1af3e40bb28478e287cae026b87dcd8f547035b5397b39b7ed621283f1b625d1bcfc5467efcccf81b6d98a1e5caa1e0f2b31445051bb68218f5cc05ad51b5f94bd64048c363f0004007468a0f7c620b8631e97e293cace57a1e56b2ae6cecb8a310a0917e54e986282630b925b0aec11f98781ebff0607c297ce8fd08534831ed2b6e69de6861cd0529514978fda78e5a9a2dee1bb902918effd9c82d77da7791ebe6014cdbc6bd4a7c8402aa28ff1c3deaeb3f92bab38d0d5b03ee05b50072cbab5d79c6954a9b5a23931d54576283a4cbe64858591f8cd574509e66b62b20edbd97309eed0199c6a3132e3984dad0a69d28bab68ddce7b0b28f7f6e837907b020008daa3662ba11371a2dcbb2014033b2c42d46e8d8bb2cf835b458c0530302ab84a8ae133bda6f7a383b9f3ca78af5d0ad611c9e0ecbe10b707b77f801ed7eb4c2052ff3a50b872124e4c86cd8e9a99c3ac68be17ffbbe342c8b990a7e89a48b2e062ef7eb92883f05a23ba841fcb7a75899c45516b4c16c9a4a377f9dfa9c00fe247eaaf5e682e04fa73b2cd287a3c9ac144144ba7fe8c5fadde3146f93698bae37c24cf01d5f70ed943333c25abd77a7da667b20f071d1ef50daed923e3d751d28758fd81b41d579784d1620fc7709a1be915089e161c6f9815b0a38fc8944b1816fc9d15532aecdd8080921cdfdd3453269605a45a781fb4670f24b24be8c7dca1c73d194f58167210d05c4a5a1b5b63431051d449a4135ca55c3a37281a5dbf4b430dc790935b0fd5ad334920b75da5095c7aa4971fe490f4cc3d0275b2dd6367445193cef94e27064448d58d71787463a42f65cc488c123363975c4177ed81eb8dcaffe267aa7842cf850e21352216f7b14839b4a82be6c79bb3b567c1a5ba233e8679c0c714a629365e269d045692e34b96991579931ba4f3e8aac6e8123a181ea0d96b7364918580e65c969f7e87b7e19419fb0dddf6be52193fdf8391ce68d4d11cbc8fe3cb6ce8e78db7f59bc69b11458bd618623d1aac761426803c4db7313fa0c00d8a646ff9c9e6c479c74110ad0baa4d7dcec8088b1581c2dfca03b049190c67866d0d6ccba8860929b3fca724064ce0062ba9e5a33e385c8a41320435e1ea0dfa8326f0f412f3219fbb0c302146c3cf05fb5c728079685b6dcc0814f4358527f81e52cdb55bf1b928e73f30d79d39a8dad49c09e60d5ffe5cd5a54345464ab36bf3701974ad6f8931d46f7d76b0a867db30ebbbb948483efa61badafe999e40a41b8bd4515f33ba94f59d0eb28400ac64dd033ccb40bf6965bcdddaf0acaa921cdfbb5bada07721ff456139fde7654cc1e193978bd47058810caf78daaddc76cd4a895b6ef367f6e310a11645ef0d145a2de7c651b49519386fee442d28029ba5a81d11b64eb137a5617a3437525cecbab815ce8383a3cced0ceb12aada78d45ba39e5841c7a13f156b2e7d4116996fb944870cc165fbc6a798b6bdf8874d3bd5caa89a330af56a5711d51ac2a0ad7849b8a873824681b7c64111f2c7e3bcc574f44e9285d65ad02d61f64a3baa1c24cc6a04c5009e39ffb97d978bd5298f71cbf934c28e823782e87c3eef8ebac2af95c33a167ab9fbee194acbced76ffeeec23f0133546ca64ef37b149c329a01c2299e676f875fc93728d491f693fd1e4dd82bfab58b50dca75fe6f392b1561d0d06f612ef3089ab9f72c545ef84c5058989427ca30d01dd0f5f3a3a93de28104dfc938cf0baf6c75a81223e5ba990f6c66a7d22bd61a5a829be9084ffeeb771df145e269c31061eb66c66c8bd74259128ce98a2a346c46507a753b2334b898da3f5190af67c9071abf157b8b5fc95bf0796590f720971f3b1fde2db7c8a24b576b1e15032f9288f8e84f6ebff070e3c813b1e89a46d2504bf7f82c5d16b82f12113efe6128e984dc645549c09bc763d73b4378d96bbb2c6f183a9672a56d3ab481f44b5cbb1b78e5fd15a27cf933c45cc1bf5f846cc769ecc5b9137f09c5dd9051606981bb189ceb5b90831373c0e6e92ac08aa0a2f51af6bf2dec644b97dbdd5c82acf42ea6fba16da3235be45addbd3e5d3a5678f6f58da5a407f657c2c7aaad0ce6f525e2877bea022c091d5a3ece768ba64bfc6c9f32c4604d450f6b2327e06fe849b8462c97359af3ce4d48f011018a6e4f294aee393d9967772ded1ab17df31ef20e852f5ced907a4ed84b32c7f8b56f06f2def91dc4b8637c5c3113931d8452fd9e6c7bd1723dd8f527730819c129c4477e10fac44d29814fdccf35e194c315a79dd51760ed34cba4fcf45bf14145f4e1683ff5cbef0a7d5a0941a45ab399000403e9c1e45f6ebfa30cf13486f99651be4959d627fd754c2b59a0e44ecd6e22a8285cf0592d343ab7beda6d22c6a47ff40e7388dea9751e49e370da14866726605ea6e7fa7cb67702721fd409016bfe8f57750081a2918ed00c9c5c787291769b571d92a6c1e79ac41f9b0c7e6e95d505c9ab9ff1a9953850becd24e14dde51a1909cbfa90f654312ed1924c74d4d5f97ece54f96bdfbe64c5481cd9f2e32771945d4af6d140a71df1e5a82e6f51334ff29ae806444157178c9703a0c9ac71692b4764604322472ad3ba0a3cd7eafadbd4726fa15c533aa46a28e28724680c8e93ef79e48594fd880598357468b9e51fe5631af384426a3f3a47a1b37d7dfe25d5b75751c7bb90e9a3a81065d87f774dbe113515642c90cbdc0a4db5cf1b7da85ad1677185b4758e7a7c0a77163ea8712dd698c17460be26ca917df3131ab0fa00cfb26991751d5abf4c5546a08359b14fea10756f078df0baa80b2414f20188dfff9c14758b02b5a1b3169f21ec1842fdd64f7085eda6b2a326a78b0b95213628b5f6f4b9eddbffa9b6977849048953dd6894abc019dfff55ef9dcec36d88de3fa4df626722a82a5462d7e085e8a589b068aeb9c40249ac492dddfd0889835bdce6fa07c1a35ef94e96ef28c5ed5fb20eda1fa950602d3571d06b54e2a589fcab669571059ff50d9b852d309fe15192ea4fb04628eda7cfdd3f69eceb26babe81f1ab093d25d72e3844881cfab6d56dc7afdc405218dcd443be6dc655072bb1e2b1addc88d39450e2c1d93fc3a0fa222a2c440b66eb52d1501f4068f6d3621ee98b247fd0ed35e586b2f04b8169b212744266453f09bf703c1ef70c9711299a9b0f4f3d77ec72099533186f910868b012194039992f9dca0e581edc87bf58792cba612a9fa1af759a32332f4edee684cc8bf934e76026053563aeb1d24c5fd44148adcdea485642150bea0d330e0273849f33c60ca37b2cb0fc80db4e22cd63f96e982d503030b7a07e7e9a160a0058889f0e4fe6b773709221ffe5bcda47345731d18c79e34d047742d9f0f21c09ab7adc11ded0e4841b1ded53943aff1155e245dab5d242009bb0d43aceaeb3f51ae336ac809f8aabf4c7f34dcdb1555bf102d90041c27eb766ac8dac0e897c4d789ab4938bb6e7e76bf88ca6287da4b1b67832756c18b0d936329387ff19153b085022856d35bab4fc081ada1bdbdefb29f52fdfd2bad699aac9bee8d6114fbcab2a347f76e88191298988e23920c31b0f2996e122ea5f699fc9bb77e694093c26e7c6cead07a570a883651ad6e2c1ac0dfc2ebf103dac7b9226d462ca1f58e4c27cde853e1e74b202f1b31682e32376165d61eec6421fc7047913bdde9b2409ef60f7790c02989807ca5e116aab49ebc6fb1f3454fd8c88851c3346fc0049ccc6b09fef6e7f9d8caac649849b4744c33641bf12d75cc0e772342bb37ae014f8eca5169db5a1655a03dcdd2554f89842bfcf806ea982c1ffbd4dabef874d2f5a3a32402698c3295d4f59dbd622c64e4338e9c7cb756fa090f74036245b6fe72bbb8854ab4f20e9edd53d9426ebb39604092f787151d32f162c2f8760d4c7189c95822f6e8f36f41865ddcc2831f8f91b96a2afcc1f9023a63175a54b57235ae33450cba8ed1199190e35835970e1114613426900a36641305b4ff6690eed8a51bd286f7f11d88d565f13e47e132c52bbdf48de64dec0b534dcff2fa0346d513087112efcc46c3a93150a00eb9a7ac1813711caafc1a9e819d54ba752fd4a7941abf221a8ed0f0a3391db5bdea6b8c896199aa4d160c309ebc526eaf983ac9b6394cf9d8398557060862715e1692e0fa178164022b808429b9d8566f8612dd24611c05c45a24d7136f0f0becc3cc7af9ab89696f75509068ece4c6ccccdb51bb6aec1da2c4f6d45ce0aaba081b18ac316dd4ec066e11bb0ab97593ff6831ce7538d304871ffc2b7eafc43b83e9e5d1648a534ebd00487a1eb3d42bf6c6d0c5997b1ee87ae31cb2f0f81a1a9754b2409c208bf11d3b62688c7f01a4b228114f28e45c365d32c597b7e2e8b4dab1b1e0d43aee684662ee30440c20d33a5ba862584ed1af98b4a2113ce8ef9feec4a801dd20389b74c738bb6885ddd0dfd28555bda46790cafb86ea3727d382a8e9743b3c9901fa7d0cc41de87d8eb823e744074d34bcd8bf226c5f017c2429b9463c26bb1f654ca796f5554e529f1ad8f584faaca235cc53b2c1df5907c37dbf057be59436482e5ef6f062b530fb13664e58b10dcb4e6a7b5a11a5fa79fae7d0eff638006b892a424856ee3d927e0441dd2bf5457fb25c16eda815479cb2e67537fbfe1b84cb66cedeb44306a0e2fcf62c9cfe1e84b903073bb24c189822fa82c8beee30be3758941600a043ec41618e5f70f0249c29c0568fb3ca86d353365fef1d62a53a6abde77ad03ff7bf7508082f9213aba3423faeba10881c445cda659cfcf917f1d721a06dbd63e59eb8c51d5908f76758ba09b448c03c7da799d260e00e31cb7c957c91969f213a8e330fbcf3a790a010f8914c92c4b7eb8a3d7540338420b44e17ebf9bc7c37cb34aa0afbf3601d0551d48f0f3b534b0ec0a1b040e8e6f889891f2a86e33e4a29a8d87aa153e126e70110a1f3f749630addebcff48c39d4ac8bbb2d385a344c8e85b320b300e66d02bcea836478a43dd9ec90544831c29bd2eac0410b6fb718995bd7762cf26346d5b6e0c8bf5d84d8a0d2a3a13251766feb5e5d258709872519e54d8a6184eade7b6173fa99aa93b7b21402729a92bd0e8e85659b36a66ad4ba2d051b3c3f36ea6300853986c66397e34de506b76fda6208db9d63facc6ebe7afeca3b2be670e3aa1ae30e81d0dae5f4a135fb5885fdb542cc95db6b150f2cfc3dffc667341e11c7e10a5480ae97d6241302b0bdc1bcd4aaeefbca246c846b48b1d9e2cf18cce550a80429e4bb484d7267dba75675f3f0189dbf335735b08c6b39b7f5cd36e9c597d44720032209c8fb9a21004a7b2743edd26229b6c1370ea55c38095bc000eb1b6675986c87e6da4b7e079cafbdcefb367280263e5adbfa9c11b218aaed982a88932d18f88cc431fc64e5361544633b789e2de83b329fbc68dea9153f027a8078e45ad1b75363c8bcf964eb5a1abbf4d2fd6fe4c2fbb7f2aa144f0635fd56515957107148487acd33e77c18ac9634c8c7c8ef5555d6e6f75cc6157814d5515266a2209565a8644d968215b801350f90444f6a5ba8c4c75d45a86871f6d0569474b580058f01fe541b6761f0674721c236ae4c2ac233559fe9b84fcd027b67046accb84cf882a8a19b0688e64aa6eef685247c7b0ebbcc03a76da76824280dcc28c757979c6654aa5bac2b59ba300e5df48dc4253fbfa6d25f88078ec2e822f535fba4aac5130a5ba7e221447c63bf8f353c60167d78589cfebf815562d7ff35a293e6d022fad72165457f22f3eb1c6dbaa1d4c7774f3aca9472fd966ad0cc2d9d51d20f22bcb43e5072fe1a5945bf1eb88c4609b8aec0591b81d631d8246021c4b3742c5a660f9f639b26b9265c27ac97424e5c0c9a12248be57f323fab4322f447f2ee3752a82cf591f11905772eb36b3e093aae2b47fdd0c714762e56b4c6131525dc9ef446c2cc8981882a05a20b8316930637ff9ee42ea7e6299d7addd70f722d198b32da0c7fd3967cdaf7b3b0f8bf6c4634382dc35694988461a4b84d7bcef6d6dbc878d28ac3088e24ee5d80c36ccbb6393ff195a871828dbe06e92a4aaf28ce0debe011e4f1626ddb0f84f347f9054709f37df473951eb433bc7ccde4f0d6975a59d18eb71958f92a3dd927be024e10450cecff4b2224c5f597cdd5c615b6ba08322d25853a56a624c05dbf54ee7352fd43c5c65424bbd2b4bf943b6982df71fc8f336ad7f76357ee570099f1da6f10c4aac0420a6e7584968667faf4ff645eaa1cdb7a52246983c07821cf4cf621be45fbb6ecb733840a3720e9688d0c00d17728eb6e608f928cb25e1079a3a77b3bca5e5007b9fe0be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
