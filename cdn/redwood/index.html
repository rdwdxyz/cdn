<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43cc45f829e6b079dd3c1aea8eba05b5c138a18d494ad392b7ede20e65ecfb6379f9d42b9fc4a9a6d09037acb370a6583df392bffe543e00909472db5af03db0917622b8908a6476c03c7daa01cba03b14af9364633b0d935f6f31e6136f1835da7932ae51ed536051b94c5bcc3ab9a9ff15c98d863e751dcdc8a7b6856e11ef0bae8886c1a455e412d197246880baff0c7a55e7aebf3660dc1e0c2d0167a804f0429e87ae7f12fc446d519224a33ed3b57d85ba1e497e37208648510f8651e4878a5ce813e2aa9e80f23d85c7855c4f1f432477fe20b7aa8b7e1e46ed78b6c786aea98a7e77e07faf34f317a1bd5c633e79b43db8e6d4f737f15c0483a7c44786c24f66beec26ab3158682fb7f42132334e71735dd2ad8d17d26ac05f8cae8a9d0b5d040855a03d95d7714209bc14fa5fb655c6254255db2638daa2fd1b3c8235e349a465846b74649b388e5dd435a11d2a74be0424ccd4a1645ea973ec7a4023e0269d3657aa4a9941f7b98362cf4a80c3d3b791cb31c6451dc7d8c4cb1417559d660b75f936bd9f6b969784f38c20fe038adc67e5d5bbbb585ca11bb374fcfa8c16df85605b0dbf99255511b029fe0cec70cb15472280825f67f7ffc3ddb954e670fe02db2729a63a1850a71df889daaf5fd6549242d634bb3c580ab888f34001cae3cd2704be6a89d18fc6ed7de392c650b607b570aade218215d5f88f9fc7d047cd9225d777136c472b2879905837ddef216ab1ba7e76707a63702317cf76c48ab0f7e3dc24a7a3450040070438e03a0d167d42eb78e782ab06645dfea357d6ee013281f912b97cb88cd471c284675b09d290625504344763625b7791e90e31d20207e85cee456bcd83f79b9d7639836ee3bff122bf68a5bf95a047d53bd5ca975ba6bfce7227ca845c4a0534fc1d8ee5c8178506cc4f6b88c4701768aaa897f21bfdc77a1542c7561b2e351e4f7f8655d997e05eacb6e92789384e3f3ad03595726050e041f8ff8f32e4f51bf838cec0a8aacc5c07fbc5036155a4c85859ad50d32dedbe465e91d9a453d902171ae905fccd3259729d6f49e0c636ccbdcb367482a381754df8a928e9403b5d980394efa18053814227da31a8af042de6a6c9cbe730d96782e9a61de20f443663dd2b80b97db18d64f5412054d37ab1d779ef464a83a8f0d1e60ebb2206023f83b78cabca161e3745e7877026592351fc6246874eae4baeb70af2b84aec716fda55f33f0f89ff37962698c296a632d80adfe474a96d18bcf114ccd7f51099502f2b53129a959ce83597140e187f71d903c96390c11619799e530336794dd5c9a03f01a72f2e06a4f4d86d89978acea33ff9cd30d14211e7e1e588c29efa3ad085c781f3f3d790e6eb7d44ca9640992163244396954b91b012b5746459b0bb37a607e1782c3def5bd5dda0a541469ea0880550d1881d25b1a73abea8d45962e528327ac798d2584d66ff93c0eac5ddaaad70c2368823e77f30e56cd7e22ad5e4f7cc7fcab9a499cfb0ceeb8507f787fd2094187524c9e67f8af6d49be53e76fdf2c02a7df34b7e5e5884fa727a0a9d392efca20aca1bedaadb567949091e432d9e9be0f8f116cf7c9b57e37e7d82f18bf0d6fc4fec05e121d8e0f8cb210317b27d021c34d3abdcd6840d35b321f1db45a6cb35ddc18ed68e82dcd5170448d665f41d9438b6e77e3c163670f728c03e01dc46e9739bff8bf7d1ff1ac097a2a58268e730c3f2882430ef372ef2b4056a829d30f45de9d9e5441b11b6bd69a4180497fd0534a6a3fc99eafbe3231bc0b9003889b028054cf9110d6b2ea79d7b561a6c41e871bbf2807299a81f478d84fc4382cccc93e4801cfda3b90bd1e28387907de2283e0e51d189a2548e3f3ae4240dd7a2cd2844f80b00ad7055baae39c846717d8e9e5ee7fdf7805e7db5080e000b67405d5a550cf015c68ecd8fdd50d72e8f7a6c71ab4a257fc3cc5a195c80451f50b7e73bbe2996a74634c43c67ee34d45b489335bde03a6a5c2edf0d0cfcc5ed3bee455cbf4090f2abebfde5a2e31b6438dd214dd356528f8ee5c82cf95d2c9bb711cbc6771a3a653893054e131e108a9ab930cf740aa5a1e09e330cc2274a3140745516f1c5fabe91c18ab61afc020be43c817d669e1e6782bda8217b2dea0147b50d60483b0be4ec1e2060250e847805f129b221ff0dbb3c360a8a25f316fe8b5d5ec385e5da19bbb3b84914044c41d5035edce023f9ea3d542d8d7a46d7128e6dc83e75b2b3ac4c8914592a825deff2409dcc7a411225bed99834ec61e741b4a534ed51fbff5b882aefe70b14677a84a8cfd6e277be9b2afab28d3c989ebbe4663481c7f7c46f093618e71df11147eec9fa7e9dd6080f15e360e3b4c0a46c3ccb826cb73843084c644d9575b6b133a6631cde0cf6d5df8f963ae2d1913121a9c09ebf48039f81ae3b4e6ac479749d287147241c5778bbb6df90dca0fc0218b52146d13a079ca40d24d0f89de1d2bc22d61326d4cb032b3551aeeaa6eb40009fc468db58ef6573bd892c75cef8daa6a83079ec5d7ae8fd278c8f8f714fc3f3308ec089401b3f68c9848e4bf43e1cd733e4c332601ef66c5531fbfa5f7caee73c8b69236afa3ffe9517bd6454e479ed5c0b02809bfce2a3899e502ad49924809e992252377b6c1fd2c072e666ca10da8fc6e8cc26df2502d0e141505f6a10442e03c9df69f894278fd6dcce95c7d36d77d2731ee139acf0c5c78e4d5659c5d703fc4717918800d0655054c940f87ef4efd86a1b45cd7a66400fe76d2a4f0d646110fd7e99cacbceda7eaa0d9829edb72861e14039a7f641cf361cf72a15ed20180540294164ddd4bfb25864c8a8aa25f2c1cb2eb10ad242aaa201d5b1d0a72839aaa1eb724641ec9d174a3e2f0aaa72518c6969821e02761421715c4f7d97eb253bf06dd309b3399865b4f4c854c03667afb592cb92fbbbe5c7b585ddb362ee58d56577f7a00e65f175c53b2c0815f1fab9bc413bdad92880397ef9264b720dcbe29d950889fe088984f475a1aa1078984d6a3aad7fcc7a134fe902b39f6e21e9198cf19149da7955955cf3704eca6635c3b64474e5b950cb1b20afda7da991c232649e9e725a336b973bed8ca43b067a5ff086d3952c82e031764bdb6f43ecdcaae407fcb49762872c171081b26f0e0039f78995b08f7ac09257c9a50044b1b68f545ade911b7daf070abd7b3385a737fff606560455f5e2073ee1082338d43e4173eb1aa5580f95d143e62feee2d60bd077a1e9e45920393c614b69edba88e028cd6c1fecde4723aaa08d9a49c767d71f8859c57df0ad9869955a39ec2a772fbbd6e1627e964408bdc9c864272c2152464b5b577e80caa22b35294cb91498371d3ea4a7777a0d4032d8a5c494c395f8686130c4fe87e11019f522fb4a41f5b0ddb5f78c816a044c989021c7a681491952d73b76dff2a76341576db7d3e5f9fb3d8316d0063c31a65fab9a504885b86f545a73fafaabb3d867470ec163e99a1c974a3f109c38aa393520f1d3f3c7716b464a49dfc7964d195801bfb68ef537e6e0227ea4bb60e9407f0f29973707bc50255efeb5c6fed888278050eab46c69bbc886acfa91beaa469076fc8f650a2a88525ff94958c3ab6e78cd256b1af435fb8336af9ba4dcb7c52d3c9bc7afd362919aec9814aaae1bb0420fda7eb4ebb1e539877407c5b6067d730474855dfa6db7348548e60f4bbb34ebcdee8f1fb4cb13f061b99c152110851940820f67191b9fea8a4e38edbcc940a6454862531647daf100f131b070277eb938f10a04387394a2ac4ec0a231de47d2b255c837c25df39d9a787b21c4d6fe5eb3a684019179b57a3229dde1511f0efb737f8ea93a4d0ea9f28000aa53bd622b047fb39eeb5d83f31f5538dc8f395a6f3c8378ab64a9f9f3f51b9da11233e1788b79af4040c7f70b320abf5ecc096f50c3653db601843994cbe1ce6f42fdf7a745775451b0c201b23501133e0349fe5388480f02a3166c32e9100c0d05ae4d4e6d2d62db1bbbe71406ea6a163f782ceb84611e3eddfce30b42fa754406cd12f97d8b9475aa32afb9d585a4284a988f817d2cb4f6dedcd171dbda4a115d9ba3a3c716a9bc6e06d4ffd35f8aad3791a398c57d79df009b41421f4743bf22f527df5808009b7f5af5fc7c90daca83e98c87b7ab69c6172b8bb136c487640fbe03f6f08b1a3b0d3185465bdea42ad41677f171496d2efbb068c550b98054a4cdd19bc320a4c3d3eeb648787535b350f1f017244e90fb30d0b15329afef628bad3ca5c034ff6c08b721ea99fab0d9bf42315b30f97b262eb72166518ab12397c32cb493a8c887dbd7c58016a5a937e509d286f7e837b289d65bdb681eaf02c19bd88c50d129d27d114f7a59a6642dd019cb1f7276ee4c340a08e0171bfef57d9704a79b4ec812a839bcccb97397fc1c49497ee2c9c6e171a05d2f5edf09776d8d08aa6feb98406e685ca228636100c704cc286a00ce085486cb78dbe2686be87de795b54e68c5b1eb3dd0258a94514317069d398e09363edf66e97b556b838eeb151779e77ba14ca1926116991dde0cbce1948da153102040bb7840e2fa7fdb97bbc9f4dac118e175a86ee73fee5804aafe06f90b9e50560d180fcc389a6ca2d6b9001e593a88a4aa2d7e82214cb9cac6a248764e00fb5d79068b5299f750f1c970d39f5d90d03de83c51581f74fe5cfc2192134717bee7d2d2ef812c4b6eafc35618f8769c228a85d9daee3b194b73c76a05c8b5407adaa25080c88021293eb66a516c949db1b6861b5324ac4707e7d33574b8490c66977aa0226f5e88ff008e0aa45648c950ede9af80ec1646cc548b37cb16dc91632051edeab672be528e817394fbe2d1c92a72bbd406f31522f7c0f315cccc710b943db178f9157e0940f2b2eccf3cbc4e7e551199a70f3e448843df3f00369918f1cb666948086f8f0fdae754b32da4dbabf9f26dea8d8f5f3afedea71230b8c672b32429c6fd3deb5c97b9c867df51ec981ec4044a8c48786f1f20405aabbb88f311629c9f85aba8bcfa4287ef8ccdcb12338473adb29e27399541f3227d0db4bdac8adb35ac42e866f3657226d4abcf8d55e628372feb9b039aa16c04d4922b94d8267a51d587bcfa5cdcecee9efee8ef2bdf278dc05fb9f28e6896ed44eb5df27ea469f5abe4fee7129176295d7abae8d364005068a486edcca21c97730621b26ed5391f01979a8c3b988f67c4df7d18ff3c426670a0717b5d29b96733541924bdbce9d4d0e3d8a702912ed9bbc9d4ff7f41b4b72cfd7b91906da236c91e415e72c7a9c375177ef432162edb5d68f0bddf90b1bb0f3685031ffeefe156251ebbe02837fc7d6b2d714924a38037e206bf619475b125a47ccf32a1e77b7b094963381266e366dd1e1b38724b1a643d5da440b55bed40040aca2e80051f290b0dc15ce5e4a630f311aad3f991210e5aeac6b859355ba25c84cf0af28ba6cd7a7e50637a4818ca8663b11ed8a1b14999285f4f34f1b5bc5b5314f4bb8214d69fdfd16d9dcdd8b9ee341a0dead6100a0137dab3cd18681c0c20049752f9f03526771f05aeb7d1946cb07d49f0be0a6de066bb6ff8fbd590093582d83d8e2abab92bdc8c8f5e4b4b906b93a34c8057b60a4a70f08cecf825df903ef2bf5f3c5acdef0fb3e28b4d8d0ceb7fb1816c08a4ccff825197384bf799cdf5ad2fa12db6c3340e704e42d992b90bdc5eaf11cb8fcc5958182d29ad0641cddf1a5c10f5a2c4f1133ccf6411462690425440c9eaa7aa68f8d2c8b0224410f49eb23000bfc0ea813b7ad4f9f5f69e63a1c129411bfc43a060e49d1648ceca2de2ccc62bf160445551ea03c0b952b978f6788bfed6b36dcb52f97d8caeebb8781587bcc1614908dee9d122ea1b0f2f65ef6d202c38e85b3b7e9c1c87f19622b813aa92d7699ac95c88d257cfa8e41d957d889ebd3665ed2e392d2cbb4e713628a91bc29c76a55f0173ec9ff6b1bec45654434988b49fa73c734a717f6ea588a67f793c59ba807e22a5fb264ec62dec83cbe4e9e5ed165a6826149ecd7f71e2327963012184e5ac41eb48f37defb7e0df03ee9f1ddd7e130725ef2fbc3e735f72006f8fdfdf6ddf126f16fe9776d5d659b684d6c3e2cfa2a01d6a2b124acd2da44bb643d969c3d9ca300cca64a0189e4fb92498a4dba1a42a479cd7e552e64135edc5031b1a73d942af3db171c428e053d3d805cac9d2f117bd48916eab632887013c956f12f147b5eb40eb13d06480701e3a4c6bc7c1a3b8b16bbc41d213f60cf65db11604fe0d6ddf4a8b2af3b6b46fd8269d26e21434f79af6673c293df0717ee4a79ea366f12473f39c7e2cb4f3601fb689683de859102c362f9a07002a93f2d8de4aaecc114b250542ee08046b1daa3c74759cf4446485744cfe9180ca3043c1685d8be97ca619d2d2a5383f3ffb61aaff59d62a9426091e8d9ac9c8ef2917374edac81d931d07ba100bf2b2eec842d37c4a144a38f5c189e7b13ee95e4d458818d62fe12d4482c3ac908eff55b64642d290855e2bbc43051ab024fb2a87e45fc7e7a7a814bf8f90e0062f857a1b5d2370ba2c2bc17a6ae89e89e244d1c5a25b3f72a3a0d77cefa99e25c7dd188e7f5dc3173a700ea61cf3275a3e99f388846aed6c58aaefc2804cf2516ec47e7cca90d090ddbdc3ad453f4af5ee2082fa18f3ecd214a3886791556b8239afdce6415342b339651e65018fc522c18356672aa3a79ce77d24087b08b3a9356ee3c1ef36f7741682160e6981b7267ea1348fc694fbf972eef22bfc10db5e558d4f96645661ff7926e5485bd6b915e2cdf8524dd70a1452b43d5c95d38af9c2025e7ea824b60dbf0f53d10e9cf45452d7a159508286a768740ea0d6a19f658e46f6b55b7a35f51747e997b3ce837ccae313b258761619ff656ea95144abcf2f895d8a7dc325b30736aa164f563b059922ed6d6f25e4afd9e51e51c320fcca962028e3e4d2c315e704787c97ac47736702a68a701f0f0bac2839f433f9fed370781ca00b844bf865b597e3e413725d77aab6c73d3b06e2c59ba6fee5121719004714fa27c562aefd44df13893ab34485f1660ca3b2e8f0501aa3ee6aab8b93b51bfaaea8603183f8206c6f9ab3c4c5fb46c0b94aebb9086081ffca27a4324277ed5d67a0dd7c353d1ab4f5fa43914783697114b749af4d7bea7a3b4ef539cd79ecfa220b3586205b1dfdc6b45c848af64afb9622f0aba113d98e3969788656b31002a412233d7725b5abd3a336b0caced3aa1b3897d52c39ecf74b4e0d52d76094f6511200c7b1c5d8b43c0ff9d3fcaa3ca3ade25cbd8f4b3e96c814caf4cc96c99fec5d2ca6cf1044ce89ba350015393d712b6e4f50f5a2fe89f514e8c16c6c4931b50eba01b35cf2773208c94cf137def127c155fdc2ce2122b790d02c921ba4901b2e989f361cb99fbd43816cf699aadf7327adf51e4a788bf736dc8e9be58d5657bd5f67512e9fe034e7daa03cb36c39469e7ef27a4939cd673c240c5d50743029207ba0e9a95548c0405736b255fd81150455e781f8c570601665a41eb7d70ff0936e196656788661630c7e03f9450fe72e230cdb17a934beebacdba13244412fbeb7f756d44ff4d72dadeda2becf455e05ed94d9e689aceef0da9e7b2e6b2e110d89f96a411cc363063a1f958a4beba2b1d07a5ae873b4d79710a22beb538234a6d47733058f4c39ab8959b609cbb9ba0d4ceb80af543d6dbdc949eb7ba7162a592c1eb84aac1c3e9459fba3be0f0a81e5a645d6094c31ef5bce8ef043ea727a94fcf19db383de8015acd2d6e05b253085fd4bd5521b9279618aa5384af5411649b808bc45b1c21c4e3e1a7db4031de2bd2bccdfb83acc6df12d66ded89bfd953a2d1db9b935926be481f06cb8a90cfe6cb800e465bc5f0f56582af89996d4d67c35611040981efff21b9896be8437725f32db838232ef28af46b0c76f67280b55d131e7b2f5a51f75dfd02df4140e470aa43f59066aac35c3d2ff63805d4368025132bd687e051a742b4ff5cc03f5a96e5d8a01aa7b71267104c63de95ae535eb72cc1485c8913f35edcfbc6b64ef8efe913e6661c48e37d665d73083e5d94750fc9683d52f9b1f92821646ac07843a05fae092f78dbd8b1916ad3f6315af72d07225f1dee106246e47208b13e92f836e8d0437bf56052752ea9ef69c838d2dd8139733e502af9b774f4863dd6651791b5ba73a6665cd4f263c46cdce288bcb1140a70d5e7cb79b86534f5b4953f81406fa41b53fa45bf746ecbbd09040c341f981036b936e83574ba75755a63135bef85dc85e678cf3e627ece1b0bc25c4779bad0adcc61fe273d2f55ae2ccfc5269aeef3ad3a8b9bf22fea65e5a37e3df14dcecfca71ae3a0f59f18d3f5e90b0c636c9a1643004e1f4794245f076b0a45de2fb2c8b9822e5e3adbd8872bcb978e15d25d4a19159b2ca0934335d42ce764d825620cdc0c89919e22356e92a020814aaf9e30ab6d40b6850d4c24c3d3425e5ded4b3dc714c18c14c7b3e9c43f7345d1d781a3a7614e781d2cad8daff83cdb82bb3b409b05574228e4f2440cefa657577146f2ee705bc71c724b5017652a2f309243fd7e54bf0e014a7ba7cd245cf3654c56b41345256d03d6b492b9a43d3c3130d14b01aaca6c00ec7559afc270a8dc1c07b9c964f98962f3f1fb47ec12afc050410589ca637ab29262a8ac27572ed832fc9352f505302e32f46d6f2a2194fc70660b93cd0c6d0238f10ab03a55974db4be487ece579379ef4159a00d9dd00e64d82c4785c49e6c75602dfb110d13dd92ba4dd10771a470b70536a1b25c6cfa71b0b8a5263f657d0d95fea9587828c7af02515d3f3d3f329bd5c29d5d150bcdc0c38c361bf65f3101977457f521a92590da18ef1416ec4cc7c4df6b65310214e9db05f10c7abb6a616563ad1929ce0b28a8cbbfd2e5e3bf99f93e5922ac21f209e04b0cb88a222e3921906fbe00181201f1232a4895b1056a5222a4aa1505d12f252bd0c10876e21eb2041f2f0cf2f8d6ba969fbb3164dbd89335f502941f0b1c856cb634c4f2150874c0033137562ce3f26ed26984873662897838a0afee559ff063337fe059cb2a305ef205ca322ff1b9e20a9ccf521427a3df6280c4fd9409467f915a03afa5348ad8dd5538c6c53fbc8decb44435b20115040b2b0d2331b114cd2f9e7eb1d39ac1523192da0f36c66f2206b437918252d73937009fbe14f8203107b9f23b8dcc4fc5b2214c564af2cf6e621abe859ccf2cb312982c8d77547aaa0bcd6ace897561be2b4290d2f3c312669973e01b08943b4bb0e5c35d45c2f6b40b71c488a53801ad48b98f73cf9235b01e66fd5edf5c5fc3056ee2282ea759eb4792b99439e8394a52a4ec90bb65ae73d23290f70acfa3836bac6939e05e66c5b8961a16541006abacc06a5e1085a4dea771b2956edd418f1d61028c88fae26cc378cd50d05dfdbeac918c0a076d646f27f6dff526382e23538e9b762d1f4026307a05f2b304970867cfdd1d82681410c45a6aa9bb74e8bc6e8ba5cc76aba38ecaea98a41651b99cdca25d45b18ea229320b8558ee387986c71ca8815ce0bfb47f6c48b7a7250124ee51b73f04da3c461f0a2ff2eeee29a3e9008deb1ac83a1028698b50189bdf5ed4edcaddb3f7e3b872a4203f3f013a50d85940cadd43f6580f55341c16a75a6552edb0ac5593b0fcc0a8dfeefd9050156a12642f02038f3728fcbe72012d6485a40d1db2c8142b655f315e23e81523fb48989cd0fdcbd16c7db5bcd012f3af1baa46a239c63fd30f011b5de89217545b1e06ab395ea20ad5e4912bc488bb11086259f79507d89326c7ef800e873f8198e9c9ee5bdc5cfde9fc4aaf45f48f70e8c50bc96fc868098c6c9986fe161e6391ef28c7dfd351745be7747e27fcb3911346bed2395670dc1fe2e8d33e5db2f6e35466d1b083fc605291d0517cc52dd308e8a081afac92968704cbeb508ab850c26eb471fd736ef6abe5b63be0583e1ca81faa397f5cab29fbf2d0c1fca89dc6745192b1b3a36dced1fd570fb35bb33565561a2660befb526d47ac1c75ac9062c5dc85319c7e0c0181c57f58c97eaa7a8a10cef5b5283dc50ff35c33f8c4da9f6170b0c314b465a74503e7f9c658b6e7c13d3b64d6f15a4eb4c99c9c3792f8f75d084837722a03368b55ae3d2fa8b0726cce7127d0cfa7d0df4af13f4162bf6c6cf06fe308fbb99862c16a9bc1a882f56a9c8ba4aa8e151895420ad39b6221b1368bb96551dc122588de7fb98d4f5a6a454c103af9b58a0639e81c25f78f240495cdc967ab1d5d976fce8e0b32167a2b2c2d6d3136e601fd7e3d6eb089a409cae3e2dbc1c5e05c6ac06e67ab0ae50423425d6f9f920422cca66762dfe170bd03a006071e6e59df78c73cd7dbb7040062b168c86af54e84749aa8bd16a3423cf35a927c0f7c758ae5d08a29177e5ad6186b0d0bd0944003521155387b548eb61c90f1bb1486f66755e8d3bde9a63aaec7c9926408a997c90caf3788383f24ae65f24ce1729771f435f8fcb64744164a5a0d2f7221fad4fd19490dfc4ad7d19e7f8b4f132351f2bcd0a86ff5336929c1a9474d2b34090be01f6f8e95750b766a3ad07c1215a15d68d897ae82ce20f76f5308d7ecad0f6fdce1050a577b17f8a5d79f6997f23d99cc0e426742e752331d3f192b98084ea8d114c0030ea4bdd9fe4595ea71d899a88b66bc4994d8bdece01f5663cb222343b8045a6028ea324662c37874b27da2fb0f584abdb06110a9341a39737e6e1c57e35c11f0b3db30ab2b879a01ca15ec87a12bdb9134f705cbd72eb355c37f8f3f6eb61bba0844b09ccd85b5b5951cae1fc91953a56f0b00ae58496f5ee8ddeb738dc53ef070a5613eff1f8f453b83c19280f30bad03ccab8e9e528170996edf370dedb95d4c01d7e4a10165f247769aab781c4bb9ab6f60023afc41b7d6c459b6e79204b1a98e07a6eae3c963ff5a61ae94ec850111a3c03275f8d6c69cf629d95b7560ba19f2667479dc18eab7c6e2ce5534199c09b52fade8025233eda206e35c9eaa926ab96b7c49381a074ecae45c627a1ade55f570d03b0bb0726be26ee2a88708e27674c820d8ad95dfda85426c69d5ae6a96419ee400c5ac0c68337bc7640c1b79b50fb8ce7fdca035f804c5edb7b62c4d62d1853d7ea1a68490c3fa341f3725b99f646601204bb937ab8eb3723bd51cd455f9445bb60fcb5759a08e66ef8fdc1d1bb3d617d46d96a161d4ed94a3ee45a987428778c6970eefd9a7c579008f6a7a5b874c4123d029bab5462db745a7019ae22f419a1de924de1504f3ab263914e707cd50b135e6d273d0f9b4cbf89c4df75be8aa7679a90c748fdf5d4ecba13c3238df7e779606d55c5d9861e99a369fe3e76a10e35ca3da4c56c5b1866301b117b76d0ae2b62438b7fe0d9f921ee54c9a11c482f3554e8e6a2299b88a87e1291dd0a6bc628e4a327c3c592806e0867f279971f158f5107633ff2bc9b52e977442dc20492532bc188382d673a6e739749ddc553a0e4f383b43e66e0ea74e32839693783e5e790a502643e9bf9b9283a9f6b07eeb876422022bc7686f4833776c3a59532f9a6e1d869b87d112291d691c57d0b2ce559696da9ec4a2211d9823c12c0525f6721178448c496f45545eb31b2d3b398c5fe48e0d6ab63a2491dd51fd93b4f495a54d72dbd233bdc9f3f08daf59e137a3061b148bd8a7d011be6b1d6bed6899a33d3edcbe2d0700503404189b0d8b36b2aafe74ec0eb1fe43e383e3b16afb533f2dd47f711a609d1085a28d2f27097605def494fc34f073d898d3e3e118824c49a62c741b0fe7c6644d1bb64bd5649abc20c01a58c341004311865ec0969a8510815e3692502e08effa3763cb0157f7c073db4824abc742bbc7028b92d6e1f950cfbed194025e0c58fee92e1cc8ee32d3d0e5be4bc79165453b6e8f9820f164987304ca0eb731d977ee53115a14ffac92519fbed37c245afe67b73e1dfad4ccdb1addedc2abd98a38edb730e6a60761061285a23981bce3aa1f50b0b806bb9aad4301a0382ba539ac5b434f64d29ed65f900d6d794ab8de1a1645460078d5ab2f2c651851346c6c259ccc245639e8ea3087e2e505fde063b5cc22d9901f1e13be2fad42b194cd64b79ea61792c55c629b42307c1900add11b50c041e258cf85e899252ff74ede2b8f08e15d8102c6f18508786a626fab38221a9b924933579c3fc1eac7c6ca44605d075aca4d1af97fc5b4f1cdf48523d0ba4deda1691b37ce0754036a0378d10632afbe9a7e306b55154e7651331e3c9691281b87000fe533590d54cda558b2eefc9cf10c5ffe24d2fc6b1435ac080972bdcf8684404955840d7be1c8570c3dfeddaaf1a799d763e991203c1503496142bb22781f7f37dc16e7d0f115f4673e84cc63652761f0fe78c222680f484d3a260ea588f111ee67a530a2d6730adff1e0fdf263ed57c702393fa8ce4b7e82544542f429593c2e0d31108d55cc8a2e3995cc5f600ed9bb3a054d283b4116726e229ba1faac2956b4bb86f298291409a2b424c78978e565c18cebae4221e12e8d27764fae3f69380ed79db99f80fe847644f3d7ef07aea8a61447b4b44a9f47ceaabe9006050f4f3442a61fc81b1999436912f89140f663727443901d176d5e20f57585b81691fe157e008f6eb1f1170669bdc6f4723a79df2bb4be610a845dc2488c4b94f27edfd2beb09642f26e753e143d4008196382d8e1924d28a5eba049d4d0ce1a83cc0c8398282ecc2d4d3eba4fbea939cc1e1ab30e5e5a0984e9ddc39d38c3f3f2e1692eec90b6f54fffe90126eb71fcf012712c31c53b73d5d931e2f70e83e4655861deae1056e367874989b07895add4629b35dedb1543b976d4b5f84ce9caa0b853657146432aa207fec980ee36c2882b77c30815672709f2a435bc496e149f28bc6c8899b6b4c894f2ce9ee027ec33ef507cc85bb1ff76a8729625fb35b6bdcffc9fcaf132318ba7b6849a3858bb66cc0cdc63af7d75b49b8f7377aee5d47fdcc38859fc919348a1d5fa8d2d3ab205e59b147b7d3bf33638cb22726a891df0431426895cafce10bfae0a9dc8d6860d094125b10a7905133a127c8f05eb27cd7fa320b238599af1a47c74dc55b74e248a788246756897f3e57bffc54757f8a3f3496546bc780afeaa8060f9c09c8b221e2eefb5b0ef1e7ee7408573c1f99a22a3c816fd7346338fffcdd703393e56def1e1760e6ac5c85beff925d4b828ac9ff19715504a180d4c6bbe0623af6f6e9b56a5d7c0ca5a1b4c748464056354483548348cb72f26a16606e1b936279c9430f43aaa30fcfdd40d059036a693735d0c07ddb0eb7df9a07cbab74c76959e217282bb055829fea6b3524abb9bf308f049c29601ef8bdd4484cc6973cb6a89da8257b0432746b819cd2d2a47d369528cc44c8c9c703d5ba190b88b5b6cbec4a5caca9fe130cf3618b1835ac80a10997a8f9f49853b7e8fa672083da436e2be3ddeebf7489ee0efe403234963edfdbb024fc8ae598de32657999c0187898faaccce7a8cbf5982132d509afa658aed6463d5d18bc4825c6a0bd376af155f4fb433958a2a292b8398f6234e2189d1680da4bb55f8f386321d18ff999910acdb9545de5403cff153b211ec536fefea5b7df9511b8a38f74cabd92b9e5c67c21455a0c03f8973d11484fbf0fdb0854097af7befb1ec66b25c65b94868632d2b4ddac489cbfa752649c77a868890bceead1753c2581655fa15083bfb0bf8387b836e3c4dd656f6edbf21ad29784834fe21ea14410f9e970b36133a824ac02956d471c4a4a0e8b9eea22efb7fd1e34e74f88698666ea4e17b3046782ad2f00a2d525e7190daa6e9aeb5e112b7ebbc8cefc28544c8a8b6a5ca69fe16752faacb939c7711e28f43d560fb846859d754b212cb8edfa2646c1ee8b9500c818320e0bd3d350adcdf666b03f90741572e51f70adc24995076ce042b6cf1a2ead4fead20d33437fdb958650364bd2ac52aac1f0d0782bdfefd75e6c154fe75f4d969b79a222b678a449ec592b151a4fb5fabb84a66f2659dd47520dca177317bcc1feea2cfac31ac729fd6260eae70a243372a1b4ca7716a9d7b8d02839ea2b3e9a2fdd76cf816dbda58d60130f3abfa6d422e06bd650f738ea83b6c45747b085dd1fbebbfce18bb33a80213460f67dd48104e57c5fabe7f9d2143a07e0c0e62a958408eed1fbe7fa19c8d359615e52e98654a68351d2e96db1a8b86eb82acd29233a7db973c21f1a9307e4a0a4afacd8cf9cb9fa49a9d9d96c1dc54e6f78637bb860551ab605ebaa83d910c6c0fa89587593513c02c40a906c9daabec2db54094a326e773be8bc2905933a2e4a13dc50a4697a74af10f4b76a70a59a4910d7f672338ebdbec14f4efcc4def3df4c2967aedcccff9c089e11a26321331506f37d3783cfe0cbeda9b2f112c105b2b7fb120a8b48f42dc34d4668dfc8def7536bf40006bc0eb48d50d138cffc8b5a50f7367b097a0fec13974efb55f6fb96ae5d83547b39b7d9021c7a0ad7c7a07cbc93c4136ccd02f669fd12a48ca36f124ef4a8ea406bff9323dd77e84a7919101b6c8c66f78ee92bd6480ec7064d5557688695ca305e1f88b9041292ffa8139f3c01688ad3ee979ca69b39dc16b3dcfd25ef2066fcef7a53c4bc977816548112b96444b39cdd1a142c28029add864a1849be8aa02ff57205a471da11a478f9d830831aa8e0bc23a2fa3530d175176d1f043b4b18f00a72ef24165b3fb3092d5be092b0a9a9bd0a287140d5a975e50762cf44e168fd7f1daf0f37c2f01496bab6478f28afef64e84d0f74045b2744c85367f52a0a83798aea0f141e33d5ec4c318295093725b17daeb30a053438300ddb33fd6f6394e025ba82a066a7ab768633e8fb0707a0d6d6fff11328f5af080027e8834321b7844f612d9e569bf847b7d2a0049bef8b952343e11ea7b8d9fa04531eac8567af1f1fe7fc03cd459aa37cfde196f69baaf27436728e990816add0e11420d988495aaa1272a58e93ea09226d302798cbb0486d8096b715446221ee650597d66200f51343eba688380536656b4c7418dd25f4b8f5e3046d348fbd1f40ce3a88149d2386b70b277e266967bbc5d1c48087be43397fca26bb6a8b7406b67903f396471edc1f983bc30284c15bce7f54c97da5622332dc2a65d5160aaee327911a5c74db64a7277378412388e730031c2c393ae3b388f1a2a0c31a63a1728ae8cd3689235af2013454461ff7888d0ddde0ee21b007e96a85112350ea12c127daa22e3570bc2808b260bb0eef0e95a45bd157bbbd439745ac534760aa9f2c09bc01d6fb8cf549192994f695f09d6b8df10eb64ddaaa6d9f00e1aa609d3266e9a6fde866377701cca2ea34cd8c8cc077d1fd2948b51fbda70341c4ff2f4b532eb87e1b4e5859adde8a520e9eca2b4f0be5501df22477a447c29e3c2660916c5ca536cd399990fe0e58a73ffa63bd19c712a7709b1b439fa653ae99997b0267f5bff046ee19ae94471efd4cda20296bef5130fc308790a0a0d515a1ccad81b7a05f988b7f60ce9f019221afb64ee037ecf02b3d52f9be1d91a29954126d76c78b871d0259d6bfc56fc656dff8bb4031530be9dbb2d3b1d7df9df176244eb49372053a06ecff09ece7197aab8fb166f1de97a2149ebec1a3fa51014eefbc6c36dba19b6005be22e18919e708940598493b37ab92a8b13549ec2fe90966096efe2b5ee9290dba2dfa7281ac19c3616cbf8c7cc55e387391ea88fb58b8adee86fea6921237f66e0220919a87110b75e4f784d490a4cc38aa9f9cf8d111675acc65c608d2292c24b1e73507ce678e44ae14f5b0e03d5361fea62ae58ff7ebee991fc0f578d6c21d1a3db526105261a5e91ff2250f76589c9f342a6d1933077a726596d53ec21870602031acebd37eac6f7f0bcfd2d7417605640736fa6daeb21c226eb5c64062784859dc3943fbf0149c286e61539512e2dea7c00a38636588bd6cf55ce0936d664bf33587e96bed28cbaafbd455f04a46f7aba7cd994831d9beca95976db61e81b3efe548db00fdc22be7b57891160c09bf3efcb10f0fba1b14b83dcb2be9cac2e964bab764ba6deea0a4d25ec28cc2e83c7ca65aff2dacdf710117973d636daa1f7daa636e2f19e4cd8dc254cbae0e90b07427c1e865854a4414ee6f65c42d67c0745815701005c3c8fdab7d25fcdceb2db15f90fc6a3d56321b9972c008bbaf2ac629f23db99e7740d94171098afaeef5e04b64ce2d3c7c40595f2051e57fcfc09a09d0713d90b11468439a547f0128cdd9194e301b6726b3531e66d799a11910ce9b626d60e388200f58af8c9f2a38f3cea03a94646a00a401dd1e6867c1ac7e61c346aae2abb1181ec812e00106c39f51017cffae49d8ae1b33a003dc830d8cb61fd79cac99b1659dfec57a69af4bc1aa46a063e1d394b8c6d310d130d9724085e6e8a5ae90a06930c4a51fff5d4a440f8f14d3180a83196206ec9f8a9bd3542b194a4bde499024ec3cf776f1c32df09bbd5e14e3132e490e98dcf39428138e21acef72a2d85cadd67997c58b14813fa1cd9a6aa6189b1f5524edb5abb0e409245b5a66e6ba64c2f969f1e1277ab1227fb16a6f8673c786576dd563b40dd239025e889b3bf9ed4ff6ad1a66890790ae58832d4dea77169c88fed9f9e27584e6a1b9b3c9e398794fef13e4e82fde091f8b244ff0d9124317adaadee2b10f1fab625346278a245b591241d37eb65ea4afc2918b0b739ab0240e9af10f9dcbfe900b41aa37ae910f4f4e4ae4c95c69a97b5989c48f7be1d536dec04647818193c46f4e0f28f1a994c3d84bfa65b0b1f8e9750cf6e6deb7d1bf6e229ca2706cac0da83eca477bbdcc6d2a76bea8699427ea58ae6337f8762aa1e148b655ab4e5f33a9aaebded634a3cc88b8ecd4356276d07dafe52a74ac2a06a88aca1dfc5e403542bdaea08156b582759399f87299f48268b0caa7c25687fbf10db16a47e6078d2e9fe5d7c85559914a98f83946198897eb8ab7bea2f9b3ffb5137c58fe7ffcbf75f2bdc9684ab08a2d23f8c944ec9fe55b48f22ba7bf49bb07a02365e180f82be6cdc8a33ce1ecff125f1c21953ad357379952c700b70077e9be521d05d3ed4664f95c6f7ca6bab54072728ec851366095fcdc143989df3fa8aaeb678358d7a4f640a82f03accc2894f6c2fda4e29d6a7f170b255e4da9d2a27254938c478baf247d50ac56199ef23f0594736aec14496825db897253909af07e99299acddc97045da76c4bd245b2c69a4cf6a699b9f7b4cb69003e21a82d980932e277546fea9784f51f7f81659c41f7bf4a0ff6ac67bb9db353fb01633880fb2d7a7623379f8ac683e5eec0d7c7b66ceb8eb57a3c37815abadbc8a5c5faaf7069e2c0a2303d2f879bf308610e6ce384e4ed62b5518d65d67f39019aa3ae51f64de21df60e3e9af4960a850a6b7a1c05cdef3df98bbb13ac0b3b05a64a5bc583919a3d9c36713ff98bb373bccce60998ef541b9359e248e606a1bfbce35b9b7d930cbc902560a420c40e996f79bcba87a738c603cc903c7036edc25b40beb62e7b07e34fca03f0a3983aef4866be0388060facde3e8a807c702a5993abe6c8f687f3ce2858e9ff4a107e2363cad60347efa8faa39d1b0d7afe9233390d969f185a143ad590c440c2cdf17cbb2a9a3f83dc0f2473006be6425c910f199792519a2b4b23206d59c2e313c7aff9b449f0d64fa7b87cdf8973575ecfd68320efa15d98a1e54f4b6ba3ddf352ff8a35489f5d4f91bc0bbed8cdbaea8145d4f6ddf0e4668ce5f1f2191c58feb59804e7421243e7fd2fd982c77b9b431cfcbd2ed7207918b7eeab2572b4ca335ef45281ea803e458d01a7cc506a89c28e7c779dfc51bb5a1df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
