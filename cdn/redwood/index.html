<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5df1a86196a417e327ba323b2a53db44e010b7b21b445eedc7f6b09b84e2d285af16bfd8cc83b9640ef6540558cb8429ad68bb38d2b3ed6794904e15a83b9ff63ec682fdde5dc67a88945da2f20eb4b3f6adeb9215005018dcea3d434b730c634c0d2dbdef78e1f2e40c8242626c1d88545e9ecde1f081cbc8230efa3ee49c7d46470ac53fd499e21a99444da014ed7d34d7b0b73899a2c29373f4f8992ce431302385b4bac3398ce7ad5d26ccc0128771e365038cc9e6fce304c329ef055c83b71405c0782c2b9e848c635e84266a01fdfb8c676e869b8a4bea06382a24a69e813801106bafb0348b19640435d71c82794bb663d92f31f77f883a3546bd3ca8e5d6adfe105d11a894ed28d541edadc032aa0852db968721eefa44c655aedec1eed8438331087c72256e2807b0302f9e88c7cd2b8f8e319bf09bcbe7f74a9fb7fe5019a5f48a9280741468e22ffbcbae738140f467ea91fef906682e08c86cb4a823a3fdf901c736c0d91ae2c43a38329f78f468c7d197adaa106c22a732054f1f3a1bab8f20c5962ca89ea4d944c17388ac7b9ae094dc5f2ca57ac64e7ec73508254cfe365a2090fe65f273f6c2fc5db5f2cf861fec636d4088d988bb40c721079ef469cccffb9c9f8dc6ce049fbd0aa9478419ce603830b9b072f4ceeaf03cdb3e1b17ce7f5c0f92a529dc32de22c6c28dbecb7439c483331dca587915d28e2a29aeabbb6fa74d3654074b26614a10a05506c44d20568c60b07e8ec72b270863e4141107bad16a8865e1c41428afe0f0df85da387f54fba9c236d8883fd231032652c5f8e97465451f0edc6b8b958081ac673a2c58abd6df36bbe84629e8e5255f7adde3565841b241858de4a527a16dc78053b56643b989d27eef62d9b9b419f10be7fd3ad1d8338300d62c0c1c3d22d46670b1380c02643314d5e9f0c6df1dab0e743e7b175efa369a64d6354606421b735dc41200782026573479ce4f4dbff8874091cc7d6d33406d55f68e7633d3ca4a219f2bf8ed16028e00eb39408fa559e83797a1c51ef8f9182ea2f7937f1baf0543dc311a215da4b120e7bfe35ab5c7294edc0047bb30fc04766b1b8cbbca78fdaeacd403a1067ef1ff8fae6cd3406817728564c50e6c03651460ff74316eae3ae64658a99db9938eb3a6e7a98118d08c325a20c86a77280960302b25bbdc62240ad33cba9db8f64d9acd5642f00757488849c1408b49d7f40f9791d5e65abbb7306e5c69002a27b2c9940cc36dd8fd043a83a528950d3cee83749cfa3b068b83b8d8f1d6488144718d5a4a762d80dfdef5c81cbcc4d8f340c5af5e9834018fc94a96f428c2491b288cdac26aaf525f233aacdb555cb5673f741080ceaac78ed25733661b036c971b431498880617a77a161e95acc5a382e47a2a18ad7981a11d901f71828e6a8c370f46591b56f701871b13fbcd51ca04fa2911bf1f1847a53c58abd3fd6e35293fff7c5ebf669c9d40d77c3d5452060e9dfd1e5917abf6f6190bfb706eb02e7dd1f54ccae964247ef3bf2555eadb5e114a2d3bdc1ff4b8b842fd32ae04029c31d83723601757081a98a6bb971bb3e529d30510193164d7b823ede1e85145a4779160b34369ea601639f7835a171e7d4dc9682959c82ac3223ea2b7aacca340cc82d632c38c8eff76775e702c68f1ab75f12a70c2d202401fe47f087356aa00742739ad314d93df9c2947c7223a737a5ac501ca05bb20297b42e95881c0bc497b14ef2adc381a1fd62c82f00f5b2c258348dc27257f4d40adbe3632292019857fcce8c9525f9b49716b502405735150116e871abdb4b745b4ea3af400ac2a349358219b8f6bd73fbf5ed39f6fc2b8eac3b35132a7970e56766438304c66b0809ef0d55522234cbbdac994ae9bfd0adc170ad292d198f305952eec49003b44ed0a7774a29a4d33087b03d458b2df83d369008413924e71d7e72e2e00823a79c959d36355e4ae91171f8c3099523b184accf43b77b7c146b83e247a2229c461f01cf8ce93fae4cbb41769188199e34c9e0341c215694d1b84aff86393db89c59872e5683a51d3854fcd342f680e236feb57c57ce316005e7253f990b16397822c8c70ce3c2ff0137141a25de90d54cb36196cb8e989ad8f0658911b209b7dee8b4bf5a165a74befd10563ef0eaa7fa4d707c8146962a56bb3d5077597246c49f654790bb0188d2d7027aa8f668038d3b400f4054d7778b84907fa075c5faf51d4df6ddf0941ebca1da2a9645fdb0c96528b550bcb0c6c50734ff49e1e7fe3d80d61d930b9a4c779980442c64c4c4d91609442675eb09ed57edd91ae1ef78622be73cd98378d5b52dfdcf63c91249b8f586027c09926348ac66def2b36225f90b4b10cc89c547d17423f8b0d72bf3063b4ee78c86806a2e2b73e5d55dd7a3da8d8865d1e0d594b2d5a9983940fe92a8ce71d9c40bf21ffb21749770155871cfc0b3cb56a0efcac0185b40ec2b1e6ad19068ee8b80392a8f610c00877f5e5f00dc5744fffe0e4eacb257a9e6360362159b91ce1b7cba097b8b6ac819e155c8c785b925f1679fd0975de7838ddad9de2dfa9a82d4707100513930a414becc7c1ebf741cb7e612abc5dc59f67374d87dc96492b671ea417cfe7072019331ce062abea084778dbc87df2c9463afd03a7eaf7d446ebf516142749aebd933ed52f74c98fe1bb0ae5c6435e2db93dc4be5e8820996c3c616cb9782d904780d8a74f32c46ed50b42d796790d6b66aefbd4538a9739c0713f103491cbf8bea1b476d5194f6f1ab562765572127568a650833d76fa946bb3a7ea7143ec4fe7ca15fb1c58a6f0c6f5d8c00d1b6ff03a64a7bae6cbdbcbe658b01e815aaf0385efd2a6b42d8f3cac28d82b9e5cff222c96ff649ba9462fbb391e9e384516f421c2c396b077a9773cc1e2800f3dc2e0ffa3f52772b37417661614e4236f5087f9b653a6dfbc56949a41fd94bc945fb40b177acd21d21aaf34a42ddfaad80b7160b7e8729b4d18cd1062f8df297375cc4b2cbfea57de519b4c031dc4e5c4da0e90081342bed12c3993143b20760c01aae264c89da58da5f75cb8429decab7911dfddfc5a48a758863145cf6cf02b58faa9c0e414259e77ddba433a6ae127313fa2591772a1d07beb74276e0b8668416b6cbdf119f6481c45f981b9aaaa259bb7c8322b962b3aeef9c7f07c24a76e50a27adb3f73e79259778dbc49a42ac3786713eb23e54bff6c00384389796dd21f10b73ce1973bf70eb3f7d622eb07f98df5549b92136bf8062f6d8a75379a4f8f1cb52325a7592685d5a02b31da6e03ec7a05623cf3a8defabc897e6d0d870285bcd94a3f8670579fe69c4c4aaab4a92c386f0701e1cb886c7bba7bf78164a44793764b1dd2e40d661f515621b4c5a491e3b46a0ce69cffe0fbf81af46f629455e430ba4cfc8674a4bc67f5f232f84f606319e9b25e0790a69b9597e5c924148c8fafa9c2bcebb6fb74307098c63029a832be388444cd15e33413a7fa349d9efea0f16a4db25699f3a654f8f0ba4a4f7652dfafb81410185a8061257ad1b658e61cc18e12a2976dd0731d647e4aca2d878f635473954527dcd1b46f10f7766a71ffc00c1cade83e9e805d607427db97a1ab296313d5375bf2903846ca03a5e0703f39dec12193964ec3c415c0a313a9e4eb6a96144b04ce70ea7338a684e38ffef46c448b6114c2419305452256ceebdf57938007b1a37cf10bab80772440080f802ceba9db7f109c117a0c7699a6135d2a97680537a9350193c6cf640c96d9c54c14d84185348757745e8ab90a8fae81ac5efbc33432514644875cb340dd0c4b041253f06c9bbe089a97f7650b26697af5ceed6001ed16fe121aeaaa6ea6e98761330ddb91a57cbc4b3c9e2fb3eed5f9157040b70292c33e66e1755d886c81a64a07aee4d5f967c0f11dd1294476c9dc496ca3a932fea56f7ea74a69b8cc15221cba05b2c815036699e696d15a63838ae215f43c922eaa7b8fbd4aaf1fbdf9ef7bba14fe7b08bd2c6fcdc0c9d7588b9e41c631d4135a45f96ae3464140c01ea76ac0d0d2171656bfe88ae9f307dc15cd9ce630bac17b8b59272b6fddddef57f167a63a8dc0bc8f13c575e645cbd12e86ae947b5db84a3c82adb348e4900f86bd39ad1617c60cb25015d0a665c1debc443b8387c8d5da6d61ac0d869c8e112cc53556b2952c13e25a45de3291ebcfde2ca0e7c91ce615e226e264188dc7530f8e31643851a073d92c9f82d0d75e758aaf67f59d0aa1a143b0b3c5686205fec9a8338914354924302c48757a6a1f7de3990fa64eea98df931a57fa01516d93514be5f96ac3abb0a3252ba3ff37257df86c5cbef91379b693e876f4b3ec121498308bd3075397aa5ea742dfdbe1fda327490b2865ab36fe81e9638b0190fc455e696695cb3ab8b468b2565272fd85445024a9b49c226207f6cf70573a9fe7a5c2daeff8fd894f68505d8187f2ac009528832343197ba5cd4cea6284f5f297bf0cb936be849c90de3f58d0a523ea22f84762c489058ea27f34e4e1d6ca39d19c439158c0f1d912fc97622f384b7dc0b88b190075cc1b4ed1ca2389df99d14a1a966517190eb34ed86d1be645fe253d40d6fd8f879aca80fdc9c2e372f2b29a478afc53f6c98c44274b1aaa40492d32cd4c483c4eafda2f30781820ce4adb0df36f53657d73e4e910602a8a8fe3346f5627afc4e10211a74e1403dcdd7fd24c20c91a5d0a651049ee8ea2e5f130e7d9e3fc3b7c61ac412c1bd33ac3da13fe41ce8683493af5c49cea29cc305658b7ddff8b15fc1f5626305f7e951feb6c9e56a32a03dc1cbbcc31e504a650177e83c58010602c2ff958855b80485d55239b06acd9520c1264495b5cddc2ea7ad9c64d6bce3a3d9a226f084b5a33b83f30558e2fbb2c84fcbbf6f895bc1752d4f09666c75259851f0fccf406c3a39b759be7a984cc2c1361b340fd9ac01aaeebffc9b87e4e6e9a1eb0940e1c807b0e98316d261c1078c08a62b5464a0de95d5e66cf0a8cb75e98f18374eb173db5d3caf662fe9c265dc21e12ac97d773984f3fe5ccd7aee85e295ff52fcaba873e9264e1cad35f230b91cc5192f5a0655e79b0992b6e752e17f9640231ac4634eaaf9b4a30e742b7ee55e40f5ebd9017d6c683b7ce33eeeafa54d3db40f60fc6a5891b7ba8e6075cb90aedfa2afb2afc6797d6322f55fadabc17f9c7a8e53f942716571ede4315ad8ec9ffb75193f072cde33f4846a581cb781012f213b53fd30b2d4d1debfe90dfaa8fa3521bdb49e1fe608b5050b618c4aa4e8d2551b2f930566fee3096277b52e94c9701d4d749a3899c261b81d6f35fa61a16fc8cdf6a009ceec629fae48d193c0e0b907e751704f3a49cf238e5d2239a217664ef64bb50597696028605ff8e7186f1f505af40f2434dded1b3c897cdbe6025f4ebf659a239588a230dcee6e378c564c6fc1c8a47daeeaeb8d38414265ee5b281e10d0b4eae8ebc0255a762b9e1de5a9404ebd4dd2e9ea096355a8ee56869655acb1dd02bc06044beaab2e0e672b5904a9e57151283dd50ba0c258adf78de14c9cd527b0ebe636abd914025547fa07e42928c715e894115c3ee630efb1c4c5a0d1bfb1c4343c7048a9cf45d7bac38ae905f1fa8d123f797c8b840fc82728c3283564e25dc63abde019baa3293b1efa58c19631b354c0a7846dde175a1d194891398af0595bc0a4961928058a888db48fa007ee3a8edb141faf458a569febfe78587c435dab92c11927ff37c0f9b9fdf75ffb1648ffcde270a6ecbb062cf30c4d4b69da2d69f3b5093a4f2b67dce0120c251b89cddec96bd386acdfbe0b3b7ac1c826235171b9f9dded9e770b30c639b1c5d23af9af2b8c9dff54b6d7684b4ac168366e1b56ec12337c0a66f5c367c4eecf8dbbda9e49151575c4a0f416ad019527afc9ffd3c6f87902cd012e4f262d94791de2da3dbd9d8672540428b80b89d7255b6e0599e18a2cb6fb440f1b19b23ddd1a7de4280dfb2b0e8b08aba698ea9bdf07e17319338491bbda3cea8a6b0ceef9bb03f080d35814dac2216708599d2a796d336575a82daa5755452af8e06e00871c00fc855a592dd372641b7111306dff672a18328b1d51397b00543e235c1dafcd332a46c2e7f72f08a61be60982dd2a30bca548e3f3eafe3784892c68f12bb98e5ead09f5340632830021c083254207cccef6fdda0fc2c1ee95a1ce3475c43f19fed19eef29b5bf322a73d369729bba246f22051c3eb055cc60fb7691b8f8861b98b470eb44b3134ca48dada9093eadbbb2a4bbe5a3b04e37b2625dd777f1031ae50ba4e5a4f8e629f31cf3041a4970c743dbaefae87c1a90a257744d0c3d28bac24a4dac5705274a4ebd7954871e77a3793e5d320ccefa7998ad92db1f02b781bda29ed85cb68234f6516210a2239b3318c88ea0ff15d9993d58ffdaf286ece69e1dd158eec26dd72156e9d6a413dddcf4f255fe59faaee06fa56705344d11c42e2e9e0dc7c3d5c426a3ac80168d2d55dd9db777ecbfc1bf606f0cc3efb0fbdb96a1839167f3c10e97fada2c069ef061ff660faa8a4cd96c63dbd4294d3a952fc9707b3f76c6c0ef9c4cdd876cfae61b86ef13f389174052bf85474030815b3866e4f2b48b6cbc03562ba6aae0ba864ef3e0a64ce64ae6232eeee8e08ef5160b07c0213eb6136a0febdba2665e8a4f758a1647643c526712fd5b567209fb473e036953d2a77c98f8ab8abd50b7fbabb84d81e439ba3765670fa43e66e5850170d5de4cad62cd0950c6d9c229df7b62dfbe4489e3e98e2816ecc0806e6582cf7aaf98be89446b3e2c6d4a1a543d787d1e12bb7d6988a9a8ea9ad232784bf722fbd02be83e4bc05ef5da7e43eb10c9ffcff88cc9a0435245113b1a85807e7475f4f2c09d1f27c2d0c5cd1b88e411d65552ade3ad7bd13d5ae710d5f0cc67f2c72c27a1e2c76d60de039a787fc96edf2f41b22c9b464c08c20291b632abd2bf8d5c48212c3de9e5273ff6f3d15539bcfc775a85678d7e2984cae2cc58a08325a9f4679eb7118e6e218fd84e944ebfe253e9ad2e9d083451c10fdeaf125e53c04a18afd654370aa4f2e2dc8c4758e4ef3f2d5d5c4d0e0e861218530479de3041fee75bb78eae0059ed27d1fd30c2a022481b23073829820b5720e7ebf7f9729e315a52b7e73c0381441cf8df6c795401b9db7c94056b9f0536e5f6e9918c12acf10c0eacbb9bc04a678668032284dfba78dc152cb4a3ccdcaf821cc2630e44d4b1b0503d61033fa6709d7a09faa008732c51da92f07dac27beb501beec7fb0aa5c911b795f1a3108fd2524ed590b0771adc2f858785700c0ef0d5f1930069f9990f4f37b32c4bd32eacc20c94bb9618684c9f7b6f575117fb055f876ca8de4241e6e3d2c071f7deb097f21b98441fc974505e2de83da5ad930c3c66f963392eaeb094a9b5e6a9cf1256d4f54c98d6f2d53b7b1411d2cfda9115fb0bee8bb073d8f2aa1fbc23a8a83429d0e15fd13dab3a83fe7e7d55f7a0d53e36eb89b7f4fbde7dc5b112d17f43b7251a37391ccc59a204ca4b35fc1eff0a8e4a6aa730f115f636575990643914fb10ca4bcd83cf58f8932deccddec01bf0445abc47895ac87e70f394bf65e967ecfee773d344f610f80dd7f52efc735b49b7dcc4a6826528d7a300cba81e884d1a3077fcb829b8ad57ac842e4b8c2921501e7696c5705da11c654df564bfeb0f1d0a62e1344c056858ae5d11a3f792f38f64135a27eee2652600a70c903256d8935030d61480d9fff4002bdf169a97485713e7dd33faf16589d86627f89d9dd544036da5ad8e8c342320eba445b729d6287308f8cdb92990756e9ad3215edd7a06df48b7840d82b5cd74c51889a4bf523bfbb747eb806f70d8d9739e7956f982239351ec9ffb3c0e59e648697cef5940acdf599a9dd91ad42560596e19b18aa0842820f0baa8dc1288230140414d7ac4cfad9e17dc57589ff2aeb385d96aa55cb50a4bac6beccdcb94d914a7ebe7837e0bf8c852ab3cfc790a496b58e1b5c61c9846fb3cd5b64d82892d38087da8c37feb3454b3ebaabccd93d041bb94dcc66eb4305fd42a6a7acb4e01895030e137b33ac2935065da4887c04586b847bda38961ada9e70c8490962cce35293288645836ed9c0c6136ec5e9587205395b03c437e82f48d2418a87e050a61fa45e904444ccca93e359556faa75b521067b2c02893ad0bead78fb2e4b5af105932cc95d4f6f2a28265177d92f84d8307b6558a6ac697eee2c283d1356db3c9871b10347624c490fb9dc996028703910c78b9f5ff49d2734c62d1086e601db3915d4bd912cebaf8a4dd8516423ca38c42e4bf8fbe42e489414311df9273bae39e3f51d61ba0c06b1bda2d636d1b627e82d2673da8cb3ed74fd39e9042b7eeca8c492ff5d29b402118f0bad063364bfa70cdacf319c4412c1a276c221f5b6b01314b9b56e075ea5d88356eefbdac04683e002f9531d373bc4bbbba68d1434233d1fd36e418229fe977679bead6f1fc48095f2e33eebfec82bfc0bc07a9d5b71736b162723ebff4fb05a8a8046525e7766a35bb05452abbeb2bc909b38ad9247abec8aeb920b89bf00f70375a53add3824eeba7e3401850d0bf17a970ef2b16efa7ffa618190bfbe609e41153628b24108c5f2626de578f1fe81bd4ce3f102303eae15f9304d225174f8befafc9d72bce4bfbbd4b0071411c5adbed767c183524d9e80667d6dec3cd7ff63f703e45e2e82967c4d496ad685da17d90940b70e832acbb968de765b374dfd99daf49a26c0945e1bdbc5d1262429a115b826fb87a1a8961949d1f2736f39fe12e9da2b75db8f24f2a1c2f220465b3d2d33f3a978a7a32b55fb5c2fd98baf2b6014ab7be41b5fcc446d048383defb5a33a1b89a3c36727a9f833d774df1a592a4395224ae29a9d0e57b94c712e2ade5ede24cbdecca8fd653b868f4ec09d39ea270a7fa169a86bf8be8d533d57c87ba9b153cdf237bf9ae247fc35ca174288b11f2d302d0ec1860d13048e014f5fcc0f6a305fe3f8f6762a9f5861564dd6394c1bfd89a7b22b42e7cee8261cb9147544cccdc8c3e572d1528f464dca94847010de84589669e75e2f9cffc5a55a813ac188063006051f8a64c3a39e752d0f32eb6397e3f218897b1c618804ce4e9cb6cb1db62bb79d03ca9e713843c4c9ba873db5f58a30a5a89f7aaa0d816a8c19b354ae5a41e9a3db834fb2a8311f1363e5f489ca929f4995dbe5c199221acfa4cac10558165259717899674ac64b3893cc1f4ea70928f9f21c7795ef1891647c461cdaefede68e9535d790581170141142bfdf5ad489ffeb33a9b0033fc7b3d92e5ca2f5e629a232fed2e6802c5ae3f0b8fc9b319a03f4c928041f9ceb1d424268623d126cf4e3e96547f88f7a4a7e19d012a63a3fd5cc110f01ac607175bbcab66c1af896b28d9e8e7376e55486242f447252154849a4cd094017f0cc989a35492f7315c98f266ed9fe13d0772910648042baf23548b343d711242248db213cfe24457a7a43999d4d25d0c85688b6b5cf0de3b1f267d43172a5c0427acea2d4b0280c50f65d7054a23af29d03ad744725c9aa69c139d8d61331414453f6c9a0498558b5314817696f72b03529453c6d2932ac58dd915e75182d74db7afaff2772e75af5a9ff21a32e20cf7dd35353037c30302107a0079bf6c5b7995b58b4bd4d8019c8cbae9f83f55b9f7cde1e22c581755d6f791af13705e4112e39ba67a3d099d7d1c13749a38e7c7380e0a92a1d6ec4b81376a67f88732160fb6af0eaf47532ff46f35a7205d2cef76f9b22ebf9bc2b89be7e142e20f4fef23c99b2b2cafb6d842a3a7e0d521a83bb10665e580da91b4aa411497ccce6de093f4765e7f1202e403f8198bfb29916a0b935ab66b3c59062a43cb49228a94bc1f20d9e985dc596256f5068f313e925a5068b41eaeeb21ea8f6522db04a2812f53903cfa1e7021345e8cfe06a6ae8a1b2ae1fef368590bdcc111bc92d956446e18f69ee3900422a3ef26e389628df59959257227b0180c08124c74a0e8664349ea0ed2d4baa714c08e72465d5bbfa1397edf17943af380545dda6c677ec70541407593f5180bb3c9e658e3489a1624c68335c573bf4e8e62afca3e6772654e83f55c2fd510450678331322b6387e1800b3e4d49d937ab5f7fddde0bdf7005b2ada1d04d04b5b29f30273f9d1e42ad1c2bafc46f6aacdaf5ab10250ff29d38b93117f2101d9820f35063e3d24c8fa73f36a64a3efb9ee7fd1ccb13e29ed911badcd755d92d886c15cf6791df82fd932c7121ca2d666552ff7672b7ef051762b80d69d9b133c12d879c42a5271ece4422bc5e24fe4790f5c85b381829ab90f93189acc5bfc05c2323df188ac84846279c62d8d3c501f685c2f0e589304ebff883bd39b24ee6415a9bf9d752a5e0ef6f9fe6e0a70a2002488c40652991b49aaf8e591ca984d8626aa47d0f77044ac7a0ba945a1995bcd03aedea698b419d597f5b1b582631e7ab915d0e45a8371051f016b220b53614223e40f34cf4f517c947566b21ca1fb5371b0c1bb5447fcf89afa10210d2b6ceaac5a1a52e91abe991e8a167b79cf829447cff6b9ce6bb54a7362b8154ed8e38bc89f701b9da411582fb2b77c6b6ab52523728152936da3806f896198fddab1599d306e75ae0e88c28db140cf268bf7788bb7c465cd5dcc67f59d4713de7354d4d399f32cfe06c590326d44838d3e3eb14e28ffaa4d88a19bcd9f0c059b1489334d73aa9c362cfb6a8c702bd00b0255fd70d1f19feafaaa5ff65f7b10e03f9eb2ca14a8829796b15f7bfeafd65f9c96ca5bbc500a2604097387852f402bf5a12cb8d4664e80004d47442c709c2cec2a7ce807560dbebca6b644d258f76db0d5c35ec39573257fddb8d0364b35cf85c74bc14d7af69398e1d487f64e6698fdd252767ac9e2244fcd1bd0794073abd082620ba5a351e9e14ef1bad1504a6cfe86268696b3d26003e34ea0c18efd268e199586117fffd05c0055464d7b081d1b1e756cac0ee62dede11a38a7ee8c139b5de27aeb46eda797c0d3f362855be7c5404ccf76b390e5a4c5aafb1c6da5ee899f780a7b4b2e746612ca862b9cd543bc30a1fd7b88fb8e34c4aa1ef9cef1f7d6f54a8319d16ac03bb54da1fac6520407b88f1bdde6a1b8ff3bd2521c90eb0bed3adf32724d4822b4de3079bc858ba5a4cfaa81fb8cf3b883c4460975bf35780fc0924dc3113f14526a7fe5e7a8ae366c3b64e4e881340e8ad438545910abd3680f6b3c749217e1b368657cf7a5a4f64d5b84cb9f163bbe040cf9524f5d19b5412c205e674156d9e40decfec597bc2db9cd02da80cd2fd71b0b397a255ca8e4b12f57eade06c5a2c54c6736845a92434c7ad516fbd0d2f6910bbc064c0d185b99167c5018bc1f5939f2f83daf304375073777e4ad5df3888bee17cec95e47d8c27350dd9c6f77d0e19d7ad21c0e1338d9b921680a6e7efb235698637035b399b13f158043c34f28380cb142e69e07107cc20f7aada8af5dfb672f0b5cef0b21527928c46a4c9eb6565cf2d2cbbda1647fbba834d79dbaa62ff45477e4c1c417e39cdca1b518760428ed67313f1e4e1f86086951b5efd19427db2ec52a89746e6e178a7a36eaa548d3bea8ffee9b7c1b7ee0e2e017802c4baa5386c6639aa73d73e4e32b72d07162c943cdb51c5e2b110fc3ea0ec0b3f73b9b6fe26b9cc73a5d1e468b4588cedfa466a8a631b36863a524eab3ad11c15bf7faf9327d292f531ee817c1a8e5f8838fa1d4e852cd6c3ea69da64e1d5e7536bcf9ab2ce07feb5a54dc16ff5f5b3753c532736e5e8e20d67f42e83646ccb4582a848ec555a1ab8331cf6f510995fc7000ddba1df02b3b88cac41a862b12f9ad919be6b3e52149b8d46cfeac9d25471ad7f2cbe6bf4daacb85a609ce3b1a24cc6a5c729fd47f0a4c744db5bb05551fe974c48b62dbc36bc8d10b1a0e80c9d4c8e7fc3a74dbeb69234d70caa60cab737d7db525f91e8c11ac03299259b29f27dab305de91e3b73859e5c74f05a25c3a94aa93b4a47cc7de2322c07bade20aa0d9953f1fc421c4dfa629feb264d35916daa6d3317f42e8fa046dbacd987a412dcbfc7e0ad1902a98a73ceb832f6d4b8a3b4c43746665c6a1c402fbb1347bcf74b15ff79003d92c641dd47a3db9dae23a87c008bc9abb2b28c5c9b5db405ebe91b745d109d72d18506ebf324c67b910a2b668cd300233d7a53524fa5d466f1a147e921996d72f9e45f885d4e3b5bd0f3d370b38d1d6fc55d9b42f3a4426230df4c3b48f00113b3215a56e7d13905a5e555dfcb233fb4016fa9a80598c8b76b29db568748cf913fbed9a56e112cf170378f1efc67bbcaadbdb9fed87d82d151ae6d33a56f6bdbf3f51396191117d80d65b83cc99e547edf8f381597cafdf018c8651735e929649c7dabe5d88ee8a1cc45b3b9a98c6899848816717463549a5343de89c327ec0cd93ec7990db4d11aedecc5669e914fc3878760a6b969c2d75612f4794292976846e11428e10b50a911c7d7e923f30563556367ad66559cc35a49b0d0694b449dcc8af208f8ab1434de04cf59633500acbd54939d4c34bfef0a889bbd017e296c3eaa469ae748f4d517114ceb3c2b2176a13e729d3ce6a72a3027217ae21f0cd696e756568dca95489c087f3c797dd5fa0460e8a918cf29fd0e27aa6f90425d8470148904ea256748ee742d7d3a01441b52f64c67156672d9a848964f610b2e3dcbeb22ecb2c752528985c0f84ab89b59a293f728f46a94c8c65aacc7c7db9b084717268e440b9074e111fc3188e36dcb8270e6a9bc5aaf3705d7e3e86c9584adb788b44ecc0257a738b8b370b147bbf979dad521fa43d9a7fc7cd2be4f3ab51f859d1ca4d23a3b082d76bdd2c913047ea59c78b5d4eefd36ca03d7d972972feef52efff051e8ea7228a714f67405f1d39611db245c5e5ef36046d1c8fe8e58fa4ca5b6a4c10866f83068665412266a8c5bc8b78939405a638d9944755d3ea6075e8a43d46e60628e3800bff31da8b40db3c3361141810e673a1bcce00d4e4a1b094fd63b97e0f2dbb3ca045a849f162aef174e51310a0d5cb056154f40f490c9641e89dba9de36312a51a2b2b43194283f1a02fbfb1bb4e9c9ef75c8e5cc2545eec13d25a081f74776d1f9959e630c7407ab8d1fcc3d2ffd951958865e839114ceae21efb3e17811e50f4a8875d69e567a63f1ed1a864d3e03db10d1587f97a68139f543e671fa096fd2f08bac29e918d03d7672736e11dd0984a27e4df0fe0a5a44e2433d279f40e4f0afca2bb888b4fcb8917691f000e55b5b31ceb17a6d11e3ecef1fd17ee503836ccdf768f59cdce0c4807e0adaf6bdd8470a905561a1cae1e6fca9635a3f17676d478b6717aefe5cad242abce7ae4a789c5f2bd6c122c0caf2f469d97b3aae378e9fef3c30c6ac654e12ae1e6e8f80bc34cd129e7c2f93ff962c9c46ff8d17a477b8b7eadcf12351c43a7165b45e43728b9228d84a523fd35d2595c72ebee59196cb109c476034a70441beb6d540c4f92fbcc2ce7287200f6ae32c1e5d8aa7f2be7c66783eb94233a84c1e62cbd920c3108b7c61db2012562cdeb652cdf1de388adba143f7c3ccd01b9501b6fbc580eff9e80908fc1ee060be0de831ddfddb241560976e8485f027d416033d792a75645109f090c47c092c51622315cdabc005e169cdda6a62457d55cb6d67f9905ea527ba5c4ab873c13fabda6b5e4f5ebe7855a6255ec3a9642f3500fc53615948aadc340376525de5730541c67527fb27e83efed506dad667b6deb1ea5efac4165bd2135c29f416c8f57e938ce85cc3c4bf8eb66b2ebd5e8681f2d4aaad34a45aa643f8eb4b82aec93ff10dc963ca6e3e4bd4088354ee94fd0cfbfde329923c53e44fe9b1cd164984bc827f8aa3607200783861c3456f97cf538cf19393fce640f9dfcc7e101ca6726d393e598cee6d1a56c6db53e36faa8173d59623187ef9ef9cc6813422f6ea098cb4a2dcd4e11f26e634972127ea80c5e01fe36a53a7ecf1333140dc8b49019dc4a20b8744e6850288c75359935bf576f736491e23c0d0fc5480b8651b26fd30b1780dc80dff0393461d2e71966ff2f8d4591af3ae344861976488c90e19115e4fe0fa3f15a82be11323c9008df3b95f85557d5254b355167c1e38869af31c628b941b8099fb60694543bfc6c5b52e3ff067c024b6863c1c582ebdaed52f3ed32eacce9e56a825820adfd577054e369e094ff1365cc6c1f7b014ac597894bddba7bb899f2e35221a348cbb31a024cfa268857c5f82a4512a51dc11d269835e46dc3942caf923ad4be9f82c71473b8ae2fc3ab6538542c1e2ab967a5f456fc7a191ebfa51f51215de4a334b1442b35226b49de85835f28e479043ab3055eabe157f5bec3668922a8e6ddb04727cd55e3b7d08a4e8dc3a970cb4b54b29beef8bbe055e9cc34cc3bca329b91adc6a6d053f8ed55a8c08ddd0adc2d367d5f0431dca8c65a7cdd9bb3d619bd9542d30cbf3e9883632ddd6f0066069b2a0d4d0f9d945f5bd2ccaec9e8a4ba5f12931203a8db40d096bfaffa5eaf043bda378e6d4a69ceca066382b5adadff11bc405e6d7ebc95a5ad604a52f54962a335ab64723ca90e154ce23c39432df06234d762cb9c8b0f841fd0bb890b083ed88f4d5bd14762a1b2d88b3416919b61e48d6001d75070bf8cb92861d60820b0239eb8997a96057ae9650a9d9e65ae593d53cd0e7d237dc75b1259eac7eb9fdd26ac25da856dc2eaf42567f7c9caff6ccf6239a85e1f75a1df506c6fe4cb8d71526871826a99c0ce7e7e53d65f586ee4d4b963cf3101f4e2d1e03aa1e887e46f2f7e2670b3416b853ec343e76ecf3febe6634445fb79dad32271c731fd7899b095f69e59888e09890f1f81bff63b2c3002093204e564f7b765f8fd9ac362c735205851cd6f453acb31d4339f2818e6818c222ce231e63e7f8854fb0d12d7a4e895d8dd13c1bc07f7b5080f167e27e644769a1d118563f10bd766d394586765528b268d69a0a154a49ef5d1609508b7117705efd72c580126bfa3e2702415655dac0eded72ad60917ccc2a15058719c6f972c331419cb141fa0fd81e9330d7a879400bfb2451177d76ec7eb4dfa98c122b1e4dcc955fcf46c8813949d9e5138e95344819ec97f4ca8bf0e2ecf772c2f53b156c5be7e716dd795a2627887b3cb1229c4f5e37a12c02e0b31cde3a0af69b80043a6ba5583d5ee2c1a1c9b4087a11a699f80fa7601d122bc8e8e7f562b5514f69fd736e82499668f1fb5dbd5bd6f045a5885ea99f7bfa426ddc3ff621112760d969b7a5f439368cc2f8859a8da3e7afa610548720cf00bb6dc59cb72d55db571125dbb79e49c77b789e86ecb42ae1c6e816e365f2c95aa5cb18d3fc37da573d45beef8057e9e4f6d0d834bf7089ffe57e7e642a649557920e9c412df31c2509c8002a6f7ccc36ead23737c3efcf2185d7ff5148ea7bf445ad77ea1d15a506dcbc0578c7a14b3a67d79c848899a40a2442eaf68e8297a797a1f04411e4787e44d3385519d503e701146dbbcaefe81a9f50e6d37a0b2943acfc2695749e78bdd3ce03285f16ed498c5058e85c4e3e0d15273086374f88129bd2757fca59ed980fdbd1aac656768e0155e52d99bb5f3f64dae6d9b742451a1be8b703a582d29738118dc1924f1720c0e7c43f9516c38a14345ac0a3af5545d33cc340e7972ce197bf691548404948ab07bc81cf71349d7bb9a25acff4962aee901b59386bf45283203b2e67ca3ebb94ff3104ac2948d0bafff5bb3566d41118eb7627f1c48f35761772972c953407d5d877aa71c278528f253ef0a9bcaca13b281323c264ed5ac9d86f88bcb406374d021fd7dc52df6732f3fe6e2c62285a0eb32235d1e5a262abb514480c9230182cda17b2ed713d6e04a9392404edd64596f2b7e4b86676ef9c81124ef8b5b5290c089c3b770131fa555673df3efd7b2029e8f23a491ab7c47576d9fb703cc7b88b2999e36ef89c0129c05ca166c6e2402e1b981eb2163f91ad0b72dc63a646dcc787ebfee68dde98b3153e107daabe9f259ac4ff347f5c4ed2b997ab8955904d31ed76e9ebf749219833e9414529b56238be52a5b4ae84331e70558304333d6868e2ad0ad673ff3fc1dbc5ecc3f8b5d50636a10eaa38559d82df46ca109bc64cb5f1529e2723b4c28192cb2435fde8eb6fe9c5360ebbbeceba7bd4f02a8f1ec4524e19732c718bf6212f622f7bb59cd00f5b37f3ae116066e7cc54f0014e46576a68501a1c4ea032053caac9a28662f46274014601ffa7cbab88a976d3ce309527292230ff860fa07d745816c3d3709bc30e4a46d844511f4abcd6b02ffd7a9d22d5e7b4c97cd4bfb5cc4efb4b1dc2c4bf39755baa1f726f6e6d8286b3db060b995f0376278aa5745bebaeb9978ec29cbb2423bf2651247339cdceff41ca0d34d7a4298b3904fbcd07d939a61b734cedfd7ca0780d622e060f7b9bdb39befd471be6fd47e9741a7ede2b767cdc1e5ba388a00d0b3ff91127986321592ff2320523a9868bc8c68953d4b6183fdf9e3db9d4ec33016fbe848c1af43c30841a1c55b0c14dcb456e559a475c297bdb434746b3bcef3909c9dc7cc51cc60976016f4c6ebb82dc336ff478cc5dd3295cc50f02e72c703493cefdbdaf566f5e0de4b8d12ade5347ef3d31c1a2c1f55431864e4d752deacc82fbeb76a92b51e80c0ea918e5fe6945d5b8c0508721ec3e328ac23d8193e722757a2f93c213e10cdaaaf678f862e99d7f2175699c2e5f4ad18361aaccb8732a8330ae3412515aca226bf544928408a0e902352c97449c0de995465d0e3fafcfd68698f71d79cfcd6d926a86e26a9d2a7d93a57eb54197a617475604779c4a4aa501997981d4e084111e4e6b21031ff61023c89989fb181c93adbf016743f2f821caf587c0e5932cf551c63f77704206803d2d624f7dea9462acfcdc53f0ee69c8f7308d0e82c3561f30c0f760eed550f8b058119fee63189f030091e14f3b5b69937da8b80741e0334045fcc22e2c5fc66da8fffc5eb35c3d6bce294c888124c913616b68354754abd9bdde35fe43e196702803df14f21c02e3693d0c59a6400b5fb35c014427894f3c9b3025e3d3e81a0ca4ba5286da8172433f102dd578285794d92b7166815443aed3857a2bd02fc4d46b66f63e587e8da1ebe253346adfe95c2a849ef91de029200ae99668a214022a3763beaa694a8838f2f8d57ec8ae752cee39fb7c9731452159dfa21214a0951f61a1d552a342aaf35f0a5686622c074b4693353305e96e01a79c542c6c7ab3cc217027fc3cf175ced3c9ed14db39c04e947b63a610df61d63c3012dae3ce84237aa60a2a75c052ab72e83f63e75ac0ad2a525ff43ab86f12d310b0e5d5dd6c01ff1baa5457cb5ce9c705b3b23b9b7cc41cf7798f2646b6036788b6fd4d17fdaf565f5d7b0a41ef1debb8fff3f6645c8dd9445978bcf32fb704171e9d4a89742f61f2566bcd00c3ff76a73d77e57f6bd4cae99162cb6299960436932d695b01939f6fb9e423d7de7275119610ee902b954205a2ba5669aa7a578b6f2d26e5f73b5d3779945d5bc9d797d5ea6f6c81547d1d92b4055eadcc952b797c260ae455e8333ecad122129cc5e2574802d1b34240040afd5901454e4a400ceb731ddc27238a62bd9ad337c88b6172195504fb3d9a39005a8e0e113a71a46817c33921247564a68e2e373a1e196e88036891322fb5d0cb3e3e29e728874319795ee63c7c3f5e1c5062f88a7cb3f0a5b3ac0cd355d0be7378aff1034c69cd599ec4ec9162631d78e3fa43e54ed2aaed122fb377fffe0c1d4aa561e115d8d6cbac8563f8aa44795d230df47fcb7a06978a42bda2a4f5ef8b089fd5352b8fb580d101b007f70af8721d303","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
