<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fce410cfd15df2322aad8b637ee46078086cb812af901f7897af2eecb309a72ced03e6b3f1d61b8e91ce2f92e02bbec74114840943b482d51cb2bb8f320139133c61b5536d99248013433272633cb6df7f42334bac0756a4d3b584f5998d53a3862c4580c56f1a0708dd620ccda212a0c1214eaaf19b4d30bc869226ee917846ee63f5ff8b3c1c3c4e8ffb083637050e4806a48d314129541b1dc723a47b104a4867ad84b492039fccb029108ad9e79c9c73069f740bb1b9c94cfd776ff3f1cc5b980c4c255c6331cc5d5d7622f13e33c465240185abb56fa15ec7c15a728dcb63d5935c6881c1df7467c17891952ff65d689347874903ea0213cafe3db230b17b0bd21df313c18b61e2d945d564af1b4d7d5d911b0576f92e69786a2fee555e8ff07ef6183ec9281d9a9110b0388055a8e083e6471d466e298a73e1f2cbb2c1f2667e11f5c5ecf1fdaa3eac4d7f3baff6a60d00a48b1a77269f205704d4218a95c2ada254462016b0c997172763f623a6a47a28f45059381977c7270ebc94a311b9fbdb7f676d97aabc41b1e8d10e8b8c222705fc2bd96eac2e2350986c90c33b1c9721ec0a1344e6946c4bf13f644da409cf6026aa5660c04d85fefba56c8f7ec5a6bb4da7725cee9fcb7dda3bdaed87023f900488ac795d3870171bdad977d2bb28ca736c3474328ee20076b1c5f71d7f8da215a7365b2cb0d6984a60acf3a9b8f58083a37f30ad07db4698c97c5e890dfeaddd79b7ae471fb68821bf0aced0b8c692360c7c3d32ba4ddad08ee5442e9ce896827bb6bcd0fb7b2c65320d0672a3703675da83da1adbe187fc38f851baf57e0040f091055bdbc24e5bd1c885112547a376efb7a5b2a2c569e9b82580db51dd678ba5c8c9669e34ce95ae3ce75c445926feaf7f480695fce0f0ebc4d55bb8a54ad227b448961881b4dcc4c968f547f9c5448a1a9370bb992c36b6e9171cfd24dbf799cfe421fa84869b236456cc3be5b6490b0b3360b2712fece4a4a784c70b5f500b9b7ded9f322ac44a3e804837cccc691c2990394f53d6729d393f2dfaf6d8f86fbd81190f2baab1e93859f678dff749fcdd7c4ade5b2dc08ca4c952e3c57266929b99ca9b690ceee1cbf6de68f03a60c1e12842b91c35412eb1abe7b44b20935a205843252db3b59f67e0691f7ead7729eddec94b28e8a991c9ab9b669b5277c3e545fd7a5d291eac2d936da33ff573566eed5aa3b4d7a9f280c3a572dc2cde9acc43b5ee9aa47ec83a074bde41ae3a8ee1517a8ba91ce1a97827cdb2f0f8a93700a507efc838749983199a60b7c5afb994c9a37fd89b0a0831cfa98e0e2a55a5dac34fc89098af90a3b7a3fdfa467b5332113b51fe92dd583076c8a28b6bfcc46b8b348ea4c33189f4b18fdffdbfa63d3bd81e8787b90da859cbb91e37df4f28015b71d9e3b523e1a4446ae2f6988c860a42239bfc8bafe6750a3893fdd51ad8ce6f2b3c24572bb659b94d6c13714a4e291e3cb7aac4d1bd9cae8d23d3d6f52a63e94289342984534d0ac61ee40101b4cd3ff59bcb75ed54e7f2ab48859d64a7a6679a36e892d6fa34dfe815517af83d6285b57e6b22b62fd9b9a4936d72461aab194247e06df53a3259647004d7b3ef864fb24d6ab66b6777bd93fc3ba2fe24a1b8e29dd0bf2fcb4ff5ecbed116533572439c148d2877fb5b87209c82c584562c415bc53b62c892c1193dfdd26b4c7c0eb99022eb01558a82028f7e7794f545f1fc2835a9ee3e080475b4e1bf9eeaeb3f34f038f1865bf0231726051c4b805e844d04b9a895d97f07c0fc9ae912be8ebf4b6119610c971c5e9e7689c903b9a1208c1ee1033660a69534a425dc23669ddc6c68ae35b290956b0b7c39b9c5e4c47ee28cb7cc106004335b22b3a9768585a656befe3335602d3c091cc7e390fe174b83f3de27a7864cfe7db108d7f4e7655ca51ec8b1fad34e7dae2265f03120b6f276ef861132b71b67c19e920c4e961947f241494728c8c0b41329cc559500cee6b1f5cdc73540c9ccaffa20111956c84e0cee3b7fb84531962248cb86bd4bb9398ff2db9367923236c808e20b038502a307cfe847cdcf59f3a96cccb5275e864b8f156bc09e0cc5f4d9b1f04457dc9e65b4207855950b427ebcc5425c631199d88023e3e87ab44f5ca50d9e46a5262b58af22dc696a645c523b66c9f8924a1a9277f28461ac6a94946a798befe0573280230cc0b144119c886f73b60d533f2dea450e293e6ab4e2c06a9b56638a61e13af3392bc407e37656041b50601f19f513abfc0ec9d9440f9cd9ebe165ac2a1b1ddeaec43201514e5e30ebe297eb96a9338d9b9a62827ff217a7a526503e5aef4bebcd484f36678b4f9de1c2199484f419929392dc6e14eb0527d71e0ab1f7279c0a2b2cc4b6561616272221a9e374752895fed4a64a82c10307f89c1f2a6c3e6f95fd3e397e01e7dd4ec1fd82404aecc13d93369c51d7168d99e50840436463d28c72cb629db100b013e68cacad88141d66105671bc893c5e770541465197ea0ea32352529d21ae4b0087aaa814eee3a9782ea9b3d8c68d717fe8341830a13f63996dcd4e35ca813ae6486369f97ce8ff475fd0fb5fed17c8e1735a7661a164b5500989cd92c43974e22c29e5353659710fd63473d31311eb07269c3b555852426231a82423f70621eabac7de6f19d87ae778418256e8c4c952f238fe68cbec42a03046389b111bfde0e9ac5eeea38f0c5e2264075d53aa96c19ef8a5d83f1d706ba866e953487b3319dc3257b7ffb769f791cf4d9e2e6cfb8cd32708396f78da161b39c262a9cd601cf816a38527e096e6f2f5d2f5c4172292d7f06c0d5393c3a8787a4553ee35db9ba1255b935b1ac254620920eb01ba07293050ba001cf370be3b5dd33e9f18e871011943fccd8ee5200e5a32a1b242006c11ca84e27e42c3f189e84242cb63796b625e031e1130bb14d453163a193702449eef71454f01c957c41c4f3917d674346ef45c53923b93ae6da07b9fa16149a6c8b5680fa59153c1f67c900f6702c31c1727d819d367f3de76b418b4a764ea29d3dd0a4e45303ea4a02c1703507114eede1bb1821329d1c489bd9c85c52ba4d1f325ff9a2789707cfd08ccb4ca17e8db15a6f40990076354b0eb27d6340ffea5ed8f8b12d79c370b7609c58f3ae518ae55c364015a03648a9f73cd85b33f336d006f5590c003b3c4525f7e43da7a87bed95fea982c556122b1645ac47372fa95833cf7f120f420444d12a2cf7c4aaa81d88b4c45eb251b1bcd79fefe042fe09183ad23969132a7344f78f56803b5f0c58b5a717869f2ec29a67e93defa6c454179cac2dcf0c8e5ac74ee6d20c61649375c3172745127327da418e34429e8dd8d6afbda91b535cbff3dd4ed2b90ca898c7609da44a35e4cf7902af82f27c57183459ca0d72c94925651943f1b9eaac56ab03870e2c3ffa6846f0a8eb5714cc1e594f362af91ce360164a1318df35ba17a536b28bc7f81646aeaa7793e9b44de0e9b166fb6c8bbaa904ebc8f036ea049af54b186fe1ecdd2ecf269114ab7a276d686a75f4be4642d9fc48e6b4d7afcdf247d0bc3cfcf3956628c9950ee7e3fac84b8bc94359074b5615a8d679f887d636b18f1965d306a6d6129707892398cbbf93034ad0796725f2e3dfcabf867bb49e83eea45d6aa7dc67d3e4f2c001f8686b08404dbc11227e830c11806c97f3088251ecebfbefe2b20aac07110fd5f8d26d4cb34c2cd8afe56cb14df2d01e79e51ec25ce7219b9794e6cb5510009f96408994ed83d51bd8990451bb2e3d97de57fdb2085be00c557d10ea8dfd4eeb90f3d564dcb868f9b47ab2c6aef8369fd47cec05f8dc8f0ef381d60db4de472d0f24b97ceed10aca47184d0a0c894b0cb49f07ae1e83c74e0c72491ec703aa85c4da3c44ad199412414261b9e47680578a7ec93229e5d21ae0e395604a8b0a42fd3e4f5f3e627e8a4dd46e270df7019d53db8691665bf3226de100e70dcaadeb44365be79733a0ff9510195ef95f23e305ef423fb304bb71dd2b26988a56616a917ac153e89d22c3257ab874480d800a227814d7c2edc1f5d7a1abab6dc6b33c85d80a0840d53321f4afc4631de1100ef36f3bf72afc4d91cecb105f01a1181b4450e933fb6c68c675ae603672092e1c6fac606759a7b722e0c41c2f11baab9052c569c4b78d824a63d2d0aa4cd1c07540d45aa9f6016a51561e2a4db00d9b72c0fcbe843b974633f9da7596438027c1e858b558b22954853553bcb17016c163995c6990b52beaa075e9e3379749e6d2f57aac78221825e614f8f7f25ef915b5501d6266b134173ce48a3bea382b4544d5fc3b850e8bd10a241736051268ab74391c83bd2f929843e94f117b8b8d85a3f039e25ec243edbaadb116e05f4a7f5a6a1953d82b5d2ce0ab371e36d0d1797b6a2eceb639166790b92d8dea2f8a38a25b9473faad39f59ce093b15260ace47f2cde495aba69ce4642588253b461a35307029282acb8e7ac681debef0ec44ec8783146c0507485e70a1ec67eb76f32ec388128bf5a4c2d4ef1d741aeff59b827587c54911ebdf148a284b795f3587a09fbb64f324e14a6fbc70224f96b518568df87c59f1c769cf87c37abcadf92d6747286ff2aad2867bfbf887f5a439f99a2cc6c3109c69bbcf6b69a3eacaeeb7598c973779b48c36685f183207c26baba0ef1a35fbfa1c3440c07b940ca823cf64fc695677f5c9a7ca8b56a63621e1a30f2d88a1948370a9ce1941d517fc3e6aef02a3bf80b0f0187e9910e25af141f4992ee3f5751248637569d17470b8871b50fb0a1a1cd30c014d13e21814e816a6222df848eb187e4922ec95889297f01f6b375b0314c90b9ef544ba265b1dfce17c8f193d4037fb07686a5b0ec4e945caa78f3191c9da872183e812b6b9fd65766f9e136989a3187eb051a79114410e48c2085f8472ae04eb99ed2236e8d9086d9bd095f12726b7cf8dadc824437e607a105e9f2e4629704c17359843ca24a90475b7b1cfe06570170dd1c37cae26515a8378aabbd87b85aad8fcc52e78a609414be358cdf0f6c628001b1bab648f569af69d13a1286c57fa1e3e3d25f9200d8556e58c5e1fbadeba7465ace78b4c5b04dc87c0b5dfbb1c0695c3adcdaf3d9a4877d25ea7424d85ed7f79258b401eb2c4dc19464d2799fbb436feb9d3efb0085ba523d2edcabdcdae359c644856c936d1fdc2a31e047325038128b07e8d9870ce132661487436975aa712a73b34d96cd41befe3891dffd1f7d21b0ec8d6123bd04e0af191c2b3570ebc4737969a79a7673cbb358ba7ca9b3e57a894d4c90550cb21a68f3dbd64dc29ae5afbe2b1a79ff850bac1c4bc129a2b8362aaf9b2ef3ba151bafe8749f60151a82c8e2bea4329d9633e3ee51d10c050b642cb4fbf0e067d89e9209ed0420816cf964c41df76eb33aec8147c706789b9b38fbd685a3b984d76fca7237b25717886347552641e8a8865078cbeb556410e375dadd7ca7ee9d68b6e08ef57857d2d85951296cd21ff042bed04b1707ded2963d11772a7f63153011e6684d763e57dd4b52d3a9f976600b7eb18d1e2db11c48a60c653c5314bbd0f3b926e112efded3617973b29b8aae080e5fc9874f53b5e1bbbbed7b281d98bdc88372979d0d41aaa07b89473b1e3a48588e35b8d2d5ab23831d248bde15866ee18e21d3c0c9ef84106e2a27c890743f052f9567efedfb34a75e1934d8cfd71f1fa393b84cd3dfae2c4654ce2c1a51fad54529551a814ec4a4a50ceb4468cc8fd3de6095a66c7b0486638060c56338ea138e36c62b5340d032d04953c87d76d831912412c51e468d4c9c3fc8c1d6a1278697cba0828978fc2dffe660f81c23ae6e41ed83e16164cbd0b4fb6fe98d19bb06262bc389e88b0d6bff8d832acb116d933f0f46afb801db182661b9c89a7eada05d9027c9a8065c3f6a12de4c6e1e954b6a8738e631114b566963776a6d8c5674df7c0627b2f64745b6bdb1a17aa6c45a342673a761d1fc6ba3889e51a64ce5e0561c9b27993cf6fcace4780f059a68b5e91c09eb8bc4844bab00dc734a03b4ad03547ba0ed92d128d9ddf60a0d3ad3f35d31262823cb39c32ca3e2f202914332167e01bf3ae69ef4b1dd9ae46de8aeb50fc495ee218e5701c1f7e991d776c0c887ab2de790f9f765037e002b4c4806dea51716f75a4844b754f1fcfe7fc0376eafab3c56ed0e75a8d473aff8de4566523cf652b5d02e9ac261dbeb7d47025a68e3f6fa1d9477504e38a9464fee69079a4b97959736d7fdf94f8a41d29a1b2ce51f902ae560decfb8de301335262aa749fccc46fbf597c3cf9e45f22dc5272e37d8700a4cfadc00d3c40170007fc8e56731dc5d18922fe261806b4cac3aabc75d8d6fc767e57a22b8e0b0224ffd9a9694fff8d64c18f12aefcfd12aa5cbeb0e4437128bb634b9a5f34f073f1adcee65fcc11e07c9656b037bc2da05014dd6a45ec111e5d79e6eb614759c0abb65e47b3cc38132bbe8cd994176fda2200fe36b6079949da46ddc9ee24547e4c43ea7e94e0b397486f812d906909a02ed9fc0ae8eab3ef92276492fb30a54f97543e20b7c98fb9a6ede54d34d5223f9115781dce1513e78480c8f83f4123d3398c841d0c631e5a3aaf45b8481ca60f8e7e58186e776bd059f073ffa2a8cba2fa65b194e4bca242e08c8064fd7f50262f2b70bcc63626bee735038bebb72448086958e68b9353aba4e2f57d043d1c55bc79733c9ba35727bff8b2421e20ced703ff4b60f0755ff682aaee3e5804254bf763a706f03f31e94504cce67069647aa4115c85e6e652228672f61b465152a6d877f43d97374e2fc428fe914822264b75b8aa9c58a1f43af72b3c7a3359496aa84e2c68a9e6127212a6d9d4f1525e92da31f9e192743eed48ec8bee2e4507e4b5c53441697bfe01defe023bb5b9a7270b809eaecf6006d94accd2a051bad9d2e7eb6891b093c97847662539f4580d7d5816745185637778e0d98c75a5e0d928d0fc2864615a47c4d580bb8a8f5a45b8029b57b45a4075f529057ccb7472ab1f194ad192b4775a89b222399cc824a04126cc55834a187da918e90d6ceb859de708390bbac7282b211e2472f7562cc9bf220cdd8d60d0aaef3b719529bc727415a4e2e2f2249cc1459082beae015e070b74191ebf29dfb6c3cec0ece7691fb29974a30cc82c98d9ceb640c8765dfc52253dd1ab77eee7d2817302f1d6d3b1051ab11567babe2f15ba0821c820990c0f5e8b6a61a6715869efc7977838cb47c01ad06a28abbb295eda360608c87e85951e4e36a08210001599bb49542d3114a17326de0b83a160f40ba6dbe71e84094bbde40979fa5b74bd6e9ff0558d4d320dfbc6433c4e90a014ed720374d461300559ad95be92d2d84055ef2204ca4294c416b387b84c2e7ddcbad2e08c6180e526a9158dcac553c432f40791a12bdc5741f2e9334ddbc11ada40f7946e7dd3686a23b602b2f48d85502d2ad26a79cd9debaeade6588ad651d48ed0305c8424f1153d64b1f5e5718cc4e59074da4cdf05d555c6b4bdb34f26a65d7d8a40fc848660b9adb82354172728d4577bd9b128f00970d78742c4debe4c5c26fdd3ff97f045b30b0e6af94c7051110998ae15bbec02101bc830ac37d4d4fa9935d46e130cc2e382c474459bc6907c8bec3a4e18789618900612d1f7c810acf36487cbc3a2da69e1166cf3abf93769324c643daf03a7b78a422126b7d04e8ab301c23730b3d98cd80ce1419f656bcc8b39c6887ec079da80c220aeb3565919cfecb9b337d0f7d97aaca5ed48983271612aac9981e7ab1bcb8c6f9d9d333a0df8ab22a5c060f8f3b9fe3ec5c47f023b7a3715774f331212c6b3b2527dbc07f13895f07c9d9e0cf5d7caa23834686a29f6a01eaca2c84c42fab0ecc951b301c80ba90b5511a8b79a1cb0e2277b3d49ebec6b1888e8e994a71b3202b3dc57a01b80aa1de64aee4bebf5fce61d4adb342780cb0221a81fbf7ff9eb9df8cf5bee35565eec4d3de011670b807bbd11da3c8d6c3a3a1541564f1579182c75ddc911d9e9d9dec8b4588c8785093366cd176afd55c3bf00909f1322afe100f5f2159b147f12c65532e1e1faf060c0ab9701461771eafe6b6cb42692354d39b7e66ece53aa35ffc51419be1e171f764093ba9c9cb29523bbe6b18da7419c700f0ddd2eb2b72a1219c06946fb9c23df4976e639657531fd67a5b6589c1c66e67031a1d9d3e7d9e217fa7ed624e239f02903f8edfaddfc168a75efbd36a714cb02a3096f8b1aa5547118a6e006c4060b3e419e04c832164a1982c084be1070e171c77ad96f7b3b700ceabf50ce04772e954ca7b8392104b863ecbcfca938c9378d8ba37755255528c0cd995b9532efc944d8ed0fbfa3d42f663d98047c658c445410200d9345f4ae986ff7083a6ad7381e4575108dc2148624b7794bf65cb030859bfecb9496128ac77b51058d36672be9e0630e857aff13642bfe45efc5e90c42b3ca4ca4f83f868fcbed669fec4e32d2a6e4dc14e71510c28ccaa750217522397a0eefd17508ad95035dd155256d6b15b58c933582638869aa11fb523e5fcd882065f23950e0a70127a779a700d9f5fde04ee295318e1adfe12fe4ca023ad955c911ff0b86ad052f217a3e0438465a2c94bfc1bce2e89de219eb129e0954f9225e50b831277f48e0355c169dd851ebad6d99c731efdacac8ef082059ce974af7fb05bfeecce331b57ce73c36b474f4208259284602c1515a0d5933aa6561b4f62954e8b995a0c196bc637de0476a2b0d484b0a2a70aaa441aa3d1b46e1db579e443fc6386e5d4d21e09d348c01ac75c9edfaaec9f67f50c4e71906b4c22a47d52712d74b5a3d7096297d8e8590c1d50065241917f12f7d3ab3e15bb9d230e4752e6782adde32cdb9599363bf695972b53cee2218255cd1e6b51816f36a43d9d9b667048b95f3934dca0c05a825b227c44550be7c096170b102a6779fdf7fa6afb9fe3961e1b03a95f3df9450fd4a6551257b8a5e89c9d4929d21a2d0ebbc1f6b7855e4d8c08a3fb4c452bb27c03c1d90b0a859d4b19b0d29afd59c233648069432c2fb4abfd59a58732241937477d1a6ab38240ed904885e2fe9a7254f125210cc9c4e62546167a78ce56854cde018573b63a1b4d71682829b0d0f7c9e253e03a9eb4d0a5130a6a75e1d6ecf57d83b9d3a7824f7d449a141cc241a4bc08060372645743beb70976294ae09d764f4e3ee83a0bea8c4f122e1f3703a1d47015cf693f08d686c6420e58a6b695dc5ba75240633bbb7fa0684ec206e1141a89cb729c96a40a8c70a5597640074e2cc66ce6e84ae64455eda0615ee0cf12f51e63959a132fbfc056cde4387f9fb2739288e5082cf4082a24f6d7136cfc502acaf9f02e6bf97906062d24c9cbc19c03dc2364d28b725ede0dbaf1dcc9e88ec77521eaa5ad59e1583ae20df7516378012baa84f7d5d04d793d91c02f0bf986d59abbb00333cea218f36f4b14c3cea212e95f7bc0e01fa6b39f1591436a8c0930dd95d88d5c63022a9a51ca138998db61802d4e1a81e7150c02cc8741c135f49e01279b30c9a2806f37c20a851d92a3b599d9f1eaa81e5f7477d097251c96b185a31fa00202481e4a2a47439be62ca81ce1926701ddcbccffe066386e27ed51f0944d53ecff7033c0ab7af91882937b6fd42971503b7744272d078f7994d8ec536d2dd8769d3826f52a528f570420ebb295a8610275e9da66d0ae16109964fc87d42fc0a77a423267d0cd6538a6cf25e9a070d625320ad89e0be196e1e3061c27ea7855c2a36f367a68a544b308d50292c430504da21951708de4c7ed1f55b330285dd91fa5844c3a463181ccc389e952fae56b1b2a7a60ba0b16da4ce338fb4a9dae4c5980084ccf021254127a2991cd27b107dbadbfde7775d52a1d433f9a6411d336b6a32b101db7a3ff9585ea956c2fb65df5a4ca657e98aa01c1b37b98a9ef6a8c96fc9a705a51524432158f633c0b2bd598a338cc51010df67a0779960696a77946b4ed65fb7939282767d533c013ae787d4c75beb3456a451311d9407aeb867bca83de7e11bc7a1e78bc114d2378d1bbf7330752b5a379733c5cde0bbc8f56083105180a8d6b4b964c63ea2c786c99de614314afbaad2ba18748b3041ccc2350588a070f50f934d518acd6982e4eac71ae57adaf25934449092515918b50b7dfc209c361b6068222456b47fc73afb2932e6ad972b751070d196be1d8548cad95ada9ec4c051c83c58964821ef33533fd9043e47e732d2f5af93428f454faa8f9ea6d482f8a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
