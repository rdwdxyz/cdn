<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0fe24602e2c264f837ba3547c8e0a2c93f4841d242dcade67f8f1da2b97c5a9fb463359c5e990f01e2cb5f522e9c9c5e067710711ca816cc1ad9c300b990ba4eeb796a51bc02181a9dd37719ad8cfb32f0b0ef0eff2dd995e95dfd699109b55a162a4c38205e454038d3917edf583563725003d15a0fb308b843ba5580080f38784e58dbf6fc86e54ca9225dcd4e136e06367440e9dd2550d7ba44dc896e8ddb6ca8256077f73954c2d42028cf0a8ae64434ff88ffa67bd113a8aa829d97b8c3376e0242bc4847d3b89819c30822ff9c16c9e8de8cfd98cd97c6e0037737a9550a2fae0a1def2649f90841137119fa004957bc3bfae50b718053e8474756df6fa975c808e63deab8cac34a2e752727c838d0ac221e45b56151d171f438a96ea17c6ce07070909732231191f2cac13e262abb7fc6a5e44c46a31f48ad2d3f6346be33175a4007710afa73bb7fcf5597392a7fcaba6779f62ce4f2ab5761c1b13a7e1d8db4b1434d87eb250f7c37f3cc3833c6aeb555af84cda227b11369b7f340ef259d1e9e592ba3fcdfdb6280171fc2a98a46b755706a2090ea69240dd975fa1d99995be1c9960ad49c3b3001da000901cb735ef6fbeedea5df8359837105ee43b92c57cb2905ac83c9b886d3d829dc730cd5e63bb692860fe7ce60c9135263db94214ac72382b009b8d96cbd1e33dbac2d6fd7b90caf6a39579b506e827f5a6d56a98fbe477e456eb4ffa38e38889b8005c4e906ecef40a0b85ec66e70119a4509c34e9f616f10917e637f0b677afb09b4bc30a3d40787f5e3f706034df2d2d340712577d67511a50766b3c26fc9d2590e7573073e2feda2c78511b2aa7b21e4bb606f4fb93f4cfa291e9f8a22b4a47f0aaac53f15bc9fe9100480a4c10c1bbac549124f977d324ff5b10d715a3f64b6d1f9182bcef8983f5b4b6de9f5fd2ccb97ef3d7c053fd818dc84e156777543a8b87e47c1bebad406a9bd67826a3bcd361e90a55c6b00525ad6de8968c9ea0a1fa7138c05749155dd3ede83ad54082beaa55852c62e8f3980a4377fd1eb7bcad926000bc30e5bf5c5c86c01ff4138994b332072495e0d09fd1c68a15c22ee66024a12451dfaed36270eb1c762925907be4cd1826d284ea201640cbd7288438c2530612e0cf4f154f9ad8a9eb1400931c91e56c30fe244bf70d2cf1cf9174f67a40b17522d73cec9593a1cd4491983604ac810d030fde1fe2c3688bd938d87b93d9faff3465cef42514556c8233cb0a181e1c89d859b10c1efbf080c8a2f5ae385d572726848805124951798063493e439859cb75997dccc45d487dd5ceacdee6fb35d5d2449c2c121a77daedf9604f992bb5584a42efcec981d604198805db851cfd8dcde5c2fa09d636bd1f05afdf94b8f0fbf47cb3f295305bced272ab7103765bf805a4858dc2ebb4873cea05988a0a9fa7b29157ca32d4d48f3d8f5cf1865663649adbddd027d1c6614a9cab5929295e74d9b962df81cd91cbc2b3840962bd8b6d1ff042aec916affed995145223623a0d9cbada048becc531eaff29d517587741583e3665c844c34dafa95436c798f3ad1c115308168e579793d1275e3a03e9044f8192d5c2cd98e6684f612b713abb34205ac94082ca1918fb7318d1a68287a26a736a5fdeb3506fc00aa9a2c7be98d6239e633fe4480ae0fe8f4f25e19b1603d0296a76e01b4f8d613cde4f56723a6c17a3b90d6af48387c60e1c3ad5eea36cfee66ae9a304185b78ed3e412c65351318b7a901b76629a217b0d0d793628f9855f6302ec1d14a6ccab40bef4de6ae7d37877ef27ad8bc85e1d7ea92b135868de69f2c2180b6c242e7fc8a8b28e62f24469dca77a8cda6ba26af1ce99d6ff382d54a50f0017e022b077125613513c0d5f13c1ed91e942c58fde464917e0f0c4b5b9d79717cac485f392db33d254fb8ad042512c0553c1ff0e891ccbcaa9ce17653d0d57b19e857218252d379a63d788125905769a6e3c59e388ee722d502b579fdc59d780cb736d0f564c2d34359b1ffe385c248bfaba04ad733aaf8d6857529daa926f9434d3a2702c0ae4dc94bc7b72ae5325b7acd8e3875dcbef51ad6a2efd416b4abfb75fbe617f29b721ee1495a58d34851aaeb0d7392c3bb0e0e9b719354999f90ea7ed82b816648369a5a7dd6a659f0d09a391539e5ea81b0814872e7d551ab9b3e3f910f6a39f8a7c4ddbf4d461aab0dcd6c87c8351a16734e3b1e11e2ce06c3d6e1151480a2575002595db2047bab9270d58da6c2a4ddb35d6d5e5b7cc7fff1ce962f024bbb5401fb06b76acf23783a4f2977a530d10f31577b6d9bd74f39327bb9c63218912dfa5f31dd97ce4a02f4643f9cc32dd56beaae000b663c6a377f0d9d82baa8fbe5d51294d76ca4fb66df8cc0580c80a8b00fd5d774cfdefe5d0d39ebc2a9428de797187eb53ec37355a0378b0bb21df3a10ffea819721e94f0797a1f79634406a3f8a00781faa8ae6b38461cd9d37e7dac279c4690d604c3b6a0db98519aaf748333dff0d14e2ff76e1e5ac0855f66869aad4f51b9e7aa396413cb9c6408fe93d7953ee5018081c7762092935674b6d0258b5032fc6b2f66e1d19b87a479ba5172f89eaba33a3728c452c9c71d54cd327788443dcdeefec0f1989a6c738a8b390d2216b455b358663373490598521e6a38f30aa3eff5a4aca0f231e5129398eba4283edba3160f56a98337f74374893b8470f4a6e3d1754523cd1ed6eafc6ccf1f9774c63b808e220db9ac726f2ef728df5449642022017184b58a9a1b9f8eacdc32781b72186bfd36d1a966ca61d613b3866356648bbfbb630aaa584882eea276f69faa730b9879a5b5406029836eb05d1db8cf27551fe446989510995fe6e396eb22fbd0cfa5d85976c9ded8046f41753ce72f70e1831a94c94eaa4b9cd2281eba53c1ea0127983f4d7c145a226f3e5ea0968c0a4829362ce8c9bb966120da7f2603486d3e51a9fb5d2a0b8b457181bee83ab12c5068737c6ec7105811b21904da42fdc3bf17cd284b6ae9b46723052ceddfb85ef99cfe43222ea60cad24516a08328d5498357a2ba6535bc91dbea9b3960e9fdab7b84a9d883daa6e7b9c88e62eb2de075ba5c63b78f3b5d9b5e2ed9ad895795ea454f9c1d00256d7ac15e732f3881713713014cad793c5a7ddf1f0bce9474e1459857e5b2d1ef5930571e455694695f2bf7fac529ba3d27399009d7f7950be352e776cf30643d7d1e77f1c5b2fb5f61771cd72671da52d33e3c501c5b526fe0597d409ca14ba17dae1cc5a09d28380f962417370385e4d5ed1944ef0ff2893ad764e002f1784286a40f6a3ec22a2b89cd0c5f2dcca4949c78cdcbe10a38639cccd171189888ed4e310ae6ef45f5ea449a6f451c3d5ef2cd60396a475b9ea128b26a48a5f75a8569138068f2045c39afff599a1fb2a39670517ba4bbefe3b9fcb15273e1b46ac87d9797eecfb1ec7f56d6e9449017b1cc3ee36f54c20bfdf5291e4ac6191dd6417fd08bbcfc47c68b88102f6a735be5680c12ff61efbe4260c11397e1db9a6ed6008e1bacb49c579c985cd180d7b0e788e109e3ae89e364b74e22c9f754edc4480248cafbe4070ba88c73c4476244fcb80d4fecac82b4a177f12407d25eacc039c55b23cb5035e96dc7115eae01000d8f5f4efe3110d4f6ab161cb1803d0e91e62c3badf5460712fd206087d76f65574c77f72eba66c4384c0ef517ff48457a54d3f40550f69ed1574a48300f0c961a4c7f5f3c749a9776f2bd50887955e5ae7b134f9c6e2e0e852ee5a0001800c308e83d87ae0de1c27932f94eb0410d98bc045866d72623c5d14943a8ae8c9eb18c336eb77c00c0a0b4fe2a97b0d6498f3607e275c3096e3c8caaee0dae6c2cda3889c70d899365ae3b9affec85d882e0b64e73439689c01672beb482ebeb2bb171b77418c7f5f8a87289a901167beec06370a681546ac6c9204e466f2f0c25f265cc813c8177ecbf19730be1e07467855846a52890c12c58ede423f53a3ae25998f41d3e4be561966a74555398f7f6b68b32aa34e2ad9f3402d1d263f7b57518bc30604dcbb58cf5dfa0c9befa7c7e1947116c7a632bf066e4b94f8a8e4cd3c8a0be3739bd69d20ff3c66842c516ccd613b2d549cfde04a46a8b89eff517e5e41d4ebb336e4a018298e257376e466456c5e94c1a53184af52a2f02c9e93027b1f066b9262d5792e0719dcb2d9bf2cb2edb6573716721bd625ecc3298baf4d347bc4a073444b46221736e96d5e5f591ea1d67c4b1503a66c718bd6df60d02138c0b4dce4a3e5e032d2f8de2cdf5d93c648831865e94c0ac540d79df0655c9efbb8aa1f8bc69e37d81afe9a72138bdd13ec1f4a6caad769cb9de8fe3cd3d6653e23f8856c04cf04606660fc628f2defc73e37668c5ae86fbbe60585adcb80bbdbe979ea2975b018b61cad954ea0af0be53d29e038f5618127b84a015cd9f8a19b413ad14287a262ae6af771a0e4c51883b188ee35ccb1fee211ffb5e4fdfc284395e9eed1970952c5e9075d99458925823f7fcfb5869c93e816a66d8b0be538d7c46b48d3861ed6b8d3e1a2bfd71a69210b653bd873c3b81a4720b0984d536b6cbb731ece0c08c5bc143f3e91ac80adeb219b8d2964f2bf10d684afff8f86aa2aefa52053cce4079fab5c10352965e39cd8b89c8f9629ecda681703ec5bd484004abb1ac0a27a773b8d80d0219184475567a4fa84ac7762109852d9e3649a20b9e53296831ff6d88e684679e198a16be984cd213a799a4aeeab4394d18a4fb70d6cbd65d71c63b8318e92fc3a64e2eaa9299bb5fedaa1d92fda2cea1b94aa3324e709e2ce2c3f062e062ac6737305b188986442779faaef84c799c34f0ad728b8663f7159bc1e70ff86440b4f8cdef4954ac20b8a4eb77c0d9c6f4f97b78e67208bc18a926f068933e918296f8ae9d5f2cf7e49f8180b630186712dca16cd5ee134a8e14a86adf4fa15504769b121ff1fcb16d56f4501363e7e4e1185109f0c4efcf07d3b5faba8fa1044250b02223992f973c2541ba345248b762cf88c04ad0c8055e034da78aa2f831de0d40f7c348acc822b0a79c9bafc50770bbea4abe81ad0a0d4666e10f72c80ee3623797791dbe6a94df6816393e1ce70da210c0cbbae22c839fe2d787f12b6bb20f8688d3d2b1154e677f74ce017250b7531e8bd05055901c3992a35336092716ed71a172fa75abf842d80acd10f7cde8194d29dcf55da1441823ad5c45bdd08424c62d11dba0ae270c18068472bffe0b3fc96fff5286e232201ee57330d2702460e53d4ce3b9d9f1c46ac073b1a856170ad33c71cf005031bc2d53a3c4395b44b1836d27b5050641861d9ce0af38d1d232e6253b689ca272210fc0755a89c3e20cf577d053447f0f07d445c9b343763f6ca40f9848b3638ba90cbfd118ff5cd0168dc22752355ec8349f71315f38e4ced0c32646c185aa470619ba466cb7fabfe5326d083c8b839b503a3f8d276cbe39ff3b64df71543944485c6c5b7fb66a9964c80419dfdaac5f4562680d3f4334374e7f9ced2b5122abc0c1193cd2705226e08d47ea290c8f3acda5b3229b49141319762953ed966632ef9a5608735b8831e2aa1be9cd33175f0642f67d3299fdcb3ec063a8dc7e976a4f1d16afda0581d0a1d24b14047d315d992a415af66564cd31ae18e82ca861bde1f724487fd65569f532b0c054a1821c95de384ab174de036fd9891495494cf42167c297d230fd55fa9a918adcdd07cb6454553545e172da53416a97e6bcf16295efd57eee41f483f3e442f6233381642b96bf494caa5bcc4c5832e2347c60e03e3b48b77ae172fd22dd8475db43f5c35f22c763240f7c03b324f5267ae507c0464b06d168f592d3e8bca5da4d0c871da5726ad94fb1250030fbae4c3d19a4dd1715608b664b9a7ef312d255f328cfdda8e70366f27d1ed64a80d4adf5105070dea9c84a6d0f6404d2e6cf6e63759fd6ce8fe5d9869fa31c81d8890bf5af0558e6c096b2691fb8c3fa41c34f9a58e1076dd407044061ef9f172bc58dfb26bebed5062107135bd64f285389fd23dc1e3f40e59b63afd28ecbbc8977670ed14b6b55dd7b6c5ffa0b0618bffa7d616620bbeac88cd3441654713e805b39a5b60f6c0dcf54219cfa14df20c7b36c8cecad9569a021d2d2f9579581741fca49088e611c9d138a26704f14cc15999d80ad8149008d7a9a7a45f6b0045ea1b8c71b84ab41f24161dcf152fcf9eb0514724635808fc25dce21534d51c438c974c19111b6a2a97c993e8d2f0d417821983a561dcf2b39b0ff559c681b10d40d5c38a9e8ba9b0607f098d654c21e9326f3b596f8c728d96501a4582de293a02ec063f3b00051d08e7a62d313e8561d1f0752b4e241da8b98b4e85842d7012447d964dac5b455554785aa6b8e148f74c6e0ad7ca9b96bf1882b6b27d8a6a119a2db6bb5ece4befdb238e8a7ffcd16b8a22603d24f717fe45991cca73086858431f0f5a53e424c468ae1daf1a054e1b9cb917747d3b27f423ffd166d230cdeb92c46191662cb89579ab4aacb846cec1b752b633d24ee4a7411175af2edb86bc6c981ba440603fb6f0358e0b7da94a8000930541896a1830bad57ebdf61a1afa3533c73b725306f556d41c34904e04e5b7244eb877cfe940b2c39d8728d40e957d95a8723fdf7b0dc0c68c67a48ceac9ec860abfb295390f75457385470fe3637fe5939437fa924e16e6c50b95ce33f100e61731e6a283458a2500b8638b2e2bf4859da41a71c6be8b67c6752ade4c46d4b78fca8082699139b076a5b441a9988ca5c3c3fa8cb6903481d6008875acae477a683ae1e43d375ea9aa7f412d0a5d81237979e3e710d39f30a509dfc2b61b440f0bad6ce870f0cb7d49bff3267f6a57ca2798742b5738210b5b39174d62efb908b80baf5320f3942f6a345e1dbc253e4210e431e4355b3a65429b6ea26f9dd7aa4c8f8ed961360ee57e5280be2f490e9bb6b4bbbff15fcc0e05a1807b322cbd4c2ec31a459ba270ec49255b6d08bc6b732a96102101f2b17b18d520586586c521c462d1366d64a70057828b9349a1f3bf9cf62415e2ed71654a831f03785e5cc23f02a9677689f879d0cbe5879eb8508237c469f525bc07fb1f014cbba68e74b9b829a401043f0eda84da7972187c8caca25968164f2f8d46f8465706fa95d1ea79d017e2ae843c831dc978b76f25b71de50940297625fc27b8391b95b57010e26e745ba45ed2a50b0e31117884d4f1904fdf394d9196e8051f4be1538de78d0dc144becf577b6452cf67dfaf06c45366822e1978816ddb17d8bd394194aebc9c6bb88c3827347effbbf9e59e161473c951ce8b6c5af58729b12e4994f61509161aa0715bd88c3e208b85e8148d3909de00dd52caa1a3ed57f5015c8df5dd55d0f167f9b1b7a89d3002a3ba62f6a974856b003e7a455b2c30bbd466936c73b504f923e155e8bc47c32783496e120f5045be83935ba1de19c70c11fd170dfbfe9b76bcc3d14db65d711026f173f98f1beaa8b4de2533b3092832ddb7d083797a3f5980f0430e1ac0b70bf9e16b64c830ddc1dd2760d5582679fc88b3fa07653af4cd586866e3cc9f07f517bc542feec65e475220c0816153b21333a6721b7e2dc7af966e6d14f20541f029523ffe7591d4215ac231b5ba40a720f450190fff32d02725aac2ae20948b03589ed7e0bbf31618ae8d658b80dc5af62f098dcd86f56bb3f77209bf57831f59b61391bd78c24641fc2745f71d39f0d5366133877ab1887d931a2588e4684ae4af273efa3aadbdb8bfabe6480e656061f8a345911d68283d53ee056dd5a57adb3011d306b33d7ac12e6cafded26afe13b595173d175da7aed76c4e0b715e568a7ec46c7b9186c8b82c08ecee6d0882d9a50bb42c4e15f45da324db2c7705c3040fb104224519b5e90a834e7afda503011185989aa9ad4f5ca9285f5914d85a01f896836b9a8592561a3d576d1ce53d587038f330cb2d0e1ae84d175f837e06b955131a138669a3a52275a2628d3aa662c8f235da720a907c8136878e9b951602f79058f8a0cb8824a3cd8a0137bb61252e16c72644d863085ecafb7274a68b3e812e2f20af3e4bce763bb28d9fa8825dd20cdc424949dc3e5667097cceb89d23b69f86a5c3a86c9886398f6e20452b94b268f4e48ae35a5ad56b797bb0cfb4a71c29834166c62d625636f04bb176f0ec42c1c738650191aa84853d978fbd37f52f45ebefc35b5294f176547db074cc752528b04e1d71ad6e6a4ca9e42dc0c05cb8d40f657b695f4ea598a9e1803f3f95e19cb8351683f7794f73d8497af8f35d3b0f33ecbe8c60ec97eac4882baba0e086c226bddca6ee2e621a781df63313db20b4bf45a86cd3d22c250796021767191d75ebde29b68b0e1000bbc92d310892248a2faeabba0640c7d8aacc539c49e02beb63e343cd2890cc67a732e4e438ccb9f7bb89ee96a769fd44183573e72b2794d9c7042cd5221d12f2b1ae7f04ac2c4a8e3b560c1d9c7189265f871e9c799ca5de8dc19e7866bae97fba565cd987d901fc185f0920d049b89d26bfafe632c78eded1d7c5642e061d95ffb57944b8256801523edd21d1ded0cbec576b79090c33fd6b653eff03d4f0f04898ac33e9bbac30815619f0f8fce7fd4bf94b3a68c465ee04d349dd40a867f50a8795c69a1175db1b122b493b624a82d444e2953ceb272c3905c83d15ffbb1f38a93cc9b5fd85b1acdc057ec76bf06e5b1d8f37919d231a77c3c0f65adf9614cb86dc199ad4cacf2a31bd21a5d6fe5a889e690941449e946b5c2c2ee5fa3356f82fe39d351a8c45c0d78f55fe0f664793dfbc361c1ce3a5f7e7569bec8714c50a05e6df23f5544aa0c641d0811db26397d36525796b5b125e192cf3b6156530526fa1f92ebc5bbdff7a7fb4cb5764116f666fe5110cc1bde46f6987d2c4c3e30d596dc7597365e77c2d5f88f63cd3d95b62c1881352f02dec9ff2c007b370e062b07153cfef2ff4ab67984917bdcb287993aedc60ff183b78ab9ca96dbc23b05d661ff2b6ee1441c09680a9f5c19ffe543912335dc5f0c3d9155036bfed2e4d3fb4c0cde3a38f88c35dcb4dc89034346a3c8e23ade2a47228cb8afc4bcbf0376d7b0241cacb84dd6e806f536f3050cb61bd3ee0cd731c514ae8aa58748674c5d822fd626c252ddae71458f3b1c0d6503bd64c8a08ed6c3e57a18a82610e8b1532ce91fde2d796fe7faf25ff9216bfe580f8e160f72a14832358141931953115b3c861b17983f6bf2ae0901f242c2debd5f139fdb3a8203100bf3dd8bb549d423d5111fb95e16bac4d2f430b216b8ad15b7d7cfce2e94411a943d9afb43745e89a374a90eb246e034cda84a5ac25cd430853c8a3d991b5629f2bfa34bf6ec1160dce583b77472e6afd83655c306516cd0e52f0c8cfd91de3941d3447b6e13d61773db57ce86c341f31c7db4d1d6fdb71cf45b80be9ec89ef8df57cf86edd693f4319ca7012180953a2b8d88d90b69594e5dad10e4cabca31d2456b1e9b34d3c6da0cedf0f93468703b09db39753c86b4e6ea83f0f91cc7643c473d226c170f152eef47f9c6ed8c2beb8113c7e699bf9dd91be595f62781142d112ce117b33835a714616710c786a9472110fcdba97ce00cba3bc50c4c5046289f11a52ae28fdff745e74ba9b93b191b40040b0f97c011bb87be2ff13deaafdd2fe3419f96c4ad3273c9b434e7d4091ca3561207ebe87df2ec35f04137642deecff9cd647051529d8e9dd0ca332dd2099a4dd0f8221139e814b1ab52fd0d1d16820dd3291db02e4af85d94d5436b4f1fb4c6b3ebd59651638f4fa7ebb967325c6f9c2b9bd05db80f13a62d909ad277e743b82c210d9c8cee5864a6c43ed55e1bbfbcfcd8aba5d4b4df2850d9044ac27339cb5731cd938d476c621a61cbdedf9549eb2d3115417f3061a1193157ad5120209b84a4bb1f84685f8ec8f363c0e244960d316a989827387a510269dcfd632585689697ca05b90a023d08ec16e2f1883850334db3a28e9ff36e4582800eb932dcf96541668a03b85d1e211e8a5b090645988718521b1161efb39bae869b86ccd822994899bc27a0e02c6e7850176db7e87f8b74110c5ea8b28cdeb846de6657074d0bab6bcf60a77782dcf9657b5906ee900bcbf24fda78b56f61fd58d04bf427c97270bc09a0f92d17ff9a816cd3bcc0ca5fce4b84080c3542733cf30ca5953ae60d56656c511f7ea9a214b4a3152aba0a4a84f6eb049560429d132495d8a3179851ac786c90318c537383b8b934ab8f0061bdb2dcca4b23897fe582cbd575dfd71eda982a4023c143621c175ec13b870e81e896a45404ebd75d410082169fd74dd5d62495fae69571f35aad617e5e1bbcffe3e9fea021b09ad55dd2dab22c36a74d0aa6b9c599beea1bc89f143963535ee1b19b1e22b583d5750c6aadb8edb2feb69799c7eca380e46145a8a41796f26e3a8427b9b19d405cc0a55b5e435356aa741ac038c84dc57a98a9760c91ccded7f7619c80290ec1812c7363781e5c508fbba10b8a58258ee9f4833075a26ddb3b2d96519fe7d63ce32118d85f7dd042fc5c0da38268221bc844cdd7193fe796bbf485072900a27e85aac7d7ed98f75ede7a72bb04b346641b845fc0012513a27a023dd4c77da70ad90f6248c9f91ce2c6a2fe704686db062519d30ae974deae0be3e4d6f77197a141a51a9049f7af032554f7e8d11084115a936ccfef789e53641ad2a5bc0fd00a61cb6c1070ddeb2996b769c47c2284129174492e08d28958c4295dc6186a494852a1865fc39472d11112d356c3242d546b77593a7fa7a19cc4e01a17e97f062c89e7a6ee9da9213a86879116c05430b65a24ad0464b2f84760703060674f52756bce97b8f1fd2f1c7ef3cd21f784c848b1dad9abd3379c4d09f2bbd757db32e35e537d678859cad39f70163e2a5353c46702607913db441035e3286147ec77bb81f256b5da1b7044eebd5986f04488838ce4f59bb954abfc9ff28de4f1e40765c55753812c006ff9eb7da2b2feeafde0c02e5932089d1db9c467b6086fd35fcd912b89a2f37027f6f59721d95a3b4c686ffcc3f74112ec50432cdf2e7c7768021b1d56bad957ae5ed6f627f1d20bb73ba84d2661cef233fe2e66ee6c3047fd4301884075b2448d98ff4caea8d37dd535e730e5326fa2996015f5bb2a5d30b1275f191210f4b8d085b9646afc5a5f9532a1a7b31e27e3cceb43aa542cd1eb276a3f3ad5e1c6112edd5b7687494944ccba425d860b95119d7b1fec6a6cf53eeb5ada58b2ec04500c17a64804e49b4b6c476d3b6570efdff083194f7e6708d9ddccf3140a730c98c03a7b8c24f83fa873df4bfcb2ed206d700a5340ff8055cad2ab71b09d1fecf73576b1d864abf2dd5bf2b3da2299ebd081273500da67ed4799c546330112faa654398db3b92ff583f868995925e2fcec4f07c6d93c9bbf97745e637f1231f8478350de2a6485ad035c1dd6f086c776f59e996de15fc822db599267e0d90058d0f03f0e00adad6c9fe150e6d713af2a6ece521a8e507232a314b0011e9d06810e5cbd9d286fbe6536059c79c0e271344fdf3b91fb39940289117c66ae0885328824e67044b08fc7340597f6b87ea061f9d1aa4684a561843c291f065fe4b44f2cd952247e91b2745ac8869fd81a15588cf4da6367ecd64154ab8295ef2042a671b28c4cb058b59efe40bee290fa400be97546020756d71f058f8103430c77e0ec6009f6c1a22185b4347229977efaa6217d8040005a6d63f1082fb6d90afc3ff648713839c2eef150f8ed65a5082ef8776b56ec95c6000c8132646c3bbfd64dd761a2cc91850228c1c251cd36fe47da951005a0ce312cf744eb22212fe3867b994a8283cd6836ad9759f763e8838712c14b41ba7fcbaa99288e5ff7a7ff409a2d64ab6d8875a8d2568ac15aa8fdab9ce6df48a6f2eb9bff27125c794b857f2f358c17f62fc4ce65717756d065fa3a9079ae5248141abbb8528f2513de0da795b962dfd34f7706efd4c6e425ce298863b76485861367a2929054e00f4536c740d2b2d67c442fd2cac8d425b4d614d5f17fd2e231161ccf5a0f5c335ea1b98840fa42ce7731529201c78caa767c6dc6b842ff6d732055b26a0cf6534580800e9580bdf28582a6e8caa1bd808528f07a9d87741a4160b1156baa33f3f0dded82c76a5f9fa928887e54f667f3d9f79aed0d48a631b13c934a8a6d9fe838e62d310441316aa833ff50adf92955ce200f3978f71eee79956ad0a7c0bd85391063f3c7b09d1cbb65f331b7dffdc6af333d4adfeb439ef8417f7d6bbc7989e44777750f12437f8d45f98327df6778ea9240970d87726e812ad972a157a4acf7a83596a4bcb4c16ed5b7c32b45af80c8454c9c13db7d30cf1e47cac8e550f82d8971b53d3c30c58a6dcff7edb9b92347e4653922df0887939a0dfbe463a595a58dad1b98d57c78f0972f2abe2b672af011ccfed8d90e4264f934d5a25d36d9de03606fb62321f4c57d99df7c611e8388be4ba15ad50d2ca3d427c52d245a58896d535295e315ac9ea24c13b191be4b031dbb65861a00dc5c2afac3f5cd9918469f631c479f581ef684e3072a735e8fd501b3b19555ac4242b662346a964d85a4cdf060e748f32eeefed52c42da740bdba52a9c158dd2e5048384997eaec3225b2c0933dd60f9042dc5a6e81b91177969a0f9b925043dd2e8efd7ca78eefb0b870daff28e67af252ae1df14081d14b79dc8f9071eb733dd89d0314a3aecd9ede70c0f5911f35d6369714014d928a0cd0c2dfe91a104336cf5dd9f29ee06207240918e22a05b9da6ec0fe341f9eefcbd3faf632d8a177090d6fe4f0fee8a8631b480f6ef73ce64376acdd0033e3f223d4bd375e90a7f87e249babbe6d1e7f75dbd2415eb660657455e86ab87d9558acf15b8a6522a94fa88799fd19d5a8ed52b1752fdbd967eea7eda581c2b2b3107a9699f5454e52b501df7b5d66452d6093088385bcf3209d4b935fd98175823bcfc9d33d495e040e26d00193f25cc0ce97b69636fe8f67fc992946b1bc86d92857ef7ddd2446da2ebff970a04906ba6b2ddc11246b75f5bbda1e5de5d99d2971d18299028fec9bff0d090e127cd13b23775b90410038a038340af0771a639a0ab9b0f9c9e48c52af74ba3866f6fbe9d9ddc3bf41a6c5b4f45ce31cea3ca5356e55c0695de41ca746f417ec5ed7ae97537766c700c827e5f23949948de83bc11d23acca2c48b496d40a3175012d442adae17c89fd0439b04ce8d67f0affe6ad5776944546366d24e7844ef2c5e0788301fc5882ceac2f07128ce41c5d9e0a07dd9f2b580b3f025bcca395fad163b555056d91b7767eaa82c414cb927b9e8198c619fcf4ec1060f68c032e5e677890aa747b912c8ccee5603a63dd299432cb2c533944e3b95f9484b22dfef1693ee0791c50c48e9dd0785144492a6efabac622d308537b220729530c5fb581b00dacd489ca7ab97b87b8bde63b66bd0af06447221fbc2aaa662aac307aa6f847d6667d964e00421c4f3a7c0361fbbbe2f378af9ebdce9a3edfa927e459b20aadf5caf1588563ba9c7ca3fbf8099820072eb6d122efcebb94f93a9ca8a7d917e0568b4eca8a66bdc0cf71459081bc51cda7dfe1e5ebcf3fa69d57b536e09a42e5eb8275c588103ea49ac7c28de99bb2e3a637186c89916644b98c88bc9abb8c6a070555c262a23271fff5e2c17400d889d169efb80a2e6c9571fb9db75a2f545eb422c2dfa76cfd49871e7d9db6f468c840565b74ff3e7295c6649e4d030ac2109d435e1ce5d425cc6750f8996e8f78d5828526805d86b36a59624263b4015ada9147c0ca3d692015ee36441d5c526daa5e22c60670ad5f0803877e2ded1aacddcbc4327f4e167a365bffb7020678c83463a1a6732b6e63a3bb1202036cd3ad6072e1caefd03bfa38cd0f858ba5d7d19c7a0de72eb2c7d4b77c7fdd592ed1c93c7af90b7c6d230e8d6ebac7c6682d29c5289d47d3017d5d6175ed13874eed88a5faa7b1a9b8f01fe3551200262468bb8992ce8a4bd786eff7259ca02e5a7ff32f900c79fed92bdef24ea8441aeba3e10f961cd6e6f6fbc260b4ab028402a2596a37d05090b581497b83fe789c8e7cb31455881a8557a803de5c2400c7e7bcabbdd260eb1dd89237ff323cc1ac7b85749ed0f16471e315e311f27a75e57ece3089d16b9e84c3e716810dbde37b01eeee185b17e158acd8a25c7f372854fe5e874e9ca6079593b07492abea69f95b615140b336cb7caa951dc5060baf400a73ace6b41f36df52471c627ffe018987fa4fdf44234f30576498fb20306782be6b2002782ccd287a2bbbd63dc4ade7e717c27cc2067466ed26b10527b93a376be024a072df4711a4c495ddd6788629b4e3d7dccf024b74185ea1f01e1266402fe1c955effae0d952117584284b1b3820ed7c756748cc39cc1e256950b3375dbd4e8e4293f05186f23b67d495b68b6f817710fcf1f01c8e49f3adc3b741e442aa777ff20eb793c518d4dd2ad0676be3bc0c03829bb024402363f00c1ed0cddeaf40d4d377a253f585415ffb540f62d4eab1b86a980545619af001451d5b51cce6b8c9b3c751c907ad5ad3233953e557658491fc53bc88b105a17aa3959a5f57b4608dbfa2f6fc3d308d0ef76e3944287b0fa3c616c2d78b44fabfd5af3ea5e2253a098fcbc3bc0149c23accafda6f6c3fed6ef9bcaae01dbf25ba5cd60645cac779b61d5f5908f0cf3ef0e08f457e113338d47f078f53a037d18c82531bd6be5094e7605761004893e67b13fbb086470143bf4657d7090ba6d3615b4886d0debab0fb2396fab8a1bb045ebbc773ed3958bbcb10b941ec66cbcb36ba6970004a528726d603c0a025c7341d53daa75628e4352f9af6be1dd748dd52cd6cf3398d21ced0026a689075c72fae609a4fb2114c8a66ed0f31fad8382fc5bed624b46bd9564d186739c47cb9bbdd03dc4b3200d795c47695d58a24120c08cefbec734c0a7913bae277dbb0177cadbd0103e53e928e382a171b7708d5106ab7880237394ddf3d95afe6fe8e066cb8dbd535fc6f89a4c76869fa33c8290cbb010fdc33a414c6f1ea9ac166c7f4362be5b40de88289f55baa2553ca05a0dfad8bdc67bc9aceea52bab8fc1ae34c8d366d02da18480cd3997e7f0888b3f9024ba9a7e2750b4825fc27129dd17278d6f4ad2496af5c65227d314e1bc60b759c77a9cde46ccb3c0eeb38c4e4e1dfb4c900a8b72b1c883e671bb8d66cb305578a18b2af243429c7a465330559ec77e3c063c090d6093ae5106f1c4922a281699a66f328d8ca468bd1325b408a73cbd77f5ac90bbeed3a1821cacee265031dcc29dd3f3cfa932de291080feb63776ca68313f4943fafdf7106dbc85686f313b7dbee19ab9a3d586f843fb9e3e6791c1890e5643e3c3ae081e8f05aae6f6132d4b513dfdfa474841417d455eafadeb943a08ba80ea71fd5a245634e3291b603a3c2493008d9a81f1967c99d0eb4e1cb3934f5216a2d55c0d9c56c34580969c5803790203ba6d776147726da1c7bf14be07abcdecde6d3f12cf8b8646e5d9ec6b8501aff3db7b652051eea5b5d860d148cab984c0f388ebef3d919996165df80fefa468f14257a46e56d91bf0aa8c80fb6ccda23a42eff13b33e5fd4b25f42c3cdc9679321792268c08f6331e97c4d6894c07167b5d2b7f7e53e042e529a2f012b672b3294adfab43db4b6fc644a419b279f2a2c562c4e44664c7c3b6211f13cda497ae90acb79d53db5ec641da75ce3f2ebd8f0209cc518c84ccf46a3f2b7ed0ca3bbffb5d106018c7c4ccfeb08baa66936841ac1161e7bc57a94da553cd46cc5a9313b9e21753916f6149952d155b4e34ce138423b1094db437ff7b716cb2640bc06dc597b705be561d3201ea3cb595506f3f2a5c28157861d4884fae9de1d148c3ba0a47aa4f31ed5235067098daf60a6816f6e5796db6166c8c45df7acb1bd534a29c8ab68313f258171129e4f143d44e4af3a7467190478f2bb6592205fe8f4d73e40f5663d1e1190750e5d546d2a14793b2bea3b18096fe7127d026004de1bd3f0296eb38e14b88e6ad55979a5727d6102e202cf3260af3de86d1bd83dcb7c4640530eb8668c19e4150c2bbc7842692d8ebe2d3b1f7d12caa545a1abdd03aac94ddbc6019ba4348f1be53a74bf4df34aa5b74d6338bed63777184044555b0b9e1563558e271a0d3cc7b386eb9d8d98e2967d5dedec19d7b49d34acb24b7efa32ed73bc9854be863122165fb7cdc860e9581d3e3ece52a19997c14f1c1ef4d4320973432503bbf23af05c198986369a772f365266e200f07899984f85d95cae1abd5fc2f59711f4dfd387bdbfb146aaaa725d45cc3c91c190591ea71ceb14ca8d3a57a94e1d51e05da8fe67824287d5d6036513d7624b05e0149284865d0d4dc3b4fcbfbf3b6277649bee971274e3d083477d2b8e39629d2397af049e7b7fedf8da851663a78523cee4210773380cd6c61f6e3f751b805d8626af2c1dfd3ba8b741ed01699690b36ddfa4e095bddb82e4fa39089cd84012f7da6fdd2d08363b1eb62cc72d14a770f44d25978686389272af29ba102db083f32669333cad543f22a84f49596b2602b2fea6471fe004c907ecc24f7b5e9b617c3491c051fa9a1643e6650f4ff9c2252bdff70f6f15e3776314795b1000c7aa0fc81f1ca8a410295d026fc91eeff4d0c6143c6ea4041fbe8551b8d9b3d9546acdb51710b05ac24f8289c28e61b0bb55e4f0222a975c0b2f8015af502e2ecc0e92cc65fcc86d4a24976651bed807b743605fdd43ba2d2b417587dea4461d7837a10d077b97e0793dd01f6f6dc2c9313e4b37d527f962f7dff00625d9ec27dcc8af10040b94ba441b083bdf722e198d2c955c3d4eafe9b38deb8d1cbe17322c47c743b82ac49692eabb2bf5fe550f8434f8c10ad6aa4639095bb53350d958295a1df143736666e9bcf4bf8f92fad2fbabf475362a770a6daf53eaf1822fa28f3d96a1ea9912844a9d2b224b57425101d61da74e30764c0923f160605f095a18ccb5b1871f756f6e14bab91e7356ce558132367384cfc864043840e00a3c777df3ebde15812df3756d01ef1205d731ffc3282ebc4acbc15dc6813e9f0b913c32a2ef08f964d190c8c01379403ee78aabc4492ebd16a4de384fafb9f2cdd15b192f5d9886ccffd37f4a1c27370bff69becb56e1314db80d4b2a6287a9a147990284bd3bca437ee0fccfec467eaa3759517a92eee0e5b02b49c4dfb1cc9135ceb1149baaa4b26a20eaef228b5d4fd97d0e1fcbee0d07b2d2a02d34ce309aaf0a291ef08567f2f1e1002d3e1c45f20ad5b6204f9f81d556075f090a4e632ef9edf2d74cf7b4b94af318ae9719184a9c27bffb5753c79177b398a547a797870710aefff8639b6a4b8f8c2a2a87856f1f4352e87609e21614e8e74737d8c7b073aecc0f2bd78e55828500b1b8a2fe2cd107105b733d5d766347262b760ace762375b1eee2701377a8eb88aaa0b47f1fb641df16743b866b217247d957358afc4c8f5bb33e12ceb1b036b424eac319922ec8429c0a8a47096ba762a4dc97d2a01a79431a4691895db6fdfb96961d71e88d4ff360e3d89f7eaa5d596596fdf9eed0665b74dc70314d654a5f25c261c3a8dc40a5586cae620c30179e0a18fd82eb78ade2da0ff6d26ddb31465d6ad8a2de538de9aa5e299c0165364b4d0add0a30d47d54a8f34b2fada2315423f3b13f81658035c1df1413f820c2e72bc0865563f51d720566db4fa90514e75668e3edd67b74ebcaf75b6f9a2386df9396c46e0bc22e1bfcc7867ddecdf13a4ceea11f27cfbeb172b84be1ec8755b8f908707e24b02d9578bea68b47f2f3135920ad962d93532b40e621b6e06c7135873d4597a4006","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
