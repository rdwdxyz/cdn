<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe1659d860e8bfcdbb7e7f7a0e9ccb284115a1c8bdae9a04077875202a4d526cbd8ad1a4fbbfcf90ef2b8d78d6a93a675bd60e833d2264b65d4effff73829f83ad6cd75cd4e1d756c73bac5cc98322cdcf252467e7798e34e386b90add7d60a68fc249e43f6f3fa52574431879a81565cc0f975d7451b6f9b8a7777e613b1f9e825517738603c4c8384eb98567e0d8c55d6dad753d2ef459943a52230352682224146d790c40e4b6bf9a04bdcdf06828418818b605fdb1c865cedb9ae683a852e140577015641cd1d0b8dc979f9639622e30a5255f0b8ba810d5faca3505896e03d500361fbd261b0910f698fbea070d14c0cabfa8b5fbc159a998154f33eb035466d9dcbdd3dc92407dc800df77531335ebe9be0ebc9fefda586b7394c6e48fc00cd867c9007965b81d107f31207e623760118c2a25cae2fff76d78038d901b51cd303431c3c9ef1890b828718cc14baeab401177a2c934d7945197b35464d5ac914ed90237ed5cfa266b73ef9e83a914d685c663dfd98d355ecc8360596ed388f4b78432c8f15ab64508e5312fdbe65d4e3502005b4f2d1ae63a8b4523be8482b4b5063df809acdbe585fd39209947767583ad03eeb261a20448cea579e11a193b48f9cf6fa3884b4e88e10b252d66a6b9d007099c0e3636e33ec32afc40871c626a2a9c8692fa60ed93bc581e1fe3efa4333a8ad4e335d052db457f066687b0c5ec1b244517d575c7601ea658c319dc68a3952e9ec8af7c3548d68099bdc239e7835c9f7c30e2df08b6b1b0191136e5064cb8ac7cd2513102568115b3f3b60698725d6f87b831aee8baccf8609cfdcf498d52d0c7037a4bc65c6382dd14573b3cc6ab5495a50d3459c5b4e417be9c6413e4840a401d38b48ae34c7898ed8ec0af3b56d60420f7b703e3f5bbae628bef609b9dc7135b0959d937a0ef7bff47ec65efcd0129dc8b0cd3e83fe0704772c184625d1d878bb9b455f157ebe397389d2c50e79a9fa9b980411f552dc6aa8d861ce0dcc6ead573d82e3cd6693c63d9ad38bba6345d9ec01328ffde112477e28c77f84768b7aeb476dd358b23cefe45a02cdfa3bc969b45d9e8a30b7c03ebcbaa54da85cf4ff192c103738286a7a4005398dbdde8e885e99f54852727cfa3860e7023f4420133c673484cd6320ff5bb4f5445d2de27bb0452da95a16014f8a57c509129410a1319d58b5bc6101e4dca2baea983e416937bc006c0567dcd7390fbfc906499188b9415f40c0ae6e93a9ec52efb4470c807fcca03058c302795b803c27eda9fa81e41a6b3e808e24660ee126f41f5da470b8e14236027525686978795ee3b49f20693340805d71641311d92ff7c68a33135b3b7c1e343f0fbfb19d675ce7af3ae10fd05b1b383c75a16e8f88f76e58cbf18dc5e430c23a8adceb5391a74a9818270200fc3e3be7adae196a2bcb61d75ea7cc10be89e5d9156738c8959601b115684a401f9ac9368e5709655113108e4ee8a4ff9d094d6c99ab384a48bd71c09e0984d5071a27a1cc539e6bff962492b4f3052903327c939bff24bcd73e467780ef0953cefb7fa6ded20a583fca5ace5413a91757988d114a598dc655c6d39d651347f7013f8f499a20c12061f2990e5b2cb09caf79e79cd78b3d77a6e5d3bb58d7acb8ff82da889e0aa0407fd6fa61b88627f893e22fba4880324b8d4a2c43a56db0b02918511ab6ef158cb322d89d79b62851e4a1dbc725add07d7420576cef52f85726e241cbd064f8502ee7a3dfd33bb1ac3967e4ccc9e499756d5350cc9e4c00805e4927a284a51f27a4d15f31630da6492b2325b57d30e8b409a5b85251c2522f6a9275e9dc047c8f4bf0dd4fe84147a6f5f154a1c19b86fc93b378da44e9bd3ab3a940b37c259061d84b686289c38383b40ffbaad1b1debef0533536bdc4778f1af3b01b587e7e421fd5c1589403be80d6ade631aadd8155ac2a995b9ab71b0d6bd99696a24415a4e4b2fc8830594177e4406788fb4a4677124f8b7f38c8499da7e25b894245ff3d585452824f44fda0743164ab99da3a1c4c33f59f020674822e3e2ae86278095ce89e22af5c47639c2dd999ab0af01eee14bc10a14bc21be53e15d7970b75286a3f1b4652cbb42694608dd79c5a2f6dc28c36e1310b2d80f215497d506df45932dfdf35b490fa860d484622831cd31723c6da949a74a42c9c5a5708c5e704ed369b6ea11a9b0d4c8fe53c225364db83c2c37686178d4a78c2992a247e4bc06c287385f2d2417e91baf88af597d56c6b83f6ca2651ce2f3ec75869bf053935e92c262f14fff4ddfe09c2b706e2cc8df66c1b23539234aa21b01ba03bb00164fdb961bbac1e8f3df65434f11ab92292a14061c7a7d68c6b98da2e151496874ba48aa078927be82e3631f7255373ddc7d0ccade75d480e68bfa6898c0bee9bf6dc8176c3ee4d1be37fba60da3c9b607cf074e420e09f16a2b30ad6474ccd56ef0be5994ed94c9b6b9a51ffcb9e7c2e1b70c340c48adc56c785eecc1a1fb883bb28012635cadc09da8a9599a6671d9d115323c37cdf670d4b91e11e1e91e208e3e215349fd8f9678d8b46b9b1661f01dfe927b72c04b5762f392812c8575e2441d4280caad857dd5244fff8299497a6c8487f20b085dc72a3024e001f0a64f42967daff96f196958477b50e86e410c0c77926d67eee5e6a37e386f1fb657d6918a1811049646a649004bc6b664d8b85a99304962bf9a92c27ac1170f89770ae245bd700deb70e60f1a924bae95f923eaabfd90a9cfcefd3ad706cacac86598b73da17f322f249214d3d57996ce24393911d2543374e67cd25a602fb76136eeb4c1deb65dd3b66be813866c79ba772cf40be0d04e25119f664092180cc431ae6684142da48eecf11bebce9538da73a2dbbc3f36f97a18c8c2d4f410916e9a8821ff5716b88ea44b67131b453e0fb2b2eb136ea7b2d641a124e3c5c8b31a0b15bce7bca31fe86622a2666cadd629d458bcd2088edce5bb3f69f8f8170123433a699cf9f2ea152ca58064d3df9a42e9fe82bf064b040947b3ef5f8de43487305c7df19c40e73e78c5d9d151c90fd6fb44695b8a59faea760fd2a72b6c70c10379bc2ad81b5e5b789b3cd8bde25d22a5e8619aecf5075bd5545bf37552dabf8049dadc695d8190072319edaf5f295ecdc252b25e91a6757bfee9047882962b2db33f2d719ae26e218fd575bc8a8f1228fb37c0c1d67fb6d8981ffb800666111992a6e6c9978323f5c769675523052b7b27464ea1e8438d3937d590db5816c0f75a654875bf79a746b4df4ed1879ec37808a9220d9de2b91b7a5b78ffdfd79b29c6d7e513c332cf1e40b625760fa999ccf23585ad16e2f52999e836318e9b997ddef745d985268f4ec9b235764867e6ee573d4730fa159610ca7df6b8b203b6103ed391ebc55890f9d7972be18d72aeee1153eaf0510011ea64bf7fda36dc5bca8c7fe8c995a2776c6ca97819609914bd890722a72912e1ebdf53c430a40d86d7b1b1f83110c06356bc1624364b02a2c4f29dc63169a467dfc2cf9d5ba5b8dc7cc85d59cc3325d4946fd8a353a19ea38a4a00a3001b200214ecaf027e29b8af4668715d805a9693d1b2df68be8738e9f21ff54590c6dde073dee1064ca6c15ab4b9b6d3474fb4cd8741ccaa5788bebe1d593b3d2ea3acafa3f9fe7d6d1f361f136887ae9eaebc1b95e159afc77659ab227144af3b6b6709d022971add2b93ed9d1da384e8d6cab81198f7dc3a811210326e782fd7d9d39380a1507d61f60caf7dfffdfef64fc5f758b30002dd9cb60464babead3f620b86204686ee403614f76f02b1c65a46289feb2bdbf6a3fafa4e28944c33a80d193d5833adcfaad7a37bd3ca99304af0cfe15f79d1e4f6f1f98d3670dfede14c50648cb8828f8831eae95a4f15bd223ad4e27d1ddbb2fdaa928fc41adffefbe5d2e4ce0bb0b9269a78686c5846c282eeafe78516c08055b8a0d45b02073188f6cc0daf18d3a6a84de8cc59ca864b01bc3419f63e8861cae670cac630101b4d28e60f8abad131e5f4204f5ae484ea71ee77b02534c221b932f7a8abe1808aa6797e945705650b477997342a697a7bb44d8ab480d88c1534785037b052c2961f389ec633b0e4c75a3d712f7ba86f35f82d3a7f716b17ee2ec7e0fd263f26876e06b0630f603fea7e42ddedd3c0383549fc3ceba86a8c62eba4c0486f0f40d5e82fbdca39bc76c49128f111a96d08e7da4b6cef8a609ba9dc141be4eb9a1ef2b35f62d0019a17b7c5af34021b360737b1939f6de518ef8b73ea476f96731a5bbc676318992c82f4e9ef324c9cfe7fb2ebaf821ca19a9a2dceccd5927581d63d9ae01009c6a0cbda821f1aefcd51ede5a618528e8424aca0b278b5b120a18603585c47120a6a75f5d993512a831a629b963ab073790a3a08637b2876e9de1caf7a7303c3cca1f376045a1e3a96d73e0e912ee8ed6ab401b4568113e9d2bdc435f726f8b8e77b2a0d8e74f91282f358c308e2689045dee26769a3ae4d37309822bd61fadbabcbdcb4d86df1cac87aa9110b7ed6b2d45737fd94e7f41b08a282ba42543d6c616fc873c3f95fa14aa5f1baa9841f65e33eb030a60de7e851aec1ff55a17a34fc5ff99056d40d93bdb734923de10b80ffe9e888ca8bb552208c8c546aac2416b1cad5e39df8059d3833dd58062fda623d40b5c5e38f84ea4ff9e41893054d2ae286c4c098c38298d4addd01472d64ea818c5a1358c2bd689ea873aa2b11accdb4920a6529faa1b83512b3ecb2e28c1c83c6baab609814e00560b43d38a12772633ea0f703f6fa03bd3eff76d1f11d5ac4f66e677ed12d2e1cd6e8cdfc4beb0e9f824979a6b6d588324c359b6444c9b0891b544ef46c6537b200e6edba3fc826bf063809c987f482ffc1c49345d06682ffdda9ceb8d6c3444bb57c73f55fd2e78a7575fac3c37c56abba35c315d20e5ad2bd9bcfd71c25fac6df9015ce6ff57f52ad490441dfde2cb5c8d1e593adb0a779c1fd9dec368f1fbd438015f2933f54c85c370fb66a05e682e1e4715f2d64ede679d80b9941a0d313768861b102e78a79076988227e4ea2d48784bf1dc647a25aeb27d61f1ad838ecf79c388478e143e33cb31782096ee3a211aa025bc08ff85084805e36bf7d925acb57afea956a4cd6d1eb92cb1b41be86273f6256c2066d66e8c5e3cd505cf4a10dbd31805bc55b4fe18d1c8e0d2a7b4963fd9427678662012d133637bcc6bcfacac8e189e2e624d3951666edc16d119aa17c89c7e744f1807a7ea69837ae381baddedab60ec57358143a4c563ba6da1ed1842b05d3d535192301f9e41f8d697e91e2356a1a553e96b67e76a7af2961425ee2ffcfe38a948a67d678e7c499983d2104a3e57cfd1a3ba6bd8e23930f603999e6b87d869e7939b5804edf6a836948c739f38d515d2ea0429a44026c7f859e032d3297acff95945eef7d360afb4cc4f51ea9f66ff8c65c481924dd6b5f0cefa2becc72deb41a58ff80ab03e629f0b8a0cdc64c4b7bee67f75fa1b6f9fdb401cf7f3e562c578832ab98916ec377b5ddff7b73267843de3af18f016afb72693af7cd8e2aef3273c7f0a0a949a1c141808aa92a366e828b3a61fe809e4fbaa564d35d8d09e0bb12603979e2470987b191d92ae88e6a821b13808a0ab6535131348d38e3d0ddc38a0579844a85752227b307b9fb24570b99b6e942426c2a6b7e801d17a85b61a3981dd198bad9dbf41dbbb3538ce4f6684594185fe0dd419b2fe34960d1d6634175c4148bab5951e459c26a813164646c6da4a9be1b3d57308fea5037fcab8d86dd4762e4bd49d0e4a65e4c3feac17e227296839813b1850c749923e3725a6ba7851eea8e060c354b0f17f9827a7630d54efa172037e3981888074dd7b55e486ac828256f09670a447fd0f095abf4790931c1afdacb657771af6ea0b0a087966ca441a843100b031c48031b0055a9eecfcecfb29f5b908b2eccd8db1623119082f46aab222d1e50e9237b7e86b4a1b03f9817528d697cc87b34a3e1d371c0a700587a9a79eced1e8723ce8c848bf427699309e08af165757c4c83976ef3c8c3f88b576f103d6ff5ddcbd54bb7c1c0f0d393dd09b15b80dc3aaa3e7b30805285ef146b40a870865e6f275ed2ced65efaa4e665a030a305067aaaccbf06f49c21a54da72c72e7d27f4602482c4c54be222ba76e5d32abc4376ced32c1f1c26b6e54e06ff396968d265bc50ee1ed89bc4b03afcd0734a1b102537d16da08bd579ecae4553c5ef8c0d2381eadd0b011689fd9e58defa1f6cc7400e2d3eaf628982921bc847bb92fb8127210c4126bce60af9f6351b471af67d7e250f3d8ea3ced5ba82742fbd03088bbe701677fc79bb140a008e258b3dfd8c39b37ec318b4c2dfc1931289b77aefe653d46b3d4565a2341fe071d8ad8d033f9103bd34474352fc3aa400d4ad3806d2107e880d74251285eb66a25448325872b206f62d53de111ca387f1706878726a62c4fbef2653547151fbf6c6079b48ecd8b75089ee3cf166ff4b4f75d411aed7e3e37bdddd204b41c76ac0a61e6443a2ca762f6f152dd8cc5527d03b74905497db411a1cfe14b54dc076bdb26ef7e3ae24fc7ba232dd855e9ed3b9917c900d1b3e07b2677ef912a781ea08ba6f15e40c617db9a75e99f4870c988a5d8f9131086382ef6fd7cfa414f8b2d53aecc1d522dfeb2679f9060acde9ca50ec169f5aa00f2bef242343be25f8579b0e504cc89c051b929f0bcd4114d3e46aff17be5dcc1aa76a550e372e7bcbc36d505e04e71a5a76e2ea8160b042e0afb0e95b9e0656d964f896137fb6aa7eb39df9fb448803eb35702c4670e7797be5bb99f62b72fb6983d108ca14432821570ac1ffc81a6e642b565caa26764dbcfff97f1a334b802a05e7f4aaa8e7ce4a75906123dc1e831032a88879661b891e633643b6ddbe57d68f9a6f5b77f154ca8ac4b94843c35db4dc4c345746bbc14acacf1f07e9910629981346ebe0febc23f8bcea405a3fddc4fdb2f7b4dd773bdd93162225266a0ede3ca96da68aa0d0730b468ff381c07b4e9d88e29de3727d1ebea52d0cfe63b6bc76b1f78dcb37dfb7d545b0f2c561c806ff719923b0c4d047a9f275667540fcd2657b1f290f10ed0b3a742d82ef6af9d894f07f62bd9d47c31423dd9b16e6b605eddede842526379ea897998b0929b23eafd0a3d85db456656373ffa55ecdd9533b7a18cfe1da98f5c7f9ea9d80a8d6d8f5d8a880747a3c3f8da75544f355c8127cff6ab37c479139e6061f8c74d0fde34408444e826c2eed4353a705c426edefe0af87356d357ea19b794c55a969ee62e2100fa3c005087ef4e69ac49030a41bc4d57c3a39a7803d729ba1486a615a151e376130020f83b1776ecee98b7023b4922c793e2e3c9431eb1f72cd6db8895a6d0a8e4214064237f52f7aafc54097ed0142ebe5239916c76286cd6375457f435580d7fb2a6b376cb892b08fe8fc43656617e35bc478e74ba7d06fc026ba2205931d37a5892bb5cd20a9e190e0d1e6569cfb26874c12e5bfce9129b77ef8e4aa955321db29eb19b5d2045e54fff25a46a5fb1775707482161d13efc6d516bb0a6e6aca9e5576150224e66984dae519d6bf9ca146f4be27bbfdc947b719c04064ab858382a00f05e1a8ac676273f8caf285fc497b28f75deeddfc3e681640afaad6cbe72dbbcebd2115a86f1acd313398f0cc7c05c960fa93d04aff6b6893f559fa2be9376ca68629fdb641ebeceb8b240a68d77022b93a1af8cb54272484147ce6cb51e9233a53649b568a15a65c0557d0dc344e2ca693240394de15d7ec3c26b2c4808b4ddc5432d3524792b7d44666816df7096e14fb5036de20fe31b3585877154e2b07b640c87b204fa1a51b2e7b4c568a5f2a73a2d0cf85162a84cdbdb0abb1a7969fde0a0167176827cb0aab78df0aad178726b3fcd6aa2770e6abd158551f69f99340cffed0e99daa2f2a732fefd121ac8a33fa0612a24041d646a92b839c1d1e91543ee1261d7610f029d08acf83f673034aa565996c4b10bb582070e6d5e26cf9abf37b11aa94b4e4dd81c8e0e2c5d71c31f7a6b6eb9fd5e94bcaa60bb3a027245edbd860399f346cae86769e07529545c05fa633c2e22650de741c2b6c7b151610ee481d3bad06fd9543af3ba04744fb4d27e4bdf110884b640fb940ca251891d7161caa3bb92e44f0e5a5a923d17293ef769316fc8f6835cc510a291fa57f0aa9e768421a14c3c01dfc206c5f407cd5d7c161d124ab2da2b1d9b944b0e0c7ce1a8369d257f93c0620e7b36d9263be267629227ecef2ffc8d30dd74234c3d1470e4714bb9f64070a75a323f6a133d90f26f6c6751c3adc7904ae65d0ea79a05b01eec900fac8f4a7aaec505e0dbe6f179e0c79ba8592a54836744f6d6e578f5a1d16c0dd811d162b71886ff96a8fc7c517c0e352ef4302b667042fc46db202cd32f6c8157e712204515a90edb3d6d328959e8f12d2e2fc04a8ba9a29ed9e43d0db19dc32b57e0369ff584a9d1b5cf932e4632a255fe28c49e2550a28e47bda18bf3344e3e6fe17646c6086911e149ce4e41c8e928e1277b2c29f9026ce6449bf6fbf93d413972caa93a4b0e933b5567e876151e4bca3b45d241669265391570f58194eb2a4c89e8ae2f1cfddc698bac24b9ce567508ed1a9ba9ebf417fea04c4c9ece056cea1dfc97437c63fe3d7075d393b2516f4b35d2de8da950d89689bbae8bcacd805316777c770d2d2c5129dc5ef9cc9f1e544b1ee6be504fdbffb77ad6329f0d29d27181951ebc48e72e737f5c4e83a7ab2ec9af660fbc86fee5c95baaec9d056de85555b871e2d0fea13a65b2017cf9184f93f3c941a8b5d66b4a27fee9258f548f3cba9b5608a0e2f483e454c163b94249624479bb89ac67bd7fe025373ff236842b2848f9a7b0976c1bb5d8a7995907d9e150068726f336fa00ca6a840b4598f892e0cf294cdb609e6faaa0f7f046b58cb8e26aa6ba4eee1f97d9edb39205a8002d4f8d6f268202dc93a017d4ebce8e479f0fad0fcc34973ea973c7b745f5dddfdd02f0bffb4f3c5da40cecc8f3d3f7ff4ee233fee00c525957e010e6903bf5cdf83ac31998e6dfc614e98e0d63e589629a7a2c80979b549a6b88a24305685bc8bd89a9a2af3d71794d901baf97c1d5ce3f96344b996156f9178edc9de16b7c8de3711b62c8e10d77e8faae948731ff2430f5aa084e73cc1755613d583a583841a7657ce39eb23ec892e6b1681cf6365174c3e7aa1ba251f172cdf0855c78541fba914fe07df1f26be35455c946bc49efe07f12da9ff538ec6d21503d8d3825fb5c356ca18d8597a907272fae5d7d8de6808b815db662b169b83b76f2b442e34f8e91c600c9ec259c61f3bb452f83c86f9bfba6843657cd5de061aba12fa42751a6b3c3beaf35858c9e06498c372de54d979ff025113513ac29a6d5dd528a11d2caec49da4e1b8148f6a3e26afd6f7e6d580e92007fed4474d1ecf95aa6f91d5be60d93706d36c40011c73b9df19f7b2b5b5de3df111d3b0b24aac5c87893a4ece940e7411851c0ab9bcead529c74826e5664938429288a8f6224c31e59bc15fafa0d2d4fbdd20f86815bc604a0fa324fc83ebf5c27dece881203c7b450b84be71eeb34b32df1b02a116a8fc84c0cf780c3e99a3df609fe5c1d794f98bfa5b3b4ea3e40354c90edb67dc18385a16acd22c99a2961262123ed5fa22876621869649119166a73bdb9aa1a6ca0ab27519eaf29cdc92525696aaee8183b3b681c2ceb7c5d215ae0903259d7307069244009a385974a11e78162e0ddc7b27fae672163091ed253223f1df498321cead58241e5bfaa6020a67732efbb92b6ea1c3005466ae9537eb1731a98108b74d82fd504e8e08044f57ef6f6871d5f45c3533d628b54b288ab93fb490246e2fb5823706c357d568bab4ce8f2975391462c11eac37ed24d18da2178a51ed6bff3b8025e4c3d70e749567bc4f685ee272650b02e67b38cafd92d51f4b76f5fad1e6fb5a1c2a219d27bdf1008eb6b7ed8720f11b07e0f99920a485acec9de2b47545638f03b8401e3ed610eb60e4e81d4d22aa8ba1830e647b99f9069c43045d2ef02fc9bf0782aa4b6902be5ef3ec59d9728d85d7e7766caedad485979b55ed0689cb5e5cb4e28a48574dc29ccf95d539199089a2638a17a387a6d2a3102bfbdc4a3a0e8885ea1620c08098464f0437037fb9786480b7043455b947e0a1c601b601472954580fd21809cd36235ef3593cf9b742993d5ceb4dfc319096d5fc9d6b8aeedcbfe98d213b74d679e2207c9b3828e9137f85c76b1029308838c4fc23f09e25075f7102b7878d9413994ea73e7f830f13e30bf337a62c4cb33f507a87b776b27359e7d3b709f12a37a2b6b5928758f86039a48f6720699b9aba0e7be7a64358e9bf6ba6264ad34a5ccd9e29190e15f3c8fa9b48e8444346e3281a1e1a93b4019cab6ec2391dedb8f996c7184ac148faab4c0f0809cdaadf3070d0dcff071dfc534f1baf9311e18343145898a58f62e119b2015efb128e018a1b758308233dbb8c93654682179ba9c8e77316e697606264ba19e38b90ad0f2469e34fa64a2686ed5511d2312d467b2324fe46b452e909ed600d700f94b15fee40b8a2c504c1740aa5a1aa0b4adf0a22db6085153cd9390acff9cd101882b9ca9769e079389a9a7d3f4a101c888bf71d5daa3b2b2defee36de0d375466c3407af199a1d148844a6470d671ae1b802765d8a63ec682765f831dd9a6ff44bfa2091959a4b738d3e993e55176c25fcdf3a4ec6c91f92b693a4e7ac27dd93db6193ff292dbc5c68715bcf686497ec6fa4dee2e38ad75858d7b763c0760395840f8da7655e33af16ef61198dfee86602710dc41867754d2b8a2239c5f28e30335c5b6ecbdaef1daaaab56753d1582f9baa497dcd3e078a195c49636b9ba15cf1eb712918409e647c86c6c24f71ba1af3534a4395f7bf70aac7343f969b10e7054fe9ded9e8e795ce68fe5ff2595214db4f37ef211c2b2520d0b4e5d3d0ba6479514cbebd8091b1ddc8dac6bb25f9b3f62605c3227bf705b3577846dff6f5fe4e8bbbfdff68e614903626b5d22e33489eaa9b4fc52931ad557ab3451ed867eac419a63a85dad564cb5854be84db0719c754e101c54708837f03c94ebf3e4e6c6da71482f997ce5c9d4102eaa75a7ce614648ac513d434442b9002f3bd000d2db0c81af63c349472a34913abacf7049569448945d6382f6a1ac3b6279f14baef5009106b6242c623a0e078c9844d920744503a1af5c96ffd0dc1d209024e42412e4ec94787e0d4b3c965735603332a77c826b84583ef7d31f0c2a5da6522edae5e4921a1899a378dc295d075736bc2e6304196212f30589bd84b35122b97bb0f07173711ae14088c53de134c2bf3d15a21ec360b3bf06ab45c43c1ef1a8a3e514c1edb1f9984f6a3699ea05b536d65258d8cd2d61eb10e10b66bcfb8cae3b33e1268d9448917a139e21420932748c9e60a785fc570f2535731e7f0be6cc4776651cb7a1349d21aad23205bd6186227e52da535c594f339cef9cd008fde618eaeb6f898007aa0d71116e2000d59c2f4cd7e39336d7c31fc5265477b389a5e86fe7498378000718dde143230578bf3341e129c9128ac0008d30f341875882af21e6419c21ae6042ada7033ba4552f1df7ee8ae48e966d7c675651787c8656806713d24d06031f323622aac41c5bda1809c52c2a99dffb721aa4ee85333dc81d77a5c4f596475705340092a4338ff243576aed6917dc0674fe5e59a9f61b4f158d6a9d376cc65f4b7043c61eaf9437f708bda2d3ab4cb5d8b0a74895885ba369d7271cfc5afe264e3dfd3b5e9b14d561cf75c676e50d74065597122f821e0c89cb31ce5b161d1c678d2462b530cdf01e2aa14c08deef3b452a35090ff2a33f4e42056629551ef0e84842e61d019b083b8f418df68ccd80e65887df7d314310b23dafa18f8ee90688d3dbfd113a4aabd4f6093bc2df178b8825f9e3c3feef5508245b2cb06efad8d9e8d2266cc8a7543dcd6d53b0010d34ccff8ade7ac07b456ec110b49753c684e83bcddd98997bf6d15f48aa1057ce79bb0cf14b077b00f99166ea183b2ae38ddd465b5bb460c52d2479a1d102e5383b92ca16cbd2447588539ad44c8e389c19213d5ce6a5f64cf8ec08f461cba0f6760e91ae3a8f918b0111be195f203af2e01b4adbb02b9cfe1fada9ed7fc377670538f1d5bf4ea28c3f92cbcdd591c7dba69ddf20761d0a6ec12d05373bdf723be546d2622659e43b5b3d2a07e2a380bdd07c5d906af3657f12ac875256715b5aed4d1792d8a32167dad6b4cb66c064eec185a53192d06cb2434223dbef297277e347d6ddfaba7fa361e3aff9f7d1609c7fca72d234e8081cf22a0b5d90a851780afa4c1e8ac362c5846644e9e1a7c0e2b22f3fcb9c99f9f457424629ed77f36cc8f6afeedd73e6f8384a6d4b1868a973c8ea4bc1f561b5724a3b598b1d7074b2dcf497b27f11c048e8f060930c8b4bbf3a65e86e3361441ca1cb645ab86173c716d895ef7c434514bfa056802b4768123f2ba615eae02c2a87085b386dbe6f4185a52cd38dda8bbe13f333a57e8b2e406d52ccc324ca383c296ca633d060a86dfd1f90e46f0fb1aa664f06c34f2aa2c77769274adc535bcb164d710a7d989d07de33aa63462e6e93360a36ea7dfc267b557824dbb98dea57c14ce23a6ecb7b4434e43c4bee53b037feadf6337bfc76d0b2df05d9d28379bce3237378d0fcb7dc049b031a78d4389635800203abc393c3183150701df9777fec36f82867e296b549373bdaa73e45572c640b6184cd1583c132f11f70f9f8505c28a1f262170da022a28224df4418e8f0b09fcc0feaa002a7a9c845a83a1797b27f25080ae58b2a37edbc1f841750f6e775f02fcb7a8658e72f33133d9d36dc853c25fc318c2b38aad234db176e7b04e12b8528661025d7c9ad839cfa7921450d6614655adc3eeaade8a716b8ec6527099f69965ede2a52a837bdb858d47f99f70968473b9c5e75da0d717d9f4a1dbb7099f4373b8462eb00e497a518e9f5a7d9d54b7543df14e9fe6c3a0c377f297052375cff2d626a06fdd1b891126990e9c818949ecd1f07ed5a93d2342976720664b15cf05d3c5b4beb6cb2819d6e4f5d990ea0c0aaf865e092cf05eaf4b6a1b95b1e37e2d1d4046df3467f962ef6701b6ccfe6adcb9d19ff5432c7b37183cb021b76451c206151e09c982412e6e72a2b9cabb6584ed73fb7e38bd535de8fd5c411b971689d7cdb9cc1c7cee44a93ff3aad12f4af02b4c345a6fefea32bceec8dd195fdea55d86c667fbab01437f620eea04e15e5f6859a7d1f837279a5053ee4616db6a2a121f1a8bb5bb0a7acf883f1f35826b450193c1d6b4a3aebf681aa7932db6b9432f88dfa2cd2d934c8b81b0599c63c7e9af9be2b6939354c0e8d1a6aaf9e9b66435571a3fa6bd97bc066459d1be972d4fee7adc93edfdaf6d36d42096ab0bc88257ed38bc394fdfd40c89e84621382d49f77f8055b127410d3c629230b5a2f7c35c00ccb34d124659b4b4b41ebf29ff467707f2a457b5cfd3c724d79dfab82f317462873a9986b2a816c7a9f6cf0332f2b1555fc2b15ef5d2933a5c72b6dbdfa86e42e2841d93946ce73dbeef0e267970c7d00b6bc21d7571e5b1926a4d23077fd5d48b36a05069eaf9463e28f615e1bd454201d9ac1b6c939f757b46625935ee8e340dd4b45b8837491ae64accca30a0df8640e2311916a3eb05d897622045abeea140295d4b4224324fe23b9bc1faf60abaed7776ca142a8720fd308ad26c3a3ea45790b7b2bc898cd0bbff95bf06eb885db1c42d99d197ac28d4b344cb7a53d7c59aafd9906fd6d6dfeb87f2c752149bbb09f27be47a9f7256f10f135c11053166f4a8a77a1c3574201d328294d30ed6cb3c1fea3303911ef93b25c5b3dfd14a23c88300be7681a0cf83af058b411ee639d0d302a55c6e1f049355a2c6e60bf1a35f6e95fd371bd38fa7831debb9dcd3158ffbf548691746948b61193e0c0f6326d164fd4fcc8db667a282ec79a56373bd63a872afe6c02dd1870020e4856a3066786b63283c8d1c31add070d574b0cbeb65ea4881bb016c8f98ef1f50b885c0ab18e21706bb7bd81a92e27b8605c669681190b86ebb5f2d4b92b602b94d2475d1c1023bca1e9e1b735ad730a144de83f200d68987c27dd8b62937ca57d49bba18fe98a0729e80791c659ca7b8a2ae90071f54c302b9111f08fa3dacd055af141193e2bc93899ffb6b8b45d6975dd3cd8a5b8ce76ed644b03f7b707289bd89bd590d1864b7f24ac85088e29f6359d4015150ebdc5039cbc14f3a9666bb647cfecd6e93da2e96390b220ec0c6d222dad664e63936611266a1eff921b03437c9c9036201089c11955fed373485d6050afc482eb536241148edca5f2817f3d17d9468295aa5a79d72a86e0c46a127e19719381546b80b4acfced50b0d7c88d3c64b27fdcc10230e181276a0320b3b827f7efc4256f90817589ce0f193b5cf349dc6177cb9feb8cd4fdb606a7c3c4a73cf7162974c39768461f55d43e016bbf54bce43ece1faa805b96b558e36e4ad5c9c6c62bfe7839bb16b4d7328524ce0c6e011e774fc08f5fcc1ffb366bed6235fa23e2532ba8df251642d160ef8acfc4a41e684b4212d0dfaaffd16876c3ae53d967ee2e63e06ff18b8c08f22265a512185bf96a4c623725315b98641f825ad06faa553f1ff1d376df6ff99e1d790620bcb18eacbba1c62a977090659c143f8127844f57d08b860f1da5e3749e85ce420c22e01e0286e18a225096564525ed2183658faa6e007f8ea356f1f2d08e4a33b1d04c21545af80458d583d217fdeb24cef043d3b4ae194e49ac9c8ed8e4e681bbe4292e9f64cb2a4e13ab195dad0eb493c85af334d5f23d39c7c8137a621062fa2893303824f429859d6dc3ab785bba98760303b33e7aa0094c894f4c3747493ad4967cf6a4db4d1b24fb2a8c6795cf523ab2cdec7773400ccf4fac809418a5c281f85814daa38723e6e08b5c011bb0cfd9ef112c66d379bf531c9a67162787b2858feb385d34bffdfabd857b356fac79c3bb380feee0656ba426d2d9855172c20863135c0aed6c4316f5d6a2873012e30989193f1e078995b980e01a3ed5332c36858fb5e7a4946b842a51d05ee4c511adfc36940d4c0b4510d2e505a407ce632bb4b660c612fed10de632e1880ac6de948126f53e0e4c003f311c48cb0fef13096e065e129c9833935b5e9e43e52e34bba0f3dbec161dde77d3ecb2a86bc29c37cef42c201570ebec8ce3001b4fdbdd97df3b22ffd9921ddc8bd2cbe27a15aded63ee36b7c7eea92a5f8472119ec6cf2272ab53ace14b843c82734f3e3b842971fb82e67b60165ac0835b5252d63e6a22ed8cec997dbbd60090bca0572c0d2699b9d44fefad9d1118c7d3b968199daebb60d150714f2edfb728b6ec6e7e218d5ba44f2003bed54f470f26e834b38660ffbdecb0432607873427867849baa0d181b587695331926081591d0c4de12575aa4bd383e3bb1f67d182cd0375d4084ba5407c48296fcb4e8fcd5aecbce2d7b7639191c1a4062cceaf18fe6f9ea1faaa7ef3a7af34aa2ad575df66e5a92b7de6b8ce28fe4d27c642d71488fde7c71d781dabe20ebfd23a26a22a82b327063b81baecc552d35d320b4ca1f4e4eb2a867bb8391a8cb5a065e7bea45cd54190e020e59b5e702de5f665775096be708aca0dd77c56000edafe3e901e35f6245cd301aa991dc985db789a04cfdd3ec484a90055fbeac060af6792857da80ec320615996b92e28e673b58e621c0dbbb945e529582b5937f2b2887d8e169e836d2d0966d65e5fc9179f5e3d0fa87b63cd272aa861f8870b769f2ea9fdab0816559abb0df89a1171a3895abd86a94aa325b679d23b2f37132fc287282acdf776d70ed1b955f0c10b189bd32af90ed87b341a44f77c9007f7ff66ced0168d682d9ed2836f8cacbf2bbf44238cfc79b8d72d4711b6caa567a319428360eb47cc694323e4166a19ffa5923b8c5396f2392a0d46b3f9f19c7c7e79dae2eda7ff0d224092ba1efd6230132a76a5f655268396a9c95201e709ed230ae91e95ec002d45605a3e405203192a60683b3699affb0f74a827f6f480db1d2432fc472b16bde6688b6e6c66b9e51944b9914aa5bda78ef198710c64ea5cfa2f192f22f4e042bacf8e732af584c28da9d3bc5a48e9c1a338325318744564957b6850487f1b8e26d551f4b26936ade5f566d3b956a59cb88225853f579bf59cbd025a8a4171d8ad5af0371a2678fd3fe830f10b87c4ededd69b833d84fe2013ac9a7e333c638c823de656d57433a7087b6e88a27526f36e75d6600b4fe9d43a65ecbde1800e0d2c66495daf150e6aa75c28409aa65faf115987c518532b64a7a08d3a8f27f2d40d07f48a5fa0bff140b32489491a526a38e430ddc3ba5bd668ff1dc3fb532c945632fd42c75b3438de0dfff29f6128dcb2095709da355cf2b6b5165e7653ab98772f71af2984825a7546fcfd3f438b785a8db3da1a3796ab43f0fd84e2d41bc7600d6b29bac459778a3e674cf048e815a5e02d3d268feae5ac8acead83bc19cac596952f62a30794230468bca83232a91f8ee2846877b08d14b48af99a07589436cb3157d4fdd166fb75c99e7d175acf63f904a041070d168953a987c468eb069813108963c9789dadcd2f6f268fd0fe001f43673a34473e4828645f579125e004191b371d213b106f708a12e3e4fe72f18a8ed374eae7928a93e863c8922365b54482584972533fd1aa90971aefeed3501922f211bd357ac8343e44f64e19c090414152507e38996112bc529d0c97ff89b4c7c09187fab7545e339af781ce43e277cca7932da04d58f32dab7055366ff55af20610709c50c9454f0f1562838ed12c6807695767c42ea315df4fff849e6f158ddf58304caf30830d425f546d4aff19063038ee58429116b5c9216490c4e667910c8b0df0a744fe86ddbec177a567e98a9858472c292a3326950575358d8d2fb472b0fa7281c97376cb3670a8afca8f6cd37c4f8532c57dd2e231625d9ad2130419ce8e535d0974bbe7a191cdc56ef14ccc62c238d6ce591865a0a27e96a4efb71d47a7fcb748d28a0611a778b7953b9d43984610f99fdddafd0a1ac9c129ee2b274e0406427aac4441860bff1bdc1d7993e2ac0134deba8c0900f74cafef1cc87c6f72be965d724bb35bc604e34c02cc119ba9b4707f5432e94494157c03a7411041f2c1fff906440f4787fd0e00905fb3c6e7a026cd1ad3d45ff3d736b2559554acb2b5f80fed7653edca9fa03fbf0e67439a20932a93089f45cf7efa523c2a14c04be98b5d23e8de0e7f2f98b5651e72c60d4bf4b1db168b93bb8bce6ea0d6fb33f850cc02a668c8fcd6ddc16d16fef4784f9d97893e6baa943c20ea03c4a7d2d619669bb70b859ebfea9ad89556e2de7c7c9778ec1ce233ca3321c1e2cca3c6f82d1619dc80d6ebc6bc0fd416335d19f9f4ba7d8259ff1b013fff1c5dc2329835fa4230cf84f723c3aa5ede9ea06e412f9e531f2f23f802b5d05c4c96ddf99a552f074c913190eea56b32f4bba929aefa22da4551dcc84eb4545ba5833f78913be895c6dcf40cd651a19aa25e6433da6922a916595c83818308ee9bccf44506ce30e228851e654919255937256f781044442f36b5f958117f50509eae8ad1d557e640c5039951ed66000e6dca7f52c14151e2f0b1934e6e997a6f9cf5974137a47c96a793a17c20f96e46064aa8e964c1525dbc382c767e47090dcdcec403d4d382d375ea81e122d5a0c078360d07aca631aa3964356282e6e1fd91acec63f7a2af02b431af4c87c1d2fc8a760fede7ac67ca39f18d13b5c99df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
