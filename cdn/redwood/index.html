<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"459c67c55e11a58aeec781eac85483c716fad7d8f10d532fd92a9be23dbc50822a5ef5b81c2999bf2ce5607a504accc51c616982edc0d2f77d605fe511ba78c04c5c167511536a8b9b72878a65ccc27a70338df967d00b838d43f4825a1a8676ca94d49f8ac5e794f4b20762f2d843b0f89d90c068ba90cb42a6d984da2f437a6612b92a4edfb36528e9a6d30b2fc9d9c085647319bf5bf00aaa3fdf70ef361c72d2f91ad2fda0586e87c8ea7f9e7a4af73e01f27acc7b318fb666c448476a9a74945bc5fd058aefae8e80531adf62b3ed64e23c9871f71fb2a37a6de6d2aa7e4e13470cd5895e760ea31600234bbab0473d2d148425ea5d977f90842325cb0622d0f9fe3097580b3934acd168b2702212de8771001945f65a0012ece3522ee84c991a06ad55cb5af85024f50f608c47a1ec3fd5138d849d5e2611db53ef6e5141316a1565b378d2540dc9f5228a1460969a5886e2bd7fa791b6ea34d9acf7fd74af813617bbbb79fc5efa2450c8941f40f676658453afc4a115207f3743f8bfe1853d1f64a3fcd56efb8fcb7cff59f827d1f626d3a159cd145c5c65578531155b917b8d70c39977ceff1057b6abc536d66c454e72fd957ffbea0255ad3643c9e2c0fe4a7cb28dddab72d2f9ab5ab89953fff6e15d9202c25433b5b677c5290132c1e830abbd37125e01d64cf04331cfcd8ae6095b7c100562cd6df14bc8f405b699c2300138053b9004590aa2d99fd25b367a574846165deec180a4c6f091c7a8b4baddee196c99333542868a9cabbe7e528b11ef797bb1fa4310b6300bd38abe82f72c666350ac8c6984fb6568cafc3d14a5b1e94d23d157fca043beba9784be56b421c4ea5e713cf245ce0742dfe2da15ad7b0d9fd1022be9b3407052c68ac98ca1c57446bacd392b3a43306080d677f83bd5aa47442977fbe33fe683e9cccc9e450a5ab63258c40f01e556bd5c7c4b57ecf1c010e1de75f546dd606a62cdf901dbd9ec6968fdaf4f0bda4fb4ec28c85605785f73d2b5933d0f7391513b0de9421d6b20d240dafc39385e91cc6c9b186cdc43cc340d260617aa9756dbb99e39987208be129773b92f954a6054b617e039e85041bceeeeec12fdab6bc62d84066b1697c141f179a32e45074e9b634679b9760e948f390c053ac6792f23394ae61d0326b61624751a050cd1c481a67d1db2dc7b9503c89adb6c11e6705a9b462b1dc0ad5c0bfda432d83f5b267f1230c7182e80da9909619aa52c2eeb9d69b34bc7945dc76f54b3ab4ed70d49f654a3a7fd9e63b06382052e81bbb5f896c15515e66651ab7c7496211e68cb09e2b43e942ba44c785e11326345f8efa74bb857a54c803105c3a30742227a574703e274c6e8dd8c447a2d9a5d4a003ebafa1c92f2567bc799567561a9641ffbb9ec498853b6ec77e5acf610f4b7f3e55cd2f1ede18edf4d9e4405a65690f5d1dd8df8fa714f8d4e081dba7d63111bab1e727e60c83f73708c6655cc82ef89988aa17939f5913b5698ca668d25f1796ad7dbe937525694c7f53c66ec8cebe5d1c076a56567caa84c45ff626e19b891ff440ad5e2901eaebd84e2826d07cca8b9af1de00b02e1385d85112368c58fb3840cce551f46fa57e2e7a38dcceefded5b923391cf4ffc77dd8676323248cb4b1adbf4e8e6ae05ca502ac70df644677ee7e993acec406dd58b07fcd859e3933d264581970b7f63832c42a15d791b5f4108a22f9f6e2184e396299c220025532033b0fae4de106678a35b3fbe68b8952ed2e4d191876e00668566131f04516cbdfb653af5258229a7b088c28feda0732cd74d5b60841d2d6563ea23c68fe9898a4ed6e8f233abac63e7d4e0cfdd63088ccb420673b59b02ef7cdab66a29a65a41447dea9c6c06e3d865b890b15da69c7dc945312abe4bb46943fc3e92728a473faa747583300acd1e0ffdaf3919e845fa90abe0a22706c36c5fd33346b5ea799eda5570f529a26f995c38e9034b3bd2faa9761b5f65db3c1ccd115fffe46b9cfcf6f128619d29b94a152a75488682b42989e034a0a9d5ba2633eb7444c21a0522baccf32c75914bd0d72b427abf3a90f857c536167ddcf638e450480307701b6b1996a4c021761f46e60947a0476a5b56e6cb23e2118ea48f69f3c33ea25e608da41120c97cba5198a75e4d920f86312659c5bf7d8461cbc3f01327f3ab01d4832d338cf934af1a95b94f8f51844e9fe15d66ee9f74971978583eb56b9ab68b458fedfcabccc38ec1dfcfc2aa38fcbf98ee3b7266b80607ac4d6052fd2257b602c77c4d17e853a7f2a9068c09b00be176768d93d79e805dafe0fce8ea358340e425d10e243efedff08c6b60f5e779bb959d99d061358b1c3dcb4531f5f0684bf0d8dcd38bef8cdab048e79e270bc1fa3d152b5ece98d969a64967eb9a588fcd4b08233e40a588b4b35a7593f3553c8eccb1a91e5ac02db4e3a533121da5ac37898b63aa5b25907fbbc5b938b11f19852c45883c226f4dae8f44ddee4791feff66c7e997bc8c5f09013ebe315604ee06a8016b9b6e48d573da6c868ee893fa3d0e97014dae98c76c1544642d4ed14c0d934ab721f2afaad3029ca5b18bb599d2dc103d71c52d9f5090ede36672adc1fa2b6c0ab943f75db458e81cd1782553e47e6e43596100ce81d576065438ef0d8169c42a6e616d3f5a51ff8e94ef2946e6ceedb151b4d422d5f252d0f1c0a04ee93c6a0b06f0516b25bec31792a63b63862d331c8a9f3b7440a7d5387dbcf6fc28fbb33e34b21804df0f7dd076a5f06d7ae7c95729d30dce873da07ef5baef2f8e56b4cbbc0f50cda38c36b2673a4821cc5c93f58fe43b7536593bd6a002ebadf3bbc1bfc22d414e0809f5d1fa3df4b7102849ed26c06a88d0b41a1a5b52cc713f6e4bb973b765aad676a9bbb14eec33d175b0f2350a298a9b4ce259da867d28949246d9a884321caeb907c55ca4d97dfea67963bc4bca37bde3c2d3c76cc37597443d989f89b50002abf36fd0aab29b5e18d6b89fc94de1679290bb6884459c0fa81ec0a75e97d9fe526c02b430314f8c3ba5bb57aefc721bc15ce172f797375b22a2f45f1edb7f7c6eb64236e80339d54485b16e99c80e959f179efddf533a584d98b8d634d84cf2ced67db083cea349634f2ede65c6287289444115a45aafcd9c107bf0388e550fd61dad89006002eafcf0c14d2c881f26deb039d22fa75cf1999940775ef38809f8d565428e542271f379b41a870beced685a325818e4c80220a58d12f4c0f07b6f3c1109732c170666b72db5e7909edc0546feb3769f5e7c443559b29fcc1d0f022658f31c10970d79f80c20007ecb14ef99fe2fb3cbb4d23bbbbe70f07da9e7c30a730ce44cb343f3d39e357b079f955448962104e794e6ce444849b91ef7b891d58aa35373835f126d0daa851708f3e6ab35aaed47b6cd331312fb0d372df0a33924a00096a6750b2d63f07386f463206e050ba97cf01d1f54f5590dc60a39356b089b16a6c4c69cb1541444264f95f317f2e12206104df8d1c0500c060530af5c1ce7fc84b405e6dc3f4698f4d38afff304e147e4aa08bca0c26e7b1692bc8113bbe137680f67f75f34ab7b572276d1bbfaa438c951d89c3cdc4b5497776dcb0a65b20fd7c9ee28baa35d87e110fa54d7cdd5b4de5b67c23081bf234631f47e875cffdd380246fc2a3321f0c4b038969810cc33aff64dbbb62a5efe7fa6c7fa8adb6eb7fc1cfc6c8f443129ab0af93d02f6bb5cb29ca4dcb29568614cacdda923d8e0fc6f4c317a48815d6c388058b5b587fb634868352d41cb1eb6c4bdcdc064c554fdb75ae971423a0ba87279569b25c9356f802c8c0bcb3f5954c527714558989525ad54fafb768d0002aa717763842f5162bad20e1f94b019a6a3b3bbfbd0c7ab4f8f1a563260949f4fc3df6dc77c18d8bc7f254cd3dded4d3b423a20285d9dbb1d2d1df614e81034e6233b22848cc761b630c7d9b13fe72c3368cee33422db649b3c5c12e94acaee8dfbb6ede07dc354427ab19b3fb54b4b7cbe6e0c3ab907ed34194f659cb62ce8e410586f159189b0260acf7aa92b2d4f0dbe3d9de41553a1678889c7c9f4972fe988a1036123af37e59b3fc69ec79fcc833d9ca8bba56eaaf930c33cdf94d2b5dc1a7bf6dfcddb14f4698bd6c9a40b8e41a0309a5501d459d88e9070abb6a4ecbc3200d6acf9d7114c0077fe62f6a8bddbb69d14fc0826ec3411312454efc99e489812cecc5a9a29080c632c738745c7e5dbdad86103539693d87188a4d5b7f34be90bef7eea2af11990aeb044bae69a1d4567981090d737efcf3371c82cd09a99d2a707ea6000dc5f20f001ecc6ecccf59dc0fe4216d85760aede03da38b79d5c639f9aa77af53e918650224a6729595795716e9a3c7a30a7a32c69d5f013e39a9db93ff11c124122f769c1626e55b264ae30ed091418a0a8c40fc58a58cd3a5e66686ff0958e5406b1635bd1eabb396ff4b27b1f7261e0db321a18a7ea9c0fe7a93ed69fb4a8c146a1e88e264da51ea73a068d8c26b3f74f2d6e15c5205f35fb3618d037ef8f93b0b9ceb90b9c1240dbc98cf998b0da1cf6f579e6cb173a10e222c484e0c924c71432ac56f15adf5e0bb5da749297aca70b274746bb0e35f30203e5a79313f6f0fa5d7569543cecac137697962624db17cb523c5300af0efa855b7990c282153de784a50e2a2bb768b6d89f4a4f050546f5028dfb4739d34ecfe186e8e26b4a600934acc87304f2919facf7633a7c6a7ad1bf8e55627c6c6c035590b854de1ce9e675e99ebdef00e05e463f678b56a191314c94da2b7b958d0aa3c3fdc06e43de63f69430fc23a3d2b2179a0a706cca9663f34dcf2ac8bc2c0f3bde275d1d1d38178d78bedbad2458d483e9278ccf2c2194c531053f0a53b04c89f01b03406fb9ff14623d31620b41fadf2cb8626a563c520d48c54effc74fed90113abbed49b686fe60b064e045d033d5e65df78f110c1da7da6fdab54461d11fb6889b6bc97983bfc6d9ba759ea6934b21c5b2627249307f4a5e1f6f541588652a1f843a5312d6c2a9e9ee501678574cc57ec497ba660b37431307f74249cc53060b1512aff5336779a8b8895f0d3f23671c277392f3cbdd9f807429d27519dd838fd2cbb071e7d0a74461ecbe3d730b557b7aa6ef7c8ff61cffeaa135f1a319884664dc9d2f4dc07b1c0b098554d444dea14d4bd9b9284c2f0a4ef173e707debfe18da206616ad2ebe76710d57553524c6d5366e0723d7461af162ca9d624a3dfe968d5233e7a12d829cf2045dee53248d3d63893287561377a6d9da0526ceef94255697c54f7cac9c19f296b919f02b9995af6cbbd4ee5cb853704da9c2e97388898a798d1bf49a1d296cc72d7ef020b72e68b8fd0dc77927dbd6748bea92f8925da8dc2f69bcffd65b5d506fec32ac674c88f7e496de1bfb17e1060aeacb41eefc90648d0e4f90b520841f253bd93565875442d85f97fd79b447ad841f970730e1c74fc00637a7eba1167909761159eedd6a2667bb1be3b299f7a420c1c66c5a082840b53a489cd84a749142904e390bb09e3d8617517d966898267824aea7f8835222181d6c9dc6839bc63caaec2bdefe3168f5616613ffa24acb52efb630a946492d3fe1e881952b9df585344232ea33f287d490f1bce4ffdd88a9a6c7cb611853aeb0c1bb21a11a10efd24ce71cdd4d152b54797365c613c7180cf9bae58f8e6fcdcf28f90411a3d138e16109a4775e7c42c40baa446f7652ff0691c9b38572031bdcd21c1df9e366699c5ff17d00eb7167831a4f106d8a1f8d86e81eb74f554d59c53adcafb09f44fa9e7670a2cca569ae1a1b7b53d633976c613d8e8b02a69848511b8df58d1d1b552789d5a39fbd13a00d595c058fcd396eae40212e1048e3d89c74c19a9744a6348e44d9df20c0a1b3c8aeece2539653bf109c49c58752a9023653d82fc2c8f9c85fe3af21ac1bd33462a90c91e4b02c3b4590a6f0c4dc6f3d4c634d6475757e26cc4a94fbbc17eb8e6be1a6ddd9fc1e4087f544c2ce703e76a2f3d0b91eafb657f89df088e8e4d1f08e80274e095fb2166cfbb8898f2117c8176273e48cccf58bdb2cbb965371498b894e7a845c8479805bd573e541602ed4631d79918a422203a03e11fa3b56362672aa08880e0d058cbad105a0952c0309356e5c2370e08c9146073d9ce7f54ccc44249649e40c4d852008ca44cfa4ba02a30ad21280df69e037fae6b0fde2bc02aec70d707c27b7da9ca6b08eb6aa3b9a814b6e64705cc9d75109e0ec7f66090f971f41c6a1bebfd3d28fba3c08c7b3af3a54fd165081576dcfbe9b6fbb32cbf90829f6e5c70c483c52bce7d605e6d0c3d0d17c94ff5bfba273c69074f09d02bc641a4e610fae4b99557e9d52b0d7eefaa111bea2dc594e9c4efca33b3e21c9e70192cc77840562bc94cf3afc80c51fd04ab254183bba044d2c154a90c4d8175864f38d823ec6f531e7c78f89a6979131016a59cdaf7e8ac7ee2150baab073927891bdf67292e6580198e8d37bc026c7b490a77225f9f8bb4bb0e5da24dbbf185c5d620371831bf8a6dcd64e03399fbb07ffd5e0b82aee3568238641225b33c1bd5f38b0787fcc6ea524f8950b2d9f8f68e05b74f0c17a0e13abb76f3ab7de76c851e505e7499ca3a2cb94b9b9868bf05ad436f5e055ff81a587474b0456b615510f87d05041d85a912ffc6ddc5772cecd5138179296861f9299cb473f9660033d70e748f9056272c561fbd08d700c700c6bf03c82414d6d3469e3d5ad161a9383444ed3d8e968ea7fd93c74c1217db724a8539edf5ceb8465e50e14b110bbd8e58148a03f6fd891dc9237b98ddf296c0347d42862daa3cc1f91c378f3b36a4ccf6851d16db4d710883f727b432012e58001dfad83fc547666f129237a7e38d6236a3d9fd73fe5fcb72f8fc06b9fca8877186d3702dfdbb13da32297b2aff58f9d4f8d0d69efc41cf2b6ebef948a4f394cc412e4da1f6145747c7b2f03df86615dd973e1a2bfc7174ee577ed62f8567986b3f9f22dc785169aa0621358923fd16ebbaa01eebd118c9c0fe67bc2a943355731b14e974fcdffaa7bc791f6eb538d54ed7d1bd5d0fa578a8eba8c2db13d3bca792db8c1d92b9b2cf37be4a116b371892ab98dc3a3c2bdad8d7e0374f8736dc210556461d5c7281e26702ae7a08c64cf76871ff34ebdf19e01bd3d479afe9388316d4df960b04ae16e03ba6735a9baf33cdab0d4769461aedcf0703d72bea48e4303b63e674eb4a1cb488c163e6e2445b2bb21bb3410ac1dbe98458671225b707a87bb248838529fdfffd6f8a1695c4797561bbf88b2bd2a543c1bfc8beb5620aa8c53605d5a9251f22beb275f47d6e901a61d456a1a22795d8afbfef598217aadf5687430e5c61d77ba9ba066e28acefbb4cacb0058836d00d6e15a5bf6d8da472e4898fba747f1023784677a00298a7c346109af9db5196e19cefe98bc88046adfb84b363cb94dc0bfdcae81a7c62d21d0f00761bb728e0ab6e55f4582f3aaa9d8e1cfc91f2bbb58fb026870232c5bbed24eff91178c016e2a3e5a311910bf9fa56afbf3c2dbd51f6a30d987710b7fd0e26f93aa241eab49c8e55758df11f859f462e5691eee1c90ffd7557000bac17907d2e15b98edb9b14ecd16c42cd827cc1c9942fbdd52eeaf67ae42c54ae54f9b0b25d866074a6ea62eac6ca780e058f675d35e3eaf4c824b48167daa27ec7fff55b9c2c99d71333a523bbf6665a475f3619cc465dfa2d700e8a83f29c6cbdf6ad883acd498c2d0af050927d1ef336c9a9bc019682f0fcbab423fe079027769a2fb4f544cd5e0d5f66f58b4e01275529104eb71e46626480755e5959a9f5efe5a6b2aafd1b857efec6514a2980a102a53c7fd4a4c5e023b8f13e7f754e5787bc7dc4d3d14257682d3205922c3c32d1d63c08c41a413b58eaa20d872d573a5c9b8d116d3cbe0d0392c87f969d85592bb75afabbbff0676d41ce689886502dbee4ee4ff64e9d273fd258505d1d55b2cdc157eadfc41b8934d8609c496b099bfe30724fcf556593b632b8925aaba4b5c3d335a1cdca2e898868e77256e9662f2b08b64fbda656a5b62e75884720d5dfcaa14afd94534ad8b935ada1014c293cbcce78166dd3be77d12e4e30094d04139f112ae073b12abdd7229c3c97380334c1b219def177f6bdad588d1006cfb3186bde3ad29c0fb8ed6a9d438121abe40c24c2b408db75bd63f10e527f83f9aacab9887be6b8756f654dd5f1f2c501dda3f1aa679f1189016453902979175995422b136c8ffdf7804c13642a986265b5df967f6e2d019778030ead89f77089a68746a201f2d12072e6452514ea61e56ab28823968d105b1cd6ddeea3d43b0542f3b77f834c7b1f62c940162c0060e46d77803619ec2832df00058150167bd713c46d05122ac5776a410045e152cb75727f141aeb02183a777aa13ff320bf253be68732b488b86556370baa824b9dcbf353bcd2ba278b3a02b501d73125cced5dc18d67ec4be8e018ef9e96af6747fe0f67ecee8862b313113692b95fa7df6c70d298a8a3c8338e5cdd14ef0d8a511e0e94ea9debeba63f0b9e0ede536e2514e0d1da7e9c5fcb8a804a650ece99ae4fee740690d4fd12789b1b73a94aad56173f1c55e2058b5057e8bee8aa7b441a2d8d75716f2c68ea94ba8e27b69b445fe3fcf0a5df7f19fc0733aa94114dc41b0d49e50b6a5e4dc2561e9d941fe27848de098ae386d60c5ca51815f72ca07a0801e0ad9a78837f0d7c1e216e51493cd8303a33d27b35ffa47eb8efea874d6c251b8e7b6ec15d58a6bc6b8afbf5b377d5d50974472ed2030f3fe9eeed53fb8f5b8ec9bb5c99cf6de9ddafb416c033bc37a0d3bff3c348de037d564d716ffa31d395682bcabdf1c23f7c364fc0d17208d51d845c34bc3ad905faebe36cf8a519fd46ac16cb617eea468b0b624638f5bd6e2068ff7e1a7560d6de896d8be19ab66a7dcf61f3a91f174ada25286805cbe762be7552b43f87d47a6c77fc9ec516a923d199a27ef0f743bb924206c81fc704e71f20cfd8baed953762fa61fef8966018d8714bdf173f747c55b138216be628100609cfdcf4178eec18d87239c0648cd9094093d9bd5c486cc0ed710be9cd69671cd4b65999f5eea3c04d182ee3dac83e17cd2e4a34ad5c370e63940aaced7d8221fed5790e55ffb8b33cd1228b9f4befdca5e8d53c1c162fd3b6f222a27e430b6072f28b26f77e174c514993b8fed9ef07a5d4d2f264a1d377aaf6c706a9048389cc08b70b90ecff284a25b9d0cf7a9a9096986369deacbda78e8176c780c7fe89ff415a4971cfe487b3fecd9a8399abba10478524d5e7612e933c40afa400a3d590253224774998431c5a32479f642d49033ee518c3a2655a3583304c1be60b4b349ba0e6fc8858ce89a3dbb5d8e224323b3852601e350eaf5329df7241639212443202fc21943e1f02c6eeb7e02e1bbe65e3b8883c13ac5eda17a46631eff8bedde22ae9637ac6bbf723e1d017d486dd64f2b457b11e2cae3c5901b9352fda4f835180b041afcaab27ff955214aee5c96fa938322e21b1b8af46db441d5ccc697fa919abd262be86220f9bf09789191bf938e547d76b0a8596b131ca79e45d204a69f5e5d92f63718add6a68b750ca58fcd01f5cda71a9bd652a8c07aa5a3db184ed6d5ff7266c290d05710e85d73d1c847cbb3d1d906daf745bedea0293484653f3975520d82af3ed8ee1d4dbe812f5adcfa845429f3f8f57579ad66da0e2730324fd8a52725984c94add6f3e2439538738736a5aa052ef365a611a3e5b5ede6771a0318141335174a8ddcf157f893ff0c86b2235be1cd0264482c4f692e76799e9bc95d83342548f85fc9df6072c11c8f7fd17daad0e7de55c6f1a38d2cadb92b2db7fd47a232eb482a0c5a70ae52a9b6008a751f931d372fdd7ed4d4e39fee8a772ced8d30b380ea8a471fb0009810964fb7aa80ab84aae9011ff458fe4e550c019d965a6bf26471f0228d9eb20dbba36a1d386cab43ec22611a4262bbc5e66b4d6f8def7dcebfff966dfddab6e364964302fdcafcfb6b7cbbcd38f305c767d3bf1dd59ebcc7ba7ec2b3f2350f9bf280184c8bf590a70305d3ad35f06aa9f81523efb4299e0be6b1d44715b4ed4b53803339c466c2c4a5ce12f58d4c87dc3df524e044ace11312a62519fe5f2dacea511366a3604855a94946d0968fa1927ccc523526d0f6e1a001dacccca52d7c35eb2a372d26c526c4dd4facf7180a70f2a1d2676a3529ed0675702348a242af3eeea2a6144cfd052e953458505856ccced1382979f7eed0f9287d995981e814ba1b41e3cbd0c161cf64a034b9ad473fb0a64a8a8fcd1751a1855bfb0b3eb43c3fe706f99e5db6f5485fddedbd6c04eba1d660ee2df7f20588c298f387e6161b21f2254d02001d4a036ae783be83a424451b0a0a5a336b561ff47768ff7ffe4dca68cfcb3cdfc4b238f9474c040ef6072790738da1aa6715f92d6ed531af63d0fb3db3dd44e7d13151c9e50ec3d520b284a736d52c7a32f68975c2479dd8361d9b5129838addcffe1dc1442b1ae2adeace5c2f4ff1cdc458560f99ab0f4dd1a0202668850f2bc63d037bfee4b473a72d7cc669613b2ebaf06e978f6ff851726ec4210ee564761a0c65f1ef369211cdaf45d2ea863b9e170fc09b8b7f72d80f2dbc73958a8bb3d4e3272c3abc782d48e30932f4134eaffeab6de862f11576d1bad6f4158e82aa64b07a4219ab0155059b788056a4a9c8e7f44b1bcd0cfe26e823003ffd7261e3f0857f0d3992562fa6662dd1ff7ccb70c87cf1069c0eaa46eae8a273274356aad1277233aa2bf4b2adeda9b59224eee53675f322bd26778a8947befded0f43166b742a7b3c9f9a5ee7e872f71da55a9348ad877fc02257cae961942c9bfe27cb7b65218a41d99a6cb55e85c375f47412c0a46098ca48026a0e7dcfd2188f16ad674814a18f003ebbee45cade5da9030c802175655a79a71a56b74686b0b39804f071284b34b95adbc3f2341fb7bd8bd1359fe751eecfa6c55f36ee3e8783272eec9e868565792547fc48da7af520159168008a5fc3c4ef4ea84357173abf629c79ce0f5481aceabf55878a8e4e94c278d2880996f9a028e063ca4f84e7101f709a2c642d9b419b62fefb67a128359295d5b7cf7536e99f4159e86d82d811ac4734c97c36dc2a6258e2ec6288049a81112252f060fe01f5647049f7e5044cb00f8e17547ea6f2486e26ad0eb66deae401e08764e5b9e1ceb4e82a39b4b4a286fbb486d5c865a65a188285779ca7c4d15cbfd702663d3d74cc365bdd15b2d5f08bad0f6319c0ace4878028401618bbaeb38d64ad3d8f368eb29828998c83c21c7653ad6336887595849a323ada8e913debce539e1d33fa2991ec4e0b17e8d3fabf8df6d824d4ebee13df69db4b6b7b0a4caa9ec70c61426d14acce9cc96c9b483621e4c00f35f46aa0b34be7d47021cabad863ac05bc16f3b4b44396dc0418a7e3bf76fd36f916097d72b3e2084dd88bbbd4e7516e329670259abae1e0007b7de1ecbbabb8c02235fa9d4e2f71ea29f550aa2ff158077d94ace356b7f321a2432cc3f90207c16caff7035766f5f4c1bd162c38b6d9f8148906323559d747b514ecf3bc6c3c4b29fa1e0aaecc6bc38309915272d64db235552e0dfe9db6e7c6fd58f82e885720af8954d3154e1375959cd1e0177ecfb7d7bdf937df8bcd631e35e4415a543944a918909325cc42122bcb1bf922b1eb5923961e789af8f4ae8091db11771271935bea01353bb057727619f5359901668834495fc004dc449a23f991a7b3987c212c614b304da4085d78fff0406998e47118e7f03c591c9521c243c07ceba0d377321833b9be0f7345e08c1b4a6ceb7ca7f313c26fec1417d34a04d26db6dc0903d965c53c2072e18af8ba5bcc70b77bb71ae50a7241ff1abf24b0cb96a2905aabb1d60559c28df812e6fb4bedf5e2c1ad6418107991a0863d1ee2741b4c4499525e112cf6cdf8fc3c00f52d46ee5d7b300bbc091d77d6a9c735aacaf00842f2b09be37e2365397017c61bfb744e9ce4046d30b76384025db1f0a1a6070751e698e20f02deb1faf9edccffc24536912719ec2d2cc719f8b8814a7e520a976c6071e9bd908a28f7d8ae621df70ccedbb57b8d48eae26bccc08dbd654ee6b081d3fe4e6aba9a89c516679e2321ee2049826b96cca456202b6bc1cae59042a82da023e5d834060ce358dc09264dfdd088c4ae4a4b5677de36175c9da51f0a44edd382d52336140b3fa46c4aa1dc92a0176d4a4c8095c1e6b9398debdb3520344460b8393508f142768a2c3161482fcb157950e10e67736f7b9b90efd1562248aab550d1a01ecc8d133c8c5edc040a7f722618ea7abc2974446df12177669e89283051722355c7461256823454ccf8cade1b6a6924c7d93755e5df2dba24b2209e3b98c9d88ea5ec395b24c70869c0003cd3420629aeae3f90ddf5481944411b73abfa0d57068addede270119a824c5dfced76c37b43743371718f7e7371cd96ffcfe5928ff1558e58f4134eb13a96e4daf850f29479cca4be7205ca9ca427cd3e4b478cffa9fb7c1447626a9886064e89e09ee1c04d47d7d77804f231a2a64108bd4b20e4899bde9c708f3403de6b99883895e0722a69eb0526933449a2247bee2eaed2e97129b620f20500d3996018b95bf22d58248c02b68da2c800d1f6f9a525520c338f43b8898ffdfdc4e0f0869fdb7e7f555ae82a3564dade8d3ad3993c8ab09fcdef8c170616c614f227a7a5fd44149bdc24cb1c5fd6e9232e0fa19d69a8f1d48543e2739727918303e84f12200bed2d6696e1213769104c7f23329ae4b34f87e1e74c56347fdc525dd7e57f6e3f9223def8c56597276e38146d723c0510cad381160692f634f116958444765adf7b3e0759bab7b853e45875438d4f1428601b46d19b42fd1a982d61f024213130f5ada6e6b3b358084951d45f4a8e85b81a31523c7ab4202612dd2d512db027bfce84375056e83a31b58c85f0fca73bbaca34293b8a445d728061eb652b5af961fb27d3a686b8474bd7f935d15ad9639c64c4a77ba89ed3a464713ad1e786c8f5473b4cc09b8c55058b0fc0e636ad128c4ba8ba10420f585f800276f0286885a11b9df9a658e13bc89fc9b6710f24afdf3ef7ca2eb42e8e0e84500d2a551c115a8f7e8ab80d250d1f00bffb9fa5de512f2b42359268c1544b0b6a557e91ef8daf7fffe14bc3a631bee1fcc97ce38af9b012f9ba7686162c1b2499f7918d646721a33c19418739401cdbd966563efe7783fc7967212279fdafda4819d189899d9892cbc4d8e6fc7006922bab8805242d4d25289c63f52e98c9e915669a125e23f2b349a8b4dfe237b3acbeaad2e7e2287485c379126ca80c706473064614182f0cb09c674896aa5f4e5fbb65146a1a77e41ec7d110c14d3dcfe2a6ff84e036cc760aba5734f84e34cbcf7df2c440a110921a9f4391eb81d880f575ff977be8bb514a0e439e7ab50fb67203d27557626452bf5ee95ebba76860ca9355612b04b9cfba3af49f1ef6253a555db6a15ac248ba797a98bf5c7a3010b4ce5b52a79bc82c854653a5e5b7a5122836438e31cfbb39a68a7a96df1a4cba01da77b884da116e285250ebcd9cb1d9592aa277ba6114c2b20c69e51310de85d10ad899ac2e125b439eb7828aff53d2783a545821ac2bf62d332c90412928d346136fe2cdef0d09f4cc36e65947ce3443e41ccd228678b52e4e0a9df8608afe1b80c360f234ebaa0f0baf07fbfefbe574e29f76e396b77002d90fd4f105744f726b91066836d47a555c12896401e3204f16ebe377e5f0ef102d09c1b735e8e1c0b806f06d2d57d862126d5732e8df5dd8b9535b4e331fad40754b31f480fc34b1944b3063640a5a2588462c784ffd37822eb9237795820e308033550450e5d9b7784fa63dea0e21412962cb10ee2b6b38a8fc05a8d0cd415d9e4d1863187d9dc4fafc1a7fd2d4c7ea44dc49a9f12f0c536d5c38e6ae07109de4a63da463823ab0dfad02cb9aad14698fda0399aae2f348d7743c3b7492bb0fcdb586f47b35b79f2f263bda0982cb1f1abd15c5ddebaf37778a132a1c57f902fe639d4bd60d3ba1863e5f796b06049bb3287bddd203d39d99fa98604f8899e2025f867af84ae03b68c9428dafc61ec010adeaf82ed1b948671570f7aae92398b607aaf20fcf3cd51e13d285adc5549af262a31f42b6e410db153879efbc0c3ddfd729f0a592a170e4a5b13a21216d20d2bc5e32281ff6b6f67586a8fdda3dbddd44cf19b5cf87460fd4d2696b569e061c7faed875e18a9d01c5095be9d961be86444dcb5daf787bc0b702db0c451c513d8c523e888054eab073d6f44ad533e9fb173d5711f21a6eca2167a85ad4a3c8782229fc52ed70be0e53c0089271ad4c2e058144f8f84e1a03826fe4145b50e488f60329973b6e7a20b468c90432eee9545101a274d5b8a1b1f233da235d1d07bb7b3a1947622ee291dfb5767a125f23be27f087339c008c189da4ceaad5296e0f76a3d3ea1e31080550ddf8b26c18472342fd9a45f67d2bc829d06854a89e4792e1166ab96fc6ad9b7bf7f128b0015abb8b19991ecd52e51540a04f8130ce2ae5b29d3a8111894ee95e67dbfd31a13de3b9558b844b7df29ee6380f483df256560d5eeb75d692ffbeb90a77b1dc72cedc94a28a5d1a8aa9dae1b76bd2092241b40d1524ef867c7492a72182d7eacd54c14c456839b7560d6dcae279524cfd658ecf645e473a800c0c57bdf56d1b28563fbfb501adfc3806d7b004d1da74547db5e59dd21fef8bcb0e50a5755ed02837e7e1f1be5b10597bfd7a1b7230d4b3c17fb3ce1bfc379621d9fb9edc1baf1f07284c0886e97ad2646e553202425aa31efe88a0dfde275a46d0aece925d129683bd9dcf217db1e6e56fdd9d3cf40adb72704bc619c2b2eecf1830fe86bc9d95e1d3e4c0b89e4f4604ec4a9ff23b8eb9ee908b6e0f14d8522d9cb73b1c38e7262fa5921015d1e84bb689ceb331933a9dd44b41df6b8e39d98d93fb1d5256bfd209b7e0f274eded43ecaa532347d74d34a68a957d8e7e7411d83125b8d3d73ad0ea818ab6d273b1e995a55af8e96e83be9e9b64dd0ec05be6cbc56f1a09cebe6663b9f4dfbf252724c7b180cc997119735169428f41efab24ef84c5dc862b53503d8ea647e5ecec4133593c7edb785986171daf8f9b3e9e2e40d4a35a2da876fddbf6fd0ca19ffe28d4d39e537e4c6050ccfae67c757e5aa547e478f4eac1bf0e054394701ee4c99f37f2fa950e61908ad73f9b6d242279f97187d78c26a95559909a18bd04d5339d93be8ae032b51336bdaa44d91766910aca7fafbc921c42ebf6dcfcb94ea412e2dbca05128d71adfca0eadeefba8f2795029942a252ddbd8120876b37def93ff5c50bf0b0879bd2da26a13ddd4d8f9f68d227a5ff6c0e1e394b1d59e31560c29abf6d0611d9c2090a3d81f9d2fec1a9727ff0492665997955b0fc7760a3bb5a257ce1aad234493f9018cddfbb04424541427f09e5d3cb3d6fb02e7f7da0f2a9c5a9f18f87808802f5c0115b43a875780e3a28dd2d8fc6cd2529cd796578a3b51943f89ba35bda2129c3b5638fcd29a45b5a6646af5e1a5a763744cdc05f8bc49e9a25bb86a9571673dfb244d95358f253290484cba19563ac1d9968859cc59cd8e1d0bfbbdcb4d84fca9fd51e6819bd8610d161867bb33d5ffbc10ea19521841bda71ed430fad1893a184d6da763c98e002c6ca041b52be7a4148e292cdd65931ef90491c42f89388bf1e05996e173e6dc9a9cde2f8cdfb4c2e3d49d9becf8f53c0ac924a3f6627de52cbbf7799a162292431ebe13324f8014d6b8f0e6c2e12b26f26538c9556bba52070c124269db46f8411d4c5daf29e47d2580798945bad8878e10746c1cc04d7d8551013c2a486a81567f8da51e3d06ff3b7c3b7a10c98fc59801ec01c601bf5c0db8700f46787af0fb604f0c827a02912bcae78da3d2d81022dd81c8adb12079ad9d5da65f94450d4de95f66efbe8a350150beae55dfc474b83e3ddc753a6e4c059de8f1ecbdda9f11e0014d5c1fcf60ac87da8873dd82dc1ac5eaf4f18e3ebda548a783bca9ca2723182d52b26f14fa1afae76fa18e0136840b106f8b8a85d888c0034a3721abe1b0994be57c3d702344cb29b2c6e99654bf25dd99e449efab8b7216f5616a803650619cc9ed28f88ae6c27da268632d463386f19d5e9619bb806eed778316aeda2679d69a66aa9dd948e7d110eda0417f7d3533790dbb18dd4b71ff61cb8099ba04e73081643a271293b3c513a4880f13ec764326d942fa387cfeb2ca8c068f900dea0cab5bf4399e695fbbdd759d7516d20815bac1cab14ee3265823fca877b7971427587e5ace1697b2d28cd76fbb55c9255515c15b2d69d66ee1ee2b8b7589aceed34a7313e332cd1106166135779913d24ddf285e9c97400982f63a0799d2c7eb9d39198d7e5cdff592508648693fecf7e97a5a03409bc3dc6a450e7cfdc5aa443105066ac0b9b7e229a09e9b036d538784c990d0fdebe080d00f62e8074a5187723aca093e3a86324e937ae00c7817f99f47f9916f0cc9539ec1146b07022bae3376b2aae471640b4bcf8b95a1d90bfc62fe6aa8dd2061c9f235bcba29093e9c2841c8d0aee1d6c2a1760bce1545ed6c4864d774cc6de10d877beaf56f26c8ad9d4f615d7b1ee5ab2fab2d0c745789fe9c32c3d407f20fd12b0490ea7b6e6268d440f5d4316148746ea8d89fe8b927a23f939be7896f4f7b94db23c0413420fd037c12dc8c0b2255e33fd42bf0b0d91e4a6e609fb8a824c8d35a9966aad75ca33b5c9f24ab16b4a3492b1aa00e9b083cf47c1d45e4cdc8526fe495e406507201347ef036da3738bb2980679704761d863ec4f743126388efe88f649261fa4579de896e74e1415eeac13fd6f8663b9ff84d0e3f6c90356451fe4c51d45e83a16e87e4e1e2608d87e02f12c00babc1f2831a056f02a51f8f153a24f15c32dcd024af87caffaa3d5070440271b71660ceaaff88d2be9418fbbb08359e88cc70f3d1810d5853f6118becba069c168b4628968e7f70b48d21e7179a37727a6c8d6ebd64e034d9f119a263214085977e8a43206fbbf094a3b3ebb54bfc56a717b833991292791ed787e22c8b3e7703536fddb5d7a03b160c9c97dfc1f97d5eae51b0d187a1906ab1b0462a270af591ab95a5ab05e779ea47359d09fd43f9411a55767d9df09ff870d2d1af0a57ccecd5db9ceb5836c78ee42bf0007504a7204a3f4ce6bc8cacc3789f73318e00347a672a971e881279ecd9743fff89c97a4d27a7ed010f10e78fd85da70479336caaa595ef492db7e043835bb84b29a3e6fd1cde099a1a2f7fc090c98ef8fb3311e5f75ffbf125d9c858352794a35716305c4a2f7f41eaaa9eb185ee8feb2339bf724684cb12d824cc04c9b36a2f365a6863137b5d32aac46cf70fb11c3541ff962c4dda6804c21c45e4da8cd3768546051e8dff21cfe06920fe5febd64f38978b9c1d364b5020c935cbb19396e476f27839877b7fdecc2cf740a06411492d734d88f640cab40f62a002e04315071275c8b054dc2e3ef7f7332e40879f42ce64946fb1b78c31f8d87e636e248f1387303d2277525763275643fc56cb90fb9148155a61a3724c81cd65efdb9ef13320cec2fc7a6ea55586a809f6a7c961af0787a48b419c84c417c1e7ebddc0939161562d174a1c3a90d3b491b85cc9735f390793afddfd068c20ed9719e62599e515d3458fed647e078c8c90e0ba82cb48d331e0d740eaf170b99704dbdc7c1e44397a2bbd9b7b6d37aaac09cb49005d7cd90d0962e4543d06916572fecacb403533e8d3554a61fbe145376d7a13b862e2c8d59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
