<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6dbe7a9e1895b262e1018acbb38b91006b9f4b705b61e2388990056194d73f8ea56205e65931d46677ae6a6dd6d5c72147d49148f661384c077ba6f29128e9b122d5ff04f7f0ddce6b028538f88bac77986e68efd75b0972a339c511ffa7d3fc4cf0a7771ec72f4295df64bdcc0f98fecfdb03fef23ffff71b7d8900abd04bebedabaacc1a052de8131cdec9dca79ebe5a8b30fb4b4297107c8d5fe2228451d01d1a574fa9567923219e2bb654ed16776d77094917440d5a6e8b1fab8bbd54fcf474a186a42ee34f6a73e99af8d5534dcff9777643c1541db088099e6b7b182b0185c9218621434e6ed844b1c2e538d509d7d53051624e9d71e2e51916ea28a25ab97fd3fd664b000e8ea65b6f87ef14b637e8f444efa3593790f331c4434f6de9d86142cce17eb7996f64b89ae490e296d7d96e602aa664edf76547d4b9762b4a115a9f6313871e4629d286c2eafd01d5f11ace691374f19690ff9ff6b757ce20f45ce24f0e896136f4bbc3e5d716cb0815a9933b14c73733e50772510741fac0afbfe90f6dec910820245d201967072ea79a423a1df7584b2fb1a154fca050c4251feb76cbcd717f41b4a7510c8d170c2548a81bc714d446e1845f138513cf8ec8230f9d073ef21686b87c7ff2ec4d7385c6f8f47ea3a96e1b56c5bbb994450e9b717c41b77d780e7332145b59d5491b83c957d34de9485d7e074f74d0685fb6e6680bef73097b3ce1b989efa1737c6a8c86e1bc8197903d79295e7b3e07f069ad0a5b45614622a32feb7605b74c865fe2195fdba5ad305fa74d52389758b0b9c1d2f57f1d8ced40040cce77c925362f504b171c968e8679b7e2583a34815f2c56393a48fc1f072960444adaad79ef6c2746e12cc6aacdc00332a920ae4dc06703cebe2fb4cca983a95a98f2eee8b40b0e4c6290619de22714916fbc67d9bf3021fa7bfdddca34f2a2972e9bfc78a8e997c3068ad72b7e6fac0b4475ca5fa6d4c9ab30bbb60b807e74f8f97299e4d9a7ced8d3e9362a7e960ce7dd095a2ca2083af1ece965fa1f83e35523233a773e63e9b62dbf70b2c7355310bfe6c0e2c32c1a30ea9c1186d788ca5f8b6c3692b71393d1013567f9bf8f8e52108c4822b22340751505b6dbd7e0a31740f8f3919314e2061563b7dd5fe114759697fcc8602895892065537889c448dbcb297fb6bbcf1d08007ff34c0e11cf721e8f0e753c30a9695bf8593ae24046605e779bb806d3daba47b04ef98f646a302b3d798275bf1c0c8c3144901633d1557b99c1cd30579b3cb688e89c992c427f24a1c2f8ace431fba6b5ac9cadc1eee92057c5026ccb19a1ac9674cfb6c43af0ec831632dbcd5fcd37322c4a627884d58dda0f69f03ba7fc3f75351da979b0ed2c1bc65b4e9c8b0b3214a4f4a831f8724b7a66af50cbe1cd5f0050a67ef2d2dcdac9ac4e61b6c9d4072b624a8c2bda4fe223efef09ce0cb1fe85d437416a643381bb9ffca9777c2d19527ca2b880b302cfd247f75abfcdc3c3e5a9374069e7eeb76b367d460379c931bd752ecf910415a6be3b64c2eb39ab2c6f11b6947c2ef975ffee2da386efb02775c45423ff6f223ad91138aaf625aabd3f442fbcc28712d25252f065275537a967852a46635aa1b1222290cd2fadc156598f58005461244936730c2ff4f5f3fabf8930d752f63c336b99312fc55a2db86f38cc7ea81e8b72d99b98946f47ff4bc2531aa8049df6011d2251c73f844ace8651cf20312fc34ba6b89b70b2cac7963081e8cf544594d06a005e22217e6d5aa7f53fa3799502363023435cd0b2a25dc85fe50da2175a5ade684ea1739fd7bb99ab881e4cdddc358e66add7a6cdb3f646fbc1fb99f7101be334afa5b388a643dc89b4d10251b443e96efd946c9916047a3124a29c53539db0f3b19d79ace2f49c952ec073983d140bbdd085d3f145cca20379bd3ae3a29840d8f8a642e5aeb218d77b0cba52b6bdaff04322e9aa837063b6bf16a089a4957f9fa994a5d2cd540d94a2f4e40ecf5832f5cae4366640891ba95bda8ce9debdd958ddbda671927bb70621b2411b975bd7bfa3dc2970248ad1e92d47512399b5f9aaa878a115a75bd4de0ae9d0e9cbb148b1f182c005ddeb9f83ba080a3d00b61df59bd20fd1916504b98b88fc3d14699a32d4fea9369fd35f390de31e50e7e4a82d8a0fc2b7ebb16f610e380aa2baa69085ab5ae84a283171579493a7ab1294c18d808073083f718bea97557f8eb5f99109af406ee151da88527baec6d813b7dc647832109651fcdcfd8b35e25c90fd329b2171f24731f3c3dfb5725112b41682a60435bdb3d529eff75ded0b2bfe5153227ab485884d91b6a1d28daa31b1b5bb1244c8be78111779e7a55a7a23fc9b843192f61a8f04a79585af7d6d2c5e225af6f06ba01d1cd76881e1f6be3befadc8174e18baa7ef773199da261c653f2c8d38e4ccc8d1f1b874422f8e1d012d6e815cbb5979bd0eb103e9b91f0e5252ab011bc4783084dc6923fd2f0ea42d387448c08b15ec4356b527d6a1f8a0b2c5656cf9683384c19d40df381e8f6648ffb3ce1c72b015983ecd8db9b174527ba410312ca505a92afdb85539f8754b365e6b79059d3d679cb905712f0ea2309b53ff6a4b516114b4ababf40ab640df1932ea013ba16cabaa9940ea3f6db6f163049b58a4bdb5daf902a3f40978bbdae096d518deb9d2e50743fcc70ee5bb554b7558d0cdd66530990c431a997a2c32c96cb1f5aae1697b86b857f6e0d411565f901bd8362a9b800a1ae2792674b007df0997d6d9b931f463307e809ae1e6165e79cc25a6e495df6032ffab9bf85f350379838176324a8edd3264989f49132a0fb2a9cd57349c7ba32696f4206cf2410c0ef3d09811040513ff28bfb97fa1f97788e3c42a8fb47c52929385c7efa1406610535606adb36dbfb1e2767d6ebfe4e8c88838902e89cf2caee749443a14190c83dcbd376730c7b16c29462292ba2564618f00c93fa30d3b381d13208b95531222fdae92f6a395dac3ef973ae911fd32ccf00284733a3d589b4d7ab040d8333e3ab73a19bd32a6ba392a041a1c4b9ce07ce4d3f623ed1b9404b9b6660e5dbca24d2f6a708f1b862bdde97da8c63d3033a7c38644c69b994e4b5ba35e5284c2b71241251eed831c1c50f66c94401ea190acd1fb673bd22172eab92283a6f6c29e162c1c480ee5fb0ff718fdbf8daa7b3d7dbc664f446b982d2b1227be3ef4273f7ee8df5cc4390370d39ae9b76a9440f30c47eb2f2ae87788a2d47d7aaecd46e689abad99b84bdba195a493d08e9a88658dd11b300ca4f818e9de3b83e54eeeac6da8e2dfc7bff7e244e20c4060ccc5b4353407ac23ec06627bb1fe5abdf516404cc4bfefc5744675b1750347bcf0e297f9992f581b1e4024a182b3b724f3dcad524b8fce5915f82f77a0dd7867b95882e4c4a35149fe459e28bc67e4ea861368b84f09441ab3fabdcfae3602084120acc80c0ac8fec3834c8fe4b1a7e78104918532f830e32435e42c645942683debcac22801cfae7786325f8cd58241d513ece7d20dcc0cbd0d1b1b2cb227f8ddf7d3e8342b6cc1271a427e8a309c6da5942df9ceaa5624b4c9d2690b325d39de7d99e34851deb8d5116bb49040c241f9d0f146f27cb9e767653b338d8136950192d8564ce14acd200f09352c071d1aea246e69409117af68aeb045753a07e312ced51483506457f0cd7a3ae9e1355e49ba16cfa1abb7994435573ddfd196c7caf4f26f740c8ddfb146497e40be588698548878dc06f1e52dd84cba94e4d25166e72147caf45e545f5d5b63d6660fd4f3f99aad52e7350ad89c4ab02b7111dede48dff1d04e63190407c35d5e217daaa97b9415f765940f6dbfdae61675d7755eac7333be77035c8acf55400a16867c8cd59c8a10896f25a670d04602b97c50a37bf72fc3d19f6b061b2d0270dc25860b71735a44049a310f9198e5ec74173dc963ce9975b68c585d37cdd90635db8b6f7a120d449bf18fb1de0fed3bd4538195d33d4a82f465298fb668f138d9de6f31abbf68947b54176e931c0de7f0647b3420b1a51a19e4c84596d426ec934473e1e030305f32d8614d1f7321bcd268e8556aad960ed193e118d18094c1f2fa6bb9307930bc0451c00716f3bb485bbc19c31b4a3768c44c1e88224e9d657d255b58d539eaf04415f168a5f69aafce7b3a02c973f8b3054a9a03399b30541dca972ce13f97f632aa6451dfde011ee023fd1ab368b159d4c0b0d3f71a9db094193fb6737689f32fe8eadae139a5fbda6692cdc87cb523caa8724419cfc415d431374049011f75b4c1bd79c2849b57d1916d9332286281c323511f1f9ce662d580fd04be2576491ec230161e824b0a8e34d2f883927da9f9218d69502f056a8747fce04425c5cf319309f7007df5ab99326ca2a8226aeddec019af90c2aa3813aba57e0fc7152bb74cc7c7a2d2602afde5f2351f930860b6b0555bb0c9a9ba43bb8906bc7e257cba1b6e1967b832cb873297b40af8726c9a7dc46b5bf39bd60f8599a84eaefc4580f92ab4b009cd5092288a6f87d440703a896eb02b44140eea33559c5fbf7dde92e193352c773f1c706c51c0035546cbcbd4693177c40aacd78bb32b0e0327c8ab4773b6723dc3d9f2080621727535b114d8b06d03772c2e4f9142cec311f13058e2bea1e047e9ef37fc62b95eb5641fa8bca6158b627d883006aac890e8fa303b6049b08f9737e4d629572f39fba51cdde05c4dc779b190f1cc75ca09f01bb680cfcb3a516426de083bfcf865fd04018ac4fb8ff7b6e6a2f82885498f1669e9456bb14ceb561f54d8ba0f93c6e9d66d65976813c98c019ff40ea5c624ac0ac1d78e9fc56f863adc4c3bcf5211b9f24a63518967daa7c781d3d30dc799d99d97992729475b6faf8e55ffdd5226be29f3b33bfbb619981d226c56f542dc68b1568e52296f0e82780059704f583a3fd959c7ab0243034695b81330bbbbc5df186082c5f255074b566c6143f45e39b087c6a8eb6ddb5852730a0582beaeea021ab1612136d62e200ccde9eeeaef2268eada156528d723b80975c9113d40b80b27d64473a954a30c2d677331f60f3b46fd3d6f7bcb6d6dc7b44759ba1545c58151e32f6322db78df87aea8aaae77ac66175180f4c516aed56bcec62bcce2454d9c6ea8e6a8934183a6e626dd058085ea4fca46542c15e470b649caa27bf406b1ce8da23ddd50f5b74399959335b42ffdd7146b5cc2b9806be776ffa40dca8c5ff93c0b4627ea120646c06d2db93575a23576d4fb3072871a36da3fe8581b4f3ef1f9305c76801f96e575d7cec49dd12d129dd191a00192f8b48a0453688f87a055cdef2f6998ce2fc0c1de5693bc2d3ccece089bcd38803c2b0f47ee49a14251df7b6644eaa0794dd1684e9ef169e56d65787633ddea939fb9c4fca0160cef8fc3350d2d14e206e58e219b1a33c82895f9a813b404694bca22e19473331944cc171fe63450ceee2b6fa2f408e8575d80e778bdba34556990ac189319d9d60cdaab97fc1c91ee4806e1203fd4300d288a6a3c47d75337dc552138e59359439f88a2ceb729df48d6b7fa3bf2df84e0babbdaeece043b54bc0c43e49c688d651c51b98e91d2ebe6d32d44a6c89f50565a1d8a13e72a151b7d7eb7baae0911e851ac4c958f2a67ade18b1ef5f88efb2512ac830970ce9f1881fcce7443e37fe1f61d430188dbf787060b31b127dbef6ccb2bf5b1440d21d89e540af7391be973971ae23e78496c5144084f5d4a156cc24d4e7c3e40138fea328bb1696e2812fc1900acf9108f8d5c9a228fc4f34f99b5e4ae6996ee238d312011fb0eee02d166b0d94078c09befb0462d84ce46d038e3116d13ca010961344366b1e0b8643bf8d228a31341e05989338a77cbef16a06e17ce1c8145188dca1d8bd9ec3575efdb8e2014c2a7f10be8c8a4cc880dd9837fcd32bf0a337b6455f726873bb18f082d2dbed7f10caf45667546deeda3fa254d63c7e4324890acae3901f591edc29ff343ddc9c85f319fcccf1af4555f5cbba4f0baccd7f16b303184fc6267853e3905d1ee66ff9434945a4c64ee058e0ad60b71348be8880d94390562909814d959e99e624b3b166a4cf583c0a0c5cea2e9fa230014f07c244227de8274a22fe755554bef52d0f8bdb562573da04cdbcf873f4ec0f9a6038d60ff624ebe91407b9b3c452e69cb889250831e18798b39e2afead9f0cf2078e9f30137f31492a7e4477e96a90bab3a16588450956f9806631ad50927fad7031681f59644330be195a54e79c36c7b5047feac771d1df4d958a83f829dd9b4c630a7368c4388632745011998c07a40e372636acaa834af64d7e33b741c68b73165c5597c4dd9052d2a8a53466f9f36980c2be7ed2ffb195ac3087badc843fbf49e6f39ebcd184a348efd837f521983318b11f25e6d0dd4c32662ed16b7e3956465d5ca8301f93eca537775d76ae87377856c41263cad328156fad4b5c243a378fa31f6c26967c066b6a066d1bd5fcb312322423bb9cec3b254076364436d78ed3aade9ea56dd38f97a4e2b73364aca8e1f3ea83a1aa8ab507dd205e4a9f81c0ebd9106996070b503d0ddef356b9b82bbdcc4a978e299dfff3348259ae80acf431c25dd7be72145eef64e4c28bf9df2d2deb1975c19d3d2768734443b9d70412eb0fc1f6bd9e6affd9f4feb22cade105a11aa9fc6b187b40f9ab979966ebd4f9a30818e1332b17ec934bf2bb617ded03b1b4fec65a6e7ad45571da228b5a9f203e88091219403e870fea0102a9c29f13837ebe87f853592b93709fc5a545fc78e01c7a5c95fe37e7af46c51c0844250b2c2331a5510c1d1931e7125e2377584736cf351dcbdab887b074b63ce4df5e58d1720d7a67bcdaa88ade590833830d6dd4f733e4e281665de7661127799262a6d3430eba8985736a4e945bbe4caea5a6cb7e818efac936ffa49b7e87ab57a35a65545debc8ca4abd92f41c467262db2730c8c35cfe4a7ed1f1bc0b345fcf490bc5ffdca99bc088af41370bcc48fb721c392833d442978c4481537073a66e36378e3848716e9fc8b6eeebc410635a18f4010689954804f2f24fb54701572342da9bcb85d65e5d3c545ae4d9632e5b4de580010e2ea0f5b76badb26fcc041eec0f131b74d9e232f88d9491566d0b5e395e95c3e51581d61288b2fb71be09c7ea553f41b57df72cf93de8a11ab1fe9e8d02aee30a97d186055cb70a2ce47801bcc090e43d7ceff0d35739ebec1a088625c590f79da47ca48dddd3a45b99f6f1364a0bb3cb68cb26f737834f13b2338ce01b86de058c95b90ef999e0a4820a8401a43496670f4f16aa2fc41d3df67f2643e3f1906232cdd83acce3cf42c5573ed3d12cac68484ffeaae148404f4402a6acfa29c901fb0f9a2c07221dd89f601dbf37365cbaf3c02250eb44f9fdb5c7c84a8b2fd999ad75d579a9dd2a4b4b591c564a9914dcca41969191001984cd5114fb865252dec99d4b39fcad4133a4cd34ceca1bb5451899fed6c9335913a7f0f56900a84b946c6d1153052ea7cd316dcaf00d67dd35bc8930a21ed29130a2df040a76067b2e85e9ec89b182e59c29337e3333de7887b14829925d46abfd31c6888a723e5e7b7ebede00b35efd749092d5790e1ba7b573d3481422db115cb46fd4c4a95322771ec3952f843d36385a1c222e7de347e2361de5335a3983a87fe0a0f0295a911bd1ea8270f5b2ca3638a6bba8e3caa0ed5fb55d5cca772a462919b268f586f9cd286fb585823e12451d36e4ddd2960bb21d5c2a7e57ef708ac149415f0b92d0f126e43839c04800ba0b94cb40994981337f9fe801e64e69e12f6b0b9a775124e46d2be0d5687cde5cbc644c58a7c56b07ef8438589cb59a3deef6cf4e6dae657d810cd9d9dd399bc5a4e2481022c28f197f1c1606783e867dfea90c1893d67d3747e441d02c1cfa1905d6d0d8049370ca768cabb04f7bbebb3bbe67dca89a0a77164a7091756477eeb48de5b83be9c206cae25a6571560cbae73d8b8d4931c4adffbef9d74dd334c60a766adda80372cb1164a05b03dbfac5faa75ae0bf732e3a70569bafc6a1b0f4246119f928e0383cf87caa3deeac876f9e74c1d74b79b47aca5d9cfbd819245e1bb409bbab456a6d7ae71f93870b1f8e8639da5d3f930b64f6f114da8b3b43949848f6ecfa80373847093301d92b0267cfec18895dbc078c0d8d90a2dbdb0ab027318b6c1867fe0694f173f3de88f16f4a897a337407cfd65109e17203e5f2bcc47c7b0ab776c5dd33e87c941f093ab97540d35ea9a0252e4d3c783e173cb89410ae073da3ac9fe901e7a5153366b16c373756f2b379870af6da11b9e32e2e4be5436fc8912ca36b51d063aa77324d155fe187b9d90a38e7b3151af314f614a8ac4da62187ce7b80747d8e4333b26ed209ed7cd8a01032ebdf5c57f2faf514108e6526dc81d27cf2a7694c0913f127453b2a791279d1fff49e8fb2997324774f61c19b7ec6ce0b168227f4bfb090eec904c04e60b34fece5e57ccf8a69dddcb8a9bd5ba75eda4a6738d63e52e41af3c5299eca1f54ffe59f848974ddff0d25db754ef874b7bb1e49ceaa9285a6f9eedd0ebcf6ee03b720ebe4946f2452d84d596bd3d4b60b421c1b97f50fdbc0ba89d388fb3f43ff6fcb0124d8a8d067708ba995deed0bf90b1d56946de74bce50ad4c140d04259672958a11e62fa68dc37b0c0982df79d75d55856d62f1497737eef5e5139a3f25c7208203f85d4717a9060cc64083024962209b025495c3bb436d94de65529420fd52f19eeca064f735a07acb33b51621cdda0bb9521445538ff33c575e37efb548f2534129b7420f2ae2123785bef4ab561e40ed177c0f8a6c3248cebba216ca1ef65e46d11b70af44a6f0861ae19f966ae0cb2f85ecf1dd52a2f5c73e4bd52c6ebdae75155af673dfa3195fd4f6d28977e507c1a62046cd24ed903b4f835fb84066b6a623eac4bda80b66eaa1c4c6dbaa554d1e3dc3afcd786261fdc95bf50b65272188030df1c2108582f881071ec5ad649203f616a7312d4f08b9fcb6ac30f1f8153df421431a73e6a8c24933661307898643ae9d4f7d6e674fda1ba908a3f726600174e61f62dcb2a65dca6bf98c970943a69f2b99e563ed4c70d8fe5af406204b9a0059b645a29ee6f92cb0c790a6cc61aab9ff41b7dbdfe94254d36da446dcbb4bf75b1b5ac073ca3a94bb6d420207c1084536b97c3ca1b1399c53592f2e972e4c8de8fabaf8519348a13d8f796eccf562a6f3de13be9e3e70c7d9c4bcf45887f72ecf4e198c60e5154e99381e50fc3d3cf63af610eef9f892acda1376366f9f99b5e267a121c4ba2f2c1e5e851a46a1637ce6fcf74bebea5e52680a4498497feada7c1bb9791b8fb51c2a799a61ac5e4a63efd2bcd8b50536a46060a8b84a41c3db57650f1a5a237edc93101b26d695888a1b357f5e3777de599e298b7417075702741feefd101c07834c56f18106823b4d1757e40fb56a3dfb9520aa12050ad063cc8fbe55351f28eaad75d28a0bd47187d41c032d281ca9fcbf29aa839d1ef11e756d8d2dabd594c515c2d1110997b765ce04475a39b9126d1b93878e2e91e821513b64f2e299e319f03f4ab85598095697905b62a318249d087ac90b27fb59563dc91ac301b4dcf648be0ef29a192ac77f410cbe5421f4a663569d94322498431b055652b3aa55ade6b57315b50cdfa5f01007af318f5d10538f6aa9e229712267ac87fa324ebb14e24a0b1856c6eb696eb873911dafa29aea170287082831f1fd4401a665c676ddad4070566c652ba5d9736a09209fd4d21293d170ab7a9e87b1b9b2e3d767db033edb348e35b5bbcbd6ef31d8f1dc130dd19c2464b0477a3ac1418a3434c3de0289732478f81b6c401ff4a080c8731e00e9c39297a87f2e6c0d20df5671416b1271ca324dedd1258e4483409ee1e6c7fc275c82949c93f8cac319df480e86c3515681cbc781a1ff673b18e7d4f22a13a49cdbe176cdc51594947b5485c8fe197cab308d736b12ead685cc6bc30bde3e212cb5f326fbe37fc9f8ec23aa87fff6c56b8afe7525df9bbbd0490c58015d104b024b069687c5fec0b6497eca497adde4ea1b99b3a9186fba34c9034a5bf4024003b2947c1a246540b62a40136c4e41e9f8e0f03a1c600b1b51604e4f63f6504e1188810dac0f1b6d9c6df80db92d0af2ca62f1fcbc245ce0b5468967a86a520c5e987ec4985d5d27d89b848f92641f9b36312c25e32a687031eef9a2cf415fadbf52e14b3802de9d8badce760ddc52563b2496ed4dc2421c127c2cc62531ad533c991535d57b8988773ce1799c6da331e3dfc5aac589149c9a6372212efe59d5616ed68efcbdcfd8da6ca57060fa1500ccfba1b5194b3e4ff4d2bc0b52795cbc244dbc8d8b629caeec4139173a47113c26be5a046d45b84e9c636951dd0b7d74233ecd9b48977c0e98681937346a84d05fd5de674fb957ef098b76215bcbd8b46f4e116249154be5d8bf8878f45a0e933f75652f3ec303f792e81591d62f8a59c249ba46ee30a740913aceaa051120f9ca50dee742d18bb6323c9ee424b1120e52426d31ba756870a3ff7e34562fe262e343e4d01924c22bda9ed1be07e95c37068fd627297a2fde40f2bf4c39895248b9ec4cec7e947b7ea6a037dc02f203cfe22564de695f85142aecb6fe52eeaeda10c0ff9f5519109536bdab7ab1c0a419c0ec0f8b7bf37ec7e2f698f81122d166f46164e583076d0c288c2af9d305cb3be1e6aef97439925aa3f3612b2a6530812282d427957acec77f076b128d76453c412b1bbe7ff55614ceda5fc9644cc2b24e42bfa963342cba078a7d2c3a0e10c3d51d1f9994594699e6309eb7ea854086f3993873dde8ee6dde231976d04353721fe168fe824f98e58f21f6d2c59ee827def23559fb103fff9578fc810e613135921591961fbe7333559dad940e67fc25a729d822508556b7b3ecfc948c71dbf4f08a3e20c8e4e996bf2612ddc21f602a95cce480cddf5c5edbafe65c52492187867ab65f28f1ff57f27e1730df8c3e3e6ee160a9802a96e470725bfdc27b261480eccbe8416011ac10a2cfb48fdf3b9b21677363e60cea3f99e1c1523d516c86a73f31d00e50f673129801a82525df3ec4b002135b2f95a0d9f5d87fb5d38c497786f5a922bd0ac0acbec84dde9a19b4bc5ced1b0de29d4145a7a9a3a30da9a1a59b3f9cb890177ea3324dce4e0e59dd45838b5f2f13daf1e59cdea6fe6321e54a48b1e627f13fe43c6a675dc57dab50b044b5fea0df9ba65e6886cdd202b25b10e67d38f9b11d28ef5bbcdeeee1966e34cb82b09a3bf28b505148ead45453f0b51c4258f26668b31a500552a9c757f38d1af6fc96d3fac888292e892882c6256177341beb3b41aacf46c19f83940325be78213a6b1e39424371172d93505105bb2a109b5d5626616ac82c1ee7c90615bcac2f84903173f3ab2b6ac348c0776a7eb65d74f92f86d3ef5dbc2fbc04cf252ff7997109fa2763c88a78ba9a4e3c1d7d615aa65a35944729cc9a9732cbf805e57437dcaa5e835e3942b85409b06e1afa6309fd060e89bbdea2f1bffc08ae91603bdc3ad3d46f7335291ab4c23e00d4d1c9dc4d9ccd1748cb0f2e294d05ec260c82a7f05ee2ce41496b3c7919eec3f238946b09d92f8cd6f8302ab6b0653958a43b546aae5b5d416af9890b53a97308dc4bd84b047a77cf49c8b9ed9f6c489bb87cf9229b66dca3821e44ff2237c7112e7f1167056dd2aca6cf00bbeb72e08b4dbbce64a3f15d90a4e3c699541a3a71543793b641a3f5b4c7212b7d11e3713b6180436e1622ea9bbd87f21bbfaa14b9f879252769d451c7363f79cad326e4e6fd6fb264d027f655a8e5d3aceffe303485f73088cef9aa13be5cabd76f2ccd5e48fb883a7e417d604a0cfb1aeb8fa407f0c6bbb57e869396d86d0a11c6f88023bb2060826fe0a7f7db7d9f7950c76a6952955ca3585a8f7c3c9070f77f2b5ba374bf1b82865994e7d66c2fe195bbf7865223676a1000996f70deac6acc5d4a2f20b1b305bd8111065cd394e64892c7a86185c93a29960c6afad950c63b29ee97e961c17a824e3ba34fbdb669947baee99ba7fd404fbaab742d1620daa376513c3e788861df0dd044997e939592ef6ad6ef2ac871c3ee6e4ef8568569d1aacdb229fd0056bb65a195a555f4ca57120f742af87bf494b66e88248cb1d9f00bdca6eb185876382b869ac93ae22b2667da6d4301a5eea1e732d5eb42920bc019ed57582be5d6e29070871accecebc43c00c40a83b17e1e39510e8c63b3b4afe53c0977fd973ce03dfd92d55b83e604327dfb915af7601d343e6ec1a5c94e0fe511286a224f25d29b98e705a7ab3a5c5de69a5dc1a016266cc58240c344d1f7ba67047aff00354989d086fb1e65ea7397239f0c9036add806673fa9ef0413ff93028a63759f0c3fdd32b7ca767aeb10e29b1f527e2a8d5a8fcd8b9340dac437819f5c568d61dd0ea12cf9d289121a157e90d14ddbb51f3d23c4fb834fbcfc8bb590c4be52f51d89658f3895d7f6fdec0ac940fb67821a7283688a8a1cd9e8231a2dacb804ece39e04c409ad0d79a5b7e961cb49d258a79f3c3aafd8c0d44d95e28dea8ac19b166144589f656f86e8a1e2dcc0ad511108dcc01e948ad9c940ff5a5cc27ca085596e7ae9c627145a49904406128ee340b72e134e4cffe6b1ca94fc14edd7f877160e2833ade31192a595596cb9a55b06d2632fa190284837c7861ba45494383fed4d62f887661b936a27bbed3dc8ff5b67d09e21fad5032b2f0627babbb7a33b0b69d486a4cd510f71e0beb19ba6d5fe82def01b6230bfb20eb232f8b99f0287a7fbfa774fe1b9f0933fd20a170ea0e98ff14a3e0eca15295990a723433fc37d66c5b1f5f7c973f2e8a656a85f5e1149fbccc7e6bab34fca04298c5a4447d9fed6731eaaad4bc3434e0875201ee1e56fd015d931eede9cedf1c0f8e20bdd2dcf7cbeeea4a1cee0917855d6ce077185c7ca701c901ec8fc9c9939cc5d4372905e1682ee3bff9cf0d8193516fc6e215da485d7739a697dbb6ea72f5550cec1399e2a6aff3774467b5b473045800a750574bf87c893abf96ae81a734cd14a38c3fbff50040ccc99ba38ac48d5062e34f3ff878af4d6d19aef801dd917f888ec37d1b2ae1431e85b7617f9494a7973a29d7daed288dee39109918d83f3348439059d96c652daaea6fe8a8a969d2bce4a0dd811efd8ee338c18b93d555fa42f634ac43192806ae3669dda416b6ae657da2215ab8f5442e1e9e8e8340a84fbc827883c3e47337d5f5945aa6af0a08689ef763e75cdbe63c9a048ed24f92e801d87e33175a5a16474bab87344e4d2d8cf342169146baa9b7b7498112ef00cfc6708871dfa2ebee9d802217a1b5b5002dec8d439fbc50928a5eb12a89aa6ef15addd63cf5b59ced811cd1f11d05f59351a88da3eb9ea460bd142dc01b04fa8331a1b03a2ca804b62b4bce979c3fb4e0176579da6525c63900d0e919bad90233bfb96b6f9938a470982e3cd3b7315a2b561be435ea1c9a85829fc802a933421c6003f9f01a7f373ebec1de188337933de7dfb5dba31f2ef554ac88b6dd6de41349da21a2e03aac3875e04e9e50c0d4fc6a4bc85c40fbf70a8d551b184e8c157177e2f6fb5526bfd77b0019684faa186291d4f88ef2bb66b7826b79af2b4ca244f9f5e3ec4e65fe3b8582eaf2e27986ed5a3d4efe68d702b4843d13eba844e7f84007ac8decc7e7e0007d988943c5ee27e519fc2121a844636575a96513bfc93163ac20a8197a7fcd0ee750f6ecb03009e07cf085397a3da217cf2856274ecc849b246bb289e655b90f164e5d3edfdc35cf1b4eb66d7bf961a304316e7a449448bb882ce0a96b41209e32ee0e97bb97c8550ca028b2ccef8bf76de2d15cced71468ad917bd5fac28bb3a1ef54450137a2a815b94eea0a926b64730702b05ab7ce2a395edca0c0c1b10d4cd6f87788c1d6cdf4100bdde624f84cf3d1e9d61ae727d81856b305f5136a878f397e30101c916c2e2fd017091bff6c152357318085273c6bd3f84681e92b30d475d7d5efa290021b12eb088fbe5ad688031a3ac1e04ffe2def4eb1a42b8cbebbdda019446a7ceb8a01c6003b14b2f0390d99b310bd6a79ca3636d8208bb13dfc00d2e1b537cd941a6123fbe75ca547fc7a640c831cd8cbe17529dead1e86e29158b79329e82a489db8a2e8eff9ca2710f803ed195f5ee8c9a4afd6c47231085b7d2406128c150239ed29c71db30e56dfa16f51a1a7b058e11f78b05889f32b4dfa3df7dd826a248b3fe985bb90abf2f4c2061fc314050ea3394b65c4166e73fa3b80f1d364387fe061da65066d26ba7d6be5a63d5367b6ee08e30b0f46b37453ccc2ab4dc5fdd44943b816ee18939250ac3f1e36ab388c6889b57257a1360bcdc0fa0612e3d7ae40203166c3e733999d4098f55cf5e8ad4b5b91372603bbbe909032f4d1bd85a5dd58b52b89a69a0f370a2ebf8c29dbcb3cfcaf522144d75fbbe4b0d8b569a05feff044d1147d62a99dc8ffb0cc85b30a2742b2dd2ad5885a46bed20182c25154bfc27ffa6f259bf0ac15a1cf3b453529786518c94d934b45572d7e94812f4dc38ead521552ec87e8b0dd12c73d09167c2ff9ec1031e2f48426b4121e6c9693c5fc7f59d0496c7e780ff3fc7e9d640a11641c7f50eded65a8f66a72837e3dfeae41734a22050e01b8147f8071dba07627cf5c1267e7c6ef440cbbf3dbea9749b25426a91251436c5d57cf5209f4e1cd2bef81a38de26278755618872b92ec37983f735652bcb041903e144c93e405cb31b04a4837798603db7f050b52e9bcb547e673646a48e172650b9fa62c91d710e83132fdd42c0e2cc9b17b3917a5c394e41e8c28d235acb7e1e82ee1e8328e2fa737b800faaba3d8dab95a43784d8ac6202587daa49704c4ad9f449b567addce1bed70f5e4e22aa3a69de263106fc2883f0af20fd7d373bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
