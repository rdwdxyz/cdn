<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12b1a7fcbd1b0314a5ca7cfbef2ad7a84a9b7850f6d2deaff25c258c6f2113db0aed991d38cf161cee4afd80dc563e3f69db8e364ef3987eb02585dbafe5118271877a8f823844b2f0b00c6b36cffa84816db60101195c27bf6196aabe990940fda05337d9ca11d2cb0d5084b22524531fe73db8c5a08252da7b7c61b8cc1842f9c81a09e705e83f070b1466d342adb0357f744bfb9bdf121b688e3ffffda538173e5624586ad99d6bf53eff08c4a183b7288e1de3b5d64b26ba29bf3f2ff5a6c476c9aacb72fdd105922501ee2b32f27f7e9932ba40ff21edf9a979dfabdaa151ae70f1016a2c8b5e35496104d1c6373a6e50a6c6694b7752a3e75edd146b52e8a3a73290130a156a2f114453d1bb97f6da20577a2f16ef82e055ebe3d11e53dd1bed1fbcb8b388084fa4d7e047ccd4914ae7fffadd58e5c2de19c202f64f03888cf20f2f45f361cc7a3e8258659f8bbf107cde958ff766ea4d727459840593645a1057aed83c31e8f03b7660171c35ba66d82035db83a8fe90ea2556aa198b7411495628b19afa7731d34ee0320d610cb2950107e3995d17f069c24b9096a4d2ad70e52af7dddeaf48640514feb06bf9e54394c08fe526fa49ef8fc0a6ad3b4eb39a004d033b068997f69fc50de7f3c7167fa4fb9eae44b24418e3893b12963af9b5d1fdf1da7f711f66d65638b1a0019621589dc4351fe0a0c8f168a5243dc5d6cfc589bff2d9bae17b429ecd33e0a8ddca815014b4fa963f270ed55b8cb51e658ad9180c3030930b0fee27f2be208e10ba8940e717f05282eb04053fd7c7c0c519d5769308bb0728635ab0fcefdf37ff1c8f028b5f5bca2a6b02c69f60f4fd267a6aa49e3390d63cdf41056d7cd320bd2e79a72a6922ceace4804ecbb16815af8157e46bc3f7562d4bb39f1df29f35205c05a275f607a9b141c73bee5f08d5bdc693664b2bf2f743625e2db225141c8e4af7e0d02f8a64352a0274e5360368fc413153dd8525ff5347ca28b413492e3d47eea4991e391630922cc015cf29572bd80b7a9cb3dd29967c82d22243fcc4bac6c9b58f2add9496ff3bd618d1bf6d32496113c8178c90a8ac6bb07a2f7f23bdc45f810474f4d5786c9fff78069f7e57e6d68d927389fdc0ccbcfd7a163e4db0af7a70d5e32ca7d3c549f35537a3990492e03aaf220747fd96ff348e9bb62e0e5df517830be261237469ec5265582c648382c6017ab81d674514e4ebdbf44985f6d0ac7ad4306ff6fddc20c284b65f718c2d1079499974cbecf1c20c2c100a0679fd8aa28e6cfec02a969fbb4da4c0919aa458c0aee84f5cce32849870d5e0745ed85c37d09b780f9a1ad12d8489c10b58e3daad8405dc4523783cf0a092f3d48282b4ea0ceda515cc955090abb535ecfb2382dec11e31143116adfa2e5919d968b733bc2371548abd2c95f4c836a5eedf9457f4d3ce7f34a320373f51efd9387811529f8eb998d557149b38d91f5a60f6b9c5a9f994dd587ee09f4db11b580d454cf55f5ac68a51bd6038a1551da88a53020e33be2b6ffc56eb5f298f79bab6ac90b596f3311d411a0f97ace68f95aa1ecb75c9103c573c85c3f16c0d75b78236cc201e6b6e9941a68b1f599965cf5928bb6579804c50888506e26ecdf53d2848b43f2febe6955a3a1b135d5d6854db5479cc7d78b9983847c1f4afcff0d1d2239eabed4d9c614c0975f368396e230a6ecffd4ab11e74d7a34a81a14538a9f8edb2acdc3f2beb95c53b90888dc1ff41662d104b0eaeab2a5e08e8ec6a02ce4fc56bfd2b017b6cc7a2a8415efa7e09b6a405ed862f5a70f8eea373f3c36a427e23be9b7818dbd3ea171e862caffe27c87ad76faf2c18fa6008f9f5c320510e99f91695e15c3ad08b916d1676433a62cbd9696b7164574582052fb81a59434585d9333eeb415e4e9f28a4e37ec7db3ad1a5adb2ac9fd68594575f033e934e3c91344aa1fb53cf33cf33817f1db85d24cc0acb73446e6b4485aec6e308910df4b2d5c5a378ccd6f3d4f0bfccfa9e663314a6edad3039188837fb7289b4c09587d52dd091b6d5723e4caed9f581550f41972d9e3b5d857e80c615d604ba03fa38b5ffc58ca49df91b70168e053ee40ee50661ce451a914b004e607147f17703cb09466948d933efee15c965ec8a870940361e461474cebc8e2202ffec1027ae764130a7df2bde1f61ea99e67ea4913ded4730a5494b053a8a5ed89e0a57cbc42d6701bb43dbade9463e45aedfb89d729c49f6f614b6c8012de9af550322541c23bc2e7286e0ce148bd4f775ce77641a9a8032f23763045b2fc40ba8168c618ed649a4029fb7ca299a7ee02c04ab606a36cc79cddf4ce322170cbd59dbe74ea94d4d011973e294b315394f67aca2fed3d5de4d71133371889a044100251cfe1ba51475988cd0f425e4d1a19b23ee7285b55b2e9be5fa9f4860e4e99f7d6cf07d0db4905c0f8ff9da3b7724bc8b393570c99d4631f320ab7d4463bb7cdc6437ca171ed6b5e5b09c04de3a14807546e967f3302ec7ba8ec43d6b89851cb1b1cb2a2d19e73d98b6dd353e8f052a5418e640a7bb1c24af334042fc3c897726789b0e20397f3b1de0dd450387490e2941683ceed0bd17974071e559d377b2137982d97be282a21594d6cb585505d0ad7c40179169b8cc1fa63c02c2a665c5f60b5a011401d679c6a31282269ab4d28433daa230a3a7f000034a673fbaff2097a982519497b409e76b842b1b310b63963c625a1de1c572fc10740615111c9c6a8da7ffdfac0a1b64b558e8393b2756e5b097ad37b14a57c7df87927b858aba5f2d3bbc5afd5b9331f941a5bbfa143c947118625ec080667d8869907000833d14097e2123c11cbcb0c0ffb1b2646c5d5440d233172d8c1ad96c4b403cbe742e30ac4228c666053498709347c79b31038306d299ed5b6e6f77b9dc0cfbcafe60a3ce66078bb9403a533f0879738de78622d75d7f7110614c0823979b3516994f6357e6983c2c8a1958f092e012476e40c588f4630dfc5b75c082ae1679a3fe7ccf6ed439ed8e477503b16a361bc36d6ec9a0d56507f2fe857d7cb9a3a5dd0cdf0da03bb04e67f68a345bd27001d64b603b4ead21faa5668d119c38e70bd2ef6a12a93f5e69f8dfa1d914d6642498941e38e6a512bb15ca22e3aae23bc5205d1a9a2d541eac175fb1708b32a81dcfcf9970d9ce438480987b2928f6ef66a911f98754d2f71ae495719aa9b0213fd605ba7f1f1be1e1a3827baf7d84886ddb91ea009a9284869e3ae9a7d897257b8b65319c6e1e6282da26f96a224a15d39dc035fc0c8ac87b931c1668d1ba25274eefdd430c4c1010eb41ef19e2d52c0f8961229e95b160a21b52d8a69b42c06c397bade109050cdf4904ec642e4dc2c5c736ce7e0704c4757c877545c00da507f9ca142160a57234395674d855e3ba36238257fd66f4da4e52ba2b7fb6d61208c1922c007e79c29d163562f4fe3273ca06264364599902949d8762a1a181e576dcfa5e9e140b637f647b9765c7c107f185663d8cf7cfcaab705d74aec72513e2ff52c9eac1dbb1307863c83328c1677448d5a6ac38c8d8c7c16b4cc7780c8564410b32f77ea79dcd7ca2a4624a58b846412afa86c9daf54128f3478e8eb018485e22ac2e690b76598e1556c618ca1ae8a4a5ddc7fd65609451bbc943522816208486ad73ae11c0d7981c045734fc0ef59830231a6962d6ad4a9f19d19bd5b1f628d6e5f1b66da6eb107c0f92a4bbc27fedb092ab880017acf80e929d34b35a5d09e12758ffa22d4f4e08137956064a2f5f99f9ec6c11cf22e4702dc8c26f0de7a0fe3c3de2b9caff4919d244b960e011619e308146c9bd0503b9d07239d52e70f0ed1e57de65ebe8e55048dcffa8940fbfa2117f44f449320766efe05f804c727c3f63ee40addb57b0675466671bf6cd1063c19a7636c0e0e52589856354a3e71faf1fcac45f26a33774bb4f82e67ef9b729fecce0e7a2903b930b3152ac181010a5f14af481d03a553fd90da384e9cf9be86022d161d30f0079fdd03a5dc958f25a4fd6dde0a2eeaf35925cea4f8ebbb1006c8da70ffced94de7afcc55a226070cd7b7b3ba9211d37b0e58b2524f870e3a5c8ccf9eecea91e191dac4df750711036ec7cbb64f27dc22b8b8b9b44cc50c1199401f3d8a2a7859f20854cb8d4dec233c67ec09a1003aa40c376f9c8a459e5a65d4231d425d40486529167e98f779a9ffebeff2423cbcf81a546ead7118ebfd8fc2e113f4d53d11c79007f2b798dfe5a1fe3dc986e04c40ccb454dade2005c5b01d0a7282f08f8cc10cae7472f7ef0c8c25a39b2c8e83e16d39c3342124f6e2406a7b48d70751b6e6fdb80c870a3339a5c41eacc88c5d964cf951aff5a8d4bcd31d842f7bab7880b35e5c8d508dce960a29555e83b8988098742fd9eb342a380c171e9b74598d0577e1600a39eada9117c38142b0bee2253da74d14c08ffaf3ef7420fc8237f91fdd50a7e93678d13dd18d7580731e508ba4686e99c53c58f5d4721cf1fba091f17b5bcdbe9c3e7effb723210192d28e007bde8cc2123ef2db09d930a12dd0836527aa1179fd81fee0f8df0feee005631da385b509090d520e0618f3293205ca6153b4def4d5dd69084d27d49daf4a527f2b99ff59055b622dfe40869b3f8061fd9c744cf146398fcb6eff13b898485947d814fe3ae2243f9870862972ecf89399c5a6a4abb84f28189e28abfe6377ca67668b217f00fd5839b23cec9aa174cdb426693a8e407528270f3b218cee347cd404d4a71e0725383365ea9f749368acf0fb15a2da3833853d2a34268529910d5091934c28938561f7928b0a1d1f27125318be0f03e471a0efbde110ac02bab535d4285b259dd46297f9689c42dd88371eacc4b813f1004bb13c041bc1b66581bc1fc46aa5dfbd2cf6010971279a2d71e1460e217d42a2e4725f19ec7450e51e1559cd2e238f71e441032458757ee0fab4ef8242af4128faad4bb9d43e61e8af32adb60bbddf38ff4df57b07db21eae6807a391e5a7edfab5ab36047e2e5e6668df69d9e3cbe8ad97453ce54a6c4559a432a26bae62a0e82418165f7046a66c579a1eb02fe08e0d4d91bb6b656740a4ea78465d65823b8c6e9b739d4658434b5b6d593152ddfb87e4e996da53047ddc19dc1474ddacf5a5776d4890812973b5d3f39e4ff5c40fd0ae054414b9073d3d687a55aaf43a67af52d8312619754413ef05c5ceea7c6ff29e1e97ea5c535219bffea5430343551b755eb68344285c317e53a170f9249d2cab377101ecf3fdd6fe97dc9582cd6e8fcf8c4739ac69b487c0421a116b0b1454a5fd3bc3aaf0ea2fd0fd63d5966da6d64426610abff56d7149098d8a3e021c42a7da57b599e56f9e6b40739eb792237e6e631ff826febcd1de04627dc74499a34ff8f31b888f304b739489279f126aaf025d3bd5b0f2d2d9e1140b9c591810526e508c7706bc894a5a3cce11f444fdebbde54bd298767826bb05d54be4343cb6b8dfd12aa9c0d39dd3548c4d31f6b575a7c0830e86a758e1ef8caf0cc4f3ba586d2af7436019d7684641873a17b93dbe147a8211839cc0709fa1fa1d63f01461fabceb15e77c19a38f7b3dfdf66f18746e629f20f2a7e32c519ae34213dfa3cbde86c1c14d10356e1932bee5b4073ae30faa352a7251e415141b2afb5c1e6c207efd50d37175c6cf1486b5909856406036217229ba0a67c4ab3863ffadf5dd7fe13349cf872df7529d92fd01ce345d04d4d0faf78e136acef6188d0a17a6afa2c371afc94a5b022ec9fd32222de8fd430d4bc53d847989eee701e7c42563c24cdcf5d526f4fd140f089216945aa5e086753cf7d60d3b8badbad4afecd56024df5a751af2c6404c88d5d170559d2b2896481cae4fd4d3b08eb484cf9bdf1565cb421bf1a14e0c5e934ae670526f26afac5f9352adc76f6f735a3874ab422c4967db6cb4467d20f4b231467be50c07ce63b3190e821e3b9af2d504f5189e1fcf7ce56c35e45415cbaa96e6b4b6800f62287a18dcf9932e2c96e05e41c2f76947628175ded2865619128ba3f5b83d5494c7f003a1b7722ea3619c0be946871a6f7d001d5dd17a7ffef497b5bf382b5e9527cde57d0426ccfb07588e3bde3d0aca5ab1935a87f19094ad14e403998dad6f6bc8217042aad9667bf6538d059e6cb2e564d6a884b3278a88300e237ae3f64fc0a9f1c89dea8da65a3cab512319f185cf2d652b5a5865eef8dc96d05b4a9d86c7637627ac1679d11e13e931b27673333e5b2f0a734691dd8cf0708eb2a8ac63aba386f7dd2cb6fb5d49b162459fb1ccf17c35262bb6d9a3b9c41e6b8d8b7e3234bd558090dfcc152bcd294c554323c059684d04bfbc4b9249ac1ed4b39fcd5e6da41ac86e6257437e5a7e6c00e8485a0d04e65742f8ac553c3da93b62c594f0c3bc49a312cb918bff3c55fb6574b4011c39ce823f97a4d8b7488f4304c62902b7a162a1de8e32073ad3838fcf50c53e79196837b8800390e68ea584bb6fe165b939fba2309b8e7ecf27704bcdef3591353b0c642dd3985bd687a874a5658ee707db3f7f9e82edfc87691f1fb5f70693e21bd8307365f4c1f8e84261619b33ab6fbddeabdcf767ac3c2a6b4d5c65b9fb06057eea5fc9470d49de37f5f6f4f84e737922c14288b28eaa163a7b89f766546873adf7535264f08184c3930f1b4fda9e469634b99157b18854d537925f350c106e17c6d04b44d272824db0a5a7812cf908a926b5b9b05447d39976d9e572293c17458331aac2a14d71ab91a63bc7b44e73190267d2b743f24954b0de1c3144a0ccaea159bea4c43699556cc3b7ad49a2d3bc564073613834196bd9e432bf3f98352bd09cf2bc2dea52ac29cd4293e1233d41e19c0aac334fc4b3a50f07267d5daf0f99eb0fff5c9cd0d503ca8aa1f2f170357ac17f3b6b81ba5de1a1acc175c3550934ffc4314cbb05c8998773cc6cbcd552df07fb5c41573437e57a0fcff2ce4ede48d32c18a474a9b0bd33f418da00010fad07138c9aae948981bba664220c5581390b0ed1fd2324418d86197d505627c273c4f08d3fbbbd2a4435145512dc20ae092213f764a96a07356c39030e7c87bf9dcf490b9dc65f6b841e67ff388d7e6384703b97027611ef666d4427c4cdc76b27ba7b951c1c2c0335a0317505d1be679300daebd1344fd1e48b6034ea24a368d7c8035af13c30258d8521ca75a9a439290379fc1441dee626e1c312376b7014dcd373b6a6d2cfc53021a808d0bd81577754c6b6fd5da006f3502b1267b260358eb55f526ff0604f0e32603773b2d826c432d824e711ca5db520f66bc500883f99008a33f76033dfbe7b88bcef22dbbaf1f744b038f321f6fc4c53b1eaaf38abf80c15f3296797489f1b11ba08cd6b898c677520083cd5f95db1025fef116e67234ad7b27523412aea7ced54b20551952b574a927a665d83196c25e7322df89fd32cfb35179ebec728352fdbf94920e15dcc34ef63bd47a8e83ad8086ec09aad9bcc90e7028c59054c058ef82430b1b85953037101d8a93fc9d2039cb5dc750438c2b00dd3e45cb3d14ea6002c45dd7aec93fb570db8956c31369b383f7ff848ad23e953795df7b66c4d7b4ae4f319f1c0e6561e2ec851e6afe6cf42dfb998e6684af90e4b59b0bd181251a6db1ab76cacf273485afa232d11ca4bb808bbe0c4aea34b6be186b33316a361747498a20b463b72ec18eb2ae41cd60cc403c104a51bad98d1254911a5c9d6f65c9ed0f5b0a1ff673c2e07d9cf07193596900b3b3da980d47b4f5a8097ca1f3bf71767248855b74cf5c9361e38ff297b450a1a7468f106f4e2838da0a4cd0f225a7e45ab0332987d15532b8d3668602fedadba436228a93c22623da554594d01fe605be734472eea27f69163556ba9bec40725009c9748c9e7381241e61699b1d07aaba1f79be02b10ef60e0a119fa31d7088a82df3797e81b316f39d1b91e012504d85dabe8f5ea277f2365c7152c56db2725f5fbbc241e09e7110008f9dd8a082d7dad90eb2ab5eebe3647e092d24c245b558e3baa55a120e9299e01b6680dbe45809031b6819f045f37d8d8d6938bf477503cb944b9ebf9da1a5f3997697f5ddd9deef1a21c0f7009aeccab7368731e78bc1771d399b409e16202044dbcaecb1dc00b8d6c9b200bd190c0964f3af9a8d7c886a14e626d27cfb7f9e60bf204807cf2cc5cc7e58104ecb7e86d0305672448780b3dba268340475004492e5ddd7982962208873678fa90964ad749571f58364fb0617b2c2af75ab75b73cf772f4fa79b149ca739857c69c10e313df6905aba2dcc454af183a1c3d5febc1bcf4f17ce13d0abef8516d8995457cd3717c13c731d09029992f91a6fc2b916dd93c0b87aa9408cc7a5c042f5345895e28335a14e4a60571f68dea87995020ed2674d7dd2d9b292aca54de80049e0d7ebe8af54a4065fbaa06199022fef64bf37653c269761fed3110217a3e8be124c9979fc037944f1458fe9fe758c8917cd5f227f6b85eacff7ee99277f48645c7c79b25e8c3f964c6d17cdfd647d923991e414846eb586a3ad00b4e519f975c3d8ba3827edd4dc1165160d5421defd9accc012a93a0a441240d9fc6756de2b86e05449945aba3cd03704e138bc08bbd7fb60899c218bc6ac3e8ae0054545a40d5c33b55abe3ecf16a28570875e56d2b549f20be1dc6c9c95df56215381326af30540a61e9be693da02f57bd2ac011b05bbf5f552e6f7176cf6b8ef26d87bc9363c06ea4baa8a3ae249fa8eb1031024e76bbcd1974f123ff2f3ffb5135ad41679f234750da4ea44b490610fd2668fc458207f1da6fdc15d861c33aa7af325e3a572b7515ecdf260e734f8d7eb2d0ab77dadb7e91cc512ed79687f1faefdb9614416d5f65341af07fda846459704845982174a35a087ad56d169a40d03a0cac9366df50c5bef9f47e0fa59a6d5c5af5e7e57c541f4e78354e9aec9073773edc54ee7e4bbe880ec0e2d6d44f8d234105f5f2b2ae77e19bfeb964f917437fb8cc6d59d7b24643e02acafc32e24dd87cd149203bfb47ee3394b73b7de4aa8e25cc0ee7b91e9a0beb07543615d48cae9ab5620c9c11a37e524b017f48bcc468588c880d1a2ea16e82f7811d328c4630dffcfcb52745bede3a062b0e8a35b70037caa2699ed69ecc4a6e724145bf23454b5ce395797555c8b21eab8f3c4d136afeb904fe23e0a1574dfddb3615f550804b3531589bbac14fe2f1b900691ee14abfe10a05cc94132498fd9e0e8826b2b8948488781e3366790316d20669a0d1ddd16f47441563da8863141f77b21b455fb146d071f0ff139bd2bcea639f3ee28c7feec72f9f41614243f385fd878571a42236f859b14f02c80a20b911c55e00f641a66697ffc67129c17cb8704b2debf59dbb3bac99ef88ba9a35470ef95c4bdc9938d16fd2f654c90dce37866a880f6cb07b12d76cf693d9851d392e764ddefad82d1ac93e955bb2b730084ceaa7945fb4eb7b7c2d61072653f6798689092eb1695d2f02691c5750b5ee495d2359e0e84dc60c50c697efbcb62d29f013c8e273d3f96ad61624059505a8e13bbbfddd39c39ffbbaaaea2ce666d3f7441b74b023da6f1d549ae6a8ce53133eda541d810bdc57b92691da464b5c648ca5b3f0422d11b17bb19e32d62f04ce7b4cfda42c944f4a050314a18e07ebcd552962151bb23e545ff649e544c331bc0265ce1e43ea0b403d228125225ac0aa510e5208bde7e6fc28c06daff016e09dfebc857ceea7611c0802063622b5257480add6a995f9f7d47f231ea8fcd7b99d51ab1f8254ea28ae0934f1bad36c04cf1195a133386d61667d2f25536635b5ec9932cf7ee1f653bed9da3bcff6e4c9b9b4d4cfd1b1e6a0f55d032c4149ca4354415fe69c6114a3c67bad9105a59b7324485a6d3cae94f09d3fdc9c5b5cc779d7ece0007f9859cdde373bf4a630c73489f548183246704b0ac390db12445f465ea21fb043f5a93c5a0e0f902b27413b966cc8a0c2d73fedc71499dbf3610cfeb4c522c9745cdce393ce8ed901b94f534eff644d5ad4801a89998036edb67d68050b8d96bbb7d7d95c220b3095b27d529bcf41729e4709a0e4b398e2ad4b4c4b4f755c2e2aba1a02d07b775cc07c5b8b09d75712eb0b501a3622620fa54d9444edf72c3da0d772aad9974a28cb737802355d1044e5e9ddcfeb3feff80196d60f2fcd1e0a7ff6468f0f07cbf84bd8a9db08bbecde87fb2b5a3d0ef74c1c85ae22004c0a52685fb1bd4cae17bc46471ce64eae55a99761f3f7beb36d7d8502396b382b0c869e4b736a04a6198c57f20b20b9d89bf1f70d7c4dd0cbc2651af83707d425cd6d26531efcd96b555448aba9dace3c93308a1215d0f37891c6f6853bad3c5b74e1f507beca4f1ccb561dc0c3c7e588c80110074ba47b281e73723cf903506a36aed42615aababba8390b10998e95500fe69e5d12ef8622f4735c842ae685f1c083e3975e83c362b3f1158e683d541387154cf503d936382176d183167662e02f4236b16e1e2a49e1f3d2d8fc12696d2e6baa72e948e2bb4296ba18c8c867906801f08610bad61495e132a0502e51b020f12344ccba6d66ef2a435405607fccbb85b76316d5b9c514de4d460a8c962cd110311fed08a38ca295c1cbd91e3e37d5295bcd70f1625e69448b9ea362d03e1a81a46dbe686dfe9490c2f09e69858b0ef7b26fd1d76fefe5de79bea39675fd1793b105e9194d051cbc018786059b7c9cba2e41638f32edfc8f413f91da1b35da570ef9f02b940caaebdd62608f4454957609c8e90e33126f8ac53a0a74b7511774d469f48dc6528928cf7e02806586d6f9bd68c507f2a776dff12136556accdf5883fb6261421f0d150e6f14147232125c93f15f0a0178a76a72158114916642561f9c772e62d2611cd93e2dd1b9e09c0066e7de90e98e1261095280bc83e5fd7c2ebcd624fb75af27f5ca6e7b3259f3e1f03cc07c422a9bf110e4fbe66219709536c8eece2c541f700c9afb448b856e9b68239dd3fe1dfcfd2b7b5f8302a398cc04d238b2f06bd3b82e16072957057668bc238d90f26f241310bd80e6de130d86677c7c9c0c632ef02530b357164971a2132fd3ea07a543ef0aa068d0d879ccb07185e66128bf47f2993efbec1065d83a105843a3b306eb826839908ab02f7ebf26333313c8b1186fe1da57732f458c338ca2c36d8a16e44d2c4208ded4b59d6359da20c076b31db504169a87d5b3d909a7978dad36e3a9c8afcc56b203ea431dc8c9774dad7dda2cc39fdeb8f5086af6d647967ca2f07cf6ca92e44720c653b393ea48404df8d3f3d49244d3f0d444a23ba340f7c0a6b4650d895793edaaa75ecaac648bd0098b702370128d104c5244116ae0f1475f896438ec158e0ff93bd631c2af3bfea6519a3218a0997e1f59b9cea0482c701aa8670ad0b2cc5198cac3a13c5dc4a02a6174cca3b81888f308617e641bc2192735550bddfee53af30ef40e2fe851ccec04052cba9e9ebab7232499b36971c7f018e0f42edd2e73e2f6059a5ad2092be83397a1434845f9132b09dda8ab391e6b0e80a65d63bf7e9e4dc3c62a55613b18e4d5ba1f026a10b0664982d0f6d3ed292c212a04aed1e1fd20a9fb18c4308cb13413cd4ee15bf5e0895bb0691fcabdd800be728cce99dec3c05c734048d60803822afc1f3fe2e5b6904a477f5cde7e271a3233129021bd6e595ff7f519b7af805344956421ab7ff4e53e116ee9b728bd20a9cbf163349ec424faa2afbe6f1138c76cf6b6710f075ce2872b89d3d1cf97abe427ce2c93adbfe5e379b13b28e4c3382e24c13be8dc7ce846c58500f0ccc9d11ec849f865fb87ea5c7f32ce684d319b7914d40b588d550f9ff06d064d7f68856c7874013ef5b12039e43f5b7cde6a574ee5304c2133f6c090fbeb5376bce19341878d0823845af44dc9fc936a75f74f0ab57ae64aa53f6f16920c0eaa49ebe4927299e4f9d49ea6045ff7f3e38584c7c49a7137c6cf8d82922feff228a1878feb19fa4cd3b71ad8c4133fb7692522ad7cae0783925da6990ccf569988719f4afa4b2137cdf6d93aeb49c8ac78a3f0986d4066a8d56d0f25bd38128c4953ce8d0d5a2e36c75379d6abf7192408cbca814f33c45752240b9b9e349da9971c0430a63ecf3a7b7abdb46be3d739a6c8c586f2d8cfbb19fff804fcf1317f1d193beef7fb0646d1dc30f52a34ba94b252a545d59057dc5ce10999a2b36ed3e8572329b0e0b0ec1a955b014cd19376085aab55311ff312fb4ebaace13b672c035568ac8bd085026b458c134cd0ffd632f2e240884fb661014a9a766de6259e7c134c0fb0cb0cf037a00c1bb1da55e4fd64a571eedbfe32c3684a4f475df86277304e43bcc47854230cc6725c7007f5334f204e1a5f69c139bd7ec597b8ed96195da609486cb4167952599fd342a2e1e8efd9f00cab26d6d77943559d17fe13e24158ed2bd9848346c310937aa77cd2270751cb3aa6accf26f575e1bd46595c872f2af50ad81c152d5b43bd4ed89e726f9883e0cf6de4da324943c9064ebd537491594651a7b119fb1e833631d2486a657abd026e2a76638fc5dda28f8300eced9561b0f658da8a36e6ad8003e0f4b8177584a8fc4d1ea2f22099f080d12ca606504bc1b56c9ce8064435e3c4b53e35027ac8174596bab667876eeaaaeca564fc9cf32812aa3d82347840c5484489bb1799b3cc0f721733b849af1e054af66c3788df553ba31b42b6ae838ceb50ac66b63a335f35379a400471908e0deaef82352deab6c84f679838f5bed3f3c0bf640b3f5ca17acba3e476a35f50b04ff850824443f1db0b51512b84bca7bc5d2282689ab258aa4002d00247467957bedcf9e883e54f100509bcc26f2c14756f373a0d2f48906f0b64c544712a0c20fbb713451b8d9e2cbdcadb07d613bb8aab6132ae2a8edd3d3c13baa9fe5be318d26bdf3c16325f3ff46967f2f91ff0857895ea7a807359e902785b23e707134a59fec704b12dfdd1032075638490fa83802b059427a59c53c554f343374e9cd4e38276fc73b1a56fbf019f7d7fccd7a6fc466620a6d00775b6e3b9ea22f31a43df64c3a9ac8b799ee96636e5967d5cbfd577a7b76589b17065e6966e4d76cfccc3026acbc948bef73cc51b197396e1f5f2afe4126ed6340f10802acd46e60ab4b727d38fa54e3097d54e9b31d510799fcefda447115e604f7dd1442570ece8dc5990b989667d81d6f5ef61e734db205dfa567d34e0b47287ce6e6016e5fd227ef806a54cd856c8ec1aae334ef2009dc5479d7c734924aad0e3ad471079650d928c39f014d5622089cb3ae934ea70df8f1f4bf562d19312d232aa826ca844a7278c5a23ee8c6dd7515b2700e042fa65427345294924cb6aef37c6c7e54387493b21ccb12ba353fa55cd2d00b98603ad001edb50293d4980150563289c97021716fc624783c5b0737c323bca018cdf11f07b1106d77f82a14d1ae2018f6d6aa9aacea7d1225fcb197801fc2bc93de568e3e1f67699dda7b8f3a443faa1f256ff8e1921713c248ebf45367c89dadc5893274f2c6178942d31673c6b225d8dee36e89d4a94f3012bd0717e8700bbd28bd73db23aca31aba2df77e019db03e6001e18d4a2384d5bb4553710e8b0c259b83e71b6b5865e1da11cc23cd31a7d5891127f3e7b0e9f94e5aa6cd7463e47cceae8d2931618457349b0474c01222d49ce74c3e78bf6acef6bdb444789849616fc1245a6f73cae7304218e03e5e54bb813094f6a80ccd0c5044dd3bed0d6ba3432dfb9c36792e9ca4afeeb213876122e06ac04d33281cc075997356fdb19e9db34460eecf4e550efa472c2e8a26cefecdd12fa6f80c998b7c38ab28126171c6e759cd6dace268af3aaa3b84d68dad55c90e858d2897e1f8d63357a7a7f8c60ca95d078eada2cddc25215eb73c7ac84cbe143bac36612b109e7fa54075bbf9b32ce5e9c66a24fa85fbb7ced8e36eb7a3232c6f916957e9c6290000ff581070a086e275d45aa192bc7647c48fd25d3273d47bb030b3a2391bfa3aa0d23660db25c586e75fd71399f8728a5aef74a103d3771ed65840fe9a5c8912b5270047292eda138100d4752822e318a8d9e818b104d06e241052bce3f2a7961a2dd8d2e2c27e852aa76518182652d2d52433b61315f74a1b508967c23c4c89c3351a3f2fd2cdf031e8253ae064ecc1861f7e3396c6dd29363103aa7d9fdc82fa19928e530b49f35c0cac179fe5f2230d1cab6f3d8d62ab6bb68e2979d01df2f0ed7317739053496c0cdce99c07a112d8525a3ff67ca42da89f9707ffb207ba9c9f74ec882f5ac2a6581cf78b4212e405ebcde575204cd263abce797073884bcd7968be9c85ca90aaf7807634f6ad4e9ceacc82fb11ed84db27d5f37f65d626c1f84b811109b80cde85cef799b813cc4018d547e945c7498171ae6ab2832e3e0d8d053007c6a96d9b2d49f6236441efb254ca792cf052426e9c0c5028c2231f22cad2cdd0b1b0b793b467f07eaa987800941325bdf84a45e2f968b41de680188361acc57875a18a5e56ab350bb2ebd3fd0996f794d0e405ed22893b36aabfdae27c13dd756039d67179d0a7315e41cd729f763770e1dad866f452786c9e5f92db5160407b704b6c10604e9d8d4a539240540582ba7e61f8ee283eac71330c4f8d1e1f26ca8a3535abd150a7ffa6410c4df9dcc9bb57aef49142225bbb5d7b58c290329f56836b11a61d20a8bc1c057f93a11ad1365dfe0724f0f723f9282858977c9fa8e6d82f43ad2728e5d8145180ffdcab4d82cf37614899d8bc3811d5724285397de67d3d2b194f959355be66568854a5936e1c0a7e3e1d80a95680446c11125d44e2adb5d917b2ed002b0670c2d2f9cf4ac1fb4d7f5f408463a2d637777f146418ea56f3aed168823f8ac6990bac01c0f852061895fa2ed4f2af483071e47374a6bdca555fe2c952be091953936950e047f95be3261edb9dc236b93b3920d8d55eb616456df874e25fdeaf3462e1254555f8229279cd78d2f7b2ac153dd13bc021b60113bdb8e8e3303f73c3e7e3734fafd0eee38bbfb63b15b8de27099c03bcb8682bfad8d069f854d39da8f40f81e0980eadfb8575d6241897601ec14fc22f703ebe2467f6700d4937a9dd9ccf924281c4ab5132aea7e9e437855a0c2c1ed95bdfd0d9d1da8ff6b131a5d8f2d91edb9de208a76284b6a1e37b6e4dd9576dc4c2445f5753436cd99a134a2f5b32809e743c44f246004492567d3315a4b3f98a87c697f7bf57f4682a46ed90de57480dade02c30af0cd243bfc3de4895e1c792e23bef3ef3b193ca0630e1a386419072481810716b657db9f5bb4f5e309355022f7ca866b77686e1f31f4c8a1e7a37329d1e4aff41cc1906b77c8889ab257a2f6c89882c15d91bc284a13cfbf5f12c3a6375a5839d11a227e5b996997363f17f240667cbcb40f13fdf04c1fe6478ea6c6dcc40121dc034d74f9a9c15ab69b6a315c6669570d6aedb82bc258810e7d1038f9d6b6748e1ca237762cf25390e43298a276bab6d16f46509211fa7b4658963594102ff9572017f331e7581fdd08f6f64884a1c03ede20711d02389f87b39252c2c4fe1d5a2026bd0056e7efaec0c2d437276a0de895732cff9beb2238b1d2277b934ffac9028c30db85f4f54d09326f9a2cf919e75dbd6beff94b620a439a426c96184eb902bb939f92a5f8164e92b8c9639fda66c58d11a787b54ff6f9cd6272e02e95793d827ee0f6cfc93c94b3e6b8b29e47335edbc5e25028e530fdb624e4ab96086e0d83c66dd27705c8defe07a0ffdf62c5d46ed54b812c29a291fd36ee7895458180828291308406bc28eb6dfb7977500022d9755d2c991ebba5a8f4d7181d82685a7a2143f4a39c6a2998a70dcdbb68ef39d52c6c255654efac1b2578e33a49fab33f46b7ac48f62f361cdabe5882917ad264a4e963acbcd1fe8fa68be7b2b61139ef755e97cc87e06075bfc6f818f8feec84b67feb956cc1f7e5749ef5dbd53eb6968bd284842f2f84155cf19f83c69ada0b7567957acf0bb0d9c2c6fe2f7701a05097dc6ab536d985ced5e86319567e26a865ac231f9e069c73e47edcec460c0931b85325645e4b288146d3453e2f8c9b3015bae3ec8c15c925f71901b052ca8c130eefa8aaa21e45d846191c0d525a012c786505da5d648cfc2d8afa463f60bb9b55106335064d6bb949aff0e29b3e9567f41d25acdb73a203945faf5c5d34e1429308bc54632f721d1778404d02579a35849577b4508382e0cfb80d5dd3eb9768ada1bf6cd06aad1bb0c9e7bb674309da0dd22402f47c40e2b330ed7cd2510968b4363d8ef5ca52b79455327bce7addc7ca7ee3d15ee20a4c85dc8324f4f220d418e231da1a926055578fee013f9d7956a3a32dfd516ffd417c2dd6cfe023ec0552014bee5cea3757746a05a30410b23744fbebd844ed04674255b4dd4eadefde19e48149b32b4c651453c798a3bb095dc4ebd50cf3c5d433dce0b9debf87c1fab628693f014409aabbcb2b9dc606cbf862aaf6b39f2da898211434ea7e0322bbb10372fcd911a505c0a8443f4d2b0a726f5311c2eafe79dd0d966a2e7bcab62857d1701cce288229125f71155158daa07aad2a568234f501d0bf30e61c46a88c1df3060f786c55d9353125c0ce44af517ad334cad830540a59278679964f1acd0152857c7cceaf722013b4eee844062882854bab74b93c095a7b0b3c163ca9035febc016010f112ebd9d9eef78ad1979284c19f11e56e4705b0701b349ec2f1b4a83bc2f86f47178c30ca47f42bab849edc0325e54c54bf1586fdfcff1664cc083a65d933d29f988fabf96db9bd0b23eadd83abe941543e4b402fa6ba8fa541609a77ec4f533b02e846d5cf784f4d271b7dcaa388936679eb782a2662f86fd379e65572a5ac49eb1437f47dd3b9f92c1b5494595fafdb7d933051931a8f6be920c3a94ff4bcb553a53eb00cd26a7b80b7e9e0eea72138b332251541c902392103b515e43a54f3fc30c981d756c79dfdfa5f12384fce4616d135aa4012e15c19146de7619689efb41989610637ada44115bf19bafeb6cc65c8b4a41ec5e7a2f0670330b9c53aae3c72370a1729864bfe126aacbf92d255023f5228fe04197620b683a8195b7add1b8839806d10139d5918047d918c5a6928f5400c34db68c218b5445876ac30f6284c588b6c7719abb255e7d1b983ae8faf37136401bb310d0bdf96fe7bb5660008ff2f723410d334e8234c934326bda4d10c54636e214893abdcec24030d6f0f4c5b14b3592591d99f2d78da7ed326a2cce6c84e6c33f8f06540fec20ff153b67dd562be46bbb03df2209588b62a5ab189627d859fc76a3286faa8b64769ad10772956ba765ec1cfb3de9da8e740709c7ec9ef63cdf95c00448cf29f326b1ccb9428a010b760aacb898b95e0a4acb7b8c06d718349c4657fcf02f021166a784850fb3ae605ac89248a28b7a1e217744ff63f785d288de55b16fe989cd1a42e80accfc49cc5aa99ff346ca8e2fe0d7578de9f85a4ba69135f89b99b36e426b5ef0a96359d5546565f8de40758422bc5a321eb90c967b4de2f17cac339d985ba2b98c01cd4921393f86aee291a92f42a551421f1fe7c691c3ca1ba577af8706b38d82b7e841322f64e15167ddf77e1b627274022def8be08727d80b87fecf5f8b27cd35196fc8869530149273e9e4f5379aa6dd07318e23f55e036550514fa39fe2d52f5da4be430306ee0949fd3c597fadacb0c9d76b4ab0b5e7c32499142cb831b2c99842a5528a9ae0e1c334dece7f72953eb9c8f2fb5091f2c0e5b8cdaa423ec193588fc3147fe1ef88d005d5419ed1b4fcbea967125b6ee73998b763c91b644a4180ebeb9ec15eee6e474084e5a26559f02a176b8e0676be9973cbf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
