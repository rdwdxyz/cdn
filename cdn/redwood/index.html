<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bac36992b7dd5fa3c4d3610dcf821a1a36b8d7f97884dc3c232819de169d5641c227c9bc69d7677420799073ff90a8a3eec7ccfc29be8fdd1e0bc79b023fd5fdf86faec2f344dfcf0c85f62657af9911175fd19b162bd7bc6fa6aa5600c40feb553049b7449b9c7224c5db5315fa675b888d828a8c06d898e95aa35f7d53659fc1bbb1503e2c329b569ee92260222b3b69a20bb8cc6ecc4f1392777aff81ee9a6fabcb65f71aef9baf529fe9a5bb4761711f7ecc87b3f5ecb2365474a5f37f15a0479655dddb1532dd409070b85f59fe16329c3e635fd95ff8f86bd7a6ddad12baa6cbafd5ae2dca9825dfcc5e385c2cc674fa11756d8530dfca643478174e36259d7afc202452bc478a09c0c59507030f71303d6d76eda0f72fe1029d926e4289577623d96da8147f3eb7f90eaf9fff393a59e21e30a9a22b16660c8e6ff93fbcc7d7560dcb5d5d7439f4cdcebe6ce62f349dc1b3422b2f1bac4f7850db4b5ed4fa0f516d9a02a33f58a9287be12c7f229751aa42de020b3f37be26ffa5c51ed0c4cd319da796227315ff6648766672db4f5401c6d6946ebadfa8ec1fdaea60c94eb815c4f92e6551421f0ed081c0f54b48e33e661c312407eefaf249bcdd62701a5dfc6c869508e23e1e5ceffeedda2c95d6b0daf2d89a4c94bd3fb9319cb73e6e4115646bfa99975edb952a96176c28bce81e8709c93f6f6986096965ff9db4968053024565dbafab863d406a1bb809ab2743c0781bf3db12e3975036e136e12e215aae3f163b11ed34912080f8827ba288b55bca16474570b33ce223ebabf55ab2d8b24bbd4b20cacdfeb9e3ba20c0770310da9a0f23a1cd3fbccb753a203a5d6ea3dfde4fbb8143dd61c16bb551ac9ff78fc8b3c524e6a1a1676a5e9af4cfe705464b5f132acd8111a9a63686687489fc691b2d76e60349322dc6ad40a14202f7130d6158e2ee220bcf965bdb715fc8e677b97accf0d47bf5e98e9735cff2f27d4b2cf9b33b56d5bb54a2fa96e93b8326c70155bad88f133500ca06a7329894fb1249c6869dd964ce926ccd7e890dd312a2abf9063e72b7483e45871b77af43d8bef88e284db1a6d809b05be6426678743bb9d3119641df772869a617399d6f7cd46d3aea8760140313b2bb15d8166bede8209abf75648e7302c0814d9ea33746226ebece427af9284d24de36658f25edb1b1e0ff567a7d1c413934f38656b1b9627bc68aec255974d4cfd63b265ba805a65daf809d80cddbd6d4106fc708132cf85c45ce57aa4577b4683a7baddc3ee636b5f9ac7b46a8118984041c6b909b71098aa8c475b49c2c76d46778483a9aff0c1d089d4d68b299097f09afc23e9132a935798858fb27ad461f61408712c7cc5bb19574b355890ebcdb5f2006c63bd0791e7fdad75c5ed9c5af31a81857df78e228c18a8b8c4e568350a6d1c510c1e97c5416412d7cf77b8ed568240a45c23c5827e3464c86b85fe38fad0d91aea8e357c08b62ae884f660b6b264424aedaff41d5c9c5eb2d50df8f4dd177e012f10abfce49372277a4d8bd83b43e9fad907099e67d95de87af4358e222d2c5f9d3d4f673ded782e241539a9188d1d92ea345492a2b442e2934c6c52c45e65afce8660b1d5c37fe70389e6066d6ff7eaeee97b29d5e09c8f0fde8f7fbbda8a11ebde97b1a73a5e3e110c285ae8199bd7f494f00d0734768ec90dc9d0b4fbe41292c60b3d2f088f6b57b34737b0fc31cd50cd73506255fa7f43a0304768eaf06a0ae7293eedb5d6644984f80d13decc6f2c45c1a3de0ef488d85375b8a6573a67af7eafcad6ec0dd07facc5461b235eb0d5b7a3b6211905c9749d5813e8e22e46a814be65b8c1b1fc2de09c7cf43788c9722e0f168c75f9c7e78eed96c165bf13dfdc97e98019d368d98d7b4b09cf05d050deec6411ada57abd8d22dc3d2a867c202979ba95297073aa33fef12df7428eeb97596ee64c494e9e14a2407d8e519d9160d0aacb897c6b9380d6a283cb3fac021f20960486d7ba9bbdb7bca6a4fe168dfa856c7e0c751af43e0369774f0114b8448c9ca98cbaa1e579e5a6ba83fe3eb2e7d590c6199b93e151eb67d236cee758cfad08580ff82109d34625ae6f8889045ed62a4e77b604c8d774f4cc1529017563d939d4921e5998e38524741a7d1c5308257886fd217487c85950da54fdb684ac975a1116c984052fd1a054beec8af529bb8bf7b504cb7bca550e949d96cf524f811f757e20db0eb91181340fe5b0b8c8b3a82f24645195bdd98ce8b76fa9ee9b081e8202a4861eb51aa9b95f8df7959c218e0e824d9e2841eaf331245c3ac1c60e7ab62b7a79c8247969f25897ac19123a9984ea44ebdb36e1b27e434a8b604946d92f926c6d60cb4d318312fab043e12f5638b5e6a41dc2b1c9ef5b9e80d8b77327111a4c78146d674987977cf60d7eb5c4b204dcf2966bca7bb3da56b43f34077121dd8c6e52b2f69307b8c20d99092aff871e83aed4605475eaa3c1df3be7613308cadc9aa81113d5934b17574ae28509b0ddd779bc845032f656e24eda74c47c92eabd93622fb06ce32b46ca999f0577638d78cbb7da4574d4cfda6ef8daa04e5c28c678faf67d9a5a38d44a6985bd93879fe5bc410182f6ed1b319ce0606453a0ae8c857a6e126cd5af21843ef11b24f5cf4fcc7ba4d221834a457593950afe2ce23edf310ee1a0e1df939170ce912eae83e699650a5d2555910ccaadce6f8a2b0a0cdcca5e77e793ac101eb22225090a403613d4d0c7419eaa6c14e785e7c82dc73be73adc7cfecd880c56324526df5c34fb4b7b34ce2af0e3a018ea6380636470d6c84f0bffac85f2b2a53ac1c5770717a24a563f6d913591f2d2ac2ef85e028ddb61fc4ac7e670444faaa4ee8d2627ce02bae6fda494b25f3ce7c1f24b171c18251d3e97843642062f840c05b53cd69e4b473e6172c29ce77bd1324285565d9392fd505dff994f2ec5797e3281fa3b71542da78fbcccbf296b3289aba010389911cdfee6f243a081413f6b1f3b28c20823249e7dcc3468f3fb823aff8552a08c8b4297118209972d747fb8b6b7cd3fad3d618edb2cdea2577a56d4c016c4206db733d38cca2a2da46e89dd50e868a4e5f67e6c0bbbcb49f5f40221d15e822cf1a10a4b9fe57a2c4c3f60d01101175e6955c35a96fd1e59542c0a52456a1ad35b45b5683398eb4924f742f5a205f781a4cba3c16731d56ae437f70a7ce20c0bbe7c3bf7675c2c45d40496abd3e5db5aa20c1015af501f952689be53f6be7c4b1285ddd1d080082dee5955c186dc11ce0b5e8298debbcddb159dd3f00456ade1ff8bb77ef9cb00a77c07942db8507ed46015aca7496494b6914642a508976a19f16ec8fc31cfb5b304c83d9c1b029cf88489c8a357c7dd74b664ea63cfcc0c52f480b30555b04ceafa60baf398628862073103337153969cbff454832412097a3f5eb8401e420928d6c183515fec532340f99913f0b8540886f28f7fe0cb37f2396f23bbef2d43231931b4edd659513be783e9b573e4e0db9024ff564ffa96e855fd3d458dffbd10fd542a1c6ae29f5db4fe38fbf4982de47457af41c88167677c01451033298347c860efe85f3c84f331d19842fc422fc4ab99ff74060f9cc732e116fd4552c3a8c8cc094bac4c11e82c8864ea2f8636103178efdb006a537b1ef761ae698dfdd07daf9432471435d422b30a820d6ec417718379867ae0d4945b480488f1175ae91dbd2f4b05c1eaa0444f1d9fe39c2546abfcec9c174748f62b4627f52bc19d00014faacf51c2163d6f516873f80960be008f20027f42742c21b162bf4f0056d0d961db6ae77d5a4ea717c53b0dafc8174602cf5b370cb2e2dca4f723a9538f0085712f8dea8505ab246d934351f067ee1424a6f23982b01c53ad94b69ae6d48e2d695e66cc38e873fc3d01979cc3f66a151d7ecb4ae13dcfa21e211ca3a975ef339f1a22cc637b101e4faed87aacd494857cd80d597b84d6262f69bd1c97043fcc0a0cc95f736323f74b93f753b7feab1de0c65042e4746367ef047d2539a3e2196ac3ef4b70e5b77c3fd68d42d9a0153544a8491d1ac11f7d01e6e22a31f9ebf74edb1cd877dc11d204198d92d176bce612273bb485a941fb8f43237a2a3b7cf6057cb385208bf4c26dbda119ff718919dafddb2e90af2735f15e0d160737ec98ec5d87e219e485a6e0a4eba7033e4c391eb920203d86614ba5276705ff5662c1e56760d05c3215b250fd361b4fd86d694a01f99b615578e04c99ca8a61a4f7a07b5ccbabb000ab9272bd683008f14d26c55d91b27d656a00076660bc0e30b5b8826047acc94cf0d01aa33c23a86623489e13e5dee06a2aec9a29ae005f9de30ef3b00f6c171503d9eb5545172b6b3b838dcbd1da46fc67c35777913025651289376d142f06248eca48af67d120cc9496e2aabf9c233a0c270d87b453bd4cc4b238bac16e62d6be4c5dbc1d80633febd99ee3491735ce778ef1ce1303cc64f03da12c768ded182f13aaee3dad2718d12c2ce1da35d30a0f81d6a4d04fd3df6d8fc617def6232e4eb9cc52f4d2e878c5ff603b16530f009e0d026fb9a0a1f1b0bec7f02b1bcebae257192626be9a81b4126cdeb5806bc87ffbdd68e7974d5d269657cbb6dc937e2d36265fc19c6e8beaeddce91b4cf7c0f6cfe7cd263aa0aebef46afe554f3779785f9551539b5d74cee15f697ed6eb9b2011414dfd7cdd4da92e964f43999de575da7a2019565ffacf3bf9ec7880169bc37137916d81e7563460fc9baec922f87cdb7fe196715e93b1239b40332ad165752803c4813c87d66b3fffccca2a73c7e6446209a4eff4511ac78d1792404c367c1f6c76b8d509471a0cbb12e5b2b1c0924d18b7e1f3e027e97ebb1337c2cb1f0e281d9b8f170096f8cfaa55cfaf0cb812f1437652c92bf06651a6fc1cd54b71ff25189ce48023d8681799af798ac5bd76fc97a8248eb42d6c9556fd263ae711feab3f75fd5df7c6ede2f8213e9d456671251bf06ce3d5842e25d08b2fcd187c2c3e102ad777f5b22ece1fcba7bfc8248e8badd45081cd422ad5d3d277124c334431f3bbd414ba6580d99bcc0e47d58a136aef0d3a930925ba0d8b415db838e2f2ce41b195c5872180dd1f191e7ba14bc3b94271ab359442b9d1bdde8b2858115b8dd1aee0008d3b7c8e94cc1141ad2fc5d30ea7165154f875374576eedc142c092c319edd1bd568d10a1dd8ba3547a4bc7085ebfe61207ed40adf99eeb36b96126e495b7ff88c6c6feb876a0c05ddfdfaf712c0980bf1af9b0ece12f036c7c01c8f263bac3b91d86d820886259ee5156599b9de99da700982df7bc3cd298b140ae2f59445c2fe9b15b2c61623b44526cbeefe473b60a5adf9f8aa9d5f97486baaf3a688ec57d8c7eb224f58da84f75714576dd7c61f471719a48a717e55cfbad08ddf12a2ce0539851adc49861de72b73eeba60ba8fc21cde561c47d4d5d03162640e7e2cf096cc531105f6050bfc210dadb4ef82f31fdc8546bcf04b290dc5be899dbcf3fd31935a97d0abe4f57b97820461e464e38cad53d076b6febed13e465666c30bf115e271686b00cd66f7643d9fe5dc0d5b74903eac9f629bb637f14efbc6ecdec34ff65574fccc3ab7658808c00f2e24d6d847d24cfb76db13ab498f33deddc6833dfb4b12fd9e90003d3a62b6f097f8375710017bcc0f9db819ee2b0bc8b2b6ba787fbccd3d2e7f4dac848a3e070f23f494763487cd2ffa9d77f7eb8f6156d38bbee5056bf9b052f123b1fc756d0e40ba1dce40e8a0b09f6e769f46f63959480fe563dc16233ef1c59ceac37186d0cec56d58ee8171ac7b138e5a3abfd0521556a648c3d8a24b2ee76bedc13f769c24d19482eff5af0d9381a212dc24bae798068667b7524c191f3fb5431176cc53a70242b8c5752e0574bb3e43239fdc7956703cae37a003eeb44231644ac0ceccbfa3b9b0009c5c917a947709bdc15570057e37c2a4c94ff2c8825253bbb799253e0549ae3c42f378206ff882664af0fb9286c4a7bf910eff0e60c8a7a8f525e4f1ec57665ef25db5c54cb5c69df1429a0d16b1b1aad8fc404b6b97e118afa8db336c7a2d9e4b8a0332ad1a42625408976fecb04f79de0ba7ac83e7feb5284ef2614468636ab98a8e471b66c69ae96d881a4f7d335755c3abbf093ee98695ae746a12c4a556baaec2628af7cfdff09d9985e27ff0e54773c31a91b76441180499c02556ac9ba645faf40b1e8efd7d250dcea1c5fa09ab08068da9980b3bdbe0d4116ef0c3d72cd256508c7e555dd3083837bb57813fe5a4e178c414638cb887f894433df48d6e813cf1005f50447af46fa0456df731e20712651a2fa6b25fb43fd439054b11bbd2b1de4ed162f123915387b6fac8d38707f7fa53822a700bd8c857e5c106fda1dc89263d294a35bcc965795e3f6f74cedc8cf77c23f76c19ce2dfb3a5c0645b1f3230ec1beb01abb09335f39643a98878c7b76af4a9a75ba6a224f6fce5090a017286862899e0191661e4593605cfacc8f4ad8065598d6fedcd2d7b4c95850a305af9a27348c2b19d8699a4e0b3fc942138f731e7f3bcfe2a02f0849db3f341fde485798e963a625fc514c8b427451c8b8b1552ca2768a8652ca903aa6b911df0b58849a24fa7f65d08be683754f8967291013923380abbbc66ac9ef6ace96960427f68adcec3d2d137d6411e43ea243fbb6384421e9cdfac6db95ea0723c7d30e118479ff963a93aecaf15fdbe06dafef449cfe927753c91281c77b94f636467017ff8d16b5a0692075b8957655a2b4f28918c89426f0d88853282d697660de3615b2465ddfb5dd23309366369d000ba0ef9f02d606f07aa679a7fbbb7fa965d06c630234367601794b2982b2efc72b8c83e84c5bdfeb35165040e4c8282663aafae7ac8cde639aa3f1af757b7bdeee86b40ae21be67e109f692cfa4b1fb98e9dbcd98a766b8be6702c9def0b1af235842131fab5ab73e0ccc21a3a6d15fa20265524fb15f43a3a88204f6b04232ce8ec1ee7fd07eb03845f5f75f5d141454972d03ca9aad7e3a1797e28abe30a8fec6e6a6186dce8708a6de90b77c25443d851182a0433d1ba8b24e5f73232908e87a89b13144a87effaeb6dde7e61c334012baee9074f64422a48cb472b2bec544e8a9905fe1cd87c6e9ec24049af9e27bdf24e383fe52518853ee6046cd8d78ba1a79fa0f21fc1866ad5e7c7f7526dbe3efbb543db337d2cacd4e2a503b1db9e72d49215308cfa502547b480c24e1aaa703ca6e00671b1ed9e424750e7fdf859f7a2afe6d40418258ebdff6fa06c68c86f1edb0c987f7617f01eb2512db841dedf2493198f61916f39b15db94d0bf635341e586789e0cca8192aaa1c24b20df88a4248e84dc4c5e6f9f041716923f5c60e676eefe9121522c20812772aa672ba0e6a780680ad47cc7e141d3eb405ad1a9e49cba6d1b443edf58bdb88686667993caa51c306c5caff37acbec942ed15116c65020311348cf274d26ffc0be1de321acd5a16488460c9747fcdd5f5b17830a8d098d2ca84b44757b07ceff896d18b8c9246cc2cb3577494bf5fac3ea566ec5dc9d057a69b677ed995fd57faa05be918b9ad6baa3f81329f4bcdc9347670133b7a5acd0efba46a9d24f3b72b324badfbfd223b6dc3c662c03ddafa472b3240fd9118515ea378cc76adbbe2e5a34c6476306defc127e0ae41b1e66fbc132c8b9d0f1d869bc7a27928de6272fa9b68e519b2747ddbe9f8bb33fe6239738ad9bde3ea69ea84b66a392a195589060c2dd29edd0b2050ea0c86154b7d8eb3dc92f6be5375e959adf22fd3657ffcb4a6fa8e5e8bac12d3c76e59844a6892ae211c51735f33e2e08d6f0c2a75eb378bc37a933870689f530a79d16abef6ec32a2e78d7d24d36beab408ac9f396241b37a143c4ad0307f918952cf44bc8d3b158a7a5ab5828881639e1e5c08cfcd227adb359dfa671a0b34ad8932555401c2e68f05fa9815163df3f1aca881bebb3188759d13e624e7e3794a2387758a5be89a846662a804e033a069a2f14137e0628b95055e5cc89c74de8ae699ea489b3ce0b768a96547c1914c1b56dbf7b3a847620304ad7db7aaf85975596c813a36e4c90c95e87e1b4e33491e89f172e7c611b701b66fc7c0cf6a6ae171fdba5ae014cdfd8e942e75f3521e601ba649f63a7411c0d5bf6a7a8ba808b947cc28342447f9aa4680125bc4490bffe08c743e75869f45529151ae029725b5251f44b77913b1eb5336694d03f797d4b3d6d4be66595b1d7d53776d6033ae7022d8a493808798100626773b4c92a85eabfc4399a9b49fa0cb0f4d71c93f8e4e76e1589de9a7585bd3ae7ff848c415c9be7af6a7a2db5685f72aed90796271e697c367dbf93ee512516efe9c525e3149fd0a661f31d163037d7ab21ea7efa417cc85617552bfe6360ffc5624e0193527fb491f47ef2101b536111f52d9d78a41fdd53c766df3411b95298584cb1ef3cf3b7b8bd5c6d5956c9935ae98f6a650aea536f314042f136488ac58d5ed00f32196f167d1b677d9441fba6f12a44f06d1d209538b9f75b58d7516eeff5fa8effc2c6012f2d3f43f8ecc8843e1bfb8e8dea7fe8075da36d05ecb4d49366dc79dcdb43ad474b99041f4c99cc54549d68cc79d16ceb07e451d0ffff2b5959d87336f6d2d0a31654f4bfc94c1ffa6f526d47f73fd88f55008969f8ea6867c2da6c05cb3edf6b9b09a01883b63f8777487ae9805662ede0e3a80f3b8dbd3b56981ed8a1327ce7d1a49b8d5b1476faeb859a458a4115da21e09c9e3addca06f121e3cab3e3850f92f6facc24a5e9b662d97c658aa24aa1cdd934e987d4042f7dbf4ed135c821519f8ca3c5af1fe15e141b32acc899dce61eafc63194941d100d995e6d320668709675395ff572e3d7c09ba85162ffded0ce8cb1e4f45438e394f13ecc71822363c8edc030ba042abf4cca0e7cc031142261596011d93e2aa4cb1ea8bd9b41ebdd04df0c3394f6a3bc001028419712355f2be1979fd7e7c77a18131ad4632666ba5a9b7af3d21507f0c8d3dfdda2fd8d9500c5b2dd3b4c328627f59e9216b58c8747518f56275336d11f6afa773b48c1357364761ce063d21140c8b8e514aa05bf8ac8f3b2e56634ac28b7b757aadd5692e0ca1c8e095f3522e0b07f213423860f876bc9c7ae22da86fb36b77c2c3c755c625e0b7944038c0c1c65fe5aa2f42e505b4eb6b152f427ea4bc53ce7c84bacf2a6889b9d02d06a14705881d827c847593a5f9e7bb059291bed3760091f44c5d0417fe0e0d946040658c9658278e8cdba6a70cc552e45cc0d5214f950636cffd60d928be405ce9c78a7151e2810b5128539016006b22b23e982efd9ee92a31928484a2596fbfb1c40ce199e4702a32ec01740ef7f30a274daa4e7ef1c1fab4a96e80632b11de67e64f62280577708898480f7d9df74e1bccb015755ef4676e72409486207b3682a197a191836816cb1410a500471dfa01c13af31fde37dd354e52d8bc09d3793e5b313aea69cb18dba748e82847c07fb98335c9824aa8b709b4832588d1729c338e5cb8bfdfef4c130a9c2e004f8d1c66d6761985ebb66eb2203eb3748f3fdf05c9a9e177570c41666c6f2d56936e12510c9357b228f5f8597e7e8979139b895c6de396abade536bad90a11696439155b86c0c11ddc7db39ad7b5423bce1bd09b083c35fc753ef3a33c2d9e8f07c32d7ca15da5deaa52f203540062d9cf9463840992823169a24a89cb567b7ec172b263a1e7cf9a9eb87c40d7a3f68b1b324a79a4d9526b3e07dc580bf866fe82e7886a8357c942f95188fa031ddc387d28e6b6e8840013432527eec2a6fcc68198e464fddc463e6c9008729ad4f4522257192cf0dbf351424af851cc79da6706b7b3f7976adf5991d7ec1a33c4461329bf4e76bd8b94294ae7724cf394ac7ba9952ac96f8d0d133a1a65a4c87909864167adc1d592bc90df0a47689bd50de8b8a101f3998e3a71c316f31d0fe8a8d537690b7426862a20410c89efa3d6c06257e3a71b6a99c9d522826379be6e077eb4de80db7b6340a14119ce13c0bfd76a0d324861f8b45ae0498b630add0480576f071c057fe015a249e13e74323440e61d37f8f66949115b189705458f9e22c92a670a97f782cb825e90dc8af27e1de06ba63052d295ba890a5499ed7744a093b859729728128ec6f0ede822dd596255728cfbf2e925234970f3e77974a3efd17bb1fb44594f92c0d30f4efdab6ad10c3f53b9f24fd5dc0d9292c567ac8ec734c0d33444ef9455bb843a877308e930a0c1555f8a2d3d9ea7a8d058217b1b102ccaf5461fcea2fae83194982154af9dd2a903b89309a87b8baf30e86243a7b11728c8de4f4f03c43293d4040e4063c55b7bb98f201c1d690eb313e1b5592925bab3235de8ccc1b50b750af0f59b8f80649afb3a76597d4a08f37f1dbaafcbff0aea0d5f0625234b31ef9a0bcee9b73b4a9fffd2e1adba997b378ab6ead45ac3953bc408199786f852c8e157a5b58cd2c1a00acf48a7f66ff68047cd14239b6b6f9e1e922e8fe1766883a08958a7c5311346bb7bab3fd42b0489c3104438d22b74f8fb0d4b8a422784601b85af1ecad71e52997bf58fde8c11fb3e8dee2f4503c9b574223a1a2952683688a910116cf7ba39390272484605ef81ae1aca2a068b660e1bac7e44d41f485b43d8886ec8f48ecd397e47ba7719bf5082a881f685b64f00876e7ab5b68e2aaaabd44b49446bee76547168944b656bce09b335963d4c7e0746cb46dfa096827604245c1029b37aa21f34ceaba3ba03f13a2c254e9d34134a4e4703b163e868135e61a52a71ab6eddd2b4eac4bc6397cf3d7363c47179b60eca7f6fca75eb075ad69fac31933c122fd2f25db13ed3fb513d9bdb152ea2972428693f12bbabea65e61c605bede6394034c46f0c1eee9214c2fba2c33b4f1d8bf846fedf0c606630b33126f99c8a3cb3be34ed6f2adc95c34760eff2085af4bf3661e3c8c3819db8614c4afb2005772d0b24fb8305301c34c4dd8ae61b0cb9cc16bdfb538df567eea81b06db68eafc861407f2b98c62bca941d4c64663b410a5b2c3cc529f5202c632c65b33e5abce3fba79e7b5bdd3bb1f2e66e2e3dc203fa39e946fdd00479b7f8efde94366b7c5d04618e846fb5ffa50124e5eae13dd120f9d31ba64eef8315e62bd56e295541fd49ae173d38e15cbd480ac7bf88d76d3295a90a7a0954af77f8ba19e81097a9089a4386dc166a461657200b43f5333dab06e9cf2c86b10614510b0320d63600fae4fef64798c80833a37e9df2976cc50ffe526dd70b5919a2dd270968dc834a3b3573ddb5f2399e4dfd803cb8bf0469deab84bbae05d745d39324f9aed5a8d5b588d29c92a2b139da021042d2314cc9dba426e512c899c29559cfd249e97488f66f012a1e994d7d0d58fa0ac49d276231f976413e73b32cc6e89ce5ab18715ef2c3afc9ad96116a93218c78acefa89068889759d2023954b292184616a040f2848b533d016323d9cbabd5f9487fcbcbdec74c6ddbabdb3c0d97fe77b71cfed100fe313fe694e502b60f7c049dc41b2fc9f03e999fca1d42218e7e782b39d8aa4e7f42fd364c0d0d3a28879e903d8eb39d6113258e8578b335af5ff2168d15653cf67e8c6d865948e2f372287d12444e56015a6450aaedbc824f56284adde4b634e857a261bdb1425d440c518bf512fcdbe28b439c1af815c31733c3436ae3182e3a2731b639f59487cc7e8868dcb0c78afa4459e44f604eb6e23f28a982ab229e1ed966e5347d4a9c71ff231a9f61c67431598dadeb32cf04ae2a18ea2a41582fff8534ab3b510142928e9c7e37fc86cb9fc70fef284b1edf43185584179ed6df106cf943d6a6fc6b9500e04db4b87b0c9c7a0d66cf89be14585d3fdd7165816c8f12ea847fd41eee95c4591a0eb940ac3acb9f8d52772872a5afa12792507b4095b06f9cbf61232fa8d82f59ef63f8154a6ad7085198485ebe5b9d9d35f54b5aa55ca66e05f88ef8147c836901f8494249c7e217de4580200255222681ac6642e1e13a3be03558e3026ad79c897ccd381098b5556dd3b63d8950a55c0f16f63ecff5549d30e448b6f9d4114231716b9684bc4960ead479c73fa34232d98e07bac8882b20336a5035b4805cba37c5f718329401f0dda9fa8dea3b60fd64901772b7b6544c929841b159f2c27ddef4321e79a6473f927ac6ad4d1579b681592a9d4d84327900224294b948cd950b4d6819abd667c0f810fb6ce7903c49ad749baa14ae4299d690d57c735fca7c95fca1daa993fc7e3a18b143de58280272c83d52cbb78e188166105469dffe1a568ee44c46970f214e942793827212b8646061d4a3069f451b0be6b194dd4bdb976b79bf688bfae91aa2f59d421dfb3add1592298e2834d9bd81b43d941b4f89cdc9e3f6877be8042869682a007bc071f2a9fe8821092c438fae8abff8668d36ac9a714362a13ff0e5989ba91905090f9f68a971fb7d4a35d9173f5ecfaef434a48fc4908e1cd1ddb656520d89a023c6c48f30e4d188503dd72aa7617d95997300c9a2d3c8ce967e5675b705f479ed873c1025e0a4b5c22c8cabb42bc3bcd8ade8c35fd97455d30242110c85f6c60554a08ec2b0e87cdba3d92a7890aac5c27e5a024c6e8c614de3620c3006f9dd04522b48ee546958c8844cd38a31b42f92e6814dd67cb4d12b59a995743260ae8ed327a6852992344397855251206fc8533705e1655ac428262f4e44e7146269f6dec6682d2f96a67a374be950ad0c6f18efec4a825ce3adfd4efad5397f3f8cceaa3f1f50fa4c9cea760f97619208e5603fcb80512fb1f11bd0ccfc4847cd811c0a6577930386f3dd26faf8d768ee35c0c0e4cbcc8addc7aaaa761d5c312ab316d18608407d6fe94f58b88f8090e9b27ee30074bcc208cae8a8fcd422498200c2b95e1ed51019d606f78c72098ae0e0eff85e98d59bbd304ccda347b82fb4924bdd5bb66573b8061cc764e5d843e1e03e014acf0b24b5ffae2f030d246f3e98e0172e6a1160e9a9a80034c9eb98c3212148c4534b0280314e4bc21d7e36b85b4fa3bf4ec007b447e9294e5ebbdaf241e13c7ebbbf2dcd42ab016dc1b3e59873815784eb4cdfb18f712f65d90758fe8be4781d1d2be9c6ce7ce8671586b22dc92440ea1277c06a989fbf2510880612296af89ae28f5bf3bbf782efb24e632e086858a60cdff2e489697994487bf5c2dca5b598811edfcc62f5d9a3df5779dd0b727c198305b1cc76da945e954ae7095f95805e9287bfc5454d0f716372c2fe6bbd085fb8e1eeab1d2f9838330bb98f836a6653fab532512f5592c7104e5d5255adc3b92a499ce09626547ccd7037d61a7d6e7540516e111a4a099da6ad0ae521cbefc59e32602fd194bd098a7990b2cdeee7c12e38dc23b55cdbaa55ff83ea4d47c465d72a00c870660ebd390f75056ca7783b75bf9ae4a968b8a4837f75e65bb63fe6aa8f492a535158895d2f064be82b50b18702a43512b56d1b81bd38c2e500595a576ea242ace7deaa215ff026f14452149ec189ac08bf59b9c8673b2e1765fa27a93f76a7d6548484c028ed4efc7dd39fc62d0acd360c95be51f4e47017811f9ba5b390a995d3023700c4e36e947fc87d1d0a48b1cc8a4860c7156d1ebead4a21bbfa79826b0c51fc977e2f220e231867eb612eb2c100a25772362d06ee4bb3a988a1eb47f725cbdd26ebde8d4fb8952e50926ccda0b8b9e02e0de86de52e22d58dfe3dafa3d5406ebc66949068d1f708228add2b9e7149e9342ba49f48d3d04d9ae08db37647737ecbd453f41bf978cecf077afcf0fb4b72342ff2c85bd614fc5165483488c63835f424c1e4ac4b624a558e71a7d387b8c291dc8826ee9efab92747a3ec3a08d06902b6ae8933a0d23e80d8d055a7c5a24379c5f56926470e17f5a25f76b55ca4fea14905e06251521ddcbca7d0a2578679bb04e385a5fe38f430fb7acf82aa62bd43a053199cb0d6fcea7f1f7bfdd8de69c584c2c718654c3ea2288135b7dceb6b27faabc56de20defabccfbdfa8f220195d0ac449f4cd2bd7eae3eb14a31b986b8b553b20b5a386977e69b6e7b60f7339f49b1f5dc8abe8b4d5f41266199e25fe6604ee1fce05ace5fc8b06e6827397f43b35e7b3154be95cdd40bc1258209fd6bfdcacf913013b0c1b81e2d691c0e3cfd1d61039faebca40888b590336cd25e108ca5c00169564c14b3ebfbdafd630f60942009ca764b1c05884b7182714c61585aa5d65f88d3de36a8edca27ebec61a5a3620abd8997ff74dab11ac4ea5d07a4e5f2de6f604ca882538e80d478859650a512569b1ed0c117251840e69a9258e155914536b1e2689db2e80d3fba39bf483688f341a890373203387071aa7688fb71cbdc16ee9125eb0fcb18c5439c5aaa55ddebcecc48f4e376813534b5a43c942a3c9a971e767a1768d50dafff1dd659a0f5de9a2a57b42a2c23b86d8cf37ca97735fc3685844ced7ebb2edf40597e6b9e0c041e05543001954e94609440ea7f57b8c888b89c15053c585af0c65631cd96a1580296cab3306ac9abca19f7fa5fa7c9b8f4238905e52c812a607db623ae49c5d687a3f0cb6cc63d401ca3a1e80021f20982af0105b1f3514ba990973e38b23bf622ace2230ffa16e8174ebbc5be3dc3d9ccdf915cb6fb4bb5a2ee96388e125196b6dc677f898dec78d9da02868d89f825643789ea67f79aa5903a00c031bd08b51d7e50a232fdf74ef053ce58b29f8ad40154e1759d2da820c6b5bab48766972de7b8c52770f098078886ba3c8263df973364093898b9c71fa5a064edc0b6ac701281a7089167a58cdc2a14a98db0be46ece7b9dc5abe6802b42a92c8ffb929367a8d56f63e8ab377ccf68fed65c0b9b34580ef02261ea45147c5b7d4dbe0c4021bddae464d0e2020e82cc4078ad93b28a38768060a24110b9d4cc2ac482db02709b42dfab593b414f157de217234cd7249f7b6e0cf5cd2578aa47726e0215518f3a6ac5e041b60fe5217b4cecac0d6c1e35c2e43295bd8a9c6dfcad730d15db9451b2b46391be97c7103f9022a6bece30ad1a5235a385e91641ae7ca3e897608735e2f576eb980ca6ea77ede41c79795805ad8d3a2d0723de347764f81c081c30bde4cbe5e065c68cac4e2966fa2b1646a47415cad1d964e9c7f19417304ea953094f2a225e853dd2cd3c281225f69d2116703717130145104aca7ee017a66c6a15cbf68728c98d440381095e99d3e6ff934683dc851bd380863dbb118de5ef1199c011163b7fd2221647e78d62b9e3252b7adb4202102b7a45cbad8dcecadec59572aaa8df44535019ebd9f5d6b10c61a4ab75cd35022259b62240807fc757e64a6a0e1aecfa957778a9914246e4d519ad79586b199b1b77d9d991c14ba505e13433f89440fe6a3896b80f7731155dd45ad542cac200401c47dbcefdaac8bcd2d9858cef657b70b62099c4e4605ac43bb6c07c42a4c23b826bee89f11038be208c7d55fa0115d4fbf3b70c7553b4f91f1cb496c2ff891bdc87ceb42177224c15938a21dc7c6440bde9a5ef2399a5226a83d14f5fba9f1f0b9655dab5080e4b7e2db57b7cd02514bd90e9e9053b3bd177b1f044fb8f37f2035523870fcb43b2adf65a68cd2f6523f4ca686ac51a70a88fc219722060fce330c32f9a0ca76d714e72874b59cdb972b9b606ab2837829bbfcf1ad39b690acfc691c33663398ebb004b3355f5629225e3e256ef3d4cca351da917f24ed8fb98c6be24837a5e53c9a22b6471012304d5c0eb449af98016d3e1f5e47395e604642406783b94685e8407cc162ab91c1ad3fd89278ba2d0b355498733e6e294ac264e70ac6c4273872689843095cf9d63b70241bc5c98ceb0a4cdd74c73ed05047a1c58e86a900e7ce560efb115431cc83f4ccb06ae83bd392fc25581c17e00160491b1dba2dce1152c78249be33b156f9e3830c6d8a05796d29a2de64efd5fea14910e666fb8ca4d2cca9613493869b48bccdda4cfc8a51795dcdc23878a4d8b23cbccb0dc4731da5f22e69860cefc320e0ad0d7d979e12fee230bd02feb0d7ad7dbf17ce2b9af77f984b94b6a49f2c8368eda7fb31c0e2d5c7207ab6fdefaea1fbda274de47dc33ebfe4a8455dfee70470b6def765424b3719b73ce4553a27b1a762eb5c19f6b144224c2900d728fd0448286aa2c6c1a0db93ef836ba2573d9100dae113a36293504dea7a0a76a9d35726ecedbdffdd0c6c5cf3badb3dc356514edef03166b9c395b37b081c76a1dd486b28138072a5a9787f6caf56294629c03b958aa6348816aa185787eddf6c12714b360f8370e2b8b5667353d2437e017d0d3cb8cd6bde01cd5af10fb316146334f30f0c4cac1ff48fe03aa3b0a5198c5b91d1cf6886b44298a1d49af33c7653fa7b43c863bfcc05f9ec69ffdf98662605ded5e0af93a9b4580d015df02724993485dc0514d210eb7d153fe8af3db7eae9b754f464b8093260e1757b48624674802993fbc3ffbb4e8975b196c0083b20fde9b14a78e8fe4be782939bb5f7fc29e4af1b399b7362dfe2c0e8d1a7a36b4fbb9665cc3930f3e3651ee8f9a038e89b49632bb4b9d42fd8ced3ed427fa3534767e4d2f5c17a9c706a79ff3c7199dda5ba8ed13d5f5028675d6f453e00f314245bfc7ecd68fbfb7f1f416833eb1af15fb8d80ee8a968255f85d734ae4e27037ae50a305592f6d7fc8441ec00b15d40515dc91897268812d1b9346d93349814d10cedd95396abe5023831d7366be4708842c92b910c886aea47eab30fc48eb30135cef2b80388d488ce81a792f933d9d8756c2348a86c296ed2a66c183dd96459c1d21efbfa1ac76473ce756ff15b2b4ef6abe25434def7b195e9e1cc7d290af5ad060c754d0d9fe7fab0d87897ec1051d56ae2cbe3d4ddc4677e6d859e108db7953efaaca989269781769de8db944712f00235aa9cc8b8ccd56084156c98aaade91fc434f29877504802d747a9875e6be6d4f993c940e0c4f24e441e8fd7ffd74af39fe96dbf47edbd06ccd1a1df2443e993e8b67bbb5f328da631e7b280308f050358a47e3fecf58704870b80c9d197e2d12b740f90f467dcfba423063c7cf4fb029c2ad9a6905950d4de3ed68505b7fc72042475d1bed188597f895f2aafad5d6782292033a5711371650dc8b311496442ce3fb8c2549fdf718fdff992e6f877af2c57218291fa97be50def1317d17f2cfd62229b4f9f8f2f1f66117788b95f309851b647782d745246a9f57a8b5255fb2c4b994cb911759cccd595ee19998b5d8f042cf9b8063ba8d0137b18e4b025efa5595879e767b9244c56e1c0bc65ebc60ec5d7ddc82763aacd651825df8fcb5f9d8f4dc54325a3b7f998d2bb3468fd3443008c2d8b2c5774b3d4c6f99ce083ed06f72324be6dbf9fb66cf1e4a7c0ad9e7fe4c2b5551c0936cc44c0f7a54504dfe9e126f84603f023e9da738e561c2d9f1741d762d7d993ef8d7a5d7056028b867eaa933e64fb1bb512fc512cb551728dfa9483c382b1d1709acfa7351795c40f1d1358d8676567fa878408d47e10b84cffa57ee3c042bb4525a4ae0d5a436e67b9fcd5fc6e80acb0e3a38fbc2c8c363f622b61a6daae62fefc92e8a0ac3225b2cbd45192cec17ee7312eb63147ea0f59110ea4de3a423fb5e0e45b635651db602a30ddc918d061195829daf8843f541046d194be842a2c5bfdb4662aeaf3f5e76d6f2983a843dd1ab56af1dea1fd2318f687106f3a7085d2f66cd4bef9bd562a0726e75c7e94ba431cb9e2f0e250760a1a06ccfce07c3a1984895818dedab127919f51e2d4bc0b2ab4cdfcc5fb4dc2d30e35567997dcc91adfabd7c0fad6456b65735276f0034150a06e7373eef47649ec655c225ace6996e20d9f3f9fdb350b9a47920d153","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
