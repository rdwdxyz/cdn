<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f2232af6f6d7e86356e1af610a4ae504d832623d2b807304a17613bdf5973af0667d1d9357b47ea0be9e3069eae94af7d56d92cb9be13bbb9f7841493c1826cbb8f601a5b10fbf162c9e181070d169c1195e1f6340acb5f1f1fb88b7fdf4783db0dbf83252598db23051e9bf3c243b943d2c98c7d15a60fdebfdd5b4f98ccceca48564df62ca59630c8d58d58fbe1f1425674ce36fece2efa6d82a14c5689817fa8871c95ac14252145574c121f8f2ebd7db4efd2d2cdbf4562013c7723ccb515fe2e1546d9ef29708451e3ba2c3a8433b8f3ccbf72a3e7d479353cda1937eb1a3dd489d8642541f0cfbdb259751ac02d4a3eb28142e7a29c2ac7d291cab30164290ea4002015605b7f3937e26e1f096d7b797a80a1b8b401b5a1261470349b100b8183e6f099ea013095febbfefbfb5be8666d9218e4ac7a7318b35a9f1fda5cd0316b7ccaab62ef7f8d431cf4ada2285e5fb622c0cd66aeb9e2ce4349300a4f4c5e7d06ea32b9bac3081cf18ecb1bdbd95b00a85d376d81088914d42e29171cc477f1d8caa05523a8621abf9ed09ba47a709536ccbd6e6661c1637de0023539bb80aabf8b530644107e8fc731554e0d3dde62e16df213445c0f6652364853b3ad94aac840741808d694e1ee0a9ac835eb4857e996866c81e68bc99da6b36367d24f13d9ca149710eef4ff84177cdee9fe8e15a3bb4ad906eee41aaab9bdf6df81736e0a72eccefa00875d493490d8311b7d746058a2696795c0311b3e14d041a0d379be90490b70fff8dc1e827dc4fbd80bdb30d54ef4cd17d4a7953eef66dc572415e18e4086dc5bf80a6b872ad7357ba3b4cc366a3b0e7887500be40a8d15e6cbb27793fb28930a35631959a38e22f72937192876a0a420495e6d782bc5457279bcf20de23264c11a991579ecebbf9021398b57632c96130ee32ace644977a3be6e7c2bfc6b03e53ea081dd1cf72b0c4366de60ec66f7be5c748173dc767df0972cb21add55cab836fe7a2e623ea3866d083ce0284d4fd1308d625c3db1044707ffb8c2fd232f77fa00070190bc50b61e576a339ed5c6deed62f9c3c8046f68e9da12aefa881ceb9e99636e1fbd38b4d9a742808ff697150ac17ae5e4c66eb30d1ca8169709ef2f93038846c5391c75d640cef7fc972f69aca8e5fb94b29c61e94e87397e81628c56c94036307cd778b8275d62ec1d11008dd6f0d5b19498a2f4d489248cfbfc2f49aa4ba5ef99de910e2b72e490353be614b6261415e09816317deb9ba712988540c213269b22c7b5fe61e852960377b0b56d3df98dade7633689e273174d1f09287dc5760b0fb0b069ed179cc8c533e90838a6d6f252eb2127f6051129d9ab50eeddf085c10e5c3d07fbd190c1f59edac7a92efebfd094131927ee11fab100667c89ca8c6d185757f692f661b5fefeb7d5525bb0ad72ef83b14adccb4f71112df1e14c5de9180980310f5e61c47df19cb9926f2889f0b16610399d33300452a392f787a6d35043f2eacf283d5b5d45d1be7f6a28e381b4c9837cd83108ebea8b2af2681026279ed2131fcd8690b68b61d8c429fe31a45bd46a089b37c0693ed788e07c8184ca259fc6937a574eb637746341b975b487f6f259369c75732f7c6adde32882b9cb49837558384bb5431fb7da1a389502c13d57f70e3e1dd4ac5dddcb7ad8758a594fe8f0c49c2a28e934da4a32f37742ba5b8639634cb3061b0b88c9b0bd660c713b964047cfe5316c2bb0771f5dfc2e8516d747c343871ee5f299f2efda346e8ca04df573405b91bfe85581a341a0b0509201228593f8f379fa516f85db069ee0872ea8ec47da01103d8d51c9082a0448800ad6d1fb2761ecf4a9597dd86464d4efedf999ee71d4c8b95dbb9b0aac880cccc8d701d34f325194dedce291f852035fc2f12c79908016f18691adb227a50a22c781da327c88ec161ac84be73c1595496fdca848607eba53d3cdedbe2c6f56d7d51056aef80138a3991c3fc438cb759a304761fd7037c19d7fc75cb9dac6e78ac73ebbbc0c455477c6661b194f4f34c7255d9c8100a593684658a2ce89e366b56633ac660c6396186d5453a5101883567ffb99cf502548aee22366c82000a95c8dc48f41ac3c7d3dfe3cd3ff8095706ece9e525edf1907b2ed02eadc7831c37d58ac6cb1461e9b23c1034264e42c5025654d244560f6d98cb65a71f5c76030df4b6a0c8d455410085c42468f05c466c34fbb94d51a302281746f5aeea49cd6d6d0a3dd7ec15c143d922c6e57bc7c5297e6022360dc2a30e3b41c425e158671412320f6bf9e4c2d80dd61479db52418c1161fd140db8dc7623d1ea3d5d62e7463a0b9642f3dcc994d41156a6b547067d054081c60ddbfd3c6abcb81cac4a50bd7f796e1e537365590ab2d11665311725fbf8ec37f01ae2c24323caefd5215f380f5367c28102b0df2e93644f6b2c6598480ef7ca8011715f87c6711960f102bd2601e596523df1e38fee1be9cc198309049d7b88b9728070e885c0bc0b7265810f879b29b360e07d16df374abd544616b747878ee74812b7120435909f801ac089fa4d1c18f28acebfef704e9665567b577c901d22b5a8ebddd1e1118bbc7f572155eaf46bc92e393e56980b3aaa30078c9d70bb58a5cc1d71bf1a5a2ae9ca66b3506792d9535717561d29e1bbfe849b341d0f841ecf530813b72f2f11596ae44b60653a72f8ae00767cd36f756431485c4611436799bf5e5533242f68a7c92539f3fdcfc85ba5de3d34b9c8a80b308e7bdca1615bc22f39462ad554c949f0b32370d69fb5831bd94b16058222d3cb6e924bac08a83e30eed4588b158aa67462b85757cac221f56c003a325498ac10f675e76e5ca77ecd97fc37bf41e4bc987a42647174f1aa3af779d4cf0117e63a195014cecb9e1d150994c4b2976731eca3edb50e5af3cebdb50f392c54d9a88dade88b78d7be4f3460b8005609153c482e98f085d44585e4879c4c00eb7a25feea41c8cf6d0356cd0ed773ce0390da1f9bb8fbb7b0144c4f6189457c36c6c82b869c8996b8305763b7dc217ce9f8dd8537355b7ac888de7ba5e834b5a3c6c0f75f1fccb4a2b1d1ecc53b8d01ac92551e0595b3951e536e5873218d2c84fb42a6d9885087e0855ac1bb3c33013f9a057f20a9628b91e381c1f437e43690cd40c43ecfdb1378d33a46dd7d566a5832ba833de84cee5b57c480ebc3ca4ae3b1d9715063378f6d207785e1cb0aa976a0b14f8eac96c691d3b119bd31c442adac9ac578e4080157534eb86e5feb50be380474fe53592d3cca5e428fb990e7ccf73c8699c36ac935adb9728e28e604fcbced7e4cea3ed74bfa773f2044aa2ac6b86ab7026247c2d0c567a879739e7abd11ecd6c509ba07b0db0c2306b9027191b3aac80b78f792aba516256930c5dde0f963a2079ea0244342b61458a0ffa586abf1e71da2d0ccc6a98eed1378377f2fd9cc41a050e645fe2b31453784a1255024574ecf05c024e60c7602957adf7083ce9d638628482775e44d05ee08558cbc2292c00e6e1e422d4de3493d2114dbdc436761f3da4e3b09c7e8c63b858b87d728d6df852374e1df9c49228177d2ae3c7183a9444af69415a386d699a6b61bba8d58318f50ebcbcd44ee90ffce8df309c6dbfb9bdcb964031c83cd32d035495674fe3b3770570274a6f51b519b148ca6ae62942d3f0c2116e040bb236a99fb9c81dff9a61b034c2f5168654afd282af85b34ad4f8be30fd952b9791158030e70257c9d7676f8f46fdcbaa1e8b54ff85eecb4bdeda1b5d767d4e0858c12318765d386189e442ae559bdd0a8b67ec0894018f6ea03530ea7805c82ca3b28c8322c669d5a53513741ee85ba5087c4afef92dc66fdcd275851e9700a7b816251de58ab193100a34b68fdbdf07bbea79165ca5512b69e3bb17d1c9a3d316ba04e7f2aac2037a5e84294bd36248a792d50493381ea17c57c05258f86354040d82b0177a1ea8b991a4263315422265d607efa02e24bab8280c9f1e644ae2ad3432e68845ec01c8615472f4641690dc2223418993794f12ce4a89e5c39e730b5f55acf87edbca10e80ba06f5a51698e1f40af74bc0beffc06245cf2d955c628567def52a0c0e3fd297c9a6fb6641ea78a31c726077d7a24d95f56ffd4c150768c58d9c16048b01d33b2019deafc1f5f74841b1ce20f01a6ce1863549bc8b16aa90ac422e54404ddfd2e7c0bcbce336f41f6ffc04c866a194bd2a1384291fb88a15aadc10da3a8734ea7bc5e090061886a471dec61a5ffc916c45f2e79e2add61f2be82d3df7110ee32324082c1b2c345adc0ec56a2641ad39340e4774f8be6e3f80502c1820a51e68a4740b57e3823e2d09abd48c43b7c231883a8bcd44328b006c4f587087a9fec42b2ee4a6755434922a1b85fee78c759154e800385082995a8f5b16f75e1cc9d1cd6510778b21ea496c7fd6a3ea89db38d166092923170bba9dad983b95b72bdf93436e0cd2048b9d6908dd579f6bb322abde7f011b617465a276344d36aaa847ba918bb45d32239a66d0368532748252a9132ac455205c8251d53dc4504f14c8cb34b0a25da584c9ed5049f1f101d696c45087044d40a76929dfdfb331467514dc5681b68f37ee1865c26f8ee81f4b4ab9745dc85512415e2294fff71dd2fd6631c5385144ad04cc4abfa70a57d78cadb4c25f87f871e9594d207a200981692daeace827f8fa1056491c0166fa92196f60411e6f60ea32ea24ee6b6eb331db40fde6cb3cd41aca2ea92ba3ba68de523f4c9fa9dbb4169d4edb7d7233dda77a59fdcaa78eea4a8cd9e0feba34aa6c71f067bae13963a634a7ad3e086a3369a1194b63e91e5b070c04cd06c899cbb2a0953dd726d55ece891dab34b11f8ec70d0083eb9b1de4c93d223a71d09c22b32ff0f64bf0739fb3c38d83e768b6da640d3a0cbebb7673ce9a3352ad0102631eab7c9b17d066926f4c1a49b9b999ebec453d2c5611d3a1ebe1981f4235d341abc0f9dc1b23c6109c6195b94d583b193c39888b54f6d3cb87d37686d8ad71a51b9b1401cabf339d4cb3bc3eabfee2a123177a4451cfd3c76a3e237d7d7622e20e8c25d61ece1afb6f43cf4e2ab98c2c4ce019ba68681cf4b8ba78b3efd1cc2015ea89cf96911a9d9e62a3b54ee9576173f764952b3489ec949d157e89e1bb50dd9f11f56ddbdc2d7b9d66d26b60da32d283e5d13f2d190e56f6d502d2847bd025f0c485bd8331b2605b5e2f52c002fcd9195701239926b2c74ea918ca6aa37c74118aa17b1e956fb7f375e5c3bdb29c3b7655fd07da0255ed37e1e9e1ed98d1858c9be89e6f5fd52491e9e610ef829dc7e87d4b1ebe329eae449772c20f9c3d2253cd1e9b8f80ddc9f303dd479f6929cbe3ad13ed584b512bb71e2a056d04ccb81665fc238cc49d388fcfbf8814d00d1b290ba7092fb991f05a435440987dbfa13bebb5653813e523871af497929c221fd26d1997227874d329dcb33451403ac994aeffff09aa5f5324c64a7f50f59fa7e6fab5bc5351be9ad1c02b2611b1c13df0ef6aa6f5e079922a9e617be0587827fb83510d438275c0f3480311d422dbc9df738a6759f3a16a6ab478ee409a20d5636709ad194745684abb3bf063631fdf605f5ab10c9abd86a4342fdc1343d1f83903b86671f6e7e6f7f2f1e241cb40025f8b11e779eec1aa6643e06b248e452d9a059b6a612b8a1c67f995242a40eb27fa906a739c38ea8826a492622e371888ff1516999e5df900526225f32dbe40bf2cf9adb2b434f1b82592b606c4e4d102679b2dea2b6dc969953f1d1832d79581a61e70f8e615c879e5798154998c1e965003e296273887d846b03c395813e20906d32f2e1de7de7ba7d801d0a740bb698fc34473d6ba31908501572c61605880faa12a47eeb7edd08a587336b2ab0d5bec331b2993ea5bc54c3e5e045d8dadbcfb606ce10cf7d556b6a92ce44b239c8b913c4d50676a83a5c950e552c60678f2e6d1c1e826bcbb56da2edceecf843b509383e073cb1c8f73e17fcb63dc26390f8fe21fc885028c289638adc5f8c05a3fa7bfd25585c3a474f5fb5653cec7a540f558bd0580f71684e8ea107320ad2821043bcb3de9371638dc859c6a254c151f94f724ed69ecff1d231e78cab654bdfbcec3b1a653580f24fa1cb595726f2a2d4c580707d5e553dd61db764c5041f8be5633a15c200008f920d2dbad971cd0b4a6eaf276d4adc20cedbf80e2001b8f89c9480f37c90f5094c5ae403778974abb8610b980661ce272e11b05a2b27778aa141b1cc9d65d72fcb80feaaf6467ffa137f9e6540cb60713e31115a2bd630279156e47e0f6f6e82a78ded01c654aafc1667c7abc08c3aa491af126ea0a6261b9d3c19c9ddee85e6f16505a4e18fc5e5e5f91c27b56f2344d7b8e20d5aae208be836b5cc5d0a1a89d3a3fe774c6412671afcaa314c13e212e6c845516fe54eace1d9159cfc42ac94ae7521e9388ebcbaec98d738fd6282ec551951cb655fec9350d0d75aa55211d69bff4a70b33bd7358dfacf9eb980111c57c46e51041af46de58b80cf4dbd10c94402042807e5917ed3db44dc4fde9cda4fec283cd27a8640aebd8b357eff3f014b68b3b172924b28cafc4400463bd5bdda58cff78470af5d777d31438bc171fee57f5a6332619ba3558772b3866299a009949aafdb07cdbfdee5006bcedeb0d9723136ce8e4f3ccd25e5ad3d4304fa60fb4ee7377934ee636442c7e81419dfeb1cffaf416aa7634133687c0ccd76b52d00d2bd11474a42d67180921bb1dea3c20809fcd48aaa1ae57756fe476534bea9fc52b654ab441a62aad639d7b1903d37d1b0c47bef042ad260f1a500e2bb58577f7ce170f79d8801de0ece7dead55b4916732a019832dfabee452f699ed3f974845271c4a16473fea9cab8491711e9b6d30f64cef308f7b3fc70b4b3888d34425f218e65958cea785dd78eafcc628d3ac1c814dbabf06f0cb4ad191a7e9fe1090ba811a6c582e828e8937146b9f49cd8dfb1882cf5e231270577b442f5a08c3b6d624d2c5ccc3f677b263623cefa64b5167c9aad6755407fe02e9c452554087a19880790dc646b9b752c06bbdfa0b9a58a551882f36b865905c9008fe7030f8daa1fbef046c34bbb7c9449d4405c21086adeb9ccbce4473edd642748e1752a5def23e86d1ad8879949585974241780cef8f857e2892997287362a67d02c5c50dc35d192336c5777a374e55720b1d2cceb5307b20d11299d31ab9b9f3e3c977dae768cebe7d49cef0ab6cd5fbd0e7c8bc07f87aca56c4389eadfb51e495dcf741bb23341b1e01415c2ad3d31668f7dd05e9317eb6c203a351fa3a5363d6e64deba1cb58b9354987ff8127df1496ae0067bb5d74950188eba0a8c888287fa87d9808b3d71408759592dc8cb70312482f2a1741789071b23918ca4702e120fa71c5b21cf4cd75f0d4f95e0f05a6210ed50ebac79249721e34dea7dd2da02a84e08f3c52c01ab3f45b31ec635bd3167b44679d03470cc74c698895f719511a434122ffd52e9792cc94fe4eefa093e2902b2c4cc8ce8f10e49c32672b3c3490a425f8b1cfe3eb8ba590ee514a0eb6a3ae5b1d9173161d47a67ccf906e49a67707a4ab9b3da4638bd5c3fd98318613ffe20b56a9fafa8972ee07403b835cff378379c3a486bb85dbde2734d50f044bd396d55b1f8311677d82cca3b098ed275da73cdb61d25c1182dc8209c757da72ab0876c6c9bb8063d9cab38566083a1810bf3ec7c665f012c93d59c4d6f76ff6232937ac0c2baf6039d387891a0cafbcaf0491a82ea7ae45d405d74c060d3ed00fb1098b44786a3ef23a81b2400b6030225503dd5d975c89fcd9694fcd2ec53199257cc02168d0c1b66ddb682f78c6e07c9056108d3e8d3666ed4fc12547e5e39c62e0422bc638707fe530f76b55e27e9320f82af3655bf4e853ff00f8396cb24064925e3e3501ad97c79560e74ade5c7bc12907c4e8ea5cb55ba5527115b3bab34ffc65afb0c376698e4231df8259c9ef8122f413eb722cd7108d4e0fa30a4f5fd35b8ad4bcfc3d870fc6180305036443210df9ecca6411021ca28efb158ee2c1aca0554a086068c3c4bfaf905d9d071adc95ae5bdd607b07ce86dbb178f55edf7d191a3510dd0c20d2ccb78416aae9ea7499fc19cd7218c2e1853d393042a662a358395aeb247a86e35d6bb1f0cb42fc23908c60eb2edec6ced3b4e6beb2ea95677c44bb77b762b1eff5e25934adcc510a4a4d1e552180df7b83438721f9cf4ae8259468db3dd40f3f3fb6513c4224f8ee7939fa4038a4d5eb073064f6bdb3be6d98d88b2149bb8aef3fbb1b47aa4d2e61adbb9caf1d530de29700d23bb738b6b4534b058440601e953a98c9fefdca0409905e7cab8e887538ee5795efe9d0ee08c638806843f74a519a17f753940446ba5038aff44fef0d4d77eb79800522d4d4cba4a529fc4b5b1c9464120d7a97ee8798714d340c51d0228a4b4ab58312fb125e8c4ddade5aa84a27b816c1402f334b50b7decd487066b0557e1179f08ea5362c859a8021ca691c96de13f898cad48f71ff44eeedf17ccdb451a3aaae8c162e79ac73d80e14fe814f75b8902061a219f124b52e24d2b855e219623843c679c5a71078cf13c3e07aaa0615d6edada8b9ddbb4ac7088c4e42ca5e62777f6e4c4c5cfb06d775d23b979036fbf7856ac8a32df40ea55eac9f0fb72916ad5aa63688502884572ef45ef09f91bf6e0ae9193095eb0ec82701dd1993fcf717adf9476eca5688e080a86024c3761be7c7b747a52ce44460c547546e2a6edc9525d43ead306bfbdd125fc9b6c90f34f6f73fd888570daa9a972fba79fda35fd7652b87548c7f9ee54eb860aeaf8d3ca4cdd99a4d07590e4f024af19792fb11944c3fd19505eacfbd0f328efbbd22ead2a08164ad9c730247c367394823a0674842629b69b7e91c4fb851b2815b4f8dd3ec797730a13d9835991a44adb9a6e6414f9ce5c5de60303002a1f3b3e94c01a62d8b243dd707a9232b270364c7967579754910ab2bfcfdc9f31738d0494ed1301b33b578ca6a94f99a6446c4f7e9b38b1f119fd7e52b52be0fb6a257f3ec57f55643f1f8e50d2117c310523bc582e4920165998f4e1565d0e14c207d6207750529b8527e178b34fc283a9ccb2d255badf8cc3711d8770784b5dd7eeadbf92148a23e5e05766aa18b6b28e561038336cc9b7e39e688d45159bcd8fc857e04ecd552ecbf876084acdc462c5d314a69338c4ee2c557b243e1b5435dc8a774972d92b8653cf92ce9e66743507bc0b85aff4b3bf02d19dc1e96d6aef3467cbfe9c5e5318d7b68c755b6362f1cbe47fc0b94e2a8e81036597e1ab56658129ad2e86b0d830e360aa30f9a9cafbd84b96e56b0b2926d93e9c9fac432bf0e9eac99271b48d2e4b85fe7d892aee62ffd679a70527c2c5839b9d8ef98b07794bffe36b8444c5bbaf6499794a0009737cf82b6bf5e94abeb0b541affada88f3a723a038c054df9dce4d39f933bd01b2da175f0ed1e329757b0e5b40c85bed4649918e8eecc9a0048c4f1ca76d918781e03abe1013037cee204b4772ff6d848dbb53eba6ca11f7a10fbe3c085484cac02328b469eb523af495d8e75314af4eedf162a08f6dae05c6ac5845c5dbe5d39aa0d1361c0e1809bf158fe9038033e74e8d9f3338f54bb477c2b71ec43fc4d426b13653c89de4696f450cda669ea15709ccdae3c7b6840ea3a62c1f4bb4b7c1a5abc951d0536c1a178e2eb1d39a976de6053255f77163f25c4629bcc73d5ac34850d4c5858db90580df467c1e7e25affada52b6e9ff05180710e8599fe6ab4ed635dc122b8e1a1537a41e3857165ac32110a0dd6cfc385b1a1f823d8751834d20a2bf7ffd9fe7e0204cbdf888e26d8414f181718661493bd0021ecbac22faf444e9d8dd00c6f37b2a556e7d529fa1e60754baf74be61a862bed7f05b814e77b56218444c7f0b111fb50ad3b81030f860fab4a07f88424094fbcfad5823384c6a263863fad502cae5ec965eceadb0456b78ea22e0dfaae9925cd71c35811a29a3b5bf6afc249fafda2c8390ee165adc35e5c349d732121da3188f703c14ada6320fd3bc347cbd376caddd68463eedee439f15f86b13f6f2b26a8a88565875dd0944698396d9b144d5a92b772e6ab8445a3be485faec526e1b7f234e6a1b1525452cac4d5fd326e0c0b90769e9d5e8d959d130137b2283baefbe46b9ee85b46ed8e9d0e538c32b7aa5276139c9ff6816c9611d5127bbeabdb2d6d5d2ac6dab3912e9be4e14cd18ab30aee4127e2debb321f748b3a4d059438c448edd42a7b0328ef03cf92181b0e72b4746c6f93d76ce0cdca080a5a01ad46e44483bfc7b8ef7f9b77377bdb6015d0291a857b690357b553c1b56559aa9a175438aa073153e7be2fd9484a4ea9bc96f7d9bcb969e1f26880d9fa4fb4c12ec0862cacf5510b80c19edda3feae780fd3b5fa5aadb4eeb634dffe63e762bf8b91fed1e7e35c3a49ac5dd64278b45d3929a8656250ae654c978270545367ff19d50649c22162747f30ebe4426cdac5b20fda350e2a5006b7b492f5427f04706eb29db0976d9e695af358d7ba7ab5244f9d626f99eae6b7f8fbdee4bc3b79abf6815ed72f003b090bc5b03ddb0fcc2f2b79443188013d1a74a1a682a7786d80d90c35150629386cc49debb87346f3e66121b061c071e40f56ca1568c7f6161b0f6e993c1afe13cae3709e19c8298e31118782e6c1d8b1d0ed5197246e8b6473cf97fd6708475ccd17383426eca49e0ca1f3bf998ea51a45e6245c197b709de943acdb7fd92e6264d078aa162d0028ce61a53f2b543adcf39fb84345e272692bbf27a043dd2d6427fa00aacc4cd8cd0fb41e5716ecf951e5932bbd4a4464e43b951ea7b464e2b4f5661ec48eed4b5698b70cee393b4cbb2b4dc6ffae7ea4914f0bb4249da751821c950c43607c2f8fb2ca5c22815a83aebbbf868d6afef801a365bc1a89aa53ece56e09d57b06dc0b05afdd6618299ebdc874735c0e927ad9ec79252a49b86d2abe2655380fe55e83d2f7c6fba36066bdb7b81b753991818b0953d85782d56ec012334c2bbe8d906a4bfd3243fdc7a8f4754e06f2f72ed4fafe13da97fa2a3377d84eae3c9ee24a2f5424ee23880b36b011c5233afae1f8585e98e3122e60df419b2f783d1f0c2e01821bd6bb533703e84a9a140fb2fea4186d8698d02a0ba80cb5d80d74351789f1cf0765ecce1a414756f9be53ca7cc9eb92bc149a5152b8a93960d631832e86a7bcced76608b3baa2b199f054a75b37e6c0342256fa605ca2d6c25a004dd44d766443f53b47f8dac6a9d58e4d0c97b0da0531d5e9bb5aae77da07cabf6caea2b1a10a7ab444f20f491de03cca9283f150c28a2ae9dbf676f7179fb4e048d1e14055899f86b2841bcd9f9b36f1bb42ff089759871eebab4d5baa5ccb9d5e93811c57a246132a4bf80e2cb67f7c4bff548bb8550083d144455f0f4dd1dc06aedda4c57a741e04baad5ea6ba324e65e0003eac5c5791342c48799c466b816cc7cfa2ac7fe1f7317af55b904e71c83e32ffa117722ccecd349e90fadc84a78c6a35442db123ee9f9b0138bc494a594ca27f69c20865fc58982751fcfddf10c1331fe2d2bbb7a5be92a02dc46b4fe1bfbe47452816e9164d6cc9b6e300b8a1ff5effe2ccfa0bc65f07e2114d16fecc87926ab7a9bd7f9c87eaa939814837d1b62b9b5e065220b1182edec943b6e1271af80407c29adf3db1e51e89417b2a42a81ec0be2c1cc1291184651aeb435d33607863fac5961a6013eba22914986c86e39a14b223420ffd4c9c69b9f858be8b4dc753e422552db51cf23cd569645efa31b65008430f97654cf76f7176f74fdc589a619a2d7a1c34cfbfad00aea340aa6c15176f58e831b400a4431714ab3a931662172c1381627369941ddfb8be65b2c4756be320933876d841105f0bce98dd86f820caffb5f85a700fcaab3a2544d3b5dcf5740a9e49df908802ed8df7325befd576b9a6b79ae6bdc0655e6525fc3bc7c4466142b837a4c4aecc11bee4b4f96db00586611ea82dcb827c0e153f2aef32b59604357b1195690cb492c7bb6aa963094306db1929e0c0551e0b75091e3dea1762a4d05c16ad803ef943707db0e9570d1cb607244e353e4bf5d3e1943c4d673ee74e7641493538bab021b1e68792bd507c4e455fdd2dd8c97f7c3658811a46ffde5b4c1940d32d1d949cecc8abac68015aa408f0feb942ea031589eda04c7ba549ffec121d79eaf13db9316ed1a79b68c830541b70449e0b2097bef3fdd4c9d644a01e502d881d642816e45ebf924a2179da480ea614d6ab01e4f7a4ad52443a60be958862f77d39729eb819411f777a6e057fbc86330945eda810880ad1545c609f1389831af92abc0f0c6c101996c3eba0c9ae49bea8f6bfd2e2f0e39aa94960ce9b20cae8ef2253ec216abdb7e7291e5066c76f759e59cb30c9eda56ce3d1dd5df2c881e32b0405487466681b1f7ab2ff335d5dbbe11ca078ccfa7ec21cb0fb06c98d22e243361002e5684be7154c4a6fc5568dc70e09952b96b623f72bfc6dae2a06264da10421f31727e82255f6e3f4279b2849e60df0a858536f7680a265dae9f74a539bc7f245022cced10ca70ae62f8aed32564e7a480997444c19e88e281d2369d4099ab549c83946a6d0aebbfeb4ec9e6145e7627192df44a8c85fdba69b6df147fdda2d890e161723f19525e007d7158e19e408d2174da78e2a03bb0b166d71cb7c203cd8ee18c5723eba97b084a7fb314964160992f254c60aab2c651b3298395841867a4d39577286645954ce3c8a4d32dbf2e3cf371b745ab649a24ab4674476ac9e6f7de8d2b9a40c434133991e8e7bd553a5a78b4aa3a99575ff01c06ce8275c782473004ccf7f8728c7428cc42660100d5da136b15c2d131b9136874b12520bcf16c8b8a1ef36d723df208d66b6baa3c1d73a9be6502eb3d04346fe577b4c5196203cb7304ea39a2e99a9f4c8e032d9ed70ae4887304bd986b62bfac90322c1155cff2083535aade13ed33b3dc2178c91c2a0cc3303bb26869b74a416499dccb0df15fa2e29d93ce8a2b739af1ee0a57605410d2b6f87550b4c6b8002343bd19c8c06e5f125204969308515a6b57ddf4101b16ee2c8d0962d5d7862d72680403d1d6b337266ced1f9a509a30eaad8f85da8e279dd8bfcb8e243c70b8e10c719394fecaecf4ea17139c2ee25b9fc392a63f5969c8e9ced4062318ad80fec99697073300978a6dbcaad38a910772f28bffda5fa85fd5b4ba765c4a8c85fa8e1b154b58fb0252439b5c064e523fc314449db0a2611585f8e75a4007537ddb3ec741c7793d341c35d15ba5f460bf5ea03a259c8013c5c68c232f5a34342d3cdb13a4a822cfbac8160c936c4ba673f700878bc0b5cd1afa21994867420ae7c76d46b9f400e60d58f51d9a48e3d573e38277f85a9f84be1c421e97029f7602804cd853cebc62e272afb52e32d261b7134d562c38d67a42f3cd65e1f55e23ba816e2be1d3ffb27e3a21dfe7da161fd569f3986e43f4f7020979ee800bbb31ad4af4e4df6be76359624189f491fcbf9bf4fc45b1c1690740d5c27a3de6573cefcd3dd2068c78d7119a5d72d2d2d817692ca5423e1a2f1b986b578b2ac88910ce3ecef72f2c5e7d3ebded29c69edc870cf8c865c4161750080209bf7e2450435d4b0f360d8cb303ffbf97f24d86acb7f7eab8f582bbd29045872d3c5db2e3a02c9970f472ab624a4fcff164aaa4853b69b4c568638d2cc56f5623f4b392a6a27b37cddf6612929bcc92f7b49282c7d3122f28f5a81f1fe0259d4dcfd9ddec2916adbb02668e65f357267578be36c7c331eaf30d2cb2b7284368df9b4d701dfd7d828aae2f3b443ca0807ade752ed90cfe91c37d97aa08bce8d89722f1f83dc85a8283781415ff51dc107e830bd325ed185401ddaeba6dc4a89237e1cbc8ffaa6fa20a67afa4afba7027f97a278d9e6aa84a8b9ee06e7b2090bc71b114f9a036bdff4417a233b52eb6fe8afa5dafc01518d88bb1520c331ae31500aad3a423584e6dee109c85cc7da170067ef8391408f3d2b5c6b96c90bb6252aaec81520b6c4eb77f391cb8a1fe193ad9b40effefbfd70dbd783dfca99b39a22eb1021b1ba63021d25b281d1833125ed3dd429cb014d3a848b74c85071bb66466e45b868c14f45abe621de52e6c24edb8b62f6189b5ac60df843098993d01462b1c4e4edb79cf44792d3ce93994390fc165d549f0bd53c7cc3ebdf35f206457271dd5b00b483b4a395df474037165b990f29e549a13b4001cc1a96a088496178465cc44f5c80f5de3fdde1e9b8984bcd51611d87a0677638b9fce0b30cc25be846cce8622bd31d4d35be059b33b11af2ed6556f609c6326052ddee6d00b7199e19752efa8f495efc13e7d41fcc2792cc932c4006252f4b5d20e81c1a88597b0fa65d009f37f42b98f5b8904ca9b8730bd9dc7287937729648adac8eb306a4fa407c260c9cc8abcd459eb0e3846fddb31d29d49d1fcf16694103e3df5757ad944bebb749bb90dcac8649bcd80fb126ba3332bdd7f5168871169d26a4fa990fa97bdaa6e09ec59af6e0db047d671ea9b7f68deb63e9c698706916d126b1e887c1c0aadc97e2ad4e15e509bdbb2944a8a081ba4452bd1973002db808484e741162f9cc03134f9533755df77b2685c683814ffdd7eb24f8c14b641fcc9d1ec71a74ac25fb8bad8320d5b4c7a031220c9f305329f73fa0a4b411e325c4c970ca3bf826fadf9c3256f87440a1e6610a34c6f22c2d90bab1be6ca188b434cd5f42f1807b325c6236ffe33696a501c8ff719b3dd4c49305f90955c4e1294af6f972c2f069b2275e3f65d4d8459fbbf4e99da0b982b189d8b9b82cae950890819822774865f5e9356635a2ba711a85962dd12a30ff711366eae6ada57d3a49f48654c52c326c203c11d3c9ceb16a39fb77a61668e79ad78a1acc4d1df8f2f3f1ecdae1d97cf529358620e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
