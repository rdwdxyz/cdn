<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"745b11d925ba5130581192cfb8abbe0e67af167fe52360491a35f7372ee64fb99c969f873851ac3887e6610b4dc0bd77da8fc32754e8684a209df2bc939644aa5aae68d35b5ec3f142ebc626883febe8c556e167d203c22b0d7cd76c8822e27061adb840afb849d4deccabf490349ee1c1409bcfd1cc2581bcf0261a5d7aa8e6da1ef9e5486db404f7763dc1815c647c603f2fe3c11178346878c1ae47f0086c62092889c89bdcebb607f877790a717ebd1e41fcc81afecca0160a2cca27cbc694d359e9c62bb1ce91efdcd0e0543c44426ebea351b3e6f31bee5814af6450792939d7c71598a401c7e87d538560c45a9b3910975617a843050018cd159bc74fb7083c0176052df48807e9cce7fb60870b15b2bd6a3a92a9c69103845755581a064256ef1fa29f92e45a3bdcb357084b5ee03eb544331227885c5c3f26bea0010de9ea32e14323197dd04de4d50a71adfb371ea5169659b8d7175131759fdf9a57f4ee8fbc96224aabac31e7b6eaaa37a1496daebf4bcddce754bfc1ae7c22c2a42d12a59adc8260bdff264a91a181948b0433f1e4cd5558e7522d3f4e6bff4286da51a689528509d1f81777d72da0e636bf1f6f22729e3fc13a58ac41f13f2132bbe1ace2784858b82bc27a5903789ea31ff6b5e9d3ff0650cf8832fbecaa39108e8718ffb3822fae35a9e7cd8d4740318609f29378b67109ac47e943b96ea6e13a025ac5eb75c7bd2bcf7209fa86d4a677e026c7332fdd1cafade0bb6afe56be8d49c2cd3d19698f65bf318a31df754bf2529f8c3e0a5bf4ec66eadb8469a3748fcf62008c9d38ff1770cd6653c741f4c18fdd92588911682d1a1394d727430a8b95a32b8e5166dbb6f7e409d207afe038b6d57643a68798706847243a2f12ca145ae78764adb40a1137e4fb573ff743adf6558ad640ddf31d951b59b4bbc1046646e65c05cb416bb65e0f77d2b4c49fc0afdba86487cdea21945f1af4cf6ab79fdc91966ffdbcd562fc5994955ccd90c45bdc4068e5844981becc7127b260ec688619291a513afeb383598019db680512cecf22f4d4386155ad1874a31a6e06dd8e4c75b0ff0e697458f3e25dd2ffd83097c9ad7a809cbb0123c9fb009971d41daa9ff19af50dacc27076c4ab15f8c7afd7abe1fd1be7a576b786c405f485e5b721fcdb3764911b465de210818bf01320a924094e937007dac47810d85b0ce396388b35498b6ca563847319056742d67f3881b93f146b265323ac068ec35cd7980da6ca2661987c0a20a604414101b46525e802274f2da6a25120f873b118d6e88ce49c0806fefe8b47f79a833dda999ef1ee85ad3e39038292e811a6255b304735b199b024a44f11e40591a1ce5261e79faed0565948135387213e534a446eb4be2900c5db7f1f0b01e72b5118975736dc0232c02772c736bb84a8e07ad84baee51bfdc7e221498be866eb65665605972bcae2fff51ce04ced9d9ba6267d27043a2d8f76942fa81c0cbbcb4b1242bd90789817dbb6f5c8f9da8b0a686ec5ec8d04ed23321fe47683210a01aba0d5c364a618dff8d809e574ffec47c9fdafde1ec1084dbf6b11a64aab892b66a1aa64d8ee6ac021736e4fb59f5783d8d00622e24d488aba4cc608759cf55054adf019c2bd678c89f314ce6965bc9702a95b6bbf48c65767f73dcb1f4f3125207fcb114a2e7d04f4ef57d03edd5de87e5a96d083355746a03ea102209d8b6b6d4eccbedda92b9b494a6912e63ad12e4192850fd1539bfd1fb009667f7dc128a6c529b558ee083676043619d2cb3f3772440633430768682e7edf5097c1146ab47606cd9094e960365790c4cd4dc3434c874fee0170e43a92569012678da151cdc10d92e1d104fb11f4654b3ef19920f19c7cb3874ed12bf7eef1b6239ec79eeb149cbf438f98f1406b6f682598e45cd9399e9de026cba86464b4e924d2c1a16c11b9d68589d1910a3d8025290ac1363ce8959c2aa25834e6b36928b2694562eb36b6f181e979a7a984a1cb53ba723bd2073ce304d255720989f38b76a55a0c5767eda9e9c2776613781a1f10e10a675f5c104505dda5aacc1a99f239a18f7d86f36325a0df39e7fb11e2b1f4bd77f59fcbe00d49d7d170d64aa35d3c45cdab6eb364d630ff4c39509feaf936675ad7280de9463267f8cd9e4a4169e873e07048362fbb85390675d9e61cf59ce06c175e73b98ca1093772cc8606dd9f80ab374e716b5b2293d1ab406e375a51f695697df8181e64c64053330bc00d206df163c010254b210e680dc5c47d12dd90ac32d9e7834858a8594ed5cbbfc57ba7725e5566930d5669b6a3bd0403fbf79231884dc718a9dd97bbe661e72a5357a61f689ea57946c3aa118d1cba91d2b68f3fdb3d2e4271d99d85f5a3c77222c0087fc94b1bf0ac77ed19c40788ffb15a8ada0c6f68609ad4555427c573bdf7f7bcb6a15d6b99ad0e036959a7c5f7c3f1018e3842274aff054637f5bf2fe2cadcee0290c350114daf477ad3dd9bbf78e2f010a3890b0e60a2a8cc2389440c4ba7680201b9f6d4f1870e7ecbe0e4ab1c345054ba80aa498af2d9ff171435b13f47d76c8b347792f3a533285815034da0d975ea157af7f276288826fb548062fa69f85c41daa7ef89abe9e34c45401d0babb6e6ab01aa15b6f7ae0f9908de7ed955694fd03bbbf665656a0fb47baa368a1e85fd3bb5751b1ccef8015c609fce16c76a576a4348199efe246428e01b2d09eda9d4cb89bc06aee84a893c1569368e7119a99f2f0c62b0e3b12bd89eac21cb230bdefabf06e9abd9bc7348dc9942ae87c09d9fbf974afe626eb3e56b82c50e2bbba41a1090b0a22d91a2ab57b45102ad60e5e51717f032dcd629388e97b67a21534b1b6eac68f0ad35460720b7c05167b64c47f29adcfc80b8ef350029b3385257230995ad08ccf0fde327308e44e55d46c806a633cb7d488fa86d3c398e3222d620d958bd947525f21189165d5f5c8d1f9ccdba3ccb4e660acf84204016d05612f3bd2eba63ac8e18b49e276d48c9e8674ea727f9bc58cc3e89e9e4bdf26de6d32ff894105eee71a4331954699a9f3c4fcba9f5985c7cc836cf2a15cbfe1aec4daee3b0173b0f94669b2a910518c7eda0ff6a458b16575dc13a4d9022a061487836b539d452d5970c1d8f23e7e9334577168d6926cdb2203f91b4538ee3850a5d5658b7101ac46175d86a122e4b3090956252d64393d947e6b52da5bd30583b175fb4e3d01e4998d166da5c17f36828d0c2abd38db114244fa73a9ad37540a3bea422d245ed0b1c6ca49c3c624f2073cb760cc556c9c8b72db68f50cfbe13259134ba727f404db258ae8f02e975dc9aeef5cac04ebb867eefe2ae09d589f7c5e94080023ea3ef5ffc53eb8f84b0e411d3bfc8e1942fb28bc3f51f9e0ba646e1fe2d1b1d613503e16ccad4b74dca7302a601422300a9997a5842bc1bf9080939eda8f0db5ca476c1546a2b99dddc97cf2bc744a01c644c82de8f293c149943f06fc357961116d3a026d6102259274f5f04b80294bd457fec9b9d22eecaead0d8c2ba066320fb629d67a65795d8a0d6f8bd6a62445a19ad1b87a8848c2496bce0c65fa235d64b151c77c00a477814cbc7a365ce8aef7ee60d6fb2bf8c1bc3253af5f9236080f56f30b7e255fd0d71e38d8355140eec28930cdcfe2b0cacce5c80427a4204af8408fc96ef9b4493faa8bde14bf97aa022c0ac73e14a6ed43706e1edc55eda8cc89f91d03c04a8fefb1d95b28df5599e03d241b8e925e34f423e2fb928aa69cb16c5a93bc0c67ecbb10c15755e3b799766e17bc94c2bd84b5432830a2e9006b8d871132cfa29b01c805b7d71bd2977d73bf90929a256996b8fc039890f8a269f5f6be42049ab629162dc7524f4bfeadd8a01e2a37b5958ddd0c4201a06d945c8cee32c6e4072e5a7c2908f5c077047dcdd56bf85e116bcff87cc7a96c0a34dd3d2825cf9af9aa411099f21b438afb318431954fc69f420a78a113c42ca784ebb2f834bef4ddada336e268c52f38c9bff508e7fd7238e5d2c9fc2eff0d9c24df348c9578c7f9992e700d6cb23fe82b76b2ef3a3fe6815d40c038f7661f8f67cad906c05d9846562c56a504d62a6fad847efe4860296dcd5e0ffd8ef910e5cd4f7e551c84770f7c51e1d61b8204ffa1eb1fde433d4e8763206fbd8c72ed706a2d07dff7b425da3e9084514af69cc753878e8ee2d511c9cdc9beea68ee6eef6a27aaa39c742d8a583d9964c6116b3d752e2b903d3416ac5b96672294d19adca3d7b380111a9465ac6272837aa30ddfe0a1a08d9a41adbc3bdf8b4612e0d66b3bef706423603f9b2fd2e79a0ed8326952373c6dd73a6cd3147609722f1373ba2fc584b127332efc56179066d6c18297471d41ce2078af69f3eaf3de5f24de31ab1e8a732b8fc3bf0a5f8b014f9e899129f513a3116a607d3c7c26a98ddbdb55a6775c25bfedbef61622b2f65bc0903e0a12d51b968fc3b7baa82d0826535c2c1b90f10d0e3b7dfa3a54f0bce1765b20e04d7551fa8b29a7c718eb7d0137d3f3433b25ea2389c8fd9ecef40a74b96c08ee7a335ae511d5a07a6fad60b0dded5ef6b73b441932313c7aefbb4c7210e46ef57eb3bf9b73e5f37972b0c8881ba842892f794884399d96622d924ebd4b1f414b93e0ba1a9e3c3035eb7a79f415b585c40707c9b55677a82486d0ea1e6c5f1930da18a1c7c9cbfef318764e205b518b9fdb30b7b2ae014c8ed356ca0de766dc63a18f0ef8119d3d3ff73ea5146ed1a9d6d0db0c91325ad7af16d37320612f2b2ec39364cb6ced3c54ba7b829b74d200e350a8210588e631fc411efb7162dcaea5a9b566d5df9602482df4d8045adffbde3b3f1e2a7f3a93fc8f5d0fc6ebcda06d3e61f2498f34c7bda52b33b7609db0d0af82b7bcdc66ab9a34c17bc642ad047d0ac854e2de4b520ee09fa40633587926963fbfb44cf71dca60e715c1fce5de643496889dcc2cb90f0c5c5d669481cce275aedafa3ccfcd58228f8b62816d61e8ba97858aaa3c889b957a0776bd16fec564e8f72c4854bd8fe31546dd509cc91146ce2617d6d9c349ebca085e0a34d26647dc7dfd1fd0297441e7af826ee5485868d6541723056fdea78cf3b493b2146e0d765536cc34c31c1b59aadcd0f657aab439889d633e9f0e2fb39a0f14f0506c4e6b4338c9c7e71e326fd02c24edf96e47266a4d30081473073244e7ec8dac5ad03fe96c22695e393446e1d9a9e2ccf5295eed4feb2e4869b80b8a82d13290a5c61cb583fdf5e5ee13deab5bc1ef345855d64ee2979b583430f54ef0e25db92be3012c5d4e1f6a2a7fcdeca3f78da5ae4b77a5f3d77346fd7df89aa098140f5fbe571b403469080b698ff73c48c6fcd38694f1fdf636f51842c2f50274fd52c1b8f8287dd07889b1c27094ea68fafe8b4e8eaf3461d266a741275d33baa4c0a497c0bd05787bd7827c8c976e6db864647a033d1bd3f5928d1221818335b5468aa5d316bc7ee041a0d0f9113d462746c52f2e202aee287da856af4fb286187aab21c3364f5c0639d4d0ec4557b365a203094c9ac5610b052be183fa9f759f23fd4a97a1290bc382b5b5e66809083e67c8d170be14b0ec2ed7e2ff7f14f1d31e41ea306f826fb62cfb0bc4461b6aaef5396dc0b831f8e8091e89495c858047b3527ac2977d66edd8df283b321b43b25f7cad58a9e3547e67f5af139f56fc61bad69d27b0e0ad93bfaf5a437a0989858691f3c310bba721a0040230f0fd14d842138630a68cc1b94aaf145df0c311db948a56b6806a2fc27e33a20660da02f13c87bff8b0cc621aa067349cce73ce937ba3ca8ec257a3061b6ae27ea0906da0b34b8a602cdc1c66f57c4c915ece42fe3295fdee56c231b2404f4e61d8d1f1d273fee55406efa2eda6351252ba5951d9e7a8e129809e845cd0304e600378b0b4cda6b2031d1648c5be99e8b8eac695cd0bf4e33c5b0f6c0372dc6ffd686e519e2bf74ab32ead451e2c0d23e2c82677a73276fdec8da97bf21a709497235e16d81ccc4b8785a4459722d33c38c6d28c615df2b8136471a3defeb82043dbb4d294421b205aeeec5134d7b6bffeecf710ea21a32425e0bc98fc302f1fbc27b7036adb43fd363326627a1481c056eb4ff240dfaa244559880ed1f436ba0f1d761a1775de290aedcb63452927dc93fc77560a4ee7ad15892db2bc1d90b13c25343d470235deb330ab03aa610c61b8654aa37570f1f1f12132ee8bdc614ea930453e619b1d82e143989ba109718a7df75c3494fed95b9ce2578be6d7fb83fbcc8536758a8d319470271dddfedb97f035527129595d9978a6c4ea074bf7b50360fc4bfe9e82f1560e2af6127a995e7830739b357c0f209cef6cff5f20f3276907bbc62205dcab288a45935a7b35d647b529cc348d68407b829c08a460c7bbeb272e63a1070ac1f9b71b5efb8e9e55f23b080e4429d2935b9caf29fb0db36313eb21b03d5cb567aeac35ae9954eda6f3164c831aaddc7489039a8f16b69394d4605f7a24a74e2d661ce12a036ee87df562f07b739ffaad6f713b0e1bdc764849ccbd8733e5569b8ed45f97e70a32b3ab686a714cf50202a38a760932a1587f308533bdf4543fbdaaa3d189be6644b87f5c22ce4b3c8a3a03c7cbead5f6f33c9a1634ce639a130dc1fff957a80ef131eaf0a5b063cd983e30500f351e339f4a7c6f6b6499f3d53fa7d833947a2d91f50fcfbd1fde1dd39dc996410eb82d0ae06842cf9e5f4afbe5fb384a894e9a1db228e68bec415dfa341cf4d6640c14a63616ac795996bd7debbc8baa30d726a420558f6a281c4c3e93a3387a6a17b983f791c3c4216c3ab40814fd9641d04473473e1489d5bba6f571dca704c66592a06fcf89a7b641d1ea74f80ea49e1b09463098da7dcbee8c91b69487b44262583c84537181ffc49efe54bd4702da36d7eb0023359ba282be6ae0acdb8171b916e730005abedff4373bc528167d40062a9b79f8290fc01e5d0a7a8b7aa79919c6f7c8b5bd2a4a687bb3989a0c830c2b7f070f544e2abdcc20f9f86cd1b7850e1fa134b838df2b6dbff8fdf50fa2ae6b606222f7bc9aa473ab5519d092a39305d8f599408b1ec57e36663e275573cef07729ea86f59e781f40708a80f80c822ef1159ddecab74698a85385a078188b5f1fe7ea650378704c3ff670c422c832e5016d956b50298ff4cd067c56bdeb71120e6e40ca48a4b9ad695a12a1fd754471205129b012579f50c46c937ce6814571b10797675740504328ab8aaf7d3a16c137a27ad16b2bed1e173d8861727b7243e975a4f5ae177a32af427e3aea9aa4c5a8a3dcd631702a4bc32a03d8e88aa293fcd5239c09aacfbf22997f2fc6c7cd9602aa24cb19bded351b5d90a92e7db8a8e710f3cf9c3ec07f44278d45bfc43bd32ea8308abd9b39e330d9deb5ef654c7c529dd568f519b5a34bb49963037482292386e5801f61b4b958913a8d48bd7a840b42733bad2673943637ac7c3253afcb354663aef2e0c6e6ee6fec42cb8a4b79ce8cd30f85b205513dd125d812558d1353bbd065f57ca67902b143a28301e47218d3caf0855dcc48c9650cc5fde6f704dd999c38bc55a9c7cb5609b379121d015d66bb4d03bc676981721783f4a3b1eadf7dec7b04e46bd891da4097dfc3a6cacfac46506cd5e5b34042736280ac4cdc2abe51b1847b6af614e7466d354787ca06474b12f29af41ca5e52e762a9a9259c0cb396a4c8b57c75ff144fba38040f93179ac8681970feef685d4a518ec5f86aaf78e828874f1166d3a68913e99eaea6d7adb04150e182ad0efc6e8fedfbf846cb559bf3d204f020fc5ae69347cda25ca6dd3202032a81d6b4fd8b122b44bf997b347b7539dd9aea47463c040c5efed250d89e1f27cb09bd7d3249eac27f81c654096b65729b80d21708e7ee04b9fa2086a0ac54648758ef54b1264da5f99f860a2e67cdfdea428526bb22755015357144b5db58b80e14e553e20bfd23a7ab1b86e7c808cc2a02cffea6b66a1d165aafe3a9cf3f128f28bdec98406f183294d2ab27eac8978cb475588b537f7827cf6964edf76de518ea0cd81929e62c9c8393254e589782362d518c746d24aaf4a45c850587bb68c62ed47483256d677e40e8fe490fd108707591327eb3a60ba35ea2b68f563d51e124748604cc66f9d03f66f2b413d0ffc28d3c89fbe721b4b7c9020c1217587c708795d2cc68f0dfe6cf8b1f9ae80f683d41f3721f889b29f863f67003ac1282c21edd06a0ea410b82cc3077fa88849db788caa9b03457eb436b617b2ba2851114170b4371b1d55b207f0b344217327c7c6db2e9c0db550def5a45bbb13478388ff6a2d402a7e0e67ca772a1cdbeb413e38a03d3450321f07d68c2a0a58b0aeeab434d2629e58173b91d42e9b39aefe96aafb8f90d691a31c61ee48186ea7e6eaa7e2e7c10a91b997210a4554550756d9832386ceeb2006acfc7c839fb1732d5e5e4660f4ceaf5c5ea2f66de4bf1464b2b4a83b0e44e393730bfd0d94a84547b22bda572721648a5befe63107158ed1f5a710ddc1b5d892ec43309de01b209ba82278eaed2f8ec5119b87f0edb1d2ebd6f0ed05b9d5398e15e34b828eb64e99a6c861694459e8d694147969fa97b916ab683e5b85a73837dff3a670dc76d6df8c3b7ab5dff3b8300e1e1ea913d54d533c39656fd68602ea5814ad09a7e1ac4ecc6f7d32d111e98c2c65600cede210d291e197cadcac16ef11147be15ea873c3146623b7c27cad3ff05375115cb22bd9c1c0c09476ec2f190de25060075800ffed02556c8534c5170b18c035af310896271bec510d2dae689d4671523984623f87f168a466894473b7a14efcc5303094ea717cb4bdbc379ff646f6ca86eed6e70b49d6cf5abe22c74a0271aa8951335f1d06a67010b7f17d06f33a3c51f7957cda3e0c72ffde5132f9607903ef5e6ad8edc700be60b6e022ad530ff3ad8ed55dc2e9f71e84d15bc06762bf1c8f95c06f2064658cb63c88f949bf19a3a88f2b36d8d1b7345e951eab0d8f9fa3383a07a566a8ecd86106024bb558fd87582c808a53c8b7c07a1dacbbf7624c46a06f63add9dad8dc810c57c65b57aecbdec78b9831a0488edb664266ab21b88a28cc8a9821593f19adfa9c801c5431e92b78dae8b7ba67a21bd8f8d5ea8d9e177944d8601739f5a22527938e6f34484a71bcdff20231b7a68cbf91875c71045e3abb225813b4760d4d3facab0193f7ef62c0d37ef84f8da52af037dd3d9069b5a8e1347243bf52cbdedbee87736d9c1830edd921d206bcf5919a17b4aba1b27dccac929c6ba66bb69e8cdc20731880724fdc330f93164af21fdc7b7de4a423f816422064e334d8236c69b06276526e2697d12e8976f66d0696105e9036c72d40801e3f0572498e24fa0827c433747b902fd728eaa252594681772f1099ceabe434bbbc55b3d6f2e4d199c94c6be15e2c05723ffc8f094a3d844480c4197a65f79918072bbf11eb6204d1183b651a5a533bd39fffaad71346683211a205307737eadd56486d0c66f51b046aca62e98fb2e7802c29e9e0ee5f6e07c2504387b553a3014f6f8c75168a8c0b650e27831071fb1c2f909f946d84dcb93dae2eace958e5d15a9c0894059272306021440fca89457c804c592724207dba18dfa1e25637dae7bf038822f2b173b6b3dbe6869333db634d57b503e6a54d0aaeb03e246011e7fbe2c9890abddb1c8d9b6c27227cb02d4022ee9a989775db295a7f72283da4eae8ba6f9fcdd0bbed85fe02fbb57554b4e4fd00a9dbd09c0bf259793c1f08bad13dfb401d1ca0f2b76639fc67284438ab8ba9ed7583bbc48969e2648f28f9ea8f327b81553dddcc5b2ced78b4af975aca8b7df63820366b1443b9cc5bda10c2a22f7148d30805e2110659600bed25a7f730cef3f87bcb5381bf2a91d7156b75c882054e295b3280e6176ee1121cb75f3cdd10b117af24066ded0648cf5a7796944d5278379c439b7061210b9ee61d363ace6d14d61f90568887e4e3fb9a0fcdfbed33ec874f6f54d8608b242c434ebf05e37efa4971add9a1a344369a37f525bd9360978e25f53e14ca6c7d888002a70e14f31ced7699448a238367dd6d88f68bfaf1a1e73eb69e3244f450a7bc9268f4e0ebcb70633d8c0fff3a360f904a9e718261575f040462ff50130e052119e6fd0090952a16073e7ccdf480f865b8b3934555da153294379bf89bcbf43c7a0c4e20f868993b162adcc88a088c42ef31a412c1d6f3ba9415fc6f2efc84ae023815ddfa34cc1ebc2c0c0e3c4a16442661153d2c3f509d236e3f033420b07618520b8df94b9f852aea011577b8718896131e25a390b151de3e62f8961269e2f5700ccab1cbb8aa7bdc56f691e9d645d5e89f5833577eea3ad798596afbe27bab535d592cc69715f389e90fa9494088f503876a47b519397b154e101cc701b70c294395c3c8a2095d3cd8cb20a9ea283c843b3afca8ed0d115bfa1c91ff18c0197c4d4429917a1d583cbbd2e7e13464ac6485a1671e96b0ba630077d3247a5da36b4014f09bc75dff83b7b9c964bc7528bab136e66998fccb5c93faf6ae71fd0602ed2c400ef7456c505851276779248635da27aee18c3e54d03647326f127d2f07b4d8c6b2fb7f6557a16dadb72fc31bda53edf6119e3ae25317377c3575f906a077ab28ea938c11e34016a846240682bde93766c57d35729e1b299995e0f0ed0e9c71929876a3de9207af8f5ff02335e9fa2893cb10333c123227a6aa67bd17073278e7192cb7af484ca99f6dd002306feffbae3d588dea4a140a3e2b88f2a2f7d42cb60e6aa14198a9869438480076add7d1df7eda8e49b446375faa6ab885ce86b4c01486d73e65d79f927026541b8b89e5057ab1ec7b545681ffc5d3448aa15fdeb5a2826a6c9e178501bba7fe5a7331da29cf410ddcba2904ca57748645e5f48d7916f6d38426cf31995a19ce8661b297aacb8fcac9db4603551a794dd0d56a8cba8c5a6efb4fe8199cf253cb7d619d2019bab47cda1ce85db061febda2500734444c247d923b85c9d8a279d843178f0de5552acb4e8b9f973643d3e178b6a05d090c95bef4273f5c7f84acdd59e38d0e9fb3e76ccaf2ff794edb8b4a71c6fbb091b159b2d2d798d0151386773342dc3f6e41e60614edba53c29e4d002f8f9fee5d2f2ae5fc2e9d17485316b6a47706ee3c38db71edaf341e4b61c12689503b381d8ae3cccd6f8bf94d3f367ca90ac3d5a89c8134eaa17d5c27add21c3725d58d662f680faf0300e5a69f1057ce62f49653e642e6f15211ccc5e878bbe4247f1f9cb1ebc3637d41340dc755cc56056b4a3cb5a80273fa854b84418a3e013e359b383d24e637bc3ad001dcbc22f9c3e005b4f6726eec14aa4f375addb7cd5569985418a446863affaf5ff57a005da32af03643a5f92f297a1c33d3e671b5024815d10ed0ae5f281864986c5038a8928173c1bf8c80fd76e191308755127cbe099e3aaf07a05c5246025981f58ff9e0045370ca93aa85fd3805a96b65ef9118df56548a6aeea3fe5da6bcdc78be29e28ff50ab6fa76883eecae4dce3d2f4c80c35c5fd82b3c233645b9e5576495dbaf1db8679d4c1b99841d4f5f64ac8442b2271e8fa2275ecb4ccfb7a6b5784175bf0bb879ce8df0693980618c8abe05d8aa0981fca1d4ec0114a7dccabe6840d7a6f5a23addb3ff858ab49884cad504ebfbb840b1bd97d7aaa1b57a9a6634f72d280632f05b60796993054bdb1d4b4eb8e05baad3058a8d9d7b84d5a7bb42d5ce442e74a8e7725672d0362ac649320029fcc1001cec16d83a9150f4268ebed9d08f97affc59d3f522c072c6866834fc1d058aed0d90f23d8a62a55ded5a435b9d2e36802dcd46c67dde207be5961ded7b3691e27f26e7318b6f3a2f58556b107d586ecefa6c171062cf638b62f92fd19ea6db6154ea39c87414f64f46b52e214e05f3af76eafcd0eb50ab6aeba3b4d4be293d88efedd7ec4a422482586168731e2caf12e09124fb5e28ea13ee56e4457f1feaa9274bf06fd3609600047af8f3550d4ce0c0022303c3a29b986b6b0ccdce5ea6cc8eec9daffccef5cdf37510bfe6a0fc042147fd000a0e2c50cbd77b16f3b75a385107f31bee5c2e2b20f907c086fc25d4970d9422dda794a367a19937698b8b79bd85dfecebea9812ceb63cdba6390e98e00097fe99e9f6016e6ac8a7edef25832c041142c16d155ae4b60687d3024096da384d50edab81810a73d1a59dc92dc171b9324a313af282b7d58729196b7bb6d32325993cd616c696db434b8b16df0fec33876711c8f0b5abe5f6c140b5b5e6f1d8582b1375a6b0fedced8a4c6d35ccf88431eb4e21ab451c53424867ee407883ae6b7bbbf8ed64f9bcbb454a5606f10d81c1c70d127f5595e82a37cf54fcd6a76ac882916aba66d4233c42c54cbd7093c6551df5fefa50c4d79edb3ce6baa3d37d0fea8e968f4060708373a570dc7f3c69d8535343151accb2ab044da2c14f11304f41995536c6a390010b1778493de01570d4a971aeae2673d9133eacc2dc448a69a739909210e0caebf1a6a422107b812c7c71db244a222b6ec8a7ad4f734f92c265589cd6df4dfc4ab5bc3d31fa7bc81456d2abf52e167896e55f9249bf4c3380dec73138ef243cd9106d1e56fdadcbbceda331566154aac72b5dbff300f6d4791edc2719b143fdbfc703913b8cb621aea88b9bcf630eab56abc3ea8532661f580e138e8111863a9f83ccd4c8a85c4a7efd9419dbee31d78df12a66c2908f33ab5201d4ff391381decd3e516a37ea071fa5779d2333481842c2bb9892a7bb4f03cd16b791c0601840b3d402779b999c3bf46b5ca8270081c4f7a7aef9f566394c5b260b8a91c3c3f3250660b6766cb1f81c2181f657c0ba50c3b05b061543da4e9f9d7b3e2c4e22737823fe6e84cf2365c66b1826462a308bfdb78a9a1220d1f722f6c8e56e5dc01aa2887e07221b2699ad428efa5367b95aaa9f81e4e9c9182c8855ba38ee84f79dcdaeaae07021ed73f1b511f083eb86bc495941f0c8164c360ccca7f5ad055a3d49cab5636cbdf3a15108ceb3aa6ad557258d4b97dd8df3f19bdd86c5926ff25adc4defbd24d3073cbccbdaaa0e0e12cf4ca88957f9e19f417d31b165ab6c64c21bd2ba7bcb3f1c21bbc6046980e237457a67115ea368c7482f7fe9fa2f810f2064096460f7395ba35898d8d3399d9d11b2d2bb268e6b8a62b18ed7c63956c61607a2a7b3bf3a59c212e1b8e43b9afd9237402749288dd40a3f32ac63bfab781d472005869e5f3d4b1606ec3885ca1dc1ddb660b1615cac6b5a5dc57dfdcc2b5c5e4509e246a6b3cb5dbc8a30d3d63daca16a750f8ab43debd42743459021806deaad43065fdcf00fce6284812409bdc72c1512aa8a3e6b2feecdd1c04c5da63c45f7be2a1eef4ca1acfb2c92c4192a90ac12c5e8ff3935dea74ebc3d542e1eb50216a418778b3241cbefeedb66f0787fec3e6e8dbefa136101e7b8e054e29989875684d3f00e893026b38ccf506545e0aade5263bff4ed19e0c0dc903c95e3404ede1fb3e33e8bf62b4d12e0c4821e7aa3be585f417b4bcf71fc993f024e0386850596138fba7ae3bf0813009014329a3e877a70351bc1efab4e38dd286917c33b862efecddb8f367b1bd6aba31a432cef1b6c47d9f5418f8f8ea38191bc8c75af43f2e5c0341fc9a988cb3295539d1f9a073baf915383593176f5abe680ac4e646dc127ea28053f56e51a0dda1d9d176b7492fc10268490f1ad855a5ba6f0480baf7e843091a1f5aaf1d4223c31571722107d4c97e0614acb5d292a3f7b1250003d94a6050da99ab6464f3eb4c800aa1cae42f23de57a0a72fc3e481a0839f4a0aedfb8eb6e4cdfc9750a15f19420efbc13b31664c7be9c1fead6f0d13036cc75a51ae44cf10d5033688b6a3313a636ecdff455ea0357aae1c07b2a7f87953862cb00c8293dc692a4e8cb8a90271a77c21e8a0d282fd75b0e98e5be996530f5f7ccaaf5176ef312ea27cd94156fc5c0fa62702f5a71fd39c43b7d3210e72270d74db65ee6b22114a11875c3470709f87ab4368e013a939f374eff2de49cee85319a7192743708d0ccfba045957bce4c263c38dcb3b67769a1fbad52b10a9d55ded917853369bbc55c1de1110ecce2b10dea7f7e0a01a724fdf29ad8a7a1842bf7f0d44a01a508d03a2719424ac7ba1ee2e5a04e89673bce9433daa3967e7bc91ac53a733bf01c6351849dbd8e922ba7b6203ee4d5e6f92563b520de493004ba503955f07e27981de6fda409073ff3a62a4795d6d4c0834cd82526ff4ffd665ae01efd56f59895f2520ad49e71f9708c16888a5b78085b2464c84915bafafe2088bbad65c1b614da091a28a88d8f41fb96b056f4f148ef9188009b3eb68437f106ba0266815c8656fe10e9d739e75ae4a053162156ee63ee8189865c9aaa1b53ede36b912f8175dae72797d0b069153b8ac0e6da8a6125e50fa446fc81a9edffdba343e5f4ebbca7490e645cdc2c1d893adcda8d48a9d54c3a66e0ac27e226fbbc3f2b6a1a6389677af081d3a959d18e6b3711a9dffef3c03ed47cc2602a2e51cc2e389847d30906cfb6f9bffa84b196e8c37bb952c84879546062ed26c39f49b835072de434b23c56b282db785e3d441e8c2c35605c4312cf8b9ebd07e795f274aac1ee027afe0f111a7038a540b0060ac0e41554ffda157de4199305b7d2491dee3df87b76f92c38d174a8c43b849b673ad92c8d7083847b25d839cb3f9b1f8e276cf72bae6d3a3e8665e41d40a8bc91da6e31be6c14164518827a6a9acab0e564017bf2e0ebc6db78d128d16a1c7fd401cb29f7f0a965012119727491c21c305d79691378746d2637c36d024276455ac315f37b85853adbefc2682d49ad799813542ce8140cec6875b3bde99f72f71faf5291611a1e72876e1fea28a0b99cf50a590dcc3198838af92f0136243c6bdba80485282fc19422ff7782bc87b23b999cfe4f7cfb066e662700b501737170d32be6853b9a4735f76a083e2cc2e43dda5a27ce7eea60dc75cb9c60aa358431c6bbf2e6666c2c1417ff9fc78e4f4a67fb821d81b1f7eb555d92767cac50e3fe8e9b4c67f05ad9b360ef86efb4d58156c848c3f127af8b08bc322f5ad55b4fce0cb3bcc6def97c813eff18f13d99e2b44f1394eb78271080f2b08bc1201afd353ca6b95a8eb79cf91f693cbf5a8d4eade1f9d9bd6b95d2957ccac7c2f8d61e3069c63427933aee5b045951eb70e2924ee79a37870432b02cd1812cef2eb39289bd4faed3600814ceace464a54c6b8b4234f6a24d39e3942516c0f9816192d56387645038e76edda182b195f4fbc2f7ec565daf1cce4cf62decac1878c102b3e3bd8e17c92033192b0d8f7019c16ebe24442506289d42031524392e35ee49a9558a45f80b1f4a2a16f6c0222aa6f5d4b84a674b9f49d3ea4323f975e9b5889aefde1ee2e844ebce476e27d72a739cb2952e16353d8c740217fd4af8cddc550c6339b75ac5fb15ce5abda526623df43124b26bda8373d03fbdd059885894fcac4579864e2bd24e4c7f1a7e8c48fb0649159c909dba1d5dfd08c5143e8dd374155dcc04b9263e84490afebeda869f6b61138cc422c85194d0329d82737f1519df545a51772f706e6bf584ccfbb354e2eb5a2e9510f48ce1741c34831c9a77eaa9c6e5c36c1cdd9b2387784826be00a104cd640bb87aeb91abc092b17184e8b5ffb000aefb85266fce803c9702d5d2c320d440e0c0e4d2367cdd105bcb646edcd9d0b3f09bbc4c5c5d2c7c5afbba5dcdf415c2750cb05e0ab8612d0ff1471d26da8a5274655c6238c555ca38435cdb0e41cfd7fd0d6e33c93e4e0d7dcd23b9a081413357551533b04548cd88a61d0a152e47f15f798c660e1d437fdfb1f65258f3edb8edc8092f634eaf3b9096d7da77209ca2424fba19d707f9bfeeed7d582767d04f398172b6bfd5180392291d98c7d5846c4eba384e35586d6d92e777e15494813648e25b75874995aca8efc5c9f2d5598f6f3f04b90c23675e4f28caa8e1a83c68036baa603b14cb24808f8444484ec1102b9f21878c8fc6170f9075071240e0ec34a3282e2563f5b32c8604a59844f9db25b96909e262972ad1bdd5b4b0efee80dd4a8ab4c91732733962bbd198de8ddd363202f77f06b098288c665c5f04cb5fae2fb0cc36385fe90d63294c3e8697e5f9d4d0dd809e25ff35f135925fd5b27fbb82eb5c0d6e40423066e5d09074c22045862f63f77c0667df747b381899d1e1835746f34560e015ceccf42da34c18f30930d1b650d5b88172b802cabea34d52b0112b372e429408bf217aa458a4794cee480dfb61904b07b3d82b6fbba6ba49777e498cb205072e7c4a99207a3053ba6589c2d085ad27435299d59d198b92ab6b141f56c1b558c4a9282a38e79450629fe6fc7e4e47168f4e0aca55ce84bd7b4d0109f8552bddddb7d1ce4a1c8f187b3a96aefd0de5660c5a5577e6af407bb9e505598f0e060de1876397a8e13f4a6f6c46a2012cb817a958d137e44c514842530b5e2c51ed50b14a80f691d9ecd7c73265cde6c43c0801aeac87923b2172ab6f29c62aae6e50f6f3765cf2f282efc81866d8f3855302a3dbc0511f6d2eb42c745e61d022dbc9ab9747820d41a908202be0d4a0a386e36b06524724892ed07eb7341c8f378c731a71fa3350b4789a949d81c2a9446e90d157b32b0e04bfdc2063594d5c46907b216b6ee7998ed686f0e697afb1d4fd21e33fd1a3abccaf34ebe5ee0e5aeea464ae570904cf41a2a379275ecb597387b5a0e2108d5a9c38981716596aff5f19650113567c4904164f4fd902666732461bdda2fa0090d3dc7f18a6b5c3fda41fc1da25ce66d734fd262434e23add002215bb88d744413598ee46c9be8eff451df57ccf972fe32a4fa59f1e6cae1c6741a75d9e3734975d2eb761b267454528ca7de9cc46c588c28c2975c30a4dfd9cd55b1cd283883ae34b4fbd8c36ac08e24203fe6a4775b29d2cbc3487fc5ccb861896e8a37617b32b3b1358f450979778a306b63a6ea05c41db9428358952958a0a19ace803ed67de1b41759458969a38bfcd1eca2a36dff122983ebdb8b4d225bc1bb5e00ee215d492a071bb90c5f67d816a3f61917289e612e658d44337e3ab0483b1b3217990cf140a76584d25454173f7813138de04a2d81550d1a2c66579722ba1d686ff4fb8a9cca2ddc33d11053d741040b0f8e38ff087b05b05f9cf4fa12cf701583e0c6930b87d1e7496c7edde86007e3b1989e24b742dc90b7feb436d7c40a909336cba0de60a274fe451edc365cdeaa69fb6618e1ee9f2f069943bda633c4134700243dcaebd282fe8dbe39b7dd7fc0471a11d45cafd83c8a80fd96a9e6f90503a886e33144253eba0a13f28ccdd0f68912fe3865527d4be7f806fa9e8a741deb8d1866e0f26f6ca0a23fa5ae5bf72c7add2f954d58898afdea54865cc71ae19b8746354ef48c95a2df06d7b5c994aa81447e4dfa98a452720b3d1108c720ced797b16d4388926f0b3ae67a4f72218fba6403d5bea8ec12a4eafb3a0823d7ac35c83993a802ccb2c67a3b9eee6ba1fa8ec249453abb7fbf6cc55395b2ddf6e80b8afa9b2e2d8507d2a29646da1c10db71312c1493ef091d57996a4539ecbf0c7b1119709f3c17c1f373cef36635c3aa41562b30e5bf695b3622356cdd91cbbbbe3e773d528fca0e7e7ca9faefa76ab35f557ea6a5aadc7cf0fb07ce4e80cc45ff5895f36ea3b04b9e03e238030862cf595fe9bdbc30761ffcdc97cf73cc743f04ac485e32a0fe8ed31f124947fc00ce250f63c7bbf9a7ab72261992e346de32dbf4f080848b0f22f05429615d0ee9cb58f3dceee9fa7458b2de54e99f460a1acaa468c7b82bf2526536d716860f128f8cff3841","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
