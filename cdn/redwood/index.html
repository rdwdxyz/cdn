<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"051abc1aed17e99e3922a2020ddbc6864274affd28a4327e988def1d967dff798a8a09023905ad0794795e4d97fde2c3c39819f0347ce15f70cb417f23720b856b0916e1c58897d47c144c8897a509f99c1a556b5d1836522b4f3081932d11b96574937928c67f17cc557b97520ae8dbb5671b8689f5cf421248647f4b3927f96eba2fddbc8af45c1efe60c34e403ca5cf85c8943126e65ed671085aefb26551352e54cfb0ffda7b8924a295044c1353eaaa3db8096296240ca869ddd65911a6fdede0eb676578c52fe858c023732cf1f0bd1ef901e10ed355003856ae92ac64e131911acbf725b5085ee58fa08c8385c2f4cd07fadfbd0224c6b60b4d9a3d71145f5c1bb0c5bed13aa9a57d1126c34580db237bb672bca134cec7ef24076b27936d86e6515cdbf0400fdef5c9add9f4c222932a7fcd3ce50cb60180bc08fc5af781a8ef7bfd0092977cd5658eabd329af3255997bf778b0ff63cced17a819fdf93a98562428793f9761a53570104f1ba2a51e0edb63d05bd2a3be0dde55b368c1e31adbe59744fdc388b11548ba8b8967faa0c5657b10f3422f0385fc5945ceec47374a2f02b2cbf838e6a0a79bb0de342e6aed8dc5b80fb3f78f48ec8b577695a1f3a7e1eace511870ff32ada21277aa8e85c37101ccc8a757ae13e0708f011c45637151e38562a4e5b42e58be374c3bf136911e46a8f7878f6081bc14d67889bbc3c4e585fc3855744e050677422061cd717cd879c82cc41a94a4d77a8252b692e909c722670a0a473b4d05dd52e0e1a0b6f8066b43cac8f250482cb86a5b23ebd636dd3b55d3a67d194a89561f0900aec7a0875d6c7594c3219c0e3dbd97561910ad49f94a78b167bfe224895c9ac37899507626c415bb37215e7c4a234c99427b2cbab3d89fd772352472a6d6bd24554f361ae760145132aa60ea953a5109e91a50d7358f33fc8791c7aba647f96bf8efc1271849290857c872670b1d648b35872b8ec5a66e41e410a342c00b0c5bbae4326fe1aeb08ec634d75865d7dca40661cc71bfe25dc9ea098a60b137e0e86b0605dd1d5594ddfcfdcd170b2046c3d32228b312c907dd2b0064043dfcab6299c1daf6325772d71c0647f5cb8aa2f5a690367c3b8f72665d712888449d70c3879a7180626a903f0e9a540b64cb87f9788063dd677293323cb260512772f4204c0322463f460cf45029ab85155938c6177fbf9bbaf9068f4fc0d826b8e82f065fa0d494a15e490719cce64f3496d7b7b21f0743f86ea72f115bb896b69810287f35691a46b425cc55efa992afb25045a745ee30a198cab8fa2eb4dfdd01863fe6622c6f5d92ba5b106e9b476d99afc5008d3248deedf5ef993f1f45141b5139f3086c681dceaa67850f1fff944de25e6ad2b1f3d35054af2e5fec739025dd1468e99ceb1670dee3bfa8628ae26f0721efb8851f334e13dd60798cfcc3b5497c73f742570a2016edf8de3e38e60cf86992968abd0085e37f78695be98a426380eec90589ca45d33b18682e00d752eed728554b095d998ec40001ddbe4202b02c44971d22bf2bf7191b73a727ae57c5c4fff2168623b4958b017fab97e1b667fef943781bc0623c3d6fb92f610d8b1e6e6573c48f304edba1c8fb75f899f4acc98d8afd2a68441eddc2bbb79995d27c0f6dbc281e1c348b72f45331655020feb2dcc0aa9bdca24569d55cbed4a451ebc92a6e499ba7e2817100c8d4d49830ce496ec719f9f534d2c847a4e38710d86abcea538fb825ab8b49414248e9df0c7f391ee28e1a61fbda272f153967c213938091e1edd25d2456dda6e883ffe14a880d4746c7c0ef5ee976c865f33c62477c12d634ae5faa4784886ff061c719b2aaa08b28bfd2d3d1dcc12e50318248a3e451b8919480965764c1a698fd30db140609bc83903e0d5307b6b3f3a17a62cc9f18c610f767eb26313754ba266bd49090ce5c7949d9a611ea6a58b9f5be8650526214ae0f6284a6c42b7043e2abde92d160c39113771cfceac9d3f6cc5b05f2fadf7d9bc3e3f659a315e8083f6793473c500cb33f48520eda506d8037ec1b52b1a8e156b6d6ef280a17e01ed0af9e67afe0a915eac268e84ee8f98dc32b22fe52db23cfa0b11f93b5d66ce18c863a1a935ad8e5e2e5b58eb5f81ce38371fbede151892b1608692174db9c5289443b97441e35abece3676d0d286ab2f673ff008b2b57e49f4fd40b7b1b288b9d1a660d2fb7ace2d47540ec1fbb81a7ce36f58ec684ad1dd9b620ad08a4aa28d4d2dc4e52cf70131a8a22b03a5b645a4761b7fe85a485cdd3f8ec247dab044d1fb461cd0d42e0f962aa990a4f549a743c686bd220f51c2d4ef0ec8fd2067f8f3bcaab2fa93bb0c1532162b0e6e2b74658a12901f0e456f7d3a01aad84b16b72ee333bac3564ce4beec7167a7543ab490d63f3288bf9cfdd784b9a107ce20b477d53f19f81d15c85fb1d81e576b0e7d799ee5768b7c8db0d6dc3287488330930995e9b6e6cb47961891de0721cd3208591a56ce2afcc2355d39c3e0f1b77d7bce471724d7f18ef2456e7fcf89a53ba5ebd9d374d988af772ec574f98d6955eabcaf0760ae6d8da2871c59aeb69830211a81122965ef7e6e07fb16a86e587f8928ec9fbc1ccfb09a0b63b2ade7409f0f1916340a9bcf0f7b0704032198caf04461983e926562b3f319f54399c32d4698e07cfe0fca6c53da4e6fe8484beee13437e7046c52988ece7fd9a89411e2c758db94ff4d7c8051c8d34e66ff91faa5c4ef8edaaf2042b0a951dc148726884a0e93ec6c14af1512d6a3b8261885970d9c013ff05fc568b4839766e278919faccf261350ca0ca2c6e8cbd31f17fa64a7a2bf63aace3cb6a0db022c4a073b972105811180d50c9c990e79269e1d16c820d63d15858817e09f7953eb0861653bf07be1a2a060a9e233a910e64098d0246ed49654a641fa8e5f2f555c49ce277ac6534b405e6a04762f92c9e30368c884e592f0abf914834a3dc9ed8f05bf01d9704c4aac875c68c53334142d85596eb9a5048306bc7805d0231e848dc95b8b198711baf1fccd22f771406ec713106bb639a0a0d9e9c794a75a760a9111e27cfa9f0748185cbf38fc6a4e890a2e438c42147e6a885df05ddb236a8b004fa6fc1c651dd6e34543f11016aa945ef5a658a7b3a79d6d9e635210fa9940aa11c64de9c7ef03367cfcbedd968c612b33a030170bf0935f2c7060afcf42f5b4034baed5f195d7681240709ef1ecb80ba485c2f48e68f519cd0a24337be7526f9295d19e2556c51071586e4b36fc694abd35c88be03eb996821d7a61409912fce110aa7f930efdb064ceb849f7753a1577a7ca63eaa79ac3add96a09dce5da9aac8a1123dbd7d181684b5ee0034cc48e97775abd4fbca72be83e7aced444f09b2c5a2314d3db3024c1958ce33a2c1c84f271b88f36a765be994663f09f42ec3d67a717b29765f11165346d35061bc43e2d76fc9b55cde63ce0e68e07ed709f5cf5caacbfdcf4a930770907f95e53db3448bdb97d98da43dd6f5a363d1a25f3cb50bc6ebfae058f81922940e897c4dcf7b5064496b90524c7110e5a86feb800d5010511b0d4342ac5b45695bfd262eddce97a9e46cb9d991624910bfb30db796cb3538f420e02769f95790b6d1b4682148daae53f9f99636b068be8bdeae170c51af51cdc6c6313ccdaba5b25bb0813a8edc12693cb5c75fc0cd8b44e5ce6e1e553faaf9a18db05ec685b0e647e1c0e7ec9349e739107ff175b910eb7aeaf2012fc5706b9f63b78ef4fae2bcf6b931dc14a9f382f3e95cbd62a8e30aadf51f898da8f030c91fcfa4f2d18df8045a83b0d450641fa67014748935b6f2ab9d6540ab7a16f31369056878a96484aaac8ce31828f5a7bcf22a75a86b2a1552f8449a7d9a7372684f8e2d2a354858c3e379c92f3a4afe2c70d8fec4f258f806d8c06c0bc2dd4df74087c0e75d810e89803f2b57c36cc252d8a718e32ae9a1a269bdb9708150f25a4f4796ce3a44480a4eed9b7e664e6b111fa47979485591286a0a58c5e000058893209363d9d11f552deb60e9cbc6790c2c1f295f19592d4ef414df7bac810512879cebf99ce758ab5ea2f8b5e16fcdaa9a44e17094ffe649ad949e7def6debcae751b845980e93a4b31ebee3b6fc50b3873359fd672f3001b34cdc27f2219b1d2b45cf864ae7433671c844f3c5dab198037fd080ca956d4c93ee2af0da0b0be8ca45297af134bee1beb5fc76e4ab1d41b2aaa64a8344030ffa7dde9d150dce4e4c35eed68405f2d9ce434cf7e4feeeb787e59f63ae7e5cabcfd411173735ba99b154c3b655d7d7d8c9989ce3fdb7ddd1aff56c43318f829b47573bcb1567ca41ae5a603c6309141440e78f2a578eac36ab097e412cbb2e0aad0bb5d2722ae2e6b86bb7088b565cab3b753071a6d982713aa703c2eef74845732454778bc6dd8f30d8e255eb4d2eccdd8da47360d9e9eb072a135350ca0a1398418ce73a6fa919cf7efe720c59a28a516aa9f2c77ef1545c223a373ace4db8b33de79d1dd66e7788be3f958b1f68ee7e0cd1cb1de09c367600d5d18233a409261a4e11b1339c48be8885f29702420923ef619e26ddb355fc0da08c455e94362df4a6b47b6117319283d6341fa5aada77d8e234a8f2764e223fc24c2e94dd34415117265c6d5fd7ed7a19cd8de1d6512f755c9930176c0c7eecfeb20c6de140c6e2702abf2d9b771be074041985e678ad9747f2d64ae3dac3d45a770ed44e0c34f319ff256c9387e99de6dae61d4a85eaa09e01e2394b5fc15b821501e544d5ff71b9fba496396fad7f85a5083bcb91b2ce51d2ad01408970047e5f48be62cfc139f155a81f58c14829335d967be31da1617d86a93ac6625e2d297cee42f3de570fb7a5dba35770f6c3cd11e946d155361a3e6a1718b35d1301b144c774e46cabd58003a85a2b9bba33ac246987581e9188203c921b7b5ec1b3b4154bee1f05a03cedf07dda632fd703cbb70ee70cc1f5905b92a642e8d59526cb45d508befdef4938014a078df77661b408dacacfc480f6b096fd0432118288613eb6899270aad8107f6facce3ff0c91545bbaa97a4bfd0afb18504a53e9aae5f3a49e7a09d919dba08b8e8372a4058efbf0aec734dc82478affc3f026354cce00df446076f287869d28fdd3495b1d016e5d4864a366237c65be07082af9a423e5e38df04806b3802dec9284ac65ed23a3ed55e366107eeb8ce0ff8c1c33210cc690ad2d99a82ce240ef6c8200e052b03b33aa18ca943f229582dcdf68ed7acf81e9f02ad2b7b4dbf1ef73dd096bbb657c87cc4b0c502e55c32d9483bcfcb03ac82bc826baee59d1dbc1ef6c01f4d38e72283ad61c8f748015afefa738bc7f1d65eec40b74bfede9d901c41728cf192196aa52238f75bc02c4d03f51dbafe96ef30a01ef7b55860a9633ebe3052d3dc54a45fbf0eff035dbb7ee31aef307a7c3c8a113cb14bb0d6a0982ff227176a18a7deb1573b3423a44fa4a4765b05eea57f2eeb1d31e14e732e68535c76251726fc708c29f4b7e73e1844e7fa7940b1122f8371771eac4d4690151fb770de5e1c730bb5a5da1ad73f6145032ac84fc3f8197bb5822011ed0a9a7a3c5a0d0b1089952e4a91d31d339728deb8e2209ee7543b8e22e2422d3b9b2168dcb0cc58b7a506c7251b6ff624e77e0601921d614e3bdad36d9c12ecb64e3c17303991cbbb9c30d34efa2cf0e4493a6428caae1ba805d9258c8331a192580a8b15b4a1352e5b40f1408f8636c61332a5cd5b8d99d36e9021fdf15e8f2adaca9551fe14688fb493cbc445edf10dd8b0c4c530320356aeec5b1707d65009bcc97c462e90a8540f80f2e0dc7b470e77592cf6ac324f0694c8eb1c16e5057158e16563a3112db46c49415f75c726a0da6fe7d810264c63c2b2d2d743e29e6cb88f484ca8373b2201e6e723019157c93c3949b4c1a4d74fe4910855fffca231f9ac19d9776d222f5d3630ddb6abe6739515bc468b9c72991a7fd1e80ee86a093c9eeddc74ebe6eb6185efbff772148d042eae1f61fe440564d43cff764edca5b3787823e769123246c0108547d27ef0c3c9e1af19f8e9b4cbc25c04863cba529afcef18a7573eb69443c58d19bbaced6055b31489da44c137159c0fc88749a1aca6196053992e355880f134dc2dd59ec1a307e5e09b74f7fe55d42694fc93f88170a89ee2d8f3ee397df937d5907c4414124d18ab86e5ca4cdc98131715bcc702189fdb28502d56175b9f6dc7455258149c44e65e9f3bd9f9a566e5d2b712d4c51f305bb00ba6a4974ab8824aa194c95af1138c811cacf42c782e9336a51a092e9abf0718ff9ce3219ade7c75f11c36accb21d2a4d7f637e6fc6e0fd38f63f116ef01d75b809be38de7ee766829ed3e3500d8621619fa20737b016f912584504feb5962e51b9706a9768266a1820efe344c77f25e085b64af385e8aeaf3e3498ef219b92a66819b9c150e73b36bf14e66c529d1418621c370aea41a9d0c56c4806b3070841f4623fa660b149865fbceae387e1ba073759a6461c4091ae8aff5885afcf8f76b74c73b39610215b4aefd5fb4d0906478cef4583c176148e5e697a0251ebe7b5e88edd348741805271543c4e26f4177267bc0cd0f4185d4bcc83d90c54af8b0e5fadc4e4706dc41a300fbda66b6503d05bf780acbfab1c520ad94347b7450fdf95ff88a09148ad91e5040a267fb35b4cb830025fe7153a524075edd5fd8f587ee31d45ba859c8bd84e14d019b482668c4b37317754f288859c94f1475c8ed1e37fe328e77b6a3e86b38374c4ca93f65f743e671f2d23dbbd55a0900e5561d5008b15a9d3bf7982276f274e89110dd74f4954603d543b53623f3bcd131aa159091730d87165951e5187c12dd84fbc84aae2848b4e79ca273e2ca2d6ff2688886528e3347794e440d2cb311ed78913b35ac6450f7f98eeb311b647e8ea2944b17afefdf30f34474a52a23d612b61161041fb912f3faf4a29b63bb2c029f9d5e8b020a7c5dba9ed598ba4a68ba326b7144faa3364a4245627a4e89ba6fe77cbee491e45ed97239e127582f77dc9b66717cf9bef70197aecafdb647bd077b058d7265d83b6aa659d714a3634ab2528ce2a895b2481877118f3a3e46109471c768c5316c4d485764c7c8e3ac8539b2972c2892c6c5229cba5b96962d1dc61970cf492d7686948ebf6e2b2d57e7c524c206ad0aa7f8f6e2cd91b5482dde0d61b901e3c76d0a9f75d235871f53c7b8bc2645e83e22bf3e38841d8cc01c1b6892cd4cf07d519b5b0bd7249c32bc91a1b0fe94d265b3392476bebddcac27c08ed25a4dc290dc434a0f23ba97a59694cc50e05bd6aa3aa2299d4934b6c97b36b6ff5df275c37d5adade7580c564c0fcc77ff147c3463220e9b2c41542e43fbe32d51160584b0549f8ca9ac2398392c693fd79ec34ae76210a43caed4850ad5d61b8b6d655115eba7e34cff6ed0bf3696886352f1aa779851afa4709d16e46a93880542830c84f539a80a48959f0bee0ba6ba57ede1fda611af4f16c3a1b553129f6a91bb37d7e0a0b7dd4f7da1b335206ea5b2ba8d90f0ab401bd671fdac9ff5edcf7dc7ba974de11fb25281d5172d38b0db2df1ac9d062075be289ab357619eb7917167d8792f80a52aaf9b9659ab47e03a47f69ef62d2fc9fc9e66ac459dd8c8afcc432933a858aa202fb42056a70253fe0667dae951971a67d3d4bc60d4a57c6c4884e382eb9ecc3988d94266dfb289a2f4ed78a789b96d274926e7c1a96e35d764f2f46f2b6b8c9ff63d452be21f8d749f6216cbcd89012b8796a24333faf299147cbc2519c9942bec9794c5122b184836841515ce9f2bf363f17558543066b2519c279251faf71d9d9fe015470ac5c1de1e7d61d42a53582fb1cb29ab23fcc3e6422f751051ebae13c1c75b59f009434b35b4fec546dd4ef7d0b58ffd4d59681201baec74210a563c408d82fe1efd2476e44abde0883df47af16c15728a68c6da53b2101ef5db7ea3153c8e945cf03cd0cf60ebacf80a6c2924571299c268795400db0ff3092d197b207e574e4d87685b3ccea87e377c64eb21079912771b15143ce045a47985e41ee886bb3c64e95c15fc2df338624d8b73380274b15bff1b9e0864cc4bde4b35c9a8f7020733cc40e7ce0142766ef7a7f3cdf05b03560fcfdc5e916b2e7dc0b0fd8dc1fe7844eef61233d8ec0a41112780be330a63ac1501d030eed23dcd21bca46d06d9bd0a944fe920944533baa8c7fc385963cc78ca1944cab42d5f46ea6d638309836829a6e253504eb1977c6208e8f5088bec35f214630464dc121043cffe0ca40c851113ce4973ee10b273baa36d86c9a7eee4f2ae36c14805dccffc1444d11207dbc3ed422c3d26438805479ed00b246173c5da47ab2d6ad8ca8e3077a5a6b7808e2f2eecac2c47e8cbb1a04fe0a51a94ce03958866bdbc31b9562c0add77645082c3cab5850175ac1ad3fffb3d52ed853795c0f38a7511b59534ae5f48a9e565e8e61a5ac349fb80806963fbd7827b4105b48add0e59da8abcb5e1ad3933d86bcc35cb4e423fe184177bf7ec4dffa6c7a9080c801a72c72a67f8a9ee89847a74c60f609fcb804369d9faa76b0f814902bb7b5911b396938cb9f0b117878337115616d930595b55f255b1c4a2d08c3b1848feef5286274bb9f46df6ec31fc9917d3563c9227b2b083f95ece9ed81791a02a63a1c2738915f4aa2d513f44b94ea37174abb716b9ba5dd58d9452d81b5e07eaf50c0f7a8cab7da96d5b28ef4eb469b46d32134a48d8043887f2dfff6f69f1759af666f81d73a1aefe3a34595bbdb1931314fda54f4e05084359ba50c4fc7289408e79bcc7c9c3403e06fb0be855d82e35fd12314c5e569af4af8e5bb830817780a3534a2701ed68a2c5bf97c9e0a98c6041ac88a6b9cb1351938f99368a0edf72cce8760c2ffb774b8982ec5e4ffd1c5638c4ca98529f15b5812295cdca5872ebd17fd1556ed17eba3f1989213512f3f2ca984924e398b4a6150d6026bf5fc65e36e9af63865b003e02e40f67c1a7b2da5e96d820778de0c011f45ffcf6cedce749baa06fea6d1c24a2a1067987961f66bd4eee035ea15576ab67ed85daa8d617b801806851cdde7eb2bbad959bc69549e2a1a546609099fe3062c3ec61bf5dfdaaa222e7ab8c5b8c69fe9c915c6615100d304bf182825e2afff8b94d70dc4f17f0762d14459ea08eb41e6d1e3a88817432c3e391ae8e2ac07876830648c61bee8a251ea8b46912bcd2095a0eb5535248f914fac6126476bfe293faf85983e894c685938035b3d9581eae2a6f552cd13de36927d81e4c20730fe78691ad98c371999fa763f4d53cc293bfbb47751e4fc730bd85c78377eaed9bb778e5e3c44389b94f2fd69c7d06c126622cbdf6d2fcb4a259c66512fd5aeb2f59011930bec1e1727c22908966b717a9cf932b5a5d4d42ae454c3ac0114be992ac0c41ebe31a80e0c885bdea41d6c4e866dd327342d31474d85e6bba29c73ff65c697f1702ebc735e9f6860829876985153446436200da0ed62ed2b541235b6e3f48379583eaeae0a5bad1e2089c6cd65448a3ab84a2104e259b5d0d1663c306062bc25790f833e02d93d70876078a7d04fdac7adf6a5adbf1f3e6347681c36fed1244dbbe1df43283b06ad132ef5df6acab9d0a71ba3f65dc137626b9c0bf2d220d3cced328f8324be7f4a82defe875cb2dc66ad8f2f057cae4e7bb548ec13ee201af62c8161175f9350f602e7b67c376ebead2a8b7f52d64c7f1953c12dde81ecaba1dbfb2ca0ba0e7f49c4a8763b4512c10cf67aa54597d0e77c201683225b5c4a2d79c940b4ebc288b0d2b0d3295813d5636e7c1bdc1fb56aab25424fd96653993eb58529f7ac010ff74dfef1438dfcae4844b66b05b6075d3e0f9078f5f52adbd6ec1f786ab5260fd61ff92f2ed083af00c37c43a8c1702d90108f54d1171ddf2d7f089ed2e123d967d97fba9e44e987e026205bb33ee8744b9e6fc380ac6a88cfe60686ac200151459fbdaee4c4e7bf6d85b49b46ef89561c50351acdcd240f96468c5446fd1c7b4caedf214e000e8e2a4f3a3454e2388e44df27fc9191af15cb4de97ec19117b9037114afe0f3391229eb00f8e3dd9d6b82f0a2fa8eced40926a52552ea949b32a99f9ba690f10651404f319562d8521a613aa8a05872d6d7a31f97a91ba65f58af9fae205a0622cd968e110e7b4239a16ccfb9fa776c5e6e8c27dbafd9c7585df6802a30baec40f90bc49755f1fcb7056e68ce2f9fe7fb18f80a00eb8b12b88b624ab946d6dd8af7378df9f3b6ae14bbc46ad36a946fcae5f6897202752fdc5249e4035e8770864546a88870067899cef81c405f3d482b5577abb7d1389fb4eb44663f589a20a4181357be64c486d16f12c985e8a3b846ee89919305183a07dcbaf9c768b94675342680fe29fc4199be892a8632a807278e259be4e59464bfc1ea7807c59b1ca7bc9c5e73fdc965763dd5c394d57d24ee9bc5c1ec68f94f673dc8233dd634b9eed391ad3e85893ec9713e07dab2f03cc9f90ac884dab28224f761eac96fe97bb24df1fb63254df8c7eba75c10a358d2738d141a51dcf31c312c59f71966349d1bf91f1721bcee4966f12a8c168484cef5aedd3ad8ef95afbc1483e4bb38edbcd33b2607a5510ac9bcb86e3de1999d7ff2fcc32e951f421f2041a6b409040a2b55ffc76ff47475fe0f94bf43bd0e13d9a849e6cc0b8589c67206ae76332980668c8da42209faa809476989738c63a5bf7d2572ae06f65aa113f5b776bcf792282e4842e41679e012ed8014916820f7d734cdbe89ab399087e9118a08a2e667a29c204e086368c2f08e1a552aac193ba30ceb9ca9c75d187072013a8cd8953dd03a09e39ffe1dfd4e1e4aa8cbdf44be05a2f292e817185108d51db11994a4694ac493c4d25202784bbf042521d06b7ba9248ff2e74ec38708047983d817b0ad82afe63da7095c8fcd3d7290aaaeab692c294059df127597a10d776c66037faf56b7c218daebaf6fb1eda0589884b35de3092b63528cc39a729418bbb1e9ff75b007b19165fa8c662816bef1db268ca5bb9fcc781ce4328ea7bdd41fb2277e5ee4b14660d2a4144ea356b4f16571163b6d2c815ab319d4670ed437b6ee9af42c1ab6533b811a05f2f82c1271bf1cd01bd49894dc2667503c81fc88e95dc357fb08b25f0b8347def1d1b1407249de227240707b93bbf93a2db79065ce63b23576491397e6ccf699613b0f0e3f7b38684a5ea4c24dad5a25d202df55c5b96abd18b92771c8c4f9ee9e29499645afc328d3e6203547c6996c28d3990d1c5b136a8905de212641e87442ebe41035ec31990beeaea8070cfdfa049ee2346015180f31067fe53980cfd35a9e93d79e4d0c41b19515e90fac22aa04a1a7d8d90e590a53ccb447345780865070d0ce036e50d935c49f8a1655b3d1977ac624538f730ffa5d7409bca6d14c110905bba83d5b3873989c11228591f8cd5d2e071d2865bc782cb5eef3cad5cfb0bc1a1e24bc12ccac623f91e25e31ad16d8fe4bac5281321cb66af9bd98b7df2889d7e28cf7ed25ab1de0fa880773bbf9d623e3515c29fd9388ee89352aaa086a0f4f0089c99f03c3b63fe9fff6b98d373762914d65f6360a87eef9f2826e3f0ed5617ead28b034945d0f07bfdf213779001bc4c78167fb24b388cef535cb0537b6a6b39b768c62efdd22b01676d58704f7879ad2c4ad9e79787882ef7a1aa195e651afa2b16bc779344ec41efb6ed9db9082f65f9380b731661f171ab2b3166c1169e64f535360ca8d9e28fd5f10e4afb849354cc4efef89c32117feb4944492168c8afc1381a5f2344e272602a19006ca630cf3cc81abe5cf0fcd56202632aa6a1146d4890e43f8f7216ab71050aa921325e02a73596827dc5937e28f6c223811e6ea6c50314ece26957929c8eeb08b84f8ee888b0a97499d14cc81b2dcaad8b0e2623d9cf339850bfc46960fc19642fb4c3f8b51a4bdd770960c54e565586a4666876ea5bdf48393bb6dfce7d1f71471bc702e184caa2ec007c39e22b0f63f9b626079dd35f19ea31e6f04fecac8ab0b43b3fe3695d3515dfb809f6010ee6d719c03b32732bf09586cb83b436558fa6baf83813a37e07b1208b016e59165720f3ac700b8ce23b82b741359e14bb97750d17622a3b06b4664d4a857d078fdee25b96c5f6ac8082e4be25b3886985638e4a8c96c7c3c5c5fd4ae2fdee3b20bcb70631f551b4a5be2044bd363d1e07e79039b44975e46fba9f9dfc20c0415239f5c887f798919b545c008808c1d401f3f0075dd103e9348dff1b18d1b6fcf1a3930e8b0fb7efd5eb4e62a4de6b0c1b8180b1918bfd9aa70d03a009464a7bf79b92bff929dd32f3f040f3bf27c1d7798f53834996cad352cd882289bae20fd745c5cf5ac4ca96f2983ab609f7d7044366febed30104cc691bbd03a41062aff86ca8b0b32d7b184e07b40ac9447fed4d67874aa4f3b1b3c8293c23b1d245089e4d0b8020276a9a2f222e693edfc7cf585f2af6cee3304f2119d29bb5165cc529069bf54e8aaaca7798fd88c868418bc2c621465f817494a0b13e24a9eb5e9e6d18c077bdf270234e44ebc6d3aca62b92e00ef545e93714489019043d4e8601f906c60a018378ff2a4a852c6ae46b613c2e5056795f47c467179209748f3ac47b32a29d36c8b8e6b048c08cbaa0da480ee888ebe62b31d6e6a47a36056ed47062d429443639ab001353a3f3cd02fbae56c6ea77122456cba507e3f89a310a77a486e68a921ec9535c2b532008bc84db0c4e85b6d32a79bde0b75db5597bcf545ed5c6b979d970ae422c347bdc9d22c5d9a7c255842efe5a2d267c6f546fff334a404103d145ee64058a9259249dc6a1a62487ffaed783202f8cf0562d01b5c0ce69466980df34a845674f089581cedf923a5da469305899369003649aae389856e33826cc5841652b34fe63605f921db9ffc5311c0d9bc1225746c5d2e06a128ce2e6132b33a5643d7070ea203cf7e0265897d30eb725e524ae8c060c155bbb191fea97f4de970e020a1c26e44c760bba4288aebac8927c6d443d52d7300dca9944577f9b46e9d98ae7fb2274b8400f2253e6454f4a1ba40cbf84db9ab8277da5294ff13b24f8115b0af4e9b7eda79dc31528f1bcfcc89ce2ef0f6ddb5fe0d2e56617f9e6cbc69930a8bff7424b855df673068d2857541816dcaa292a02f7fda23f9a20ac1b970260de69b40c4072dac5e3d8fcd5ac31c8653bf93dfb6a0bf95af901b133fbcc99059fd88587c1e482f5c78ecae298ac8ab254442549fb627db7723749eccf7f9e9f616091ed52d9dd052143e9e180daee6a8d0692aab39b0f9faeb56f99b795436d5fd145ae1dd32b9549a4629d6bd58aca3f1b274a4951794770271fc571ad668cc6fa8df05f0de9fb73a6d3adb6e553f8de7020e07a3c39af9d23583e437b708df78826950eae8183871ce2a2d94dc8d4a8742e2354c105dc2723178ca5fa3b05f7d7f4eac9fb4bb2dc850c5ea80219623780120631b176f57df2434d62e1d41d0f28a527b34c4435326c5c36c0f188b32947407ab3156e9656caa89a65a613cffd0cae8358ac3ca4aa3443fa9e1e0a211950fd44e7e0d6dba6ab1c41ed968f2155930a5ac51ac047deffd1036d8743fbd98dacdc1665d203583e01054b06d4d123f63992e7a580cce93cde8503ceb06551a8ed87d9cefb39e7b765236252890c7579c1a747e5939585cbf083ce461890b897c6ce98746f5e42ecebef6c0070d92ed9ebe9133bb008606984b11d5c657b15ae834bb6a08f17b154b527ee972a11ea5010cfeccb50bbbc84df7f81c5f33b7431d90f9e3deab1f7344958131a600f2e148563f35cbb9d03285de675e112fe4b4fefdc9f58093d949c6ab16d3528f9cf205073741a9bd13ae9f750efb6daec13a457b172207ab8f17461fbfef3e84052331cf6fbc57cd19d06646ef0d8f16e3acba449ee25fc25ea72bb1b336fc521b451170fd66f7a1f7a612df2f2cd08b254cf49ccbd661127c646c509d31f24ee58f262c6915d467f45f737806d676084d2b917440cca4793ebc182dfc28134f83a4309607a4fa3b1f36b8b4e148d1656fc7a2c6cdef7d767544160a6f04aca8e6af4f8c2ae59410b9019e20fefa602d51114a5fe73565d77434150ace1e6a756f0ceee446f4ee61894d9dfaa3ceab0996845033e68a35c2b800f6321b7a6d7138425bac505e4d02df98ee955d78a2137e11cfc2c42120a88da17c9d470b6ea73d7f28a837335023477bba4d0647038265e5ac2daa816b72e67f4fd5312ac71d71134ea71a32b52e93a8577796074b78d2c172fd9ca40220411a793493bdbf80983490773db1ab5516189b1157cfc6426b7708917ad8e9053692cb954c02381523a28e2902ffa9e1dc39df98ba617d9c9aed8ee4dbd75bb750d74bb7250d35c209db86f2b7171dd13e11d844638c9b09aaf71344d6fce158c747901df5c9df31ed1053e5ce0fe7e4b67f5646289ebe162ac11332fdc6c7a900f5f20b8b0197cb4b6c3088dbda64086377ad275ada00b7cc45da4748781a5aa21a0d629120d9f639c7f4870617a3d31f5fa9cafa9a007438aa9d139f36712de189eb17df39d1487e806d6e02e25734924f7f9eacb2f0806951b4c78fb5a5b46f4889c7362ab104181e0e5026977d518cca366fccd628d0f30b8d0c04cb992f900ae17716f1b6dcf41c050b68fb9018b902846d840f032b7aa08f22298a38303237743e2204147799b8b1c52c6e5202999a0984389a3dc18d7c1ba2213f2b737cb959acb160ffc0891670a3e2ec4feee65e416df0573f731757e6b6e07b5ce430cf424107d790d206d1aff59d5908b8faf4ef9317c06ced60b83563718368c279d99603c6437b9afc808767724e5bbaf5ee431e11022c4544951b1346853aeec10ce995073dd6f992b7cf8e7196b79e88edc2f63977fbfd73acd3581675330ae73b22b5a255c99f3e5cc82c0f4e6252a4aa5564d975c1d355fca6dc2b76a6f6be5948428d863bb4463d884e4eb9f68287188ffdd7bbb1437b547f3927f710636b629115e057b2f94f7d350972eaad97e475bbdb60edd2c53cfc5ec402efed2ff6f6f6d0abd524b52fdc235c07242f22482f46060492ab3a402888d70174cb77a9e62a34f504c7ce31ed8dcd7166351e75faab34866c0b25f0b909880f7ffcdb633e3ef7efc99ee538e3674186d4a294a092d3924b06d40832169af0d10c67497219eb9b3fe93d31869910f2d47bfd862d813ee02da572f552ee084382b8c70a6769b5f9753e2325039e293e3dd2b5ca595fdfa058a4a9f28c100edcfb977301315406351e0e6cc53453a1a187c0411c8de3ddf4afd28550bba30946713ad9698127472e46621ffd059ac83355d8c4aa46bc52a5120b139292abab2c1e3e67052583cb371a49a29588d7949dbfbbb56e8a0e306bb51764981b03aeffcf4e714b608bc63881f350a6b2508a02a4264d0f8f7b29d178941c39528235812079eb31c46065069912bd5a39b7725d35f40f2000803fb51058a3d62a71ea1997b0788fdf3438e8cf89d58aa7104d3059eeb21fdcd81977e4dbc130555839f1a51ff0e09d2ce32f53422df3894f5a26043d7d763c17d925ba8b68a7f27426c5425bb6f22dcfe556e314a149370d4f2bc9870588bca5d42debc422cadbe6c6849d3a1131a4b55ceae45524fece39829c9ba636ced8ec1bcb54633287e320e5412b3816aa7dbb717071d82fe7c5e80519842a25c9d465635565fd31c20f08c2a16d9669125a16944d74fda5f8e37ee6c7510dbfd7d02b4cc18c9e850b9bb2175689f621c28369a8bf858e8486bc3ac9944eef975045bd51347b31eeaa3956416b281ac562c824dd010ea85ccf59eedec4269ac24562c192dd38a972f552f852cd4724e6299d9e26ae71e4222e12de32d1c39a9ccce5bffebe4fe7a4d075c11a19026f39e7594aa504c2a3c5a85a2982e7789956f7d627240014480385f4c80a7524ed8fcaff8a65c244d4e53577d129057d2a1735c798654477e86c31f8645b89b9e17847ca108baa96e0d43ee1754bf1828bba6e1c707892837cf971c3e8d9dba3de7dabce40af7108606a93d66d7fc189dd1df1a2939b9083ec81019449a98ad4885cc21667e4e3a14e8c1732d67accf84492e85b687ecc9e338aeb7db0676217634d296cdb1ca6eb1e7c910a262af18c7cce7acf1066a890c5bf3ec1d9b7d1ac34dbe3a2150ec42335d8fa720621305219b7b7b20e7b95caf9ec892fb17151374b17b645bdd048fc228f8cc2bc8ba168a85f644c80e2fb22fb1190637549e124bccc3d8e692f4163732c960d6f574104555852b24e7d20c9ad5a3bcd3d375762deb7b3d88931df4cdd3532a42bd81b202da6397019fef463cb85a2edaedfbda139ef71ccba8d7aa791f41f31ced615d89c05c4318d4270b8fde3270f50fc047af9e12d3a5fc531b220350ea2419adb56c1ae48050747437b0af895cfd8fbfe5991a32592b7eb607a20b7b126f6bed6d61f74f8c7f3e338f6d27c8a6afeb504713080aaadba95280a4de37e7286bf7d7d4888dad104542f44cf042954d65e12fda3072565123c0ea8a7433373c2776b7fb1287a33567960ac88d6675341aa79c69e754810f64fa79e2965a22e129886413ecfb7a9dc9349e991bddfd70b1a19197fa87f52043aad0f252868f16455bc7d320dda1c4efe1c7544dbf21069723dea5982903e369ce397cdf6f6d7a5f83ca73c0a6b15a2c131cefe4933665291c937d8f23c573e33b53cd4e844f4068b652fd7573c5043fa0f12a70b65965e9fcb75ec97a7413545caf2fd3758d7472fc589245460a053eb2daea95b7c51e0750ea27c5a28494d06ba31f0eeea56de750b677513729f38cd05edbbb89c0d6033e264245445ff99fee6ed609d83032442da89a4f8e6365365b8c265df3902a61fa9ab971100bbcc7fb986c8e2ade8b1538ba39b9aed083b01c8c2eae9a94171b31dc616d46fe9457fda6d3b6fc84f5667344e2b127c4814dd3adc5914419e99ad97a958868de476ac5a665690684793b097ca1ce114d21ef87b83d9e7fd4b6ac64481e3585cbb6def93805f77ce1e786d718081f438143905ac55520ca1d6def05f9f1523780fe7e88bd7ea2f573254e7eaf2a5c9714697dac9d0b22d20497a580ca815372168ff5512bfd061a7f1bdf732004608dd7f9d8c85672958e59c74843557eb90e152f2dc66f4e0a340a8f1d170899c5460a742f6bff1e4f1d7717c37de98f26ba287b4e8d154b9a407e82600a96ddac31ca66c8fac5bdaafe203b718937565689ad39af6d64995c92c54c10892f238b9638f03011f9bc23522e6f832f6271158a23f96985ca81b34281dc1976f5b0c23abf8f50236af59268a8a821f0ff2d608f320dd5d2ebcbc8d70cb92cad0409ed4540cfaefc0bdcb2c77b9e9db5da21e5e32286d421b98e1311265f4dd5f3382971c244635a47a7607ce83a33266319f4fa61897d056905f7494a01194c80b7b745b3d8a58dfd177fb0ab1b34e779381fb2d4fa8157d0bf1e5c7fbe3d770760629ee4a0a1c316d682453eee582c77cfa64e71a38e244d6c6e402ae1b4392426c83cb04dcbe8c309cd5a867ee2ee728b3fd1c3e66e40e045f16e11ab48bd4c71e0b0297a02379153d141c6f3988b478318e95820a8fc7ce936a2cd4099375e0cc5d2147ddd574c448ec09a22cde800aff7b782c5159ba16522680de34b8a7bae2904db38682fd5f9031c99cb9618b4b1128247664967266bf0e1383b55a1cc1a6e339987265078a18c50b3e8cbabb77d3b10407ddde1d2165fe514512a927ca3a5b49a2e01883704e76fa7545385cd116cc6947fb640c725970fde6c3ec97702929e010d4c019c8e7d52aa280f0bc13725e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
