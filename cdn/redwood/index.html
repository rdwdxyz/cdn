<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9888fff8d6b1cb4c199b526069a1c225b6da68ef433539af0e0126e343d322bb245a73365c64335ae2e620c721be22684ec924bbe84d62163db4b7930e8a9960e1d28d60c55fab34c12333f6691b7166054a3a4ce73979cba1186c29f2268a82db712735ce4efe0e8df18c1c87c92dc3cada1fbb80309240f9898a267dd0a6f6ec3984ef73f5d1da7ca7f2d894c722973e763842a637b7c3a6b52b09f266823373c41c61fd3ccc233182d59f832a9c883f67fcbee406745c62680a4e0362bad26757cadc795e06275445b596657c4dbc87b79e0a3d3dd16a73cdea4ce538931519d9d388285816ae396fc32de8710404780369e457e1dcea5f72ad72c6ed1974b922a45e80502d595fade3b4b2f55518cd06d918c6ab4e317e7283c7795bae8e50ff2ff2760ca6b98a2e285bbdd236394d210f878f4d34d03dc511f31c326b5ae06470d5ae32fb25aff2dce6225ddd57c41db52384025a821519a63ff1312d7b73975dfc6cc0dd6bd011e5108348799eb5ec6b289d673711de7e114a6852a8136111f9e83badb9df6c124cc980c66de9609f5efe6d130b0740dc95880e1491f5365c58b66d82f15b50915d20a690a18ca30cee53a2e3b03427bf3d0e0ee79558c60313295f5bf279edbc862366e4bb49e039adbaba250d2a477a866c44420d266442c03958bf35af5a6377d4a49922264656567d91f7fba70c3d34381b2ca96ba67a6c4e40e4c00381f20220af79a52830dbbafda062c4a772fd4640592cbebe4a283dc4016842324d2b702fb63d553711b6bc90c0236c451195b23ea12dfb25f4b2efa2a29db466a975b0368a087d2aca41ca08917a6ad6d6c327b32124b503e18bfb4d91a6973fbe8d8d009e6ef631fd8f6711a5aff1c7365e8dc6d017ce77cde184a74edef1f07bc2d1c903f60f3d0c4962e8774c4ae7d1d3ea9e5c51fe6063269bc1d043ee65b75959b657e4252c0b5ad5f41a9df3562b1d9770cebe4cd1ca13123c548fa5d46835bb3f762235085ac70bf855f3c85f2286c29d331aacd79e081d8c62a0a0d28c709abbf99960ef69d3a19ef1205794c0b2870a85bef89981a60db78e9b86591c4f1c8e44a7a5d982ae3698088fd0a429236672f727758a63d89e386092ffb85e4a4bf986bb2692b47aad21dbbed750a75a5477756dbab780107c2ae4d94e19650d53d4fdb31136527d1df19bc13557bf3ccca854d441cabe91e3a51383e8cb30fda0587be2e485ccffe96bb344f6020c1397e16ce21b834d35e485a3af6e71be172d5ac560bc04436f5d8fa49834f37aa8364f3b56748dd4e445ded54b5d1af1d527a888a7b812436f3a336a8c6074dd075ef541513913cce8ddcd88a709ff7cd4d0498988868f7008ed0d8cdc317c742c72f4109a3522241c253d88c62115b6118609f95c36c53dce2edf132150163e710a6a1cee61fb5038391fbfc7fbb61fd47062b667cf6c54dcb73c2188cf2285a9f568605fbaa488290bcf04cd5ed49081016c9d8e08a90795f14767eb914d36b830a09ab215781c5d3407baaba3af3e3e820898a9babd22606aaaff2e780914a0151283b26de1aace066c4e658f73846e46bb820652c1d1c383fc6f7156283b89c17080e233405d7d9509cea4861f484a849c23670a735845b0d3f6d944d311948efa479570a9b309777fe16fae4464a7572c3dbdaab7e78d6d6825d1095223f729c0715cdf145db5c80eb613b5916efdd8d73c31e4603236c9e14b68db2e0266b11fb267464812694c7379e925c141bb87025d44e6bb64e855530816d862b06ee0ac0828ff93013a6da0ddf74466e43a6fb3039999ff1d2057c029c64309c4a71fc3f973f04524cc01ec89239d38c0f95ed30d32fc215620ee14dfd7441c5e6de856acfa63a00f7087210a906ba48c05871d9c763bcd69386dc9d6fbd75fc3c508794e25c3b9e449252554cebc8595c3db7f7b60b7f1b002a7e03000b5152a3ab989be55d7b02683287dc2406ec99d212e3139af5c5f94cb13a1bab0d2f6b59cdfdb5d680b03bf2c0365028e1ede8223cdd9240f0c143ecec9ccafcfbf8446dbeef646887e92eb621994ee8934441f3067bcfd7345f8976372bf623b86682a9ec57332dd549693ebfc9d91b0236ade294cadb4473a8ed57d6844e332b0512dd1d471a8df8cf5acbd2c3c6bb42911e46c3ff432e4f894ead3ff63e35c0045043d396659b6c78901e5dfeb6622c980ee61c8ae87885376daa213246c3520d5d65fb675def1eda1400f1d834118965482008644df3a9e947794535d9e1ffddc1f664e6668d8b680ac643ca378859649aea7b404d66e31f8e5b29d9523e9ffd16e968ef49aadd9b13f7ee8721acf691f672972338db2d6204c359335165e4a21b35afd0f2b7583195c376cf77cfa0eb7c8b6f2799b9635c24d59bd447570751cfd0a38d2793ce49e1451a428e7c7a9648fb125a72de3c6e1b2f50d82bd190d6b597450d6a15481bf7ce45e611958d4fa0395e34e76e58cc7b4d73449060f4ce97c45f6b7f848d83972bcdbe82917d4a55df4c4b79fe0f0d3887a02464c07bb84f61b1f3d458530fd0e949c9b3ebb6495464f20e7040c0b2ab89c17e4deaa8020a20ab6bc068f54cbe1f39b4b6f2d0158b660d10bcd7ee62733429b50cab2aa2f59da0d52d918cda50c79fb1b365485207647f65700a5523c4e19974c36fb42ad2622dea9ece28954918b89296e3a5e8cf27447b599ffb063c3c5f30e5a1d803c28c8a70ea3b2a4550a60dfc3e1302e19200c7388961497b58254dded1d05b710658cbcbca757bbbc1e09d6f5dc377011fb32e2c865a0dd56dc640981d47b0e86bf1e20bc427fd31a70b559f7c9db8b3ebacb30ae9b54973e6b42361cec0e0097da3be16611879c3dd4539cd95158c8a477d68acfb7529fe76ed319a863ac5200d4db585e0729d399f2f8d6f0bd017533df4e78c5597b8d4aed1624f1e15bb5748a5ba67d43b1dbc12c43cd8142842120b441dfd976f52fec4943581c67b5f53051153644815709f92dff5760e9f34a8c1ab7ad1054520fdd3ddb4996ce2138d2e118161eb9bc5a7df9912ebc29d59da8fd8bb2ee00c96402f4badcac1105f13acbec0ae446cb425903e0207837844b15a8bbd4f584375b9af59f4d28a8c14871333193cfa2314ddfe9f4bbbf8d2a25d7a1f2bae6d47f7fbe58e7b396f00a41b184c78822db1ec45c35396398c76ed7d9804fed206a1deb61e69720c5efa52737771963fe1712b28bc4fcdd7ed94fbddbe763d0abbfad671d04ac971f85b269f2452c3091e2eb718ad411e7c461984eb6909788eedfa877028d86528b875189442be6e50a88010d8eb7787cc1ff165be38f5faf591b219210158fb361cb73a36718afa204541974293f391074aecc860a4807a27ce38b83ab1a18fd9eb85dadd218b8be55fa2c65089ae29eb4b763510152ee600134318753546853f62cdb7e68a9e7cb17ed611aa3ce72a3e443a381a075c55d9b8c4a2a4cce6d39aaa3b3dbb31e59f80626958d252e174c8364be5556dbc8ed8a3c6468d6901bc86985f5f107af29e67f767deca5a6b7c1c5b5430523331fce3ec8e814d26d5c2d93eae5fb15f54f2649b06f35b16e0428a52d0f8ba23bf9902e0aaedd5ad22433ce5729435fae01c75bae3a903fa0cc05cf26216365198a1252b350524eb9bff0df03a57104ea1271ea6acaf1096d32a19a1179104d9c5ef8ba4baaf6452a3185336f17b4edcdfbb0cf79706ca5a3988d8d24fe857c6d0bc221a3d93b30916f4104c90fb363ff027e10c1417096e0a66e44ac0a00ffea18263f2bf5d60babb8c7cec54af4d0b32f61d95bec093dbee2477fa5a19bf5b3301990b63e70a06e8d3351c8507c51bf937617e9c3b85eef023b8135c5df40b8b6adc19c8e1d0ab8967080036f7af7a631bce68a451d1e04c2642671e980f0a11dbbc51ba53e78b3785097d6ee474f306c4998018436df78b0a9cfdfccef9027f966d9737a62dc48d64cb4c73fc974dc79699f5d5c6099ddd36e066aedfc5f765c32a5e9866f727002ad78f98a9fc759d2ab680fcada33f7e2f384977e37dab6da6b85b6cf45d7e77f790af43fb5d76020619c4f952edc1c4ed403068548bfe51e3682be0bf9e458f8e36429d75fafc3c3f48a5cc2247f77463bae243ef634de5573f865c2019b2acca9583d406f55cef90524679e1b422e4da2bc46963c35495890c7a6ca8d4b8b793b93fa97880e2e1aaab69198dd1b7755567bcd6a379cb7e3bfa20d4aaa89985e60703391a91753fe34d03b2557fc1c2a99154bdc8b831a764be0e4c16cb14ba93d1461f720742c5dac1a6cee74b553dae9a6f4fdece4d88d65f312a3fce12c54008a5a5413bebdce42ae2288f4a10c3cdb08b85d40e94782d58d7954962d4f4a667ef2c95d31a482e5cb6bf64678cc4f60a1f63f982b3f3fca5eca8c9320afc7cfd76cc5d972bfbde4a81848438fc1cd13a317afc78eb79fc6c527eb7c99055c2bb3ab324292e9e8ef815c070702b3103789125b451fa4874fad765911ed4edbcf3719204a27901ee70c449cc37c36f14833df9295f3298579cdee2735979edfd6fea5c1084a0540e60c01d5679eb3cecd955b2eda34fc4712be72ab7976d1a7d1dd53de77cccde865087600feda430066394f9c35c97b6e9497518f82f9a73e58b71db3685861e420b33268bf46bf13202ca2a2c1cd33ed53f12743c0843f5e980b3a2daedbb44895c210aa33ef09233855c303d0153598009c173bc0b948a44d52a6d106ead61cdc456b2e71605aba5c8a1e783dc960241820fc8cc65f9e59282bec20abf9da740d594581f8d20adc4d510b19dfc0713cf1f2875f93cd6b0e8d62383523169c1b985f051f4d8d9c687c5cf7699f58f11452d582cbbb4928d3fae29a68ee3c89878bb119f3fe638fdfc77d12e855c3f4114e74288d2b58f4aa50d2a66677850af281f433c3130c31d6997a05555fc3fdb59273bd7f12660ff1418a450ad4f0b46158e3d3a5dd66dab972dd95350c6f4e796de42f2aba53764bc916de6c567f8a5ec1b3a348b716fe485bf7f53f1c0851ed74538c94caca14dfc9578113199cbc9954e90e9803707048ce9e48d07982f2fc0cfbcc8324664eb1310543193e945582b3e10be67ecc6f6e08cb4ec26f5ffa6b0ce2c1766186547bf8a87115eeef37e8203f4e7fd5dec58122c3f5ea25571ad7b39aa0542cf9f3ddc8b34fdc39e1623c0a2add929ea93a99f4d47de6956efa4b760216ab5504c247c92b48695650a2a68046bb5b9758e6e0e2f648abc5b7f6728e602df8862295a20258864ab712a369f92209ad442d50492aa663538fcecc8876115be1b884cd3a37efb396eb691608e0ea41e251700447ac305987264b451723bc84e7ff889a8c31fdf5490d17ad13f8dab49c6331a023818e846138323dddd83f57f4ef374eafdc4397e743f01ede3bb5593de1772bd7c18a966336d2b4d7e2bf72efb8780fa62907629490f12983decfed729a792f5d15ae2060d4880b2335f3c44ed0e37e6ba7d264342ac70ca8bec9ba3a4452fffb039c468a4cdba7692c21df4a50cd96cbd78e9e6b99f9c4c24d4db456ec3fd1d0e789035cba0c479d42a28e949053720ea149a583339ce09256901b4446ff4a60f8d84417aa971cee8434b625e71f72f5bfc032730aeca72c603157c19bddeb8e458aeecceca179b9058d25d7719bf4f7ab537fa215e95556876380765d602048e280d8c28122d903a4c595d58f683c366a6754a3117c091922034393c529ad15e5a2cd44c66abbcf712280a9544009d314b72391c0c1f44bd575329790c6ba93cdd6c918c49a49189a1616e12abbdea4ad97cd66f5b61177a0e1378eb1211fd5f1071a943850b085822629c7c56ec0dd546bceb7faa3c5329fa603a0550fbc49d64ca30a534e01ed81dc12e21e44e58fe0180bd5919ae1d94412f2b96193634aef16480c11e79ae24eab44cecb64ffa4fa91e9b0d2fe07ef281fd4b62af39b080a13791abbde59e62edd3d645ca5a1683ae3ab3466b27d56edc6c23d38cb37b854dbe1e413a9fa162ad9f063fe476ae2c5fb61bf7e14917bf6612bd612612ba271eb06e005b30e4e3a65ca47799f95b35de61ffe571337dcfa14381569e0dadb5848e198097849250ac5cd6b21facaa27b5495b698b6cd54f6fce81f573e7bf6c6932abbb50c016ba5a07d469e6fc56ad3152abf579128bd5c2d49d79ca31aa0b2bbc640a44596dcb9af900e41c12db1de5307e2fd93c6e1b8a550fe5a76aac155bc628ef793a5721be9fa5b8f21f7c1e5e8a3ad074928b997adcb6152f8139d6a8337758ef60d0d0593640dc3813eec4c1a7aa7e8ecbbba41b2dde8273a7845da884e1726c618a40f94fc2049e500ecc9fd797d63d1d8fba7490a47901fb9cf0f970370c6a207f68cd88c55d4f9d82a33319221ce9462af93973ac15226af645d2fb5a6875db4aaa76d3fdd4fbedeaa3b50d41458f65a957e505005e050e4d19679e702e42c028c93d26830f35a129af49f26af726fdf687be3c71295a93ca04c89fabe6a0bfacc12da0631dd5832149a4e4cf5e9901c0a554713c9127c0b32abbd9f985d0426dea1d39eef1416de9d9777e006685314c4ec8c2afc2a74b044eea76f174a8480c243f866835cec5086ad9c7d5399e6c5581d81ea0429c91e7afcfdb2a4cd2ddba25c6139aeadef5fbc761812e5d8c272ab59f6642aa8a14d8798ab12424830230cba717b536578b3aef0aefe02bcb6757b94d0502d86c3612c3608a3b5e154e4ad5b0d37d9ab2fc7eb384e40f66fc3c9fa2bb20e2064825cedca277e3497c2558ea7e324399a7a4e5e797f80094cd1709acef31d7a050063e87681d1681a5ae6a25d3945910988ba46a30533278a5655181c40f5a0b2fb3cc6cc5a60bc072a33d984132e6188902e11e6b2be96a60820618f891b389737a6bfdbaf460557e982a5a444d44df4256df36a15b903808e28b357ab4da8b35bb39672553b67b372c9937a9fdb9fae2b7987756762ff473bf63ac626f3dbc1a8b648c7357d46060472b232f9d2addf42eb1e37aa5c82b16c4794884a48e4b0b26218581f2d683f18cdeaa319f962422f9dedf37ae8f36401aac1c6f09abda3824ff4540beb0e5f70b60f80bd60a2c734480e812df1bdc4653ca484c53c680f41157fc747a6210817b4610e1b64cd0dbd8f9fd89dd3e4a263eef29a67788334dc50374c610a2132aaae418aaf9a1e7eb7266493d154693ecc360901521640ee744986c14a87677909038a770baf399990d27115af8dfdf04e335d57d901eb7a9cfca385fb9705b8f56364900b0e199660c706a228b2bac347fa66fd4ef5ea062de34dd6ce5752d67ec8f7ff8900f3b9daa23f8adfc1b1e6fb52f703f087fd0d1d5d2f1d22f3465b6e82ef4e2f4f374cc216a4c23178ae043795879d20065f8bf884733b4dfb14297c2c95365319b6e226d6f48d919e5b0e7574dba670af75a67ba2b40e3ebedb73cf8dde27fc8428629a2161b3b576bdbddd1e586853e61da48ee3da0a1a1b7e80d8ae0ca4c0369d5b8777e56bda9e9b8e27e6e929a83b692ed2fddad08b5b600332f6bec2f62f168f35e910663adc9e73e69ca4c8151b39d4190ef1488a658d5f13a527e1ac2bed88e40e69ea7be5e464fe0692297a8e973da1a6c4643ad8a977510b355e0c045bc078f6fa7e7ddc07cb4003d161cee21e72f1ba0449c76e65f9be397ad15e0a533a86c8212fb1c86046d3c50cd8b2ec2c5c928f67e00901f04e99fd527d98378a964a88dfd2f29c24dfd236f217249fe4a6e8af33e8e2fe0a8d19d76dee8262c270eb2c532744002034bd14814139bc85672d4ef19588a5ed03fbc85419399eb424d3ee13cabe6740253043fc1705ebb5d8ed3774a74faa313c11770fe81ec94cc4c6311b4bfb6203b23ca4b43a0500733a15a5ba04122f0ea547b4362f46991d530421f5d2deae4f06363936d04cfced8f1281b43799f323c3e3f3cc0f4f1b0fc283bb44b45e807e6134fbda2d10092d566a62dc4eff17061d7007f82a8ae140edf6bffffecfec1eb83fcf8fa194feaf7be6ef84908942c6df33c3d9fc90797d369cd87be21070a61659a53dd53c47cdcfe82e240cad103f8a8a21010ffdc554a2c57ddd4565cfa412e7d1a77be099c2dbcdff4922efceb99c48db9a6002f94a581fb13fea5c5ef402f6f6293a5bbff66a3b8a7f8f9f0d607ef9eda3a8f73ec09379ae4223220af7d0efaba86471616342e557ad672c8964a9c14fc2891605609915c739b2a2c6a4e096c33cbbc0642107543f73ae0596f4a0109cf5c680b3cf2f55370914e5b90ee71518ce060a2f35d1ea1cdf9a5440adecfdce5a7d971b0403a33c7ff457b704bfbadd1727e1922eb1bf2fae62f8acd0f299af260ce0ede189ef9f7679d908fa69ca6ca7effa0147d52650f5de5752084b30d56a82ee5f40efc9b043079aafb322a42d7de3508b3e2b197cf4273a5c7a08f5d69716960bed19bc3facc393c65961ea97ea0a42c4466c1b71b9ff60171a172c4a311790436b6ebebb16c17e6fc1d99a677fda4a6b82811cff8e64379daaedf3395031c09325f666b75d43e2800f974a82cc5cb31a3f9ccb31a5b296b8eefa23a2795c4c67fd79f384288e25452fd953e306b37363f462737c36fd18b58f1e90d6d9addc07881619c2a4685c0f5d63d7e919f0e6fd1eb0c7a5f8509e3326c21f9cdcdb1b8b75d2482c573d1ac747a1f74f8e2243ecb56517b9e894e34660d8af16e4acf4843cdd55dde54ed7fee019418a8676ac574a4c35beddc97ce8b0430161f1ab575afe2a6783e8bcc90e5007e09eae875316da20c097efc96bf28c1f7b6a495128422dd50f38a02e01ce14a0237c1d39ffadc59f14cca333373efad22eb691f051489c6d2b539f166e28c75b6441658978da88054647c524e31419b75f87517829a65f1a966956654770de74febf887e66214db4d9619968b115aff113349b0a268586592a0bb4daf931b1b04a7ad685d0370af3e9d69f1a63cf8d55b43d47db35050ce93ddcd34cf337b1decb45b62ebb7183a713f22114b05dbe8d2b4636c2abf452fb8e2a460d0b20f62d74122c4a05eb24338bf8d568849adbce878e93f77a91688f9e15e2885102370d539c95601b1cb7ab9beeda5b9afc092f50bd3f7fbc70a40a5c47b327219ebfddc10a4ddedc2ef025c5cdcfecd4832e7ea3fe86c65a7f64872aa498a23747b3b1988c5884c3d683c372c44f1d6a3f6ca802bd8d55349ba1bae104d8165a291d7673bf6024bee6576a31de3d74b1ebcf3c096f0fd368cd0759fbac8f1685c0f6a56abcd6c093f2d9363afecedb8d61b2bfb3b8868dee3be43e4d4651912683a0d846659ca417da9e4793729bb14b070d154c2058e98027d5159abdd3fdb6fcfbeb0af464e2b8a645de30c0b7b0da475c97c22470df5cf4965e4bb84c2e09ae678a02026c7cb9e00792cdf273f6034dc43d70a2ac6f9c6a0a04c2cbdf78b0e2a5c74e912af3d9321e71ffc06ae8939472d7a3da17ed4023f2a145544bdd0bd68fee104cec4d7472528cb4b0d0d6bdb2611a6ebf64f730171eb00aec22352e893bddde340851251dc17cd19b60cfad53723b7e53d68cc1d28d47827273e809a8bc131d52ba9b4064d284ecab51dd62f531d3fbbee4effa3f7c221dc462ab7444318e4be13a49cbd998c8773d3b78a81860804b970c708f47fb7fbae42767e5ac628ee2090fc772fd3430dc0e48eb63a5f5dc83370d69c062bc667cc99d3617883720d36ced6249568ab39f9099411fa9c2fca08171b065ac620242dc44e3a5750d4b119e0e2065fe225af7bc42523eaba702b5e29dfb3d3d14a72290680473f1938f5563f2fa0d116c2648c216f98033868171b12ed031a4336ef4bf4ace06eb9229118fb82d68d6df75fa8156831b49d9ba10204952dc81f72280baeee458364ca5101ea791ff5bf4e65e4b82f7782cf8957e05421abd49e6c2e50bca4175b0f4ec71af85bb704281401ca1ff9431a80f9a6f7476989a7ba6ce3ff5347a9e47214215b80218911977f8d220c19cc3e4286d13e54798cbb4330000192b6085c143829b5832a1b8a049da0edb25f2b522e51dd4dc0ab269552cd1846a90f3710f72f7604807c113770d549a80fbb079a58e2e360af06f5c2829edaa4a18355cec7a19255c517864802e0325f4d2eb6da41595f232c672044a6fc9f81d8ea5a2856f29a97497b63971a40c0cc4a3c9e80413a13c71cf52a11dbeb09e752b60ba83336d71679b2220001cd3a20e3bb8d3e391f064ee5ec2f95edfec55d9707fdd6152b29ea983c84e0e40da0a1cf6e7acbb73628adbfed6b7a2f253b31cb1813f9a1ab76fecade51ab0f9c354fc6d7c966192c91e47edbeb1127222c800df421f43c645d638d278c24bdc5977efe1e19e0a9a98e036dc003b24b65b1aa37a8b20a631ae1f5a4b81c2c8f1cc42714b460494cec080f23c2478cb57bd305bd4f6d6191f4ddb39cfdf1748b9ef31b9139b20c7da703251f3cfac2c2cd3d48a3c860f78c7089c653722492ab05aed105938e693a36a19c0706fc949554661af0872c17f3e1cf64e6fd94b1f30950173eef3f6c6dd2c844d3374fec772a9a6c306b4cac28e8907def730b1de363e6a7bd18fa0cf1bf7fa6d0cd5aadbb6767d462f2e40039fb182e6ba7fbf7ad7ff968b10be5beace9d15e9b4530fc6e63d9676355b622ecd4bcc3462dd9e539007467d221612d2fb74ddc438ab9917fecb26c94654453431ab8abc07c68510a78cb84cf344434dedf6d65f264a51bdc58ac1f5d6b5204494433d96e8110348491c5711dab177403080d7ffa8ad7aadd72f89394b15baab9e9d02b49fe38ac91e81b2c346cee12dc6c65b995bd3f59ba1f4000932fb319ea00cc9e95da73be60bfa4829a4001b03c13526db77d1e5034b353c33f4243f96eb7e21f3be3875b693032d778b9d737d2c8357ce42c30c30c10f73e133d88d2b6113d9d1bfcbb93be0e1c18e46ced65b3bcb0c56979024288f5bf9f8ba4f1a97686cd39ffa1a2c14d70ad4ed37d75c78ecbe7fffc4d492f553e52de668fd48b95b4391f3f26b1b4a82ed4aaf0cd66391798dbe1463691437dc1fd39b28f85ff9a71b09b920371f960b0c2a952e914aa40b2e5bca45d9ed842ff430f0760d8e24eee2c881c9414aec9f036f4a5eca1970a430e62f86f46d8b354c1cf14d5269c22e38d9dda568e73344587d7dc41440f0b2b72f7c01b9ab4db8bde7bc4883bfcc5be7943ef0d47a3024d2be1daac42b36d0b0e9924eafa96f62e761c0a7e02f8fee2ac8b1b1764259d842bc2d6d96da02e73ee4ae221c038ba6f706967b13976043d88be111bb594c8fae0d7aff08f376c8e0b27e8a57b0df309f3f0680b4de0b5529f6b6a3c27b7c462826245816a74a784dae6c4412874b792bc4e045a255ae7fee6a5a06db5667c6210d99f58afa06599b491d53fe04161444cce82684239cf9f95317665c5f7ab1d977b21feb8ae248f87f7fd421e6b8120753c1f7a47f6e7019a165774a766618766131d127f74f3cbfa5569fcb61a9eaad5d2cd4cb036500e7c972c4065c1acec488970cfc9de9763199b2029bc364419bc686015f27ded333b60c7f59069110329e6a1531dd8320b9292671d402eafc8a17926fba4f82fc64cd0debb91b7a3057613623145deb1e32485f2682efd890f8ab1aa507c646ebcab7f3b4537bf6ccf3c7b35688562da4f4256cace7273993c6b92e0b4a3db3ae0c6a73c8c5ece07eacede5134a218b8127d5d7c9e8d8d472b420c566a9cb391df35427014eba0e05215d8d408204d87137aafd94d24e50db113fd15dcfc2760b555e993a26e5e6ec3aa0e14097be1f85fac9864c107a6c33945d64024a8867c551aef1fc3514a5cf6a9499a50298f81c752c0d8e3c639c42279ca2fdadda0d2f3e782f20f3d0f9679fd3c1d8ee70bf224273a23036ace27746fd609d512b0d88de3c7fa879ba0c13b485803daecbbc2f58ca8c2143683a418208d5cdb3cca9f9fe36f9dfc34e755c802f29b8744ed9223669824d49203f4089d1144d28f44062843496289c7a5ceb48a9b26dc5c358eee279db0ec2405ddac541e435cf5172d33d7a55f18ff01a64a67c48d206d9ae575da33381af7dde0690925614ecd84308b750e750a35ffa0b9cf99a808c4806ba0633aab3d9e5b35101c0bc96070e7ed9c096f2c99d0a1f33c71faf37370c8a740823b570485e42f4afe9300dd8ee7465259b5b18b8bf82afb6ec5eba1a86967dcf0dea46752fd1698541e3778cfc7ae360a547a31b554378f9596027173c4528ffd82e0622e4a2a40772cd1c89a38dc2edc6ff818af143abb7974af570509e621c5ecb8ab1759ebec13249e3b9c8bc94b1a0da47c273af9931ae22c98f39748ee275d3703a553a8a67c1123e0cc7043f8ad820a7f2bd6ef2bfa82dc963866ee05a234dfe3eb9b69c97c72f522d322c723e5cb1185d448e8d8bfb5a1ec875394f7bc300f9932314a7f034229afc21f4c583040212093ccf3c2ef99de8a1117ce3ce0f40027134c108629f1b113e3254c03ce2684783da59b4a742a314886822865f6091a43b27c109b8fc22383ad8e7ba16f723cb882eb8739ece9be094d57b7e1ff435744861da082d61db09a693ca6bfa04c3de6223ccfb988e7e91a9bf2541b0732fd93f1b82144d798d470d302fe675102db703177a74cddc9ef1712697770c69c5bb74fb9aa650d9925b8c822335748844944448a9b1952b5ce1e66fb1dce671e7ec980571f6a033e9c51a315ab0d1878affda489785459052bb8879afd32b14278b8062a413db950d972b126d8efac7785ee25195d9d8fa91c76e4ec92675a950e6de6767f3c0500c7aafaecbb45c5c4016315c04fb53252c1064aed27f2e68668706f56b14719df7a85f764c2bef1b3d9ebf007a1338e927e6f6ece0a88dd0974b21471d9191935929ce2188dc22251e71b1c798537527ee7933aea9f393b94366f7147ccaef170998b601b02c9608cb074149354cf3718f79f012fe1f43e2d0b02d24f314e5f4ad4114965d4c85fedb429694d240d89ebd7bc19aa08b8cad4492c48bdc138c99cbbb1527221602212f7546e1a24ff12ee71e912651764844d3fc668c40e61619f8d6524100b642f7985e93b0b49a61679139e6c3820524cb1552c5cf230e7f0bb63f5d1c1efe7f3f2f45dd079b455ac5f5360c285618595dc12edb34c7b6a2d381a62d3701c374bb3c07fc6be22a2054d4dcc16482d100f1c48eedd5c28ab15809da3e39818f47bb0c66f3af1baad4837e8d7ad7f05f5a177f2e4681b51441351cb6cbe21b02b423314e6d097eb0e78b26009acd3398d845ed903041f6610e3954d0fef0a6a02158af067caa7fa64f9acfa6a25609cbea133d0f95256729bfaad2424bc62f3dffe4333856f272a996a82e40c629045f6ed0082aad476389ce296491c779ce5cc50768051744131d84f1215978948576d7b347a4a9c8f8d9f4082af058bb87acd09daf7e960efeb32b6698bbac63b760a9e213c1e7c084954a55673585b7adfbfca32ecff626fc5eac74ebb323fe8ad3478cedf0e65b12d95cdf50c10325bde134a24362eb2bd6405761177c02c047c5eb1e728531bd15474caee181fca862983077f31810101ae17eb2170098790588508319a3fe95ea9d59a89142e5f169272f33c727ffb2cdd1e6e78d951e8045605479aed0d11834f5541f62d3514c2fa8c65c5241a623098db68caa467514e47eb2572ceda1541e62f49be1015c2f4e610140477bca79eeec251291119cad06d15c5e1755c46163d85d89d1aadea0ea8b04c318777e040ac923f1909b5be20458b72b737505ce3074bd3d6525969b6bd14dc00708f172d1edcd712a1296a768cb6e16a477b7e3b0afd0c88a544e68959dd79521a794b0f5f6106fd7a2159364738cddd40103cfe165b45590af1e7bc47e932798236d54b9dbe2ac2a357cf83a5f44e17d70607a51a0c962156755c009ca959bff1639b68caa885969567ee09b4739fd2962402156bb0e3cc5a2e8555f5febe4286873d8004d22e20a47d221b6c551be49f900249dcb0ab1ddb8559efb3e2fc8d4db34c087b7cb6e288b11c9f493963bb6b0bdfe139dad9146fde213c936b68f1ddb0c647cf5dfa98b60bba3a5402f374c25de3b3d9127578e17a2d6c59cbcb54ff505dfd6c1ddfd78d053236cbb416a85f3f606d6cb75567b79865645069296a8b7860c2eb55916022e06eae6e3a19e66d34bce0271348fc4e3b22023b4cbf1b0128b6cc5018fb7c500a69d0ffcc4cb69e3909954b7268fa3c21ce02d07a63ff7f85a3f7b30fde7292755337900234d7e33f7342fc1cd0f159550d32033971be021f0807314696ad02971e032366f4448ae1f308e2d556028722f48119bae2c75dd0f6276525f9cd9e54fa81262c4c53902cf5ec8ded4b6b4322cd196e5df001ddb6e05e2ca0881eb13b3b52368a0f1cfcd5bc1130b81def23356993bfa3a2c20a37e4f9b09108774f855fa403ca2d498088b1eafb44c6a5aa54c1f3955b385228909f981e41d0cf07af386821c0f1cb6a1a8eb4ec8f47254bfa94a140116c95a1bd9b125cb9bb067807341c092dd86904367476db74ae6e4e88ee02a60c9e4ab5834a79ac2fd7e02520acf61581c9bf35545f4f50f2003a578ef1dee4cb1b6fd7ff824fceae90942ae9c81364b006fa9a631436b0eb8922e51c3bf7cef7b250b59aaafa473798e4ec92ddcf51dede26ec1061dd3e3425fd550120414cfe763080e6d53fad77758eb01e1138064421fcf1fa7c2e1110a726109c07ff6600259a9c07d5dbb8f6adb95e12a2bab288e121171e4b6e6ddfd911968d4c21f8e2e71fb68694d58fff722a37e150686786e2b305abc965d411c334008215eaaca9008cd794161c2459d06b07103c33662b3816a8b68cf64d7cd085687bb27e290c36f1eb02063a2b53cc45666b97e333a984ab38e879917b9dde0fe6537a7a1b37df51ba984bf927206e05237ec7af65687292d8f865cd498f9b487aaa0850cea8f045c7f4d3db11641322bdb4eb3dbef65f1f3b689e685e6bb0fe45bf6dfd6af2811ddd041a35869cce93b28ae9116437f7444dade6ed799e79851d77e22c9bd65513eb65523c01a18ef5de1ca472ea83953fdaf8832f2ae43a8ee3d32f9d12e456fb5ed30efc8f2f65e885271095e02dbbc65ed10c6ca2d5ae8af4266a463dc324f4661e14b3b2330456493e98b4d80450c1482ccc73d3b0486205e149ba558a28acdc1a3aa65774728896f46aad1fcc4d068db9cddcd75069bbf9f3b40e3eba792c609892a777b74f8ae04ebc1976ec11199f650ba1c7582ec8326d8c59b98e6ce41ef91f7e5cf4c9f57ff09630b363d5e2fcc7e6c88057f6d125ef3e2d92c1f0176107f6c63f07b1a547abd80a5b70fe565beb8124541948f9083a44e5f786292db9e8b28cc5577ec77ca97777809cc671518358902f01c7f6e49f0c89792a643b2ac2145ee07de870442908c02d55d12f0c7b8263aa60506567ebe5880579edcd2629395ba72f2d76cf20f2cdcd72139171001a83334338a7942ba83fd224f79cba84648411269bef13d641f6c719aad88c4868b8ed366ff839353a45f8f9be4d0ba3065ecedc338fc5251e35bed373e1a6b16048bbf2833efdfa5938a9355edf35a7bdf891a87f2c830b4b20404c1714414261e0f30386cf5457c6f9d394634d22ce72923fa5e436cb61b5cd7be5388355703efc116dad7bd66ade8178a5a5cca2b7c3cdd348cebdc6160e0f0015663026b9444d5ba6693b3cffa84cb6a2582ef26605d614be4e453fbbaf36acbfaf1dcd53850b3e1679c1b5e3e7bd1086f2a3ba44739ec833ed7de66afe6941d114c743c11596a358fe995bec4d80ccbf651c927470affd36c49dceb0a9e06bae404e83b12c3e4b597ae21f32f05173b4e32679d608e874ea5e98e8a3d253d587cbd91b6055ad4fc0383df1b117fba60437a0714b0e79434e73442b556a9db36cfdf31e569b27d47bf11558fd3e384b11bb84ef4c133f667cbececdb490a07c2661732ae2954cea40f69849100a319f697c9ec2fd281937ccd60f26fe5531e5d64517aeb32b96afb2966a642efc4b39de5d8ef18b83b15b8cdeea6048c700fc2046e65d6386159ae440fbd78656ac2766ce2c58b54472a56182c0b1dd3502a264a9a34788c154e34db496601d81ba891df1db12704fa0db4f1d3735451cdcc2985d2fb2bcfd867de237ad6482b6cb48eacf57f90f4d00bfbe18a1554e5886c2f217565ec0f2e1eeb627210632f47756415d877dc3aba7da3bd95eb700f906a2866372cb95f363c2bcd15a790179f81bb496739953f405e50ee12552b7a0df59ea763f1e5a0a32bb96d74f35622f1239fd2c9438a4d23e28cca82a157bc756ea0abd8253b4806357ad1b50aad253f8806f3f38367c88d2cf113425ac903378e68492c884da9941ede662626c48323d562a6884a6a4ce1cbe032d82bfb2a84bb17762cdbf22ed6d6eedc053980d6bc70a12dcdd08c933b46c90475267aab2256944dffd60dde0d8fb9c7078ff3639e016c708b1b6d4b2307a28a64e3334b596d1829fde98697d96810869f4cdc5469fd00cdeff74d5e8d0f08a6d8978978fe8ce4d92d1d96d60880efad58ab88c0cdd3b2f4f7c0606e88f519a05994d0a27e2a63c424ee7d740c9be82d1980b2d07649ef44cbd425996a50de58d61f6b53e7753c6b0d3d79880620785c7ad8b55822cd278bfa99a9f02b4ea70d17785c220a3242de9b985ceb52710a8b8165a6b2242de9fc2781e38a96253d64eaadec8aaa7b3a2c94a24fa9ec5d8fb089067f262b553fd4c723d7005d7bc6a6effeb1eafe506ae572e6e4e3370e42622dfe92ce8b742ab5db99075d4a73d2980d2921a7e0cf80b4509febef006e75cd5c14e9652550f2bb063e39bc607a5db403b859f0ed44b0bcd049362caf0c99f946293cb8005bb7ad3d67b134a55259262fc77a5ff08b844d63f2f5c72a1394ab48de2736ac289da167adb966ce6440e293b93e5bbc33a5629fab0956a6415f80e6816e953727f83c0bf1458823537e83da28047141d3b4d38c35ef1f571fb0579e7b68672e744273dd5a7af535990eab4cf10985fad03377c1b65cf66b3b181254ab2b8d04b40577f6e2db9b256d0b1dd06c50f4b6839e06c93a9adcc2c92768db7e99aeba329fe470d679e195e327e4cb82d8b19729f5ae250d674518068037bb24f53a1c631545298a8adbfa9372ac6be0f38f012ebffb9e80350c2a8f83f6176cebdf5c48a4d9879e920fe38d905d60b3d6258c106c07220372f7dcb399df0ef33492288de7ab3f126d6405872a2937ba0bcd399f57e5aa67229db3d1ae6b33d14eb973c7b0a99a210f753d1eac868f7bf27657c496046f7123e790f473e3868735ee92f5dab9c7f7646433e926785cb95d0110609bbdb96298ec456b42f1899bc20d0856be552d56c4a29bbc9163ef49d51e1217a7bf784d63b9f1a6b2dbd2a276a437b883232976b130620a889c7406d5aa9dd3c3cfc39e07dfdfcf5983f78cd64b9aad864ae423e7234fb244a79d635af97d97284783a4fcd106dc595aebe1067225859932f47ddde0fc9bba45802a188cf92da026f5e5026cad0e0f86837d0025e33140f7197740941ddd536b85a84b54f8cc1e5acfaedb2eea1dd62c126403a7556fd28367ffed0ecb755858528bbe1989eede0b695901e585cd7e1743d56ae3887b8065ba2398470c70ba1a547f2591d935db26f7eecbb26dc76e46bf5127d21a37795f28f0a7b7d5d1584a8a944fa77eba0a56e45ea6d371f2341cdc24861997332c46e1f3e524d216f1837474b3a1dd2a6c93f4ae1f51a4e00a66ccadae4c974c1785e20887dff86dc43e749e52ca0c5cfea1af2407b1477b8c3879d2fa201c43b65c59c391e59e48ad6748","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
