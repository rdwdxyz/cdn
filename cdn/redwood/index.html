<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd6f18e4746fbe9bd480383b375850b0074a6bcc473e56919cf72d0857fd5ee994b03a0405ca3042ce014b5579263865df7a83aa45570eb6fbd43c2ed3a00336d81346c5d12844e080b8167f868068df67a2faa54c6840a16af21ffc4ff6506ff715009600d65c40c3cde4fb21832a9ee2c5cd80f4ded97de684f1efbb83384a4d5812efe12063b75ac3a2347953795a1e6349379db9a0b8d08fa011ce561e2605722bfc5a4167b437fefa7afbb4527193ca3ca006904d9cb105257ee63f02f2b5c457d83653f95901ac5b0ab28d191d6edb59224e203c8ebf335582a9db14527e143a4ad0218d67633269ae6421416c5f14de60033f044becc913d59386b0740d776d555386a8b4968762b056e03ed426ea5a6ddcb5b111d92b70445de95345db683513edcb883828ad0b2455fa611c1b7725e04b5fdfd7a93544ad993e73b8f6818477ea150e04bc942341889cc12445ef302d4d468a53aba23aebe7f63091f4ba0241f84c977fbcff8d6a34042b894e7f2af2f7cb0c886271f6e39895cc92e14e0a4615a0216067a7a4d4564239e6a6c8ee0c2260bd881dbbbb89a6db509e79d63fbff0c06d43d98db94e0ba19ff07cb5731d80de45c4d944e39c19b845c21f096ee9e96169ace43d9a6138bc9d2e2aaf1642304a8ad5f317c02dfede6a68038ba804887a024868647299930b77b42b984ae400b7d3ed08e1a2ae043e083e50928238df98eccaf3909fbf0743f0eb09b1c231bc0d52e310ba040bd58cb048c572bf177a7a50571bc1eb02b97190e1bfeb3a82a42d98bbe2a3d0004cb0bc0efc98d45fbc6f94940e31728e37955a50f81893f455eefbbfcbe8c29a043cda59a7142aff0761f1af343eb60a271b5410faa7612abd17d03098394e1e9733985a10df9930f24037e4e146ed1032f381adb403168eb5a6b1af73ffe599034b59047ab1dff5ccf9fe44695a3cf5cd79b5660ca23d25bebb68fdd2377c0348049c02e2bcd135348c6c91fd0b0a0994d317d3f681e75d7e8daaa52144aa3f4afd50950895f7947bdc40fdf770224de5b7d2aa8d631672b22dfdf996d2d2a95e023ada83f9d491781bfb6de8be1e52e322a63ae6f870dfad0d51db171f686a202d03a95862264544c20b5f910ed26141ccc09e12a2a7dea7d296a08d65903128f105bac57dae0b72bb9c864cf7d6a7b116c58188e787a3ff6a1b1f6b714195e6a4c469dae14f91aa41b1124f180a4266f913894713e556256a6b95f17f224e10d985993cdf0fe9bd7f54ad45360497a2cb86879db106a6589d6bcf25c7164dd9c84efd0a397d052947bb1d7741111fd589a88a60c5fc7b3e6c818c14498d10527370564642ace7ccb9fd7044f86f52906de17ab4391625af02021d02814d1cc43923066b55b8e424521117a00d3373942d9725dccb46e2d80c002c010b299022ea95e3f5aa2093ffb30a65403b9c8e71ade623f7c8311f55163a1d39f9bca22361b6d12481ab1ea1817ef0d7c7a618917af79c43c7ed595dce94922e370ccdfc12b7696977f6994aca1b845e0f9971b2531d9858d662599c72fe3ea6d2f1728f985e98d128bd7fae16bfcb3646c8ff959343970070000dddcbc80c17b7d8a084b3f9b889a795bf88892584d8dda079c83043f8e4f6cfeb1229d7c94c36efa1e9bb65ee624d7dd8e6ee470076ddddf3cb8962cd7d5e783418beec199d55f679934c1d9211027505e4667968ac20072d08439893890b3cf2de52b337ef627ea8089481426afe2f4588e228b9f7e31610b9f1055e696d360bfa913b194dce579c5dd5a66fee4792947bc264e66db38da789e7146e3ec2e35c338587c7423f058ec01416a9927d4005c12f3acb86abadf04955e633b345b97c7527c41348de922a0ffc6f4ccfc7b09c3fb5febbdec5f240c2a239fdb77759993cfcd44ac4926d64b2ca1439bf64731468fd17b1cdee157f58497996de7e5d0cbf99dff7c9f8272fe4d0cd1e78c784d643375713756516bebc95d052b372fe63c3a184a2b32fd5f38fad3bfb21cf0f4784e6afda20d1e56ce8b13e8fb963c68b22271effca323786b2d32825ea594ee9497e9ceac6ecd7bfef0f389279aa3e2a9a554f1f954b7678aacc208d4d36530abd956d467de28bdd3890aa6d8a187209dd885876c3a65f122376546d29e0a9b7d2a45513f38126528ef55652b46098ab5a4cc37d99b4d610dfac975123240b7a487e246ae2fd939181479c87dc0335ec7954f61f391b2bf0bdc100bd243b5670b025a1fdf8766dc9530a78e81c511477c5682462b5e34fa675e7a1bb77c05f71f927050a243421bf129281df56c6773cb5e9165a5e5dfb6bb3c1b8edc622c4cbd23fa554251fb6cda65c9c89e7be06c7a8880e1e5d11d6efaa6c9eb248d57fda6ab473abb4e0178643a9bef674ba088dda7032a1a656df4e13f301e6da5c028f6772397245cc2f5cdf5494b229d26918a845be02c44cafb56bf33b56abb6eeb4775556dd0be1d2c68807461dbe9018fd6f1d1f35114445994794079c55c731bdf7aa8c7c2a456e085bc5597edb8ffdfed07446a7a5e53151d3c3f95b9eec79eb8aecb3222169314e4d5afe74ab9f78aba15e192415e6e111540a50e587e78b6195e216c8b687f48b17014945638a8d806019fc093d48ee86aab3d3215b4e8c50aea33e0d4f3e54c2517d5899507187cf2a763423548a24bb0dbdece3f1ecef03c8b4ecdffae682d153cf8843d8687123badbf05a9d258fb4b72c436ef51c982e36a4b6cf9961bcfa4eddd2537deacf9d69fc550761bfa6c2febd2a5eadb0788467758b8b1ee6679f8ec70fd2389a75f5e477c2d76574d8971c8aaf7418e6b15530bb795ae6ccd39cecd9435a55368c1dc10719c67f8675ed0dfc7f062d5a47b797b965418751d4b4e6d2e5a3b99123d3a9144d7f43e3da2fd6200f6c573525e8be6e896c1a468e8ace559e09c07953cb4bd0b228db07c86bbee9156094b62620953bf509c0091599ed83adef40f104eb9abc724feb3f00a46790ed0ea52481cb01d17869f697a5c7b27d5b5e8d0e111438fa913c62610ab1f6bf4dfb2103599caffa19d48a87132ecc3a834405b7d31daf18a27f304c2b728ff31a608b61274280550dccf4772eb8850fa5ca0396250043f90fc0a470007c74557a3afedb25f3584d15781b7b6c41614d87ba102b9e89bb4fa08905e76eee009dfd68104d81b705325dcb1811bfea6189b645811dc540afed26a9764ea43de4cce56f411bb68728b8b2bd6e46ca7b86f0671419a7a0e9ade843aa87443d94015cb5d5dc6a7f9a1b632250a09d2534d424ca03ab9de10de2b78acdc3344e2a2f204e2b67f0d32056d370a6639f4fe09c7011b81ab6f0b8b5ebc18c21089794dd5036b5e37de6383d7dd19335e2ba2e844e4733d271c74c6c4e24d37ab58ab598f2d29b9653cb4d02af3da368fef84f5bfd9ceb9c3362c6c45413d9391768ee2794922e55a42e430b8c9a341ecbd3b6a0af37f9571001d204115ba785ab00c01558c611385ca4da9ee37b2773526c17887232c9053f8d8267c5c2b651c1ff2f45bbf8fe0c63d3a4d28916fac3f9a48757559d3bc1d17f25686dbdfe9be772130258941376776ad52d5fe19246e9399b9a12f4eceddd5dfb7b3c3c74925fcd6e1deaab3e1df646248235f2724012461855ca2c550e35ff74fdb0a4eba3a9cbf4974c9bf652d99ce07bb59867234fc1d464d28378ebc3a807912f839a302e9de77a8b0633d32505730bed586a1cc469380553b042f60c03432eab14156b87b92bbb85dd76e73290fac7233f7f2804e3b2739cc2877c451797cea7fec616711ad0459ebeb85033cbebb6d23916e00d59cebc40e1f12fd1cbcb700800277fca33366fd5a6980949700a6c6839461a8fa7a0efcbc95d59ff1d11009d6685dcb242555b04b6b829221be514aa7306217f7cf229582edb41b1ce629239c9917a40f846b2abce7f06c5f38a77a787045266690ec4118cb9263e9cf0fa0680051a33eeaf08cf60e7fb7fb7765197c94a13cbdbc57b92f52b72b64456a238ffe16e75644b15f075c9be69d291fa7341f31c857d925367e1f16bed6a1442696a4162a96a9bb58d95228e90fcdbe8e022ba0ce5a2337ec314630cfd22a2aa75facca90445ebb80e0025c83a720faca315b2b378fdca4611c40f79e715b059dee579967fb74932a2c31ff4118d8081eec901248b3f1dbba714f183d0ff2673583fcb55716a0263c8b64bf880e5a208e15ab6f798249634348b678fa68dce9146e1c39c645264e3297d803d336ded4734d5f58356b4e3a8b51e9d55bd4ab8b867b47e99fc95ad3f47e2ff786a4677027a3e681b696a66f99fc46f4ab4baaf65d9bddd84272bc3ffb05d62c29cea2db7bc46c372dbf4f196587b49cfa9048e72330172e895b889a76cbd52883acd69645f8700027d786499624d8397e9278e8bb298564b90fd324c224f421c898e76ac4a0eac665aeca83ac71cb4eb70da5e0cd8dae44a4ee7aa6b52c1bc249c0f77f7a3e46e9bb3c0441bb1acfc43b1b70121e26916bd0e70cabf97649d206e329f07f6f4ec4633651c04919a5ebbf2487eeeea0127e6d28aafa3dfa11fd94f861db72adfa42be09de25bb49c144ec6de34d28c5fa8312af58dacfbeeef4fb49e4facf60f9ac6d317c606b08cd7762d35ae0d855c84a8ad970b757172406778b0472080a8ac7221e92884de9abbb68ac9d2f120ed57bfcf34a06889acbba79c1b4a1ed36c3038ab9ec600cd172c94a107daddbdeff6452736fd367e5e94278153461df976bdebd4e919a58163dc2f6ce5903a97f832a5da2fe55e428b9f76589eef422f1478fb372a7650c7bd9ef42d334af9ea08d2bc5cf59970103cb5e8a8c269afcbb4e5e36d1d3e3403bb1c6b4b470f8628133ac8c090cd0de537d0c4f870ee085ee9ef9b322f2bb4d6e8a23781ea4977b48738c9093cb284b76dbad17e24f1545f970bfb2dbe887a62fc2c8b38974e240a0d3f0312a5c5ba37d09d3efc57bc36c708154c41c92797500929daf77b81b30f536d5bb21e474a5e9fc8e5126c938c3da2f9c82ae03699bad4252e4385fa808816b09e511b870a5ce99ba46df96f89e9b6080d4c503c4a16a6f4922f39b37377d49c648a79873b66d745adc840676c04815b84c54b21745289efb52eecdcb0d5536b7372a9ef084d2607d983440cb906871cc6bc09a1e61ece3dbc1413e92ee681cce8d1a944acd9facde96aacdff585dcff4ed8be99b3260059c3cccdfe332fc242ec2451fad1b996e4fabcdc30f9547a36bfec4697039fd8e815f732efd2b9880cb033a80a3d953d3167771ce753211a0bdd6af17c83ad20b860a4bae8a872332ac8b04e4f8dbeef331873fcebe1b53a6871d0e39b2a434d0538c2cb7a4080aaba7e48dbc2c5a99f4144a1b2876c26fecf23e0c0ed44ea978001e4df6c69bba473ebffe602cde21f3877d377af5288285b41068090a87c38966110bce813be3aeed032e154b8c72457438d8dc0da824b132405b68a823bb9e0e6d5eb05916cc38bd0f536d53015f2480325caa638497b8c5296cb9b03b644256f9b373edb5a557f18d5c79ac54b204f8fabb6ee4e312a0377ab14592180bd223d394e34f58cf85abc77281fe5531c65a9138b01fd18c624b6bfb75a413b3daf40e5be8f20b4ddcf6f5e64a28a5d4a2c72540954fcc60688e6ca8dfd8e776cecbe5f76ecd24f23eb9d9b0ae8dff994f32404f90b7b5a140461b53686d57cd7ef3048d2097ded6e842b9980a5d8b870141f2c4ec151fb979d5047c1571ef42e185368123d758f5203d552f4e1bf8ea119525d1a660e4e9e9146d4c649588cf663a9b2eb645347fee8a36fe6421a15bbf9237a2494642eebea090b34d48bd9fdea21222edacb8b60597f1a8b072038e258bd882b5ca77dc5e6f986d0d8c4d213aa4ad77304d4b605fe5d38c0ba0ca2c9858c48eae7929c1b819406463c6d3ed4cd129db978526a447cd1a5b9cde7b0e74a1dc339a4492e3e893ea749e3cadf6ab12ec209fb071e393cfe508b9a84f0ba782769f7b1213d3b134c3ea50d3b55af0e6ffb9c7e527ed830f301c221ba15295d860df26d0c3503ca22827fad27670fbdc0202c1f1b481f46274f02e7ce574e37b1369161c6b30c5273fef305025fb160a796ae0eed291f6197f9ee8789dee117dfcfd9a7faa260ed0bdc0e6fc3d410af1c35e3ef240c1817b757140ad0cefb82147b0bcfcdf1b908a9b8f14fc41a7c1e3d2226cc57cc2a43f31083963ab75952ebbb8a372b80c083580a9388c4bdc0c58ebede5a78d5f795850e213b732e864017f7e66d504da61e833aa7ce4956c546d3bba40faa5d4f549325a9de0506275bd3ed02543a408935a654ba25f9ad1a36a319d9e5b37f159bf44c451c83ea0cda69da89fca873b098cfcd41bf33f0381a33eff22fc0905e6cc9af76f2ce7bcafd7e64349c9bc469629fc24ce18ab6df0ce64148adef7a7ce3f9f63132ce81d915d2541187e39e9a3ef8dbce386d6cc5ed4326cf32303f9af95033f3792a0ec208eac8ab6bd1fd79476199660f408a811c96846b213e8f3ce577b6a75b45e8ea3af6da39b7dba710cc7ae8bedb2b875aca2898af8453577d5fc9e7471f9f5f98ad5a5df35bb60ba481f5c921f63bb1b81a6af78c139befa8becee186fc76ca73c78e03241eb47307afa3fe7d83314d25a178bb8efe4c973364c433339d92f942c17885bb6037fd6c0a5dc064eec003957a3e82f4ee6c6f9e76ee927f0a2b84947674dedcf98148dce87f640d7fdefa5a07e4a08e65c66ac892bbf191184287e218119d3dac6af8cbd68971e65cd62331f1ce368f8fbe4051a496881462a80c3bd571665ff1c48392e9edf0c2ee639e9fc586ed157f728496e0f8a8c8e928db116606335f8cd1555b5a6716c3856224724c987d1e8d50c0edbec93d09fdebd1ed096df6461f2485c7610cec6b6b4a000ce0a295b777d7b5cb1a631a2af40537f328bbd34a9fc06481bfded83a74eb7bf39138d2de0c7c3529622d102986c34f41e78ece44e21320ef151de14aef5ae5950b315f3de1e113c98c3181829ea11ccc72d955bd89274c3f62a903d1cb28647d702f5291c11262ef0e866334b38b3febb3f83936b4c2322bf682a4ea0c9c0f423aa5a972d70d1279d0aa955768f8ac7229f2b03f6f5b589e15edf784d5b89fc49bdff68c8ba08f1756145a4efde4fad71f4c343d922e61d8691f0d4478c0d309bee8b94af17950905e2aba42a6e0e5dc3be63e990d8b4c1937d596ae702358f55b36cfdbaace68d7ec642d5ea0c3aca961b434ab5cddfc1aa5f38c0081c018bc1b816337b0f061e6cac6a45e88e98787b50ad71776721158c0ff99b5c85cb612e23d7895513304af5a3fddd0048d07aa1f776fc8641a0ef78cad7e5103a0ffc50b60458e6eadba07472fb209ddf24ffa3abc190ef4fd7339a14bc88e4fb376364df6b7c61f30b87a6c2135db0345fa6e603bbcd02f3e92d74a6aab004bc06bedac8c61e06ed956f52a57f37a42554b4919b49d21f8f1992bdd5abea415d8dc9b986fc1042edb04db1dd62f77bf30427585a6feeab216cf7a3c55ecc6e1a700ead2c8c08370463fd82e0fd6cb111748e3cfced16d55bbe1971ac8a24d3c53a4150e4bc4c9a7b5a0bdf2c11122f0a7536260676a90e294205e6ef5a731471a7f6d51a9b65ad81941df7089ed1f2529dbe3d1b8e79d7d4095a679dd530a9a75a191c30fd02d762c3714197d0ad2a3a27d05aa735a24319b59517ee31aec62f25b2a3fb6cc943ab80d0e58fd7db018d35adf9b21e16f0bfdcc9a2ae4d20e550e4819f346bbfb3a9746429148d02a3418b7090d7a34881d7732032d948849f003fb3088b09d7cb81231dd3497b2cde0e4e5cc82398eb04090d0174af9281552e3bfb0e931a55fbf46816512ac67c1f4f2a793e40c4e7dd95f0ad98bd9c5b769505163207f9fa50d8a9490e49717580093b5169cd6d8544b70925ccb5146e5ab28b90f05bc0574f3c8b9530996f337fb06580478487d869e811fd162bdb528870aa1216f4bbd166ecc1a426f22e2e8ac619859eaff802cc560d18f0d502f5e612c80662070f20e055cb3c8279f8e572b226defbeb98f75c8517520c55637a4b6e13400b2339686e083ca35bed2466b0a9ea07c93141294fa32d402fd38e005a27365a078f2d44adbccf4a6648095c63916740c8efdad58aeabf471db92b95f77377e17f9465a8a89e56f024173bd8b665632a63d691af63be9c55ceec4732911c028f0784d6e53fcd185704892f4ee2e7f691b8957dca3a341b1a885b35475e3ede415dc23ae4c366f6f28c3c5dffc8130c6c1b08ea8630cd80210d29762ac32da35f2b7a064d5e81095f681f9fbd889deb85b60ff9a17380bb062a57589c62f2f6828fbfd384291de9e8a3b6b160e0447acc1d734f3ce3e85c79e09a34fdbd6b040f5abe756053caf67e41f5af5847d55805402fcfdb91803012a4906610ed318ee0edc4752a5255bf8ba185bc3d1f6115535a510899ba6fddab52038db8795ebd4c96d6cba14323ae6a1c1c9e98ddc6d7f2e338b3080c274a7a217393cf403465b808f1769fad5e6ddec976b9c030b2161febe55ea6ba333bc35e3d5ec24ef1c765ba2f06f49e3b153e2fe9f79a20009e4e19abf1e269c2c2b975ca5472cf0dfe58a0bc7d77fb7a8247b124f4a917a94eac417d8de9b721b91b52a5c0d2a9ec4c659c7651e3e877ee4ea85fab4839549290490126bf7e667716dbf39ca2c610d70bb7bd1c520e9b0b73b777765477cb4aad1a6231845084b776863d79ddb1e011f932eefecef06b3e1ce264e99679b70b3f15667b4ba9d3095d9a4bdf30e5d4fd4a5d4fcd2df30c58fbac88848966ac1666ed74f1f4548f82cf8fcb4ae728dd10b76e3e555f46347f5b2df4a3ee6e4f113f564e97d65e38ddaae6674bc1e9b0c7284d7bafa8e421a1f7539ad9bb0663c4b349f0328b1a49c8f467f5d257521c0069a4602756518c6a0aaea3ff7144b77f2f02eae99aecaf36c05eb680474a9b6a26d71925ee564542b948a14d90b00e3c29f00199de746b61a22c2c8aa668e3f24c40b27f74d20d9c47eaef59265c26ec17bf5ae305c5d72bf9fd2b486dd721cf4466f5f4a6928f74668d92367b8d684f686a73fcb16811fd2d494580920cef9f8ad6dba4726fbce87948f7f1cee900a01312aee2710a1d76b34d3b86bc306e84f999a6d1bfbdc5528814e99614da483a1e029200aa1919067cbd3ab4baab1989b1fc164a10e75bdd10f1f04a830b50e50d93552a58966f031c9a622b621cd021bab74ae866782ef08321c0f89042c4f4b0764ca870cddd6fb75df06f7db6c5dcb98405a0b6ded4bacb143713f28fa569dec89c098dfff006d23f50afa016602a40be7a18a769431004e1cba852232d667a68ab7d83ccf35a13b7350b8cb1936ef9b374fa1a7d77b71626d9c243aae07cf6e7db5772951cc1d68d525dae206cdf9d6f083db5394aa4dbb67774240c792fd2e969b2ee08cd54e2267b76c17ad23eadeee4d61c294932a73832c1da4ea641e1fd7911d7b13428071dcc451e2f1e118d4afd6cdd06123211734f5393ef35f62cf968c8e4f1795827319ef2c174c96c58effbf73eb425fa04f2d490e6322b6176e999da51e1db27476a08db1f1c8bb9f5501cf9ac2b469dc367ca42c9b7e6bf196e05e68de0908f936601eb03420082568c07adf99e673041e3fd032506e049cfd0236992119476de84ddff6c3db359e7db894870915cd30ed6e98c0c251673b3f9f5bd6404a74bd70214d3d6bfedc0c2c05743da03e732c88f53a450b2e85ae47b811729d52fcf36f4acfac70460fb95403fbbd25f80d239039a5830d5b1a11bef646e8f88640bf3596c7ea4bf58ebc2f95352a50c0927d9592773194d664b019c9cf5f3e0b9f9fb57f4567e3234dfa26efc58f4f76c083615dcb11c85d12512c738c7d9e890f09a895c5ec34734fafe41ce7fcd7f25c11577d0b802ffa8d94e5382b6b9e86d2b6cb54fd0ce9bf07618c64e0618fb9cd05a34723038c5e3aabb7022cc046a05fe50519fe40963be54a0b245895532b32fb4399a82329249d9321fb4c27f081dfaa45bbd14cf77d21246ad47ded02a41d2d3002b8cf6d4c9877f38b3eb41d17f17c0594c6c717dd6ba1fde215efc7e2ebe676af33aaacb3b179e07c6b36efbb3ac78d7de828a7009e9724eec445473f4c4a68a458000d153832f1f8b91914c5e9e0cc9fad8d40ee279799f929c66549c4966d53c98ab1424ce805445285fcaa4141eb1cd3bafa4e2662cc1761c103a0be3aaa1faee01aef7bf210e7df496e7d98a0c68376984d0419933f79eec4d9eaea71e3176c8111e656bc50533ce88966854be927f4802c0ee138ce2d9566292889cf042fb305468e52a8eeb5f41f33bc830c10ab28bfa418ce9f871740631f678bb4cbdb8ab885adb66e3fae4d251398f190a721947ea8217ff83012ea0d03e766de4657eee1be21ce38e577c0262260e74d6f71c69be8013509667cbb34bcc55dea2626278ca90f39b6eb19f7c76e9b8013914eaf0002211413130fb8f4e8459e786e1318ee5e4cba5e38dd935a03c0264566cce86d63c94a05d88377db545f525f654c1386c9eccc1a8a84e7810447059bb76cd1e6a8d98ab5ac9f1ac271f7177e897846558eb00960ee8bfa7b13c31ba6298bbc40f34aa64ec87ba7ca261ac090f44317658030be3a94b5e7dd448b0bcc699d503f799f5d0ac3fa55ed54170369db64095e0b2eff2da81dcf60d6c3560886de8b0a23459e3d26839e50c4699bc70f80b8f884016d4313ec9457926510147aed9ccb4bc304a4cad05d944d8acdc6ea098a5f4f25380b484c2a57ee40e24275fbb2f04b6670adcd7e0ed66ecc93073b6b52997b5043ffa1f8b2f131ad14ed627290741238c265bc1680c0fcf02f038648ca934441d25baf1ab13b4081be70e178b5a752df58561ff42b058adbd6d307088b6cd7746844ea39c9256c49288d242ae4c3f47fa29f74fafc88e660614bc0f8db7842a1f391d377f2c45a0506ed2ed70a8e8ddb3fbb1607d0ad5549779544e6ff82b82044f3623a1bc795174730572c160dc527e0b293f47f77b454ecd56a5ec8d8c6eb25fb7063650e30e742b8779f62d32c58b0f4966cabbda087f034ec50200ac8def1920dd407f8c0d442b0f3df3f788056c2c69be24a159e2789ac43097ebe84e33731f5c476ba634cd5f8adf1fd8fcc3c3138f792dac55b3480a8557c2c14c754e17a8e844da4fa1e06942b9e9c5180ba61771352d9b2585282e923c4f9028d3600b5dc5e3146f2c96812728cc8677881d31f14495c1614cb50d62b52361d5d644acc1b851ba78c00d174dbaac1922dca74a7ec95e0a2c3599349b3193844aaf5e9b45fb86482a69924294fd016233bd7cb5108c31d4b16cbfcd19fbb3cfbc4f56fee81e237cd7b099e5d6d1a03d71aeda458351e7dae70945a6ab7386c87eab5c5fede22595bf51227550fddf5c201f97c0f985838b8b0de8b2c08ea0b84ce47af83b1d24ab5ce3084b632b6699a5bb27b1b95370a8207b34b8f6b409c780014e3b99b41169be34c5de1873f2bebb583a48d7eac31762ba26811da99d41e5c2b9a8ee53ab6d3ec76693d77a72ff494cfb3d17d91f19d7a10a2648e599316cfd2345bf404d124ba94c0b4bba81dcd80d4501c6f26eb234a5c52c8ace39acd360e98b1340350a933d139f7021164e8f5a5dbbcb7b3d01453ea1c3b698384c51f23b6c0fde8d88ca3dd85f70dbbaad04a8e6093b2a70998c1082a95c2d175b5459f61b536741e149b44e2afd182b320a73cd2ee1e313329f819463dad44dbf08947b8026809846725d196045ae854c6231daeb05be331c5bcad47106335315e2322f8ab2018e98b628851bb000630279c2ec49c05d47dc5e13bd5437a2f499a9881fc1d679538c6fa659fb8ba5e01178e4f617d041904ec09e66ac648f051485f04b306c4fc17206c85d208bd6367721f9579179085467e6cdf776db6f4e4834b1d7c04f2fa0384858eb9dfbc75f351377482bea1036efbc7dbf6ec500ab557a08f190121331c41c4d1bdd8da11907ad523f12185a5fa918471e625a26ee317e7973ea71bec8b6c15ffb0b0861c6ac913324a180a65ff4142de7259de61598c8eca87c4a3b2ecb5c1d5e344bf9e88100088cd33d0c2f10d97297197e9084484ced0be29434e9774acbe9be331536034887c4e01275befa2aa14ede50e663d6da2af82414a0fe1cb1a60b8d81c33d1b0627d266cc86151af7a48a39f48afcb6e2414a2cd93136c86243e8eb2970ac04f2f97a93764c0e06eeab3e417ed009d75a5db650f6146f15a4e14a38db42125ccc4fb6ae32883ab6b137b6b23ca16028b5f33bfd208d24e005cc31442a19f10784aae4754d38f70ce5228764c7ef4ca1dc51cf82cc4dc1cd264a927adfb11bfe6b2b2f9a8c8ab8cbb217bac06991a19bf797c315a71d9be835d7a3b244495e9e25c1edcba5b5f7c33c1b2d935eddfb8e4810ce074978c29319ab7ac2cc1a0642f243ebcb6cdec45425437cde2601180d3f60763389055aaf3dea332b4044be8ecc4c1619d3f87de754d44f143eb53477ccceaaf981813c654fbb9300f19264538f2a8c712e8e150ab9473d0e455203683ee71fc5a29777ebd8408ae6510657ebbdb6c724af9c3927ac0033ffbadda63de12629c29667b26a78aede2a1bd805fce644034f15915aaa5a0a67d1d86eda830834a0516a494a1c822603039e77f64121bccc9133cc96ed902a3d89158bfd03dbd8283320b82fa26008825e2e5cd2319ed74b6287f9bc00b6eea54b47990b477667806150479ac56cfc0ade1f24588a201e78214068cb5ed43d4342360d7a8ae710412ae035b97156a468f0eebf6b84d4744141fcf52c829a13532fa41f97bf5d46e1c1b931526657b6adfe44e472e3d5e5b030c9a03eabcbbb6da9185d1d60e1960288307e6d79c2d8a811f78475f90e6e5ab78b75ec10e50e0ff4726b3bfa0c63b5cbe743a933ea4ea9585453a49bacf6d13cdd207a61705a360440e3be4172e937099ca90c3975d90b76d295efa1056993f3f3e45a2a161a7e29682cad3e1b2c8c297654a2ea5ea655d45d7fdb7626d7c6f4181f139a3b66273e207d1058e69fd0f9cc4af22523c574fb7824e4bb377876252425bef23dc88b0d8889b06051e5f03afe66e7285c60385c47f9607c301224339befbb817a1f131c80ab5ad9e05079e4016c282d7496521a713da45a6ddf4afc6417f8f575b5062c3246b1a0a0ea9bbb2bfc44c2a63ebb4339d28d935b678d0bf0c37b74f8cb9e3f92b123b1a7556f739b3e82e2a824d14c8d3e1f30ef33a5efd05564d74928019cac65908614840532c4ccd7254a53f1351573880ec92248645b880ada40b5654e9ebb0fdbf3c9c548701bee81646d3be91e7e715e2022eaf97eb12e378c981b38767311960fbf7e11f8d16869d517303ccb0d2f2fc1e6b8fb293fd12583a3632f475610142034329ae5e10565ead6e7d0a2a52e2a0cf0b4e164be7738150637d0c5e4c0ec747530733dce6849c67ff5fcba9e48e25ad22b707ebed9e325ab6338d8b040a4c70df1b013a0cb1e096eaff7ae96319aafdacd4baa329f135532e02c6409cb0e26d100adbe96e1ffb4657d54361da673c203025628c4b9e50a68ef046630e47848633e64179317d744d4e719787e2418a379a38017eab12363e3c0d35dc15b66acf8f35d596364f0dbfdc4103a65820a3145205e32b6e1860a2e9cf57a3608b3a07e017b2fce5f8232fd7c0974d0802a7c9a26e82404f2bd42d3e5a1752df16ff3744f73a06597792cff635d111292de4ce0086d2121791facb7210d3c89f53320772627f38a05193ce302a702a1e88a74b577aed3b098764c965ed332e9236adc424544ae8c8bc6677cc04eb27eb2e4131fb9d39f5ece013c05e5e8489c39729960aa2dfbe1760d25cb9ee0b0b8fbe6db61d604141ec9171152a478614a5a948f3ef97a89675d9b295acc102f5eae887ad891414c176b382623a89f40cfaef0d97c15e04c62dcdcc94fbfd418113536a4843064c74ab4bdd05e2ccae06c00aef784de4fb83ac69e20a5f1f9b59c3d18b14529676092b6ce14cac4f0cfecc29273c94868477e568689404d6b87564ab9d88e742d16e8b00177d90c7a65d9e951f3a7d7fc3ee31a97cc4d6484a19934fad184db09727fa5319949c6625d5215f067d5a4a88ea44a7181064fb4b66eab4bac8e7b0423cb10a6a932d7c175d50e43ea0214396857329a9ea2d3e66ae2fb40d97b1713f774856e06d778b9d564ec9714a1a9da3b401d447fc4beaf5c5a0159411bffeb9f34bc7792b6bc5f31157aef26337ffa1ebea68547aa8dd26c536866cf6c2a002448e996e0d327924b574c04c6b676134e15fc4216544b903a5bbfe8016fb4438256f8e0e9f10ba0e88dd8a87679732b323e2119e8e9970fe31e630f9f39cb7e0d188ca65bbaf0a8da014a139773d06adcb0733206da927bc6bd07802b46e4e936281b47451d6ae91823d3b066c4c5dbee05e19f243c5f81a446592628d0e0fbbe2c274b60ef10ee383e2227a761bcd5f3746c5414d7f37e9612c0ca620bfbeab5f75042aa50ce85916e60e53ea97a085cbb952c9c109813919421017edb86c45e5f11f86ddced81871f137262322354f12caecf840381d260b8c1a9043b4635f22559621fdc62fb87e562a4a5b30f9eee002f554b57a63001c4e18bcce146266a176b1834eb0f51e3ab81d6e673a47f9d0ffbd263b4e311b9019a4622d10776ecee4ea069e56a70d9d5e6abab5156a4cffa81ff854cf8985b5ccdf6f77879ed3ca342b8f2a764f381cfc75b34e44bcad9de814dd41cc69eb22edf6bfa6178fc1772fff117b914ea5c4a8e1758b7dd294b5575af1d5e1e7560bcfb2fa6eaa5bb99a5781a693ccf79726a551d5c8527b8568f8cff810917318b7f5b1899a00f6a1f7b71e75886b0c209c76c0cf06fca39722e443353859d5f2ec8a770a31ec1f0de2bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
