<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d52188dacf7a9e58ad4ba0c6147aa32c97809c6e8b1f5ccf7e4a36782ea0bab75dda612d2b53ecff7e16a616a0ce515d495817aa4f98b614dfc54af67612fb1d8c5700ff55428bed4b74b165212e261b5d4b1070b0443b591ac40ea84c11975ad0425ee00d9b732a7cdd69067d8b9bdaa5688305eb20f6af607b4e9796b1b4793218a95bdd602443a3a53f33a858a3b22b4d662af3f6097c92aa99045baea1d2456598f5f251f0e839963d0f027e95165de7eb96a6cc900969036674b3ab5f7ddf94914c8c1b2eea30f346a64176c4b25c74a629dbab4373f27b37ace5b9a8b522d33048732de0acce3b8fc2875eaef6322c5f528d4a61d0794e385fc34fcaa4ed777fe528872ef3ea9784144a76c9c63fda32869ae6629ac381660417574709098450fd1363ca9f5fff2088c4295187f84ca00f54f635c4154df8afd7edce4ea36e3d9afd6eaa376f665b1504b77c64afe77e1a19a3bce6808464b286f93d5d65ae1af7bd9df28fc1fae1ff160c4c570cbe9fa38e026eaa20229107831e2eb1f183e9c51643bc05958ae84f012d8a4e9acb65da47fc38a03ae553e8fa8c51d2c7210a1c4a41f897985204db10d70e78a0fdfc222720b423cc9693eb300fec369e56c2c53c9a711f1684dc4fe5cfe3fb54e0261da7eb7e9f662e5f0c89a05e01aa763a044037b66ee93d7267b5e893ffbb0681f0b7056258276bf56d538d25f0651b1555bbbad13c098afa7dfde5a64b9f944604ded01735d85406373fcd82586af91652e327903fce0bce90a52e2cee67a60fc4acc160451eee7b8cea4bd1221bfffbc869977db7a96ed53d881bff0a04801d737d8115a69675ad2009ad38d0d7055346f34fbbd682298e8f23acb38feaf55e9e0d8ae6cedb503d6dc7c1e376ffa3f7c6c16d582d323dc42fc9526feadd5031bbde0df1c307e6373c85647581a5b9cd6228bdba7f265f325c777e35f0b2f757e8fd7e81cac2a3a9cf024655553c831cfd67ff1e8949008a312bf20dfcb2dfd03b658ae53ffb823e074064af6d2afe2b81adb6601f33a4a79a0979d11fd88fda774e0b4b451c596b0739f3322d8a86b5fbbd160d5d578d3d751daf051a970d7af3303f033384923a3cfbe85e5fdaa9fca5058c17da92e892b7e17263fcd1e4e3bda48bff429cfab13379875582810bd52390e21e3512acf59690667ba4522c4b3e1d5eaee491a79ec0ff07f6693a6d67bee644abab4e255ae59ccefe88f2632a870b86413d1761f8b76b322154d7e7e9dfa8b698367beb4d97cc95ca9a689087ec0167f95280ba10fb68338d6955c459a1eb84913fb3b0649d5ed4d81b4a88ab4c5bad8cd354c2e9d2138719360f0e69bac0252125df6b3f94f6b7535640d0299cdebd5245543a3e03b5a619e1c4f5ea5174b9f99724396d1d604aede407fa0ed94442091463ae339353408d680d46c3b3e6208ba9a8d48ded210e76d28da775884c9c7bead8f3f5222f67662e59a783c282e122ad36908c9a009b7ea8b053973f64511d9cee7274d872120c73f0a0943ea176cccd7eadcbcc250ae52eff1b9b9d2da21c221d84859b02beb5d4bc927ad4584a41278d3802449712d1d9e85dcc2af21e9c3cd36bcc6958ad725405e1d8c6e2c47a05f20bedb85d09ba1f81aad6688c03272b2d60810755d5baf2693916ee313283521d8a7ba4a4e6f5ecb1a33a771d2c8896afb91dd2b19223f78e1fab5ac6c44a50d352f3c970e5ad08160615c3fd48b1b79c816964ca17674327429988abf23a8107e6440ff833b1995330849d601527678f14ba6380333bc361a29e9fa460ad640063c4dd00c4bdbfeaf8a2efc19979dcd44193225a5e98efc9a76bd96d02df0559912ad12ee554cd9616a1f06c8d81161a72aa6f1a06a3a60b9df7449440f57eecb5025328089d61b53bc1e1f322730ef13fd5dbbcba25cad26483a1224a11fd82cf4042cc3dc9b1ffda9aacf9e4126f349223852caf7cbc86585c5c04dd13a2889f7766a3c19ac3a5fb32091d9b1d11ebf8550d696cc3fa33b722aa7fb42d67abaaae9b934366f59525ed141f4c25fa999ebe222d444588039162381dcdc3a06fddc87b05c227619dbbf7620708d3665c329f447e27ca58f5d13a07adf414504b1ad1cade4a54fe0d349abb4bdb71a638dfc3f0b685d0f415bee2c26335cde8188fa2d07295ae560fa06a792952ba0a61f1864f5fa774e1a7bde613b31236ba73bac0db734a28d3d9eba3f5e956138dc51be90e06a6e075749d115832b5747032d4bcd481e9711735459ae7a89ecf978223ae4bc8fdd43e94ced6ec211f6753807bb99a58cf50e76bf83c3d0678e675fcccddc6608fa81615827f50d4d5e9228bfd417652e21982ee972b5acece77b77713a39b3c4f1bbbd9ff890f678056c95300a37c278ca549c0257d6cff69a1a387bf3dfb1b6b5f592faab431754382f16bb80c86ae558e9d020bbddc2b2dfaa34cc3dd18e64f907239dcda6773cfddd83116f68f01800550d448f2bd42a69e0057b5ef53af180ba4bf1a1bec1204bf2592f4f75d1e1b5c3700005a7ee1461b021c776614185c93878f2f7de74372ced80d0d9d6bc20b4dd8988501c073c51762ff7c6b81c3b93decded27f3c108a8a5d3d8959b13e45c81cc13cc9ebb17381aa537671c8d1fbeb9d4e15ba95b57aca80c89a96108de9d4d3da3155465bd996c309ee4cbfeb809be9561be2294edd6dee8c233f09700ce271828de3017d18071da71bb23956ef614f35d9c33512d5cd9f7f20a9d8ebbeb2ca3ed8d77f61d1554bc6ddaf82a391644eae4b999d1505a0929efed0ca0c562526ce0ed471a0f608a571646e38d2a3c745c4932a51594bb4b422e5fae6f4ca254acb8d36a57768a94d751904ae5b13360ed85dfe4012e2d3406414ea8d641e2721734d2d081f09f44457ae2ecf2b69ebe8b1ae6870eda66b316cc6dbdb0849f5111eec45739c28cb65a8b4e0fc8c36156f88ad2a05db38b531fe8049a396efc50036fb0a81f823b0c6df95c708c73a881d53540e9a09b51d1e2ee64c3acce90afc361c6288fa9244746977bb096f9743e98ad9629aed60ed234bdfe717b6390c9017822ec2d5d11e22823fde8222bdfbb3fd93b3a3fef11b19a6108047dd81c47f0bf09cec48f674b5a6d0f7367420629dfdb37d512841193b5a8059ee7817353dd9ccb9aad139c008ed08d2e9ac0d754a6339528cb6a47b28efe8dfcf22db2f670cd304c2f6dfd32441b70ca590f299b36c7c246b7c4e8f0c65f51e571a5fb27b434ab262d8ed718b3e36d90be3ed8c6ec9a0af63dbabba901446bee8355cebacd3e91f4db9e86e5a210d0c536d1b7f6730723f764e83897e16d2b8658f0ca3021d85b455f847ca41d90982812c7d2dee16507a181dffc1c1bc807b1ddbc3a399446c48aa0f95dc0edb4f9bbf1ed58041389b9ab8304df73c5672261df3391616c36804e5da5dbb86d622e6ff3cef71135245de7526026050d54f1e34814fa9764c24eaf89c6cf5ac087e923a5a5baf3026681690cca16d079298788497ff863ad2772e0e279059cbc784509e31b382035339e564cc77551f78cec701de9bc0a118106f78120c85b1e5ce4b888ff09efa5859e77b097a5fae2aba17c454439c3eb11967a6b7d28bc82b28bf00501acd7bd997ea015cc459eb36becff492c7f61f1d7d037e56077868d6e46b1bb1f14ef6e96350807364886ebc1139aae62b0817c2032106ca28a7fda9bda4851e418fa7b17790555584972a7b6847b271a06e0af246c03664d3c4b1c227e3f37fc39604211181104c6274c140f9ec12de6ab4b2bffdddcc75d060117b11297e90187669098523ea1984f6ca182bdb0faff5c04de271c96cb71c44140b9112ca358a9566d389a04fbddd574584c5233f87604b78f20697558223a5898f223c96bf167498e8e39d27888b882e27489a32ea9a846bcc19d6f17cca226551690d33fbcc2cce197ade3a619f8558ef2229a77557f138e36107edcad739d4157b7b4811fea894d2b248be0c24e02ddd278298b1224d19d6f9c077e237b2b65b88c8514dfbc67bdb37e208f376dfbd92a539ec2e7d1f6da6b804d9575311287703c09d828d348ad87994c45ad5a2e199ebe04326859b27c5450aea317cf98f0a0d1dd667b8b193fd378bd52204813bc94f1f2114b9f27c3bfe9f2653ad66f854f562bacc803ebdd8e58510c842c00f80754db2330d812adea7b6d554ddfe21083d7f2d1bb3c04105a34cb04afb77d91eeed6c05f862d5b82de93feaf12f68aa86ab3a9e6a1acb665e403708701ce1a335c9f0fff85c3dd9c42aeb9e016eaf5c0dc54348fc9037f1ea6d4943d9594fcdcb6c24c686ec13a151deeebdca23d3ecc0cdd9e7ba081849f556add8662eea59a520b1bcf10f6e0f30a091f8d5f83a40b669f7e2e51ff7c7095c8ac6407136032b7498330990eb05ef5aa79d6d8ebde9924bae1c0e074d6e5f8a2a8f249970f9dad357da17ab7609bc421d4050a0dae3a141bb169ebe92a0d1906816d37de82ee760b15bd4043842fb6baf80b67af0b6ad8e028712e2e287925c992cc3f354ba802050fb81840d21f823a7a85c61fd91d2096f6497dd5543dffefde82e62f543e6ecc93d7c1178711506c409e7530f597b8d778f3758ccab2ff87af3e3559a373d1eed4033d7dedabf81374540675435ef1f2f3089ef612a2aaaa4386834c7123c2d74dca4f6c0e3192d9abd7a266523cb3aef1ad288ad8c38f40a9b241fc3112ecad2f4ec234c4d366881c69e8f825de25831b88eaca19addb609f91e3e1bbc5a76d50541aad4e056e4c5b37f0800cf4e658abde2e7333a843739890af0eac6d2edc678e08ad07060a063ee6b26862eb6fbe7a3b60439a29774cb19ade90c9c037af02ea05b84636babf35060b966650440cafe6969d37b5dc96238c37f2763685dbfb03c2f57417f06b23c3376bcf7879f5fb294435e648a8cd4e14ad454933b56ddaead84d7c90c287e09d4585b58e5af8b7f006f638779c0ef239df893add36db5a9503bb053f5ed70c83e8813796db61ec036d20f56b9bd5853c7068b7521a0a4df7759970fb561efd49c15a118820033b739969757a468e49289110cf98dc9d135c6b8c2b0de0eb9bf9651b391ce37fd5beaa2304ff0493a48d226533eb29c6ed99d525e716cd90d5b470c271078556bfd1e2ed0838b82dfc08a5e9aca771d23b2465d8fa136c400c622ac0b840d744eb0dfd84e991cdeb7ef1ce79d05d83e874a3d7709ecf8f6ab27a1effc2e86a96306e887bb9bc3b22be7f786ff571f6a9bc13612da3725f343f93bfdf8e72d9fe57aa6cd67b64b16b1f21cf09d96806c2eed188a47001a08b6e1ac1a1ab119d1fd3ba4695e8458ab0f0256bc291abb577db8487e2fb40a590ccee56d1fa845e0e60c63f0d1cf97f757576a6257a9af430ce792953778701183929762b1664ddfec727a08d62dd7409053dea49f3d5fd910a5c5eb81d779fc8da25ba94ce2dc0e98cbc5ea0191f649a8218b3ff0fe89dd6c733bfdb0ef9f5c7c7d3c98c5a15d818dfe0078512531e423bba066da047df732d808ffdfd07d6462ba5bdf119972c2fa8188d6f24455b4aae137811ecfd259814330d0b81900c9738929e5b8f50a951dd0cc0112e9de4a87d80ae19ed727961caf9e61869d1c0b7bd74378915473eda7c259e253aa2bc4b505afb1fd5b1cf763dd45f05740c1ce2a2afe8188d3f3919592968943c31257df59a4528ebfbc18eb61c098236b3c35615ba53cce8e673087cc74ffd8ec8af055e6b32b565706d7aef33886203cc6627db557a27b138f93fa00be355d509490cb0743ff9f2818959dd67b2494743c3f5ada09e3f0c191d106653248fbb76dbf6d0f33d22e0dce9eae49302258a61e8012e508727d093e7f85fe3d1a425a4caac066fc486fc742fe819b7a4ea17d00aaee0efba71c7ea0728584151632d40b3b84d413c69734108a8c57d5146ecc47a66e8358c162572545015b8dc2dbe2e54ed7bcba4ae88e3cdbb08ca08d5df63d5671c75a5bd2ed5cfa6efb3bbc26ff06ed273e8957fa84037fb19614fe1252443612a0ad0eca0b3e251ddc54eddc1374655b26efa5c5e132aebbd51826dee51a9b326a580dbef3dc8c12647ad878616cd3eb5f4c601b6bba06382abcdcb7ac77648d8ce3a0f52aed953dd6ade65c3509d4849bc91fd86b2b7410b3b0a3a519f233cb375ac054f9682c6d807044232fdda569acd896c23a257392c53d003d9eb314e861c7910318c0aec84036d2469fc56f075ecb086361174758d57825d1bad66611e132c83476eba934cd7050255bf3ab53af015c1b14ac680bf3cbaa432730093022b8ad911cd7d92f80982179d5de442072316b65565d62fbe6652cf9ba6f53540a898bf28589f62f06c1eaa9e7824b5e9dd2a744945576338bfa52733a287efb9ba0eef3c113fa23d96d1b9b6a207b1293ad9932597388c134420b46fa2068f0a1d55f766061b321026855b4d861a887687daaeb294e7a3f54698d8c871be1d8b00c899b9d41d0617752c1904cb401688da4be8d9222ee8722616a68c150b4d89aedcaf6eda9f2c5284599a0fe2962efa05357f4ead3855d6c78d488af94a5a4b4b4ff35e2390aea6d94c1c7ee675101f8fbfe898e85c149eec30c13bfd669e8f2272a9d8ef487cfbcd8792052b8092e79054f1233b786ba4a96fd4e9f0225a4bcf1671c15cc6b7425d4e20a00afc5ca8c188c7724945012092222ee580aef1ee182f8e621f7313001602d24271498cfb86d6011dbed4f4cf1ebcb9ef0037a2f4c70749c9991d470f9d84b3291a9ec282f8bc9a5f544f0f6c684ed4307b827b70156147d070e8ca8c4b41cb76e6a3f12188c3d4a0998048df7595554ef9a6f19cc013aa825af7832c2c4dfeacbb3cde8a6c939deff3c3695982a5af35353f4c3eb6afe75d66a8677f4ba713a7c1e25919d944b128555d045c297ceee5617b9340fafc75096cb6f04f542e3310be4b7c3f883beab7aa61f24c0e32be5c369d3d8e58d003c627ef9821564c00d5086f3455307879cbe110a207408cc477093ee38ae7ac913d7dbd22f22cd2e3e72cd9c20eceab73025f0b9414534d53c3478f1baa9052a5b7a7fe8654447db71e7ea50108e0467a1b03639ebc46073964fb5250ac227d20d4a851303afcbc7a8c68ef5ba0308b31d0dad973c748046180b3e877e09dec3de4f66ad0dc71eba1cb20a45ce872105fe216d781a3be5879e135aa7b7821075df82bc1c1f032507f40c92c8964d35f933f9d0f6e6932136901e228dbcd43a18c8af97df8c048ab884c480882b1a0d5a2de7637c01a65942c1cc2560504bcff9c559b7a11e9bfbe1ebf7e670cf01d673ead148125b84fce2fdd7f98aff3d7815d34310d2c17e0a3d15ec9a56361a2eef7df1fdd8c4bdbce6f8590fb958eec87aa3981abb06b90d6d60442cee6cfcbffb05faeb7ed755812456fed5390a8c56fc83f2e31a73715371d1ee78ebe68a539372d84202a49518fe667e2313dff9d0c810718e6084b8c993c80f54077e4e97de80ed642413c7ab1b5e63d98e7487e272854d6bd2a39bfbcd92b892f5175e676f723d7a6d409038fde07f15f035e9575186802b836420094bd04c13019d9cb985578611febc9ac023d0e057a769557369a8177d173acf4670a82a5398e2973136a46235434d08b3ee1463a169b30bbeef510bcdfe1c06fdecc82eea463369dd7099c88b98f05ac0a9d73e60455691689b32d9811ecf15335a6246f131ef93b6205fbd5fe69d4f4b54f1c5d4e3c26db891e5ce23a6c56f29b990d16e7f06dba3ebf1aeda2fbbc382f4be6901962d1ec2a64111b3bc754a9e8080ac16c8715ccc8cf2fe7ec093dad70a6f848b615ec521b106d6e9eb5142db7e3b3b4e86813b40a19dfd8087094920c9742de6f0df1dd6317514069efd7a37f709d4838a227fb79956d7bacc11e39cf5a62df398186ec62a14c6b670ef29d5ebf401b529cd72624dcfff0d924ea6ecfc628a5d3fe55a51615a6a99a80309690cd080a8c6d3718dbeada835d05904c89296e6f50ad90202d895c362a026785296a47937786cd65027878c99bce99575f83e8f71a39ef96f9e9274ade19979f6cca75fd7b6d1bf1d6553676ea4c2c2ccf42e4cbe339e3353e880de5bdfd14305827075d5a63133b1007abf21355b64511ebc0dab1165447a0425d1674c84155bb3c59d7073fe3f2e6168894a6c7df24e3d810f73c22534b0e2ebe05cf3ccb4b3f88718cd92aadbacbff57c55f01b021b09f7fc2722feb512c3f0806d99cca4792a4b4778bc2e2de4747f8faf64d9365b121185b5b4702ee52b5f1ade35b8fd6aee4d8eb22fb4a41e5f2e137d34312959912a01546ce91e1ce946b26a1537f76e2699e3ba7a244b974414803e764b89055f2318a92990b5795b0bc91c43e65b6c871963219a3812748edadf74de88b81560c7ac68d1ac054a7f67e5e299b2f0e0d9fd34d78d282a4dab96fb06bf2283bd21a62ef8a627d42b8ce58a7783148d0185a72ea1b9c0ed79e8d416a0b2facd9672dc1017ae4af09565d044ed66019f3b42ce666166f0eca2b81e0079811db05cef1dd8edeab6ff2bc7ad3114a79d121a3109441f8081d941db9c53075062078ba662b4cba45267f2de62f5e8983e2be21c48c1d6a4e4120997a7f37c2a7df3f0337699bc548863cfe5203075c7dea10fda7520ee03add8f144899e6b4ac0750563643c4f27c63db5b7b1766f25f29b6644479091da56560f282171400295ff007a21298c738966f600986cd803f8804231fe55505e723277deb4a4dc4d83d9ed02d3a9c2279eda00bf7f180aa5031f22a57dc5ba5b2261c1f7015f8dd17356c528ad29907473e2e3be8e7f2748c31a9ccc961b940ec158a159fba052785523300f8382d90ddc895d7f05b786c05ce91bc071f6dd22e09c00d2ac1c7ae66e0e012e973833126194b491b706bc0ded8e849b5d4e21e2ad08ecea841cfc6ef01c33077052001140f83e8246892f340f8b49122c6552bfd476d12f4e4ba2457896514f0399109a950657ca7dadd885f74d8abdb36ebef31afe9cdeced4adf2d926d23123b5a567a355d281141de9c8658c114c009cf5355baac163a3fed31c588eca540b38045a5866f26de68f4dfbb9a775fc0db33d26ba6e036471050cc239c0e1107ac0d1b8d1d5fa8587058873485aff793670484475a55da989a7cf5b58ca24fd5f3593947bb374ffa7f8b9d966616edcb394effa29a2164fca855f40f27c9f64b7531b7a2974c0e8f34eea7ea12bbf0367b89ca0bc47cab336dfbcd7cde0949bc9be36415a5da030269203ff9bf18ac84f12ec6b4da37d77169af85fce656e0750d1566f18d9d76d4cbd74f37824b447a38b3bdf21463c0e72001d2e1595aef98c4d01e0e3844bdedf070213843e5335ea270e7b2d13d51b09aa7ea09277f43c8b5da93a9dbe9290643245974d490acf3313e0a8958a4c05fa5910ede915ff69e7f41c1b28500661b1b2dd9e0e087b949d6e555b416ee783a7d6ab9a758d946fc02dad4f3de587ff93b82dfee80321c363a07f5b9671f5fab3978107068f48362e858cb0c77d5d2d29b79d51bfd6603cc5bf7726f4e858a010c3f4210eca0fd0ee6a7c1443320f999c6aab88945afc596d2b42355a2c0be52520f700c747e4dfebbff1744bece3a733c3df78814afc1a1b11be573b8d02e7950870f8f9944a20e2e23430ecf035de519a8fcac52f3e7c6af6552f9848eb33384f08c1ba9ef47b6ebabd939da8ba9bbf3b3c1a02dcc2cdb9e49db4be5a336a31a7280c17fe7241c566f7442f193e95be7ba92bd2e2b3d30e73e9395f6d79fb2ce05059cb83b0af02b1c3430599fd7efa4bd1c6ffcfb47cd9496ff9f1d88d4da492b93b8aa85c45afe9440e801b58a39e6bf50cea6381bb3727ee08a74448da81e4915fb850ff0e5403db998a3d9e5f1b23adaf39f26065c95851ac6e662aaf475f7665e935f7f82225c3bf1bd5181aff559df5b1cf9c3ca097597a3c61c5d93355c345b4df257fdb3b9f130d53b5c25a42490df8556a63ad4eeaba3cb863314978173f479471c1d10cef695b74fde33b1d0d6c57740769cac0c62e7fd87616f34d88aa6092d6cbfc3cf16a86bfa601e9c3ce979050c4043ea25bf4d763778449b532dd5161bcd54a177929920f64e4e3cde6877506bac982d585844bac8b98d89dbd7e4e1a1ec6091e826ccb0b82f656aae5de1a6f62a1ff05593ef4c357afa7453027146adc2a4b475e5f709fb69dcf9858b9871d4fdbd7a486dff351b366a1ecca439188a4226728ae65285cf83208c4870e5f8724a399fe02554eb9aa9f83aa04b260cc131a8098daa569f072a6c951a69de44090fe3ffb57366d4b6ef050413805a7bc40d51a257faadfbe0fb0d257c507621e11437092b037ef406fb9d7fd22dad933add016eb6f6dbd7af0f8ce2204333cd3409d96bc04befc93455ccf5449f27a1c3a7de5dfd7c184e850542b62ae7b98073ad0854cdd14072274bd2d11f646061c6eaade1662340c4a49d64a9816e95750ef46708647fe8eab21c32c4ddb193f4a4f4b9c5dbdea9704c117c8aadc95195b0d82f986fe864c991375ff3887925b0f4fc83af354f4a551ee3a7a8f96318b0642f28f4c1cb19dd36b3e40fb508d2b43317a0bd0e345220b9e960ac92a5ff7318e4091424d268a8109f3961ca4b9be5406fb03ae577e1b965a49c1b066b7b018ee6fdd2ee5abfbf9c1cf22a02f52c3386478c77ef09837ffd38bcf1c5853af612e10cda45c662a37a36e2a9663c2e5f7f8787529c88b53c269446422255ed571cc0c36e8a034a4f0dabf52dc01f176c180eda60f758f2a098372d9ea54199c27773a04c465f0e270c87de248edd5277e204a5384f722148ae8e9c39e496b84ca605d3ddca3c3ba4e49c4cf439894dc29e9363df156cca8ec926a0cb7273af7110e7f9fdf5d0c7f8909649689057c25b1c64938c8f4f4ccb73c8cd4d283bdcef7df4a37ef2a1043c40165033938471dba4f98acb8bdd0a7f0ee48bd9d88076e53dfb6b6db4f209ad8bf30553a22b5ddfdb6c2b4cf3dbb3f1132b626b04513d58d4a99be52c97c4ed6548ebd55c674322e7dc710deb8329fefc59b3567ff5688780c2e133d3a5cc4a9391097795afad2e750f49b49a2bebc6f632aa188967bdb8d6f27560048018d6ccd857ec28f407f76b571abb51418a6893dd97ab82eb3c87a0235b50b9213c61d1e2dd1e65fe8813a31bf1eb6ff2ccb0cf444e6e38b24185d4c81a5ccf4138b50f77223c8a2946f8b7aa06b914b74b23dd73f9f05bfcdcbe9cdfa8fb9694eb4295eedef7caf10acf5ec36f8f941e8005933f08410cd9cb635ed19843b946464ae801ab16c5dbd77ea554900cb86464c9c7e537e07b7128cc4456c9a49770d42a6136bf198b7847dbe4b076e76977d1c0bf667f4b0f044c65d8324deb6d8f42213d8f6df3c350355ccd2945f3002e681762f4baa1b0036dbf215074f626a1f38702855b3ded46b5870c0a3a0836dddb4502092e90210d28676dc1a403bb177201f58185fe80c51f5e996c64de1be879204b20096240c5ec133560457756b8fe05b143487066f5fb06fd47f3fa287f1dcab4b38d82d2928ba4f00573b58baa5e4dfc7569a5d9de26a52dcef0bedf8a792d7c4f859eea48cbefb1a0a8f62174dd83a37c7e8c9066ea22937418f2c1062901b9d865b2decae68c92fbf49a513cf73414e7eeb399a8485517d1d75121abbee5c0f5e1655066185cb5200b278fc155efb2f9ab1da380fd241ce7f640fc87b2da2092923e64b5c0a76fdee8248464abcecbb23810ae83c7b24c0f872aa2c603218ec4ebe9311cd3c405f05917a7bb14f3c6aa521166ef588e9ca2a8ce48a491d20340707431624f5a48ba7ba75bafb83cba8ffc6a6fd444fb7974d7bd3eafea6036dd96214dd836911e57599f1a02f1e2a6f6c75fa2379be1f17bcf0fbe13de2afaec6c27322449ab8593b036e7b4ae6eaeec3acbef4b2cfda2d69c6b2c47533e9ce56090fb33fdde3c52b6fe0ea8ec70f999cac9da04c0835247360d36419d3f94c413b5edd60d6a337ce75a0a8df9d7e3d28ef7fce970ea11a7164bb3161b6893c339ea327c8b959ab0f24a45407db49b5396dcf4689220c2e8b52dae0e3dd1935ea9e8169e5f455a91c9f5101d13054b530ffe294da8d1dbbb888414843f248ae913bcf52bcd7a39bf02c1f1d4d4dcb55688b124370848a52366ebd0f14646cb0174d05a641962ec40783a8d08d72b50ef25de788efa83a699450640b5bcde07aed5339885c7ee526dd9a1d51576b907a1a93480987585f1eb6bc98a5499b995d95250cb5d38fa3582e70f0f53e58507e1604180ec444dcac89811690cecbc76c9f005267b0a5f7e41dd3877114bcc1d8033498a081ee9fa69c34229a57ed3b01f8c1553b233f1b41f92dc27d56c6e5e5e92a2e46d0289fa59be7e0f40fb50e6abd493ff6b1da1a67777fe4e1937a7b41d8f8e3b693dafb18643e2b5ecf3a8138e063dee4d5fed8cdd6455145de3957e36a6ec7970387dede6c52139645fb84ac05a02faa8783c39e2796f198c01c3f1b4012cfd91bc24f6feee837b14b3d0e3f2ff3d0d051a4d01f1fdd38c768f28c56a518be0763087d62b12609e31bbd96d54b2e7900543f64520075d2efa9b444abe7c99122b1aa917ff417cc23b94324a39a2fd5d3ffb82f83cba13dd1a9013082facd2589b0307bdf842ba3a1863f4866d5e0795503fd2f629f7dc28873790ea01e86942444e458edcb95dd812081a056f416929efed3a61d41124df106a6be86a6ae1d534a3237a7391a0bce14cdf9ae2228b6544f331aab3b4b17e9dd196fca9881788eed84489950253a017fded7572671c2eb2d9683ae8be98cfb13b99fdb2f0ebd94c07a47d0e9e8f6865b9804b02f3b8d7a7c0615c4a86aa68b35bc22c211a96ae900f8ea0aea1df3ee018e8039624c57d5903b45165d5152d20cbde09d2d01a4bbffeaa6a88d19096f18f6dc8585a48635d6c1dc81eddc7f48fd583e7e67b9919e633465ab3898135d02d57bd4b1af0b954d7e36883413c037a56b5f7d363a2a96b2289937be89d0a5f972e4594d2f93aeb0842f8bca91afe0d4c2b6118280735c93a522caeadba1adc3eaa962f128dcacfcdd226ee996f6dabb2547c29a70a0b75816054e1f06b61b314099a66e60c7af31a4d099397894fe2009db8f78a2bd0980f20bf7b1d27478581136b6b5554101fa206f49693dd5f8016226202ee6ef89463c1fdc9102c24afaf5ab5cdf72f244735a2cd46f55ce1980350880b14b5f3a60836f1436b9bd566e7f24e08debe49fb99565eb40df406be4f1885731488c667f6cd1291be680eff868fbc9f347f8ecf809326cb33b43dc5d209c375c6376683ba63aacf2802063cf4b02f632444b55b29d1d3420727c9ff328ecadcec0b45b047ac1e4760c369e2504f8b396e328dbf3998a9eac0579843f752eff0298bbf9acfee8d215b11182178d9781a7c93f7e0dd8001a3348987b9fb03664c0dd5771d82e49a6660eb8d66ef26693ffa3962d501b3de420687d25106f7cb804246fc9699e890ee7b433c0952c12d64896140932f4ce5b95489d69da038b97685dcc601eb2fd7826ca16b11668ebaa701c75b58a88393b1ac895642688db960ddbc8db5a324515d680ee8743b065cc12d12edb0e03d124b8b423a61350e98f6b79232106a56ad9b29e683f1f26056d619685bd29d40f3e92b9902679058e9e90ff72e5087d941f2e48160b7a4693cce3e25fb14689e8c9b5791aaa3f3d23a675546eae227eb2a28517bc6021a1e7c899de077d29ed49d7dc841426975ef5fe017eb080c859155144c75140a8c8f3d04906cb26885aac500cb74db7763f3342f8c29f6e7d41651f4a7da5940c56c270d41108e4efe4afd4ae64c7e9f71316eae7276589d6443ab78645c60282f8184a897e3f73275b110a64a9969ef0bad89dd3e3eeceb181ab7f56f74a9a5518df3f702a64521550168fbc30f8abb5ed0c5ccf338726dd3424bea05b84df47bd5f168918bf8bb98f9a5656219dd27357246728deab6fc80895827e0b4aca1517eaed7c660f3d5d5d573eba2e06e85b6b8c6c2825f66e9ff381a38d6c7a9e6de4b28d1e8140b5fdb42bd64264811fa5bc7f007a37f6d1cc5240ab6b53fc0b8c0e946fb3be8ff423c569e614fb1c98f7a854f0fc144f505c2879bdb679598a6f63f8a2117ac8a07fc7c8f4060267cd36685a0af73643663f5c8262ffca16319299f5f568915c3ed2edb829606663344a71f962e60964dddfbf41891db06962d8f527eda7a84b1027e4c8f9261079c3626d7c0393b8d757822aba55db9bae2c79dc9182648f30fe5252815006e8a4070fb24132394d577cf98a18524b0129b9445baf93d9e1b3ccde5a0a49586711079450e2ea04f321aab62aa6dbe172f472131d1565010f80f5be0fc8ce3b057af6455e6b1fa95c331198d9a7caab1b95522cbddbe85b4601b204bb2975461c63bc783837fd5b5c46992ac78131fd5c008a14c048484a51b28733b187e22bf18224bd5605d8727d1a2bf9458bee2d040e2e6ab0c2c10b799599533edb67ba2002005e13a8dd86cc40a960f64ebf3ec41e694b5a72551b50baa46df9a5586d2c7c65a7159d143098299110c25af8280446a72bb78b710e34b3cf146108b9a5a37089d56b98d9f42d237b1f3b5d19dfb9e950f6e3f929a282c067cabafe16c6d575243c02b467ff11082e51bb523c8fa56f27bdf7fad4eeb1ddf23caab61b6ef176d8cd5e57bcd7b192b727a806a072e66c93bd35ccd93887730d4a1b742d4b9140297ca1217b3bef8c557cc9e847090aea33c5c952acbcdcae6ebc8a4c6ad825039e2479ad182c815ce79c59b21c7de6eb814ed9f3c4ddec2c0c7852f07819fdf70da5b291c334fd2b8d7066751c49eacdb4af8086dc9521ebcf42ebb8418cdc30aef5e7caf3fb5015456cdade72f51f807c0a8b883aaeceebf23437aeab554342e21a410967bed1c10377b84a0196270eed7c7997406b475edb6dd2618fd2886b5bddc405da32c40d78337ccf4af94e5c8dad38f6fc03fec2cf4bfd32df0e84c2f4b287df9275749f3e8ba36c7e8a6a39121d57384c9eb50abecf4e05172a2b28a326d87901a3f19fc76937087c5a83b7ebed7c96201f3941dd467ae777b0b87ca332cd4d85ed0c9f0f14a5a626e6227c52e41face028a1ddecc92ac42c2bc784688bc93f081c1d4b79d9bcc6ab50b60d8afb81a62e6448d787ae986f15b31a2e9a9e6c9dc01a00f45e391edf8ef63b33c03ad82522f9222280d1aa32790ab861405a89bf40de83630e65f39899115327dd0cf91e29e69152766d78a5c05338a9a0202a305bf9a61ac3d8950817bff425f3e3b17d9e2902f9772cbcdc62bd490452be6ca10ac834f5fa85ab1f1f3c3cf928d43f2b673ebee49b9dde1369866f32bc113f1678e83678e8663d18bb0dfd7b216122d33c943bf75d7e05d8bf3232eb9b52f2287f18c3b119da0984491459df138f3462f6d3b64e3e11358f777e897551e1415248990c8655d1fac023eae23f89be93b9662d6cd512fbfa557f9157cbe390af49a29f91023563dd259b6c157683913dc601cf72f0f82914df192696a10d7cb8e6753a46ddfa77476b910d4addbf4d41e446f30b6404ddca0f1dbd20b7e0795df00c35141a431f1bf7349ab6219d535105b77151d366406d98cea17eb39c3d767bcbe9a57b77b5a79ba0342f0788bddd3ef82ab604f2d81ca38dfe8bed5339626cd1faa815cf1928fbdc54b37b3284ca8974abddf58c296775326101925610988fef291f504cd1994933c3856e3ba6652f8799f572544ad649a23b9be5aa8ac479e64cb9c64b99b25aa499bba5da0e9874089d64879431c0f4cc33bb0117b925f9d6737015f31d873d908fd427c07e75c9ec85e3e7296bda76c6561b184f5922dc71212d8360022147aeef7fe8260d205f7e8eefee83bb87da7b816b2cdd5f162d291e6b52642b6c8e2b70f4c25ce5a6e7c014885436ba84e5ef54a60aaa92e81f6d268a577c380abeeaf688e9b1c63192ce958ca0403bcfb405ebdae624d2115652070b5c1eb7ae306add5e8c497652208eed169c0d7d49138d1e8a95f0fc1454b4488ed296687ed4bb57b481e7cb30904f2ea11476c98b9a4016f1a0c031e2ca40a43964cc1d5c797b4fddb65fb5d5fdd6378e7532066368f9e93c0aa9bbb83df6ba368a01cbf4400865867ce73acc635f4f642dc891a05d52a822657e9a1bff1878f519485ceed2ff64b202750b1a03f9954d26f3c8b71380978a93ce73ab9f1769d3e18e46da5c47e586cd28197ff61d7f7d9ac6305011606576bd8c9c06c6fcb1602c56ab2f2cdec6636e7c785ad557c73b4cd7e7e5cba3087f32e934ee166e9c6e948909db69b1db7fac3fc329e2c21c1bfb3fe414a4bf467aed8a07f6f9875ae004d0f3778e033f510051d7411d9d3e9a100766d51da1dc597a6439bbbbb7bae01178da9c8cd7a0b4609e6e003ca3823c0f672549e65da20a79381c0dde597d8f633e9e7e035ae5d345670dcac15767ebde974eb6259778131d16a06b50f43f2230c5fa94c76b25c5a17daab660e56d1ea1a968dedebab73c32d63e2b33e11d93db40af5786f6287840707f9427ca53d41f942ff0bd318908ab3a2c4b77f0c59b9f931b262a4b6de30fdab2c92cfe7758a78e9a6999e7be32a6e6e5398fc34995e5ccc04434f52c1b8905d04490f54c448b4f639119cd1a6b1ae0a43c33518c940dcaea545507a3d650ea6ebba8ae10cd2c9075c92684e668d912b3e74a44e66f694072828db2f5b47adde548756a63699ad1bd61dde4281eea9ed9be1c2aee9a82b8a49f956526ab8047693cc7dffcc39df179b7bee6d406d4022945b6239db66ea998c05f9df634fff6622a39cfe7c48baf7d4ee69c61702d011ff242d1484fff03b5cae833a5eaa0989fee2b252f5a0afa64301622c451dfc96ad3b90f64060f6a3bb4d70454b80508a69c2a88c109b78b6f3adefae8cfa2857c72635aa581fdb56b0bb6dd454e2688423a8e8226738ccef73eb945b1de7e0ed1dfc9dd3715f87e7b761e742a11aaa28102ec1b9726215c2f62a2ac23cf83a0b991c267bc3947b87443f5384ee3d1556547413659e2b1cc70915164bea3402bf020378d17e8cf692d5cfe3b26ec10591beb7333b9cfd5f8764a04b4f42d6b8dbda250ecf9c793c221c2671c4745f91bfe989c6b155f263203bcc8e75abcb2aeca451ed22d546453aa4e239dbdd813b65e88978daf9a8c5ba800d9f82af7795ced9ae2ef5da01da1de1cda85f8a787bb838810986e798f6f2782c1fc58cb531ab534993bccfe50c6cd247ed212191ec6967e61e59fef6672dc17b85c590129ab512dd50c800a32df9d886808c4e3e2477f1f8cb191c15c67c108de5411794d2c4d81bcce2a0157858b128f7276dd48592c4378aaed31ae19a25321133c998784ccfdab8a9789b7b0949cc2ad53e4287e8c5e0d9e27235c141e5eb44ead00a650d7d8209c9c30233c1c41416a46fc188f1f0cc31ebd937e4bbc157cdacf251aedae64aa8112a408a3f1c4f7038b39bfd0da08f5603ef8abcf12b978b55bebf482d565d0958850f5c79c457fea60f77b37f75a143491a3da12b0013062b274cba7117041450c3314abcb0beb8b834e4397d0d5ad673d09a372689ea248d713fe6566c8877e53ee17e12b1d6aaa251bc4746f123e9fede4f36bf9a7d54485990b232c0cb9b1098f1498dbba98d03c65aec46036c186954f10ae335b472a101e506b6e0b67dbe896b415b1b7d0108687d1b316d8e21e88b991b31b38da5335334fd093c11fe73cdd7029a83ebc083874bc5a6bd2a7ad790f440ebab9b8a9a837417df55fd982e985bb5e250a92eda109610440ce2b8f61078529938c3e7e7c455","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
