<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc27b704104d54f27574c6127a3db1cb01866aa12a37f51ffd305ee1717f28ca92cc3ee65f55437b3ecfc31e4404267ae2564703156eab1a2db58c7c4023b32032a20d73626073f13403ce356eeba5d04be530d8e2c8d7d9d4f4a5ed9c8fbf045e019c86eb0df8ad34adf14bebf48b191ac4b053944a8962c44ced5c4900f5c56fa7add91118077d5dc124729726a51850f742b0ce907d6ad88cb2e37c5698063405ae0dae6e880b0fb8055c48eaf39dfbbe7602ff6cbfa537652dec1bf04bc582a377f4fefb1f711b5fee1a40b99e3bba8470328fb6337207c3344e917f91f33854a412a5bbff1248b48a7507e3ff867323324f4263d98ff8750efd1c13a0ec48c559d21f6ecf985ccd4024493f876ad78dcab3b41511bdfacac132b7f40dee60040a3c3780de4146c13c517dc2a4259eaf9a29bd62d95f9a12ad92047fc6f401222ab3b8f79b599d589c051aa3e7a7e9cb72b4fd2f1fc5568562c42635d91f7853714a5d47f5ce0c2656f95c3c20b655ab5d92de109fbf1668e38e82e7ad94200ef8ff741f726545f29d648f9832b3ae79fbd63c56a75ac19f8706a2d6602b7d8cba955dccf54d1e66ea40596dae5ddfb1a18e391d848d1f893e6a39d6b3bc04f6c4b30b16ce4c7cafc58ae7e9b01d72eca38005dab68f109281b8574aca78e9dbe357f65fe3026d298545c0460edadaaee9166fe6d9b90210699e7fd0aed5ce1f121d03548aab37ade3fc2ace3e52c2ffbb686128a9210d806fba6cedaf64e4aaf99f8cbe66f04f7f8024722bd3b1840c55f38b2131d26e3df17502cc5384352497877794b0921281fd2b427d499baec8f41d256ef9b042f70e7389b5d6e7ce8f3a293283d3875eaaf8a69ece63dde5b5b07f2359eac1dc440830fe950a4cd543973f17a29af602146cbf7407a6ce3cf5fdd68e56b68b48702729ca22124942355b20ebfe92e2c0e796b286e935642e8923a96029525a7c447eb107af59cdd830b71486d88a7b6c81a1b38c857bc0e3a2b1b088fedd43a502070761b989baff55c41b4a28e3b574c24df4a9483594674874ccc5f65f142d31c4b025772b6369177a3eecb24e1c25ff7b5fca24ca83ea8fb1305497886c6fa14843c59f5f383b69b2594e7b8de45bb2b2c99b67007ad7ebd5cb541be957eae6cd623ce6245f5c6606bb62f4c6955f244b48817258016a2dd38fa3726b078a8854866cb9dc7f29cf51523773cb5f2b61e838c1d827ee69e772c3b6279ddbf052672fd0ae6198460f11963f125bc58124b58dcecce1b7a0611a5c0be8fe3f61f7ef4ecb1678fbe7b8b48e39299528facfef24460792e02eed9218a0883593081ac30d971adb6d0e464e68657fcc8a7c60bbe4a2a2530ccc0686b8f2648bbe1542aa4091130118e5dfef7030ef5f6e7737c4b2f46ed515991f17e7930a358b1c41e90bba203a5a27ae3b1f28d31aad7873a66c815fb9bd82668891de8dd770ea72e80e578ddd1ddd331b8bf4f1f303c334ca6e7c9947ad01837dee1102c26fcde1607c848bf990bb33e6ee90de16ac862b8e4d3901259c2012647a70d67560160d69856edba56532c873c3d54706d36fda83e7034746d4291ed1b55d5c9a95f230474417c656daf68e2ef8a4e2b73dcc89bfbed3f532d72fb7eece116c81db7d607a042fdf1a245ad48d43a24578683c22d3439e2e5d50ef0bccf2919cfe3bcc9839d74d5945c3652bb930097c15f4f059019b8f9ec98ccd71bf02d12936834f614e475c2e136fc8ea0adc3d57d4c246208a7a55e927b48b2a527aa2a133c716a052d42286eebc176189e4519da0e9c39f77199af029a2a92eeb0841c88b91a196753a480a15176761b507f9272c0a5bfd989aae19e7cd8c693b33875d45d16528d8bf71e37aa8f27d13d063fc69e337313e87a3abaf424e40a534b7b86e596becde7fe6917182b3c320bebcd037803bd906921dd199c96c398e1fed536222d22fc3c2318812d3e4a73ce302bd44ca283c2d4ce4bb911c8bb85c675ec474af279ab39081ea5bb00da2cc70bbd58e7ddb6820376e4dcc799f5093db2ff1563247fb2910f567b40e06b0e196ef9f0203a0a957b0872b97532fc99bfe8f400166a5ead24dd1a0f5500b334e113e8b837be7ba894011704bc88889f41e25736134d898d6381440962284c2e640f9bce4233b7578ed2abffbf79475319931512634d27d7eddef8e8eeb06d3b8b91b8c199b5a5d944c810a9c56ffd966e00901f758ecd1e0c9f740d72b1db5d13ecb9a3943d8e89aca8c1c35d39b1f09a6636e99aeff4c52de86e60727e259cce3c9fa24514e4e1ddf6b4588c9bf9a8525a26e81f687a2ea5fe5242126b6bce02594a98e6a17c0e8ef01f8efc24bcd93afe859daa64781c49b63d056904c832cd335b5d881dac51e3f0202ae5908d7b647b5ea5fd1206906450332336c5c739fef66a7ab642abb990bda06f9cddeebe795bf5769f23f95585f8af920d0042cff50e14eaa1b9671101e8cee7097383b6fbe3e690f3d2bf85abbc8b8272cc9daf1b14501cc6e74896f5d080817d7af91f29db1f6d7a07493a60c23e9bf3f07aeefb7c04895f107fa9e7d121f114db1bdb0cc715bcce8adabfbfea76790bfcac8391a4023a544dca1a8129ee563f93cded9c894062ec235dcda0348bda2f731cee7302f059ea153397c8a0f6be76d752f149b63772336abaff9d78ab61e57a70d43cced9d38d351b2ee3c61260379ef5b2af66c92f6eaad2fcd673951032a28558894d3d6ad211abcc1e8052eabc4cf90e6a2f6f9861efa4982207024c9095d6bef0fceed5c641abe087b74d6fe780dab5fd89bef99c831c5ac2755a3a9f06668edb8a1967bb2ca7982a694d5d8842d2d3b354ffc04ee90e291704b881e6c77f538dd7ee1853e625fc01ee3b88dac5686a5c230148abb01c70b129d961e092f47ebb5da2194090888e3fd32ff3f4ed5a4360c9041e9fb1530f5a5849ea8ea944ac82cff2be6d21657c7d78bdd41182c01f708dfd007be36b00017bf06bb6825b0b2a2d9789fd76467eefd3445eb034a9e0333d71c1c341054e7df3703058fdc904bd4416f827cad25c2a8739bc53e089032da441825891be48bd36e9369d3497959e3057c7a6a33432d87b59ae4c8eb56e78a0bb9145e1a7463f376be42a50a034dbeff31cf8fde534afcbfc8ee564bf80290bfd20bbd9f1bba66bd0fc13a9c1fb62b0f43b9f32ac879ab84806a2878f3e75120a74bdee6f976a361b8a5bc2d743e264ad1e6e9cc2bc0672cc1f9c44a02ba42afd12bf79edba042da9dfd56007ea067eb252821347455f8a63d7ff88461b911f988cffef29b00835e1c0e0f6203b568e919ab971156cb4d0489fdac766a5ca49995c83ca6d606aa0795c0c2e9c6e90ff9534333f136c6daa6b8e3809c7e168a202b464783b72756b428ecc5bdaef20923bee5cfcff2fa5b2e3dd698f33d073e6b27e0a8005e7ea3ceb43cff05368467876cad8045122061e335c3f35231bf9498954311772cc01c0199dbe1f10ef20978a86c7a56de83e6b3592e5e697a9e62e8209035f36768bb7f08441ab8aa9918c8ee2366e499902215769a6439a7a70c6f85adc29c698788865422bafcd3527afb0aada06a5f40f1fa652a21b93e10ef7e15b735a28417dd54309377eba9b560c91a926f4e5b7cc1dfbc5feb46f18c0c3385caf7845180375fc29e7949746c11ac69d8629125b75bf2e7adc7f164fea89994aba4e01036c51b4935dcb765058355b35fd64f975994dd3a2dc8cc9ed564d1be0f2656d4540a76061c3b4e0b70a62f3564901b3a5f0dcc048490b434d6d25c258062204426dcdd97553b482bed7c61c5836644b56017fd1aa3ab51465ce713a0b49df6cf050656e8d86b74d36f96221d8b3969e361930eac80ffb14ae948d6d09c1e8ee915d0b195f9f6c2837cf4916f4c8657ecdf36aa48f532e62897f3e4138feb69e23a164bbfcba624528ff044f56e639dc7e306bda1cca2c3b037f64e9b0f5bdd0fdaf48a450e4a9ef542455fb06c42cd902841a63859844217f5d2036c040ade41600ca02328924ec60c5ed735f10b2293b2087bb2b91eccc71709d1a07b50f64d8e5b8c86f387033721b38495807051c04d62e03c5226bfedf2ee147ff3f071fe6952849f92b86b5694c350f6fbbcf5e5c291936ee1f3b2b713e8ae9fa9ab617e8c4a1fde0e91f5d964aff499e71734714283a4bc96ff84026f87193d4614d1a606bcc194b016336d3c288722ea1aee23f3dd00393692c56b72c7791f95fd22bfac5246a39c2c4a3a44fd83152cb16f36cb3b2d358d7335b1a9972f3dffa6926f8f1a04da17d0feb2c85abad9e97a11bcfc65d63ee14c3d5da1e624e9b4deaf5887eaa2a3cdf9b067924d9e6b111a97f4bcdc8733d254c8d70bc01585483d2ecb855999e14a73674d28b03ecdb5ec5c21f33f1396f6c03427786ac0623a599561d478f6b5eb340ef769f5eae510b82bc6bcfddf8ac6ac3ba2ac3f287e0f2194211cc0b2bc8553aa38c91e213983c8dc6b8604dc9fc84c002161c0f0b64f9755a1dc08e01fd55548d2631bb2a04462e8e16b1a5153540442a3f847b7579e1490d59d5faa5ecbc177b1f3b532fd0154dbd55af8d88110e5f50ab96f0a1c71699a942e459d75381eb4dadf6645e615c9638134769157ff3c78754f8017854531bfdc6adb883b5bc0b3664da451e1dab13a55a6b90242e88e53e217918e36bfbe7e1af50026935fe7c21d59e92d4069794eb23928d2634c28f04fa2de258e7e0d7de99e83d360c18f54cf2c8910074f2d8fc64c99fd8f6deeef13eb93568014488836073443eb5b297a3f0cea8646998c173f1bb62d1e1011a3c710a519d05fa8b6de7c05e35bb04d6bef9300ddf65834aa57f1d4c6564bac5f979438cb6d137a60c66f671b42a2e098f9173f5f9d1bf6d78aa32a5e2b3b03abb8c30afd942eabe0c0cadea2176ead426d7cadbf5245fa99dd9ed948a24b2f8ade7b772cba12e7455b1afb65509856b84871ba87e4a8175453b30789c42e01264ada3a8669c240fc166d5affcd79b58d1dfdeda8275b535dad6b2db2a223b1aeaff206c4ab6673aae46da6f51ed7ec87ab8fae4e31648975d09f8964b5a6475f8f150032cb8ba723260f2d236a78757d4fa8bd07e6b187371e5daf0dbbca8e9c0d713509579b7127a0077ee7bb76dc11aa85e2526a81c04575122dae89a5ecff5c567a14371d92c0b84cbe0993e37819a0e46403d5a93c75f2259837f50d3878f505d563b9a20f462691f553fcc96464772c4ff2e135903db347e46dbb9bc542e70565b3f2201efe5a79dfc8c71fbbbb640f797114c3c972c26b71d2476ee46fae6446a9805bade6d91da0b0e95112f07850f71ef540ce7e8e214e036e1e170d26b2535d3990176f61cff96283522b3413efbc9de6d4a8e6331f523815c23f491a75b484299b57f0b25c058661b8fc1b97b552a759c4d369c558f5623465a72eb9fc0a906d5cb33f49ea0fa0d02365e1af021e12a59977912e0df108e23aa60ee0e58cf49d2b13f013bf7487cb3e91e7088fc57e9124c380c7ff15b246de79b67e502923f00f0e353badb9d76234773c23e09ce7c509b5aebd9d4fb5a0df630e3a356c3b52d1189de1c97e96061d6c5970bc459c01f8919f5fffd5939ed4a850ea6bb26ea2e9b00660fba11d66482d0c38d497a8b39d0094cdeddb11eaae8fb4ffcc0f1d1670a2dfd0139438abcd6391b8a2dfdc6da66a8fe9e0dc2c91ee2145960178f2df1c380611a6219b0c93b70fa5356a3e8588b4ec3b1ead6b82a9095a56f477be995d57aaa7c2e4a5cc57e9f4290d55f5ea17d4fdbad411acb1573b301a5d026fe3ed5332b97394d083b3a0ba31b23d8e3624e82188cd8cad91c25e980fa0c891c60a328309063674a1a8d0597fe7276b09441ae3b3766918b289693dd89b665eb3d52d887ac746a5924dcd10fb9ac0c590ebaf52612708044ab4990d8ce7e787f67b0aa398de886dea0f0d42112b3970cc0f6464c8e5aac36cb909ddd7834afa09ec294f88b19484e0f33964648b8a59440016a0a3b4dec2e80754f20ff6686f55dace099dca23f9a522419107eb38bbb1889f05bfcac568c57d7f875dd675de0790b9d7a14a316ba5fea091fae1382d3120752e9b824127a9ec8092645ae207976ce059cf4b8c76c0c89816ae1caf09b1ae3a42a46cab6e93f74a8e766bfc4d2be53e5d0ada93cf2e98b018015c5b38f3f9249bb2333a00f15ed293ce89725b3076c65a2728e52780a0fd140a5d5cea4bbe435331b99d05807d22a0c50d9107163987c6b4d345ff1efad139fca90cfe8d3ad3e46654f992c4f3d77c627727bd19f8c9a4fe8d4e6d97cdb8fa7fe06b8199adcb895de26303d92e7b18e52d3b670b51e72dccdff0e49a0a8c65366a1d3b74774f709882d1b70942d926340d83be4f9d10ffb6cbb76f36c02848f5e82e807227079184441f782833aae879b316b33b61490dee411aa044f57ad45c82e7c9d44d132c8b3e912f0241d2e7090272b988fa63a8b8589a818496eacd14a9d81cd2d236a9905121cef82e6d4950e6249f6ee977b6ea529dcf4c754fc7d2742df269c5d2877d73853ae7cac672708ac4991c4e16c960c748e92196a5e7ac0b6a765732f6bedf2dde967f85bdd6996846295cb4084081bf32cab75e97a90cb0852d3e0e2a5b737a8f3dbe8ad88bb4c79d3bb76cd47a7ee8908c685653d09614984814657fa7c523d1ecbcc45af817e998eb438bb36d1141f80e3089a78ded0271de830c9edef7bde4e811fdae597fce8668d6accb53d0710248cd29b80e07a099894bfe019e163f527ce0361fd8ac77764bc2e83ee9af8a2cb0b5b13e532eaf5105619022338870ac2a48d489e24e5222a36b9183284e875172c097acf85fad0bbbcdb2fd4de261c777761821da2874697a5cb78cbdaea4cf83b3816eceaa359315adf7eef4ea27647683a084c2a7e2ff7b338357338c4daa2cda98a1732967f2593a89b03f407a88b88cbdb9a8b05c171eb0a11fc3252246dfee362843d0145c6e7c6dbeda7defff5eeb50ef19ab24d7cb087280285c1908c839c07821c7cf5f9db6bb78f2aee4dc58a080ef9757301bfb0e97f702c9b5866075251b118c5614f15f39a11c5add3397e964459c19e01f5d8e664fd07f0a5df465630226d6ccd7cf8145e225052e9af896bcff4bca859a07ea47892a542c5f1aa3bef8ffaa8cb552bad1e174007c23e487ac82d4304fe23370b6c46b595d48e42b391dfdeb041d1166d0735f2ab6048addbcc61e101cffd47d2950f923c200789dd7c8423f0b3b4073100376808f7e792f5f7f4be0860aa1ebb97a0bd420de5b96a77818d6767d7be7f73a51b6d2a7958eb86058f40d0191039c52fd53f9e63e25bed870e5be7cd6509287335130d34db20e35480e3462951411a42d8797ea0f624470a8065241c951b545615957e00b554be7428545fb861a49ba18ed5a921774d0f989446ed5a54190d0a479e57efbba9dde9142fd660a76664ba77c7520059e31117fa1b352c55a29fc90b20704e367a670db89dfa43800555940c2de3b191df5fc9a751c9d2c81144c287c89fb8e93e9c75623a1cfb3490b023b7ec254c446f9b2852b05830b1b07db73681768d68d5d5c127e9c95029bd057e92d3b04ba15f894262692b004ad381e488b59af855eb1a3593e8bb24899be248457ae11b8ae0d3f34cf1a081625cd27f1f1efe41658895233ae6485ad683ce7b42b1ae06e0532fd43140f1e2e5f27861cf65f40571378fc2cb62b1634756e7d8ea2f802f221a158ab1de92d51a3bb5d7ea06743ee05b406c5d162bb20c287ccb598f86bfa216263303e2ffba36d0de36f2321cfe92db2ad292211bac37252432e771c03bb3bfa9b324b218da30768d3842f3fb00d4fea46e65104ae2ffe5ea046a63253de405bc00a4d3cf24c66958bea057b160130f0c287d7ba5ca591b3c7210c421feaf5b0e572de2ddcc8b9e79fa2a7d423d87e78714394b510129eae8390680c638591b5bfad2b2f31b05e24a9290209f4f97d2436fe4a99eaae832cb26a5c60f39e7d8e0a879d74d2b8ae598394caa47d191ec9b0367a4c2105eb77a0d19492557f3b9e5ac2edff2355f0a0adfb799aaac5ab0ad8b86599d2b1d341b3fa785d2b00aad434b76833aa17133feaa2161a8ab0f963aea9e25edaa1c3606332633071abc80fe2b84dc6c05e097d08da70ee02320fdf5f0271f3b9277cfa701fa38ff39d17df51a07e1ba0f504967299acde079a90dc4f28f2674ff37652868b1dba3f96d8fb523fef7ee51ed3e91f7d9e9d50191d686668bbb2455f2b8be2de861f6ccfa09fe560ab98488609439788d944a038be28b99bb2bd0447d585f84e6daaddc77a1e37faf70c6ba3fe31c2dd2a48a39ebcdcf1a61177f926bb0e31f021a7c812be0466ff414fc272d0f6c50bccb51296de75ed315de6fb3665aea1e272cc9961323168a81eb8e8be22f474839242bd9b6959107b40e6082766b6ecdfd7a35dd5474c0a881b23e217fc852ace55b3e7f358247fc623fe51679df323dd045431393427d09408436baba4ad21822a93f5c560a167aa05eca21cfb51df71f4abcdc153c8596f092bad7fd2bafc1be585cd982279f77ed9ea910c9b33f352e3bc62ee792d908375602c3792fb7a81f5d10525d1c0c550fd7012418c7b37c3b277af3b4b8cca7228a8a705b9d6ed69f716e6b8b82dc6d798d6d0dd9855d25622683f191d6b1ffe6d73af825fd77fc890bfc9da1dc2b96143fd6d8e0b7f6c393f9eaa3c00d68ed4764617af51fcf01885ebf1132c4f25d3f69af9e4938864a63e3421e77a478c578359012b949b735f52bffc3ac7c242524f99864d8fa346cf5e6936ecfc3f42d7ca9e5ebf81857fd7470b2dd8774147cda54da873aa1e185981d21c4b817b2e741927206cc5cc3254c6366e8bd4c18ebbc34532f0e325c9ddf18b01c1a62f88d5a5daa477249f96592704e4d61e862180c751bec45f9d2ccba53944c77d5f9c389fafb1c7a9cab3b984745ee8218a56bce238fbbe90944e311e2597e4a700f78a361a9787b86c21a027ec1d1d978358687abe2642329a78f4c58848389387f741c961d10aeda81c092c92e055e1da430a5cdf433738b92a5674faba6eed613c033ab81a27ed4c72aa40207579e4450d259f33ec8a2bd5d2a3c6b6692a3ab11c110e720c18ff626c097be637fb1c960a9f8c2db2a41c7e34ea5eedebf86221888f40d765de698c417e114c15705c832546dda565fc09f0d67c364ed8bf226d2b82875071e4cb76583eef456212f0c3baff0943c851ed5e47286486d394571f071163cec598267867f8158c59f82c000db0a08674cddda537bc6851462f66ab18b57666f23917e6dbc2c4a386f1558ae18a50e1128fc05f77a62f70926890446f008f5307dd963534fcf4d3f57fcd6bc06cc8c3678c44436d71dbc40cf22e647479f89fcab4d9487c93b51f220096ef0aa95be78ea28804d55dc628ac1e9746e7e4013d306f2c8102b05ed84b6245469112bceb450ae103bc2197af63a8930ccc77078a15d8efa8f55a7f202a01f0a27b916b9001d99b0792c1c52648f356a477cfb3e5033cdc170e97fb6db81ec182d2f09b1facb329166ae66c945adcfc759da147c71a064390822d311d07a4ecf67225e6842edcce8008ab7c0aaab146c57351a7d00eeefd804d202522096a91f88aa4e235e20cc9c7a6676afd5f25dd09eeb3cdac6af343ca0ce7563191a8d3de056c3746b46d7c7190f771fb45bbc7bffbabf355f208699e37971c2b2a238dbe3b3f7490323ac83507c0d630c32b21dee279cb2d08d46d00eed69ca862e4345ec3b169449f440c66135c961688c1f75f6cbeb2fd323d615ca1772f663617a314396d40fe3f572b8ff28fa9ee9489e75bd5ed54685681a7e8d68aaceb0aa3e6c1e122c3430af29a90d51393eea1e18d19c6ca90c8c8957c47a4cc486637c05bf466391deaeea612167c732d7dc7c220f1d20ae7c4414eaf70cadcfd080283d349c84974bbad0c08e859fb454ce4d3e7bb6e3cfc0bb525cbfced7e6116163b819f72971d03f92af1501e9fd2efe4ebb78bc1150bb1272f8b50edbca5522864532c0d4a886cc88355dc697c218468b87f7bed5b56c503094612be0c3d9b41a16914bdc46ce18632224dd395e76b9f30451a7aa5c747ce1272214db6977feffa76e643532fd758a228f90d074919f85b82a68abd2c80e0f2389eb2574a15f8ba2234f01dc368261d6c13d50410f887ef233270e822c55375b8140267419bd65174895074f5f549be3ebd480c5cded25ec0bfb54044d13982d1ede91fd0acbd2c0f384986d985ba9159e25c8ecf250647580c3b1a33d12a7e675a203d2c0d428f473e638223e59a79dd362b7dcdaaecb1335b2f647b8483546a431aff14cf09bbaabb65d75cd2551a5b0ef35545c8de659535061004beb2a33ad865b08527a214426ef7e76eef3d73e2465b5fdcffbd1a9df45e9055704649f10a2afd557388f54cdf82489ca4126e5c8a7fb42ba1bd1df1ade34ec8aa6dd2bd0199ae68a2a604077a73648d8992dc86416b9db0c0387aaba09984c12c799927e4e2c98ccc84efa1a36e116c50d97a3536f694aea968f7f8268f3efcb719314b03ea19b6155094da0c5baecc182e36fe7bc4771facf4dff70395be26438056aeedec22a0c5b5825723d4453c1135a351830beff4131f7bb5c23e626e2e19b5816876691efdc829582695735bc268fe85b2ea1152b003c275e8c1e636dc36831fb640584eeba7aef7a641f3b19f884a3af61fb956ef5cf9ba923dfa730f5205e4d3df6b09770067b0af67431eacdfa226830d597ba96295141c3a3c10c59b5de9b949a360c713bb599913a324d23223b58aa07be2429d38ec23b5017f53932f67c83001e04c3cae4afbf4cac7f562542cc7b58227da063143aed88b5e5d78b21af51c58f711330a19c04ed32e588993060105cbccbc08174bb4e949166e76e93a9de8bc6599337b2be9ddf215c3a6a46e41f86b74a5821b7da06ccde1522aaabb78c39b148729c4434d5745dc8d3616db2ff40bac35a03fc1ad001a32f05cbb666150848e38250688abc734b4effafb054ad78584ffd173040e3eeb3399de706ff01b0d00991ea71339d8920e28422d51339a1c972ffc506e918380c0f84d0700d929631027e2a903216a72cd3a00c45f327d33cb6b95eb00d04a6647b5709202ef0f33d7953d732a11cb30d48b5d4c0f9cfade9986aa0fb6cbf2b75256146d1cdcd19e630ec12fa2f0fa8dafe6b4a00592f275908390f85465c5aca5b4f6097301e6bdcda9847bda4ea61d08c6b787b8213e73f5a1dc9f276d3642f807bce78f2f71e88ef7579dae1bec71f876b867b41e252c2a3637d8f497e2da455a00d2cd79d93e9a399eaca356d4af293a6ef5a6544d23c077a23b3a5d93a7469796b56be0d0ffe5c9c4a9b2bbb160d70b6f4a5a7b40fbfd6f8afe0cb9d70c574921cb3518d8bd41beee89130a9747f1592298c603abfc99c8572363baf77efc6ddfc3afdb6da4a1efb1f9839c703c6652bbc895602eebd6cf272701aecd4f818bc5deb30247dc4f2f7ef46885bb32ef05da9dd823ec6cc83a48cc47166f977c61e8d5cf1bee8ceb9571ebe57050e913cdaa41233871e67f684be5e5ad16451a07c7be3ee2ad6b6b4e419f8c5f61af097dd002eb5f7ea89fec46997c64d6f66d24f547fd65768740cc5d0575b0d601be6e48594d555b3748715bec66b6b19502eca61747910235548db5c6925901f503e79922bb3c54fa345400b6a8ca216a23f7e905bc7c467e68795fdc7de576978137084d62e057f1eb08ff29be899baf3e6a88b9006d1d5fbaec26cc812c5ea36b0e017918f47b0d4871dc69b383416c83f680a5eae1f56d7f456b130532058524e626ef0b10bae54c900ee615b54b48366b547c73d986e2e0d9446f60be014be640b763a06bdb2028fb199ac13e4201eb83eb09b9a713cb6e4c8d5de04d5ccf2feb30dfb8e58b85832a98ec430874810f428c3a21ac09ab061c5f5965ee5fa2d5cb576a02da7b8b3cbca6c1f70f3e8e37aa77efefa9e5e6d4fbd38084a04d1f341d3722a0670db3e66c0f05ccfbf61c180b6831439cbfd55a2374631ad438622383a54889369e5c8e69a0fb79bca57b6359415579137b773ed0c99e5644feb9fac875c56cbfa636eb20578be5dfd67208e8635bcc2001749bc9d752ab082bb95306e5ddbf4dac628be4e57212c105c38815ce58859755a8905d24b51d41d21e1e431c09f6be65bf1375ddffa4f031a18b9b4d548d33ddfc9172d94441c8ebb8eda4ce99ef3032437d05f1f2e5fb900052f36b00861f08bfb05484376bab22d11d81f41cdc840428850a0737cd38d0e453106ee6be5712b97ce36d673a3e91a83111fa6ec3915b8d3ec8eb5b7099521210efc417b65ebbe9f88b8344cd241a2bf46f0c9d4818c07100a355333a575549e4847c6bde11278f8aac2b85ffce8e90767108765c7f5647235359ed4a4387b43c7a4d68d743eae5dca2480248776b31f9c4f44b3fdb8101784da4b550b4f171a44ec43d7707b955b0d6c1c2ee553165d892841cfd7a38289ae9dc4c8022a4721e0c3137681cf0a4b1f62edbfef319cf7378d23b2a6ce4031cf97e544bf4562288a0ff554432f1007303c6a2e6028af3634080f820b7412dd4514875161c08489d8534d1b5ae3eee81196b33062e1234a809b1db4c0b039ff6e76424bfd79f0b40b7c7ee567b75e25be507f8090078d53407c73b2d883a15e2b56dce3ad8715bfcfa013202bf692b626262884f33825282a497ef3bbf24e8840bbefdedab373633f676184ff93d44284246a8ec98a032cc32a8930900dd3a835eded9a3a610d27d080bd1e9a694687c987b8c9e6d6469bb1220eecdb9237731421f9d4249562022071889e3a320b651eafaf0427081fbbfe8aef5c9b951492c010edc712fc2211f7104bf776b9beb0de1f060958e06e67a998e6a0b2783400fbb446be30d04ef5a3cc78689fce17adc5c33f0f5d5c82088346f79218121d48c093dbca2b6649bdb3e1913aaac9c90b39ecd8791c73c78dc3d7da4baebbdf4722e869a3d7b30966e21d5c670e57994e7f76a5eba85a98e5d8bde36e033b5a87215866fafdf1e8ff1bfcb85ee2e3425bbb762994cfb1f4874b9d6106fa2f3d1b5667f2aec8aab62609dafcb4aa47a7e7070157fc0b6f6c24c9ddf5bad8c9dd3b6669c9ce919de15761b3a2af6b9b01429b1719284a887c9856a11a3cf8714e68c764986a8a06ed5637387a5f0cfdf93f22cbd819ce7ca200b05d9a8005299c7f1b99a896e267c4f4e7056bd78ee22561553000f6779c2193be012b8c22fdf0a4a3b59052fac31be09f768823e9dc438f984ec1177f24cd9d33183e2c609e3ecfe9e7de95557f1896101da648b36fd4658a4f2f81c17b3d04644f76976b40a19008b19dd40e8dc83608d80707c20030be6a374f4fbbd22c4c8dfcd8c407987b8aabf1b8e28ea4ce85a527a3ce46a584564f3bd96bee7e55ee192613f7ff0a2dbe0812bdea6bb5ca312dfd465027aa2b117bf4cb27cb965dfb264af8374794a10faf4d217b6ba349cb0002b112f5b7721b3ae6bca6b47785eb0118d4c23aeb7fe8e13a813727337ed7036cf2b9fb1672f459c69f7f1a610cb81633531fb59f13f71c6affefb7648b269c226897f7be8c96997767b25260fb1109d5370db5128ac839d33aec3d09254232f4dcdce442ea6e482935675bd0bdb19778525fd83f246f7128f410c26b820b8725a0fbd8dcb3033ded8f59f24bdb0d9f3243184db841350e0cbe73137869e2dcb8ec2072a67332468a59aecfb8c8145b056f028ab560177ab93a76d2ffaa527ddee1ebe4f5410d4abaef746f9388aa8c6610ae2fcb88dbef51dec523de934466be16ab635c67ba27d6b42ee44bf89ec931f611cbdb7e0f69e48aa5ab9f3f75a2a21109985c36da80e29606c7fe05956a5539df0456e36170de34af2d62ef62fe3b31b7a69987eeaf30b796bee8f94488c5179fea8e719f141961484ae664c4a24b1a8cbb75ad46ce25d9c610311dd24888b648184777fd3d9d2f61fde58eb862e1e54fd59617dd67ea022f1db7522d47f9f8fffdd7150fdcec0f40a0229c75556507bd07b7ac3d9ad2fd48eae63ffd195d0713e6c8a08a4b66ab26734f88761cce6b167e6a25b1120ea76d702e00189a794e2c7ed0b2a12eca62cc08aa464c6ae251e6847c4ee09ad1311a375ddf6a05786e2d1721e3c26993512da72d1a859a119892ba1027ed49cc24801bcf76098b6598917a03affe3bad6e7889ae272b5e65278db4866ae2c199aa4375a7eec79502e60322c78ee104e5f4b34a8a2132e136dfe4e3adcbb8fee54cca12f315cb6fe8f49b1b6f3f78fcde50e9e009fe8ce5724d597e88dfad5fd2ccfe95bf4e90bb13011e8a36539b05db85db9992b60f613a67d2669e4837e4bb2c9f7d26e3c0358349d49aa24cebd22d50c156fedca2c7ffc97a9ab19fb3b7adba8080886fe001ac43f3add3921858d6af76409d9796874e4a7f0b893fd1adda43730b5090e4c904eab022eac435c6c41c1e0a2fa4af57cbc16dab4a433c0c488cc6ad1c4a3d44a392ab2e6aa38702e9c99f1dfe01ca41d9cc83c31874c5682d1404ab9fe00dbdf81a01844782ad626c618f8b565d3bb8f6665f069b9c30aa022782c38b0ec7b97fd3ca790f8328dbdead19f45dc3994d0f691776d277db8e5416810fbe9cfac9452a49fed92ae0976e56c19175ea75d6e88e1b3423e344fb9f5e11050abbfaabe0f50dcca926162b46344a39d4fc01f730f2bed8e8d72451bcb1a93cf33e4818a974d2a295d6eebbdff175214850838a83becea2a62f48fe522335e78a1e87194f08f0ce85db556829a059cca1f17fcd7baa764771aa568565cdadd8c6449d6cc29e7254792fafd1e9ff7cc747bd36edf52104f8d35122313cd6e10a2dbf50625c549ca1d03f99b884db954f6a160925766eb8b2c0a8808310374eae08598306b89eec63d0df023c06fee290092104a7bbbb1ae1e7b97ea03df3eaeab2497ff4936d9123ae518a0d1a759f8fd893fd48750b0e372b6118e338dfe34b295b31979ed5dedcbe0b0ceaaa2160d18954e0dc2b12babf559daa9804efae2b82686550c6d418b97fc1873601e127b346ac45e369ac77233658a9b303d3ecb9fc64fe4bedcddb7b85082a945940de5383feb43925b79ad3983d4a54ddc268a8e68baeecb8bc6fbb13264f4cf454b8dcd3adeefb20a4bb8814779248a80c057ead645241860082f81b7cdba2ee2eee40dca63edbeb718e85a547a5e2af8c78b21b5f2afab4dc167ad87160fd7f9c72323ff3ea9efc70a7ed837809b550decfcee4a2472eca716a26a490ad3f0a1060c9bdf5d55c2f04aa539c273008485f985858aed526063281ef21ef4b161703bb4f7000e245ae70b7e46f757237e54ca1f464216543272c122de2965f758340b4fa6c858e596da0d20cd1fa6ef768195807e24853356963280d49614af20aa40c4d979ca48c498e992003c25088b58cd387467035bfe8a6a4c04bcda7fe1f5414258fa78ca3bfe39a4b1b7c9588cb83da5a321d419112f3cda4ee350df5b322ef94857b3c59279913073a2bb2812c6b9231e9bef0a9d17b7f054e83f88cf50a4eaf863ab87658c4d04948e1b7b2a0b8c37ed32baca6710cd6351253718f026562a48ce1a8c47f2cc102792658438a9248319bbed2bcd655d22c5ef178f3661c3ed448fbaa82320612141ad46b9351f3955b0b28d18100802e6c2adae4382d1a10df1b9d535eab31aab24db617e2407699afa82800cf7ff8c644e71930a8c0d00e1aaa7d69a20b7c367c35b37978c2233916f00546ebc60526fbc870963437d30a349ad1a6b12d85516936fd56153e90ee7e298cd4cf55d36250e9a0a6041b3dc25f579640ea0c47c7f245bb5bdd04677701f354fa23f8c5d392d8fcca1d94be56441db1a610403e6316c759ab3b9ccdcdda4cca4a4ddaf3a09fd86d9730e8ef87ff9f5331788ee5bf33e3e0680a0f8ec09e3feb7ab2b303372cedebc59cc42462a7ee54f0813db66103d25c188e033c85b9d249a42207747a060a388a015f6894d9bf28018a6e4e751aeb35ae1371286dd5bf0d48cb017e13cf475d31d2d18012371ac204d37ccf4cf8e9cf099e741a19d015761caf32e9799fe7b5fd1a040a473facd07543f2827982708095673cf920bf048f0a1d6a005c54a08ac5a6a09980b80881b7ba72533760334c83db7138244d2d4492e3070415fb543a1ca00dd3144e24c415878f466e4ca9b0893ea391ded6a5fb4ce95a52e50b0e2e70bd0f0e21687c736235c9dad29d39757d50654db29ad34e8af36899bb87e52d9640123a0cd74753e2d89413c028291d04beb44af60eb0ed6147e64cebea0a2020f984e6d6cf1f5f97473eeb338eb80a35eb843eb8c5efa6c8378d25dc4ac911f496c8ea45f3f97e570c4b0a92ee3de25e6309d8122af249ffe62e315b9cf49b909d9040b972f11262b4fdfd6a9cf2884bbefb56ccd62d1f84763e59f393849f4a3e2e90aeb1e1309ac0918cafff6c0b9c1526fd96f0f681c81ca4b066a8dcaa9b1191575b32ba73d44f706e3f647f8214af0de32292e0be28b4d9c4338701999c3c5c020420776a78935c0ff898190820f36c3ff54f33a1050ee928f425dc6438c19d8e1f6c5cfe10ef9f10968f029158719ed62bf2440815172133b91d239c479e8a7c7cf0ef71df3c953e43482762e1a935d90b0678ba37f32a38ef624c48ed928a38a7b45ef7bd516bf442be6e0dcd48894071f7f6abf8d2ec95654e136e2233a1c918cef644bd374da8cde1e34673d6d7fb2bc9f7c9e7486482e90daa5505f0985beb71529881114ef84c705f377053cfb86bd186d2e5b1c9746f982969fa11b0954946f9418830c0a77a4ef89902e50e8a6ce0c2b641e3706097d6505ec59d4d59bec0f8b68a5474328ea172a3f6aed156a772de90d1b00718cd63f5187f4e1b0bdcc5af194c2cbcd47aeed295f73d8528f4772f6d69fdd16dbae9e4852a4e8be419d0d4b4945c45cbfbe627ab0c51ab1b3e6c8e93f1f6f8f952d8abb0dc381cba2d527269b25149882138f63b6a42ff628e0b67f15b1499a4f40ea87aadff41c6ece0035cb76e16af5a4952497a31c5dfea3f07f6217b33032dceb9eb9f639b3ba766ef990bd219e87faa7ae2826c3f0dd9011d29d1318dfbe15aae1def443d026421e4d490edb5846d0fdb7092beb57731df374bfffe7d4bcbe87c6fb5481a8ed8b69d1a51d08733f556ca356c505fdf3fd999d2526988b82306dc98ca75d5a9f22e096fd93d6e2a2ab1b721fbc97f901edf4e03ab1bd50fd9b96a1f02215e9a8b318afec7fe24a40e7a524f4eefe116973adf86052ce30b7171093e7acdbaac56a600bc37d6dcfb118830c8dcd20942b117dd469c59be25678cb561304264850a8fb9ddcb49e6721317f8547a973b5472baa6013f713099c247f508b56796aed17d636bdedea0a68d885b6df1c8c86d800e2a729980fc97c424cf74df54346b41483a3c758c3f5499fdf33344de525114d3919f2863df897a08aad2ccc5fb598895f37e66a39dfe20e8dbe909fcca4c52b5ad474ee0889f58fada890c909d92d9cc5afde6cfb484870b6497a8f5efd212ecb6e290fc17fedfcc128f60f9bbc5ae5bbac57494db8b097b2d620632ebd0df4a24298739f1205d38a7603ce5072442b7120c1ea0bd32e5360536b88d8cb14bfb51596175c8eb9e176051e88197f6f1c252e25b9afa4a9321b90696f3054a47d8e03efe0d5f1cef41644ac01d1c4bc8062ff2b3b23133fc12f15c33edf98bb20898f655ecbe0e8031a96801d8db6e3c607d30961033ce15844a37cbe9dd6aab11262f92236a2a435bd803e39ae2a4b74df09","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
