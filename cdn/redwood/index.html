<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e44e60eed9623fc7c14d646bab3e0ae285cd0548e311d33a6dd73c45560c82494a030a04b9069f85e35d4865dcebd3cc0c7d10fd2ea74f4e67077cdd4e0cff1e175f519ef01f73b21a6e22db64d219f3ecaa3608523c1e7fdea1ffc5083da9ba72d4926cbe1ca1ecbd6bc2b23217d821c6ab3d05eb107c71b39c6ddb52fc30d67a142a2f8537b83639c6382c4246dc47c4d504785f183ba5e71761447de3fbc1c6ec61d34307fe22d0f67b6eff2529e81daa04ec750f2750b0aabc278eb3bb76cef0e65f7a46907d88e52f4ff50ff1ab45cb9adb5346344ea7e268cf3d7457861ca95d1e1be43f5d51e0db242ae8fd78aa6cc2ecca2358a9920b3379e2cabfb58ef77688fff46f1a2df1dae7e1006a2a37f71519f4ac33573294381272b109b41a80eb1e71c85aa5e7ac4dc1a890e94702a554c7d2c2c09440f3da7c73d183fe4aeb27d8bf785734da6e4a176e165feeeb222518f5024693f2630db045bd423978b8bf7ea9083e72b3025935bbaa7a4677b0dcd9d25f5c6356c11a93375cd981c41fcd38096723ffdcb7d75da9c33a4652f2522fd031b5e09dfe70fd7c2e3af2b9243eb705688fa450571d3212d5b350b79dd1353cdbc6e952eeb88a217a7b10d00782df65c7b708530d8c601e3197b8c2fd2f51d4962192c506dfa279291b24ec9a6ca42588c1a00c732e3b50469d00c6d79ad6cdb7cbf4d8a851701ed4d674ab12c5b9bc61fd8ca4c113dad2014541983858332d69785f43b77e1e29eee87f986270a2626c38cc0138020e586faee7da821c4d81a0b8205a261874c7eada967837c4e3e5fca71122c338abb2efb95a0c93d11708423e3aa3eead0805064f5b908d9384d86db6894f052fa1b587fd1f5dd58e76aa127b4d99c0bc02ecee82901277948fdce7e43cdebe1466b37bc59275920bfa373c4d0cbe1b2c6376d0f606aa1d380c2bfb150e825bd75390b6f7ddbaf36cff84c7ed4bcf9b69ffd0aa9a5a83332f73eed478355b07a572d43c992d5806effbb10bbfec25a45da823fd19dd4c0440dfbdc1c8529ed3725655025ad00d0b7be810c7f4449afd14f312593a5fb1a251a287ab2efcfd2a5206da46790c9a19d1acf6513e7614771895512a146f923c7bc2400a7cbe5cb75a3356eb1d3fa8b7803e176b241014571759a866027af30dd01a76ff15eb86c6b6ce126688d0ffed1bffa3d32b95e7f08e365721332b9a4ee19cceb34f5633f0e0fef2e3e72c9956c57dd0a2854f9ea6e5cb87599f158269b94b4b1320a18d13cc2e909afb4c13e75d23bb3ba6147e6d2c8dd788fa24378d6b016913da188c6c15aabd0442cab23871c5c376a85809d58cb031c87f328fec1de1d3280a95cc266b4503f093de752892dad183459116a7e02d87579f869bac4596e68cbd13fd2dc3fcb74f3d2789bd74547ddd72c9af4cb9b8b4a74480c35e4742fa1a29f0f78e5ef0ebc11afd5055e0d219b0a3b3f2931cd042afa24d37b4dd994fffb24256580eca0dc89c0acb97811b39beaf56c0d27b48af9721eaf2c7973eacd837290d4e1ade9025b46b0f092b61caecb54692aa5880968857c50c85f33be77703d3c916e793ebc8cb5a0c7b7186c4451c0c32f9ae9d6c1e8deecd076efe8cb7c7394250816c0a739eaec5d215e33c399505d836af0ce905983385f15e8f35b8a111405929e83a84a488e99280356dc9bd49d4e44f4a67deff054811768595331858ce9229bf823fedbc9c1856dcbf61964b2632add420e526286065a35d3d219a3e2302addce7aca821f7a6628ef93862f1b6de7fb931ae109154502ab8b170a9520966bd298210c8098b7857c7f930db9f50e1ee1c5c71c8a63f164224443329e27a16f7f517e063256c243d8ce04da344603463ceb2f4ee87dc622fe10b446cd69c5d8b91c5496ba31ab21ede55b3c707c323292d2250df6179fa121c6f049c3438aa132783c8f9b005e895c240c4ec626ffa662ab63a57029063ce89aaf4ada0bf3c78b0b233b2c10bd81079c7c457e610a4c544bdc4f69d197c6e9da33be7f6b737ecc555c72b5fa8e9280ab6cc6dbc1b2975963225d3bc8d695fd12fcf1ce52ff1b989d307478cf7f5b620772f4cce2637fcc4a6374ebf5f6e74ced446856674ac5cb2d37a15966eaf602d895ad3e4e08fc1937331359d452bb169510e0151abc5d33bfa5e7d32db4fc9660efb774ad89468ebea3a3bc82cb6e7145634ac2cc4befbaa06bbb6ec2f9df73429296c6a5cf5b04c35ae2c4a2668de525a4105b5be27d0993f4f53b95747dfcf7caed007ec1b085509d540e810d508719386a61d83d8bcf2d36afcb09536eeb9b95957fce0574d23076f1e4dff51224103c0a13239dfebea1007ba303376562eb8036a4f7d01eb4d7b9817550aad8c7ed7d05a05b3dd060455454de135c7cfae2693aeda1ee9fee609646fb2572b45bb83774d6df925ffbed11be7558976d2c508368eb75a0c66366396f7aedffd9bbbd44e44808dd1557fb4cb9dd74f8529a39d0a073794ab9895b4f77b68530d35929ca0c22c5fd8f4b372b8fd1f599a06af9911b754b2da0af2938e8372fc06b23b3befd74757a4c7b04e567b7f98eef4e63c3179e91eca3eb80690cba96fa3238214c24117d191abbc8bf5461a92f080ee525726bea661dbd7933bd3b1c399defcd6dd4fd509d0fa304c7a043193756daf8311845dd3e7931dc0dd3267c69a1ee319d40f19172d5ca9dc5af83e8820a661d4456e030ede30d19f8793bbf756bc16a274577a038c334e7618fde3f8a2c89984ce30a4875bf994fb566fb04863d1bf946ee76ea5bb4c4b3a34446c981b237d0dd543f5727dcdd0c48cc1b194085121a0db5c1a7dc23bf37dece890ddec71acb4141fe225c4ccfdaa58404ea994563a7e95b2a67c9a32c257d64a7704ce0af85ecf3e7c57a14ac043699f8e4333d24f1a1f5c59f93bafcec13f8640fbd9839db101eab1c087dfddc2dee38a043fe8a08cc7e7b9f2396586be9b38e731ff588be5e0cafe934803cd1598dbcb6a7eed3464aea84339277cb26d0bd217e565df7553de30cb02fc80806a14bd718e400f730ea82b5c909529df836d226afda595728a59113b3c77d51a26b24c1e95dbfafbedce0db9771615a04ac7f206ce973f00df3c98a15713ab960c1353bcaf9d5a70b23f3af815f3cc6aca4353aa8cd08c53497dd8a0dace800a47638e18cce012b2ff74ea0c0741610a29ccdb22e8c513568c7c3d7cd57ccc7de64be1d52aefdca04f948a6dab007fda91279f625ea6916c2ed5f06cba124be00dd10257f1e81251f97372a0214ce99e45c67cd627a4d551853570d2a9ee6ef9680fd34e0ab7c099932052343d168c15a8825ec93460d24bf196ccf699431bf29300a6b5fe1e882b11761e35017f67fe8b6b4d829b12bf0984555df8d741d21d73dfd74531378774a59750c6ea6c67d161af1181b5dd0f7f4d1d4c611e9064ee88e83bd772264f98f0b92660d176cedb3048aba3049d7d99aaa943f41f901fb89132d97b1aa64b9f2e194aef1484242a19036a792e24ff5c2ffe5c3c030f0864af72ef04846b846add1b727d47687838a2dff9e6ba728019f09379ee87d0c892cc68bbed11a9c9249e252e3ef3dc501d7dffacbda8252ae689247566cbc2f9b12410a4269b433c1401323d68551837e36172042bc5179132ebc72d038c080c974217a736cc53fbf8f9b8866e6c890c411de79880a22ae3d019b8088d0991b86052f2bcee91857dfb9eb336490d4f2e28efcd09b751ef456aefdc926625c651a6a67ed464cd9fdf7da780f9fd1d2934768663b88cba75eb5e7711b309a80d182316512ab67bb6264c1bddaa01aa7f54f11325967de2944068f51d8885709578e53416ea815be1ef2f10ef0a8c04022f6fd0965331b0acc6099cd92dc03c3180fcac78ac463b9ecfedc2d4abb8a6e0cee06964b59aec3d8380661aa72bd675b07ecb83633da8864c2ededa27ba6c376f74b05b0ba296a779547e2fafe4ee1f3b5cd27bcebb9976ef2afd3ac221777c61fdee29f71d5f6f3d8c9da359894b2aa4385129782f27652a9f0d7cde121d53ec1e865721af6607a698a794ef431739934f1e270014a2ea8ba225d7226f43cff1ff8fddcac582ec8209ac263031a3fec0e8f19dbc5ceafa0d914705e4754cb4b40fdc2f508d48a31e3e1ebf9a0b4ad16686222077fed38d54feac2b0c4abd4cc95e4bcb2900d5722e0908ed332a358f2bf8060eddf8ed36c8d802af0cfc0e1e09795996b27132523047fa4a9af50193427595e1e3018662417978be267bbeb7695b6723483792b7155f5070b916b7079a8616245e051707472ef9d23460b0c03f83f6bc829fa93a8863f74a2340dc16393daa69b45861e7b843b1ecf6953f33d2d350450eede1a2120362d30d43f2b3d69fcd2763fbc1943bd4c0c3b0c4bf9e2431e83dfc9204131e63645353828073f4382ded124a14aa114e51e8bb53699bb15c527ce12c3883a69d6dfb1c2e2e7bd57ce44f4e69b09e803158b5cb80a6501cb063827ba66f50cc3fe01659dee1cdb4b1be22df0e5299b721230f148c2e4865cd35ef3eb6826dcdbf88b3d789bfbfa6de0b01e227c4c874bd4af77a126cdcd54c52cf8c357cee9950bebd272f4d5686598326b6dedc9b6a5381eafa3922be6ea44c30a53f54f0513db3974083ae027ac927c470efb692a5d4510256a068f530bea66833ca58bd6d08b89fb78ddb9de29c817b5963548237be51b9b4fbbd9c0d832ab779545e332db147a5f63f74dc6d53f50d06fca7fa2a7217a86587a9b54e68ac40060463535b31846c62c5a7681794cc0953eaab18f1c489d74c48d56ec699691fa1020d4628e746db307a4bef7bf7786c6e2ceb626566e9e78db60b82a2648c6d653c5d0899b9906aeb11702164ed84824af57a076513b5f8a249366c1f0614c0abf3ff9a303cf3156a36fa96aa1b652417f2599ab2d076102b3a85a832a3cc04d3ae73bd241e27e4d89eae725ae02958e0408b5250cffdaaab4654b75648ac25e01dc9a0fabe04887c8f94d5646793aaa656e09e763b59239507602f3e962de2c505a72f4f94d500da63a68e3acfa61a6099debd6cb03982cb5150198589d9b4c6926f1ac608b066a35bcd911b7f2dc3ebffef201df3ea2ee6a8602a9d35ed38fd59b52a6740f87e6380df6b75d2d2e4571672fa23351fcd41f28c964dbeb95b488ac7567c0e61627a8149015f2255888b7eb829beae4d876d1286e6fe1836c9415b6225e17e789b88b6c57815d53ff3d319e6b38bda8ba7d164ef7648d2d2b33dc79c3dcc04b23c2a8506dd7cb35fa078512ba05a8a512a6978a1c4c27cf036d68a616042ccab4a9567f4df437c4972b7d37997a21987737396a8160db8fdbcbafbbba28fe05d9471d81429c31d4ef3e7c22e0b30672e1bbe80e82c5642b4414abb62d7fddbafe3b416d8f590ba3714d77f1efbb190577d0b930887da610999ac8fb32e308ae0682fc47ae26727fd3854ca8c46708cf32e93b3c329f0df5b21db7b01081665e0f7ccc6ed4662f7f2a76562a437f0b5559c9430a29dd6846bce0fc9a87327961cf6f34170de2970e6badec0f9b144d934b456f7ad8956acaec1737ddb86970fbcbfe59c2d0c7475090fb0d49a4d97b8123a1a93522eb9e3f3bd0b3d544866093085a8fa4f49ff520b2ec295ace50534fc573875be8cbed7969fe051faafbebd3c87c028d9147563a4c759eba936e9a1668f3f1f203d837316020b6e1cea70c2e0ebd65f481d4fdb6ac247bea28647132076de6b64654ce30b64f0286fc45219335d65123bba4d4460ab38f24e93ca442a67da3246f343483afd65e4d9060ff46f7df8b7e14b033af3159489d7c3c825da1887e35f110a41556abae1e3648ce734259ae12449bac318f8282f7eaac1fa53bf6cefb20035165759b40706815a0661a56ba0bd3447b0d870b0b747bcdc81be544fa1bc05f40eb5626cc4108a42b53e90ef0bab373ac488dfc91500efa584cecbcba9883bfe734e9ad77f704ac3a89c8fe2e50ab0686a5e2f56f9f5a8d2c02a99788a3cb613bac06db1040184dd31021234346623b5f6f00b97267053c5426f54977163d7d53a9647c8636944690c71e6db50d380de3bb7576bd2343b57ed1c634cf1efa8b899c53b82d8d5c377c43912ba9fd3c1457073e4a2b5b3eacdf9dd89966a0f025ca5d8bf1f1b194085c8dd075e867a313ad6eb43cfa38986a79beda3b08f5b061d66f14af31e1b74549c037f4a766c2658421f932b2337141396927bbed174fa50118484fd0a3600c49d1f128bb723038af9db19384494e83d66778d2b6311479d8c89f33cea7fe2f5c713ec3454a2ef862a900f307aee6f35ffd4b07574bb08f29e41065124ac9b7fccb4697edcdf3a26552fcf3bc18c1f7390f73ca113aef14728826be626eb72a202f6941eea3c59ce6686d02a2b0e5886623fb6fd7b7f4788878a88bd0ac702b05afb8337f91cefb85518471dac884ebdf6e61e3f39855a559fc299f335403e09200bae895683372828e4e5cc0762e52d18869e03fa156464a859276f7406fcb29075aa2468e257dddd8568266e4c2ae06845104e0dea0eca95b4160813534a56150abefe1c12bb0720dd7149d0f8ec5906ba80afae72cbf7d72053824677f901f13b2b3d87528418fb18b46369d78b68ee7d688557b6418f674afb99f505e14321afd1887dc54e69e742f1c45de7ebd0fe626e2d4720b42544d95dc58bdf99bc6251a2d516e81f8f65f2632c5b9d90436476c0ecd85a400d947ca16cededf24ab349dc7a205404fb7f8294d23a175f6ed693fec727bee7889cd4d7c222907b783fe5b418a9817dbc074a43e55ed6a25bd40706b5085ac8466dbad3488d6c19abf3e4248644a9dad5b56f543b7a0c8bb953b5ca16b206bcc888f0cf8eb62ca8eb8ced78bfc6fb7840649c9cf570085fda984f7849a9999f1a548f492b694f55f0e9aa08d42bc1c076a93c9ad568dbe424319d9b58f5239ba0d5f642e535c3c337d28d536c1aa8d78bc4375f66f94e7e555e2bb898367fb30b209abb9d052cf8d196b9809cb2f5fc86c9265b82ff30ab5ee77edc1375dd7d0663e7a8d1f7354dc7a2d1ed064f65fa313ccd0ceb1b6cb401b7facf1af928d7b434140b89beabfede488002120605e4250b3455e16e183c9a6221b43500f5cd5c69cb994fdbc71d84826e1c9abfcef60ea27f5b5372cdd0127717c717162cb987c24c505464f6b6b7cbe6e4945ce90333f66a336a109d4c52f4597280773a9be7d745c36d051061eb40951d704e4b50cca10afca63875e24a5e392ef8b9e3deb15ced23322b96457c2213223788ff91d10425cd072e6eeb3d8f770df57b9bf126e81eaf764861e70bc14f78c92bb24836758f66c2575adf00e4d520a2964c1f20a39a46f03a79fbf6651636c88307af14e7bfce3802675f2b43d976e5eb681003449852e0d423826eed5f28db038a86448630921d34331efb51a2198f2e8d9bb4232bd48ec7b41651f3c182eae00290796c907273d0c1850a82b393c5aa876a788635051ba0574965a5781eb1d17c8aca54f352029233d2db4d413c9d5c633687ae0afb6f7d984f94a984a98d518b88b0ef11123fbd3762d4c598eb8e42aa337cc14fbd70e766fc2fc20425068d70233c55e26ce794b78d7b416dca0038fab9e27e729429b38f3762151ca4cca63ae48edfc367ed357853cfed6dc8577f9fdd984d9a1f896a36fabf1e9a077189dec50bf5981fa3dbec04e4eceea1dede79ae2762d854437934169709186500d137061b1519bb29b14895e2f7870081e392d61d5cb70f4324211d198c84901fd08f3396eab619b18468d943b554c78e1c20ef14658fa555187bd511ceaa3a70c6bc81f954e9020c0413daf4084717155c2c6969398babe4eaa1c80667f681d5cdbd219e23f39c4a5bd389e1e9be1ec1b58bdbdec5bdaf17fc19d7f4927d0fd7c6f02a313e4ee74e766e470fb2c98ce9e52f9fd16a8cbe960a54b8d0cabc13a1a1b99ab177d6b57c48168542aee08c9e666c0e7eeb334e82b4775cdb2e522509833a7b170d7231668a4b2a300611c94d0b71382a90303e27ab47bb912f7107ad478b1b9d03a533c7931a9b4d711ee099659bf1e04e852da280c517d7990bbfe76600e94e321c4922666d8e833d6940603684848ea8a2da5deda9d1c4bf40923a7320d7f426886a6c45db9997847c271b73168125aed5a6ea2de6fe6108fa9c7ec1d39804e80aff9215fecea09805b452548b89bbe6339d8ee3278d8a18bfff89076c577d21b0fb4b4d9f54a289afb7310d8d3e1a1b64063be7fd1d8be304bc540c9133453412abba3160a5617b386ac5b652bc3a93aede2658b6ba677080d55803cbd4a9af21f9f69940630046e5128b784e7466ea82cd4d4cba6de5b7e204a62c473885367eb6d4fa0d4d6166003485d1951e4c975fb0ee295f14110de5cef13544689c0b9965070f65e1c8d42e4ddd23ebb10151495fa340e1cdca2e2ea67bc2a2e73e9d0dcc571ba185a43c1b02846e9fbb7acd1a97edc854030e79a3a31274d517928d7377598f602bc7a7fec108e4a0d5132678b50689967a4964b22fbb601bc19c9af5500438881649711edd2ef29ee30d0e64aa79ad1bd58b08b0df8f15e797a10ed00171a1bbb340589d5784b1b031fbd02017ee190cefe1eb005d21abd8ae4fcad4a06caa7bb6910e0162380bf2556bdbf53a2382805c926bb7c37f65fff5d45bd43d14c53890dc2941ad4010ad300ded9e134ebc3ceb97e1c957036cd22301623965e4ccccbe23bd25c815a93fa684c242d0e182bbcfe313b843c178f3760b4c74cc8593aabfa02401217c0375ee3cb651f1d62f3525d8901befcbed3ce85ced1e6c0ff18e2be405607b85f462273a32cc7a0f18f19d4bf5ed958fbab684c50e190489e6722260e2ef52685ee7ac80b663d5d379970a907d3360ba5b9dcba0d4d892b830fa9e835ae6a6873101e588a78c510ec4f858d5bc1a58927c1950ccb012cda6c761b7ca9ee414f91d60f38550e620e28628530a4b4783ce8f5514ee5c3b6b086f01f36688e94c430189034e762cd26cef4912626a8f3df0bd52b3c27c2b9c933a0f4d1235941bdc9f0df4ba2c946f3ee11d61bbf562091d461f11ce1fb326b4a8cebaae20755416231adba049bd2a29f694c3395e8d1f457d7b57ecc5957e42f3330bccc92b2a5920b560c06f3dbc15b249192d9efa6b3db49fc12f6be73d24544fba705b9dc25dadbd222efba9aedccdabaf8136a76420faa0f7c9299a6c6fc54b3c72137e53da6860137a6e06fa5451ee4e9a71742bcd94c39a1042c9669b1bb8e7da9081e23057731452286541e7c53c19651a13411c9415a99671c4068ea35c46f9db44caa16b2019bc1c1aebc009f028b5f0af72e2719dd21d1745f9760f1c75f836874672b0b22c975e010e0ef019181c87393253bc63633a64751efec0caaa9a3f1017d4a0ba8d5c7ffb6938b018785fc7bb3603464051cee701534bc05b732a7c5d3a813f83ea7b310298f463971f260afdb96b6ce7f71d6cba7311595f7fd0183e474b4214ac8d6882b25d45521429d4203f323fd9e58cd973b85f8eca2a4248bb69f872fb2f52329e3771bcd0a94506c06e97e5a2e187b933bf4dcbc6c6ce9bd8f8f8a230d8a4bb8c023388defdf8c1ad9bd5a276b084ceb86e6064bcf12e1739666c0c9e379c2a0f6a5fe6a30217c37cffd0ebdda1e12a288019043deaad1a9ec2ee2eb6b75cfcffae2b84cb275f8590a571d5a0241b1d86d94c23de63276cd8416e4f5f587d7091f2017366861f70b60adb2b71e047b2057de2618e5fc91a361cb7932bfa835ad8221537da3e6a13c4ab9a725789eb0ca9a1a6562d750b0807d2887c3c5e6e6933f1b740ba1340f6822e62b0dc5521aa24e12c1aaf5d46eb1a41f81418906807d1cf58028132eb097c563bcd2ec091411720532989bc1b3ba98dc5cd68833f460d43e26ffd3777742c78f7dbf1db8bb964adcec3ae96b5dc03e7cb10f5c842605f2e4cb9e392d39a00c2f12d83609211493b1cf80d9d98275c951199919b54055a4db8327b66833283026077d668d757f2e707381ad155ecb19e9e9fe6ce9ee91754902f3284952b0e7a62653a4f67c8ba6622bf8affdf0c8ec3903a0389e8c655ad7cf260f366fec55aca5202980cc2ebe5614fc9a918736b6a9b4f4f21e15a4e90daa8d00e29b4e06b131fbad4e23986dcaf86553691544a128ca0fa6009a99f901d647511560eb1c1e89d5a7daedac57ba0a016818bfdb0ffbfcbb85a32a00504e6d700cb4fc8fdf5fd1e04376b1715d60d5e2c134d5bbd3fecd44762ba86f04e14cc1ace068a1b2a5a7e2b65a31e11d7ced59ea5dd68e7634518b6ee14275ff9791e8e13f8b5a87534d90eea7c5a4a9846fba18b937ac98c74dd9a9a1e1a643ad52b61e9e19ce8c5ff925f895e6449e617c6804752231ade217ec2b40392e3416484a2120d6db149b8e575dd22f812f5161166550bc61b3bb1bd165879f2b6d45d9d8f094bb3ec9b8894ecdf39fd03b1aa9bb7bf99be131171486bb3ff5a3a84387be02bcf8f9ff7c4f336587700e761e22aa262c41bcd6678ea2febeb5237ebe27edce3c2093cc04aab258ba78f928fb337bd67af525ee46a35f25dd2efb8faae327834a789910b765a1e0e20ad3ac8eedfd19b37e06f86472506e39000607db216a2133ec961a03a66843ff4a9414194ce65e87147713018289b0e6c5036c0652e9503a52b41666b7247a134be047beb316838165c033cdab97cb9151774f3727991a6486d1c64563969f3fcaa339d4af4386b06778e6e6106a3377dfe86cd25c6cb1fbee180807ae758f0c67bb8289c5aa1c5f34444f851b3a967b232af6774637c2998a5763ce5da2d6b9ac3e2756550bec601c575c88009c3b1780a99511641720abdb68baa0fa4fe89801093dbc5a1ef7e8ec2d13563e2939f20d63727e156d4bf9469cbea2751344d11051f73bf6f3ca0317acd91f92e04179092fddb41b21e8190c602be94ad70a032d460eda96e76684dfb516af0b8729bed6948650b8fc086abbc3a651746f7beabd14a28d79fa42aca7ad2ba079e8ac3ec4546aa0f5a09de69b425df4cc63e8563bb4ba5dfb7f916734b26a80f62c2410228c4f1caee1f1067662c7b788a3c72dd1a01dbc49ef388fd98f4b54441fe3cefcbd87da902d1e2e496ba2e62e22dc430c6e3014bd063583d657dfaf16a7bd4e64970ad2b340e83158b0f55d707064f5301080cc95bd76bac30da8ae4645c8bd493a8908575a72e74206a653905be16093d3da4bcb22bfe952a78004a6db6647ad9cb15e215dbe181318ce9e070b1b5e303131dac69a041f8df911955873626b59dfd6cc14be8f0e5d6996876ddc4fe7ed1bdb455db07667a3b524055d0d18c79c7765f101c87c8a159bc62e11ec352f4b4d214ebcea578c36723ef017bfa750bfdaf301e1b591b392825fc9712296ec8dd7390065001281ad785e73d4e6bb7d35a9b57b3bc3333b4d5633dd760bbdfcf14208d0ffe93adf71625b5170eff538649c2c74f1ad699210c71512650aee308bacc06cd11598478c62eb7244c87154ac4519c4b2671cb07a3f4f785c67e641f96b79ce1f92eca723c845edf033c483dcdfbe79c0bccecf8a85cf86865821253934ef591eac8d45680a40a3d819d23806dd4258fa000ef5c42052163e8a87f72f4d93f2297d47eb71e508fb2c0687026d43437839afc0b69be606f5ba29c1c0f5a00edf7916ae421522221073c56b5f470d3fbb71d71a5b497c45c84f8f2620fbee21d0ed61bb1cfb434281d7e95c67123d597be2b7d5ca8964c9fd2d8ad3720b9d099538a10b7e0b5a749608f2003d141046bb8418af3955b0b49e5bc736f909493f188741030a60c2915d5f976e5cecf76311861ca0c88b7646c03ddbf3da24b21cda67282300b9eb07f9cc999474c623b49b65165a96f592cf0e4ab1fbe11cef4bc04a2dc195a787ff3ddaa5ea497a19717ac6c60f5b21a54d6466cf18c8a181e29a37b83f17ace0050e532c756b593b59d0d119e877d13484285e2564baa44f982418cb07b7489aee5a7fb3c086f6061b4e296a65514d3862bd81d9375a724c786280e740f78ce2b4d1e83a87151768d8668fa71178bff0aa97cf288e6659e31134dc12685334a8c156a26f05e5e94eb151ebdc26aeda742c825304a49796845a6fcc12b2030141bc82b850ffb4c7123c587ddccaaaa481e7ee95ea3daef6bdc5e524bcbb5e1044ee4ffc9da2bd66cbc90f720cee18b8858dc20802cf00d8de87c512f8599aede2cb76278a2e2294a9be1da969acacbc2f17a5fb3cd1996adead1705eb2ae9601e199944c57f960310e5d527d7ce96f4ea51f4f6cd37ede084246fe43ded911ea0362313ce0786608f07f3ce8c4b5e5363fee369fb52f96af636c9c2a63186e193899a8ea940b88ce73f5822f5c07f9d5d844056042f9ae3db62a2aa85c3fe0293cc48e656703f58ac4df7e7112c7db3b86c64886df7b5e05839311324adee0737690b14128d853856dd66ea7f520f85e9bb1b93ed3d131705722e9f90f947a9ddcadb7628cc891ea91a7b519f6e549d7299bfeea34b2c845dd641045a23f0ac4f81d32e76bde345bf803a252f22f8894822283b8fc96dd0fba9ded2dc7faa2d20480fe5a1c5adbe925e7bccfe3fc216f6af24c905c882f334a3373b679dfaf9748240aa99018bb8fccadd3ecb28276d7187fdf749a6634591e1302b58eca0f80472fdfb5ceaf3cefca6e8176501c9bb3be86647a21371f7e9feab6d48d124497b20b2e0adb863016429b3b0b13b4d6dc64d37f5b7c09b470672a095988bcd0e0e96a1188b7e970cc5c553d98d9573dc13cec3def46d7ce92093c4328f564b69fd5266c5d1109f05c56448724761388b14885a7181625393c07e62f1fc23e1bfcfa210ab40fb80ba64be6572916412b647323b968f4fec70cf5231b67cd8225b80ccc53c0ca4108a2adc50dbb84ff023253f043ca1d842de56288a2e981642972293b34aafb9ef673bae2e63e3a5fc01db2efd3969369db9128e8076f2fd808fe1336706a7449562b0e784ab42a700251d8e5254ad6fd82adaee94c40c092bf4681c80d067ece101a8c3241d819d9eb6b62ac039e77664d7213432cd1d248443b40b1ee7eda6e306e0e503ed38d45f411e346ae9e36508382a0d2e0ec63f43694393604bb3f361bc48bfb2fa5446d8fba84033f42dddb833b64f666a6036f7eca2a272f9319736ed1c0d4b53c5f63ce1e35ee31fe32dd36cb788c0b6351eadcd1f81a00e9e902b046c342d790fd29d1d8b18ce1df355f64b562f76197430da3a501f94c0504f2fa5f1dad94549d22eeff99d0181ba6983afae928c846a087e4289bb6b263d70ece5068a76d2ef1d24892610fdbe1b54374a89c8872eadc93ce8bd609844be90bf76b0e122d2c21a5672a3df8a3ee144e8f12a7fa162787a40314bb47532795347e82535aae8517320b7b65ca6614a8544b5a87c5f28bcfa774db8613e41eb53efbaf34b7cebc124613f1fa0b6fe7741e2b844af6afa3e76addfd67cec40d80ca14bede3474d7e1dfcd8e8cd774fdec57c14a963cffd43446c033d527197bb0b9aaeadd2bb18043ba5bb4a7e0d401c3bc72195c0865a0c676d468eeff3a721e90a5f3ed332aed5c0bef7f23cdd06725b4dd75cd204ddd8b7e2e693003ea7377b812ae21f3bc6f819f28d7a9d2c6774a77f35fb218121b5bdc1684515c38a359fd6b4f9856bd2b9afa1d9c6b938deccf8685d728fa7c4f4142378d39643c33ef8e26d7d6a0c2f2ee6f726e77f932d058785e997f41f1a372d658f3ce23d25fb10ec5d3cacd8b90f79919f11c550c910ed50a6f38189013e48889e89216b4df680923b862993e3d60255512e3b6f07a05886d259815a46647e39b02a18fedd31f19734c93c8f2864ca67771e10b34b82ae69aa0f636c2467b2c91abfe6f5cb6ca86fb2716ce4e3af08ca7d4d1d2afde940d670384ccb8d6c4bf65f18265eb851096e1ec890c7cad7172c3ba690b73a78ced757220702b49a8f9290db49936d56d7697e74cf34a7fbee28625e8448eb130d4c0308d259d13215f81970628c220e7bdf74b0924392a71966617fe701d3e03139d3f059db7fb818c64e35e935b384af2f5d242c65dcc584cfccd7f29791465ec4b146cbdae6a418c1723ea9555188d8593087b64fc8e2390a1ddacd748aa0a38d92330015c29a9047d4a80a5a9a20cd5d1bf017b9d8b3600ca84dafda56d16e27b50e77340d11ad1f77eb094230f1239bcc7dd9b861e90b92a01ccb19c03668ebf227b14cd12b91f39b9f251aa0b67017a8372fcd41b8de514a381aa6d2c0f1a898a2258a3fb036a4b1216ceb61bd1778cf247ec247b901c36e8ae47bf8bb1893e878727192625c6eb93beb3cb6dbc8bb9ab408b932d91facd0f5274cac9823640ee1e3fe52f93f177cc94eb33784780dfafb8d0e246d7addcae001595a711d3fb475af39b4bcfcc133bad205c1a39213bf8ad99409b4eedc33a17b51d67bdb480c835cfb753cd05bc6811b421ab3e21e5c63d59b97fbf064e4bc75e7d3262f94172ef2ac02b7c20f9a0ca2705c19688cff9af8bf49bcdc4831c0d3d95a5486c4d64fbd22128d0ef7e04605625d8760b471db5c06eef2e9e791edc6a58bc620f18eeda8db230738b6d94ddcbeb0d69e9681985b4f1690fc2f057686ebdfcc5c2fd70980c19ea2d07f5c90e21a17f91c0d1c0750c334618de9a78e271f8cd21a6cc77bcd434d68d760eb242a7d3aee56b9b26b9e141e7f2930feb3094d29b5b930eca689173faa2104c4170b3a383b1ce52574a79f7b1acc6a404c9eca2f5e3c683caa7fffaf572cf14c84c81d0e4b8ef7c1f3edaeb59d3875237fb89fd35770f7c0d61943a6b630bd64e3eb57ca04f26f29b8fdaefd43de24ee95f88146200f08c48254c06cc3dbe45c28c0133141ae772be07c00a075b53b09fc74b15e142ca9075340601b38db2369283fd2848da2332df8a870dfe65914c511eeff60e971217f8603f7e011dc1995b3f000b080a2d21d3d32644cd3c84b7e4c609bb842734241177e70a3fcf12b01bbe8e537036bd45c2be4d3f5a3b293464375de681d220b59a59303a7b2e4b16cf956b267275d5b24569302ce134d5dea7dbb9933a82950d103fd0b29a0e831d9e17a7cd014ee530bda967061cb39785e38d285f848332efa9a63edf648f70ddf045d6bb1ffe8903600dbbc10f31964e835285a5a4931afd2b2db81fbe818a23d02e4798d2be189e51a6411afb4059f35cdd9b19fe0595f3af61db374b3a573a0d4727d0b991541cdf9a94bd8b4b26c81ab1ea401b09a2fe3e5a9f4299a022993c34482572f3ef25a72daf07464b5fe3d11b4decaf76df7d673efb5e30fc824743131d3d9a6e9b9d6e9b7effcf719d32166cb29f04dd0c33db2108ccb5445325b36eb94be3e833fdf5069d173c2e34c8ce85ea9b3d26f510ccb4951d8f7972452ad86d0a81044691edcf5d2e7afcec8801e0e58f3ac17e77110c1b7703018eba2e221959e9475761068086df1ed34f3b60f6684f886c33fe0e2f2dbead5af76782cb41960a78de3afd68960baf39e46853f3bb8575c760cee79b7f040ec57d38efef4dc600038e96c7905b9a82f66c1ceeeeb709e7edb5b54ed7cdca5ea8b5a468bba4f040d1ebb1d8bb6762d2cdbfd60a3467689ef82a3b1f05c8b40a46afc1f62a6e70db500748acff5612c391db466a153fffe54115c87042bb6e53d8cc374a043754b23b71a071fb9100ecc35b11d552a9b01bd6cba8611837da2cd37de2d703b2677bd662cb9fad1cf08cdd70464d021682a683997cb63c8b78823cf339aaf7f26926bff5efa6d439640bc9421ade69c51197c730db325040cc5809fde1987067fe3f48a275e15b9c86eac53af6c5ddb162f4d0417216357f3118338a7746f60485ddb886e9b1638489c0996bee817e5f533e5dc183554774add8fe039bece5ff863aa9b7e633b01fbf20e7a22e6cf70e62f079c322009b3a0f29f3b8c26b5dc7fc36e9fba978cbce3ca116ccea4077e6266a8fc5418b049042674277b112179bc313093c12854e026b71bdaa1ab90b0ecc0502db717a3fd3ea2995ec33893fd85840510f3b4dbe744907f6587b59d2ac1a20f3bca05544f2d61bb630f4e8bd6d5261077496c2f4ded99bd1cd079a4a82e7015ccea5a2c969d659e9d91d1af60b8532765cfe69f3929f444a359e79a36a5ce0a7518c797881d7b2ed18ec237cc168f45656f3cf6b1ccd291d2cb9d1523bd16b96dc0cec4e4b87413bd33d669a635e72a4c19bfe8fa6addaafc570c0a0f604da865ac38f6d7340cb7ee2ee4a8680eedfec0de6d0a97d077cb1331acb6e74b3b2bb625b9058df04f48f07b561954946fc1af01274418b47ec095b8166ac0d2e858b1a7cc17a2375c1f4ba21f97cc0225edbfcff6f76b014c758976871eda1ad3f338701a39c1391bc934b70640dcc9afe38e19c356ca47f0c740550b402a349bd74eebfb2552b03a452f9b0850a10d4b4e36aea3f02452a59660fef7819e592c7dc83f121d34d61feafd5ba631747da2995b64edec58a00b81c747a8ac1688127ad574c5aa480473db25d2eee4b66f82e62ad8a795da7b98fab93964d9de06e2c636bf4f8dd34834ce1a90f16c0a123a358ac8294a12205643c9cb331442f07c39cd79c9d224a72dfbd57dde3964ea0021fa0d30a4f9b7575aaaa186717a8e6b939f99a4b196344c4e0657276b8f3c7a1240d1965336e14a84cfc269bbf206f736411284093a4054fc1eb3348bf654801e71a667a700059bb6e3ec2df3807cc9f0919cf1d7f99b2720458da0000d161e0eb63fed07e25c7e420da7d5fcab434cf86904da7c995209e4a77932d9ef831ee999cfefa54f48ebc0bbcbb53b1ea66a3fdb08d540258541386b6fd7541583e5cd8ad426775c7f3906796e7b618d4d7f405c908fd648f5ca4df44c7e692be3ce8880a6eb10b7a47e057452105bba7226f50835558b4d2f2afdd5659c97703dcc27c029271761eb004b25871fa05a12186cde6770e5a428ad6cd381e05277f38e92e14292ddb2812d578fdb1e072f8b3402a30d332227690c17b72a3ae82d99a42f797c77328e93b7ee94c2fd1223ed9af4d3fd082e9b50cbade4d0802acaa481e6ec1a9be14d946931da30ce046873abbde84973c533bbbcea3986b59dd432a3f36e7c12aa8cea95a2925f6aee64f7c1d09e5efcec416b8e24dc600838a43dac65c24fd8251494bd8afc963b8f9726af8839cb1e3db9f0a9c0f7a79e7d5c14cd5bddbf5d6a9f5484f73ac597b6f722b38dc2f4eaf3c8226910cf75e13b6bf568a66db9fcc3c92fd78154cf108b7bba2da4896b74c0de041fa986665033f00dbf7ebf99ca2f25839336e48640d08d1897c70f15ed339e459cdf4074619a01ab793cc56029ceced9b194f9c0a42e846aed50e0b0942bab986d322766f0695994e94062b87c67bcf3d34e3e3058ca136f42c4f8e4d341330e5d63127201040056d0547009eb29c7bf49245d23eb4d2bfc920672c091e25d353db0c52c52ebdb7293dc2e2df0f45ea93c53cc828832272783b6fbdc2218f650e202a5d816ada6ff983ab35a60b1d1cc46c5b88e9be41a93211873a810bfcc03c5748d1b1bdf0297b26063e423b658b36ea4276ccc54ce2e0caf84edfbf3e8a2fb7a29024985019c534a4096c0b3ab730ddb515f469ea2ca913af9244d3e7724a84113ac9e25a46c5464e8e2917e82f170cd6981c76c5b17678f264c61acf8dfb5bab9225cbe5a8b3cb37876b25162810b9424d0517c29e911ad0600324e0e9f8f5d301a7685f1c252b0b86e56a2d20c91279e4c63d65986daae0e7507d125052345b92f0c7b52e7442e09bd6c93b82769a049c31a5e550d465f95a68a992849670","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
