<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7fe8195c082676a726bf54d57fd78f3a33b473bc850f7a27313d583c0d9cf2b0e641de46bb49ffe581e4bc3e3fbb850657ecd001f0703a91485d2e0a1fd2e6c636cc2c6ea1d9322fe2caa7b913c335ccf04539c216cd16b355ae7677c27d8259ef0b7b36cc3784aaa9aac212a52a9cc989ecf5fddc2964a32c4f36ec43eceafca1cded8f8ff262d1db27f0c1d51f9600d2b882aa3e41c3631d7a822efa85c692d8822366c057680e3f7dc91258d828b2426a08afcc36bfd379bcb224db93d1440ff7ff3d5ebdc4a8bee908329b217fddd7eaf7598db666e9f4f376f55c1ae31510b368f451b6e267146aca311f1106886e750739d5cb304c10b742baad5bd0f4dabf072c2fbe622dd39304fd7fd593591a208c7c3de89e4d445c27609f579761449e63868189789af6fb954ca8d970fa57674ba642d6d295567f2e130dc4fe95afa979b541f259a29e5b37a905c0a55fc30f3095e24ae862aaacfe8d0c19343d86c797dc01e3109aa8f115f96ef5daca473f70911c4fe8563902c4aff69a9725943e6c34fa24a901411bd67a55642a92ad4fa0613b9f8d2b5ab60ae1859b04bf613c883174a53f66398c3af5cb644704b7b82d81925e725a4936cf8a1c6a977bf6a47ce3fe5a521d409db8aa0d1615cc5659cdc71f6e5856aaa8501412341692098bec5e6d16172553defd362622921ae80b945e88177962ed40d925d347fe18c46b18feab9b872d025a9b3f6b95bd85839fee122c193d5f8ca5277e3ab97e6e1a18e284c6ed86ab5f662b61f8cf85b3a80bf6c41bdfd844ba5292fb46d6d4b7302e9a863e614f7bfb78a46e248cefc63857e56ca975e17b549d65833bf70cd8ddf2832b1722a3d2f75d4aa5804beb2ffbefc87935a40a024083eb5d8410e1e0c72b2c06cade22f05c9afa0f038b9a78c702bb14c87a7f60169dcec335dd4d8dca2b3bcb4cdcc50e62510e24fe5ad6b024553ad0c3226043fbf02bd761d1ef71b6155951534a9138ce71379c4be25972cc0192693e610998f64131d5523f10d5b8c5f0a00993d4f0cebdb902340b12e4ffd6ddff90fd07b9e495fdfbfee99f98842d5d430bcd42a71ef0e7354bf39046ab958071c85a36f6b12a898d431df2a2a28bf37be2b60dc2614525db4ca870464bd99362bac62229af12cadf667f6c3873d390baaa1d399ec853a4d576f0246ca35c6794f00657f6988ee5fb844edf36c88976f499a5e680357dd5ae29ed0ec6255f8731399ef0a38dadab616d3b773582e37f4a5aa7010614cb213cb115c7017fe16c6c27053f6a4a199aa57b8389304da51a5820d22dd8f11accb6bbed498d0e0459ede5aebbc6f8e7019998dae140d0a15a12e95913bd0a0f3998e97a4c41f1ba1534edb3e70dc15767d9054ea3a3bc735ed379f7bd200a9eeb74b1f274184f0c9e173acf851e31affb5a7404d6cee16d4037e5c756a5b8ecfa7f0aa49ac6e7730b97f3106ddc1f166a9774f7d4f3a853b4b81b8a846031131624fb88bd432fdfe5dd43910f3c614e2ffe6e7d0c3535c876e6640c8594d49d46757ab9c40d19bf310bc83a4b2ace972c18db3c3f13c7e5273d6881a68036995aaaf55b9e3c4c368b40fadc14f450283100327f16abc7b9834ec7d1ede991d80fda111a03bcc6786552b30cd1821dbd3d46eac48b6fd0e0ebe3b86cc5c25cfb708b590e79dafe6d71d951225fc42f8cfc98afbabe300af2fea3e4732c95b02f22eab16b7388472661dac3cfdfcf711d9299d7b3c5ee1409bba44826c11410829f157562ac187c2f56867a5bf1b94b277c602ad7e0e36737b9b7e52666087531d4810bd967b4cb9448db7b8e83385855058e567b3a5b618c3d56f718ba3c6c547afd6fa52cc9c9148429cb6d26ecfee5af66734d4b13fae28d3fa244e26c9119ab78b284a7a832a71088c9a547c6e389475a2abb7fd195b81ed68304b779e2035a0be95e9cd68ae60a86c84eb45153f40b559ff4301eeb0399009d3ac1a0806e8965d6f0275b4103d41f3002dd969ad95576d13f306354b479277166060bdd4b374828197d6246beb07b23b46adead5d000d3843e5384375152174a7a872c7cd59dcf3bf38ddc3d8b353c15959d549b894c0a9881a12aece6ffcf9466f9443301835342b0a52f2bd5352c8cc28331894bde342a9b467371db31e6979ef0040ee6dfed2f320d922af2131ec8d2684d881ea5bae0cd2eb407c560108bf37d7654d7421230d4cd61b0e7333ce3f353d0aaefd028e1a4f3541bdf642d1f07cdb130163c6ddd6590aee2781c47c8e28de6d3a85ba2b177da7bbcf756b8f29e0aa946a02c10afdf28708feb734e8d6e5aac33686ade51411176f0b3302dcaaf20cb894ae14a69b419fce2a2f6dd5cda80a7e85f49fb1f737e9e835db8763fe90ac76eec2e5f1ce1e5a7a3510e97e8903061c09a11cde61caf6df98e8b9cb340283d79e93ba830be9ebede58ebf712151fe97efe259b0bf18e43ba0d2e2dfc167e9d142102ad951905b38fde1858cee7ab1aa7c6c0c7d123b547696f94da53308ac29a451a6329c3bda030167e12444582d9a88f42d448f6da7d2e4fd8c07e9040e93c0122435734b1fd223b3218981cf10f179a3c10d6683547710e8206a2abf9658221a5ba06c5cce0b30adb099236bbed8c96c23dbdf1217ceb901965da9c67e84c8c3be7c5644881b6afab08f32c0c590b1adfdfb65583f14dc8f589d427e75a0e796246395d710a20b3aca0201bd5970207d2364c5679e90280e44337084f50e2f91b81b104b5fbffdc6793a96a01801346487a3c7330899816ea5051b1a612178f9c929cc6babc3afe5be7626ab58e17808f003261b9edc436d7593beaddd750f804b6db794b1c816bf1efc8f6cf79b0814e9d0af60c3741bb2886d09b0c911a8cfe378f5ac04ad75ce47a846390f6ff2ff0be8ad34928d765ad42a203deb9bac9768a0fd7b4c48647ee06e6b72ae0e85322647220499ef81d25d553404e592b041ba15c549fd96f00c33c0cf8b5f1ede80d960ab302cfeccd7e17c2542694066a5ad44ed738097226f1b5ee372b520dcf8ef5453f9004f004443bb953292ab47143e16c137e378f836a54c0c2320b2cd12bece7352d4d8befff2e76a28ffb7d7ff265c9a85ca3cb0f8a24e2c046db821ab177ffdea0e819070f8b0814d87d3bd412a51a02bc0cca34761b566f4012633a62182910b7df96c62f543772cec7aeecd91f396664f463c35687eb986d37a4672c86c1a1f6b0d2a450c24d0b013d8457821214831cbde81cd292a2aca9ea79fa4575cff380c418cba6d4de590f8702732eb60e128fa1b411882c0bad02986a24c3860de5b550c48ec88e1cfcc585e2b9423d1067e61bdac1bb54bb4e0e53ab1a8b20e1917a0c02794bf94ff407c7ab39ca41df498a02f196e70f9b06809992e2dd60c97c216396fe2539caa125e1c3e07038eefc6f0244aa91d25f6ef52046177d9ea0656d857d07b5e8a732652a21b7e2407669d633fe562bedc78e336ca05a2163811921cec2363d16e6ab9f2d1139d263150aba03d086fbdbd2d48129e6ca8f6e3336f31585092c747782a68ad73ccbf6e37c39a6bda106e02bd3b3885137ab3c08066a6aaebf986fc796439c65edb67d2f5ce5a9aa315c17f9eeb65c446ad7a13dc6945549467ee21797f9e9fa784d9c2c4e9f9643ad90103f592040856816a2ae80eec999c368b0ec95b4fb13480208092e5daa252d11e2e82e2c675c872d5ae2c1b9d3460cb9206e89b2d0f0ae7c12b2f30c9999fb56ac8ae22e7fdac11937c8cf7428a2a02fcfd19be2a13b9b11cd6ead485f8572fb00943f97278598aa37094a6c84ac46890cb7afd9c6b1969a2e3444e5fd2aa76c561881206be9c9c6082eb64fae888bd4e5d8de5ea971a0ea67fdc78bea2e06af5885fb881836810d683de9ba040ecd520ceb3ec3c5794c21733f255b5d547588a4bbc9887f45e4b56c51cc1dacce7bdd8ef87a411a2c254980773dc2bf6f4c19934dc31147c1912481bb932056935076c4b6f446fb7c93f7c1945bf724c132e4de9e2f7995a8358edd8b3713e981eb72041497a0528fd6cccf9b02ac0f3e0dea6d187cb357ad60718f909c9d0e2c74bb5d9515574f8610094fc6c683aac045c7c460bd372478bf21293b803c7c34c0cd55fb2da2c4ca798b618c59d6814e3886e88abbb83afd9dd168639cbba639f6e392b91d0eca13fba7cfb1c168030fab951ad1b9814746980c9a5845023c469ccf46fb2baa0deaba0aec95d8f2c090769b5a7dc466e9bbbbd46bc512194f59e68483b8c07ef9179e091862c45196e8196c2fce4c30e252d86a218d704f28d7fb47bb438d926e371e10fdae61dc9b0fb81327e2b3eb210fb5283f75f7207bf16efd1fb3024776c419eefe47ea3dd4a662f51ca12b52cd5d3e5276a342958d0f50cc83d7e89529291664659ce91f5f2759f63f85677a0738f6eee0e6403856485c3b2538f3e425ea0e06f77d2572741ad56046ee31b2998b3170a53cf7da78259f57d3fa406fd3bf75e9f8abc391bfb18e3198f4c16b73972461a22d0c7f7d08f452b868f5cec8f32c9c61682d0f2eae197491998473d0dae0a2380b9e384188405ece6af6001242ecdf44e5fbe7c63d5331922cb2ed130980c8951e42d16431d0b4648c7a7903fbd67a333ffaa5a78668193a0465cb206dc7b5e1f3be0e0f6858f3671a30cfdc21b2405c103b46a4ccfe2f5f075ffaa07661156d6f72c541ff49607bdaf84c27821c9c2afda49ccbb81d560c7f816ea34366e5461ed50a9485da62cca631b39c5bf3d9e9393707ed77c2971bd051c02507eef2da7abff92255e69bb5aee91d2798efbcd56d9deb8cf6415e162e61d66de11a6a06d0ab8f95e93545552880f182aa04f9fc76745f6da05027c51fcc213e85d4fa1215004c26dd502bb36a0a0ea5ccf9b1b06f70bc8a1a84af73ea06cb685982a3048970e915e95a23f2faaa9d0bd8b1ad8f3d9793717650e9bc5c260f9ceb3fcd77b2d168958f46ae9ccbba7c7d06e333561af8c2cd79e3238be59071e396fd094aa0540951f4396c0ac06efb5889fe33b1f3d21852d3763a2e802381564ce3740326fd679737fa8f6fdcc2ec640af76c49114dd35febb53efcd81f57f2a4b7601327f98fc3193ea4a2913a1578307200188cfffac526ad6d9124f783a2fb611fe6cc4c590bc66a8eb31cf63ad0d3179718848561a15dc4d14b3a105e7f67b89a743b8c5cb2e5c84b3e4deaf15d4c654766abea14103c065a77384ec3f5a753fa87f119f726dc537cf10c27079b2318d379f3d5bf36866a362cc1dc0f892c609927c18e0a073691bb4b0ac39507f57a2559220f56b95931284617d25d8f24c4551a3b8720366a60ccdaa03a83cb3f33eed0d67f970c24ae900526bcead1e267a9c5e86d43f39e4696f58d898b6f62ccfb702b9ec2ebb0f1090b6a62397c700fed36071691c0d49bab716ebee6befab4d0fcdc0e703da2405d09c3ac3e303179726aee72df03513baa3921137fe0883ad059868dd4ca8a0147d89064860d9fa003371e10d56bba26ec859763a016dc7c243e961ff5f4626c58bc27814988f7dc8514837336f768cc79ca57998c2315381f7588afe51fe3c5342f4036353493ec0dfbcbf772fbb73787e0f3edb84dd2623ca41fb8ba8eb1c36867aa8876eed11d847af0f68a769a9950fb066e4f32e9e1d42e44c341a83589992c38e47a2ad6a872084c5b758b7c359f8912b1229646664afdba3ddb7df8670221a904392a114c0b0d3de875f30221e362a26caeaca97b13cb01833f64f36e90e021e35eaa30c5e68362d595179a66d4f034f08bd0478be0a06d43f66cef555fe80379150605358670c2af9266f73df7b95952b1349821144e73297e7a8e93aac6eadb7f8a3ad5298a52282a11dc68e729f27659d1eedf286395b8101281d19dddaa6aa2c3938008e682f13fc6c37df83537a1b809580a40ff9fff22bbb61d4e233104b90a96b170f99cf6b2b8bfa8f47404ec8b9223369f7c98d2196f9db33394cd362642b678f02e2aae290b3914a847273d16dd79d13060f12f5dc106dc24a06fbbdea84ff9ec837ce6374b3eb8290e66c354b56f14aee0a69124fe6f415b586498084917ab8f030ab6723f752cc6cb9d2f377d559996de3b3c121ee3633214466a66c915ada109977043b84f831ae4385d1df26e3275bf80d82dd6c3300340e3f10363bfa4d3c272c3ec3fdc6c2b317a3bb7fc27b9f0a7f4e8ee77515173a30c2ca368d8c8fd6e40d2e5b44de88bb328b9ab3631abb30c56134132f5bcf56d1ba4977c41077643bd9da6c6cfa6bca4f5391781af1bb8cba80b531b2ff84203d876d4d44d02b21a9238a39b45ef48184fc0734e06a58ecf3c75fbaac78bccf08d700f7d1758067992b07583d2e29c7d8a1beb0e1aa7231fd00b7b49b0ac3dadb364920685bb7b3edc32a66cb85e33ed70ca4f6a61f5ade9e7b412f9e51e75cbff8b049f5f64eae0626c7cf7be888e371b68b4ac263e5e7f032565e65c59fb08bff7788b88dc659f10836a0f4eb5df5eaf55f12d0f3ca0f944dc20b23e77440291074a6d7dfa282ee15bdd13a7fb8e77099c6df97ef2e80539e6a0843302552c0b911bc69db5884df1fb36b28b06f815b923bd16bcd9770915dc5aa635102b8bae73a79dc7557552d7336104d47b490a9c5a296d68086bd3cf59afbbec8c58b62346da04f3aa324047e11f1547399627933079059a033ad409777367667aa56302e9ea3a419922c0c01eab378e660b03f92a46c2aa25d0605d129c359ff1a5e7f68310da76142cf7136ca6edaa7472920391d114635cd28f6d91dad3e312588928517696dc25559c6833201badacb8e66b8712e9bd1363daf9555a980bd6cdccc860c293149723c167005c0ee77a1388fc3e2f9070d2bf2586d75ff9a8ccb43eaa7cfe831ab843673a2640fc127b06e04f412f90ccee2c3d086cd9de02eedec827de404cbefb3bb1afcfa65ffc31ec2cfffb9938dd0202e3c104eccc3e6d1df1b86d6b0a9d99681c9ff67d3dce9037269b58ee3d6f3f0aaf84d9b5dc7dea33cb8405eb3cd3f5d53fc00f6a8beeec2e5f056e1757ac2d97cde7e5a757ba1bff73731555bea3a17f2285b6ebdbb60197a19f90b69c3b045a4f713691034cdf52505a84e007a789509fa43e5b26c0096bb71054ff6cbfa0af8bd02a2624a5fd5981efa723c9ecaad0cc4a48bfd49f4abdee6cd1c7c9c7d14cabfac0f038ffeb981bcb26dac57fca530272bdbe18d96fd499575d96425c2a7156b71071cb1880ebe695922d67763773e592bd9c945b6021342a8062823a7f22f91f45cbe77186ebb992a04e652b1c01bf89c63f0596b6d7cf01acc7ea7846085fa381cf59c37025497e804f4bdd4037c3f8210105fcf6775912812c7b2f7f104fe70217e53b93973ee1723cfd7c17cbd43b23f21196e07dc989778409aec2bccbdd97be3635cee16717bc759f75a7a0af08c345927aa8d546353758aa32cdff1a5d784f664ec2dc72802fde662111d46375d4e3db22ba31e746d85ff47607a47d2a3f7b6af6777265bfe8debc472d96f7fcacb29477bcb37763670ed02ef7da08abf8d1a82ab1919e378f925562efe46ebc9bb1d3c7194c5ceeebf5a83d1bd0a769c5076707f3e9495014a2308eefe832d4d4daa298185f9a81ccc1745dcb0aa6c95c53ce0d3a785db13876bc7b028e8a1652c2f7eba992806bf0756a7da9dc304946ac08157d915d6cfef7bbc6cc513ba08eda5f5640973e6116692c1ba795f6d3d9803ae22f22072e1484c20e08645dee4e6bb086aafc0c541840db6c2a71b5f3db2d3c859ad92006e4dbf9d7641ae6cc211b283e0aa8fb5504c3046748270288c479ced948450a1e712ffd0e90bd946212540352c1dcc18c1eaddf7a2a0217b8e91b1a54f5cd5dc0d7f21119c538e93bfc3c848d258cf627be290311b7e52be755a5c74afbfc6c1617d7a25739976d47eb0a35c591e5d85b09fd43316f5423d779cd2c87338123f7bc495f580404bea1f5f85ac11f8d5a34a97540947c3f8579c6a9c16ced52637ce7c04447348106c878102c27bf56b5499a9b68fe7748a915934e91e6773f05b381aa03539ac7fa0ef43ab10d7b80cc9fbc2a217c8a6ed95e15ec42a8473d17f2cbba2c3b45bc999e78033eef1c9b70d089d83ef2f7bac5d1177e6e968a4ebf46ea46ae57320a6a70cba267552ac89c14ddb086634d9ad640e5e6126951a01e7c61fe1950f21aaf314997d0196acb6ea79828099eeb7e3cc558cc37eadf847019e5ef1bdf62a4ed65deafc1f675f4ae01c0fe37fc03043e359111673f10383e7616d4e0363806faae92d0af8dcf3ac63cac0ec7cfaad530dfb40518a9d86f15e86f8db2b03c7b1492ea97824448e82fa42f852eae226a8bae17b6164567a99155c47257b3952a54e9d7b1a20be54f683caf610cac9b98c5532bd99e767a16ca2c2368cfd44aa06a1c55f2689e756a52150e1f4860ce6e7e43e9cde43d9f7e3c23c0faa90dd71f94d3a4ebd91b7f680b60991b3b7468c769324ab99ad84363ebd2bf239fe93b51c9ac99d27fef71512201cf7d230a9f0d2b864a9a7ec1b19aaced54fd8e57dda7632f971faa1e8c61fb916d035cdc0b4ade60cda1f5c259602d71235b8964de1d7b45f253fa08d2761c5f0e1c47b8d56a9266f83a2de7d8d8e3e1e33a4f4682a68c84571eb9b06e80cefb71d0fd6197a41a4eaa125eff89ae0f361c22b2fa79597c8a503d650f3f3fa17ff0d81ddfe5b3f9f3950ac4fff57e7083373315c303ca8a648878a30f8691f24bbe4770b96ff6b4602ae66d55183999b5cf4659adac7804acaa6b0841397a1cdba9d3cc1a9c197a3332ccdc082e583672386a0b3c428e7b47d525d1705bb14454f2993e31697183d70c87058777cb086c130dab13f671c4dcbb20e0963b44c70d3aa027c7b22dbe17d961344cb2026046c161326f6906ab72c4ab591d9db2b0d9560bb781638066d835c25ed9909c7c2f7eacebbf903d6f02773df8630a2379976dab4bfccdc4b3bc5ad844bf37082b655d42936c320ddec5d113a01589e1dcd1d428317e3304ba5aa250dd1b3ed8a29263f48808f30e4e48aac87e5ab84b174f253cdda66a4487fd3b8e37124a4479318397544fb2d6ca25b3a75d2183e613d7d2c7d27f870846826de3902c7de6837953516858c2589f5606031c0932b156a41605b6b4328359223cdae30c09146da41a858b3a88cbaeb40b9f2dfc31b59871ec487d2e8ff2f7c5a912c74ebd3d1673f6e0ad9d926c647078cd59af5d99f4c5ba836ca65d9ccaa6af725c957cbe14791d803b1dc60244547a7f99f6bdca752daa3a2f133be4ac63968c44fc5bbcc326c6e3e138860065fbc67c8b02759676a8739331494d085aea1baf35fba481a5f3de19b8dd607dcdd4b539b3a323141915da5dcc56cd3beda8169c15bf2c79becce4390154fd8b8dec3f17bb4a2c9997aee767b804c1b15142e3343c300ad14a6f57d0c84d937d82d9d9df588f1f1ee3b76692c9bb800b4f0b871a0f38e8287e44731397915ff21aafbc9d76419140d283fc4aebdfc23672f1e2d855f2d6028e5e9184518e774a0b13b32f92736ef09bb50e859c3a18a886e8b34946fabacdf74eee89b852e806347bc71b8b2e16f9f1418ea9ffd7c5b9f8771bec7856f5255112d0a61ff1900c42987125bea733ed95715515a0cb51a47a658c65f10278a2f0789c9fa7ee4bab11fa23dfccb08a82c8b3c476f4b4f335d822b85be7bf14a54cece3ed21f1cf3e8d14a4a6846514dcf82cc4ac6a6a297f1a59b483924e1fbc061f415d6cbf84cd3b5c7bb53b6078b71e4a097622df6975a2c9c4bb3bfabc6cb1eca7ac1fb37284a33b8f8bcab0139e4cae07827b501df07579d98f729a45535fc60340a149e28e048cbf950454f21f13218368e2de1cdda681f9745d6ca10fa094aaa2c896144fbde9ff04cab306f9dc55fa685e1993320793c85a77af53aedc89796229b7350e8994fc272bc01d2b370c1bf01526f37aedc811f2fd1de76ee45c5d19ceeeb23883972e4616c9cee15936ded1082a98f94f3b6743df532785a53a7c7390b6a4c9a6446a51b6d8f0fba4656a6388fcbc507e8af77e5d393018bf328b8c97922970d085383c68c03ec69e8d3a3ff86aea086979953ec4a1420c88cfdb32d9fb172c4dcc71ce8f3921953aa04aa8f7a875ed2ac245b53ebffc07ca4b70742963fde8603345c2f850e2110ee51ec77b128985e3bad8c0d3f74c1ee7bb8ade285413026759805552204d60abcc1c4c8fd0be0dc8fbb795263672e6204447996e036b986b49b7ed53bf9aac1998de6593d506c35b9df757956da170cf7bf45662536a08be3439b86ebeb72cf012f60adbe07d8e7cbca0eda8fa73650311a5eb9e71eedf53d5d91e8d05c85f3fe6570825f5aeac7f779debe975d30f6b3d163dbd4d586d5d1966e7c245750ac393415aafc6f4ec5b79a035ec5ea2d4743f1679d0a8c96bcefbb7f35b0f889fb9d65e384e317a5ef46ae129f31a72de444d827b5785c546946db5e0259ab2c4d624c64c110238bdc7a68942c5072556105fa5f3fed9c471d71a0ae263d11afd91cdb7ebc0c23ec49b174d0764de2026c31c135c523ab6656b8f9dfe6d36d21e3fb637a2a77dd22acfe930179c5ce5efc484a82140fd1cb0e2dcadf0ea0945992d53a873bff89c263f6d66414fa46618f97914f9ab1c045536c0baf4be15fdc17b381f93c8272ae6b37f458128572b1137aebf6af2fca1ffd25cc40014f2357d7a5e1e3acad4b4d3dc180c3dc3ab48c9904d76ea61ce9370b0a2b3db91615a4680bf3c7c153c9aff930f167b1c82d7cc49394471c807772a6257a2cacc24ffad6e262215a3db78b42136d991023b32b19c9bcf8b90bf9db34990d19c5e9960ce716683b01db659423d073ca0ef0c01db8a73edece515b8cb616d4967c9f8779fdaaa8f91202a380f435f985f5ec57cef601264653463fb1847e1fd26677f366b2f2a091e740ad10b3440a433071525f2755ba096e5fc6996f0d4d373542df378a14db7aecfec24c91f0c7958d6c77f02f796b712ce983b399ae8b158f7d2369a1c3d2a4d6ae2254cc99685e11c6385b15c5b48a5fee49f9f7e95e9fc5fa52d613eaf511d2e3407a9b4e267c40434ed46628c7a57dea140fa87cfc1cf197f4d087de7f123844893cc316e86a2984af5065d6e4053d44b2665007e745c706b6b899527bf49d2cadae3a3b6ab2e84bfc9fad92f427229411136af22d444bade710247fa416ab00a18d9ae56af198bdfcafc50fbd83ff10bbd978d5c33d7c8c4e8f03f95df0a0c8e41f648c00a7c35fc4314681c7104976bb33442485de1f6eae426f3c897a51a71f8119cd4d12ba1e6474f1a1b925e919a11355db59fecb40350da719fbf90ac3c822072257ebf4dfd623826737408a25d8202f375b8cd288929c58bc38a104f344a8ae46927f674bee1f3c0267ca1790ff5d6a4669d8a2b5964d005259760f8e96407f8962e1be84397965a4d685c32275f00a28abdb4475ec2bed1708b86ee29a77a50843bbf767610b0435ea93d47186c4d311f96e0e0892886c028af65713adb89a6458ba71b612963a7d62a822a205c8ba8d6250cc6004cdb893267608533ed946f65fc046f3a8a86a1cc1e5807b783ce230f1efd476fb7a4c03ee32523a622833874be10a1d32aea9d5b2b9b1d75296854edfc68636d04a79c4408c91e2b3a2aba8d7e6338dd333e1e9ce03cc7d74f00ab748f27132bf272d077caf890ecc8a91c08c48099add21b571ed31130006f6be19157f13bc7853c086fa3fc647460f2d5a1eded4bc7bff1f88296aba59d25efa4f8cedee4020b7ee1fa91c1e2a81ade89740c8242bf0147a1477a257a56ecd5001d6a8faef8f0701b4e30ae385c932b70d7f16cd0492a03dd427c2778056a52ff46a69599f91333c856732e33e585c29bd1803c2cd83896d99d206f43ac3f6e180d4bbd4c0da07af579b48e32c3815fc270b6f974838738fc56a8fbdcf53985981c3c2c8d5ac1e35e58bb8cd1f389b6f56cc3173ac8d9a03d326d67b4bc45f77fd7e3de2d0fb296bccc303f587bf9b5a1ac911e16f47501df6892bd23514538774081f8883ba9fef0872d8d9ed3f2419977e032d822f2012f7d2432f4564b33cb9714d6bab4b8b2bb4b70de4a59e077e8d92ae7cb573c6fce938b674a05c40b1f21d2da183c4cdcb76faac9446756f27a5ea0f760f0596a3fa7d74f406666f62fb7bdeb72155828df4bd7047a76dc57a2f2230972bb96866aace2a8024412e8fb39387f5795bfa9d116de4c40f914763bf2c8a16dac7f9b64f15a81ed416a32fa994dad1daeeb32c804438530e8dd8384e2d689414568ab857f370067cb29b9c50674c97a56933c6bc8a158c31db47cc05b22d32d5f26afe74ccf0f19b5d73165dc3ebc562f6246891e07b737eacafcb8bc18889dd4a7c271942dce2cd832dfca72aef249103c307450de92fc63148b0a7173e5076d232b284159eb54ec7fa2fcd0121e4ddff3e0819a2e010b66908b5c8118463f85bfb1c074ab49828ba49db508640a010b5b7421d274187a95630a05b541dfb201729e72a5a2f896cf3a4327fa313bc05b5467d8ebb11574c6aae2abb7cf0f30fa8d6842673cf839641488a9df7e227cf5a7bd20cac79fc2575f66f7e620cc5dc35245176f236a99df6b6d772986ad33fc7cb4c04cb7deb3c45b2909b88c885da3ac87ee833e7af300a4114f9698bb9809fc65fffd70a4c65785fda437239f7dc1a356f058e40c5bef01bee65c8f7f0714b4b76d908245ffaa4e97e2a6e6a14d003f2008d4aaa6bd54babc5d0db0a553d57b249ddcc5497e2b521fbe222c1a4653831fe150386fedc05b07044ed5dcb6e23c4a8e54e9d2518cf55634c5c38c498fc05ec8cea2edd22efa04c46c9e619708d69a0542eb53b1c9747f9d1cc19589feefaea8a58cf6f03f2c7a839c25451a9379fa234e85e4576487c01906f35d48d4e36a73c6072ee0a0e0db74d95b1c84d96226d0937007bd631c63d15e0159a77bfae3b8fa09f42227a497201a14171b3e05fd4e60de93759546467ff81f78cd64aad8ef72f0428d2611a2562c17fde6dba6a1d21053cdc8d6324782c1d3a455e994cc060c8c7c8a3bcb19925118b0019fa07acd3966c5326208f34320c6cfd75f455dd13286411b383488aa24e94e89339346280ae5fc53a41d37b3b22db0ecdbeb7e36d47bc307b9f73f0ca7642994cee58497e7b1f88082e37d142882584d92cb7939572d138d2707fa8f18bad3efd24157934464cf66d2c5b76d5ee718bfb1343ef279ce55d683e942835ee720e0a8a3a34da339fdde2d9825bee987e70633c3049a0b27c7c2330cf26aa0a607d09cbf22ff9899317a3ffda028404ede6404c31373924a089f5b030f72662a611d8e9e7ab92a0ac6659089c8a559608d216b7f8a020c5ce8c11dd3371210b4068de0e87ef24d484e5ecf5b9974d4941fcd09a3e59f31d2d0f5eb9fc0dd62e4435ebde52eef2ba2f6fcb0afb60960bd104ea0dba9038f422ed373a051ab3e24184c2f453457d5d8b4109f8cc772f8daf70d07f8d43dcbda0cf9b03bf31312e66db43f7d8a0c564f27d73ce60c0b5b0c119ecb0c5aba56cd9f02e6bb02ff0e4e2e3b3908c82d1bdedbe9538ad1ace9d3fd5a56a2985923ff91299c447821d6ea6309adf2ba0294fb69e05f8d1a488c256ca32eca7277a05c1d311b502cfe88c68a9d7c17a4002999510098f8a6abd21a025fc7746ad4070b8ce2daa800891310c7f63a05b395260ca93beb49112b8da75c229445f8d34113e74d4c79ff6c365ed79fae99b9f2b4409d2caed603d48c54246907c4f28ae0343177e882f22ec272198908c71b2761becd69e7f8c226aff5090a1dd39f750f8fec04d02fe3b8dd8c45143f8d8910949c52ce1ddc633280dc457dcfe624ef59995fba277f9d7543bfbdad50a6dd2c0ae954161924a1bbb94ec2ac3a401394a0f541674e9c2a6865f3dd5cdcd341624026f2b408118dcf073232833399b7d1779165c1266ec0e651796086fd15d7da91038ee2e4a513fa1360d506a094c9d1c79562a6ef110cb61c7e77413ff41983be73d8c397798542779a15c06434ac77c3cfece6befd5f72b4c48148dee1e94643c4727b2fb2601f2af2a65b32851134b4571f35bb124e359053d5779a5d3b86c3fa32d4de4e71552711de8ed058102eb747f8b18b01cbb9654d63f2f7c6f68bea08d95c6e51a8b4c2272f9c27f9c99600cc5e152807fd6505ad49cc389b23c0d506eb8e1616d405d9b9fab7318e3f33d982706bf24305dbe07e12a1849a0808a07bfd578e93c5c50445dab354ab6d8cd2668e8c29cf9f4e4181491bd8bd44c7684a827ae40f92ad3de5b4e8fdb8909565bf8add77039aa56bfb17a9b05e5e51c181d8dc6186bef35ff8fd791cc63f99a93cd8d1e6f77c232b97c14534ad95be862e862c9c4a688c9f07ff7f55e804b33b1a6d711a1a7e7ee751099f8809086801a31ea4710d08d2a20333b90fc7e6be299640b5c04b24691ba2b2ffa5fc700107ea0d30e2e7e45f47b02c84f58519bdec44ab6579ce76ee22f72d1d17975696cc09d117a29d07b113f8d502b28a8220e822985857647ccf344774b6602dec50d90e7cb55e412e114c5b6c505e602eb8be196d2a03e6bf0d718da433dce1fcc76d50b2001f4ec27a0528ec67c1278d8a0c8591d50e7edf88ff6268283f8eec684e17c49cf445f8d0d32c8c672e527a993f969bde6764f492ed5e31ea2ef50318d03b75a666d6cf0adc65a3a2ec8ad000589e204b7f324b49d3e23646619b84cb0b6bea814172a7d9e80ffcd8231132c986255f3042bcea30fc95988cde04b38abca1eaab99777bf14dfa77ea6ffc6ac157ed9833d9356382b62ea301f9e51db8c1ea82376d456013f5ed6727cd574867d0eaaaff6b61a63cf4c45cc30785d8d3cc25ecb307a2b66440a050b1b1c8bb26bb029662e72e3c5145498f2869a90b74360d64a77d22884df65874","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
