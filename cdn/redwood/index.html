<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd9f534dc8c2c4282f0ec5c99ce531f74fe79c53bb474d9da0a5a1284b2616f532aba489501465de85ee2501870892df1ec6ab1f01fdb7b5493f7b5cc55be560db552383d0c71e348dc4202f083f2e60af52cfc1a62f4c63ecf2f432b127ec9b436e7dbb5ab44d1f554613deaddef6c1b015ac2a502b029b493958b73431797633e01d48953e8b4f3c921ac9de9b45deaf78f3f767fa7a44a844d99288681c7828fdd03576b55d5557a00a94f8d6d7d9f790c0953341bd23b3501b885639a6918876efd631a0c2d306a77c6dff115b58b2027b35e34fe3f49de7149dc43280a9d7d25d85d3e4617cfeb0e5d6d87afb08c1c42e6856ca375dfefd82c1e4fea10aea97861424dfae0fd7b5f3b636d6b76aff39ca5d75c8d0c6bb126337fa35b4ce6a133d8c29ebf11b7062a7eaea84ded86a818d2013cbf87c5532bc7681ef9515f70b0f90eadf5e8057a97afeb0fe5be31dd71719f7896031800dcd6d943ccce71ef5f0d66aae69d67cbb23c7cdf77171bc17ac8de295f662fde383e962c39222fa1556b6ee3825515473afa5de507fe7be4330e4e78cbad5a5152f5d55fe0bf0cec93cb2a7d3488b163bb8911a4bd257a6988b0f680a907c490f55e00535467ee830fff045ecfccf6ffcd7a4b9c90db389a4095ce3968c616bfd2fff4696a6106643081a0173b4a23c1f467b75f17511951ebe9f24e99927c292b5d750f8f87f087dbdacccf1eed629217aaaf40a06392debc313c8225c0e83ccaee6e268314f0262384912b6ce13239e005db50883dec190b8fac5d9e0b117071b956ada149c46c552f6c81b217097f057ec35078cfc1f02ca77a316152d1012de2a30254493b1a8ba6ba10b79bc21ef41cf1149013bfffa144de9af9e9914068eb806a41ee503d7c4871f457d05b2f6936acdeb479cae93a6c9faaf1ab27ceb77de4daf6588df0afa4d76b983d7121c28e0a8b0534319480ee5514e7e097d5da6e0af03fed2c0f53830e5d58fcb997c91c0773888a9f4801bcdc1248cd336dd745eb85664e5f40ae8bfdfd0be1daf682f05f16aa609ca3b7289f1f562a8d03a4145e20265be7885e5b8cfa8d0127ffbdecc8fa9e88916635c2621abab69a6b159a6a4569c85dc42a7482595f6e6f3fb5983d91c1a4d9629d2053f2626c4d18be334630051a3b3da502c3bd49a219a411fb6f265be4a114e333dc989b18b81fbd5a293eb9b01da20ec0bc454efe310a211e3d2abb9dde439e8a7583f896e159bad37cf05348dab6b51c4c6f066b5be98f699e59de6279be2c9685d4a300f803d07ab74e722508ba255169c9c2b3a82242402b336479e5b2aa80adfd4d8d03a100de0af24963bba03a5371522b10f33c5204d1e7104bfbd1fbefe6019671b4f12481d70557ba958788b5ee5150fa50c7e70b0cbd81747a6970a74bdc271abc5c37bd43e305a5b0115897dee5d0a961629c9585de878264bee1a6ba5171ee0d3f56f252c524d0fe77473bbb971d890afc6ce1189e0e0764632d9267ca102070655b4e1f2bbfb8a1f92a656cf145d38db80f9d26dcfe17f7ba9c4e053fe5a34de87a8986b13f7b85f3def1034a76571b569e508ad0e4380dd88bc5df07db10ca52fb2f2d387d800f6036c3a2f6bc68b609b19f88e2a0e043c6022d6b52434e3c08d659e44444f14baf4f61b4a5edfee66d9bd616cf6929eae9796836200d2c57c8ccb1b0da0f51095fac113e976584dc8e30245887e893b4299c671d8e7b65702421826ae5c56a52d8c8606012a1f7c8296e187e403a4d4082df76fd891c1336ed6b55f6ca5a4558c061bf2c141fd5435594d9f61996ee3379b2804cf853cb9652308a2a6764287c28be6c9a5e970a063663c3264b6472e0e572087974244300eaf819b540fa000fef824850adde40aee8cfee967eb952042399d082fa8df2eb67f51750b2ef2b4658778ce967e33634285a6f709c6f0d82e875188829f2fa965446ac9e4e56040be57f1cc497aac8e710757d7aee8e3d271fb388365af12356db804befa53757d7a1fbe0dea851bf5e97ae34b16485152744fdc295640b4393370fde49d33f3f70d7ae458dc69c8825cf792c8a50540ee09eab1375dac0eb1b9f2655856c503f2802a67a13f15234e14fabdaf0bdd7f259a85ebfb40ce3dc1dd420dc31ff1720c107e41ccc7896ba56b91bf8f3aea4259998a04384454b795e4d664834ab801b55ce448a7438388fca64578d84a8c7d50c2d0a2f5b11f7642945988efb5db45b3d00cc26ce5ea669b0e31dce47509eddc9464d38c1c048b6daa3df6cca5aa60f8f11c7fb1e5162b3a78fd1019eb3ee437a1718e4c033da635afddb116b2ecb977332e98024b9f6dda414f7f514992069541a2024a8b14d40db847276393ef9a7d1651d4b3f424a1c1d6d1615dd5b5d139140baddc501093b910cdad7a3d0615a65512829b2514887fd25028f824d831c560897e3ed85aca4cf3e88dca4539395bdef8a1183ae046914fe7a7fabcb03b71296462ebef72888fcba081158d2aa384623fdb1f97822a0545332f0cb8dc280e9dad45e479122a1621ead81555e7c0d8ba67993bf76d1dad79c53195e129101506234ecaa1017eb4a8689f8558ee8089e2d7897a8374ef60b383a4760e22336ad56ea32b544bd4b158c961847aba833666b032d283a33830a2866b0e8c00c3bae6d49170e80c133ea0263ad5c26f3518e1f73bfaea9a06c5b00fcea15f4effb030afd2bac2ea93112eceb6af2f10fd967b4fd80d1a5b6ac48686cc26effd96a4e8ce00bbd493a8ca38d09cff7223422a052529f384eb47e70a786ecc1a6818b4098560e1e7dacb104670803443420faf6a31092114e5a24b9275d203cc5f846f55b68b61e69193669d9f6733e9d76fe6e673731f0d3f9717b07404e39d2952916843261d35e411195de86af29f4e3d1dd6866af2eb20be11b33f574d4f0d4e343dc2e884714a8943ee35287d1f3e3ad6c85c887e4d5c7355fc92e86ee272c1ae6f9b3b65516f00d2a6518055ec0fbc8e028efe7dc48ab202532a0bc310f872c1f8c3ec39cf0e74bddae1b1bb00e755b376790cb8b967e66bc3df10293234e6b8f8c1a45570f30cd2a4844539e4ab9f07bbdb9bc2a7fb6eeee2efd8fc8a9355f7b69ae894a53f3b0cf4991e5f51febd2702a18c3f69ec0b4f9a34f7cd1642ecb772e1503f591d6b587e62d701b0b7d5f418c58f6f6efbf98b9f9e70a742c93a57ef376b86bf3f57d9d63c3db729b55113b8b2b3b4ee689a7e4e1a75e136492692e4feb15129b8f35256de5f165ed6b9a1c47d0772b5dd248991c556f73da70f6517cf54ac0ad6607c5b166085690af66cf99e70efa5d3d9e5d3f1b16accc6a0143846a7fd986695756cf839861ca861c174681760c70643e7a44db56bba4771603eb1628aa59b8697663e11ab7143187fc68b50931098f30f470fa5870c3c60a67e03d7f191189dbcb8e5cb429674724a860b76faf9671a40b73c2a99e28a29196cca2de9c59233408bd307a011d62ac2d9022d6dd08496ba47b5280376d9cf40db8e79b81682ebab27619389709eb5b1a0bd1dcb1ab777147dc36335142a398174ffb212c43bd1ff33dd0d06e02df6c316d111ac64cbb793e3bd23cb4f24314160c2095419c0f7fa9a63437880c5fb207f7a0625c9ce8de0a6b9c0615a23bf78d4347cfa3d2fa910afceb9dfd679f981fbcede7e6b68aa1a2dca1d49284173a267241c0135f2a4dc034623105121bc7fda472dcaa78cd0d55824a69c2f8da73d0c4e33fc80af061c3df78d1963ec441072c30d5f4c895f3579d8fe0185d9b13d6248fcad1d3c3ef78e4f963c7a7b26b18b0179c3f0f921c78aad98b5c12714d9e194261a0ef3a4d30487e07f3a524e13ed2c9c64c1390e2bcbde4edab634b5a370920da36330bb1acc6f72239ab1d2e850881dc29da497e7ca2f2faa3512f04ff304999db47a536163f6c070cbe1cec3444a900eb7dc42d05e5a4a4af01796c73b3e4566074aac45e7b4fd070b260f4e4920f1c1cf6b9cf07b867dcd8408ad57bc6dd3ea5a1499df2e887a15da8050468429ca702d0e2ccacd8f2ce81db1ec7a61003f37042d5d21199f3046b4e08a9eef6734562bec41e1abe97e0d0fb1d3e4fe1fd15a134746181b26758e1d60620bcf2f7698481edd79776dab5d4fb3debb4fb20117c6b9085ff7bc9cd2cb4093ebc79c06f74ee99ef5cf1c73d5c2fb78c1f671cb9bb705b28bbb5877d49411a6dc89d3e40bf73d4a198607a34d65de9ba298fb5982beafbb9186133f6ab42a78626ebf7239ad4d50bf54d94f8eeefaea74d351b251be1a91f46df8f4187ea266a7ee1efa0c1aef0a6e5705dded400829ef54c6a5a3ec5c8c078795f7ecbb7c404e12c9764be7f2de408572c5f29ed01c8e8ecbdd616b8f77d9fe265b874db9ef28c245231999286bf2f7320056f03c29a07869efdb473ca7dd8243aeafad9cf383e034586810f5281ef6bdedeb6daeb211f0798af231d9fd6a1d9875792787a31715d4405602a26aad19e4d3a71c24c44fe7aa32c554b634d4eded93651c9dadbc84a5c55d98c7da7b9cf84d196987112f5e94072556be55d6f9cab52bab9ee549ea48b787992e957490606e48f453c7f256af5ea3d939544d6f8d6cbf992d9c351f96c856b3b5eee7c1cc96aa1ad969ef728c4caa464765d0687db64f234d08652eb03678b3f4ebaaa529f9eebc06e0821c0a51de126ec0d161446558b4b48202ec13ba277f748b596dba93b89b889eac3badf713ecfc91c3fa0c930efd8936c0f6dca2733a248411a25234a334f1f3cb4870fcb49f58b8e5138fa7477fae01d4dd3b8ed169372cef3ec4ce96046aab6319586e72b6a2d6540f1b0140fa2d64eb02db07eb68dc2cae992125823e844d26df1005a1bf7e4e4dd67ae7fcc9c593b0a6b5d8fe7142d511965e787ffe9531e8268533a6f133d42046f6ff2f22a5c9b609529fc56422604b9f5120f34c2d9c6ba6e798395c27a6507e29bb968a67cf337969273f06e509eed2d1be9d1053ead119571fd1a2707c1d166997dc38450b14a0d97297266af7bacb13e32cd9c3dd34d32b67a00763247225e7410fdce68c1121a8996f076c2a88be831ceb079feb1547ebdd441a6603a5ab9beb70e78f7cd28e5069ee5df42e7bef484f79940655c94a457ce558bba5c095952196467c04dd9f634e874d5893ec7545f7ef887fc1621f9a6a0b0f8935314ab4fb4d2436fd6b2ec060a0c345587818006d51326baaf6ba38066c16c1aaaa50e60852c5bc58bd903731de0d2eb8f3b962041fac31368044ba51cb92ccd8aa61182c6a6fca6b9e357efee4329866ebdd96060c801de4283b15453c73810cad50c7adc56a04f93315a61bd83a81da32ba21a45a625d85d978773ab4126a857755c3083108e8bcd9c0207659f1c0a5cc7c2af77a9b58fb0c987fb9336b96c11321070f5922aef08668ffa610f9a48bfb6cd0c9f9c4025418081a10bd16d658aaf621ca5e9ee8f8ff12460e62ba938e731dd1e8e330bd8aeb6e02c1b4bbbb90b3304740ab4084e14bcca0d3cefdba1d5f478565932fdf07f92cfbb018b0adf8be8b2b4ab37717697b11006508d91e4cf80ec8edcbb5b71240d2cd752c6f94a4f40e238e527ba5774f7307ad55d0d534db80b1dd7545361b172c3353a976a57ec9097c31cf8d7626a6f80042d1146765373a3312e4fd390cbc27e380bc1eaada1db6f30a2c0c0f0f48925d2d055718dd10a9dabc0d97a728d3b11defbc55bd17cfd620bf60a2bcd5289a78a5d71a9732d6607f967753a4d1d76e62f114ec3deec9d142f80efb79886ac07794d1a2fe3d14e41b3ef533f5ed4ca5786f9a575d9bc17faf207962690825e9fe4d5f1e11918f72429ed753bfa54ac8cc900e05396c5bff0c29394fe72fec6e309995c7cdc7129a0807bb391e0ab05c010ca8116e81d9a96dca58f5ac2076fb2664cc98d419e6ec1d24a13c25120cdb6b569dc6a5913616d22615c1903071067dacb8dc6abce6610c787ff03e0270d88ad421563bd166b3d7d0908ab4987ba144e0c131c28de625bb09a929014627fc9ef10902202ec88e1ba3799554bd9620f1316f5989691a88a0b56f98822ac61a71236239bf90ccc7393f75a5acc68a849457f9431b5400118f9502e802ac88c5ba9f3699651a5dc14dd425edd04d8e6db51f91a5e2242a52e29c1b839394d244d71ed06ae1c7e937b09b18fed9a17dde43bdbe82fa24cef22ef841856516ff7076e922e197755dcd5d6248ce1db1d4ac96f8cc9862cf2be52758adeffe5454b8e7de2a7e6105c4b7c5e86632099ab1e86c0ad53e34bf0d9476369aefda20a39115a343eafbf2d400464b1632fdb9908d97b6e6b43b828843da3d74ec74a16ff062164a612095d6c97aac7baadc3261c0853b989f34fecaaa5bed35d245c5b5dc9b7c1ab2cb5b03e25ccaf77dd305fcdc279558b6b3426cf7263204831aaf2637d6f7c5f9e3d75155d75698f1449f30ae573c38eafa3abf73e08f3afd775a2406cad421836c69ed7c7802465e258c3334a671c386fdb96d64b8f9dcd90ebb597432a5944d00aaa6538753147498bdbba4518bb62a382c0b27ff2271763636467ec135a08c9775433fa50e6e92c44400ceb1d94efc898b8f40c47c0d34887e6a2da94e0c68cfb96527bb0f240811b44cd615514aea641afdbc78f56adc66f509d96d79d52252bf7d46afc789c1a29e05b7a3dce327e7f1fd56825e81fffee23bbc6569d37b6639abb0ad261e85370ba66982079ff5db2a9f8e0ee29e68b114f0868720c29719f1335cb0558c0c058b5905479b6015af8c06d3c6848b02bb7f3ce10ba2926c934db5547c35dffc8e5a9688e1cde76faa4988e5a49240de7c837521a9e209ed66960c0804f84a736d7440294f7bfc2e21384caf87cae68e1cd581ea15f62dd7db4cd714af6ae9fdd1d0def3d41531e57c64420538098d3655e359520aae04d23b4712c45513721dfc6212445563f397e308d46269f48d478fb34ef5e95549591f675180c3c8f8a2cdc11f68c468230666aafa3abc18bd6f401ce73adb420badc031856392e88bb88c68908e2d23541a45c1cd21a0d4c7d1214b65d514685cd99ab6c965722adc79418622f114dd2a7d988593ca64c3f067f43a7e9398c6fceeb339bc1b23750449024c28c5efab912d7714fb731354e5e1925c9d80f606517f701eeddf8827a62f62fe3c2e849b25c5747daf203d42494cd7f2173d2d97c0420873c1b835c9cbee5c9c832ca24d590a14c6a91a01dfc7801a141472263a054693dea37cfd9b107db150d1b20234802a116413f73638b922752c4e92e552c71858b9c273e808e68707d3065739d3d57fca8fa6af390bebd669e4e6598dca93864b0e23572a73c854815ad2aeaba5c2eae5a762c883c0f6474a4c7e03ba02c84f972d07914e477b684e7d6cff4657cf3a7f1ae594a686ef2ace65a6df66e934601d2a9f3e80ecdc047bb93dbf5959e288bcd5613b7fd8d0f631d93bf10a6f4ffe1f4f38738875c8679a7410632d260a1e9f695996c475c8ea8c1de8a652f4858e08138dd0e2c8ce310480eeadd400d5fb575a82493a4124b495c5b3c840a1562befb3852718df7ea63ad433add91022e76aa59998176a03f247f17415fd7d07abd1f8cc172ad287948744acc63f4fbb89ab0352f444608bdff8c20ea0c09dd8b46fa7feb80dd66d5ba731c9633a66ecc39b81e3404ac42fe1fd7bf30ff2c0ca8e53d4adbba71f3dcfc889bc109bf89a8aa0d6640ac36fa48f0d927162cdb302839dcf18a6eab8104428a55750c53b1d263a92de02111b2135fb501f8fcd7cf8047e1d087ab2eabd5eb651b930bcd48a2a0e2d95a06c83602e34e7c06d3156c542eb0749ed5755cc44f738c283dabd610853418d4397b2605384c6938d6274a08fcb8c8a0b689f1fb5986b65d5a75761db7676ae28c46bba29e56a4fa336a7458639cbf8b5cf2058caf5bd8fe2bbf4edec93e1a4e52f7bfacc5c7d1c6a4d269b201e336d11d9e1fbf20fb31a5f0132399f1945820ab365da121a534da2a522b02d050d52d1e3913a0e5d561a74ee5559903e0fad8ea81eb9a825a88760cbf2c56a4fac899c0e84483984f341f477e98f74d40b0572d06324b116ccd89351cbe672fe3cbc44527c03c98401258ba43b25df38376131ff8e665e48351897b5dde0979f25142b21354c1414bb61cec7d53d9acdd9efec3df0cb313a9fb21a8a6a82436418a4f46eeae4cc67924fcda16ff881c3a05c4bb27bd6ab860ad9c7569f7f0c058c1a7e865ed5f959c4508410823c3971fd279c892f9d79c3d5c29a73b482e2da179f18fffd095868b2eb31c8ae7c1f6fe14375ed1b72296d53beee55380af257c9596fcc1fedbdad3a0013e20655c72f8b336b19276e500fb3051c8c165d27f64dd0b244f7a88a0a0651fe0c09be02dd56b6b622fd6b43b02b39966384511302a1b6ef2237d840803a4d386326b9b3f01b470e855d32ed05cc9bfa2899be49e68c8f7ede4950f02314ba269f00d5073c465eba1ae007d4f58864872051e381879a0ea09702346d68c9c24448b7b0bddb994078d3cf1a05bdf2b7e775f436c18d8bf80a948624a14cc7be838245d361c01697ba9b89653993032689089bde46919d659855adbec38fc86f94283ac0e5c5de53ee4e7df64532cbc7fe5d2e1610760420581c265317bde805824ac0f684688fabf1049d7bc91075e3e86409e65e858e221349b087826012ac5bfa9bd7492b69e6d1222c3bda31882843418b37c95ead9e18858d2945816cdf1846353ea658286c701319d1995abe76ea661022f246324a09cc366cde0ed5e62ca72bd4b940210c4effffe6e8e13378a1487ebb3175b7380b9343ff8e2421668beef5ffb4363adc5d432bc9b99cb4f1af57fd93b0671f24882355122c78039a48d4f9ba74ad24e15cc96b2022a3a28b1ec9cd019d11d5a7b907556b29bdaa2f8dcf3426a467bf31c4cee8606f7135aa7ed611facfa95e49fd2ac89ba3c3526da7d2ef7396299ad88250d8351345ae0b34eb80c15db39d3e63d3b60262ca09e23cc906156a6e7f00c1ee208b3fc63ddfd36fec927fe2b09a4544546f2755dcb8f4d250e83c13d2fae50525426d449c0b991af39149dcefbd189d25d11d5460238fb3dd73d5cfabb9e592e5845122550e399c33df9fca0f101800bb5e267ba0ff5394912fe807744d25ab72afabd2e48369152c49abece9c04c89dad91861153bf4876b3bf6825b00b4b20a6f9b94bfa2b1fc7ecc236387f2b3664b7608346e271d8d8431ac7e5e46309f63450ba7b32f9ab042579a6d395fe41131d67e5fd96589f8edd935668985fc894687f21390f04d25de8ac6ae38b21c805e1b6be00d36b7cca7f0e6a51c568ac0717873e1c865b56605986f1c317b1e1a72dffba231032901a49944a51c06ef4349c24786feeae5d777a492223e4df1ec02f9cafacfb23748a11420da6c18ef38ae8ebd60480861f800e3ba0549ea5d248b93c34b8fe19d6fccb755bb2798c92ad3bd26b3d8c4d89f36a4c412f4d3346a4dfe801f6b98f633ba345e8549625ff0ca9f5578ba5d2ddd773219c8125313df65058c8e2e67b52e2a6eab59e5e23d73dfebf8fa497d5d5ea3acbc755e894d1cbc866e993a8ef31452dbde6982770713efa61e287b72098204910946c864d55841121bbde4d718ffd2c19241649a1c066b3095adfbf57b1dc554e50b2ffd036d738102f420db2b94e6a6a1dd2085004df150d793fa5edb14c9d5f4d3ecaa718929534e2ee0afb3f79d3e06ed5d877650971a14071af42725b898a63e4faf3f48454f622a7be517d421118aa731a3c07b87196badb8a16b79395e9211f1391b42b7e50b831fef178ec0728942d2045275e0a6ac0c6224bc7dc2e0213c11274f6ad41474d566afad239314aec845b5e0da1cb908232693aa9949a69f225d5b23a3148cac497f2ebbc0581f288b356d7c5ef8779bddf28e2e29896267861b0dc00454c2f3a335e21ecdd9581a0eac8a3e2a11327c35b47ca4831ab44374f01cf9dee4a73d28cd55a3b0e6fac5b97344b4df404040aa1a81c947fa8980b5fa5741b8763e5f96ce436df9890c9504d1212963ef2b2b24e27d825734721eb32ba134b36dbc99b134b969825a0d2b531f585cde91cd1566cd2b28b03f3611e30c004958bfa30a1240a95673d08d59705cc21f4e3b682a9c1cab4f2288e28c3bdaaf2c3af6cdc9950befd2910665805891858182bfd1fd7d65f1aac3f684839d96f0b80b00407dcb40a770fa6f5c46c1c635e6f21d115c844c39c3c4e39a57ac51b8a85d156e1fc49d9a256343151a1d826d4ab79e2b40e764bf9a0013f2919262b466750daa0732803fd0c217d8b3a770a3d978b31f8de81bb7286afaa5b6531225e897e1185cd8dcd77a40ffb1468bb72861d1a728b0a735d89f9c55c282abdcf50b9a0cf4be9ecfb10355d1a2237577bc44c342776a80a320b188f8b9097d7dabfd31ab972a2fce1addb926e45f671402ab1f15aace0588de492a6fffadb94d6b4330db67f4b551538c06672c86d7bdc7806716c367b60c523814e4d7ed65dc9c6aeb344771d84ca99f194d723d3d85ef7bf6a7296f5ca97edd04b579b7133989539688f705f2125fabb73bc5d97da9a30e0686b7c7a0867db8f83fec29113a5423958f9de924751fce1947394f47c76b2978685f19fa1800e543ee48ad4d6dd26c164a6fe611b7ac432327a2741e7a3ab9b7d4140fbbabc3d01503ebab8985a16785a4e6b6019b541781e792c61eb6505a6ccdbb137a234e32b6156b6410753981d788654d92c8784211098cc37096b4d43a238679ecf6a8f185ce61796e7ed531ff8763183559ddde4f34fff75e6b217801eda3bbb962fe5ba81c28956ce725d810044120b4b241a9936ef09d8e43548a440463723660eccce6fcd7065a8be05f843b099ca3a026874ca30958c970d43af329be84a36d6ceac012d449080e5e62860eff5d95d359515610b766c6e350892111d236e0fcd5290d0eaa9225ebea2f8a20157ba8382e3736118491e3ea743e2c12fbd250920b8ec33e7f8338058845ea871b53967bc7328f0bd36c0e84921202bd7fedbf1b5f973f22cd706fb26dc689c261bd1f7c85b7cca47390fa38b3db16890e04ad4fe73eaa09f8b3c50fad235ea1097bf329662f1c8b7fc91a85aeac2db524d132ccd38dab84c869f80ef7c03120b85a04c0d243d83ab14d21dae037e8a9b6750f3686cfa1ff4595a5468adaa5f76b566ce85703b2f8a0d0ab7ba47d5918f32b093896dacaa4a666754c3fc8cc1ee1bbe858b6f1c9e30c8c90265a2038a9c7278dc2d5d90ecb545cfb64bd27dc61edd47099de7194e416dad7c384ed2b115c6b122c141b83999da8eedb13abd80f4317c5b5ae036a358878027de0436debfc7014c659f9bd350f2fd2f811b3c9c695a5db2525877f999286ef158d4ce0cab96de5d909224a982448fdf3f58f7f5209be0e7a42e3db23ef576ec62bd5274af81fb2c09eab12d7f56ef3ea0a9a6d98f0b51b01b4e401a47a02a02154bd0ab85c615827def226b4c41ca343a3e795e32efd9c241c6d6297c9e0808dc5ce83d18f88322c44175b58ef20a70e02a34eda4f2339f0c6be391fd5bb34cd4f2850f7ee309e2bf8db66f2a108344ac6fff6b413710f7900b2afc886a56d5b006a90952a5dd7677ccb67768de5acda34ece86135cef4d91bc6fe53430643ca7157ddcaba22c09a6e9092cc1907b2b3beb288f1f789fb0f7dcd8b4c5d3bd72964e31f45247b7d7dd909eb9add2b3a13b7622a0cc1c0b484b48b93bfa3402b64de0c19dd6f13c86f2fe3eb9a5b4cf651345d850c620e984350378130342f53f95f1cc1707fdef2d978c2d6adf68bc15f27ee31b2a4a14e066c2775874c5be4b9c5a17c27515533b05ca6c50365aa28f019bedecd0b4764ed96383ae3887582220f7e9ef4e338aa6ce2398eb191fd4abcf761384fbc95f4d212ce8daf70002af276fdd7f2c192d5c52ea19f4fcc58b4fcea9c611d62f628a68f532d06f1dff665e2a8d4bb9586c8102c6ce2a68754e01557a229ade31b9e070392babe3a56a869aed13a8ce8ed47124364d24e678a8148aa358c6ac91429ab386d0183afa943434a052c41334a09479959e901b25befb1bc901bba4cca7daca5b385386e41e384b6987ee0d288585a7819f548e6ed9b6ac7f1582eddfa8029a40d8d4988d016a07e8c22e2793372263ef0bf3e2bc414d651e5138f56ab72873c48088926199a2d357782054ac05e8508a082e0ca07fc709ade7a4761be1da1ece5bc89adab42596b3a1d98231a168bbb31f5fa26f3644a838ef02ef4cc59663d2fa06b95eb81adbee97810a58010f5c49ed9047a8101f741ab0fc12d706d9437d472449df419b40093d9cd8dbd34883ed99853b9e8c59887b39b3ac282ce272aea5b54393e987477fc6c459197680124d2dfbddf5f0b5e068e4c259d277ec4bb0e4bea49ab952de2906569918c97335d8381056424335641888730081eabbbf480d2881a0352f8b7d50bb9eb10e6eb98b818a069b9be1187d75570332c958188a02578d48f336286b203892740b6b15f7430cfa59e7247e96768e9e812091ad5b60bebed3d609c0e85f728f1b253699b34b29382dd1b7c42321da66205e69b8274f7f21ccb9f1faab74d35546bb58f4cba6fafeb9a59dbbc9c1f9daa999cfe510d6276b7d50c9200fce6f39a0eb65bf2784826b8a35670a5b9a16368daaca298ee443350b6fe3839895d5d66b9c341ea418fb08fba557424661b44b7d64cfe170ce609ec338327ffb48478cca175e9f67a5de95c3b826fd88fc4365f1230deb28034840ef6490162c98c894c7057341a5bdc69a21beb50548fd1625637e8137a1aba6c06be119e6d9e5986a3cbd8a485d8ec96e3c03a7a854e4892c8c2b49624ff7daa3904c82dbacb70de90eeb1ed966651225e5a3ba1f8d8be37874fdf6c8a673f144900fbe4a68423a7b88df3d97695ca82e3386b4bed4572c8e1fdd31798713643820d24618fca9b3db66daecbab36120db891a5713ebbb5b0da5639f80c08f03c300ecfd0264d52953ebc5635a9b43d881ef62e4c37620dd42edb624edea5ee7e628164912c93f49fe797b9fa412029151bb226c7b4a575e40d021ab31a2e1acead5fc3030dc52d1b67860deda0222896e287d5332fed2e1ee8e786286c93e373d3c7ef7e6308527d9178fa44071dff3905a560f5b0e04dab0d52c43c01ef45f3d0976b0bf09e11759a62867ae95a6fadbba8b41417ce0bbe63433904d9b8357a5cae20b9badbfeb912be61a98e77e8e8a869a77857524630e9babb76adbbf248b433775a72caf4b8b0ff0a1a1a05620a92d34bed2238cd15ce403683ef15120eed1eb645147971161522c68637cfad2e6856bdbf86452be8928fd911fe6f24a5dcd20d4a381cdf576a5c4c4a20ea4bfba4f557ebaa40dc0141b42fd6b992d8526b11d6debdb547ce6e69b637c7c041ddf45eec13ece830de38e97d6c77c9f651ca1b03d13adf9d4510e54faf839644bde7e9272b18b2fb231493a8e628826985b7735159f2eb845d37abe31b96fa934964fd2e3bf221865ec29eb2ab7a771c24ce6d2c53259a14bf5e02bb217603319006f48e6e2dc9e7d0ce82d3fd1ee3dc3542be9576bfffd101023348f45d311ed07e74e2d45905d0265a62b192988b99b29019ef381db5aa999858620a21077c94cbeb4c84d389eabeb096fd3fc1be158a369e800c12239682ed5e4081863f591f2aca08e91faca0c4385d65d8e37a36918ec7a6832d866121c6772a5734ed2f0509d800a9e275105debaf99bde069cd1b47695f57327532990ad5d59a0d898f313103228ad1bd8b3fe658dab4a5d2516db7ac3ff66cd32dd30a69fa32bda4be400c6b71efd0b37e0284eeddd07b454fdc8bcb39b1559a82280a18d2f52f804c45e62647d9d0adf692db9d10476b140d6ccd36eebd4eac883b9b6bcf199cf31b4be3694d5d0a05be83d161f667e658ea026c661878119fd0f13135b14f3c0617f2279d21d01ac8cb2a383fbde2cd2f1f38883b2facb2db8a1a80feeef88e522e87fff0d0b90a5bbca08b5f0fb47d8684b83b38c4a07cec7e663449449977e6c9a11f5b19639394948b79c156cde8f41ecef9d939c026756d3b47520d9d1a678bc0919640830eff0d95f356fa6aec3da331af8ef6b62df1d49034ef7577da94d938fe78485a6917a756881da4701656963c4a99194ae5d83eff3dc725b93150308277b5211f7046202abd166ebcbd085235c80a38d7ef29d415eb0d4064c0bda2b101bbb69079255788f0c7522acb76e352b4d46b711d6028eedb031c0bc033a368ac00a63de64da3f86c01b53207a30058d178358425e4c4e7a3a476ef13b0353134b68d9833a4f0f516d15d42b1cde1f946317a17641dc73bb40282efc0daa2780dc7e6220ae262a1c91464c53b3542c403e475e1235a26cc45a41ce9ad932618e1f694931a650483fda1753a41ace857732fec7db4ccf8517a29bf339178cbe6ebf4df23313c02e4f1779041da979bbb1f77a8c5a083f0e23ad6493b9ca26031a924125b306a372f1d2d6dbbec637464fd68e385f1bfe354daccc544ec3e7badb6a2a2cc6adfc025a0909ff1e0f3dd4a4d8cd0412f0f175608314aeb5f4e0ee1ee60f75d33310ada91aa35340baf242e4b83ebbc4b7802bb0773f5a54c2d92f5172a913e15d9d5cc06a1a55b0d1ea1de3ae7ce212195ad8e9779f0aa718a333710db65ba34a700c4a23a48fcd004d35f6c8d856a5833f2bfdf4702883d7e974e90bab8833fffcc3ed71c28953453edd05759a5649da8f1c4b810e321f42282d04886bcd3a1b024556b7623c65c58a9e2ee82ab47020e11bcddd71a6e17c925550d76d2be073f16c38a90afe19934117cb4c39c9124d8217d585c49309639b1990dedb7fd0fa8e6b9d16a4583aab7b9343e2e6b6d8f387e6b3ca14719e732a0bc8c02868cbaa5798df88cce77bee540e068c26250384f6f46e1acd3ffac24c35ba3b2403ef5d4e4d12da3ceec24a3da6ba2fe6dcd70a69ec3f73cfb7ff7a8f7ac216079a0ee088f81ded0d645b14bdc27aaf68e0dd42af41e2f0114a42a863aa02c2c22e591ca7f29ac0e72bdd09a5e9027e5c4919d82616b39b5b46dcee86f2604649e7390248a7fcec607fcb8e6824293abd331e5fc5f0f4f10af9bbb44bfd72e347b3b2385887d26f32c8d46688b14b09e701339306581d85eef2e68399eadea9fb6f617b8408ddae30ec43be17d75fc19d18e00e8892c86abc76ade147a61cf264c564c85e62ab89447eb0ea67821510e2efecca887a032f3077edb71c8e5630178f3809f2410e0b879460972a906277552b46e2db45d595acfeaf0156fad3e25d964e1eea8fb5a47cf4f83da10fd05e5a8f62df041c110fb91acaa63542fc519ef4e5129b799e901027f8c88c3449415af4358b499e25e77f172a1a1d6b5e7238e63b7c6c9d7e6afdec37c101d493ab08c13466442c310cb0398c62c84d6948ebcc8f1464188c60ab5d52f31dc5e844bb2fabc0e056b5006c373509554f61507ad56a5d539ef2feab4d2f7cf63f59362ed7ea8818f3ad687661c67e8b98c524cb7515a034ffd54b1d9b9d2384e082e5ee231bda76424fad6214a33d4722ec392d227b7163d050919e800fe8671a2735a78af3a529c630eab99a7ca63656a3e7d42fbc1129921bf09662ab37708c4d7d84c1de45fb2fbb96737270287b4e952b99d907e6494a3b08b3dcecbab9a34c64f862ec4d8863a37026493016ed4d1e61637c26a7a84b242d247d0c0c1751a23aedaa5373d458bd67a75164680105c8cd0973f890ecedef5f8021285040031f4e82bba63498d4af380148eeb1ebb30f858a0a8c4007001d7f539a62993ce23c239aca3e930b0be0491d0eda5a988d0c0a5d7193b776e8f93e1cde4da3a95b64691286fe2662773d330812da83ce4dee3ead0e245c357011128da507fcb12a8cab56405fa4a5399b100651c239203cf72679585c7c3d072ce6585d4c816dc23787e713334d6d293d07ab5e2222aac242dd7a973cb609f514ce22fbf21b7c4f48c2b6e58dd19072ee95baf4e0efda1f79ed039b16711bc41b56b485318d752edee77d5763d1349a8cca5bb75a5b5d5c0e76dd5fe640814eaa9bc05d14cb646cd1375b9a2df78c3838567c1e91652733e77dd998c26d45c3291b72c3377b1492c20bbacd65d7782c9aa99692da209f91bbc47d7fbc220ea931a0308dfbf91ff9af900ce4bbb95d20a731e61029cb0a9265b353f87a3ff2e7f3af4fb6349dfaa5d8d8ffa267df20bd4d3355b89870b0e6851c6eae191f07387f3ce0a0c4b4f5ae07d2c8d9acf214cc7cb2706641c8bc4c0615d212ea04c5a9f906579ecd1be893b1ad361a855c0ebac945f95b309b717bae57900c973fc3e7737a8173183a9a59be5026c9cbf56549946c4566c8c51d3cf2301e522148f6f4ce276d2fc1c5b0e15856e083e9f2f57ac7cadadddde8c1eeb48b370c9f62be2acbcd2d3cebd4734aaca281914872da3b3d9a3c9def8e68d61134a4b2fa1f6dc8ba7e694141b648aae004e4e0acbeb500d0365bb600a4f40939ad55a4f6ebd1796e601d167ed12d6bbfdd72a86d1e6104e4d65c96a4b1203a022228091332f6d5f5fc8f4076e3fb7d56299ea2fb84eedb2d552e93fd33931f64c38acf09253a56a2ce110cac0bca527f3fb12aac05d8999be7a56ab550b17ce707dc9f6ac90748745a93c518d9b4258372ad17a496fdd48077a68654f9f26040cd662b1294f8e9c17f298bf4abd9a490db595498a34792f69e8f794e04a575018e25f0126583ee39fd6f1bab095e8cea99c902de1f30734db62e3601bf9b60636ecb781abb6ca8bcfc375a3eeefa839931c99e7aab09cc78b4a63b8b75bc3891bcabf699cd2245c957142f1d490a8faabd530b24bec9d0252e5dbefe9e5f3e72287873d5c9c584b27de65df3d6f008a2d7a000f53099c28613ce67a40353d79aada0e4293104f3ae6c80452b8e4c3c498bfcd50578685570c842fe8c5593c5b1e7e6546ee97af3983644cd483f8261e623739966dd492f3c44140e0fa2ba32f64c010eadcf971938e042522c1a7d205f72704f40eae91ffbeb224cf255608da04a05e10555c69fd269cf01e8476ce60b7baca00d421e44a07b25738460b2b3a20380f6962997a8a458cc5c2c2a1153c0c4b45df41e6ab1a54501e8869ae80ac3629bd9e09598afc1ec4535a0e0e45a3403e1178d7e9f4ce938bb07cdd33efcacae43ae109fc54baf437cdba57005319cb7a4c5bafee56f9593b0aba70e840d2d232de4636b6bcbc379e0ceb71a490207918f087656ec61a711cf1f71428c9dba209b5ca307de376e0682fa85937f6b1fa96d6dc275cd599c0517455f031e172d6410c394e0531d609ef2051dd01ed692e7e86230bb0f2e1a17ea373ab9d3e6fe71148feb550bff73d17734e767429772a5a1e3702db35732e75ca3db8ef128090b3109ebf346d01a5ee3db60c17166cf6a1b464f6ec0ef713a4a95fdf37327a9138cf070b26ede39373b5bb4270f401eb4b17af69a5bf78f5a691e76171d1e7db980732bad88e72da7e182525dc42c67219fb35177863c9b9d6faf803d85be063630c08f9b86ec623fa19c24a2372e28e5296b2cc145959b6c3fb478417a4f87dd3e771e032b482b44e9d47e365d0251560cc1ae8d629bed0194279a1b97039dc4c86cedf6b54ec69691069ab67b0ff67814233d591e765d18938ad009acb788a2f485d0ca42789e3869a302a528a49052ace6163a96a411d7da5bfe08bae31bd0871e9b1c23fb857fc81e8aeef91ed352bd9946b6696cacc9c15c09ab17d9d8f5a0ef1f775ef9091625d2fdf7055e56f3663b65f4762b7bffcb8cf8261383fd6b0cd3c2c90b37600163d38b4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
