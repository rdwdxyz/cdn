<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ac5bdf5833a2f8a336437cbca924b29007d8fea9f1e2c7df335de407adb8f138ab1a483014ff304e4b8689085e4577bc95a614fae371b311e1b68e0acfe761d35130e02766717b60b2cb7dc3f68e6b73e37fa184ec881c45593a76734f78ecaae1d9f99e32600f230dc2feafd5f65142da9d0a4e39249db7ed76b989250d22feee2494640e0e175ee71ae8fbab11061dee2aa5e6ab2f1a6405d06c3a2648c295dcb7aca76625988f32a824c5423c91a5f8616377a0e088463475b3f10eafacd639b4ae338eb7f9991dd2cccd4a19a8e43f9531cab9e195d1890d7b64a154ddbdee8a0c798f041c12faedb56e7149e5fed609a492afcf86e3ee787e0de84c184590e29291990610a09c744cfe84dbd7171923577dc488c0a36623ffeb7e0a1edb1b30399718015b9d04e0c10be980d27f210f45278ad58737d8635d21138162f7209642b312059771a6f374651cb82fe1e8dc84615823c4aa11f7497b8949c6b31d6e5123882290b2610c4543d32d5bfdaaa87291bde3d6beb983dfe0c22742bfd6460202ca2db09bc2e32240debc461d8ee26c7ea920521238691c4b131fec6589558793574ef675fd1a92375da1b961326a59ee3ab1373039c5c6ea3e47926334451cd1a2ff9a4cb5c2a841e82a22f861e6fbb5b30db4248d8ba8994617b3b21ba2f28b88f2ddcbe7924e21910396fb3d4363281afbcf4e2eca45e1529e61182ccfd4c1033dcf051b8a69b1568f7b86f5fa9b5ee11b91137b18add28d7788190b02e8d768359434545d023c4ede62925bfd85e495729b2a5c91c659e01496d9cf617745f4f72207fe8745702d1052c9479d39bc5a05a83be6564db8548cd315c8c82ff14a4d8d141bd180508950c6c753676665a4f7b8213fc9cb00cbe3cd7309120046aab20cdc09eb7011e02ca92af14d75a913dec5b36e1fcf60bc41e7854ca3d2a9823cbf2e6a5d5d5f3722f4810390137d9225ee6b0d4a1738a7241a07d7f57b0c7df6b61be19088324da36588ad0e7add1799b63862757752314df2a371938f82b4a067021aa19dd3f11192865ff900ae121c6f4dd88af66efe21be3b0582aea8c607c8a59eff61228296ad6adbc9aae943fcadb18c03ae7a172b4e34b69ed398fe37dd1e19e198fe39cb69257498fa60c7674bcbf5a2f8d4ea0d461dd74da008c595d8adbe71d5684b900429c09b5a2497b60ab7a08f8922a75a1fb08107d44cbe1b88161fec0846cfc0fef3db2e85dd48e8c5b108fb3e27fba9e721bc88357943d04d682f951265bcbe741b695e660e480b84d8372e0239b16234cf12091d65ed4889ec8f14ad1151e4eac75249a63ea12834fd0791c38d56731d2183d1c5c11c912dfce05990227aa36f17f15aa73ba10f97c426c56017a2daaf2edc251c69e82edc4153c715750d9d157e37b419c0cca274c8fd8b1a9df8f350e4b384aa1378f52443b3c29cd802397350cf2e659ff184f770c20d5e14ef5ec794a633e6b4e45024176fea441b77d5ae5487a89ad55692510932b3d3170256fb6878e240a6cb9ac6894a5a80fb187b5e73d1683bf1005c193e959d16b185f6d34beb19f0554a754a7a5426096f0c2b6bfdd2d46d9e69cff5b8885c732cd36158542c4736b00fd71675a6d5d0af7d447e1debf038861653cf4e122aa5539839f3b3262cf112ab2fa6e6cb0a519f4a3a57117db698ab3171dadf803722f04f7af182ff4c4a3249780030936488994e2cf4a4c248bea8725e4898e1050382fd7b1bbdf1c93fdc871c67808dd83cdd77bd5802321280af7485fb05d091a695bff46d59827d213d9179e8cc518ea6261d3e7e5d1e3e0fabfecc217cd5a93eb754a4263ff4065b04e912e86f167d5215b48ab7e6aa1a7aff4541122e0445238a08b165b4f4a945be80fd683c26fd5f1c846a2053b4dc4bb06b3830f0f223bf3196912f3f4c58b97195b86a8b66a72d72ef60f2c35d07894a91eb027e139507d3d1d01d4bf918819c4e873a6d2f8eb283f5d4f25367341a246f64e39d714a05fb5617c086a3cfa7fdd9a4e68d5a3fd7071274ae159be178e1f8ff99490f1536dfc66e82b765dbdf9a47054f14bb7a1efdc4e65b5f124efefee5b216daa4c905bec45ca03be73b886239b35935ce82b228a19fe5e470c6c80580b357b46e3ec63f3cf73ec622608a74a2ad6f1c09bc51e2d70a1c29bba41f48548f9a828195f372f2c5d5d1d6bb68b6ff60f606651f8aef8968d4f75d229a763bff621e2f0868be653855f3dbf6e78fc3533ea63932b00390427cffd6c7563f14ffcd56a7ab1c7791cdcff36da7872387d89db1dbc5b7e1d98dbdef84a8e87d15918f01689ff97c282f11f6e22f4d923d1b0e0d64f32033e6b40aa24cb383640d04f0568b859175787911f16f51a5a2d9d9804ba794e311a1ec0173b023b7771b91e020352e70ef70b09bcd655b4af22bb264d58b7eb478ed737acda40ce2fd1acce1e36dcc1c89bdd91dc4d553d978f1ee5c512f0c8214ac23b32011efdcdeb9a962f2acbf910125f103f41b9bd84faaf8d4b542164a34669075f5637c49496a967321df0c18bc463b41f0c20cc3ca08bac24337ec979e20759b73ad5c3763fad1abf63f842359e42b5383d4e56cbd060db26d283851fce9a88d7129ffcd2430539cfee80ba6ef31c4ee7144bf3d6e3640e3bb55dd5398a69e79276ec7b8a988ed45a9b514ed7a38ea0b8336c6fc6a79a8308bf33945096ee1315e94ebb5b18384b142f6b5646baa48cc2b729ab1fd937cdc0690ba38d1172b5ae7281a2882f407557f6f0ffcd456eebb3eff62be61a97d785ddcef508bff59982ab7aa98da270c98dfdbaac62d783f8dcadd74283bcf2f2b4273ece8c4d53af80e38147439703f836b502902116846bee313bfde1f28883a6c13fd7f6d75bad319fad5c940ac72efd4d5ab95b7f4109bde99a2d1f2dcee7a65edc99059f4bcea0c594111331786a43a7268a0a43a73b58b122a3365906734b63272d4b86314c13aed326eccf8fc6b3d6dba4a3748af22e2dc8caae782a2a18cc9a1baf72fef0f1be2b4fff252942323d076f0cfca98822ddaa8ceb83e744955db505ac25256f8e2c8daa9b6a4db282c64dd83173d351c7b3c0de84756e8916d1e84559fa8899e5d2989e182277712961f3c13b0a2c5a3a09c6b34cf3513804bbd951d602ec7362b8c6e974df9f34e6f1c2b7a8c615aca20b0af7b48469e7270138e2ce244dd42100238a5a911e2e613d887e474535cd552cf43f1dadcfe8873682e7cef43f59987e528da8d2aa4566dc4d6df42102dac6d4818c5efa04b18fd8409cfbf6d349b8b59fe6b1076945f4963d2fec8170f9c442698024f51ea9bdba27aef9b9273563afbc552262a30577020ed044f2d237b4009c7ba7d0c2efb562905f0c3c8ddcd6fd87e0ca8689d4b67ccb2af4c431eb49c6d05fede32d31362f96bc665b250b8e5b7616fb287dd3dc422ba5f3311532fecc35c428d52aa5d9e26cef5a92ac24ae2087f364421270ed3efb2d4a13b8d30fed12039806bc070d1041f257ac94015ce200f12494558d045c87019df37d5ab0d23a6fc1972b2cb5a26b3e20fdb62e5f09f729425dffdfaf6b9acd73dc5d1b4fd1828cf6d03be3b80626cc0095cc01daa349f104d136cd2f33e3fd7451a37b346c8b393f8567c821e5264a4dbd3c311ca48ad19e4fd068dd4a8e673e84e449ba61dd761118099c47fdb3aaa43ba7b52c0c71e9eddd253ac238f0853a294c471389386bee7efc3b7a61c0b2d07da07549534b097f400b9ffd4b9013aaba13f8b1ede854da0521ebab2810319728391ef80059b15c41c0210c4c93fdf4b3307ab4676aee24e8565d18139f0c19b71d40cd25e9a206d0caf4fa32e864c46fbe563e72b8bf6243102c4ef240f637fbfe5c04f9dff238eb44c70cc1fb06e15a8e22e58eaa95a17fb16624f0de15fb76d7ee08057ce5e98be85aa627198ce3fa94d90ed8d844ae6f61c0452909f989242ff69d6624be90fb46157d7f75222d9c7005c5280ae634c4279be07e082d72c2530a1c63c37ba4d38652245e36a2585bd958b58e192519d72e6a874c8085d44a574d3b48a1ee3d0f7054a9ad146dd2e34e187889dd4cb42f711e8d610abc30cab3fdfe04b6c0492febe34e1035218cec931fbc143909a7048459cf4f0c88ba5f0f7f0cc175418d053c3c3590c5186d114a9763abcac849e5138d6948563eeaafb6d9c8a267342334f30764a7917313043ecf593c6936910a6ad83bb2b7cddee37a6d2eabc399156ff07471bfdc4f45c36dd54698b369aa5491430b860a29eecb02f36fc0679ee8bf45e2c566e416908d774ab726a2af6e32b95cf5930c627fd3e2c12cf3d5cbe08b26dca16e7342129b26524032c61e779b39e65d3680d67c2ab0283d23515ee09a8ece511e74030e49d4bed077bc788dbe3410e1c737e8d5e404331d3270f2e6899d83f93afe23751b514947b3d5f2fae81deed2e1432c6346f671aa5c6b459f0da9b2f3ddd21c6f7c7e3e144d298abcac9855e597c86f962e376b2fc3c0a3a882a88e4abd31b8c5282f6a14684a475989c24dba50cdc7b26d1954f3982af4d862fe00f544941f7b774c31b87aba247a5c5ed3305d92cfd9410cb740b359ce513f68df54754f607b71de2b7f4921817a0963321a6d1fce5625f43b0cc04ad134936635507b79381cd02aef565b353ecf77fed1d1a3ab01c1d204df5e9d0cda1017fa3ed925b6685073ceae50714ea81f4ac28dfd4438d354c5a8bada9f3a53e535b90079c0abddb55eb6b0db703bef8542afab33bbef5d11cedf499ed2273675c3c4b049edd0869198ddfed9bec26eae3e8c0ccc474802c1721bb86f1d1f2c437e433e19d822e75e2e61ad7771f06e5a5d1db479bd7ae09d70c072844e81c6d8d89ff0c29e0ad989bac4d58aaac2f28aaf5acce593721de365eaefb8552f0a402f7aa21cd134549994826408fd59a3eb0ae8406db3660d84580d7a4b4706dd62699800bba058a1afd71288e3c6b4d4c1d0f87137ee259d123ceb62f704172051ffe91e3e51d40d825a89fb4ac64023eb5e08510507a1dd08afc8e75b79d0fbd122351730e76e61a990e4d6c14010c98d6134d3989719c2df65731a6c8bc0481eb70b8bbdb7815d567d4ee08424e3c6efc9410e2d5900e007262dc08df38964953c9aab381fc513d69a1b4af9e6c22d81c0ba7963abc5208e6acc87ef1b0913638144703b9a358bd5292105c0cee32bd1e09fbe359c33a01d6e657d5441b0221ba07a8150ff8dd68facdfa650432225f092d675ba67b61d19261c71c2f3ecf378d99e4e719dd599c0a12208fd36c2c8c962a495bdbe89e2f7404b48770cbe3e52a7c344752aa7529d20f1ad3827987fc0e46fb4eec40cd75bfbcf729f21162753e6206c496c26db5e902d3fa416ff263474609a9200bea95212acd6e349d2557dc57345197fc5ef67d66cf44b8332feb4a3d6f1c87597adba27aad07a217bf8dabf13b43bb67fd17dfe90940ea4cd38ae8214c6c224eb7441fef9c084863e9e5d73d06c93ddf61e208314fb7ab9403bada807c6c48be579467b81814093b41fc1537766fc4af496d7a4de8867076501149d6a3cfcad30b6245760d04ad941cb41f1952275482cde57b3b45997ee0583395b2faa1f0080b8f90b595743d9c05f112bad7c61f8e50b85f10b9aa5100faf6b3b1235d7db249246dfc4d130362ba14d1bb54b3eda04193a2717bd93cea762fee550df1b7ba9fc24d0746cb4cfa6dc0a994e9943cefb24183ce44011d73464afcdfa35b83ef6ef9da7dc35f2181d5ffd8c28b9c8039a46dfea9fca11950fd4db38caee2c496fe137f1604a64dd127ed33e9d2a0ef22164cb5d26c3c62444f69e4acffeb5753ce1fe78ba145223b7e13001e01252e5eb6b141c89ab604d8773e6a5cc0aedc497bd5e9e7ca553fc9a87d66e5c478a50e3bed41eaf12bc8ac5edf41541cc62dcecdb42ddc21e3bdb402bbbeda1eeb2168a919265518faf0aaa9891eb1f6d69c459a0d75dc7ec01e3ae2fdf99ac6a64f9ba158888c9e412317a28dc1ee17ad6db0c194b3163b12fea327f30e1c50fcc54bdeed815cd352c420628d1380fec6e156d759fbe5f64cdfcf3608d4d190ae8da7c21f3499f841aacb7522ac18d76e1642993534e255c9a93ed63cbc5998432931c0abb9184137368d3571cb846716893c675ac752c067bc329c26ec4fc568e50aaa36996892b253fe70d3e1b69029b2e8d9d482fea639ea603856022e1d0ee64aef3866a7cacbbf61c53af62841ba8e535fbc5a273dabbcb89b69f733867f8c40aecd92a16662c0aa0396cca5cee506aab96146509da69cba7d1d467be3d2e8e05b9cec650c795c031308e15dbdeabb52d1700cd679c906d5c22a272203e6abd2aa70b55921853aed5f36a8a3274336e5d087078c14c9029b9c0404a4ea2113d6f4607b4196f5fba31cb0cf1965920b6306b323ed1174781812eb96e30f334682c88d9058546a1739f9666f6d7c6e371bf3480cbe37aa8b5c18c20269775feaf4e3bb91a0c9a8a0e3fa89a4767d0e62a53ed1d32e489be22be0979cd30c19fd9addefe68b18c5c8c364925a64d90d8f399d8577b56d8c9a6252fdfa100438217c42eb4b8d081382b3e2dc59fac0e2690c522faff5bd81aa01318b6356a3c5a20fb77afec74d360a37d5c8f1b9289f2614293f8afa2a7d291d6bf2bde9f71d6ca9882543424234dfd354b3cf42a23189b4dfbd1ad7dd4a574ebf069468183fd3c62668625a4669ca3c67b314a100bbf4ec90254d47e2c91c855dafd0dd62f4b84a2cba2395878bafe43a7b11d94c217830a554f2d2c7e9575ead6618937bed860fefe2f769dfe97da1488ac1fc785f4794da4ed3d12dbc1ae44d69dcb2893a0bb4ba04668fa9ad4602669bc1d5d7936aad33480256eeeb6fe1be950a4795e2743cb06d5946dab5988e854bd34b371ce5b1f59b343bcf2c66463550d4c7c9fd0c0dc28c860b090dd5799c30851f6b0a52b0bf3d1cef5cbb66935315bcd07097a539f9894b7b5acde5f9403a838d855623eca270a646d606764adb34b75a96be2208acc4593abf8c08682cba92f9217f66076b704fcf37611c1cd2f9a4f67d570cb07f6ee6bf40899b345ff20781c2258af82f5f7f08b8e71a51fd79da705c4c17bc6def1e303dd73a6b616e550372e52c7841d7a6625d188d0cc30baacce5996ea14d473dd0b277612797ead7439ae02ccfaa184443cccd18b406e46c4dedc6da2bd681d2443be683b73d570be74cb19676f2305f76670181a848822a009450214c0184ac4f3183faf567e18e431880ffd690c6396f8158a5e32465f7f37d81ba71d83e875fc403651c232bd91dba7db646d85d842ebba863becc4f874935545259cdb4fd8c7c1429b3f48724ff58a64abeb2a4484b4242571ee28acffd2a2a4046001c90c6346ee65804a8af3022b54e54ca798506059b2b147c60bba73ca08a022836ceed0b38aa57e62e052f264b611ae161b63f8663a1e95f33ef48d27c6abb80d0dbcc9505778f67db41e7e1e9175f0ddedc94f9084fb22ae887b423d11a4229838d82b677e35366a3dfba619056a2e6b4d1b6b6ae4f4f239284496c9d97b0c7cc5e473e4317f7397103d200791d777be44d52a009ee6b4c3ef5aab95e1e8b796caf1dc486db2d59d2aa8adabdd05e8a3669640016ff07eafa19500d2ec7ae0653ba64d5a20ed4af60b9cefea87965170f8a0437113cb2b08b7a4677d292711da7adfc6fc799af0c5739cfd77f5126e9bd37eaa30853e395d59bd432cee37fbcbe793aa2e03779cda90c51cb768ff245198c4778c32dd1b3d9c7f93e8339164075f16d2dec9dd12dc8a3f64ee2bf22912d2ce02144d01f2c9525bbeda0886c1f1d649daff1057edb80d847178e081c306092753730e5395af070be57f00bd51064e648bd37caa5b4db5bba8606986408ad7bd61fa594e9258d75abbfc4d9d7fbb66ca8584c2d1ab01401e1e31da6e1c822036f23dfd905d4d32014d89587475e2fda63c0099126b0a3d3fb9292f0d4ec082bf7f3f8177c07d1cef9f2e8eb4831c9f85a1036f59a35f73e3d2b7fde7b0ad4991a55d6dc8a07f558818fc6aa6bf19da2225a1fe4b5f123af31181a35da24aacf5bb1de01ce2575b7581fa0472fea7aa165238c1f184a6f962277202f2b90d374c3dc5eefeabc0a34ac183e6fbe5cb7162a74b18af78b653a35187db6b249213cc488e41594d6bb73980268e986bca0d6f7aa2b457e49ded450f810ad74dd8adbb935b560e9bbdbe82776e9d37879e4db2a6fb067f4b5c04c40eba0e717a20aa713f51130f68943702b99199bf95fdd08a8e4a071a6f0eb09acf0fc1fd615450a6f8e01bbaa49ae921482246c04f25f418bf943cab16e631b3d2aa54092c3269d0d0bd754c35d13acce8b65682810d5ceff8c001410f71e890380bcf1cc651844371d34556683b0d3e8cc564aa48c5cb20581bc8a252604a113f145df91d15dbd593bd6f825f300d7b64e77515984db06b526b212aabdb98b07261e72e7bae1917b6dd3140a0e9887b741b8c81e3b81f4bd6bebb7502255959a24a42c08e12d3b294c6c0eb73b792218eb7e0818926aae2cd7f27296244c09698984a421658dafe361e0d81c7d72a6f8865e59c6f23df79c245a3bdcb37c9f6d41dd4bffbb6282f4ad69353bb043ddbdf7c010b7cd83fcb50180cf0e53d6a4571e31a14b5776c7a5917d780ab258866605c46c8be9c0f511e035576417f3a36f17119197905b010ef1823392cbcd150d1fcb0fc125f361f15ea23e11bdfe41de91e9c4350ce46e136d3019046e0503b6f5c29f4d0bb70892b750e8abbe3d22fede2ee272677b8ac54226938009e91bed50b11147d1a7cce236ce30018d689e1c2dd6788abf44ba63523da5305d81588846c49948a315686143622d346ba1d1158660956e4908e3fbabd39b5d59d2988d88f6b863982536bdb2463ed7a60e27d87dec45f33a1571985828d3b6b28d7d4120497caa6355a2214ee9a28e767d43a0223f2c58b055b1f9ad1e6bd623049ce4dc4b3becaf32bf554ec034a7b07eea0e5757d12ade59ec7cb5161b6223434a8b061b423ae6e037ef00e89e1ffe79a90b5bb6b0c33470c0ae0fa909bc5cec5f934f392a84125ad742f5d18775c27c5ccbf0fe212a0049d4e504a436e80b69e1ad0b12829c0cb6646797a781267df165c63308fefbf09a15ded6837c5364e656db9677da94b48286dec7ad8914690c13060f09f442242d9c81571636caa06bf85f769ccd6a7ae3c5688eda41dbfbfb2a40d975a25ca8fb34ef69e6e09caa40c9ccc608ecc37abb2e0133180fb1889072f9869a594d498748fbb7597ca85cb21d1d2a9f3e1324276ae846a002e1d8b561c092cbdbe0e41d8b9b2b0b789f4835c6195c3158f9e7394f8c5472381b81b4179fdba715455c8d23f9fe8b94d067eaef34e361f141d4af77fe05a8b7f73e7e1e30aba2894fec5d1a5342fb1841f3220ae79f2ea9917e1788d1c86226bc76eeb774ed63d24b3a7780b8e18adeaff1a8b1e2162b5c333172d4064fb1ee32d5d40e7a7075e0203e1167cd5e7620224ba1e8c43ba915570d63b426bb44a10b10739c1ce2ce13d24104baf0feb5097f262fd0ea92d75d9af9707815c63e1a1fb8b0e86dba6816419d8b047305ee22fbf3493f71a76a35514c1b6cdebefe5f7f87f015067e13d7a7fc9af3f2194b0d38efd0505447b08fdfeea083000af66baf3aa07ac5c7d6f06a6dffb2acaff6d1ccd3c444528f52a9cf694d35b369bd1150d4d88f429179d81671203d30875f364106d4a07012cef520b551da067e9676afb137ccd80465ad5cf13a69bf026ac823ade7842741804e06612bfc83a9654d0108464d93b956169aceb4755fa28ce7c773b2f90d6f80d328bb6e156996db5098a5373b22cec126f16108abe8c2fb33adbb949ffe48a1d37033cb16e96160b9a362d02c39751aa8cc662e06b367193b89adfbb017cf38ee0134e969fea3f682f4551ffbdf2c482f2012823a3f48a8e7ce76a1af28a1e59d3b1d45c9ec803a43313e220adc0bd5fc55a69c9d3acfc2617c12d808e116ade460f99c27c3a7a661a3d8241737498c0aa84b2957538aebd22673dcb21bace9022d8d7631c716504159f6a70b70cdb2d5470773dab2004b7e30280f837fda9f7011c19dfcf74c771d37557ba4f68aa637710f310b33a440df7f014bbc665e8d4cf4d36fcec752729c4e5b173e229ad934599ee62f6f6c0141adab9fdccc7d293729ff705a2bf3292016d1b6d8ecb02b6e8756bc6b4838b060f8f6d88eb2fd56cd7c5325f08b185493352b96af2ebe276aa4968202dccbefced36fd9cd07f87673918ba227b0e8ed55322faf9f28020719255506fa1927a9498081220e2cb255cc86eda4573295a0338bc8781e392129faa710414d6dfd3ef00238e7eebbf36e17084f545aac399f0e73dde83bb1af709b035f88b57a3c5e56c4a08328a63534b929abe17de4a765ab403276e629430145948970ced8c98c49d1bb59ab8f198ccf2310ee1feea1cdd35a1f0fe65ed619e9a347673e4e232ce8474ac98c918be2ead64c25a38db30ab45dc1c8a40fba1c6e32bdf0f6a73c5254afa7182f8175cfd4ebbcd32fd31e7c4e3d6c92ca1452215bb3b9870c7bf7309b2ba8f5043a516ffb62e47dd6900998f366cdf124a0c4351062f1cc6d95399fcc1585a079223a3730d112299e973fc34f2ef387cd0a15c71658420b92ab8358768d971c7ab1cd18d226cec9129ecde71171fd85ebef030566d7660151b8efc487e8d37649d1c3e6b9a4c29958145805cee362bd76a91e71032b7e0ac829f71a0743b262d2acea1006aa2203623ab6640e55f2071f156f063ac135b9f6924bb0d6dc2fe813b1839fda76e907de6ed06e543fdaa23d7e7bb884d1c65eb1a4a0a49e82bc00b5e258de5d13d11834f65dffc03028fddbd4db134377ec1c7dd1d1fd998a9ad88a496306c3052e4a51b87fb34bb479eaa82e20698097e283d07e7ff39d63e3bf3d411b727d36bdce1e0a9eff258ccedb3dd2a9fe7e647666295cf27828abf4a60fcdd1c2f479dabded715cd25cd2acfa1aae24cf933a32c132fe64232cf5a320579ecbba9ba66dbb6e92ee88f180382b688a0dec65373db5d4eb323072447be7461e96314763bb0532b656ac662f630d6f08d5032a6213ad9349f0b238f14d239baea6302cf39d1eaae7c0496b0bfa523e7ef4fbc6169c30197393c116971210e520ed4cc85e761436e70022888ca4f1708348d3d4be84380ea15dbfbda41e6dcf3721902a54040f038ef6c006b5b1cf17a485dfaeae2fdb158eda5e77321de6a23d82d82f877eb3687747c5cf857b9847543344d37bfc21863af0f2bd04039be55ace37d0a287d1e1422829bcd282b0a86808ec0e967f46707d9c8d55104bf5340b6054bb2166205173ac2b9828d7956a8fff0aaaf4b26e1b2fdfd6e15890071fe16031c9f9b66fb2258c32c1a20768c3925c53652aea17ceaae261bff0cec9fa940ec96e4bfdfc6502cdddb04e5c9d3bb9a1e5fb806aed388deba5e142782ef5189a865950e1da92a0e4a67ebf621991f4a75bd6c5646e4a3a52214cbb9703104b5e22e5f84f6900d56c9ad5f3952aa6e8f78ae247fbc9be1e7631d96fbf10530b9aa9072a0535f3d5af60928cbe00ea45d9e6c8425fa91dfd0401f953c3c9e4a3dd871d44444e43efc8e758ea267a8537d0800ad370ba6026b445cab45c90738e0b466c9f07a0ec3101c392829c8cea7f96d2da7a3105b703601ea35177dcd404883bcafa3a668de697e9d57849bd9421487d0a34694706ae9fac15d7509f83c312b71dc85299271cc8004d018b6f6d2c2e0235326a7049153593e102d16d32fe0461e4a007a23660edaf1651899e02001bf2340f99afd634dbfff95f29107a6f071ce98b0ea0077ebab93730011cc84bc995f8fbc510cc8875280b4cc96b25a83401ab9c2f8f066bbfc977f9af01c94751af87137a84b27615b00c105010581e1b99415659a99a7f272351a0791898d6d95b79407556050d0967b1cf85ae4571389976da04720ed29457125935a8e54bae8c7235011b526f511476a108bf8059fefa75c58090018b9796a23899230a5164706666d53cf8e5d30d3f2b4c45c24a8bd569fc1760b0d8c7724c194a322705daaae4545eb84c09f4f933810b46c48c11b51c388688a7ee23be350cd520fbf9f84e03d455d5925e7710a22d7982d697097506f5cfde24e3686fddcdd31484f3012a357b59bbea6bb06bc3e2271b09d7ae4b56eba58f16852c37f042bab2b37aea52eebe643c827a292f9a5363f0a44a25e5e42b5f090dc0cb54af0c343c69ff5aea3314acb0a08b3f4e004dcd9ef562de120badd4a67aaec4337373bcdfe0ba7d1b857647e1f2c2db31460956783c4744814816bc6a9c3b206a9be282d8cfeae4d91f453ddc433f636055e6986ccb6bfe2c25fccfa6bf81647ede1218fefeebcb3c50fa1f9b57336437b55211ef2fd121f0abe71f3e5a0115a33c213a3c32b44d3d5b73d269896838651654b02ac8454ba52ec460df18d61887ee6395d00b1cbc690a29d67052d8b205cefef8c21801c1d18c770389c7413709ecaf11b184b57b8a37870737ebd3aaf669c5635c9821e5f7c93894dd3f07c7d687bd1ef4243199547722c801759cad5524d044f084e44deee15bc19ac867f76455a944ab2d12d1e27491ce72b43c1b7989c4a27ad391b5fb73483b24811a5c3877e4483dfce2746b0d899a411c723a7787fcf542586f38b1c41d3638f4ab2e7d39241da0ca88f477f5cf833d0383deb8006a5828db1858758f4d6a9404ced65e3548c9e1ab93755ae14687eb7fce53bd6aefb113e539fdf539cc06c0a80e0153a3454254e15d00c6cbed2008b82e369058a786ec8b2fd23086c38e83cc62d06bcf021ac893f7555268f404f119798d635c1dbe5b2cce0bee38c0e1711641d41e5ef64744055c38833359060f252e4ac20e637038d4c430028a558b8e0caa7f069d87bfed6068a8af5e478e7525cd95d3f6576218736c0d258cc25bcaebf3db037f932cac0c7dc015eef8f81c686d9d230eb1c92be11e7ceec9feb4d3bb784f094bfc5d52426838f44482d63be8f72b19377e93655cbaf50d6ca5af5175205a5aa5b9d8b43bf68573fba228859b7b6c08c68328fba9f97b3196b0def6b2437f0a5f90a57f4a1cd4c8b89db50273c0dea64d15b53ad8c771c89e875b8f77d282333f2ad6450ff1339b0f18f33dd05e507b09cf4af58d230961c344d311b52129a8623855b588fdad7576b3695c181ecd1ac23efdfbd47660a547df7c23b17fc6eb331572ae21f4c869abeebbc94a453016f8a8f83d6eafbce0d3a3e0bf8603995a8128d0a2388ff6c39c4030efba95f4590397d9f729a5de1ddddaf9719fa71a7285fbe3ecc270702f88fc91897907c650f1f7ad85cff8033228e0fd78c32ca59b69463808ef860c32d8157319dd373c6c6c6c78aa69e4915f8caad55f712f2636c71fd4d999568698054ed87b437c9315239079a85c272aa6927dd69b188d0e3b92e19753e21646a020eefa3754dae615064563e84a876711baae3f5cb5447a210fed19a2a7018ff4ca2618248242ecf306829d97629dc0a678f02c33a74d00f451633c913a144a9faa02d14d21524be41e1884e7775ac94f00e89111a8347a5a9a9b2b3b3a6b270d3a16d0f84d41da5e921d8d7fdb92116bf24e248b1f6b3a548ab4097d901595b2ab0828c991a08675f06922152e4984b37da9b4d6b4172376f0093a7e82202a6044f997da83df994f0f147fd273c2bf8fb5bc27587a46dbcce8989f927a2d97100970630d7aa2d9caaec944ed4ee0678f0b3853707d2f6b9bc0d39715fc389dee596b0d4001171e7ddd9d5ecbcc7aa0ee2d262ee3767e7b1885fd5a9a1c9062ef0b8494592023eaae0ce68f053229e866c8e360a339452b254fd9c97189af731169a8c1f5dd0ad7cce37ab3a1b3378801c929879646b44d0d9300b34c56463c8a7ae6667b80539cc8bf6a3b781ddae29c75c58e71bbee326bda75ea2b78be47c146f7334aeda46be8d57b8abbb68ee7e672bcdb462c86eff08edbf5a8a8cf2bf644cef3277e80a42fceea483173281e1a8f0da430f29fdb1428ab2eab4b84a14ce33f2c6f6d0d2efd52c9dad7979ad930bf1548ec28fc951fa0e8134f2268024ca430899237c974d794c2fb5bb40218df8a7c3831f954fbf605e5bf77bed4ef29dbc51ee5fc41b6ca0d4652f90816d7b95bae5515f187a3905e7df50a9c2b66ca9c6e712453fad1bf812f9bb71f6d300d58c88afee0b4705b7cff313c0062fa30c89571cb9adeece8e5ecdee1eb8b8fb941bbc5f90f7dda0a4c4981b44d696e7db62c1014cf3bb419ca2e9fa2ef108f3a99e0dec71ba1bbe6b769e0674437ac5de716d8447f484567275acd428c4161d5bf3f1bf0c3196477d2bc90668b365142b7ffc922387c6e2e88a6287be41224676c537b8736b8910c6eefdb51a631552b018210b86fa03505932e5489f40bbae1f69ff2c49d5d806bdbe8fbe96035757002b1c47d255d0eb3238be18f3f974554f2e3ff8646d5e63186c785fa28cbf31074ca206127c306f42384c1a24720edf5cbd5974563a4cde8c023fb77cdffca5654e80dcec4a9be7f359b11854af37d40c37f6e21d3828fab331daf11baaceb3ed22577bb05e3eddfedde058d4b408fc642a9dc0c62af64deca8a9fc17b1413d8291080a9627f0dc27c46170e8fbb4b26e2fad8e71b6afcf8e496aa066faae735692c37b98b706d20a1cd7bdedf3685f91180624bbef90accf5d24e4e05a2417fe5ac41e39df2846dcbf0489bcd58408f9d5d5d7f8dc0a159457617f9cb4eaed26462ffbffa3eb08853a33cea28fa1d3bde8f098fbf566fad31c39993050545862dfab6e61a42dd20338741fc6714cbf17ff6710c51badcee85a68c02833cee482da5ca189fd394ca5b2d7056dd9b6d172ddb7263f4afc946232d93e7d183df5d91b70dfd3c539a29bfc8d044178edb63229dc4a8b85e0cf96bc4c06494164fdc2ce449121cd4d17821ba63a176bb9c2e57b7734eedb625f8f29858ff58780308bafe0bf8b3ff8f4a25fbdfcb87edb390bfb3cc06488784172f373497eda2e8382e6685cf12996ab19e0255dddce80be2d4f6b7cbf4a0ec930f1f22b056e26d69a6aa0153b2e30a5a244dac3425db43b665b0c5388f963dc60476121a89843d034359bb279f46fa0e5a6a17aae38a69fd02aaad6be17a6aeb6dcd53a3676e63545112bcf2897346ac5b3d94aeafda25dd02b7968f7488e6ee85c20d2a7fb9fe80b164300ee5679764c8ff661f97c059bbacbe4250cd639582fda93cf063d39e2e7bdf3975e7df90209a216cd6cc01633eabbe0aa944d1b708daa869aa82b68eebcb229a2424ec58839cbf55872358c0031d0407998a392a16f0577788b8c6ac14824a12057aeb10b921035307d95f10e9fb00dee13f93041aebca08bef35e4c6da376c3e69ac17486dfe45d2ba532dee502c3805de6fd06784a62b0a2d73979c898a6bc536ba2ec0e84614c0765b65674687dd8d3025ef25197310029bad26b264a79b63ad09ef764d8538a156ccf26ef63e0baec884197bf2e979ccd007e63a1bf0271a4769c4fd3fb9c0961554f01e6e1e0a75c4fdd586f0173f358dc4e6072ca4d50121715dc02c4777b8451e4d34e297d3ea2fafa2b9325e0650e868129853f95914fc29b1725f52fc08c43dc7a5c0cb9927fbac3bf695fa22cc396f8a723bde2af8f42e3735d379fa721932464e9d1debe175f9e01dfebccdf5964c1d8cf6f5c2151329a4789f3d4f2d23e014d78eba906f8cbacff2b2d71e4c18390ef9d7a179382c51205f77e43a049a2097ee17c4108566e3546d431776378ef8334f14a711dabe9f8b435e8567647d1fd3022d5536cc43705d3b73f1a618bef15fa59e5b70819aecdf1a1802241cf5bdebc5fd40ce8ade22f9e24e692700036ac098788f2e011d562165a0b2996bb96d191f41485f34ec84ae5eab4ffeabd6617a77c51d01ca2649ec37dffbee6e12f22a5fd05a5e9e579aed255d5dfa3e7435d144c0d7dfa8b179ce1ea17995d971af5480ba3d490022b9a7219f187fa63e7e75673f1d20eb7a616c125b9640d388079b8e09935e9bfb0b8dc8cdbe1185cd586b5dcbe0db98fc7bd30feadfac729f267748cadaab80c45c0e6462cc6f3c4723eb31896cf4477d9f69c7768c35e39b054724dfd7f4eda241e7c10313c1ec6024c340c72e85ef4e9b4ae180cee6b9af85e45a72ae7398f1865f3d3313bec0999050df26088088133ef62ac52bc472620802b24af985d532209a5bec4d9d4a2c30498d4b27cfef556a3e0b926c56279c19fa8a3c7578a7cf840a1e7c9cac4ec977457c38702db3e20db5cb4d2e8387dcd495219f992f4856039480dad773217836b695087e2e066a381b543d25944bfe660adf99f6a8cc961fa4d7aa056d839f1f8055f95b0513d167ffc2082d5a9404115e75d2e2b9c65a9b80085a4b62da41295423cd70a10eacacf213707a24ac04bbbd86467211d4ecbd6d88c0702832afe74c2001623b0b128a31254ed4fc6d4b2868d38ed320c2449a24ba8b2d4b74d7158acbf187e31d0abd2b0dc723f95bbe297a73c69caa38a7d155d8771d48018f14f135aeff8938849fe57d57c7278df52100e163b5c344afd343415fdf2e0beddd44a84b3dee826a9744c725f65c1c181dd9c83e389c2fa1bbc1b6a8d1dae286881bf5397f313b323f457884e5505690424554567d96648c69aee97bbd6e95ab49bd0b4f916c4ed580c32dc5d89566c004cf017749a07466b565995bbb8c04c4df7bdcb2fc102282bdb33b61c66cfa7c56e6c072518487d35ec4d226bf272ea1c4610b9d415af424e1359b1011627f3758227450a6f1ef79f828c0d6f48c2a8eebed9e329be8d6d58f7e1b710a45205863ec9860007bbd60f0251b72341c549816eeacd062a1466834ed1f70b252d34427b7870c07dd80a1006eda982ea9b9c4c78166eaf5818ea5dc69fe08c1b83b9b4a338c8a13e7ae926ab94fcf62383cbb69943a332b881f2ee8d1b5fbb1259aa0b04ca840f6a3d91f1b7a5e9255802695b90a4f3a1ad9096c295312655a0079ac9e7e9573d072a03a24ebe62df37fde938b8fcf2d2762cbcb45d42f6930c4c9a050a6aaaf5927f955fe0443a23bd0619928a3782bef17b7fc237b5df4327d46784bef659d5ccf1e6259a3e1507b86c7ef9b0980809c3c1dd91c39b4e1a8041fc3b9f91632b8ca30f4076fafe4826d317795ccb7da59cd3134087160dfc248db3640058c17e511bb06e4c3c38e75fe10f501f4c6971e0b6e883b18d726b9a57e7d09ba5cfb0f589190935801a8fd537925fd75d7c85f0ae6ac645633882cae45b3576dee5f2c71fdbdbd60b87fec444d0a3dfd8a87ba92aab9708f72ccf2ebce456fb9659f3e4af2a6b38b0f41ecec3acf5c396dc838d3f1ab36e0d7f0ba81aadb771887f18f9109a504184ed974aa628df911e74185335eb97cdef15c6bfffd2a79fc0c9a8492407bb0ac2c476dd426d15af1447dbdea2c6b9099295e654ffb5eb6bd1df55c423f7ff6369ec12901fad31107ab4e5d4d35ba66622d38c0d7e2354fc67a2ad2f246328dd5de514c760fea9d9b871a4d5c64918c14e7935ddcdcbc270c15e6c489623bfe2e3160103937f3c80ea2a41d898ff78a4c45daf8961c1f9750fb75c5ac78965a92716078b2b19fdf99c9dca697d1827a84516893f6d6c29380817241fcb3c87cacd2ce77effcff7504ba1370e90fcdeca4ddd0dd851baddfc64cf8abed0567631011c78cbaa8ee9b381891a19b067cac92c6e1498fa5b54846b39917ca8cf09d5fa9ccb06cdd0874c2c398a10c349dfc5665f4bd12b90d230def983368536ce7bc0d40","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
