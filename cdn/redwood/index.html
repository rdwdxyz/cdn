<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe42b2b62bb9e68ec561f79372844d7ba800c4bea8e163ed0f04359a81bcb0b9649497d80a367e9dbd6abe3fedafe8cb671ec00fd1ba92ed49a63a82f51df06fc5cbcdff56a54daf9b915e6d94a1ba27caf10e09b7118e073b3e66483ee661d1e391b907fb982108ca020b0fc57a3e629dd0b468bda2b4852a01cf1ccd9a8de9112220728dc442b4ff29169338cd4f63bb3cfb9465f40b67e7bb07e02dfd6b4fc26377237855c20b0bd042660633edd78b0d7a15e94ae334566c5ef4276ff22ecbb0bd29d6db182e9ed8a5cae969b5e174e74f059182bc608b13ceeb01d8ca6bacd7b1b789c1af3e6ef551413a256140df4edef7b12d5dd642c043e0f695e2d4c9b2f091719c805baf9e8bb05afa78a92b9f69ed1c3c59a5df63ea343745eebe4566b35b44cb58f02736fdf84e9926b27ec1abb26d6d190857e1715d8b1a34aa415b024a936ec44277f1a95433d35c4bcb8378877e89ea5607343f260598c01279d82df5a2214b264d8f3c85242e6b3bcb25af4dcbb487bb46dfe7e78291b6901c78f0df9553c94b72466a5b0e45bf94b5fb4cbfbb16bf283666709fb69ccd918beb77313a348b6ad031eda253068fe13c260732f3161bc5baf9521d2dd9287511c7ff7d1db8ed8be285e2c388881fff04a0995fb45777e2a92f81c74c74d82e491f6c8fb8bd9c152dadcb906d72ed522d2e3de8eab43770fbeb8f06d52f55f80f3033d3a69fd57e6ea70f2d5b8b19b07cf96ee817bcc27a453699ebc73ae2700816b5d99448353c2052130a64e2210a4b6d9f825ee46646216dbc8d72d8673373734d4aface69af40b854e9cb1d82f30242107b1a30a7d823e38b85bfeb4c06df5f3ba8e2ec9f6255b10c3fcf4a2bcbb00826018dde6bf7340270ac61a7bc7844cf8a6da10bbe9a77aef0630d0a640f31798879a4239a7597e0ce134fa25924359df0feec4575d0488c559e57038ced664f605d6cf353aebc121ef0e975214b893b5efd0f6ce5898f1b98b05825ea0bbb566af309b6f35836f8ec10e6e1360fb29320f71385b4e3281d9651ceafbc8ab2d75b81250ae133d192b7b003c4e29cfd21f24e46351adc19988b36018560b4a69dd70883ed093a121520f1e1468bbab1a8453096e6f5b3dd60069524c06d215f326607c8593bb9575ff66c5dd1b1dd1f8aead8229f360f6d0b91330573b5594e726a6e7f72759776684938276562cc2f02e0dd1105936d216856fb5c79b231b2dbdaf5cf075b666d4066c44fefc581457e203e3e33fb8135fe7633ecbd9da693aaa53e55912583121523cd18700aa054ad8a7ee7a1a99b26d2ed8eb175efc16cbefbbb238650b49b577b6f13d138c48158cc4615351589424d7351e6b8e1868c2b29411b97100847a29f348d9f9567bd9926b4d24bb56e0c666e573c335c0fe42458638e0855b7102b57d0b49680488f122ea0154b0c155b2408c7f577c72f64c12dca08f07eb02fd5f1cb32d76aa0e724793e2a954f928c6931c5894e3c7370b5fc2529bf153fa51465058914b62dfac16d4f125edc8f32102347d05a12a3089403d14a4ad1f6af1575de6c8c7ed3c3fd39ca6adf513e4765ce7e57c3d1c5aac4c58d9caa8f567226020fa557108100b2112e2a19e732c7294bc07686d89e84aba6a3116bc8efbd5b785d1a9e5c6831121d73917e7584d793689dba1a98a64d7060af717313f89db7faf48dd9442ead48e1f0f20f51201d71cae904b457da87812e8f32ec6f7baa9c273c8c27a16ff14af1166522c4842ffcc70b66389f87202c7f066c9441d026b94cbabb2494ef7cd342ec4906988b69bf27f7593be1f7079cda7afc8209073e68143c6c700954496be23e4cd52af6458bf7171847f7082a485e9078b13fd2058acb07c9f75d86e47aea45d6e577fe5b52c0720c2728b69e47fcd216d00b407cf585a79e1dd6c18f4cd0e682f9ef8d7bc8ea41c407fa2b4e7e3ab8dcf42b37ef8f0e519bb9e0ebb5902973907226376cd7a12ffe5a9202e40679c2ae76f87991e479a82164001859828b12d063af0642bb361207d1120a3102700aa52c651fe5047df206b83098e7bfc4eea026ce321b6be06b3298dc975fd27dcbf9f7096d9cee9eefaa121601d19591ea9dad1945170e252dff6e78c4a55230642d3583f13fd20cf19b28bb1435d402212af0d0531956a0a4f2981bf6bd5900af6aafc075abfbff4edbeccd97548ec71d69c5f44b629cdf53aca5c56987f07d05970eb4d94f7c898862fa2bee3efabe4cb6e2b666d22e2b038eb8eb39629f151866152c7964a383da7747f3d9282df691939b4e291ed634e770b266977dc3fbc59dbddc64c2d798c5e26fd781297ace808ad118e6741de38608b7fd93f2af92a82c0abfdd318fa22bafb3082a42a20e7907c8e4dc21b5270d2f3464e6b802dd64049a757155f11456e4a4af9056e04d2612d8f88f1a67f5d33a10043c93d3df0e29304697166bbd0ccfb89089f509e0145d09868c52bed4466f0694fbf5a5667bcec29a96657c4bd520a750c47aed5044767b0b8852fdae0fc62231a2aad930bc1f4e746ec58ad99db56a3220211670e4264824e9566940585ff88d8d7fbb3fa17c19c24fb84f7ce995cbe0a42a2e5c2776ac99b0c76fb5497c750ba5175ea8387658a1c5569b4adb7a7a3f4ed96f998f8323596dff5ffdedf888d6b7bc661701d07d4d88d5852304e8265653a96ea28d7f128b2c8f3c638aedbe3899587aa46fb66fe090450021c68d881e848d0c6524d68bd00ac5b5f829d26e7405d66bc2aa16f9660601abf51bbbffc5e1cebdbdc6cdc8a9c8179982b0510590cec342451c7120cb2a5a2ee86b43a62dcf56cf3f3452db9ddbd27dcbda5451464bc567b99dd2309af44516ecc8abfcf01a0776ed5d6fa200ca910126c74b2630b7ae0a59ebadd52346cbf9ba58d3a5c3b9540e6ed44fbefe6aeb8ba8859907235e9f1a8a9451ecc7c1e7c32ffb6984937be9d9cad6bc5857daa97925f4bf3149d7cf70f75f2d51983396f0fc22a851f61b13b40e26069b02615b9c33234f7603e4400ef5588bcc66dd1c8d6a4c1731e3d48d87cfd966dcc1b6dc253db19c04f9b35270ecb79425e9c2034f15eccef6edc8bc4ffcb20a09f65fa83f8753126212064d771d05424ab308cb9404ff660bff6cbe99a5fd41f7b17e6d7f8b17aaeb4c275f048451d6215010ea35240e5cbaf815dd5dfc41174b81e92d6f268c418d7dbae466fc5d61902b164aa029b9cd48fac4614ab3679ff30c6b46d6d3afc6644202ddd19a078b27ff8d4fcd40880f53ce51bbe709472040a4cd554dc6c1d90bace43209a9421a0c368034355db31cdbb17465fd9bfdc5f7ee3f32779a465dd546f4fcdb9fdbf788b7519e872338fd86423d50fde222b821dadd8f2159f311b8b6d76a6da378dc08eb27e0803d2de4b9694b90a6dd5892b1651380f7428e83672526f716c725385ab0a88c1381a3a8bf076f20e09510b786a7e208d93ab834d273a45fb7903989e3c59370070ec79e5e03598221947c7987a49f612299479781b26fce9d0cd6c1b39a44bdc9a65f287678ed44c319cdca7f085127640d80b2f306fd3dfa9b60c4c1e3e14172123276cae543002cef91b14672bacf4e280b5640faf3331c350c995b6b2190a3c999330fb604c6c9d19a5095503269e05aeae39cdada4a038ab1126d102ec24bb5f1df30b59614585b1b5d518af47dcd23564b06e0298dfbe5c0729ed966a823dd029fdbdb591046e83d3f07d9b0975d2c7e09bcc52f1f33c61ea1582f597b80d5278be68d0339203823e5dc1b86eff867a8428c8461b1c60a18e0f4848c90c4c14c7079cf52a0cd57956c28d3067666950bd4afdd2df531ff1f6407f3b2777cebd970a2887060570999081e8ad35ea9daf2fba5717bb64af0a441f2e3eaf4fc3b861e1ad66fc9b3154ee94188a5a1bd5f135ff94444249e6a4d404d1459e90a6115a9d30cc56ce82f4fb5dda6c6725bcc0f08b9964e3e02064532814b4ae6a62d02138cdc78ec7442246de23a81ff61c3c8c5418d9eb7153cd515c15054ff57233aff8acdd561f6e86693f9c8f77830a63a881b0868c2af3573e48927d93d25c1a878ec589d14f6139b9a1222e2d70f6675d71ffb23a2a1847b3f4ef05a125bb346eff0f1dd7735fa6d8cb15a02bf5d7ce09c1e0d9d84ad2735449c3f827e36ad9bbdc23786d6a3542a8c52702066b53814436dbeae9a697fb696ddbec3e15dce68c1255978fc8b70ee8ceff532f2f30dec2aca98f511ca5aa89acaa623761b3fade6ba72203d8793ce4b5877a7e1c38242dacd8f1ffb06c43578795464bc0f424887dc3a2551a610e33839bbb4b735858a8a195938ffb595425e79515667bc20f611a4238164b8f59e69ce43ef719e8b4ff9e732badf2ca2d34c92f10aa42c2597c293a434ae1272e465cb994c55cf4e3b213d56c6f02c8eb8836d8540cceab1100a1863d069ea9bb7581f12c4a9696d9e15d5c9de6ea9140e8117545e2ea4dad8298f92cb03562acf1dbf05177d9ee69519712b6c7438bd83b8b1f8823afc53a2996f7ce0cdf950e6770d991f4caf57a6c5eb4d11e4b5918bc7c537784d9899f211e22f665eff916b08de00d362a652ee02202a3552b875220b63626a489721f49140ffff2fad6520b1d65c56088a7ac30fc051bb30d91b688dd3235ece30a273a237588797fa9eba82198d6adf55f0669e76b275a2b83280ce5c7e0867fa33dd2f5c6e29c166f06ed06a670c846a9d845c065463f3a863d82c0546ad4c4cf9e45bc74a909ff10fb94ec3bfa37e7ffdb65cb9df9cb6c941b90396fe1086c83829fed4e3ae2b15efa71493ee1fe833f504fc95b178c865cd8187d0881d9639c23c38a4d148e2647142f98fe39e53efddc37e7fa927747333553c11bb54d7ef7ea143c83049bc5fd1e495c29dde7fb127f160611e2cf9f45bf8d427efeb8aa170532ee90583b5e7c3a2620d26009206ff95ba6f0f3cdb4bb48e9d876b8f20b6b73c58123c07e54707ddd9fc90686d46b8f1a44cc041959492ea6dee3e47132b9d938fccc4eeefe05dea1846bfa83febe1ce044592bf6f2fc1cf751d7e9ae5bb2252b4dba494b03e03bc307c8e5204c946590f1ac56bae6be593b327acf8b886f1979ec6377b8b12371e02cad4b8bba38f5c8ab9f14ceea9d883fff7773d6e4f593c10ffb2b0e1f83c9e28278baab125a992f67984dc01112987240bec1a3ff66a9c909cc07d12cb098deb5f83c9c8adb90dd32bdb14bc164e502cba9ce4843e308c657d4aef6706dcf8032d1c81588cee3462a1b08a31aaca767fa16e69e50817ff75a6520865f431f59136d7d7654b65b108ed08ae598dfea749619a9a32057812488b70dd067d0db6a47034aed9b3bb04b6db4a26d94016f632511f14fd59faa3c01c8ea349572b9f849ca5b12a4630e5756044d297e0d0d3663b0561e3aa205f2958c8e509af5e98f98362bb01d05d8b24585e4eef4e369e08d061c09150c3ec0425a37678c37fe7b4704c4193179d3be3828aca9fa208621557c09cf543537f745036dcd0f6546a99337bd658aa97ee30368d182bc414a5f797c4b44d86a6e969c562d409cc805270df1c81dc69b15e967681b3031de1c51a8bffcc897c9c2280835b856268f97ac08555f9c088c22bc464be1a01ca07d4db1f5fa5dfb9402050ac094598ae70ec5efcc5eac57bd7cf550ebcb9e975cf6fd8225f824ea5089259a1c64144f3f85b646c2edc68fdfefb252c5b0fff899039c9ead2b9391d595554c48865afa91ea21899c350a0b14603e0e275f678db4777596b901f6a071111dd9fe1d74d9a681fd490e4693217bc2e8572d73485f10383c083cf56fdf5081413f3169a0eff38f240541e57ba86a4e395d5927097105c42186d91b70bd341dd09fbcf2f733f4596b91152fd1eedb7e67180ed4f5acb9eca90c1db9b1f451dc5d683350a64e1c387701aa1074f9b34909c0296fab0941d0244c27f101c9c619a08f8d44e73ada5987f8a2e9fab3ddada0c888a05b76a603d8d4bc81fedd67423d3810d99b908043417d462515c5c0f339b7659b6cb649ab6a442b2f800a717d843690c221bc9237d9292081b70ec4b5acd8a1190457288f95cef5fc0145f8603a67da9ded3dc71635e5ac01ba467765a856b92906df64e0e87467958b7146ec735808c9d6bab8987aecfbc6f1a10b9d20b829d078205feccaa0586805354746021d117c9ce4d6c74c8bc430571afb686b8e430c29db68df6bdaa5ec7e90f7645be63c8f0e15fd90fa0439b78377a907be9fec3b4fb7f0e93161879c9de85275ca078d981c6bffcc061b4058b320756e7dcdee48ec4fe09a9989c727b18e445648ad82b1922793e47cb353e4137f616b19f2c7a30ebe9f6a748be4e0c8bad68d183268c3ce78b972b8cc1027c1580543d9f4c270f8caa16dbe22ba1b7c414a7cd5232b55e85d64450a22f322aab064d72462c57b1b1186311559301ced67c7c36a7267c969244f6767f55eaeeb06fb5905bf35d53f240691fdf037fa8494289a41c8571a564b8dbd250ee9181125a5af644762cb85dfc53fd23d485297783e04080a25ad7177a0bfc735d006c99f3bb80871d45474d0a3072dba1c26de91d50f2e8bad78aa7738c7f342d01d5e8a68c44a0f50ff125aaa0d0507249c5df21a4453d106835e59d0c74fc2e75275179a5ed5574b27e8d18f3b1749b130a2aac3f4b6a87aecbc8058f8878479b79f5fe5bddec4c72490fa8d60756a3a51359e0615474281bb33a9fd5f6454fe391e7021c0a273ed416fb0fa88ef5d27a43e5bcd45e317b63cf4844fb1caf6a98fe8f0f4164d81bc32867ff71e36d43a928ef8654082478634c497bb4a1759422050742af2a083ce0423e9bb6a7eb26dd8a3701b2c466781cd18fd8019a1a90890c758d60c6b575b190c3217bffa1f0ea515001cd65903ea84b82ac60f7a49caa2e88ac38afb04a096eae59d5c5bafcee2551c0aaed2596980711020fc0135edb3673781eaa079c91b1b397406234296a685892df3bec496f57c2ea53ffce6a4ad4b123cc41d0a49fd4a6264a0027b79ae65cf5fd9674b0c5d04de8659d07ef5538d0885768b496cf0d128bcbdbb91b698dae40bf7e789cdc02cfc1c7c444d2528011ed4fea72a7c762e468aaac932e4682407383363b77c083ff962a8c0c7989adb068acc59ed3a7c755bc7c13c6f6e0733e02efafc80d6477e38642a4567085878c81d9c30e8f892d1f42b0456d174733ce5b99b7717aabbfedd9fb3f2d3144de7102f5d097b83b17c21774b80fa62b5fefac17a774e229acd385b6b1f46076e79865315ec7012b7f62a2d6511c302b3535588fb43bf859beea5cc736937c20b3316799597425c0df249cd6b81c3c98922fbcd040a97d5349693171b42cb66aeb1b3348dc68264bf23f82c2d7ceb1dbca28257a35b3f4ef66fec7620ebe0bfbeb7bc6d90d2cc133de5cafc2a5f75a640a6675518ba5611940ce905e47f5373eaeda2c05bf910507e2b3a417ac119610cf4468a01afcdc67f6bb6d447fd55e7b2b9f442a903b82e69f757a794752f09e42cca0e1af3922a8cab35844586126927e4a5769948b5b632bf9ca925eec4f2e0472cdd120d6675d9730c3f4e4ecce6663becefc4b198d122dad0aac245379ff6501242bd7bd05841193673f07cef6242272dec4954f68c82cb693164aa11d54f0c0b9684d201bd7aa96e8b672516cfb1459fae7a7c1ac497c4edae73d42d0b66bb8ab45c2be0531c9cd817d430413529a73749151df777d995db856ad8d017cb036a640ec6ecdd0218c8999bb2216db2a94c10f790c9f9caf0c76c230d8b10eddada2e4bd40cb6b9e065434468bdd4145aee14f54f13876c00317a1bcd3b50ff53a2370c48b0f15ed7c5afd2f85a9188bdc392020c831c176881b6225039add0d013a5ee9148778d9178a8dabfcd66a17a902876619b23818e16d89ab2aad63ea57258bc49828031d5efaa06d80f838f1931a0a060b94710d7c2d0850c74464f9ef6d831ee2dca2d465c60bc4498b8243c6a09e33fac24abd8215c9108614f315f57e0e8aac8f73d1d5d80243d5d47f96c0dde70ba3c2605be8c2ca97b9137e47668747ac6e10573efa4ffcd3198316de917a66fd8e0b153aa7f48e586f489bef17bae505b6c2b5518656acc99cbe8e739a392823d306b20e8da0e9cda6394ad20ea9bd69717f516d5f2fc80f1968c45f4cf8b35e690fad2baa15826b904c4e42006003194cc7b895bb7c1e804cb70d91916dc6a3c4f01b2abba559fcd5748a333794455b94c05bfaa5d5e14c899f0e5c680be2f83a552697a4ee0e28d7b2982950118d50bfc1c5c5c47cb854b06f264142344cf8ad257eb800b220cb26b440e994ead7923bdc6353cb8bfa8d2fdf1b70db1d52a86bdf490a7c6a1fd8185cc3b0be3eb97bc1100edcb463e74b6165f21d06944dba44165f412a2ddf3818c83354d5ac67015989ad33a756b6a5acf1523e1acabddb79c09274c7be4d4c6bdabba4f94c5bbd2bd19c247e5cee0300f5436764b000b63325025c530fced05d2c5bb9ed382d3d1ea874e9c6a46085cacd3f99fa4da18dc062c56304c8cd0868fd98d44d4097cf5282698a13177209a3d6e85852788a3472fceb656d902f0d8ab49893104161a40d5db16d61471c0e0a7cabdd7ffbfeb6a9042990f3d0b2b91dc9b6a9aa26e81d62adfb977e2c4d8f35141cf2774e2161de904d309aacbe06b8833fdcf4a647de4164b958077c730680478808c63e75362bb69c1c253092062c35289f8de4baeebc29d20f16ee38b1c1fb30288258a9fda40c3402344a8e49cc73b5f16a47de292a9ae3cd891d7a10edebc679e4516ae2b3bb06c3b6409cf844f2ba838cc062ae2549b2c7ce06dcb7808f19f93639964f541ebe3422afe6cc08980facc7db95b7af9d3ce67a64f0d38d7ed1e0914473886196e4b46ee65580d20171e0525c4e1622b07c5d82fd877c237afe02cfaddee865460dbc8c807ac6490519746f3100520eeedd8e4ae19bfc137b4fdf51b7e0704b17838cbdb47e4160d2f3b9e56db81688bb05420938f7f6c1b4b0ebdc85485a6e8e6586fe24e2dd6488fbaa0b9b4cbffa5c0a3b8be531b1751efbb7639600f46260ea5e88fc416008501a600004a09699041417042582b5e452fc906eeacb9fee9bf421f76893d702bd89437f56c2bf4c042a9b7720e5bf3ee310c6d290f2a104d89cf0f43034e8b79470fb544275745dbc6d80a2071191f16d0ae2f7bf0102fe3d48dfb7c205e00bf464fb05fc8dbc48952063523f65d18343fa8da8d0b2f277360bdf6f20076aafa6ee4b0d81fb24a49fb873fb080189e1034e03e6a90199faa4934555f322298b75b57bfca65e20af1ced33e43d2eed24cdb3eed680b096397d4a9c04ac9c557aabc92b3eea96dfdfae404739338be7bbdd43a0259bc7b0a53b4840c27778d4f845026a7cd0cb6c12fe9753952652ea69b78bfee1f7b6f94cf1e2625edd916820929ff86c15551b196fa46c4e64e722219f615a902583a995ecfcb475908b0fb0c8b55f06cd92d6e8d6b5e05be882e55a2ddf5196e3d3b1182d6e47004ef6938031d9c2ffa0bd34367b453848fb43da907835d0e854433ba1c58eee16d47bfdd267113f2f18c8e7025361c84129fc97f98c0d1c5682b656d167b6fd509170801b94afacbc589185aeb34f13bf2506286bb829b3c9d92021a8a4d7f179e1058206e65ad607b3962609c960c423c7c257633472bc07a2dddab7f7067ebf1cddafd668fefdad2477a71f01483853d0c1ec589ad2bd7d0561ea1c1a41770460c8b21b0e3cf5711fa68829a15fba29dae46251f9c63d4f9e13144da8e0426db955d4cf531dbd280b49902f6586e8ade945449bd89daab667e1580fb7695d361fb47ae8bcc8ec07f5a09dadce4d9c811d357d9302aa947cc4aa50cf6c035a056d6a534a303cbcf1016fc10b68fec54e96f8a501de16b88adb42136cc5a08ac0987567f0bd67deadca66cc48636d0b4bdf15fa5b6c1a93dc653f88655cbae77a6be5c2b5b4669b6deecc89d14887c61776a0fb70e1d788abd502d3be7997b443738f12a0464d68bbb3fd03491a8673095e75c8cbec318d4b3d0ec947ed1ce041d74877b0b1636c311e0e76e4eac81be3bf25d317de5970311bbff8417f79aa24c0dc1cea6761af31040c974aa3ce38c7101250c77fba293473f56641ff0920ed8033c854b4052cae052eaa4ed1f39f7c826b5dd63a563335a81303cd6e53b4231ddd0ed0db3a02a3f0127ac7dff5fc2a5bcc930d1feba5be63c5a631a54321b8b4bd7d717d291741349ff432d4c07a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
