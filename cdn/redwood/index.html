<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e816cd64efc36a2b181b612aed91a9c6f20a1cec999642b05a385bfba3f277692ff1669c9f72f0979ba2149664c3dda604d4b66149b90a3e8ea1abbd17053e2412a0d4c053c4b1d7be4c6c388b165d2f5d91283839d3dc0f506be1f1070e98eb0d564c166baa62ba187d333888c00b6758ce0fe5cfb45ca62924e263a122f4c3d961e66b32937fd18fb4811375acddb8445b961c373a36f2c134a4b73e499ed9380cc017e8d2da7221932c89ad3ca912dd36075ec0babf2b79dbf4a99c5d54735d6acee046fe24e1d49aa0895b81b2005e109011342df90bfb6911f2e92149f6c39426de22104e1dd125aeca11489ecbaf77f5e97984450a2a60ee04c808e3946591506daa0feca52853800d3a12d29013505561b99174a6743806cab705ea2d1e9a2d24113f9ccaf277d141ce8afb540e4686e834e99e7ccb930b3940ee9061cc4b91b9ca9d49517f41e0366cc47f8a1993819606a98d06551cd1680f0f0f673392fe0c6a897f777b6b5bd6f2ba704ee94574aab3d7b56a288caaec42b150fe4a252cb0e7be786db50c8e432b856b39aae9659d1093ad84b322e85f449591a6b9999f5874ca86ac3c15d33ab5753973ea5c44e41b39b3d5f5eba35233300c2e172957434c70a23d47be5093e416418fe018b1a00628bc9812f00e33d145528a27c498005894255b247fbf5afe3e48f4ab6789c38026411f711be894a34db8c6b8096378814610eafdfed7455920f77b0d3245215ac20b080ed9fe8fae6f6e9c738b185094128cd1d695f477c8b8d4b1e12a1068510d3d878b6d6bd8bdd6483ba41ffd737fa919763eff2f1a9e9a05dba6323eb659feea6de16b0d5aab6e4cbb783ac1536e4a5097b87e7738a2e834d1708b44cae64158170feb07b5edc59bfc09d45e5f3434404a17927187c4794f2e1c9cc6c101be0bb360cfed005e2e99d43728771b4e3e88b8c53aa79a307450dc7cb1be1e39c8113a277811515526f59aa289c54533baa838737da1c614c9b0817870cc7fd3fff6995cdce44bdaea9b2d83c6dbbf0ac07c72832aa0a0ae03a024fcff6f37686d00bf7da160b79965e7ccba98ed3267befc094ccd0c7b7766e4eb8ee3146cb3fcd6a39993b1da1f0efb9f9dcae4b806b24b7d3e05c072e660cd987bac2a391583be49412aa9759536838c2f5717562f295a01c9ff46572e0f0c9eeb6118697edce4154fada318d56a1a846736b2df90e2abb38ee57f8a2030aa4e996d19f9ee63a3597fa47fec8cd6aa7cc5a46b0e1bba3a1af50887e61a6120c5188ebc1aea5f14a7d9c71679f0f44bd0c614d08f46e13313ad068339eb89cbf657b1d167e39e85a88405b2ea5994417ae6b626cb1b49bb543be79ff7ebf97f82cfe3ed7a58983bb989bf488ad86c2daf0c3a31a2936eafa7f9aa57047e796c705c12d7beb3d37b7804e63b04d2bfadea35a2927cdc1563d63eb1e1dd999be840f3f47c31c863a4a5c8bab410a8b7c928635c50758097c2adca4a87c32146ddf02f48fb17cb4ab691934c9f54b9f6e37878acee676c963c8688c252b63035c75cf81fc04d0204451ef1f3dd65364f8137ddf9a6605dac3fee7e10b0d1e2a984e1a53566d89baaa7919fa27a2f79cc35d9aad323983af249866defb2247445105628860a40ffcdfb04a31a7cd7cf69bc4475584c5ac3afda6eb9abaa0764434c688093d6ca5f49094aa1e9c6aa9e063013e0a1cc3c685c4b47924245dfe6075f43bf4fb026dd29f0e946c0a5cd2b4850a248366921961a3a11de090e8a16ad537b66eaa6e1387605ca86565c576147db2b051838433d0e4618b59bcfaaa5fe6329f8425c6f1f9b12c39ab5cddc3728468007c395e16733da749f6049929d66a41de272e257f1bb6ff91f661b711167e488bea21db94aa2756db94f997f1b5b5e58341e197fc4ab697e2244af479a57ff803a893987003449ad8255619ec3d37cb4345437203e07fb15c710b59c0478994aab92ec4f86e11f223fd0c133faca585681df68a4e16372e747a49832a288430411f79697d7b0def13c02af82a8cf99a76e006f9fbdf28c98eeac790ffaf22007fd5bff0c0f610326a7c548fd4c1d01d8251b1bad0ae9ddb3163b336e6f3adaf5d563ee969300012d8daa2c32a9c7cafa9b3b14e8d9aa02d80122d3db99ae0cdffae351a0b49e78189f29b322052f1885d64d9cc4485b1785763542d4786f9fddf04699ac1e436b1021cc7ed0cef46a7d78838eaf9c58b03413908960dd083c1b958075860ed3311e86b3143212648325888a54cc807c23eb641742bfdaadf9662577234ba997f388b30bbf1e5a8900c67d810585ffee396607eff93a669a3b2ff5567c9d50eaf8857dd0e311f30278e144683395c1d19cf81c56d39c70387a39eef8e86b31d3f13e076c07eab6c079bafce6ed965343a73282a5e8efe0716b4770daa42dac13dbab9c5a8e103ce23c2d00e526c82bb98541444ab9a3edd23fb87c7200a39a99aa1f9fc37c41de0177a9047e71bc8ba0007af325bc5fb44bedbafb72f2c135745fe75e0272416cc85132bbc451f3462a30fb8f9221490dddfa8739c9a87e3d6bced55dd3a7dd2fb2acc8cdd1a6c98968b0789bfc81a2ea95b84b2faaa830d37cc65be590ad2f9b815a247800a1a0cf6fc037e0a7f3c153d67b1cbbd39bfa09fb59100c848eaaa5b99d550de39c7c2467fea2ef6f424ed752326cffafe5318a045dde57ba17ed1e3c9e8419e1b5fe133593f0b08bb0fcf591c581f1dd455ca8d2cee7b96b5ff8b330009c3a4f24b7aa08d21c1f51df54cbeadd6367384699cc985e420f2b5e39112df969f7214f08d7f3d67103b49025dff06a363d676d5b777a17cb396917c5946e01212a080c3fc8a9ceb91986a2a6b9bb99da0470e520a823194ecea0e96dddac5b1a2863715482174a1c9bd6e7c7dcae5124278f8a3bdcc465e0382a55cd66d465041e535b2b9ee03fe84a9f0b9f43f5d4592e21cb701c9dc595c31c0da260b89ca4e18c0f24c9fbcd16b705a7491bd98736c00ff0a9eb2db093f1dcdbdc742731f7391343e5cd931e58ab8de78c2b24fcb70d2930bf765b1562a7a9590a9bef2b30722887323652c9f3ce48f5040d625573c99d84ad20f41df9a1c93d441ebaf8c0c6553689a93ec3cdc220988cdf61954b61f579bf625493bba9f1569f039a5229ead27e17c945bc1c372b7525f783806fade3613f5e5a335087561152341d7a23111a534875f1a98c6080ccd9ddd5f642fc114f3c120a084f0f4d7ab456951eedcc490c4067e1458aa636bcf969a736c2160bdba898a9bb8839d16b535351a65c877ef2472284e34727a4aeb868e8b1023b65124b7ebcd447357f7dcdf31d9972ee699b3f8730a2eeffbf1560995c30720ad87d546f41334698832d89b989fcced82ec5bb12b3806cf6a18155738675218bc0af4fceb0e63e6ccb50f8ff93c86a6d917bb2ec021a075545df6bc873519cd4ede337c71c7e0b758866e22401cbb2825fd65a81fedc2c11c07cad96eb021fe6db5f76b3e888f9dfe9f8b28ce997f7f3d60ddf6effac88c3e36b40c920d78d8bcc93b3b0f54237d54f8944986f9cc4ac2b113f48a039bb6c1d6f548f0b193c530ecbf067011ec897ffcfede1064583d795239dc8fee92eee669373276c7e42daef941e99ae329a334f6b06ca81c84a1831d0ee4eb79a865ea958957944a778cd2418686d7f6f1bf6edbe957d9cf067707dfec151c850e9fa993155182a89cd6db07781c0bfe594f0df20971382e5c8f4a553f1a5a0291bb1e0402ea77c4261f78b2352a80c36fd6220d6c1263fbcf600a9c7fd5646535b327175de31a5f0bfaa5d06b4de1605d8d5e00c95bbbea00451cbd9e7d447eae37c4c69d3555df3b5cbff2d70e835e4719b18fde883c100a9ae8fa15ced724471bba0bfe05d390737874420fe53762fbb1b72f471280854873a577259722b9565450bde271a6cea8c8c671cf9ee3fbd3bf9ddb546841353fcbfdf07d956eb35dceb5e35c1d80f7f8016428b87b966f87a4c2322f4ee5a12692df3ca6da41861db515585264b1ffa3c487be2a1448509da13d998db380ba8c8fb197147ba713756a6f3020fb1107499b16d88ef68c704ce17cd95474d59acfe704e501d85defe3fa7bfa85221516c8186dbee32a2c1e652f2690470f420acbc4c3fa1d74b0237d954220e191322177f37ae1eea05fc357a4873501ab707740ba8e84df77b08ff3378709b40d4919ae7b0277fd14ad70def0b2d773a5ab2612c3c2e6d3a0cae870ef71093691c92dbae6c35ebc59be649abef4fd99791eb0c151f230b3cb689e34f29cc63e8b00b87ffb57ea5a97e26f0deec684d34503559584c184210a3839c715af0154f04d6b2790a835350684d63443c3e204be25ef89257b338b7cc8de05c1d830696418b79c08edcbfaadb641e7aafa51a42cff1afac2b2643449d17da0c4b9dc445bac1592b5306a055564974b9dfc95682be99ea20676218585b6af3a2ed395798b7cb8c6d4fd0a9df305da5bea12fc797c175e07c7114dc6736857c7dc35b87baf5d79e5fb68bd4ca222a510cae5fbe5e5719d5d0c8c1283614e1ff0580ae1c74579c9173dc3da043ccf027596d4dc3452d2f417f72ccf819cf594e19f73f5de03cee0564c556667507221d284a6453f1703e9c0cc906016e99060e7b0fa3305003dc472b8d85792a0d9c778ab37856c514cc3366f7f9bb936e77e588dce9c8efebf47a6339112d165863a916a0d6ebd23f2ee972c92b11ed23434f13198442e8c39d7e0cbb5a7caff5b4110a1bc3e2a093f0f2dc4b93fbdcfdc69a44b7f0dabaa0d3b55f1071241dca66d8d6ee7786adf815d4677f84449bf97ebcf64a0195d49e101b1a9ac82b968519552e851d5a85ee85ba035d52de8d189dffc285880e6896805be7599158e43a72569e176544908aad8aedfff5ee2705e23f4caa756c1451c8520d72ede360803e405759431f66d1150e2126a61ae611fef8930ae8c4f66e69cc72b251b5cb92791d53acab38f79eb2fb5c5a1d486fd2bf0eda818da6b9d504b648b274561ba3f50d8e44cd9153c1b1ac8e152e8c299dc561af2fe6126e6b3bcb310f5b0a334bc8fb9bceaa4b3e4e35f9c68d39923389cfa7af40986bde9e6d9ec61fc0b4e283114ed596373cfb0b6f15d8bba132de4386f8bc8ecb205cb0c796015a74ed13acc149da2e615e204ca801028e531b8870ab5a0d3cce7d18940ca5c751288e975da8e4440d450c000380efee8dd94b7664e721fff26603de8dfe730ab1b037f7a2076cff32541afc25075b389cf5560be5784827cf794cdefca574e4797a5c22858d820f5f33f40bd13661f11beb6311c1450248a934d53302acc718a2405ce1c9764329d2c66766d440da460274db0c94155b2ab3efcb46eab2791ed05184cfb792d085e063c05fb1fde8da5744451f9dcae3b783069c465eced695678df8afeeac7b9911be59aea8efedb1d4597a897ea42b07e02e58f68b33411c24e013cec7941d524d7a4f0181b661452a35309b15f3fc5cd3b5b23b95c63ace3585a95e65855e5af600a663be5cff8f6315c6f83b4b7a126e9b3674a5bbb123f39dc8b8d30037514f771ec16a0321ff8b7498cd5e2791f0d8b3bfd8ea001a2af870da1792ede4bbbaac85c1c17605f670c90aeb98ae0556e81a64dec36642a537222924bb4d46273dab27a6e01110cb4939fdd3dfe9806356fa5c9894717639ccfd70a2370cf5aaef0b98a0fb5175257e9074dbff110e0bbc8b2daca5c43153b79ac4645ac07ceb301fade964815ec241c8f9f3ae992e0c3c93c9078b5e0d839d96bfca6304c7211152d8ccd9355b29bf28791365627689eac1a2942325a7296db2cd87f626891c96ef405bf2b028a1988db7f9889fa4dd41d5aff540a3d48e8671cfdd2fb7e33dce8776e95734c5dd899bc951c36fd6b1fc510879d19dd16fffd6047bcb563af132fbd94908c29c30ba07a1d47045e49921285f49630ae05f50dd4b251204710dd481024bdb37e87d4e4738bc943377ec3bb4805235e0713a69b9ff7eabbdb823f03271e924bdec280754b65714656588c1f9148f6479a4f629ed4ab36d7108159685bfc79a8cf47db319e62c50d9888ffb06621ae018f264a723d577b7bdb82537f07cef4ed0816f83d2f0b218f864ac572854958f51cce0f98aeb773bf3bda06fe9ed6d6a2084000e78b2d4d3ab8bb8100a698f8ea7eb901540e1ec8fc54f679cc4cd6bf427f653e5f61c343dec49b774a888a6569c1f97953a3f7250b76781dab6e2340b413320f2776333a5ce169f5cfd4a0ca4bbfa64b33344a80c5f4f42a88dc36f964e565ea1b9ba35150dff880e2f84913037ac3e0e8c7947ba126944927d8214157785beac9feee0a31fd11a683d9128b00e001007e8a8c7f82868913a785a3e7b781ca5f8d4df867fe92c32e530edb6be9e8cf602d0090c91a7f3297c46507bc3de9273a496b5151481731106575808dda5ed9749d5fcab9909623bc04a5ff8d4d008b4bbb25fb643323e4c11b6309fafb659f4d75848adc2e97f4c78013286f31917b8a031944ff77bf5635ff366910fb7e29e59dc88f140cb0afcc460e15801ac4bc6f92d0593430e80fd2ceb20d4da8969eb8a6e5d4e8e24704421487dc554c870b71309fc54d4ccad8fe3cf4e9fb7a1c71f8378277e55660934f7f092e7d37e27d18d3ac478fe2c3c61d74b019b1b9f4f9295d5dd9d4e01efa4d22cc36e9cca26fb7b244909e4808fe3ebc2f8d730e923ca270ec7d8ba2dde7397bead957bd21133d495b1dc552a266259c7b32a1bb53b58614e4420e630587dd288facce041dbea962e683a5e1b32def924022d6505b059078a8e41cf8e2e0905305d1b432c88428c8844ef83c6b8ad4cf6ec99904d2867b87a01bfb6810204a66bdfc9f8c326350dc42f684a2c7df4ad2c6d1eed1f89c369ed545ccc6a57f71a19926c484c32ffe323dda2ca9b7fbabc36bffc3addb6bc7cdc35c256be9324192ee7c1d562ca550938b2136c1e0d16f28ece6e17da8f7d35a156075ee10eedbf248ef2d62f195e768eddac1be2392ad2e94c1d33dbe057f34f8cb801a3fa899a4ac0ec0a7a32d215991e537bc23005ba9b8d6f82a0e9e36415993f68792ebd9236d15a59717a6ac6a3e6ec5ea94ff50e283765b0b892c4fffe9b1d9d0a328b3a7cbf1f6c1c6599c1fb4c4ed745292fb211c41df4e91fa86136a5a23724ffa5ef2b323919f08618968b3a3a2e8afdcb48cb5bb269fd1e9db288054ff8154a18d0c2d3bcf6f13835542ea4754180b264ac104d92576891b72c24f6820648844b710a3b2bdf4ba79dfed301cf29d1c1e501110a2aa66c7ed16a9e6900199e26982ab804e39b8185a0e9ec91b20ec56170ada97ad64bf180c05c1644b1af832b830d9377052d7b2669286b7d403897101e24c0aa69ae8f029673bc2fbef9c0f762b6d21ade1026872834bfdc34f1654adf8b0991b8c4ee9ade11c04b4560f7361d81de090679a4ce2b49855273c72be6457ed8ac0c683b69761ecbeb4f2ceca2d971eb0c97d4c9ff619e700569bd3a1768ad77e4ae0cdc2ebc293a37eef914f5d9b056309d1a06e6916e461080f3036a3c1d7c820fa47b6bde202011ea8160e494e436dd7c9cb7f571f5183b91796158475526637fc435dbb40c78e3751bf90a651ed2dc0cf0b68c7ac7c1daeb265878d3267f2efba13de5352cf948e2caf0fc10756d0469a697892da22648b611039edf50ff7d2494834646e5ccd0b7437fcf6daa0aa962c70926dd96fd69b8df2f1bf8a04fd9f479c9704a1f1b1092903e120f63b2ba7ebdfb621d442090da8891f9f7c0a239eb521b5a71c43f197f6d925d91121a42297695a1900637d835ae408c58150e17a5d22ca0b530e34d3d716906ee2fb249b5dfe367487412235845d325d9e638e50b3d699f35304feb528ab72d982e678bf15f0cc9c831f878a95d9679fc5c321bc49435c19e8a615d2f7275b7ae3c0f7e5e6b21207b700aebeffca9595b5a4db399a2abab3f061108a6074ec1b1ea8da7de31d6c1786d0925102d4a940658e74b8e44a64f7f1efbb013adf5bbf6294a0ff9975bc0799a6fb1deb79716fc56ad7cc2419b727eac6844b7f6d2fca0b03df0b8d9a6cacce6315cd175339da8850f353f4f53300e0121aa09795ad40fa1379a656af614c6fc4941918efbeda26df5e36572182ebc6053bd2c56cf44fe027be008d2f55cf169e6cd5968a8710ccee7edf386d182e6a601464d498d155eb2e4596050ba1bc079c0595c4ac1124aafdf685a8ec914a83e90de8c2c29e6767a3c405d59db7cbf2ec46d56578b5e72e220401deb19f7a617c64691f7391cbbb290ef0afab7df6b6d19139c457a869bf4042f072bd050af50a981d087cac93098f91d67a5c2a17ab27c5fd9adb57329692f7fdfdcf8872bc8b0ab81b421ef67502b1520cd416ef3f8ee4ba310dcd77235393249a1b417a4595d2b139bc9a1a41dcd4e14e0982d348761ca828a6676744e9bbcae26c5e9f33f5e70bec4f39049437e71fed362f27b64a6dd265043c4f96471a877e61bfd129970f85936627dd524c0f91823ef6abacf707efe51921fd4ada61d1ae172a94c73db1e97d71ea95fd431fa557a32ffd9f68a1d5eb4fac272d6d562e45cd1448ef7d3e1c1b210d12baa84719659be735cf8ba6863ce874650351690769ff3fd814bb30b24dbc0a90e879bc5c48ecd52076a92cfce95db5ddfb81fa7657e7c8381546a1d8d9dc499715e238497d519c092bf395232ef18106cb76f7f63d9d2630425cb8d721eb15908606922209570d0bb2e0a9eff554f03a63a797378b8abd941ad99b39dd13e012e8cbb5a5007916bc262f7b5bbddec371b3792532b54269d5f3a7524838ae9303e4c0b4f8e7de4f94c34aad7888a5f60c0d26f53ce92e624271865a2992239e0e776a2c2b161d1432c69164f6e636ef28234f815ab08cfaa367c987171810d5f3b3c0ad90f4cff3c26d63ea0473cb3b97e7b8a5464e7551e245132aaf9fa30d0a4b26b15c39ae5eff4d4fabe61306107a2acdc3d323a9db2c26010ca48fa7ecfe6364f245f58fcac537aeb84e0d221b70921ab34d2c0019e28e34775be0a6a51c3635b697d03e7ed3e452e20823ca29c91dd51bd7d272f9f09fbaa2e5f263d3f017b120b7a992996c7620b0cdd367e2c88f1b2b92ac111660928f235debe7e3661425e7401cec1f28866a2ade1d5972157c6f4e7557a490f655c4382a5e064e38e887072f8a50cb352dcfc614283334d422d2125aa555c92833a5fde2f669d80637c6d04914c9e7bc51489d81aa3ac8c7a497403efc5d7efba9bb696ed363073714b8dfbc59cda17a46d282d66968d084f55ace9708b484dd6b01425a96df0a9cdb63d832a16fa9ac7450a890312263a19fd4d5f3b27a210e703a4f11956b80efb1b81d3ee31902ad136ffeb934194fed49704ea37dc59f4be235524ce8ca7f17d4b381f7270f1077f5e4ac2a9de1d6321252ef517c0aa3985a4e6305822ff2fefc037fc3711a34307ffff6e2443a7589ffd7740fb45310a6d1a21ae212b9980124851928f803f7f1339fe579052504f5e7573bf6ef2186c44dad7157000679c3a545f50d6240f55c80184e9a3ceb35256e757a1847073bcc5b4b6f406744c1503cbb8b5eed46509462e3a8b7532734de04662b1b299175fa715f1b784321ecec389345b0afad8c0a0c58df1e8c42d754a7c4b14ad4ffdc6dc3c4c374b5284cef8b42ce613dfb833d0c98429e516e04afe9feb01ad4c77af6ec9cd3b5dd8f10565424565ea1fb558ddaa1383ac81cf483106f0fca42ddc987aee66d3116bb61f77f9def12219f9e20882465904a037d8955f333d2336d1529a68d6a5b6bcdc7d366c827d38386da1adc1337070db5375aa2692facab668335f217eeac4bc53b65447cc30b6d68abbc90c1c69d6874f15300bcdd65fe2859571944328c3c2498ba984898e37079a1f79881b5883e0270b94b31ed8ece9f3ecd6e77e6b094a3e9eb8254e374ac54b77c59c4ce1ab1cc19dd3b82599a1a595f06f3030089820ed3030277dd0cdedda0a0e78e2692730e69a5eb40d797c8ec07d05bd3bdacfb017aefaf26aed65c6859c92bf167347b7460bf01a9e372369a39a9080342796d2b4905d6fd9ebc51999399fba2319407057f374ed216d903c3c60b68cb5cf71467bb70105c555e3125fbf85bebee7c1c4f6990f98a90a3e533f4b6a82f688de53d43c3a70a912867cd9bc85f751de423651ebccaeafdad8d17e05fbc42437510723ce8a495021790c7bb2cdfd6794df08431731bf91492365cf183bff675fe92870ab836fde5ad7a040d87db0dc7e93a1f8519549d9354bda575ffdf467594e58cfdea347d837fa9665a8e970e8bb84dd34760365665b25d296251bb09d1e03366135ab7d16dcd646168ad7c20ed0bdf0ae784b3649bfc04c1d92af478db52ba87d88c53e86316b8ced4b57af488fd504789281c85fbeee1e7ee9f9111b6144841c0a964acb2855555765d92f318218ae83e60ed2bdcc80d4c87825a13406037cd5b7ef786bb4df4191a9a0effde09f641ffc6506016e14ce4c3c8e00a6108e33277b39d1ed4d027675853af884bd4c97665607a95ee4aee4e5623742af7ae611654cb06dd268961b61b77fc245921b5b24e981f95bc6091ac59531a2ce585ff8baf3629637fcd6f9e0a3c89aeb062fc9403fdca18611c181db3476ca4fcbfa3ba1bd2409d3c7ab7485f54f7c1f8834ca1c5227fd72e8c17534bf5580ea15142056f78b02686f753a8fb9ed2d9aeeeb16f7f2bf620c896620c9c80604d2159ae77a996c0436aab60d6a34b155e68ad23a4998c176d1a7e33dd4cd2ed41b686914e6c8846b993e0d4e710e05097f75d85e11bbe0209207119ffd3e1dd969e21857a8f21816a5b8f3add50554d10608ba97ff3ea47598f532bc967ff0ed77127232fb53a80aedddcc3a28adcc8f77185237ac314cb677349862a653eb4b9d10ebc9dc84e8299f42cfc3cd05b29552565e0851cbca9cc3884d0c6e03889a75bc6672b5a8496469daf7bc2af3c73773c96a43fefbeb657c3ddff38b5ed49bd17e928fd0448fb610febaefc1a1000bd8e9b1f361e17b116512fb3405f3fb59a5971709973ae5bc2c373b45cfa474b250eaff5b85498c30d4a0855cd801127021877a365a773c039d56993deb2e27b20530b6a198bf55384e2ec03f2fa78369529728896d84221d642dc4763fa5b66fcf3acc817e247bc40b67a377efa03e3056cb971665deb2bbe9ecd952b74c11a05c97002124a25b6e84bab5fc1a143f31f00a6b9691c5965afa93198da210af775cac3e08ec82599cd55d506d01ff7a6b16ce83592857b6190fcb8391cf5242537d8770c8a414e3e30c021c41385edbdda815c972e7ba112bac72065408759bf355d393c0e70355e7d45464a46c3d713d4948e6d41ec526d8d71c5dc441c4a52901ff530fd83e8c344ebe7641e81e718f3af6557864752acfccad908c9fa2a29fbcb352ba4763d89349dfc2388a54e9e9ac0cac5c9c68d1d0f12f2d4bd3dbb64d75db472a13d859833d4f2ea4895befadb9fdde019c883a109639409995734cf74ee85b36c22fec13c5a0942f6fe55d1739a43b9c70b4cb0b4cd632a6c6b38afdc44090f2352371bd8d47aac9ab44d49dbf140a11d1eace79e503d7664625787695a431b397194cc2841fa24a41633a7d157b7e5ed246c59318d6001d66e729256f2f50b9b89380bc8087de1cc5fb0bcc9107edfea8fcb0ae7e387328172037a46b1ae65f165a822899b83de16977ab76e7a214dd02fa91c21fa1b7cb2402538ca4ba08dceb4dc6f9a69ca72cb3e1fc60c055776a385471b6369d895dc17e16dd8930758d9de2155602778e9da6b557b6d438e3c64d1ea2b461ecff5fd49ebd5c9000f30b9b01fbbda38d9867a0b6e006e76f89c9d35f51712f24f70dfae1c8fab4fea399290133e4ffbf4da64c6c5ee882919d14028c3c5fa725566c0afd100f6e101fc6d8d0669c14cc6fbf8a357a30dafbfe8c9411f9aecf202a0e577b173dca2dc1b9cd45606ec1b9382bba7b4edea0b762ecaf20f0da981ba0a797d8ae5cfd49d667f01cde303f0a1fa57e09079175b265b0c649d746c2f08121fb3bf8366803d61bd0f264deab56aa9a884878c127bfb01c177c1ea19296b4dc41e9ce12826270602d51ea60c368d17fa584bb647d1a0f830ce43d189d8e23dba441a3f68696a7d3155ecf751f6b4ecf4c6b27b3914fe963ffef1fcdeaf8f934746df17a5faf47a949fda1caba1b32833fd872b1d054b0cec102b54c3d183afc277b19b48e4f1b6a4f8df11f2759836ff168cf7f6c50f9936763dad23a6fee4fc8351ede39fa354e078f937a3ab93bcc7fc7cae338d03f2a36d7f7d073703bd90bf6dd0664415b151690f51b79532b505ffc91267684a69cd9d7bdf09194177b4c88e97dc1a81de37af4d99ff0feeed04f65173609fdf2dad6d3401726bc23166155ad8125d6476bcead6292ad73ba6a35fce8bbcb33ec6266d09de1412059f6791ce3fbabb7d03ab742e30556797cdfc6aeaaaaa89f798e10bf3369739cc99fab7427835a6d961043d5cac6c454bc9d037f2fabc954e65af3b68ec1f42a909cbdee2af41a37938e49f42f4374db0fa8b59867888bf1d33799742e9302299f6fdf22078a90f6a2c7e7824ad3f66b1b6d3e712e08e838a1260c407fef00b9529954fb55c7e1b9da01d0dc0586bafb740344a8e08ebe10fe322917fb9710b4bcb13b3f8fe630597be52a33ac89b43d50c500960ec29e49c3cbffbd3eb94ca4645798f61d2847379b90d0f81c841b4fc77f18e94cb3c4695e0dc8e19874a3129c238ed7a78189b3669a617af15f8f9c870da686217ec514eff041df03a00d50bd27aaa82fc212c05a858e7bf7ccab0917a6ad1241efdd30e802ad54930ce7c346d9c130f0aaa7cf1c79bcff5eda93616a22ce4a9c6561d812c6cf306c3381c265df12d4383d81a0b2269ceabec744ab73ce43816afc43fe2ee35b8a2a9bb47accabe2f937da253f5a7602e9f56e990afbe9182428b59a939245e419e09cba6edb1f98ef1667249cc4e514f121f1fa9f6606a357647b6e4907311a764d3920227610658e325e1081dbdf512666398fcc5e6c4937f5639cb46b4956a0fde36e18418dc674b9c63306020d4d85bfb2d1de180cfbc89e44a073f55a742c827cb06bfaabdda067e55cfcca61eda29122490c09c91a93418f0df4a50314359fa6b8a4ef907de50eeabc6c32703c29b9438e5a813c18559b500bc52dacd49890c43edc6aad9a0fa5e6bfa6ef0144959efe9a102955d67c89a89f8bd0ba74e121eb4b5f31f01869dc9039968d54b15ebc6d986c23631b9105d8c0ec27f061b6197dfc39c72fd0adb9e602f768404592e47e149c7938e0e37f26eb11be7316ad57def8b039960cc5298c9f189c6e54bf6495037ddf540d4db59466d3d2d064a90449e5ab510eb728572fe6f1f2fe64fa7eed937e175a8191ba4579b151dc08d675d913b6a49f9e2b76e8cf5ef14ba1c132732cffdc00c22f2b71d40833da258cf834784e4de906941c5d712e52561b49a693753257320904164f952fd614030d96bb58606421145c55a2a1f090944dc2003d0d44b6b2dd062a4d0ac0064f24f6ddb96f7f53a61b62d3ec8075f162231dfd803ed8abe4202436cf96c55f6d79765003e2fb869c6cb20270df291a5c6e526871d8d81c896cafdca211564ce66eafd088768d8d54ed65ee2d5e7b1cc710bde9b09b6fc64b137237be4c26d8f217cbb2b3154c2111f83744087852fe0af76ee03865c88972ecba540c39df80e0213e395fa71c78243de8e3e32ee46365e699473959d9d0508fdae37cfa6e1e43db039835401b49a480bc526ca42b5e8afd3fd174eb49b1b7f3a203f52fc69e70aa86d58c5e1b19a5f85cdab379b8d532dbcb7769e4a71d9d970bdc8c5a9d7d9470b9a11d687605ba2a0876221d1165996219e3c6afa54df5119d6bc0b3501f4437d7968646788c951f7d336bd3c5550d37fac7e09e0d27ab08bfc7f292643a0415828ae13ce476055e57c83fea618389ceab0932e3dceefd7e923ad2ec0315bfdb06d150b1029793e6cef69aaca5564f6154d0c0c2a6e9ae46a2c9bd874f8cce0aecc0d1a6e871d52d53dfe4cd56ebda5a741e8cf5404250c076052311ca873b6d3949031efcaee4c12643f35cbaab9d0d0ab1f03b0f23ef8a61025d2c310185ebe86c91cc753d265463ececc63fbf7f92cf29a4768c5605805b6913fd642cf49afef5144ea2a74e9ecdb2881cd6fe2362a470158fbe615880e4d6a46a22f93ed5cb7c65b3545760a290043bc1e4eb6fdf59363a5f7606724a02d7025c0610704cae9408c66fcdcbf16c186ca3bd2c15193640f079930de26a325b4d0bfa6cc834b6c2b3d6bfbd9d5a1f1481d88978efbbe5ee80a6cef8dc4361a1f91895e4896aac407a3f1b6525de7991f5e8250813ffe3f9eec0a8b42fc48e11a3808a09b25a4179e7811347db87810c6e0e9d98f8cc6b17fa50e127c3a3d50677be625d6d649d9eda5b41de097617c9afec0141955f2051e1ef01d11a5c6628cb09c2d05883cd7bf86c2f4af26cb818ca60171d3be65e9ce560d94dc2571fba3d9ff219ed6a340308f97ff53db47ef880b3b0f444bd8aa41c5cf94874a8174554c58141c078b2551ed0d0f11c61d2cdb0b18e3b301b31a1862a3aceba430f2aa3fa9b78484673ddf087eb28f63f284fb6febda12febb4c126e2173f0170ff9d893be3b4b994e53cdc04e98fd3147adc15ace261cb5a714d5991451dd1b885101c0e845f5543f5e4dd418f1ff579f758cba1489c3e9a7444be27572a6fac5d8500d4e3cdc090cf6d71c2598142dd301ed6c8cdf2112a94817b0a8e069921f995ae2020a2b85d981492c02d9985ba9ab0b4aebd7128bb4ddffcec5d979c92e932fcc34593dd3827b5c47413d80b6867c89e6e1603b7a4bda68de33b399180b501a9f5ec3712cc6e9207ef40a529c2b0dd8502b9f1bf33e7ab94f6ee80a2de549b5e660652d2b268e52d2bc14c3eed03a6305ac0ff24ba838396a54a08698dc5d432fb3a52f808e50cd03bcf05cc3345b94b6190a5edcc8d59fa6f03e3f05aa5d7067cd7e004aaf32b60135e85451f891fc37c02265186626b2698e697d3b15e011920361f6f32729ad13fb38a268bf119a7c5d2d5ae670392baf4667408c20a18e0b0d7fa11f1f36189f3f1a6bdd66545429264bc03694755dae96b5e016ad75b4b648ce0ca9ca3cc5d8ac3a2e38c35710fab539b9d0246e8c7cb08a7e5039d2b22ca4a45e21ab1dd7cdad06de94d4eb4210e518c7fc2c77bd5c1b5b6e98c8579959a4807d9519d2f825ba74c0bcd244ac5981e5114738e3e42f66b1dd03f6550ae7f31dbe378f94ac236276f85fa0dfcf81a63013d9fdf36045c367d760eed24f34d0169d409ff0de5d14be37a8ed98ed1317d58fb1c7a346b143bdb8a5fa6fda49b6a5ad46da1397030d3c07143b17d4bc0b9b55ac13b34d8f9d405b7440a923eb0578d5953f3aeefc87da9843591f33c5dcdff4d9f931f67f92a1bfe6153aa7adf534c5cb97b349a683fa8d15dcf152ff0a3cc6a02bd17bb715287ebc2c90016f59ffee71e5faaa4b78745a6cb709ea1db27a45eade7f7b5d73847434a5ace1ce6bc1d36ed95ddc6a7e92c8b1f05d76b9484f337b0af4580eb4c1f448fda4f9e288a19805511633c352ce40c73ea220403bc4a5c84d110f65751e24f3200461662502b224bd35baa38c6c93d3a9566903c20d57011b5c1dda0767ef7f337161d81f22de8e0854ddc822cf23bc75f086fc6022bd30ef4efd5de9d0b3f48fec4e9274b832f4db47a36c777fbd53a30c03e647914e7f1a1ee9a4219cf34330288067dc60f5e8f89d1f0dcab15ed9fdba620c9967fbbeba453559816797334041fbb8ae048b005e8f3a78d01cd912dae74d7fc5c903ba5b21421ffd89bf88961c9bacafc99818a79530fa1fa5048cd824288d4ba90284b05ebba7141df0ff0e27ce3a70ff1654c27ba65db8838c715a32fc9833aba320a289d9e6bd993c5711cb4648397d5733a4a52f6976617cb4803b05e1c0a42c7dff97d387f638129844acfb8b569f8ad6bf3896dc4d708beee63c3f668405b220e8688ede86bf479111702e86cc061da8969eb2a87141c953cf430aefa8dbf30e41836d6e4ea760eed1f55c752b992c08aa213b9110415d97eaebd59067c33a77ba0f0b43de6a852491e001727b7c7683c48f7981eb5ecacbe8866c0528bcd469dc862678fa28ae2048b4d7b13cd405857bdd00a01eb1d045bdb20f398daf490a5314761eb989dfe77e9bb0709d33dfdae94db1f6879743b600952a3672cb840a1db3cc8ee75d2f0889ae4e5f859bff0b607e9bedbd2a25fdddeb83d32bcf29f5448f72ab852c606d388a47855b420d4534a90329e8f61ec89691513cec9b74fe2eb420f5c53379daa3f6a5d3d5ea55c2581b59718bc994b430bac1e7d1579587423364ae4f6c113bf7979e6e349d137dcfebb0d2503772134aa966b84defa2907c1e2047392590db744c2e4d77dfa4902861c0c458c954ce3b0b1624694043c341cd1829f4ae500f49d3c48adb06669bafeee1f2fdd5dc9cf633a2cbe63da8a1285886678a123b3108147153da3b919b0a92d3014e923930027500d07c615ae1a99f53efb23a728c07827cac8f990242eb0310c954b4d8eecd994f66d045d0bdfd81e6f1bd3a76a64aab24374aadce56d8af581134ad49d422f8c5021e7370ec2a04bbb05d7b1be62d1d846f8022146b4858c3ca8a107e32932275ae13d7474ce2118369f0fe0b7040c6c924187aee126fd5e52fc4482d9a922c1096a87f882195e0d0e9f264ba8f7ec85e500d62252ad07f649ed277bb6afc4d024347811003237d22c274a4676bffb276a0251297f5d302eb6994bbe4483dc60e0a5540154cf97d339262f775d94d7b8d0509601c67e2a39876bfeabec4d74664bae347d09a4dc9d34ccfe49fdda2e9bf8a0bc80126c8b5fda4a1c8dabffa316f85fba1117f2a0b7bb636c2eda3171380a4a210b8e6f3ebd1b4ede22220c5ff17a31b8da7de9d4fe368294e375f4c3c79b424b173389641b9b79fee3cb488f266dad263cfb59e8693ca13147798f9c031515d264bbad677d265c9b39215d353c2018582db0b1c87c8d55485a6011beba6f9db0311015eaca860d6e943db436925cf05a4a404b6c8ea5a10fbab3a7865561f5d8a9754d315b7fac7c8c48ec91fecb7eac892c8604a4ad299ea1c2a608eecd770b829be75691badc5fb888d6efef25b347930991a37bfadd208055bff7d9e7286b6468db16c6fd0cc26c40c87af53d0ea68fad442f42cc35f74f1bd5f6c118f097aec3caa7a8e497de0e51e5af4f85ff04f020bd26d48c3e7f4a398388ea33d4d7fde08f86865f206612324553a892d06afb6126ee9cdfbdc1ba9a844ed8d65366fe91091081046ed6891dbd290151f1d6e547ee28a2c5ecd5f7c732c02a7b3ba133e2eea1ad7b2f9b2143bf51ecd5374f9fc9be8847d714e2e443669d4f996a3de3a140914252ffc10ce8f462931afad30c764272b272cbf28b84f37bfad7acfd66521b719542defe123995b9a78d130d7547637ff149c7ca1472fc28b8c109e70dd2066f0d7b70562eb49de82b3957c7aa6cf8726098da9a3e2d5428e5cafdb5a6ecb8578af446ded832a10bff08e13bdf624f4bde7573fe8b4da148a6efcd40d465f9b77569e0a3936a6856fbde9f7649ffcb621bfca2401871aeda6d708b1718017bb34178b0922c0f328fff1cf2e6785d837875f032c20a9718e017a9a41b6f4965e5df5fcee1b88bfdcd1b384a341fdcf210657c0fbd81030d378c05c0933d371e07d6140fe9e5c29fec09d8088205d2ba0e3736c86713d52f4a44","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
