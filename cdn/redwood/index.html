<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6142d94784ad677b560bda730bf13237350dea0bc90ead2feb6d01b87bbf813ca8207b98250f01f789f98dd98efee8db1110480a3cc92c689a63c6a09fc3497a603490ea52ff1e3458e7cd878631ecb0d204dc275d946de46cf1141ba284c2a62081543dd1fc31d6c951e88001a21361f9f2b11b6f93e8c507cb77ed2f890654387fb2d0273b13214f0b0ccb60dfa89687c878faed6caa86c1e7736c5cd34a9f9388f3336c7add7157f510575e6df955364aaa35393ba27e073df57bdc4eb0e07edcf16613bd4f6dcdebe374bfc2eceec4c1f4837a56ac170c6e6c5c3883bdc00a46a624c940b1f0cc481f781ff896662637b7e26af1e0bf6f05b5b35e3d34f6241c77bdf607542d82642125282ea30c60732f535369940c9cc81188fded3d9148864a6a71a484514f922ca72e35cbf917205f038e3adb4b11f5b5675c6c61c6dc05199ba6b65c17f80faeb83d92f01214859f2f06afb7e0ce3782a6acc6cd4dbfcfb1e40fe698fdd502882e1d6e3acd73b753af47d4facd6b1e7fb6d87e4766cfab03a5cd994985650bdf7bb4deff573c1cda9356afa2bf430932a7b506a56dee806120339e355cda325c805cc75b9777325fa52eaeee1dca36a70621b10201d8d7df7b629315041813ee96d8e98b149e5313182f21d6ae00fe7b305197761f286553872f7a9cfb606374712a0695650733ec12e380abb897eecd7d8b8a03db0bb922ff89d2c4931facecd1ce765adc657eaef60237eca55edfb6d08e9e4ad0e9a66b8186c64e6f3aff7191e38faea26f364e6339e513295f6b3dd51c4d5a004661142962588d647c71dd54f16e59be3ab34cee8fe551b7c54b4cbe07173461c4f4d0d3213fab8344a15f1e95b2670d7030c763bb4b6a89a82de693043f2db3777504bcc9839a8f6238aeabc3050f064833f884d63560b34f203611dcd776b196fb26112379ea23014dba6a1af24bf0079e770098741456a861cf169555a3ffb164e687d3ac160dca284a8bff1f77e0fd6e77e0f509bbbfc21cb115153b4dd452a98399e4e64df56bdf6a54f909e292708ee095b2bf8048daa7ac716a65db10c8f55b31f17de9a19a68c5ba4696e0cf9aae1ad57b72fb1c52aa5d0508e85e6a953b8ce1b1acf44c36b0f2b18327fa08ea300be72a8d310c5459e4d9dee5d53ca8fedc0a527bf7c672e9c2531124436c6a44fa541db1fd7b6b188c190ab37b7c05909b030d68090d54a7be503984ac7c89b3829a7a08f0d3d685465836e49a5cdd824bfd2cb1776b8498b4ff52ec4d94bad94706382217cf790eba43e0bf2dd548bc7b972cec4350bd38b9f1eee352cacb595bca8990da64e5bfecc5bf3a677262f49f57c7e8e14fa880c22a6adaae573de749aa1c105e0c25026755e4ab0dc10eaf0b435fb53aa1d012b0541f63408a99c1c4072cf9babe37a0af021de17a795a5e102cf6841b74f9691ca9e05b275d4d8fa1251559e75babec93c311e7ba849855a9c2960c35a08f27b69dfb4920e029bb3532e6ad9e2c5f763232a570293dabf9c5ddb82286ec17b0cd235abc8f0155aca225ed4c4bb9d00ee2e3293d3961f960c02489ca32826393ceb0d4794874c7a5b6af7055fb5e14bc84f099f26274bdf5006e68b6947f573fa9082ed3af2ed8f4e7199e4663d671edf5a753dc328571893bec319e5621a4f9b5332cbc02fc97033ed9121e3fb88e682be35110eb96e0e80ab8671fce280e440f01ea78e822806d6d96aec4ea15401ec26d1cf31fb7aad515676374c2d8b0fbdcaa74af72fcad26bc317cbc3c0e372cd228ec23fa59ccea50e8178432aed09eab4c008bf10f2aa56878caba4d647225cf8aca86f22de56edc32da07dbb01903d010297d36317ec0428c8fa950ec4a1ca3d5dcff0d5981d778cac7b852843f6b6cba11f56b232bf0aff184a5379c2a440548f8e5c53958054cfadd6e8ae89ff0da84d46f73d7288e44d6540954244df10b170d36677bebf1b57fc94ad0b63deafa703ead84835f4735fdfb7dba05b33b7597168151a7d665eed958c3f996c36f0739495d1cb4525678d86801c4cc040a64260ace8e47959f6eaf4a9af6ca0528c98afdbb99e6a8dff5d59eed774d2a8619e437cbde221ac5cd20ba5d0a602c0ebe7a55555756e70676f09e16c72425051f2908d55a505507f4a72b5d6a973149496d3dfa7513e3bf1465a5242d0770e0586c974493d2da4fe41c7e543131dda12cabbb1d5fa4422dfe6ca36ecbe531b2f56e80ba7d3adde3a40cf6067a24235b6eef34d2b7365d78a6a920bbdf7e7a504ead5f3b02bd0a9352b19f6f5f730e99a0763a81ba52c57b9cd62dc222923e7ac8e54d3a44e6fc287b061b2ef610b81c74eee46fb3d3ddeafd224eac817cdd83f0e4412ece26e3868eb9f62696dfdf78d242f5734ffa9d226fa37b17d823e8f41359bd063b3b4bd5f9a1efdd60e190b2f28f92c43c8ba47d05510739e8049b2d4a6e4510659ced7efb4d499a16e11aa5f7f1a7dba0138c5f4c6a5c759895b6f69488e32dec8a9bb9f81938a6783117b72b0df2e2fdabce2a0d9ce2a8af00f6186dcfdb16751d516ed189890d47cb5f6b8bae7c12c61baebcabda40074f6443e393c1c35bbe79113aec6bc9968b39b90867d486d8b8eedf733042afeb55f438f71c52f2f082749a10243d5c093f2ddac5b609bcc4924de29c21ad1ef4fad32cb19474a5339ea5c2474eedd78ae0263a98c70f6a4f2f9ce272eb6ccac533d63d3c41c55e2fb0037882ba892fc6ee906ef41fffd891ad99fb5e8c9846cc19795837a0e715067019247ef70c8694e2286fd4b2d7dc1f4a9c2f3a6209e0f496a590997484353e7798207710676f6f083c9b415055f0a606384ecae98f3852081915df81710ba457a82ed02bb777f8d9aad3698383abc1e7fa4cd904dcb282d6ee0864f2d4b1041695edacea35402151d1730780095dab30146192670e0e1cb6eff2250e4ab233d68229c3039bf92197462aa97f3f8db05f2e13a0be08586493495cd67ca90657d4d11db85d31b6e79b0289fe00e6eefc8d8d921672e32076f12bcc3668462a15fd9c63ad0131a73aa8b468851ea44541336ed8dffc4025a46bbe7210dcacc4fec8e06eee869ea3231dea4a10e1e8396b42c6f8fc0108d937ac8e0be02db1d3717df9be832f25151d5a7c7c0a22135c0ddc68eaf3176636d5a0a54c464735cc1802dc81734dd09c7b6f859b938f2b99180cb48d11c053634e6fc2c696a41ce51a1227205fb16fdbd77881d9a2e74054d355178ad0cc6577830811b29028eebb369dec52e5d9dcf1147415b0281ad3c0469cb2d94c43a06193a9f08679d232f7bafce1e4c3bc0dca55ffd734b7aa586b3663f97cdcf19d313bd521efba10e181e03e8f6bf2e021ee0e4b0997fe018f3e0e4b2f7180edd6b188c420fd61532e04d182e79f76acd909ff98526602bf9c0face341caafceb9d4a5113edddd5772c95a2cac349ff42a56d1958157510c835c4fa26c3295b95f62cf0b7330dc1d7ec4aa2be4cf2f1585ab57aa8a597ecdd53291ffd29b5b105b5899bf81684bf30e68223d72f7737464271982028ac358e7b413da72e4775573330d789b54aacd250b39f08c484b799c90d6511e7cf335d4a1feac11cebcbac9c5d71a10cb272d0ab50018c80ead8d0c903b3d1c0ba8e3a5a7935a13102a638aad730c68549fe72f5f6e57b834ec25faa628861190562d6db2e3b58b03d1028bf9f809f15bb5a12d131cda7ac9b3646503443c9bf6c149983378d3a9faf22b9b48c6d20d95c8779f7c981c2cbe6bc13b225d4345eaa0218d087f5b9333d873e29475af48796210989407946a16b1bf37f2d0106f58374c5480beac9cfd9bd5f6c51e54857e2390a3d10a6f08d59985a9edbc8a58884b2b848ac94060033a7379db6888948f5eed6469a86423c640f1c1389dff8e03c67345eae4e8e4cc73e6b2257f90aac423c5c98d096189aade645f10617d38c74dc4c2ae636791579c33a2620d71cbcb6832298cb4609c6c922aa5d5a2267fa0564ed35777fe605c72f318c2dd6c89b1b92034d783ce369d36a6e467e65fe8050540d22d103ce32fe03e9d985a695cd4d46365256b71fe42113c97401a7d6dcf748c878fd9d4908c2345fe5159e35571581296c9d2d328e50a4b38ff3f8a077be13d1530232d142d07cd6f97be38acc3e370764eda7c3b0d3498cc3356e68a107f27a696cc1649c5dfc18430c6f7ac8fe95ba4a07b9a0f7a3850fb44228ceac34ce9cc2494398cc2904114e09824acc8d5d003f9f0a00042d59e8291447782b157243ea7a93035e7a1b5ad9c66d7cec0c356043fe73f1ace53dd53cc279b5c6fa2cb645246318d4546e19e51ec2e52e608367e52d9e23965825205eb81f29fa6821b4ee52ff0cbc7e7496ba26b693681f9c495078ce018d6482cf68c6d7d408a9f5f0024c35f3dc3d404c738763643af8bb1e12e0db0682a53b1157f4ff80f1d01933ff092b032abf46bd9713fa66b58a0ecfec865b8e4a5a28785928ff8947001482dc31935aef64c9bf8d33327d76dda196b98255997a1bcea005ba640327ff4bbcf838c467adcb7498ecd0679729916d6b9faeb0fc987389635c24fce0440f4ddc92792b977df8f4fa1ba2e7cb6dba62cc740645071d66bcd03ddcade5f61b5b2aa29489184cb97b4b0db063d786b8e77d6b415a346e7f199c8a8689836c03d2b68535c5f29d50f3ff9d50e8fbb409b20ed449dacaa69db5aa6cfb1b24be7ac2695cc75727220390d342bab777c964632a7bd6a0ac3600f4278fff4414d9b2a2bac7bef95a28c6baa0558a2940b627220d2732a2f3099dd64296de5c0d030e34498f2d2fee49967998cbc65b8ff905e15d5f307494f62636eaabcca274dc3bc2ac1ae2f83fb44f9d16b0af5acef3e91ae785427727fbdf7524525c9014de518e0c88b3b4bf0a08fb58ffa4c6ea29f379d9538b4f2347893decb4e55730714b7f99375f7ae2edca74a3f8ec3c1686366b20a7f83247417cb0deab18a5992bd829e107798db46438489f490470090ee6287ca5759090cb8c42445b9befc88ce495bcd421d17d51768f1e3254e89d5a99fbd25dba31ff54d4c4161c41b8abc60040adb1aaed1b85e863d3450c83dade027d44e1c5541064c214aed799a83444df5f531d9336e1373756853e7af92c6701469c77a81dfa76451b6bdd368edacf18fb83eb8103af1d9429cc96f7d0b997549aa0574c497e39a924411d0e1e41bfc4000d6ad2a3fc45c6d1d8d7f6e95ad26e2a591be72821c4b23421981048fa6149dfd5d259215adf673dbd8097d13b488b441fe64c8af9d3f4308a069f4b382ec964c5e93333f0f678aa7df3daf9f2f6aa6fa064d429ea9044272717401ef00a05bf318ec5a3edbfb6bcdad65ef7d3c8e78bf0219450a8767ecbc2093b965e8b334b2eb30b8be62ca504ed7303bf61cd87a4896fae3c61e2269715669303da5432cac53c6136a91c919de6d266077e9ec1e3da44c8dda0cc0b1a302b8e28fbcd9fe2dc21c2a1c3fa392ca7d7b92a2018d248f780a50e56d7b574cf7030d83f7c8d711cf8198c7b6a3dbcda10f67dae7c03f077435ee5cde180c809c4e1626346baa94514262267b48de6607ff30c7e3c17c952d98beed9aea97066f40fb2d991fb4806f47704553214bf42cffc168e2cac15f4d8b0df1f842b5fc9fd67b1b91c13121091e4a2b3226451382214d0365b0154619fc8e1e529a58a6d56191682ffd596a822d12ccccb837ce949c32dce3dae8abec93aa123344de38bcb63c8e6c340d38e094b5f3870973e0ae99b7e7df695ff15f65376c479ee7b9be2e8372c5dff1f429c83d9cfeb8242e2991fd72813217006684c77e3474d33423c7ee7751ae5f2622899b641383c4b56c08af3085f61216efee7ee74a691d80b5daae8facb77d3448e1b3ae5949024ec080c1e238f48604c179c05fad8744c7ce1ad30870bb8dfc90551aaee6c45a2e9b5d0dbf6a051fe1d2929fcb5ad3013038d43f437804aed90a97550065fffe46ae7250935a7cdcc845ac8aaa25903c146dee8607cdb7dd26536208d5ecf0abf883ef08d8f4a2f712a80e34dd0a60f0895f4e7f15f8a136fa6f04afe74bec2a16ab5b238a560cfa0745ebb23ce928b0ef9a567e32645e2a2354a304cbc9a9d84c5e4d8c4d109423effd0114aaa4b48ed8e7de329a4dfe788d46dd2ba722782af710af6c884f3ead9f2a1af50d2ce54137f13740c2e3420a16c455d2201963c911ee93f7a3a9ea90dedb9a9e9f3ad0487671e91efe6ddeff5eabf3f9fd80915dd487b1199c688eaa644d12f4589d1a1bd9b86a77d2f61acb7494035c848b0665dccddffa1b437658d1bb7e37713a5cead2e9a36787c34cf010100b7d47c2b0658ea6aabc03f65476501dd398f46ae2700a3c6cdc90aa4a808f7ecce5947599d870d2050a1e65314e81a575a04bdace5e5d1cc8b996cf5a3e4e0ad3a58945182caf4bd3b1cd197d22e88db37f64ca319b18831d88aae9d40e988923b62d68f864cb3df7b40d3a1e9fc1fbfe7883c8b88f09ca295d5018844c2e15e7128e2d22207104cdf85ea1adedcdf7098f9f6e207f9cd7a1605ca89a86c8d5d9e3e6265e0dff42cc7b0479da084a601a96836b2c8d9134616121d73ab747ee1c5148eadb9b9002ee28039b31e16b945116008facf29df3021177b5ba12dd23b87765c41f554fa2e33bfac43019de17ded739b7a0ddcd8fa0a95b9ac0a3913527fc5819234020804a99145aa03f96565088fe3461c2d336ca6a60af8f5c729c073f5895713fe33d25db967cb8f3fb1cd9724515fceb25daafd48a1fba1afb92a08c52a71f450405d6e262f4167091aae0756258248eb5610ebcfe345ee86e0c9ee0adb98567d8d4d2b0d89974ec5dfeee26c8960ebcac7002c20eb71025e61d2933e72fc4d7e2bcf945555f85a843243ddb99b3842291c7b4a5824dc0f72ca73432eade20296272be34b2f63d1adcb1d69bdc5ab12c1079f39cdfa5d31684a20c3f751b1e29f6e51f26d5e1451300072b0121a69f4c7fde9ffc92ea0eb5457512c59259ac0e68e871c882d6f7be75d0106da6e71da88fcf6d00aaf334be3b9d508d25d5cec18b22dcb431e80d0dec7b689716456f1a08a0a450cc805091bdfccfbc06201d1fe70a7c89991daa1f1dbc2df8c9f038d4766ee4447fea813376f2b1ec295d62830cba80d1f9f5799f53d746c5ef6d88f4e8dbe365980747c98250cdd32c0c7e33237aeb117941a8f2e0101e02866fdaee6d7c03dbaae9f740604ef7f77a26d509276b2d7677037d58b58c1b507798702677cb47a84c5ce691f532dbba163c08325c5264d03b03f8ed98b5cc066407b9ffb190ba4dcb8d98f5e31006dd3363bf87446a0ebdfdbdbae4fcdfb88b01f69fbe25d3cdf374d47bd73675dc2a3f80656319a506875694df717f47b256db3f202b87bbf983a92e09e6eccab9f459e4a5c5f86d2744e116449d86a59cdab96fc1641068127b2a9691fb060f28a0ffa48b6ed0591b8bd1c653972a65b5753b1b3057897e3fd1004fcfe378a9aac9bb794bcfe7c91388861fe02f7f292199a94dda1ea56f7c46ff2c817e85e30d976bc9202af1b29d9f6bfc9eae8dca7a3e779d87551364ad79e5b5fc947e8cdf782f623e0ad3afb81ac38c23d752eff8eb65712e421c20bc5a12b1a169e8ef8d508026ce9d629fe74795ad6e81c4383044d99dc6b55e9b674149f83db7fbe053eb786e58e616a5f1548b570894bdd4f564dcb1bbca20b726a52329d80f2ed4665ddf58b54313f983788d4a59edeaea48d7be42db61c128955fcd8455de5bf925b9aa9d13956a7f2e2978275ffaa28a6ab3d0e8eb5d7d68ccf392837899c23ff620fa85edfaca372fff343d8637abd755a999ef61f63d4c3a3844b957c43e63d55be9d53e07a3acf43f8e80b697c38d570908e7e65b5d625ef28ba751d6b1e0b97a8452ed7a034fc19f1fb9259da72f4b85054e731c12b4ecd7eb9f60879ee30ed4ea01b9ff5919f943bbd48b1a26ee2500938465372e9911821d0eac1944bff6de77013b99b57d41d9f1f5f6257b83396056921191adb33b4c7fb761fa9fbc24aa19f01f7e6a523c56ab3da951280bb34063725e4974d500afb870363fd870cfc1aadb19dd76fa3bd5256c7b83e18c0d54f73240b23eab01cebfab610a9f5a4f12af20dc692e2e7e093d9649a35d17463df8950f55e0a04d75e0d9b38b28473243dcc516afe6bc282eea5f5deadaeefe88f3dec6d820600b030abd8e96465f61549b9fb892d34a6913adcedbeffa554a74ea303668f313c8478365cd830ebb26f0928ead54713378b378f2bd71b730bb2a2618fc8eade79c07dd56aa1ec64eeb540620de931566edfcfbaa7260b929587b32116bda43c56712e0e476422bcf99ba86ae3bd7944ae06c12927de80f4e9a1bbae7762c2db4b0522a23d1cc0abc721669fd2cf239239f1aa937015677dea2541e53b8ec611e98725e9345e39fd3c3a155903d6e19eb6dcc42c2523a8495a92e6199ca49b4c19406b2a9ddfcd560d0e61a94acefe71afae659429f269e20a7295e71e4b5a98baa8f17d51e8e5fe50cdd12c78b7e905d65452714438fa58cba8c91b63419c7cf49d79c9ab00296978c1b865dd5bb37cfc0bb232c0da11c8d261c31fab41a03f0de381afbc345f40c40a9f75561247e78783b640a5589a3f65f0b3dc32392e20b105309e3a7d9eb39c50f8cd5cc921679fc172d50495139a36cbc3004af514121e6c40fd5a487e4657e5bd6678df517d357c0646a6cc5a0604fbb92e3abd08119e92bc23c37398f0d66364983d8bd58b2f39340f760a3eaef8fd54f70dc6a1c479fd938feca219aac5f579dc70e32dacbac8023fe212f2e69f0bd5f7bb0498fc77a40ee4199683613c896f2b5612c60c5719cdb6d2b488b562b59c42d5b1c13f64bcfd9e8f1d3b7326c226b835d78df39dfc193d74b9ba01eaed3a77c08b73e66a08028e9e9cc34a45549dc07ec4bdda8f2f2273bb64bd42cc9fc4664f8993f29cf2bc2d034dbd731a619dab38b171decc7075717ef05f19ba25a89fef26dc8628014249464cdbfa36c4871f0b715d9a4b4dbffc24f8beee003f59f33cd77c73aefc8f72a86843a33f769c43f9b76a52b1c0243b989964566aaa65086d5ab6f44c72ee775779ee99bf8cadd2cb57014df0107614d79bd150d124ae570a833c8581fb5839de1eaa08f697c0a951d12f89ab310848a1ed5f61f19d1a292443425a1d4566e7d17c285070061a77c8b97429369c1daba4f68683fa2b72b69574e4188fdcfd652561e1f2e134d80205917090fda6aed4edfdeaf6f88d9cc3e5f3857e93d44b10645c6079028cec73248a3e990777e58fbd98f26f1adde8abbcaa7e7abe203e22509d9b8ee737643b3f8783b22dd0c488b78bf2a08c05a920751454f453422831384e2b465d4af37fc771f7818bc2699eb41c5d146807b7c5e6bd3ef6b0b328a79638795232f6981d0acdc0cd93510cae2e8bac3336f72b5ee0ea6e2e5eeb0e50450b6f94fc8896d65ecfaaeb6f8cefd542c6c13cf90b3104012c699863a319b3b15c3ac32e63e8d99d7b743ec1d3ae2ee4389c509d2e8f17a925ff10e1f40f607a2f35926b5df3d5888ac6010942e155b8e32a984cf7ac05ddb55d90295bb13cf1a127a89575f09de3b9350e9b1a4533e92806f332cb12fe77c44ecd2357cefa02bb7d4ba6dcdf20e9d763700b10e3939c6b2d53e12c28c07b72375615cef17f3ec22de33cfb064b4303a156082a1848bdbec576eb25660ae108c5963bd566c67f414271d3d425955c4ced0328ef566fbf7c8a99a3db1fc5c919e73cf6f8f8c4f53420d389c12646359cd01285c4976a85f351103106e034967201a8ae3d5e89fec3eca2ea3143b2717c94ec9f5ab46bbad3868892dee6b23a08d08d26a27ed0e515fea58c75dbd8f74768065a3a444280ed71a0e929e76c97558ff2ddaf29141bd3f853501b4e58f10b421ed316c97c90f542cbbf7197f52a7c3d6f0fe891dc8c800a6679992b336ff7643cadb2efa98831a641be9d89e590a5902b674d1bc6425e1fa8729891eecd9d3f52a25240aad7e6fdde1defe74bf7d503fe620ce0cfe1a18de9bbdff84524632aa7d161409824161a84363825f4b954b3d6f778d0c710097988f4ee4ffa28675fb05599e1568f8d0a935924fd879fc30f24a750778ec29be2339587ad6eb095dfaad63ea1823517d9f369320467e957c78131db242bfd08f615d0ab60a69b1c997256d3b7758cee99a62cf1b123ebd798285e2a67c9aea33279a6f33e93a65dbb28ef541aca76faf65675460ea421a786f71231c5717c2614a1ad0e5fcf546877f57d6e14c753c21bdde086dad6afa95ddddd762c0e6b790b874b7c1942a26cc259374d3ec6ab59d70cbbb380cd0f3f34f180e1e3d207e606a0d24002eda1963531759f763b11be7c0669a467821e2dd5419887538857bc423c82bfe853bd5ee2363fe251b1a27c63d67bc8a90caa6b6ba86d11cb2f6d4d07b87e8205c107257a129c5a9264ec179793def79c56625aeaf69f9467e32c48ab2ac0e2f8b85c54656ba20db1f03c5ba259e874d36f53c36099d48fcc37baeb062b63065dda1c58e0475f0bc85a080a581e33ea0147f9ab40c0331721925a76c2f81d5227d1ad197e8df2838857962ee16b4827cf23bfb3a443418fda9fe2f2b7e8cf63acac571f76eb855b05eed807e88ea0bb06a95d831f9edc5849ad1bd9d5ebb3b9ef3476415fa8d83a09abc38144b03d3d106cce480d874bfeb359436a663971b62f60b74599020dbdbe9f08df0cb2786dee81895512ab474696262900e304768b3b94120ed25b15046a42ef379e82146cdc18a8efbf5431ac20f8b6e5798eb4849b9adc875209708dfe54785309f820c0af0a8aceaf799dff4c066e9e9b7232d2c604ef95cc1caa76b75465f2af99ed3d618cbe20f60f34429514da0a13602267c37413ce6f0b4e0eba2b6e8892788d3c3e1c2db56fcb398f4582dea607191cb3ec8e04964d1b34561d602d4a8622c0e2f677b65199aba02a9261dd6d52036f0bfca4e26477c1e07cb53ebec357d3872a343f4ad441397f4db17033e7513e9607c21d1367e14cb6cc0bff947b48796b6e80cde3713490bc4975a5595bec0a31417b37953fea5fb48d0d5360dc5545333751a77fb25931b77a620ebd63eb6b54ab2ed7380b729be97df063c05113afc2712deca512fdfa47fec343bbbf7aa74933516db4289a04d20bde2e463e5295326038cded182e3c4f62d58be0084fc4b0b2f3b22caa43f8eb0fbb314774e6d55ffe3c985d4ef693a2bf4be729a58c9c64307196b40d4b7212c4c747c980c24d9bb345bbf40ac9613ea47b042fd3797ab86100a9599b690b27dbc147e5220ed730d838eee43199e4abc5a353b77382cfb973e3eebbc0b207696c28cd9b81c1cf23d1c5732e103f8f1d165d794690f3530b5166378588ee973c019d73f19c640aa2be64ae19b5273894b72d61e10fd6529a95f2e4ecec9e48e354d6be4238a9ff3a3f2a4af41a5be84d3830046374089b67bd5c7aaf9a9888deb0b7e86e7437608aa64f065042134fc1077d89f5d1902824f8236de38f5e23efb207e43e8615bdde71a0dfc3290dfa77811f04f6e78008012e039ac62d7c490943d92d5b26aaad14ed34cec2cdef831eede4b99bfd1fe62b6f2204e800f695c262c50c3d6c5452bf8cea27c8b55d9dada112f338fa1a36c6f78b7d03cac53ec74d8262e2720a53862cddf3ae7e646f5b4459308c5db40a94af8a6fc290abba12ca8d950e7f0c04310b0db340297c1ef4905b8498c50a7de0cdc50fd7835933002a14944b9b03ec9ddd550b79a30ba302f65ad3916b2d87aa676283835facb65edbdde82ae88cfc841dd69ab32781adc860b4ce91ba3cd406f767320aca4518b988cbbfb78c9449ffd7abb7554decd5061ffa235c4257645842c8e74fce503fa4184e10135d333d7819d8b90b353580f8d85a7d016381a23f58308b98b53d86ff155c9e5a2d319c5477371b4921070f9ee0c6f5f2829dc9c4ba3a2b3516b22357b3ba26ac3f080ae98c4f5e4765af54520eeefae28d91c2a6bd153f702888e7140da513378a0a84ddd2360682f085cd7e4c65e6e9cc513957503f678b3d82820317c1d9d5370bc6ede190a612062aa2013e50354ea85cbfc16e6e48c0833be4b2ad1128a4825a6df0dbf9fa4ec8f653eaf7179031673a3b3cb1a1663a4683dc2de6a8fc0c5be05aedc09b9bbf39ca2963bc84459d4df4ff4f2d673f1a99df20234248f9ba974aa97519fa837e03c6fdffa25d994e5a813e62086dbc1f8468ad3c541da82d48528d4c5ab0cb000a2f5608bfb4fc21e18a8a1edbdfe4244a64c2c5ff296a5968c2fe7ecb07573bb5de52a15b431cccfbffebda8e92d8689d0b4ec4793a7f7addebc4a15cd688e5c0ac018ebc9f37c37ae90eb71ebca07dc3c5e3dace20d188af664bfa35904d99710723f184ea18091f603152bdeb905d996777a6d2e7d5672d4c854b8efa11a929ee8590a2701de028915fdf51e1a8cddc28e9de1a2f51786ebbae48e00bbc40140e239629d83f9e5ff412459f62ecaabf471e8135e68f3c1613f47b22c3609f416c334038e31b60022b893344e8806d4ceee7ba040d3fbfd73618f72c4b9f185b7e83433755af19262045c94c83f116fe96faaf27236c98aac9b690c352e64f8831b4bbd0a203a03b14be5aa4fcdccdf1a8f7786e28bfe7beab9c09be092c829494466a78e4cf35d007207382aaaba6a6b0b7cf7b63a1cf3e055c116240cfd96cd56086c5b155967bdf9c9ca33fd9addf8a9ac857364e453037ac0127dd07894899dcee4fefdb8e91b90ea45ccbd5256f94c16215cd6cd08a42aaa9c5a564f9003683ffe0dbd2dde095e0ecfc688dc9d9af3bd0590621dfbd29625028d22241229abbcde9d0c5e0dae2255e2cad2e42c5d58f794274f51cac2e6d7a5f6bac287d00db446936028386a8a2b3588e508a82ec549b8daaa81eb34b4c5aacc2a70f5635d09d5140176079d24320039735c7da7a7afa4f434ff6abda727c6526ca56962fa9f7dcb2a32e7e93a3012fbf68077797de4713ec2aea73189c3c956079325121dcc635c695d07cfe733b7afe4b7138cdd53e15bc5171343036c1956335947fc69e02f13d32e8bbaf980e51fd0a68df7915e28f6eed9b38807c7f720aee8c7512a3e6bbed49cf923ce6d3e6a0e6623b27d86c707920b13f138877b3c155c1f52837966032d0764f93cedd82fdf44264e181604ebc294e0438948b8a2b11be2c025f266714a4947468840ef61c06b741152ad64a9637849afa191fec257a9b1d2bc049323812828b7bf016b4ac5b297eb208d31b110c0760d18603d21dfc5eb7edb214a89bc7dca09c495d4c801660104b3382bf3919965b6806631867ded7329fd5385b8c9f21c6ce8d03b455b773df286d7c423d43fab8a84f50f6cd548bacd6e3b3c220fa09892956fd1d6d18d4a263e95b8c115cdcc7c42d0d8871a2b43cb86f9137801748740b5ff9635d2cc82ead7fe4bb31206cf7ec00091980a6211c2eb6d1e92f3d7f5eec752fc515d49c1e6e2b98f27e64bd2fa46e7e2ed4247eef0fd68b0abbe8331b5c6b347a0efe0ba57dfd8a4a619db700fd91fd60861886c813b93766e7c879cd27f86828f311a47cffb57d4f169cbd69b6a79a8d72e471c0ecc918c61131f8f1b1b3d83ae40f18388f99e23153856bb183bdf3289756dd7062f68318ed76d10c9d77db8230e974170956121d33a94ecd9b754cfcad1f1f4c6419cb1026ad4a50cf2b7b056d00b5b2e1aa935cad818d455d8f4da2f00bb9a965cf92018fa1ee499903ae67c44b3589479e823d6caf61f95e2733a8e3e5a905a371b83bb4afc72aaca4def8f3ba295aeea5c394c1dc76d4f92003571561f89ecba8de2232e1d2680a27b1cfcdc49f448cac426d97c26d6fd15865f16b542801d966118032bbe5b875ff6759ee54d0594037fca0c23deb7abb9c288bbb54c9b1b93e8f7e58982e6132d0b8901b959c78a93a082bd5efdab5fbeb71f0bfa5860fd8b939a248be1d071d70a3f54e26af71826f097013c35129bddd849a2bb7355a9affbd582f6aaf406e3367fcb36bf460c92ba8f02da2a89eb1946ee1e2721f65c4c9b32dc0bbb646feb7235eb9ea4e81c9730b8f9db7cb6470ad53ee7f0c9d7ce64f036865c67d9f7137172507033af473902347ecf85c19979e9c5e6fea0ce2c1d2138b0df9248a8f06f24d8cac4606a84cbe4a5283a52ab474763c61b0e2bdebb3b823407a498b1927bb9fb23a9feceae2abb23fe5b08087f7b1e53b31ae4f6eef2a668f9f46ef409bcfe2478416a89d0e771ccabe17f58abe8637c35865f8178f0e0a928a957f7cc81681491b1b57e7611ea44634cec0e4e0854ae11209bafff5b4088eea5d37503ec60b344e0df7e4e63e584210f64f00a293b02f13584b8f1f6a892ad8eb0de2c7b77f6b54223e42e78ad7d5920dd15065573444a18153f22aeb63a52be5a87db46e9073275902455c5f5a8996a55632f8d0fda4e376f9e5aa523a1bc6cb5d5f8fc02fa996e58236ea0df5ae5324012d8e55eb81630a4b55b7b433501be8f0039990801a919682780f4a6cc99f520a45a1f9fa2f95198babf772e23e827caf546611d7e69cfc6671f7d21c37d4899039d03e1f107c73d1ef858c7039694337271d1002b07a128e662ced20ee4209ee83ed2b0e40e7d2d603affed8a112f9a719003666f187b7a9d517b8828da73c4e08af8c8747498254da3c0e1242871ff58cff72cecf8e43f9f34486707b49dfd660fa07afac32fde5f2073114b601af6cae750a4f87325b817a6c3113fb91101043bc63e619ba63d9af2da85dd780eee4ab031a4121d6725a8a028f0086e24b7d48ee653604aee1582b65f5a42c2a27e55d3ed0ebd7af6b9febd09b19b08ddc64f062b05764320a84f062812ff9e65b869a9dde8a685dcae225ef34d8b10aecac442674ea9ff1c50a01eab1084172320e2431e78d6e2906ebbddfa4dee5274d67018e7d0d6a7789d16d4950e35836eb6fb73217b036722deaf41f84aa1e44bf2bc32fb7a1947a164d4ead4d2bb3ab59ee06695dbb16ef42a0537fc745078a8f309cfba74cf1d0d409867b1a48153bca358b9e6a270e2eab65044368b4440a9ffc1e434747c88c7487d63d73bf09c25c66cdf167ae1a04d6711a18a8db33e899e802eac11a4251d336b22552b9cc6a82a68b305faffa909684e8173258464d023ccabe8e7b0f676f9692fdfd0288d0c462918b50ded68e2eeec0f5c277898aa73472aa99bb656093e9ff04da7ffb34c359f2e41affc85711e9bb1d064ff90abda9023538159c2fddf5d0365d2357aae1d6125335824b145c6aef8c92a1d38beaefedce5caddfb33c1c685156a14aeafaf40b29574c897ca6a80d5d3a856b02d649e33e26612354299eea1e82fbf9d1e820e594570a74984697951768eafbd9d169711af41796ecaca0c86398b081f97c360847c1cd144307f91dcad957c68d035a7e616611c0ea0164bc806875f454e18264d9e38996334f4debe0a6a8b59811ebe7ca045e9c924e7ce0766f4d2a463efca4a6fe951802adc1b0552ed46fe2f408e29a1bb6f4e8542f9a131ef7e26c72682619b1c7d539b618bd286ef037e04cffee51175fab1fb22c70878ad277cf36cc477232ba33c9591afd34d3daeb9364d721f2605a49949b14cb0b9e98f551de0c5fa3968c8bc49241587ccbe437d9931801fa121b293f128d59424fe7696bc04e80efcc3652b10ec16ef70d06031a89d23d2b1eedcdef4806fba00dbb116c8785a2d7ddee922a8b78ad0ecf0d6a061aa27f20f057177324219081adf6c06c2bf2201b76abfd293d5de3f2439ececc4301c2a72a975027cd437e4cb9e1455c20bf42a6b801a33483eef0f1c760a0ea1cb2e1a793c873f6849e8bf02f559a91cca20bd35c628843053e1abbbc0fa1e1fb51e7b49d1de9abb2e18ce6463c485957905bd22d8c5013deaf000756231495924c51159c773859de041b47b0ce4f6ec4daf06dc9edfb78c65e9e184e5048071befd2d7211529eb20a8b835edbce2fdd6172b2e930f3f32c77299ddc9c8dc83ee6c2c3058f39e5289c02b5201b7da87729d0a15e03261657c0bd70b9e7ab5f623b861fbbd1bca577d19380cd15db5c9813415b7a219fdc5ad970810b9170226116de2607ed31099fa70285cf7843291ce6bf46cda7875ab00b711349c480c402948d62630b78d6e68ddbb8bdd0ed372093d44968414b910e4751166356bd733063f8bd5b66c83b50a811d8a1dc7a3a2e163115f17c19faacd12d93b00d671635373d0c603f27e8789cb7f88e6550722d371f5e987fb7b7e8625ee09a0e3f1c2732c9ec2e219a80ef837b061e681edbee0b7cede32cac5cf0f5eedf24f2cd362a18ff8027ed137fa68e2eb9bbabf9316eb28cc21b6b576582dc06abe23c703e22bb1043bb96f72d235002b7cd3aff69ea504b022ddc5d33e74b5bb21f92253f8826bfae85d0aa0064aba2d2f379bab47a5ac99584d1051d55bf88f561f492743a0fb0821a09b673783f624ee8ae907e5add3bbbd42718e64b8c0bc3ac12461f81236c67848013cbc552b935ce2bfa36e607a830ffc46f37574596e02189d578f4871d2beddee8031eebb4e302ee3b11972452527a5caf3960e5524568fe42f3b4ed346f8a4d9c9d0aebd168c6404cb2be9b94752f52a351972e28f5d346417428247d50a419c26939a9456d15204b6a34f37694229be8783c2415e083b53ee28faf23cae4efe4a347e3b60e3dc87d4b0bb0decb293860a0a9b1ee9d8095a6d2ba7dc0db63274b3d19c236ff5350e994b89c255171371680f4111865c16f80542a6c788c93b04aca61c80e151b8ac73188c63b073d9738af5b77d7cc27d87cec11b6f7079717dfad010ff47545c23336f26115e0aafba32efd137a2cd877aa65f94548f86fddd153615c946844b2c5306339c057f0074e09613727574e85870911d772fa574c5b26d922e39b65389b528085997a19781b5e7ce06f195e6291fc720fcd56c7fec734ca3a51dc5c93da7112970975d971a5fcc670126f83275d2c4d62e19c3ceccaa72548fffcc2fc4814629c7843223e51bf9e56e1bfcd3631b4a860b8efc9f0432e075c136d0d9bf6d6df67e785e0eae18e642e59e950ce7583f31d1729fbe712919be1efbd02a28a705e3eb6d86d862b7793e443f924ca08f0894ff3e8e2af4a144867e59111d4f7cd0c7c1939f5e9ae92580157bd13c12463f2e1fdf7ade18646c4fa2e3c6a2502580b904898ce3e52519372271cf9683357e095270fe490b7340e79fa078d30f474a7e4924aa9da36cb53643ee6b2a225875bfbeafbd47a3313ed427e31d0495d72b855437a16383f46e49bf28fe49d91cb3aebf5a52b37ac44ce999f253b684e84405da1c38bc1180022f28594c349d611202ce1e7296e161a7175606935acf903a7bc0a826690afaf50002da80a634f1a70498db2f3ac65483d6e32190914c77dadf00ff4396f9dc12a2ab096a4948dca0eb9fd1fb529d4dbb7063813b38289e91de61271b57cad6af03011dae6bc4b57799c1fe2af6001f9e19d03efa67be170e71aba08493d1d912a419c371a271b6291870dc4fbfce2896eeb3909feb061872f0cf091bf3c4c91d62ef15f4522b4224d4ff259e1b7209f19eee73e03f6650cce0f2673b35ca7c1cf69aa863c06ea4491e7e0e0e642d6b3cc891ee063942aa65078e743353351aa7fb4d80d39a3acac0df579dc5d6836095ecd6ebbf6968e21df4367ff8f010e0490a51a654dbdbd5b806681fa2dbbf2d0dbf281d5f9942c382aa3b8fd39d28ff992236d429b05c82eacc21aea3ab88d6c5b1c0b0d89a1c4b432b62737812d69a549bc940d924e8ebf3a063e3ee36a1e73c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
