<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"506b4bd55d5a649e98d6b64de7359da986f60a7d62457c92f587022cca6d22a9e837daa730e1342c6c4a816955cc45d8e92314650947e1ff53c562daf5af0b1269c2503e0616d707f448351d0250e3005767a509acff130ffabe6c7ba2a3ddb4f367ce8e333ae3601dfe12a70d5de3432c8bfe30c08edc3b7815b9020d16c31fbd76491854666e5772951de376c11da5bf32663978f7090007f44af49db8f1847aa2c6149b88c36da0b9a533b268639070e54f4b6f290f66acf60778dafbfb8a0e0dc84e659420029cd986415582091e63d394c17a48fd1828d3fcc408da7cab09d8a13fcde2e217c6628d96c841b4efd45f4ae4ca2eff6031931fc2a2c8cc04196df790273b0f51460f953872dd8d8bda9f3fb2ba983952079cdabb2eaa96c4476303daa58a1114df8eb8750e68a4be0e55e892ec8f677afc89bc249232aed6d14419cea7a9536758f683f82cb3a850c1c6bff5a98a3aef82d0df9909cb4395d3e4d94d4875010068e8d9eff8ddfece6fd7c755de042a9b6c742163d14af1d88154226d037bcdba2260aa9ab5905d7fc3e3e5034effe6d9dbc679d776e261b0e38f6447593ce0b897861c1dc9d6c80ef40ae0090111e2cda37ba12967af9d016d414aee5415a8f291e489316ff5a7b2e69b029ee2277a6ced588fdf71482f92b0dd5f6b003a5671c466ac74c05d2d95d97ee1003137a9fffe2678866288c4c9445f3888acd8d6205694873f3ac0eca0ccea46c55750afc63fedb0a3006988c2881815659ca3284609eb4f1be9be889eec596553da890b415401dd46837d1b58e62dc5b21e8f57c48671c8dca65e191bb12d2333a13362fbf528ebb5702d120c86f4241b68fbfc80c37344f2ba32ceb05f02b6cb7af5857efe36fd5daae6898a1a15b649745599e69c991058a36b58dbcf03bc0ecbb56097a09c2d8c8b37e0d57f43f069c1fe7830d5275db54b18932d252c96551bad293f773f6808dbe3e07a3575a756e88e36d35536eb9170a7e60a7b9dfa6b5719421e45fffc17558b41214c14d242e1fbe0157537874cb9c94b2789eb523249f3bfcc1146dcb3627c674751bdea237ffad553f46201495497fc5a8ae38894f3fb1e0fa7e045fd631de37e7980b06f6d842452b2b46fbae358f203ecb8575440c39cc66125449277e8ea87d82cafd89086e1d3fe098bd4fc9ebe166ea7c3c9664a93aa8b25c18c2d4fa34ca4226f20f2425c4307361d0f85c59147b3d92f973b98641b9ec7874bca691a03d0edf2a60e561766b01b3da7085cf208809943d071a4caa530ddfc76e69d10e6fb5625f706a033e07c564c1175a672c9853ebb065d326df2194e59b29a92d327c2b3110162a15a61e6e5421af836c8723a375ae6fd0c8b1c807a4c07bbdc5eac68be7e5c031af0a5467739ce9500d6f9c89dfa4210bda40afd0dd5aef6ec22c307ed2d970e6befebdb39d83f3f5145542928592811f372b78e89144a845742e3c0a768b868b89b44764929f1fca21b0644a5a8f276ce49580cc1811f8903b14ac1412a0ee98d863ed2ade9c1e7b3b394913407d7459a58d7cebaae879dcb847bd03313a160eeee95d23da40eeee03a3dc9148ccfde4bf4dc11c29316aab4ce00aadc4a5f26e6cd2f9857eebcf11d0236f90429fc78402761989c10af28a173bff4b67533388fb0e085973927c5984bc22cf8550c91f86ee1ca92853a059c025482588412d80d04b2d40ac720b71e1a8b16541a47f62ca09f5910570ddc134680d673ff174f7abdb7c9dcd9175292d3be6d76e7e1ab468311dd70a019d402d75088e5c3607463b0e26344397da44776120661f909f004c33ee2acad47ed0e4a7cfb5fa14ca884f743e77278106fc4bc660107da7a796a9292505d017eda04de9271e0b8160e2fe1ef3c4351d947ec6bb1809f2ff7603bac20e597e336f938f1a0e26c22566249cd3697cce10b49044124352689e4e60be2c162b4b464a9acd69d225c78b985b07f1cbacbeed186446e46200a36da722e4e18bc996014613008bc54cc9258b6c02457a57072387195d0c87441b702d4b2b56f1b1fde533aca0e8ed54df34a260a8d6435f669ce7bfe2fb076f2eded1f8be6dfcb0868c30d9accc6a11fdbedea7d625379d7a673dc0560b0eb94d1001acf73c06e68c90b8a5ab20a6c771d153eafa1db63c155e6f566b98d1a361834184ac3809331e864e5f531fa3c477a591b081ab9c4a375697ca3fc27f40d472d0bc26b96ad9f9c90258597de23477225cf757925a878c49f433c8f17d8032b2e92c1125bdee39d9cfd946c0d093292bf967c17c513d6162b74e3e31279506da0327c67164ddcc852c9c38e0f1e50e2a3f917ccb02a0b59d01165ce958034b793c046cef3eb4e90c6d4c2a8845b4507dbc83254e32daecf93deed6db70fb54648eaa46a462d1d0ca7559de69d59afe1b4b824bb60a68097240b3aec24251efa0bf44dae89a209c7794fb22e837dd8e35eb8b6e56776bb668a65402aaf039efe4cad2b5093700a36925635cca8ec24885865b33b6dbd6c5d6dbcfd658d1f61b1f58492e6457a230148c6437d5f0f9f14375b61a91bf5be7609e937064b50b8b453c5426a08234169e8f9aea746d0127c57f910fcd0563f30b502ff5b9e9ad7a8cdf4eb2afd487119d4fb71038d4ee72016617e8030bd9a557913595747889950002dc988fbcd3638cf3bbdb3fdc353ddcc76e37e8da5bb96ff13bc71618a51bb2127232d6a4536dbce0b1b3a4a79884f16d0f71e2d0b7e39f0a1f7a1a296fbcdfe8fe74457d62cbc305173d389b07c1a3ed5544b4d3cf82b2161507f43f452fa0ce934e28ea569280c3b5492f6c4e128f27c93584f53a7b9019ca10d09b87ee241e5064c4ec714a464fced3e031372b9d54ee93e5650332226a183558913fad23720b4f50d92ff11892386a4673dc3ad3a5e6a223d0e9ffe4857b03a2c976883bcea845f109c8e097d3f587c8dfd39828b54dc031d2ec67ab5673e61cf488629ef58a65bfc1c420a0947fbc2516dd66bdea727dc790510802be0afb4a106801538433a7a1186b089c34a6b2c78bc8b5cf0a053e2d2f641e68536e0e86de279373bfb342165a44083f09dd45a430014e76d7c5695d20a0ad61412a8c46154a79654966d3561e8209b0d5b9efc6aee8a13d49947ae4b97789836d59f32c523e1089eb6d181e56ea1252b0b2b5c390fcb7ccb5411714195bed245056e62637dd75227122aebd79e68ea0abcd1517f3e5ee539a55cc8831eaf0e456cc5155cd52ac7db4756670637ba1a3b11df99d5fb6f1d5f02e4eda301192a4a27c9d6374e2a459817fbafbaa2c27d85a597a25c9e79ed60d3de4f015a11f6ad4a1c4dcb9835b57abe537e8b8c80675655ffd98091295f544fa513f4d51b73066a95b12b98ea96eb52150abb108a3d03b730e0370afb438db3036d78c6aeedf80911de90f4d8a787649a7eb6c4ce501151ca9eb6be887e0d14e015540eb03d725770618ff5f33affc3e5a5e8688bd0b2e17e85d633227b5514baa5973b1948e0b40dbd70f2909aa50569b12b24e819433b0f44815e0ff9718fbb3605327b5706d3aa86879bd785d62a2c0966e3b0d28de0af9c69454ce3b0d5d13fa9c7f3fdb90e8265ef72c62f245ba7a0e060a676840a011e2b69f1e854453c75d2e2354fb93fc6769244793ad7d4c148b33a909b1a35b8dc688a2a1c432b76870cb34532b8d342cf58c51b35a21f6b9e6eb76b5d094faa7a29cdb762db63f52eb785fd1928939158ad3ee868bc6b2fae58383d9cb3b9b209d8d9cf6fabd8f269a8d38eacc3d5becc771d7900a0172bf2195e4b3a0e7e1c26f8dcc8986c6673fcd832029b0e827ce4532c50ac02b0353339f15bee10105b2ef152ef7452ee4897aa967b7c6a76a4fee33e6022ec8e8d018d2deba1c0d36dd26f08a918e5b4446027c7e63c69ab20f88a3e48007121e86212ceaf8d0673ff64cc5a6d2ce72aeca032f7d4914f9e3962455cba27582ba5c9a849105028a4bdcd5e65b2ef04185072d4cc8370b99d71a3b189e77b9a39ecb993bd71effdd2a70adcfa87d94213a43683c856cff43732afa8c817816a1b4778bbb4a6c78c0be179d7538cc7971fb8b35de9ff296dba453a2db67d5d3964ccb3cbced601b0b2b9d549b328ad309a2fbd5808035aa906c88a8187f53d7aea99714281cbb72c9194be4ac2ba197ef1fdcc5de8618dad7556c8b6af4efeaab179f74303058b7adfe22123e864b569805c0b053fdf2b12bdfcd6db0f4af5da972c0d2fab5f9ad8716c288f5cdbc87aff3fa1a9735a049888d880ac7e74e177dfb032e26f0eb1054e2bab369597cdf837ffe911bb5c9921b8da3012a777eea8434f4047f3e615cb702e843243c08fa0f0fc733baf9afacafc7c5f9ed5ce059fc4bc7a6d6fa8da1851b490d362865b7d31dad61c3baa85c8608317680b698719e9cacbc11a41d75ccf582835c862b3cee27cab7cde1746477f76d7ad6bdedfd59fdd3151111c0b611531678fc5bf23f9e85e6dacb319869fb2717e45670bc055d3f4ed4a9308f4b0c1ba7c5310f44011f025eeac98959ff7f3ed3b4760ab546c27ad885851893cc34ea4ebee5653a01e60bae9cf9668c59e45492cabb09908a0ee29d3a0ef2f326360818bd1e450cf02543892b846dc9bc8c774a93fe8dd347f32ead3fa41a64a5171970e66157030525b1dfb10b207b0acee3a093058bce780f3d945cace91c4e3f130dfdf770bd28575ff00923929f9a4bf4e28d734f53e0619cdd9e305db143734b80c03107410eb9db56d980c9cca1955c365aec783ae327a55da4738b4a8a0c8000468b438e4ac46e811272ddd0740be00e020f36ec6de4790ee7ea9534631aa58cce50a6ddb02bad8d92a9a66719ccf94442cc8c784aebc49fff26fbdda0639cf126837d64dd5ae1e448c4f18a80d59032107aff70e722a50dc7a5ae062ec5a08276bdbc025f08ade375f9cf559d10bade4446fe7b830d8de69d466e691e49bc6c49f1ad7c93bc3f39cb0c198f2a2da929a59611ef00c86463c3cd6752f4ab2e95cd697cd12f24713f29f5e1cc37ac878837bc0eeb89637b7aea8e10ff0942c7bbe701b7ad7ea9df0ae3799abac2a1f0879992673de66875caf6bdc89d8784298f1b251a1d663d546fce5891f65a9ae3e375dbf33de0ef9f21fd38bc7682f8c960f37f0817481613e40ff4bafd8a7e473362b139db97f21a18898786597c4ce22aa266aab26935c557506cc19c8d0b24adeba82c337f9d2fe5551369e418ed4dac11f06cbc85e41fb902422e77b097c5447e0e6ce5a40f189fd08fa5aec67b2bfea00eb115d185a30d18f6832652dcfc2d16976639cab7fa37c080d7b74c14e70efe5db274c7080ce05dfe822c26996ca6511db407db1f895c3c1f107113898dd1a1d14e25f3ba62e49ee91d9d90d527deef05691d6e9459ea47ff9419f3589951334c163f5da963281e6b1f8cfc213bcdb47662820628ea9a5432f7898dfa2f4c7a4578227235f7ed9d9fed7afea8d68f1955e56e6a05049ab969947f709d4a25bad90b1e5fa46d4bf6cb5c53c3896a6c41ebd092c4ab7bbeb2a11d2650df3ca7651b46a3e8a08bcb656ddefd2a82f8669c49e5ec1cb6099ce646f20229cb602f1d4f8a36d70a938516fb0314d2b1c4ca2a0811ff07ca1b96d90940934c5de51a88e3b61ac86b340c52c71ebd7559bd00010cbd7372946971b6a0e67410b2d0374b5aacf929ece1f3fb24bd265d497e6ddbf229e0a5d84bdabaa03cf9a85161132b8a7d2a321d02e2d9de106df2e68b41a08be00551ef2f94b6b622f1aa95ec1fefd96dead5a5286bb93bd45c4d0b723c4c3c81b373915a20b094585831d414a69c7fc141edc0c90e8bd821e86a534b5e49b42879dfcaae975e90ec90a124b33825e4cb1a090e8417846c3fc494863e40c25e5b6f07f57b7e14fbece14136b7a3235be83f00562954572176640d8fb31b0d5df2406efe44652acb7f9a60cf35e6602de16af6abd525848e63fa70702aad7b2d6dca1458fbf6f782f09ba1ca0823b6a7810e94b557b11b4c81ddc225705733666665142aeb223297bb2f45d43ff06824e74b19f78b06c9a3fdbbf84b106ca3157ea8352ef9c456116d263d48d358a88072d303072383de09d97a9e5795dd9e4b53fa28e96e1f75a99b4ed5843304768267a7462e38c573d36da608eba292c939f5ca07308f7fd394d8954430317b14edf91f2debdde9e611bf3140e7954a4a13fffe7145662fc6355780b3255ba4b676df0ba6a7fb9a184f327f86e7813e096333af6189d25611764bf8fbbd84b40955167b0edac552c1eacc4d1060926332a66b6dbb802d8836b7996d0ea3c3a8db0bbd11c584ca15239a407a046aed7da958035d11f3d3db9370a29c0d7fa27cfeaa2728834c441d96f9a05107d6951330a38aa30a2a71e284d9ab386e4d29b1cbff29a6530bb01292bca07b9a499625c9dbdb1be948f039e5ecb43b8cc383bc21b99d0f669e26758e1dc8a662eee7842e0a4430ad69e7addf8d8af87d33694d377fda878f7c4d4b0b8895243de6d44670b1d95e55f16fc9686e11ca8c347a98da88d2a42bb8a6a0c2e0c015589fe43baef95d5336bcaf0aadfe9cb8fb7773a0afac281d6fa29c4ed18c463be713b5068d2386a8fe4a477f28a6302969ef228ce82034e4aca85fa7e6d2921d220540a1c4d967e94c60b42e29f6bdc6c15ea689ca7eda898ca56b2dfd2243a5d119d0d8f55002c37f10db9028de212ce8e56c83d1312a8a58f65a9be28183531ad070449c2009009d3fcc57dec8a1d27ff5233c983de69f0b729203c4e200d55dc5f6c52dfd6521c3c2b71cfff3752d995a21741d718b70304584f85d27140fb8725a8df2f66a4a4364fd020eca9591db99c3c8bbbb4d3f0976a437566f66e02d330f6e124c9a597e51f22142c1621e443b754a542b9deda284f9144a768d5f008ea907464fd8d5eef2e9003de07c628075aadcbdbe2ba439d6011b39aa37226bcd643cdfb98fb7f834bf571124469986d051a264f7ea19cd355c8369358708702bc6950191d7c4bc3d24d1c6d687c112761d1994c9db328eb7b1de84e90f36945bffe72e01e8a763aed4d955e08665d99695d8fe4b3d3b509088e8dbe32e99a68e78233ffa62f907d296f832eebe34f2ab41a9a845c8bd012be82c88e97feffe32cbc5689b3c0e84030185e0c9e9e4a768a7354d489ba9a5d5f614d22a3fba50e84d467dfb4932214099f3d931f0268373cb75be5fee6eced774faef12c089a375febbcfc809ec5bd9951de7b78e14c09d51c14259bc5ac989104fdc7161d1f30fc3cc59a0b40684874170087718fba5b91619eaaeff9571a57f1b44b6019387e07d073c67c9ff051f99a03981b47af94bd2194dab627d78dbc4615cc930683f188f2aebd42c114f56f7f78d9feefcb2b33622b326b22cf3aeef935f29b69822edd2eb1a13ed82820451fa7a8c327f2230dd433b6881f8330e2f0b78536bc49798cbccb1cdae56e9aa24ceaf0f555b6ab99ff709a022f2f77dbd7e3087b82aab1031a97bdce8d8a9910a793009cc03e51a5a4a8459a5d617ca6fc525aee55dac74a86aea92459aff89fe115e2e9c42718aec6a1dcdcbdfe41a0bf387e4b4ab8270638278e89a8f9f5fe7c41dd62cef84cfa8687a6267110948cbdeca6c8b3396abc8e54eee9eeca3e57fbc4c7108dcdedebdf5478ca3b720d69aebb07a9b690d30179d3341f50004435d407038d71786c02e97319d51a06c7ab01b4be9c973416fd04d6af3ead91f14f7fef8049cee19dbcedb26a8ed08b8253d0bb1922d5dd130f5f4c2e6cb1b4e801f776fe8cec5e7085955a6abf51bb069ec817047b4a681bc7c55263cc75304ddce62cc2641789efa68d64fc0ef62ee27024377aaa1af54f68119330e39cc85c1ec23e4d64e67f506bfcb021486edae9a783e58fa20fd9e63d8a86ef1d09e2c4b90d216caaa251171dc9c06885ed19420a989b26d9e20c3b32b1f1230a08c999e18182c0d4677e23ae744a4a7a58e94d96b18830cee20ba5e47dd54fac73fe3aa52cdf08219db0617e2d18a3d29beb98b9bd0f09a92df920fbb54abc5d0671b49774da759b9c9260594d6da43b4830864b85f79fba7dfa8b513b7b3f00ae8978504566514a47299c4b39eddaa4a2124c67e044d11b88c2a5b46fbca5dce8415188e094579ebf995c8b1ea3958bee9fd34247fd9ac9798b0739f9a3cec3ce36ccdd3c765cdb07fe749742f9d75de5651c0c3b51d74e8fcdad6d65026cf44000037b186ae7f3426f943e6e8429f70fd95fe2be824a7f768d10102138548b6325a4597c9a116329e4ebf347f05e0aa0dbb87c8cdb1ff4a3d622d2e86b06647e61deb2f1e9509a8d850c36212b84e18bd97cda0b4581c10baec7e747752a393a92a0882ab9366723186e769639d97e7fb8b10acebcd97982f0b8ecdf8e35484c226018eeff928d5e9ebc528afef47bdeb875a69cd8b7572cff6ea65da70ca8421b581934dafe8ee6b866ed992a2d72a48c0aede63c81d7518988f18ea76305eab9cd1e472e2a1c0290eb91a76530721ded9bf402ab95a2b9b57e5ad635d737ae86d00a205e872b0ac82f82be1ad050ad3ba0981cbf1b4e886e090623e93b3d532db3504b00e4921232c75e6a8de70fad635b6b0cd8ac82df7347f63e158ff7b54a9ec40b782bba835225f48c9bd65f82ff33fed1b155bec19a3e73f68f8fa4eca753ffd1e7d8dcf196d5b29a1cf72ea811da59c782d236b99dd8084b4873fb27fb2bfd3eacfc50df31720810e8687cbf93c01f7331c3941237aad5d66ca8a61f11e1e19c4abb08b8e0dfc35c4492fe7b852baa5cb9dc8334febb1baca022eea069f9d7862517e106e111deac8d3ade847243c0a6174897b3801d431988fb6672d686b121ccee6abd3cded22cac0c1249212f62c5793a71b45a1a48bea5288202c85045ea47851da66816b61f40e5ccfd73bdec6822441e2ca54fcb4a91b54ab14bb95a8aac56158219ae4bb51f37e8d88c065244e555448a0183432a3d0c03459cf0bbc6f5de7b6bf15095df4ff400b3b48a1ae9c8f7a8ef2f3bc9b5316297b6c505b1b4e5a1df3b3c65ebeaa8094cce7b7f64c1b1da38db7f8277c023e97a5e34ac873a1f6182a0253068b295614e6f4c5a95e414b8d783f59e3c81c70b5ebdace91c8ceb59a39b208159bc0fa65d0583264e77a01f8c9a03d6628654faa810ba9c5eeec1ea71ff98e2f72acf53762fd43ebc4f3b717db631d36af6469dcf728f533c734dee0a74c6b1074df13a42e3fe2e76eb7f3ef7ddad799b54fca2d487eb18c58c189b397e05d5cd9b5a9e6dff2e9126b6ffd22825468f0e64e1e99bff52398ba7b8fbe3c31187e49298b1d81cb99145071451bf7c457895d203d97ae5297ff9f5881a8a48bb84a6db57cc10143537da1a10ea296da9a12df7e93be8529f6130b67bfcbed2e7e02c081bee31785f2ca4dfdbb923d6e049a78a09328351a4a12f97c2a6be7117ab3d4d4d7802e228fd5e56ad0da0ce2616812c2bfede703ce113082011cca3afbeec5f5b4123ebb1d21d25ba61320af462947898694ebd5e3d8e7b023c1f69e7803cfb42b1c99bf259003e1dd0559f3a4a4f7d9421beb6dbe1c3bf60a3743e41735f5d3e7c4a3052ec407cb2f74ef6c629e7146e87e48e84b620a40cd29a1d820248391f3691e3db5f0b6e554ada3266029436437b685ed8aaf4bc50ac4ad7b119dac40f2f4594220d7a6ec5c131be8d95cec58f68c729b9fc765874ca793c880dd69940cc0bd4502eaf062cd1c2c7154fb0cb4f0239b9994010aaccebe89f065e87306a6e91f0574dbbd0ca943a75b95de70aeaf296fa84afa4a52d03e017ac6bdbc914c81a09061b7bbacb0923a9592250a6cbcc918aaecc6613035097ef5eeaf4abe69bb0855ebfaad6640656a4ffc40218963d010e866bbcd5f09a2c4c8e16742656e5ff450fc7b73b61a605a2664cbfc289300df39819a0ed1684fed318ca29b2e8fdb2536de1638bf507d41f941a402da465315137ed9c52d23970056442d9cdfc7edffae91a681d2894ae868864b036a142d8d1935cd67ef4813752424a2ff66e2e4afcc6041e8fbca91415df9e4fe7aa232057c7d180f8f80995b9ea923d23cecd9227012e03b4724d1ec05990b0dd12a51525d4c68f9681c2ed8d3a08633373aac242da7bcedf6137e65932dcb59d49d15d47a78dd3e46718b0cb130e3dfdcc90a35d2d5b034bd216c3ba35101568cf0a433627712cf304cda66e7003a1b08bee375dd88f74d4441e93340e99ee1de54b0a3e66e0ba609c0de0ab09c275fb40b87144e9e27acb84db976c8ce8d4637ed781c585509ddeb625e1afd16b0bbd23d0724f3938116a46dd9842ae4114186547c5f2e42c9b91544cba99e5d22942efd746ea572223c28503a9ce57fcb5df0e3e9b0f753af7496cfa1d7495e6bb17d9aa4a9d4747c6911f14c8772fb4ca553b3a9fbefbf1932fde259dc93faf4fd2dac66b0f60258df30edf0dc97cde5b24d9b36e9553f8f86ebddf793683fdf1ede69bb12410124afbece329a0f9d02d4377cd617a7f8ada2be91686f03c0fea123f257d74dc78443b8c38e21b83eeebec38c4e7537ed7476f93778eec1fc803b8fc126f3cf8c9bb98fa0b18e86cd03b65b49e5e976841e9075dfce2d1fb420745cd4751d82329dcc7ffd604a0af5ee27d1dce22fe04806c51c7b62f94a3010b38fa289285a47483ee7e5aa09910d8169e295af8d049c53c0f4804a6a56750050657577d576d91acc15a2cf5955fd24709fd0213c3a2f72a438137fc8b668a36d66e12709a7cd4b82d45af2d07c55d0abe9b1f0fdaebe38aa8d7f1c3ecd4c6764d7befecec8c27b9afa9437a7413435153dce48520605180024b5218a1a4a5104cd35416588ab4ff105d463e8199f38ab4e9258211889325846e785b95ae8813ef79790ae31afdc7cf5e9f470a6e2946fb52b750fd4b4edb617b482387bcae9a14d0b35730b2d5a338a5971f6d2420a1850e22c29a073ffd3a0e8b4be17c2a638aae8bcf2b83fd3e8eb03e7de32fd989ce9f100bf2a66ac0bd0aa93ef2a65039f8b7963f346d338ab6705fa12eb3713fa734e82a3601dc4b78d923ce3c692eaec088ff4153917b25c34418b81accdb903241d3278084e26f26483fcbb7023e80e3fa1cb04045cf1990336cafb0e3e2963220340db40582612c4d943cea15a6567932692c40930b0986a05f2a15868517031a1fb3f13dfc4d2fdd5db0945f66598ab685a2a71202c1bf713b8253d61010126daf811bc270c5f177b63a65d6914417a7801f32521c43c0ff33fe9ef1e45cd6b8f793942d4e5f836552b6ef01fa61214a592bde3fac173b2a5559a7daa6484bd24407d8f5bfef11962f6b7c1d81ebafea2e4bf59490142e2c4a3531a5bb037b00900fa05c02e468237d7df7e58a8b575a00d4f628828e3dbb5ff1373c72607f4708d2b14f669749b292b684a65327182b5573804d7933a5559de44cf37455be34b5ba67dcbb777d0fdcbdf5b1da93e55682142799001e05a98f9c442ea2928a3a026654dad984b5ac0c4a241d6f649265f5d548522f473a1e16610feed6847b98a11a50e4557faa50efccb809968c99e18d29cccefa3d0f6c7cce26382a1080e90731706e9bede74203781d31388684c3ac1638fa3bc5319c150d15e3dd9afbb4f13f7606f63c36a0c4e4aed25eff4fe28508659011ff58492e65e72210527a1cde183e612fc0cace019ad6becc1727d515492150afb67697db6a57be6c4693572f7452d3e7a7cd74497b1cea63f989a4b1fb9272baca017be6820002a608062fd56756c1c86d6a8b0d8773c9cbfa7c14dd4936f36f576f14f1854af306ccf6e002ca02d33d53da562a942b736fcf8a657c4799d7e9d0c491f0ee3b6c95d3966afa784069b959eefbc70c5db7308832d4d902749fddc4983db2029e867ee17fb754afc2261351f3bc84e17fd7d10bfc944955a24a4f4de2d486708da90642aba28bee489ba3c73eb37d84478250c193fdc4198a9e9144963742e2e155c5529550c8704a1c00ecc23568a81837515f31eb27a856810471cbfd5e0801efe76b491ab930bf617dade3db1942634ab6449fa68c5698d607893c6362edd6b48ef12ebcbb29bb1b59e4aa58f182d7137f3ebc3f82ac8a5dd19204ff5b1e13db5bc3411e6a5c446d43ba39a46d01cc934e4ce77e2a7bb6ce36ccad291874b6bb388482715c91c25c767a3c859b33663b4dc7b4786151ec25ace32cfbcfc2bd585734491ea429b624153eafb40f0617ee7002ae3d1503ef9458e02088d809fa5d8f1110825a55ad348dcefab0ff4a03c33ba160d2a851fa223d8a3dcfed333c26da00b114ffd9da64d8373ada6fab1f783ed532bb5dc3ba8daf083c574e0bc7cdb60a9a590190b1bd0fe66902ef93ea91b2444e64029457160cb00bac5ab62cd96b975fee9116d11b8879fcdbbc84d9e2cffdcaf4971060799e62eaf25cd4507d9f53e2f16a4f6bccb9648b1b44c7a0ed69c3357ff64c16ac704faf50deedc6bec12d866b4ce2f419a299f3f9adaf70785f69c04f426f9aac4dfd79414c82d26bb15fc5e5e54108638fe36587190de897d5398f36c59e011fe68db207b0af25e57fa99c331c20c2fbcedbc1cf33330d4d82eccf12611553ae5d4c1b7b1d2f873ab0288bd55936b41b9d4da36734ae7ece9b52ce1af2d2b6cda046939367708c26c891c4fb77e8f37b837d52e1e2ad79f37449fe8b122638e52e396daa998473f449bcffcbc97a89de65f44f0b9f8847798c5e45431d9cacb18832623c5260278a4456a16f58f99e5c6db1e7075897040a496a6fd155a82ee7110f7691edb69ab6ad3c7adb8ff141deedc1b93cb23fce16e2909c9070649c272e19be5b0151a9f84ccba980daa99276ad014f40df675f57755944538969ce2253c169893438a8ab119901c7596d7048f70b6e25845085e96d337564c6e5d887cedd722f9bf20b02e8a140aaab5670c9322e652fbdefac463e2adb2bbc51a010e52d8124b2eff1d6d5e04fd71e34f3e77519e1a5174d0e89a8b3763e870e075b59fa467b45e1d77f4410b35d63feb246686f8862afe7cde82d9c3266a5185623d16dd69bb05447944f5930dbac93f5db2af06bbd2acbddffe2ad63fff854e56c51464c11d6e58220f871c98a7f81d618fc6fe1d40f57e10879b2fcb95f1c45b51802496f95c76993ac9f8164fe3370e14eeea047288d5cc90c740f7bafe657ee86d6225c1bdce0cb52dc7ac15cbdf6507dec03c097d853270fa6ced0a08a422248b0debeb41dacf58ee30737cadb67c690ed0bbcb1165850ebd4d490489829d30be8c622a1fd159e164b5ef0f1d44707f922eaecf2b699cc8174dee9446426fb10429990b5317961214d2fadc90a81c75b6e68c4b6f99ba45f917c56c7f279665e8c08fa13b6f734da02500bda060002fbc3b9519fe67082af6737710161f13017725a932809331b0a49b3305204525b2d0613c22c350897ca945df86a23d0bdf33149c6d655dea66e48f4f8ecf3d80bb667f2ed6281187899e1b858ae74904b34ae1cd9584d59b3a38b4e806611c570beee0d7313d0b444049ce67f2bf5d4a120a4fbb65c89fc86daefdfcfebcb5646df03157a9f0f06a235771aa629deaffe1ed179d91fcfe56f1fbd98cd1764b0eada5022dde5fd35ab8b3aa4b1320d1565af2149072de020424ec2d08cdae9c96798be4cf8f19ea80b9381930f045ff2181c27148bbd677d4a9d8ed6a44b69db7ab9de11a2d29ca430b6d310ade478e65a66e592c89d41ea5a8d9aed6092f7e62a653fcc0491adde0e6ca7e84944be55d754914af6d5754af13aff3b0b07be74fd09aaf1dabf95bf56ef0a89e2d37d0ac0d97856c398ea439cef9a53a26392392de6048f1d19dd6418e78d60df53ed3ce98f9dc9b79b3fa2736f51d5cdee1bb6fac7c4b76f1a09471473b18f4e6a6ce434113db8910f9f2c4c235b5daa95aa3c8a63eed99d68af8c55ba582605263400f09044a93e45b7496c7ca2d8dd6ddc1cdfdb36bd0baf3c984931fc99cad91e33193e44f8c2e23ffe0ce80832cb19d54c89f4d97db154c8115f2ceff59c5e9dd41cfff58bfc23ca005dcae4e0db060c1ab2d067519ae8cce36f8f343440884e9e7fd085dd2e77df5db43fd0f2f17b193e8f85d853bfc9605f62a68f0abded03b506a615bcb0501fb0db6d1d485c4576c92148e7296144ae80917950c453eef1a56ff1839492ff9061919954502fbfc59f4abf1069591a107d0b6b535be7905525f68fcc41601f2a979b0126880362b66dc24a72953e040bc38debc4dd6a7a709a3f78e7d3a2e0935688bee3450f85c7700ac78e7b6aa1f0b5fcdfd8d3312c81bfee590a13bd35bebe286cf112d3c93e08d9eef2f615a5feba90ae4a22ba1d8aeae296bbe1d9104f73043c0a7a9120ba6fc06a1c955afa44a99ea01c5e186280916d6756bb7420fa649d636e10654a41b8c5c3e6020670f055e018c58a62762fc5e8e829119f42c745c53bb994798c384a1f6811744dd4ba2d37bebe0dfeb2a803301bffe3cb8507fbe5cd693e24715faa653992163f6a72c2dca134449245171a0b5821dff60394a6671e9cd1c8a52157f0085eec368cea2553d81dbccade77ec03459220d0c4f84eae466e90829f7d09f67958d9150bea909cc2fe728cd8c3fc7717dea7e79957eff08f43bafa54a0c199af3d0239ceb607a431065a0f5f2983617b238b98c47e4ebca37c1655efd5b05aa8dcf19bec8c4a87cf3e9892456b0fa55995d85a1ca03fa05d7627b80389aefd38a461386cdc822fe07ab87aa392eb47368e0806fc2dc3217555a10bfe6895b63cf20456274a1acc171f3972036383cb3c17507ab3ee5c800a80a5471650470b565a68f8ef9c21f4544e2ad6884e4e2ab9aa49b360b200721960d92896d3c5b13bd46e6d8f82e87876e27f1d13865a32499f9da1477f237ac3bce2f5a3f3f6137ecc8377a34fe1d52435e27e92e4c3d17d63c748387bfc3ea4d9483fbd2eb3bd9cf40c49054fa0aab24a4705c57295196f343b25b2865937c2c72765b238731ff20e77f75980741f8d3a9e40e4d5e67801800e68228e5fe63b94943178e1381980e704a55e008b2a82ca2ccb2aa534870162b905f193aae0e12c8a5a458f85d36be425d08f4fdd3dcfb3d6b0e195037b7b4aebda9faeb4403362b20e2bc456dfad72d5b965bc8264533a449629922464c2f152adb2bdcc4b46fc4636ded8f1b6020ac076b2c13e860eb47fb072e7ff517db5fe528a2f1305021d3249b4b0ffe07cee0d4a6206d34926277fd2e8be5fd679cb006e58b582987ef8e9d3fbbfb729585fef6d22007a375d448221c1afdd24010876e4b520d5e4013433ed4448757f77e21b27d9937a5415da6810f4bcc504de948b9f916d41fdfeed749f10977f5ff22e8765c910baf6ee9c2cb7b6bd6c3debf9d60f104d9c40aab1a77994ed76fc5f47a4343e3f7fc80f13ba4a3a13e75cc303d8ba9cf315a0f97bd00d16241e66f594efca66ee28876286fac3d2fc58fb2bb094b0a66a40133c22d821bd9f73995d048b484fea83f685b21ba71f1c61402cea58ff765094b95b3d7b48bdebfb96ee9d064d1ebd96d88cbc976b66e3d64e3e90497486f0c4c33cff4cb90ab3ae0e7abad8806802c98ee8e600534e56590fb65f57c4763f956e1b6439733921edcb15d95b0cb40595dff694569501a6a2a8731f92c93d09063b83ac310d45de175eb2d4d113d385d11d750e07dce96cc67ef0f86ddd22800ebd31fd67ed7ef4ecc2e84f167fccaf7ca373c875dd29ebd13abdc958c85a4b17a07dc529aafb8bf0ae4e2731bc1b5a0be9bbabdb326f58463bd897f5dbb4b1f7a6778ad15e33fbcffeffcb78f3fe302b80c4ba0ea9a44b0e018debe00e985489298a29975888108217b07bb6db4177b528faf4a8cf48a3903f1c2596787406cb0660cec3ce2dff38f8f8557bb82d287080220f6a4633aaef21017da63c12a2b9f3c9eb754a05335e3b3006f104993f89eec92494712f761a7d34500b1f3e930e90673db8a750345f2a4b0c6a8151644e38e7d0e7e5f92cf5057bf24a6a79e116a071013064c4649e321d3fac15ce4ddca8c5d703c4a934125b8254c2a7ee1f98a1dba2101ced2274371ea8ac38efb7214a4003c61362a7ed44bbfab910b7f75608b71d93bbb01ac24954c3bf1dc47597c73c395d47ee0e31fbb9fdb0bdc87da638c569a0412a38a78bfb79f6b4c8c308dea22ad4f172be654d57e18529cad6936bf02b997ac04fd64d71cc274ed020fc4ea5a63e63da17762386136b0ceea875506edb1ad1fd6a2664807fa552635acdc084264f3cd5259fdf33a56aad1788453ce050a408a602f567b4f0239ad218fd42bbd8719748a8f877fbf54893d09ef05193a432b25242f64e7f0dfeb7f0d310989149ee647ca03de7d7854b3ff86e3b573d312b87138d27597737e09933ddc5142f483bc20c76edc7e086426b89f984d91c28c549a8e9a9736fb45e2b8e6c0c88665f4ff4abb8d3331b9bb789d0badfd765f451b246d74cfebca3913bc4ab14b9d15f274b052dd0f2f50f80c36f324eea737b83a1d4fd1a943a83e25dd0f8db6ef6944dc4ffccffedfacc51ab16004219079f9a741643b303deedbd539f010ed3d2c2b13703a151529bdaf73c652244cc0e191b8f2bc7ce73dad5a9f0f332f96fc1237714f95c9c32d0b24eab1aaf9d3fb9e7e1c443f3e38dd039fe3216868321fa180c6794bc91809fa51c296fe31f55a294b2f3ade48fdec26b4aa2d46863fe9f592f33cb680617c0aeb5fc3d4593a02b02eeacf41a4e59d619e1b6afa597f9e8b47045f901523fe19509600591cfbb187f634f5e37abb6deaaae594413fc0f8b0af0616ff03eabc610a94bc894d686c9db6891e5e32bd2566162924c84e9a8efc9957ab5b18d49f47c20c43225954397a6632367b6068e091616f9d7d133b0551528c7293e005e02ddec8e1990d1bef10ccd9f39bc7749ee17186f08a6084214c64c599e4505fcded1230e9ad99586acf0258fab7810665a29f1f3faee4907f1e8eff4d3e7d83b52482125afadc9d644b2d33c65a24d61d88b7aaf88d59777806f5179ee1764c183bc8e8919b582326478d785f11295f7e798f32ef8e10841b5b7049dac5804096db62e435f89be02aea837cd373cea795c03c7f141ba100183632502af78db3c86557ceabb3c921e7dba1cdd30d3abfd54f53ad104268c5dfbe329517710b7f35df60c5d68176d2999f07f33f6fdac43492e83ba374917b4134a1cdaed69f9519a8101b19a7fa34528daab0d86e8fc020db49d324c8a3ffccaf0349a62ba7164748841b4975917e7a5db57c64eeb5788b43cdb5efffed0204906556cde83d892333141bbefed6314ae1dedba456fc740a8365f9327978f2aeb3ef2e790a0f81ad132836a5a6f14884ea19954ac96ae8ab712a2844f1becfa3e4bc029a4e41188240078608dd8360892ddab8182b2b79c30769c25c2e5acd6d04f9f8372c66b78e4b6e8a0a519ad3e650182742c595e89bd63241b5ac4a9140f186ec6a44aad58cb433a7419a0e0dcc7e83ded156ffc5edb80b618ff3cd7d5441b5c16e2d24aae6dcccb5fe0d6f0c5058fa184eb18beca965e51899ae17cc81dcf8a6119015b883ee145f69908bed00ff275d726cdd909c6641e9a4dc43d9f68b47780e268503c2a7e2ed4cd58f43a109e38d7f48dc971c270e16c422aca0a47e632657cd1306736a4a95a68b0e603e408887047d21153ee0e80683c2a892957698d12a4337311c61ca9c9aae07aabef13d919a05512225174cfbc73947eb00b3d21a674b9f7eb655ca16e932482bea58ca4982bb326f02b6ff12ba5c6001e9b1c0bd879621ddfa25ea044ef7c871163745cf29c25ea73bfda8770cf0e381135e5fa8b24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
