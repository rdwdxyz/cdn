<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1cbbcaa95f703e7cd3798d91442ab8107721f7638e4951801c46f886d184d7a62e6bb443559958d39abdcd2d8b6ebf2e2f786b0bfdabc521f35a1d204763ca8fc98e9db1c37750b61ae8635186b126ce55a6dcfe228ccacb1efddbc514f17c71b7270c923d3505d88f2229fb28f7d30cb15dee746e5cee06fbb07aa509f62d05732cf964499dda65aebb52971409f06b938d2c462a6540979ddd41f8e26d7fc33a157a8f4b9d65eb9da19a4e1b633c7b7f14194337756cd5cc3c5bb5380871fbb0c43214a066128b104587e2f27b2941c5d2ed23a2178f50e346e4bf67ec672985c03f1d4e59f2e92e771bdc8a4d1c74078621b1b648fc9a9eba54627f340d7afffec5005fb06c0e726b17994884d6e7341d91d3ff767ec721bdebea59b57f40164f191fa6b2044e84214db987ce84cf03b854a8652132f97809af4a6b9743fa9e66edeebe584b09ae0b2acc0e6f19fbcfd8e619572950352054a2bfda7a8ea5a327ca87b973a9c5a53cb581b0698f05bde2a186d70691f7ce5ab7c60a31e445fb874f8c5cda839e0ae98f5e0e9c2c6cfee083b8874a8a7de8b37d734513505081789b1acea65e46e912d02a951f5818f506ab09aae8deba2e057561af5448e62bec44a8a1d9552ebb3e5610c2421efb7a3d2bd0d186f73b002d7e3d5f79f3a590cd77fa8c7268eff6d04bf4a0afebb090dd9a106f74b0ba50887c2cebaca118b0039b3c97daa7bbda80599760c89dcd33cfa2713c81b26a997eefe704fac5856e416e8e722e4d4800075bc476156491701d5294e008d556bc953a72b453d782f42e4eb0978fc329967cc85505a46e0bb18b6a641dc966a25e48a18fc929a49ceddb132af2912fa0eb48ff94e24841109d717086425ed78795233afec37d2ac351762d4b2f8542f8a7c3e5a43e2c9b4c6026a635bb84db3ddd5a07dc5555fa7cce8871e0de5cfe0224df9586e3b870d600908feff72ee1b7ecb68064f9d78490a2c30e333d479e42a49ec3e5bb9ae7ad02435a103977dbf9bef9a9f68b41f8a19ae1d4a5f4c704ac602a65431c5080f41a6a2eb213990c6c31d7a857b075c9ad76ab2111966b81bbb7280b535480a815c3e1bdde1e465ced0337440ffdc7436a754dc2f154a687a78215c61130c6ce15c15e16a5c186218fc04263e8556bcc0c7abb8b7c90715416332b3423b02b0e64bbcce589094336511aa3315c27d2ead825040fe1f74ce8f83e2f713de25594e13266696db45e3f84017aeb787b5691a319aa1c14dd2f67035de4fb351bad39c6f9d7832280f61e8f3b47a16f83ce77a53e8771d7de860023c6c604bcf7b0967b7f031213c3be59a00504220749a2fcc9649c27d48c4a5b1efd7dddf0914b0ff3032ebebda073360e6276794591c7f3c62e4869e44574ce8f967376399f46b7af1f0baa6fe5a296d0e2615af03acc9d64183366ef261e34e348e6e90034512e9dc274efafe7c132f1aa5013b30c7ee835845a0371307bbdd12939c10d710aa35dd7c5089b9df6e77f3f7ad0369840960d315917abab8ae0bd93efb7330463efa4d98ae976817b062cf6ed5fe560dd798d2e35f4a8a39c961d3f7658c0d7412bc2eefc968054e14526d5d16bfcff656732f87e7a1b7ba048ace727c610b461b78ec9a83bec55208ca3da4589c6f1a7074738a7bcfd795baec774cfe080451854782459caee40a088788d914b0219439ac011d374e811ee67b23b991011952a827c663ec9930ae4b6fc533ff27494eef681abcdd84faed4f3039966ec325a6c5f5e603e25419a94fe6590226743fd594649e984e3ff26632e37c2a5d36958a88fcb3834bd3d96c1839db86623219c1d26304531657763ad99358e78458be3fadc80e9e3b2503ad4bbffa67c2991b6303856a5a725a49df3616dd8c0e58fc6d87191d3e7f7fda6a8aff51f93606d99221aee5e2fbdc730d6c27c11519bb8df4ab77661e5337dff2286495d29c6309e9e41238322058d47013228ce233ba5a16dd9d0af11d9314944a30b3fc61dfa67eddb1611abdfb618e2d7ceffd26ac22eae80bc04de835d2ee4f8edfc80110760e76e607a338db0c828f159eb4711fcadffd0fa06e4707085666701ec0f72f756441adb94ae31b6d8adc3aaa697b6bfa346c1a2b27f4f50b5e6b532a16adf57094abdd99a13a0372e4bd63266075aca908240285a7ca322016283856de46c89539c0f234bbe2969cca8bc87c20ebcb42d27109818e77b571afaa743d1a66f678e4895e46d565ccde80809b2f1f40063535dfe07617a7f6c9445f8f7bd4399c1d9c53ba85de5dabbffc507775c9fc662840f1fe276565d7cefdd7a7497859322c41c6b92822c3385b214790c6fa261e6e66e0939d911219c50a93d0c24504d8a61d8d717fea894c77c1b7b1df108424118e38f6094dd3d88261bfcebdd2ecde67ae0fbb87a8df317d8ea9b45ce30b47ed0bca704fb8a5454c6a4c7f24c209d097423cef40b8e499b9383dadb2490f66092ad35fa09e7b0d2fca7b6616abae8ae677dccec98f42cd4f24d0b597d95ab8d2d595c367793d857eb43f21526498dedbd1cd8f24bb3833611195ed3d0076772dfdec9a4426a2a2994028af011ea71908fcea96aed0b0ff80c3bc3726e6da3180f35faa6aed1077f7bae10a2448ff5d2b9907644e7b589e7606d52b3170babf9a069077c21ecd6078e0080784d622ad11b2976465f39830e07a891f1a0c18bf8369fddd24fca32c64a4bae2c5a68bbc1041c2e6e62ba267f5509a94493957b8b6b66c8bce9b247d0dbea31f35a968a82f941aced587981e04dc74f9dade02b97cfbd938c069dd99729804299a617f79a3427ac85533fd0f8160ab58470d641de9e0a18851c4eace9f02976079199c9872f85441cd22c9bb59657cc7dd8618a638804754d9dbfd8d74a493ae361904544c50b1eb23399251cfcbbfb7245da2821f1506809d957c82afda4e3e4c56090eab07fbe1439c74eaca2efffe2a3aaba71a8e45a721ac6e609150b67fc10cd39b04dc40c16c293d793a3787fedfee1a9341ef7c259371a37116d2a1285e461a8f15855fa2207c609a95c0b25edc5e910c888ed872a89209c7fe4727815b9bc6a6f53e805f2e45a1a93dae4bea8bb918a6110309ea5e2ce173649ed3d2d822209f14bb3176439c320dd60b8c1492d898a68978b5f9e7da53cc9135bfe73798b828f98302170e6db613aa89d4dbf10c719a0ca218cab1912488280c7f874706ccdc5acffaa9bb07b1dafffd50175e8c906342e192b66297fe3ce68903903492247bb920041056c0acfea1f5966360a826e1d28cfa0d7ae9b1bc43e8fe77088f5e33d98cd78ded6ca401552e3e8d7f72d79a98400cdc07d9fe8a724fd3a257cbb9a1976a0c6fdf5810a6b6374c04b4665846afc683c5c79aaaf4af96e5c50671ed6f5e282c7b31b2d837a998877813f09b6d5e53e3ddf81c20748c915570f63382718696db0b27b94eea5de2d3bd1148d1e287bbdb0302dc1ede917681e19337dfe4ea74826827ec4779739179dfaa152ab190e23f0367c51868bec5ab490acbd33cc4066735983d0c0d565d9656dd20141f3998a6c0f3546d2b4e765cc3c798a6c7954b8aa468803d0693d0b70ea7fb831ecdd3ee8c9869f00fbe550eda777d445c5fb63a4cf3360ab692c23187c1b3ec8b37fe474a83481e01d437e03f765b48de016812c254be200b0e0277f020340f54dea4df5612895883c69e2917bd7830a7a3f51251e38258ba32b11bf24b383693d9d6224f62919528e18aa77738ed0a49faa25eccd1d664c72a32ce707f43217117caed593fba5d5de7012a24739e30943fc3b072f66d71a93fafa473913e13db5e0ab0e77680c01c82e8a71cd0ebfe79dc6ab403509ceeb892f89e12a5e4d3cd3862419ba6389b51cfb3ca42fc4ef3b70a7d64c56b06a7f3224a7fbcaff54cdc999357801fde54fe48f7ab78b7ca4480f2c8334044da07d78bf5f21cd0252490b01c869e344822bb65faeb51d11a544584693cdffedc4809616da49a80f006dc764a81117edc3e60c571cada0d2d09c5c81c25c014d5bdb2a6d3e04fa35b4942cfc8e322d3dba542b1a7ca32e2cbecfba79161dfb8b81260656e3dd6ef2a254005e0d50f30785bc44e29b7bc75f07a2817f680621266ccf683a4c17b59c0b4b523ac9ac9719fdb71fed109078451ddef81c3907cd16296a8ad00200193c576fb9bd64e6d417c587512ae9655532ab665288ce222ad78cdc82057f0eba4febd7b5e54d208cb4936b51f52a5aaff207f7ed6e9c5fee72d3145ee2b71ba4bde8553108f908d5330497b3c42137e11eb85f640b99f56cd025cc83935c7e12d4649259fbdd2a9776e9e18dc377130f73270b7f8a13f46f5c5935903127852956f4fd0924660c831e23211e814b6b70d9bb224535702be531fad18861078aecc452acb0d9665fedebac98e7342f5f054264d5d6315a097941773e7c7cedbc1f70681632190a9c3c162375f94d59969d3057a71939286bed2e280033135867a29e01a6a584861da1014be84f5a10be4989e56c78e4bbba54090e7bd465c94c07ec32b558d1c7748662e03679a284704d1e008a785b779f1de300ed4ecf844c160fde7224f89aca5d4c6b4e08bbec98c91e14a55f8072ebbe6cd5e61a6ddabaaeccb7082977b6f323a4188cc10b68317631c220c839260c22c0f5a3b4a4bce4b2aa77b0914b470fbda480d378a3328617ce9f44de9cff0faeb0ed2f081bcacda151f97c3bfe17c8b4a7fe0d6b6e3cd6bb122cd9d422bd56db26d76948da0fbdda1b4d56257b528acff41c2dc447da048455c158671dbc9ff46a72593b5669260e392a771ef6a9610997d6a6a6a8898e0b21c084d19f35c9e5ad47aeca5f043bb998518003824d0ed77ad78431f308e0ccf39969fa06515171a2536769ecd3526ad2744424131ea9fd7704526e9debb870e2c35da1b074581b1fc747a3a3bcd42c34c61dc4aee5110d345cd645ecdf4714452d0c8932f6438f0875e59288c8fd7b9f328e8794688f0e16cc2be7d68c83efce732ab4003c21295a461592cd854dac4ca6a3bdf358ced4ee89abbde94be0e32bdf9a17eae47cecebc44b2bd39f4129be06b61e5b34f62684bce47b7199fc1812c9fb87cb74ba06486bb27f670a77db407b37fe038395d3ae0e9a85f061380e7ef420db59f85ef1c9af64bf7eaa5da597941887793eb3897f9c2edf39d42abbbb338235b780defefc4b011039ba83b9dd4fcff69bd00ac1aceb6909fa684e7236acfa8439889d45fa3668f1b06f1068201b0d382f4e8c5f515fdf5486bf63db507727e491246f7c90d4935255e3242348aa5c409985047f9272a1c0f718ac6aada73b0108fae88cceebdc2943f1cd6fd895006174d31f236f177d58bc820bbcea841271170e435d4b8fd949d9dfeba11b09a8036a19787fc1704c4812001151ec2d82117393249a6a0f2622628f5eb655748dc46732ff0ba52c166b486147eb805db38a6516676e79e23e5e5c6d7b30b72e4c71f47e983ceb58800488025615fa1063050476534579329c8aba5a79988309c330f34eb26da1725841ec434f86ba358e58d0a4167c7fc478f9e92f1e0b36b60aea458a02302ed2c0dc9e866020b5e23ee5a5de0b1e8694d3f4ab4eb5ea07ce73ac6a167763251cdd5487a95b43eb7d206f9cbf6d412bdaf1a29a6f4ce626b5f1640154f25ba6bea2053e95e2b42583eae6771cb575212a9df7b09c3eb0cea4733b27a642d7028a4129c6b31fcddd691a4a0a0ef5f0738d0058b59013ca1a6a443eef496bef482748658925abd5ac7e7e180c16fd84fb4fb2abe1725f5760570c4da81f5e963da029d0bc28a5165bba1c216e3b6c2037258921b3b6bb86b322dba3ed85190036ff8ef94b848601c4dd0f3eefabb892b6eb41390323c27605c755fcce03b2505b490bc829f24c43968c0db55325346915f6231af2ad7151afb98b7fe568929e7d94da40d26b93e2f17cc0e9601c25e769cdef37275e829645d63303e3d0ced311575511364b2df89baa336e768016e1dbf3f3c994455dd69cd7a42889b8404d8eed90d6fe93b574dfb54cf00eb8554299f313df96c17029da89c36d0f437e18b9082be4c8b316d769098700ac501fb18393264532f165334a51d72db2cdc5407f1b221974fe59f4e1906796f71d901b7ed21f93e39d618c79a8ab8e9edefb91642a52d56c3bfb2d3f558a30ea791de91a93f5fd503efb3df020ef02a82f875b9ed5c4be1f1909dc3e0c87a6bfadc0b584c14a479b1cb8c0d92df410505fa88163905bd6a32c09b6945dfb2a9da5ee4509a40d616d18e8a9704be64edef059574ebbb312cee8c085cf7c4b9094015e9d7f23a80be43a1791692749e34a328a09f367ea0fc7c07167c4472beb0e2d4fca5052c94649d606ae5f163f1840df684c16c4d541d13e3b0402f7127db0ed6c1bb3d611ef2033dae43dcc024fffb9d47463187a95b1e33a736da7362f4c10fb7d5620230a35a0f1fbaeb0beb2c34f5af15a8a901b28979706a2021a582b49bfe619eca3399b576b97732ed97140237c04c5079ea3a92d648a7c2d0b84693b49344498dc90ba2cdadfd195d25052bb7c8b58269024085bfe9c7c4f06a22ee9b4f411cfb65e1c4f27f1e77db5b9b64b15505c0ba65e8a8e5b072634804643734502a81cfc16e066a572754e7e4dd57ddcc1240bae23e2bfbeb58dea2c70fbf0c83f37bc35e6558d0107f4e7526722a34f4fb94d45712a9c653b9ba2191eb47e6e7fde2b2f12553eb1ddc6c7133d19efdecf4f7e1a08dcdc3218423c572258138cee1453661a76c2caafbb84177ba86f5c6eaf1daf20dcae962308fb8b5565fd769e33e44049784bd2eaa66cf0c2da8eaa8f80aab30da4e95b9b469562201c8e7ef43ff3d99233d289a87ba261ef891cc1f7e9fd4ddcf09dea04510a876afa53f632018080c0c35cb2f59db498a99f25b7e17e2a2fbe605a416d99aa4a17b2c3783c1c4592cf09d7b333e1c02f159f70f942f5e05368a1cc3218e620af0d4908926527afb72c5221f5c11cb435b985149d7ee5d6d9fcc0f5e102d841c8f8f199d733a3bbc1c8e4e14cab7844adb8fa9ad7e6da4921057250b4189d0de944c515461ea7e30a2639a90f7d37d852ca04761d7e351615682945f875720444b053ad9216aa9eb01fe9d36b0ca7204b9f9025b6b6a947abadb1261fbe5246131164c765972dadeb7a8a3ab5a179fa4004cde402e2809b991eb2a0e12f8b748d7eba5cf03b9d3d9d244aeb2ed4bbe8879bcfb8c4f76845372be45268c27cbb85873aa6f8977eb5bffe92af104518684656bc504558f2995671184a31271e34bff978d85a7e448a6551d5260ce181e6cc53f20423d75a1eed1f2574cec8077540db7a9f264b7d7cb783a3d740fd65bc6635c0ee328c08c019778defbb2f3025823b9407cad41228943bc38452d5a249d61238c199c835c8d094e06ec7421f9880f87b7253f2fcd420b833cd9ec2f3b958c052008d1d2fdf94f20ed1464a349be92c013db3e15d9bc13a5681f1b09ed86de7f502f6577050f6042b1a33a72d2c07ad3940350950c406dc9a2095dbf78670ab146f8dfd05b91493e331b507f41e33946ac99722f9c44c85b3dd7e3ff91a1b86d981bfd571448166d3853ef56854e6b83d44810195e52b7de3dafcd5e38cabded7a7e610d87e356118322e0cf745ec4020c03e9f3a279f9d20184b131e10f85feda85d9ddcaa0a80fd523f57d811fffc414ce8585dbd7e36b3e8313041699f27c08751ab219d4c392e3b513844cb46a819c3c080d4113c0b707c61e29e97f70915078ae0193fbd217ccca9b5bb5e8feea1f00e3f2237e132d10df3033b6125a8fa0edd7a3954d2ee3d327235ebae6f5f165eb7ef3b39f2cc4cfafb8b0225d335fb5b42e64a30e03f09b9f00492c71aea7bb0215be8b2f6d26f752fd889690dc10f722cfcd9736ac474f6b177a313a9175edc405f3ba1e14d0f2e66af43c5629058c6d124289f09b23ddc7b17441e5de31c9f6597b6eb2fb245d9ac2581168f3f015dbe1435d5f18d8f611491719cd854b760552a3e1e0d3e2be3028cfec3010422148d1a5229f070dbe6e02613cd8b3c16587f4e967468eb14a3d6c271b51d2e4506b25211a2e2496274d40629a46559ceef1bd594567c9aea1ecc3abbba897c0c4e355aa3d9fecb71acc8813e47823d840e7e29fbcbf58cc035b3c781385ac3b3121ce438c9714cab9c05cc7df0889ab7c8cbd56de99eb9286588b1a80d56e1b0dcaa987b042826776ba1747b4e421c39f14919a36835105fe712b304f9ba38f8d44bc4bec6e0ebb3107db377400cb9e46d519777385d0f6fb2408d208678e8fb75ecd523b13395d8f95ec24b9be779007fe51eaea69f4fdcf0d1ab4282a0d36e66de49beb572bc860b04a9ab889023cdd6a9e26688f981a6d5abeb8442488593d3ed8b876d29d4ebf305f0212dd86187a23d8997a932e8e922db2ebaf7617bdf2bb8c25e4de0502e28d0bfe7e5e6a82d6ce71c2a3a7284fa2c099068d5ee497adb34f1626f0c742186b11e37174b29eb9e26f9d146835049960a32ce8d5c53d6df97cb7d491bad38b313fd225cce7d5b67cfde69bff84f5050ac54899274d32c573eb6b5b181e4e7c195793147dba8b8828cc1e567c39793c363661908bebf9987f58f9141a6cb42e70f12ac6952f5cce72ed1860b8926a40774def93d324393985735b83906dbadb25b397ff03bbe7c9be3f85ba04f79e68328e3d6e8c4ae51e2d784a78c28d3ced132ad79ae08782fe7581a8950a0c91111fe0cdf2dd57d64bf34f4e2c180c043e111ea19b4c2328b3059c15c3ab1e0b54992cf7c7c78e942ec0cad55b8a55ee2e55b439edbec300df49abf478b0d1d9433b908eca42ec02e8ef3b5806f5803c16495afa71b6be3a293d555a3f170fff21035b732535b91019ef5adda55c464a224627be89eb44c0adfe10b468477e3a3333a2d7caa2540dc1478f1d9451abacc6d5682802769e2289b1aac94089b1c7bd370ebc00790bc1195e5e1d37006b429ac7e6e5243589638f52aae009e6a6f5b26d438e0ae45ff46b8168122972e2a91468ac2b6be69a3f56d99bd1f55539e2f3c3f3dc58793cf51dd011430de358574b1e8e0cc956805ec647d24bbf244d0bdd9f0d4f2ce9bf9dbfe8d454839b9d93e85fb549c9653c2ab062c1250d2f10d6e3033e339341ad2ddd1d2f21448bbd3ced37f42a2cc4639824e044399ac60956048db74864de0ebf9128f1a7a4fb5c4eb54063e98c1c4a0c99206f5950686bb50a6d451198af996cb3d0f815cd11f4a07d552b39a4f60ff5036f1d4084326aa32c1a0e428a19667e5a8f5e997e697a23558d7ac717ab844f7500f5636411d068f1d8286149cd9b1416248da43390de905cffc6051af1ae3accc91b8e0a600f6a15e83c4ffa3cd6c7f5a84a893f49cecd583c859142e0bd43c04b3dab7a2e18f206277a02bcc46aa46fe224f71d9027b72e9cb34753dfa7a706c6e642090eccc62179de035ea7df5be2526aa2f41102fb6c6a70aace81e298f2faeb0e25c950eb0e54ff414ab1fcdbea85e42ef2c463c27c12207783a99767d6f5a4d6aae6191e09c54eebea5df687cc622152a717edc0989847bf8351b94725dfb2fcb7eff5aa5a33f80d9e006a943b8d9343ee4388be053fedbae59c68c9ec6aa5af90877c77d2d72357dd8a8b695f7eea05ae377763c2b18d40cbc8eec5c0e5181d2c2a07d1fbd0d6eb7e7fe71340efc510125474137bd2228dfe4793d5fb9a6253feb7f6f14fed600d88283aaa1f18f8cf987a5642c0b3eca543672da20decdc5a9f3c447bf40af177cb501824dea61e6da5bea42ce92ba1d7986c42064ff676e22de2bcf17e2777a0f08d191b675b0ea4ff50dcb8dee487ae3a2a3476bfa228c0f6f65b11cb10f09791b1347e2004a37ab9e4a1648454acd7948bd3979835c459bc17e92f9dfcb6be098afe59b720f7dce145e8d8a52df74c7825288c5bf6e0538a41ed24647509a54640b5c61facbfc3dfc7092def10967d131a5e577be16042aea0860a875f05380f0c8137313f038d8c70e7b57fe82ef2506c596ae4f553c2f5a36c0d096b4a3fbfa618b728ad0d8478d5e20de95dccc69202552830ffdbdfe124fb43932984ab8fc58bc2576b6301537ab77efbcb88b4231eb1a79b50a983608b96e3846af925f9597edbfe9b0ff3370a7e456824be7887fa1bad31e2d344c7cc55d28042bb4408bb0bd05b95d059403025693504a3f93b30d44f67fae32435fa21598b09981d37eff69e9718434d853a8bddf1847a8d8234f2b94f702de2bfd251b6b79cef660ebbdbbdfe5aaeb9c827cd59224428c01bda15e2e5c5b10a453b0d1ae2cc0801b407e1afd4dac1a19025da75ac09f63a284a14627324b55c9ef66247bee3cc519f2ce8a346b21e38d8a49abeac2d22303e9824848d4d60975884bb0311e1942b9c3138b5eda825ba990d4430cd9b3cf0b60b662687accbe0488d6df490eed089f7e8f67d2eda64bad243016805a24b5127e1c61e823e8a20ebc4b9cfb86ad1eb4794b14e450d7ccd26cedee3cc3d6c5c83c1762d1d1d2fddce7b37d3e368a3fcf4c71a2d1dfc8a22a049d45f4f7d98c029eb5952dc2b2f691475b7bd421215d83fa32f9ae22de75c748fde9dfc60fa0eae5238c2f370eac210afd4e8bc69150aba5095d8bd8944d56cc2c59ef569b3912faf7d291030593504435ce8d93980725bbe0e0efcab050f0930529518d9b7d90e21a6cc19b59e9d96899fd8dfb163b568b8577fed58d055ec0f2c753010ee19de055c2ee713b2cb7c4f7bbf071d5306cc469f0df06bb150827d6841fd241ced3270b42cc14f130288f71e9ffdac3b09600a9a78e314e1262e0d55de106f9672d780383836c0bfbca751b6dffa720fd6133808675e2456d405287cba620f2d589a63b8c19f65b31b0fbea13fbdc473776cb1dee8deb43f9b2238de83211b61d20c5f1a1b39b31ea561b0dc5475acce8e0b4276e26fd87168fdb385fbb0289bbef2f9c6a442d2132b5cb01d54d4663fb24351e2727be619471d2c6d4d5c700d773a4a584bf97c0fd4c7c09bfcc727f675ef66e48ca4711dee93cb1e8837f5c5558560cfb5755f2dbfb090dc04304aed1a573906f6b2907eaca6fa680ab8eda46d564dffb417e62d91514ec1f2dd7a57a0428973d561e7e02c3ba608e888ae42f1dc64acac9c127af636b3012aa1083bd337451c5b7455d3fa09009e87dbe67c3f1df6d5465cb6668f452770b6a2d6ed27b9dfd5151147b67a5a5388a654f40fc66b28a722b5d9135aed4564d10bb6c2a8f03fd124c5f7f4d0805c6de3a60cd78d7dd912d190af9f27640b9731da7baec16b9c1f903de43e65f012f7fb8a29e1b3ef763cb231f81fdd3dd19a7b57237bd6e8a9c990ac932bb344d88733a959b34761ca6b63c0d3bb5f7cd58492cc4b30084fea7f7bb37aa243169225c9c0a11de5d2917bc50d0e550bc8d0e9d4527e4a7d4892aa36d8a06d305ed94d8f1a44b3f58b837adacfe3460b987fb6a14345ac4ac0dae52ba080205f44ce0cc38325c1848d9d45f60aee3c866fc6e991d562209ca4c787afb3dc4c74d30588f96b3d38d3228738ebc030b011351dade84d29a51262bd0e4444d6db0e955878bc97df218f1f7671db45a92ca032cca49e47e65e1094800c91bda236892e8e3ebeea172fb01bc7bc12585c906c2118cfb91e6edce600e7ebc419bcf21ea21cad31acc9133912a643d970a979d927e423d21a56dda7d5551c3d46468f1a1010f300214f862b6c1de2142be42d5d6ca2b45ff3e3642fb8405a28eceeaab6d9f3e580a91d62108c79b19712bf98c5c2a9762bc0c56169976dd1d7dc8dd692d8f19cd75542d8ec9ffa5b262918f8bde1d63af1af1bf7ffba2fbfc4122319b781fd4d602b8ad4d3adbe0a76b69d85993b5399e89047bd45e4f1099480170b95ca513d517ed5aa9e57a242eb765a22dc989277142af132da043c058a9a217cfb5583ac08b1630b6e70c39f96d5007b3d57932a4df2d5682ee458dd0d3eb52d882bcf642b2019031a95bbe3da5f64b5ad1626139b5e4014d16bb34c9bc153f8e56eb7d9df8412937e205f7567932ac01b9b0395b49f1b23f4e5447282ff46cef1d1206d1beb86e616479f0f8b77bf0b249917f43f1a5486a170c10d804495f64d5377b55ca5617dde546d8dd5b3920f9b7bf89f670429e9ab162ea666ccd1a02f818e76579481b1516b5c428fb0d4758487ef2a9497047fc0ed1b767bc1fdfeac60102e08e3c6cdf48daf16ef15c9682842eeed90eb4039ef01211fb35ccb5602cf068e5321db5dd7c00675ad9c4fbc8f470eecf6141da5b71fa3d45f93c0f5b7092bd7efc28cecd17306c741465e1c1526d235b174037271727654c821900de3ab96926fedc48f103f3f477ee84c6387f448fe93a30f4a0dd0e05514729f63b85c14d050b4d116fb2a65b328db9834c0518efb86efcf6224dd5a173803483330e8753db2a9c3fe5df3aa1270929fcb7bd6cc674a577b2cc70a7e2d68a76d9f8f475b598869f408b72c429007ea763801a7c690ac0b6537c6eb2b9c6c06c0ad6aef2ab9186a8b3bbaabbac94af14c9f06d003251a6209f3055ba9cebd0a6cf273767de4fc1960d4ed85e78ec5e96ffacbe9e4a5e28cd64d3446437f5b1ef433b6b0ed6513e0578b220778d00ffe38552b77dfc0eb2eac9b2a2b2d062dc4117928c661ef4fbfc0f4b90843e8c0aa54b33d14e2b323659a9937b278ebebddcb90f730f0c242c0fc3ae01a4ccefe13c2416fbff30eae106e55c4ee0836d6c64ebb1eda1ddf831ef3385ecd27189e2cee6d854fc15806a20a2ceea8f3edc8fe4fd97d61b055e8ae970a098fddbb1113c23331142b4914c2d035f98df54cbda54c5e2eb86ccd33a22c65744cb911b024745b6f51aa9d8e27085d0f2c3b7e4e11f3b24766a9f54f3af4c181ae0d82b2b513c9af87475db4a686fb0ebf8a2234fd556c4feb511171207d05d43d6592a24612e3a6a183f76a01eb4ab5c0ab00f886d372bed0ec6a1b157d8c1d01592a71c3729bc4fa50319c5be1b743bac8e5d561fbd549b86713a3080803b31cbe52a210db120bffbd38e9f270d67ea35d41d9c2e2a5bd4272e19e8a172c55adba37379c97b09d69d0556a904626318ed6da9204d195d5908c1a21fccc563181c9a088e31b3b69ccd2ce917d16ac6f1272a761e5fa5138bc642031cb1edb709335af1c9e9b482cf5247ec8b9411ae2924cbb65c0f4da004f319f0c0a5bae8cd3e44a2ca94c2cf9d59bb71fef1af39d81add44a9f9b16ec2451c5190380e01b0ceb90c497261b9a206a21ae6f43df4105c5ada6bbad18b4153be8adf73ca8ce404143255aef1795bf2f2118a8c0cbb5378328d4dd64b15f4d9f9ae2b74d39d5556c79a9c0fce011762c38512da21bd40256de49d27d14f1605a18219a3151ced12a80fb4ee34cf06622f27498fe7038f8a2db90793be941dd0c084e65446c634c5e699a551dea0030cf6b6750c78d1be2738ae50f7e27b2a3cbef6934361db5e9b07f4204a9ec3ac64cc8320626cd84add9e984066bc50c4db17beba5b2c6ac4e7c857949dc561a8a2ec2edff9d8bbf687daab2a1241ec45c4a86e9decd48cb5d8d255dec7888bf89c8e385b2787a5e9e563bf18e04d329404b1968cc8240114f0c7d8af377763f2e7af962164d0766b308732d35ae71381471c70610d5d359b54bb333dc13eb45241f8eecdf538e6362a05d0db19960cb0d3d88095436c8d672b5157f368c378288fd03f51cce876f2875b25de9335a689f234e4a4654dccf9b92d2ff87c4b17576584cd50e78d0289ef9f71f05f3149b5dd35495d8b811f4fb700adef0b217096bbfa4981f6f38740a781650fc3017e5fefbaa261c23320d60f5ac2e4776473d54c75c553de82cdcc8c5b526a48f53c9b70663a489dec49826d10683c11f799e0cbc63da0314131f906e7395599d210cdc7f000ffd4f9268d5f2d7cdeabd240a72f6d2337a3bafd4d969959cc20cb8d51869990a617026f949f2d7212da0a1886e6a7a60f966905d60ba972856bc909fb0825d5fa1fc7637358120f426a08751a1cdde5c9c335aeaae3fc956d96898447e61e87f9dd882fe0734f61ee0486eee87000427d41a18aeec673145b172db9e919c04a97d9f18c59a2801004f0c35295bbdf530b6947b9f52920ef9319f88201cebc636d3166f3cd1cbe9721c221c00571c8aa24193e1182ea85b17eec3699676ef003b601fe6a24a8daf202394a0c65e76f792fdf67f5ef95528ec05efaa7bd92332313e03fa8b5f26f90ec3c218ca7d596187ffc2c22916a5215361730d6ca5d1edf2d78ba967634e6c9e4b14913253e0db5c2a6ba58695f14a46edd224acc2c559a53e15dbf46f71c40f98e6c94b80bd6f0b4e0f484c3ba88d4980432d23cc1b570d24de493c12d193e4eface6fdf2bed04202f32b8542b8cf5dd64a7e8c2eb07b44c2bdc6b184a89450e4fb06c08123715eb7968ce8d5ec7bd0095e14ecf16a7a06e978241fc39dc15a0588d0bdfd0d844dd2512c5dcd89832beeebf5308f4c0218f79c4248f496f589347a516c22b22e1d219ef22201b38b35d2b1a33cab70b584d8b2b09e3604a03540045fe5576e41fff7b7766761442a841fe69f26f677b71024e167cec88a70c8dc0f2af19a3bb4f79a232463932ff0a584a7d57a38a558b30fdf2d52dd43f46b3231e684d98b5767bf4fe976d9a53b92f1d7a999cb506a9e83f969a2111a79714e67da21694097da715967c0aba75c12bf1bde6d95c6a565d8e6c36bf9f6a11759139df0fd9c78c3b66602f22e071773772568cfa14c175dc7549d5e9af1bf5892ebff8902a6c7f1495cf8ee33f0dfcb30b2d28ddbb9b28129a8e47cfea8828fd2bffcd4d93ccbbd6a2e922e49c0a9cfad6d93d1a4a6d6eeda26d7fd645ad7638eb449ee67e7fed24438346a6b843cd8e20903dc6ea9a0c2007a096c04d5543ec5caf17992b3ccc36a7ca446409c1cb9ec50ae7dafde9808b8a47243f56885a96aa6214a1fc52f0d88dd22dd7eae525c7c299a52aa1f6708dcfdf17e75e8996df99f2d5a2b75dce2fee9baa70b556c5c40590d0918426a4afd682e3c433d553cf6af9dcf05657db693391ed524d6fda1a214dc96af7e7e8459c23b6edb5126780bc37dfcf7706aa5641b648076d50126a557fc52d2cc318ccac86d53a3c4e67742918655d96923efe1b3654fedce4d559d76f5f144352d1193e9da432d19055d3c9863e6eaec918080029e1ae51d370fb8b5f777dfe64e27a88369985578b5c4ccccd1daa370b7f32a44405f2f3f9076ed15a66e244c4431907ce797ad7ed0178a8bed67f98750c38f2e757145d0c6cb70224a1a8ec26b3418653bf3ea34a648f0b7af9b87450f049d630e26582fa6f536e821cc3a6f2921ce0804673c75c4d3ba32c0e10f9b58557cb6469207cc90930b0a1fa34e7452a32735291e3dab509173e3c4d8c5dca2060f5c5280c2e299e850b32fb1d24b65bb28012e819d3c4387a6f93e20b697acb3c99cb9082e331b71494e2ad2210b86050a9238308105be9d3f578d6c59b61284b277234bfc78d9f3b642291474793dfae80cb109a50fd787be440f0c9df6810cd9bf2a3dd7449e498724fc33c35c267625dcc13c48947ea8f53d0ba0312075ab15af84c5019f6702d909029cd1319179b362c701dcb5207122e3ea4be7bf80b52e7a3929d9e48d5ce085ecafb6cd4b2504c741e4acf147da96d12716a14caa61f85e80140f887d2c2bf27cc950a517a8ac5b628e894e2ccc1a4e4775b087f3ba14264e074dd842590e9077a6f24be861975955a9063760ed5de36926fd939c370a03a1cb6329dc70bed08044a550e63047b0d25720228813d4227b7179901c1ebe0db5dd529a0e7097e0ded6b979f076a575a33cfc4ecc227a4e2b1fd5f8621ffd51ac7994a1ee574aa328af40f7a8e44c255c97bba81d1ad631e00b14edf0014875d657b7b9e5566c08727a176ff875fdaa520b47f2ac9fc2c8f828df243b6f14489859bd56b311110d420bfb631110b2ac1b102c72926943e68b1610121e7d349c9cc5ec77059d3c611f7ba4538f6d6ea7399fd011104ef89061e0464ad4b6e996c4285efb49d342e847826ca26a634f7e723fa12ad053ccdbffc97bc59d62bc675020d8cf45b9395369c77e2f1e4e85f6ed427dc78d655f4f8c92d9726dc4adcadaf729201c8e46df18d5aa673a0e98c22ebc22363622eb0cd4abfba6484f9a72b95301fdcf7d4137fe9e71ebc9708e41c5ba97278d2152baf9a9ad330fed4e0f9208764a7bc623d7b84ee0fb0551e96f3e100a260d5e7f78558c00240c08a9daea2c13a75285edf7498eae429a26703672eb852338ba75f71d64b23b1579b52154a4816b677c0237eefa2f179e50fb488a49af8d18c68e51426024f14b854fc07a7704c84620c71bee02004799035b7fd5297dc93e9ffda41741421893c4082e85bcbf590ac774565fff5226e2688a17140aa8a6e912affe2143739bff921ba277e54e43d4fab83d234611f0bb81b3d59ea97f915453eab4f6c370ab64cb6cc84983f3773faf1b35917f513ace4ea9b3161972a3ccc62031d39e28e5c7818385428f31dc7ea9c5fe3091673a7c465f04a5603ff81ed291c246e9afe6ee7a148247e5b6f694dc955b22fa47b63ba5affecec6f429fb4e4b08b13c3b56d870014428b8abd62049ddfad6de200ea0accf114b8f1f0ed83edddeb92a4f68b00c6df59cb55b6fa09b79312b37554bb7cf53e69e0ca1196419f49b3a9af465b097a90cb9a19797d25bd2239db4177f320c448251e2b52fdbd270a800f969946bc184b8e1c8dacc625ae2124e20467c5967ee6bef10ac4de36b839f33f97ce2af85103692e19a5896b98713167ff534dfbe681e7dab706f2e332c29428b7cff50456ab2960edb18bb69db64601dddbf585079ed5baf169dde6bef267d5e8b2c22aab6dbb4801b733405d07b69c9d29a89cc79aa266ac3ca32d9db8a51a500e23a3a9c195ba0034df0cfafff1556f9fb8d2aed41b07013d75d415636c4e35de99c9bd1cdbd8894b2634d52038b6cff3eb265c0b2e509c24832504022ffd307a7052970fffe49b8792cf660c7a0c17630e28067ffbe68a19fcab14494a2e1a8f8a66a095b879d216495b64a4e311dc75d354b7c68c9d895677fc72318ee66f0dd2c084dd52ec6a9b6511245bc25201ed99e93b38ce1d818360157900619ac4d4c2804dbc9a92e4a68686335f09fb1e57a154ee0c2c715ca6f13ddd1f181a1a80111238c1653ef50636dfc08e0c6e06d2356817a7cf870bccfc4cd278299abb809156e00fe45231f7298e21a00d2fd46d4edeca5c7d0a67be7572b419e2e48365c6eea24cc251deb8b4c328a395339985c4407a3ff06db026022a00fc056d368c308583ec38fe7d362ec2df9125885149153f7cf2d33749242958ae648ea51cdd0f99fb76132199a9f90b67544a6656a008ee3dc74c2a0206440c54467ef0ea1c35766f9c410273519d65c34ea7716788744c6e5bfb008da25016144d13bafe48c533e707deb77ff86285fa212033ec84b5137f9807d76d02152581505434bb3fedf9d63627143ff27764488bc6ed6db479ec9418a848dcc325f9e3bdbf3997409c7e002e4fd22fa467db43b064e78967ca71bbfb19fd6633bed7bbda59ced0230a2e9f8f19ba2e69ef48160273eb51a324f97647117bae83036e2a93720743470332448f55dadb745aaf1b7ebdef3886f177a44cdba887ee296f22959aa5387c6b97ea5c6a5b1147ed725219d3ec7cbe3356dc01c0e21c5dc0587db4e36845d8bf1b688576cca6b32edfecb0a25902e4626026f52e58b430e46090239e29f159507f52a89c67d9a650649d5690dc8fb2dc5adf13a2e37980eed08a0c7e92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
