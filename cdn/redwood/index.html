<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"630e8d812bc09b3950c95820e9a0d8bdda1a6b7b51b5f703fde75ce79b143425ba19318c0d9c1601c91eb0bb5f243bd1efc9a8a57088251e44ef5536d7364e7d5168c8539f9453cfacaf797813744cf320e0316b046fbd2be592d3d01242655510fa71cfa067cd43b09589db377951df2e5bae785af707c591445147ebba3065dd570f2d1cd96e732d8fb26aa480f306693130d16f96c35b105aa7f2e5a631714a6e9c742e045307b5941d1936deae11c98ccb55bdd886b28414cb3ee39a9dcd7b469fa9a379682c63b6d07ba136a029d5e71014fc1ed2aa209895807b39761f90473d84fcda885183775c87d147a6a09c1dd40ae1c01d4ddb4e5aaef9233e3e969f19034d5b0d7a710f0dd067c34ec13d5f0c5cd6f48c8a4dad9a598f97658a3b3724cfa52be436e790a5572a49c63feb20a6e92311aaf617f3997f2b88faf4bfe371beac095ded42632a8269efb592b8293e42f7ed3a00ba8483cdc0ac9ea7bcb9344ec229bd509e603cd46105d36403f392cdc13c8ab109074f51ad4ddc7d18847a83ef47ab38d7fde7f410fed7e195eda5bba510731ecfad899e60daa94e1a49fe5edc4bffaa9c8b1c05188b0c186137a9ad52ec19636e7cef911b8ec196df574cc957c9929ec63392271be522a41004c4c8bda0a3e72a2321427a7195cf6ff1c9e5227a9d5062f5dc98b71356d7e1188f4ee970dde15f92fd544170213de2896450274c7c55c9802eb4d570b583d9ded1a1ab27cb5beb2d0fe68544ba70e414651d19cef8e221efc2965041e7516d44f33cc94c6787cf3deef0dc2f16560ce3b2e91fe905c2e96706365c7005e40e8e06be4646287d123425bd5a6b154b284f1617dd463580d99f119a609278de870d08c544db6f0d19081cf8dcfb61d8f2a980fee9112358cd1e8c04dc6c896ef985751e9d1bec09c380dd76da1d9c7d53a1500129eb0fcc20d80b361d14d5d8fb992f419cc47b238d90ba113e50bc32a7c175c1bfc2f7f89637a0b61fc7761c3edee972faad5306e98c49f23f97c3bce96b16e76f25c6f3962f797be0492d877b14d5c766e5f6de78832b7919e9770401ba5b8500638d7c93a4661e0c990422f92771ac9809538ce70a33051c4946eb8bfabc0134a5674752bdbac8d1b4de90dff1f72a82a9ec0790f541b87450004d912e4c99ad6aac02cf5bc465d2a6f108a528ff9d5867b1c46f8cc9d0f7469ce22912157eba1ad1351ac27017a3b0ad94237537982aa56a67d199009be1832a70347979fcd2bb0adb520709cf71666b5da7712246e3535a924817007df1a0f944b3484fc883a17ba70ad27e0452e16aded6a57f80ab9b33950985c7febb7e5fba82b820ab30005cadea7ce4eae259401f01827e936865187b357e1483a16006f0a2f5b20040397d17775afd4c5fc6d29a328b25073eace65c361d4fc4ab96647151c767d2ea42fb741f8ce245fbd417a9084f6fcf18d3a2213836574db7eacb76fdb091e8ea5e4d25883a44c81c9485c25e2e4cc6aa782f4ab1255f0f23b514adbec39491498a970b3886f7f6073b99353d60a1a481ed67e47c3083cb7bd5ea0bc9e09ec15333055bdf1c3202384192b85f20e121512d40fcb1fc308947065595d5ea2fa3497fc076859dd8f87bc891c165cff003d9486897bc1c36065c0df20faeb226ade7929d78d21d4ddfefc4755772262c862892a07e1547968338d47e4922233ee4b3ddde03dabcdc224d20f32e73df8b0c7a880c36413a120a2d8842ed703f4994656ff94af10957ae9c76231f9e157d7b97a1e4a2f5ef38c9f0eddedf3523e4bc553c8c33e878253fa49651a92d635766882edd5fd9926fd9765f38c7cb4606cecf1f76965d0d3dc6d314bd640cd1983b7d7f973ebff44ae37bcf43b01ac4df655107d195e1281107b6fdf5c9ff2a9c8ee684e7f8b5a9086dcba1be4a3c0e3cf532e7f33caf2a2c318d7d8641dc1c76580e386ef41ff65c23729c737fa5cc5239fdbb0f54099f1afe3212bd4ff938a4c7e50f6f45770916f4bb78979313824552a9bd0c983fa5a3f515032c7511120b2a7c57dd24e6bfad5e3948c2e3b31dc8d11522be7e7089bedf9d0cbab48e6c4c5e46390a3cb336fc2601deeb9e0baa490aa7856e59e7034461fcd77a9ca0e787cee6c220516578acc54771eb4f024627661ab154c4ee6e9de94583859d77ce388ca7cb4262dffe2ddcffa3ecb4632ec7e18e1e4699529f1430e7f4b63cb02fdf7e58215bd46e5ab54e70790dc04b263cdf5af40d3e269157437e75e681164cce74105b9445237a9f14587d78e57914296482e53010655249ca2c03f295217696482b0b5fa34cafe6b171344ccf90b7cd7d85b0ebc4f706505f537d30722c79db1e7a3d0b9e65de316d0ec09775d293de9d42ef1cc24a216eaae3c458de45cc6618abe5a21621b9f289ebe7c4bcaf00d0d20c3962a6df39e0121734cf44b769ae5dd991d8373adad3a675e0488814287e5a9eaa7654c12191c2602c283200c6ecbffa883c33656b9b585820f4a6b69da8810f8ee96b0b786b0910bca5ee76cdd05a743b2d747ab118f469a15b59cdd2b7640a61a85404020e5f5acc2959831aa61e29b7c3dfdcae5def75cb629b7c45ec9a68d3dc097a7d6c0f89c9d690326f640c92ad6f3c017f6b2d200cd82bee9909fa168bcbe6ef96371517c5a70125e4d7a97232bfa16a501723e3bde3fc26ddd189732830277bc4d3e36e222e3ebbf8fc2b996b80064cfa45b58db20cca2bbb7bae3b05c0519bb50e171d8a2095b76c5933bdad5c12d7494a6a57e820cf5fca0c0253903a456375cd4288f6e776848b68c8a1b5378128e84a1ee903e3a89612dd0e20572d67877036759770dd8c2e7e878e60eb0cf3f06340e6f44b77f3c0adace0e96ef8223ea9dbbfde1cfcd3e54002571e5209f74343ba3bd79867db4be6d6e7af7515047106005e2319f8acf56e83007b162258f40b1dce566542dc6b1008a143b17276c09c03a06ed437483573d3c6f62584057eadc0e17277f93c4bc70ca5ef66776dd094b54ce75329c86af6ff91acea68d1e70ab9038ecd3025bc5b740d4422a8e6e44c1eed7c58007fb62a6667ecb2940d30c0639325578ccd7a543a0a850159ed253582b39630b2706b2d427cf2da1bd86a39f4fa7ba811b8ec65e54b9b6b916021e14b32aad05a74267443b574ffa8151f25df7435364af45d03c570956bd6fefb5024b917b818f4dbd414b107438039ce9a42b328070c876d77148289c3a44d8b35e2cb6b0fb99256f149b5969ef192dabfd5779e7bac92aeb198b43b20aa2fab3f87b890705a28e3ab5f153efcf0e3e885058bf61b1bf21e9586992d10531ce7e92f81ef62c5183665162ca3d5c9d229f8ce7b236a176ae6a5665f844092eeafaa1bfd732bea274994c9ad5a28ae36dd3182b1b9f202e35c3c92df789ef33ac0fb191f29c91abd3175275b4379a032a439cf26b1b94ff38271ad8983f8432e64767e799a90d9494cade4a59b7ce93b2c8e5ac6a9fb5104ef91f852d5404148b42264fe6168f27d78a79bcf30c8c0a32b8460c696c2630d224ca1bbfa7af8da64d9c828edaecf822724c39ebc8fab88bef4a7d98d160fffb4c75ea09482cf94cacb552e4381577e652a37000d79cbb7b435bb60ab72484a311f3fb4a33c81b926608d1aa88535d32b95d0a710137503aa30768d5a51d1ab2893a97bb646102a3000502d00a7704f6742a89e6c97a45d16f31d47649e87848c5e6d6f7d732041e916a1aae0caaa1d936b2cedae8c86d22e4464b7193ea1e2729d561f84b8d9eddb52b50dc0385e2f2967cf85e0a596e2b9ef5705a66530bfe4fb76d9538bab842410b5d9bac9b0a67126fbdcf985dc71945dc58eb63dcf2ed7ca2799c343224bbb2cb62d5cd516cc755bfa863c12ca8ddb17c3fbe24446f57f1db2b5c4716c50caf4cc97eea4e8c90eec7a8b8a73e5795a4aac923708245e177b2bba6af7dddfafb1f74b2655417c19b986e3c55cf4481e9827a6e1a32018aefd27d6d74496b45c2c0d5b1984a9fd9fc20f3d41299883dec33ade6e00647725318501f5d201333b7554fa4264cd9c4eaaa9b343763a0405693b477e7ac9107c7ad8e69e5fbcbdb9511ac092fc383673b9b6b34d3e75b97d14575e27154d90ce9196522d1a847002bfec728dc790996e69b4c802e7d750739f7a79f2e6befab810409bc000328777f7f00f1436104718e0695a995e15116064d9c0480d00ec27a5b88feacdcac6ca196865ee77bad37fe735b12780e7bf0630656bc4ff4a11c8b768d4a6dc794e8c902c27f126bcfc59823889b08dc7d99f4b23d089997a24b9b08f4d941f6fb61496247c6146df10a6f90b435ddae4d13f619a04d1a5520499000360d0c76ba28ce384016b5cc5ae45713c23138c346dde087725c0be86e62516576fae0aa10a000224f10f67e7913a04cc09a56520b96690608c8a80fedf376086a604dbf810bf50a72f58127fb50c3f8df6b8e613a3d75a4836bf20a104930c44366f8439810b3f7da926dc599bee0a7ab4172078cdee087911ada48963936f6e43a2d198dba2dc6fc4c3c1ff133c3a4db6966d6cca209df4a45426e34d6fe34e666f73b871cfe0c75809e38ff999e36db8fe5ba76ed14911f4c505adc92bdff9b68ace46a94c4f4a5f387f4736273650f12a6113450cf7b95c82714b39cb2ecfb953c29d1ea9647bda0141740bd376a251315a2301c5109c990540de497036ae762c9fcfede8f07ca645c74e2baa16fdd39d84f785e72ab80ce3ce35e9906f5a078c076f15c6165dcb7aba832463aeace0d709a1dd4c2b08da533abf14ca0375b0611d9a64ac2f85ea91d260306a0ed12d081be67a89a882aa83bca92c0660bf59beaa6575a806df382557faaef2f02af214bfaf54c8f89ba2acbe9590b8e3eb1781dc131d61decc3b54416708b0ec16d1ba18c4084d50916d21036f9553b1073bc467eae4a5b22b06e042b4b99de078a78de02be8e75bc860c79ee53b96d564a87c6d388bf45f54b31455a8f190ec62ecf8dd44741d49289d67858941915596fbe7ea611d5c5f70bfbee1ee35c138b3230de9d403cf0382f2b796dbdae99ae8866dd638fc23e5df1a64206e9472509a2c7feb83708c8f939f70e950c570842bcff534306348f576005c42cc6c32779e826390d4408ebe79d626a8b0f07f5f9c2950c4b1243788396815172b1cd3356d60d443038dbe29fe798be1e8fa59a6e79ae9b0f53bf3d19b34cc5f6f681dcf4cdf152236db17f3343860687d5f8f442de21d3d19b679844fd926e1c5749d4c1a739dc3f73d6c55acd9498ce2e8f83395433cbb8ffa6a8fc76bf045b22ae417c491d391f06c05e0ea3c04d29cb0858e0cecd0728e97138212f6d7a4daa21370d23c50b565c621b8dd3dde44ed0054626987fa4e0f9986bec58c72d625df7e05ad5c14bdb56d84ae7dd651b1d33442f8ca592addf940419f5e8561aea5fb2c7da795af21efb35fedd01650a7063bd961f696a5b9df3b216b10f082b68ea1d594f6f47fa76411b87a5aecce6665f6952e8386b0595119ceec1c561830c9016b7fab344b8cd481af92ea466bd018d4989e1245662ac4ceaa45c2fb85b6c367d48249288a660f0f118c94f7e2ff9fd89ed0086b395b9a8fdcde3695e8f672789bb74298a38d03018d61bb9b67393c109ae286b6b84904c786490b8657ffb657b4d87b076a16731a7b3b6bd1abe33bda1035cc6d723a104b6090da46caa897d704c98d90c6bea7e8fcfc14ffc059db738d214e5b1102979866bdf4517b24aaa6b8ea1bcc2c4cf269fcf8ec07b82d5a8880b6f35609c26719ba3a4fc30b0c26d9e9c25633aaa84bb05be20943c19aaaba76eb27913335f2adad197495163da6245ca5bf2b7ab89ee076d71469a249d4a44c18b37d088b4097263f8b18f7fd2ed32c55a2d731c6980ad72a017c4bec37f2ac20f9bb843cccc2458de46788f7470ddce5d9a027ea7a0c72135c886e2fe6cb68e2e391bd2857f1bed5fc9e8ffba963896e304909108c21e39d1d1c93549f61075baf7d13af7719ce6c8927d436c5364e4e1b45ab7163623d0f6957e828699b256288a7e61c89cf012ec5169979c8b81acb7dd685567a1f4e79a40e1d47d877a09c9d0fb5caf9bb936b881195f16f9e6e26c9e84b66d31db19b3db0219ca237943e1c2e158c21444e8244b2e3f441964e45375735d42169504101c65c2ded62ed95caf6a267561549c12622b2ec1c05f4e11d3a46978a848ad03c526f9d801710839774656d810aaf17b15a29bc103641ed8be6211db2962c7ad39aa65020c4dea98814ad817756ec0859422bf288d5d1b300a3538b10a0344f9b81d2eae706f61767d7118e00cb302370e45f4270b5675eeb3fdf66b4d35faa6c820b6c973ee95b7112bc16a53654f1e9284fef11f16791bed4a18c42de5445ddabf9b73536f60580db5b9fa072d47f6215124b85b6f18ea213a90d692c89eb5346f8c515cc0fbbabe2ebf936fdf889000122e6f8bf81f0f9a56bbbc59c232ddd923333845f4dc98d60de5c51ce57ddd2488ab21b95cebf0cf5fa45c665172d20212c55bce8f5f81a8745bd74f8c15e48db089618fa4a029fb245178b9d96c2b890ea8b3befcb4d99faa0003791e86e9bb9f28b38beac778148d54720a5c8730bbd3c67d792a67bc606bf176a928316d25b5640ce484db0d228d610516a1d873e8a30b51a578c7cb9293a5894fe78a286e6b69ce4c492bc3862e787beb1f31c937fd80e14a0fc95105fa012533c6dddbcd89ec60c796662826d990e7adb6872d8957346b3ec4c19ee5c8f6128a8c8486ff44a54105bcc4b0127daecfc78edb2b8af82424331e2a494cac70dfa31670ed9ab3303818b758985500b2fe3d54824ff84d845566c2cb53a96f75b2b16eae458485cc0a06a71028ae71e3f1abe59158c3970033f71432846732a283f4d709e432520214f8772efe7b315fb5ff3f335e5eb111771d707432ad0d51359cbfa37069f644f07f6984b5845836c272154410659af082988ec3955ef504b4c1b6d2e3279ba080da6d44c50f07672a00e6bb178e23b7151ec87a6931d512c2f126aa8fc1c3848136192516be94628b8ce51e128f18336a5b3e36a686943abc4357671171b93ff836bbb45d64112a278f543cbc4a241df878a1b21efd6893c04867ee380c08faf4b3eb0c3eedf26ff00df8bc3450db05cb771ad983fb8db0bbbe25d38c4b23ea6987e5b1267dc82080662cbbd08dbb76f631e7057cfce55e4337c9e39a135718c4d1cf896c2af01208cfdae96fdff11c45d480a572d9e195b7f536264b56c741ba30494bf1474521d4a2d944e11fa2b7498dae9cc077e2e1a8489333e5984a8b5b70ce6760d9a6d72d7c62dce97604c6721a564d836657d7b7a1b51586a8afd6256e867b20d31298607b72e99b47e31ccc1b0ad8226879856ca1fa9c052cbfcd0d6d38811c567c782b729b80547a37afb81c8e70396de6602243e2f637f33d7e2c4480fc7b66e2540ffd2f5b25d67ce08809db9822102b49ede28a9d208fdc49a150706fd9290fb1621b7bda5a8643d900588539770b6c3cb9f6cf7a77fbd767b20de488c60ca8bc120e9bd7831d2dd644051f28802b1542103acb7dbadc0de056e84592cef36b35fb06a2cc75de9311cbb879af314f6ff8f430fbd1fa2e514524b2dab367c64425a0350e2e0a75421cc6a4c77ff5642b1015dc80aa6d427324eb432a877262f9f6c71f580ba92a47afb05d4cd82c254021ba87f0b7f2e4d3e65f0e246ac579666921ea547517e6c1acc9017bd8da524e0f0cead45b813d7b2d1412ee1b99753b18496e63652397f9915fbad3c83d48deb10ebd2d463885a3c5fb552b12bbd193cf8dcb23cb1ac1037c3699a99b340d762eebbbd2e43ef2d682e3e626430e8d8e433a084b8978e08f01911fdfd4c7ef9fa299eed0cb51b46646bdaa29a7bec64de3ff19e28d43bda5471dd1c2e22f891abb4d957f2ac7f9d3d8e674a4be717cb490970822bb0d4bf487dc97ef8e70daf86042b2bdb87dad7bba2acf36718bdfeed7610fc81697147fa3709ff6ca2462841bad2838bfba38a472b15fbf957efd1ac46222f1fadd27607a582d5ce64778f95b7d6650fbbaf4be7182b14d271ed272d2dbcab15248858a0ab7c5eb909585483b0286f5164299a00b3357cbb1435e06c3180aa6363cfe2001cb658d0a2f2f5870fbf3afb0f419ef5edfbf9976ff38f308a8deb1df8318d3adf623a238aa3c92b8de2bbc31c3199e90e7f605506a7566c8fb765c0500b8f579b4754f74d9755990f6d948287b698ac40d1244ea4577eaf2e3ffe19dd2112f81872d02175d9e63de36b24b4b81115c1b1694826371d8bf62524c0c76a9990a38c41f5b1c24ddb5d8bd06a55c4799cd07fa72cfea4f6298546891f5f7785ea7cbbc42b4b38606f28a1ec3ebca762a0a037ccadac4ff5fe1ae2e0053f2951bf3fb3aa54a46a52fb693b54a4e106226955c885740fbb6025220a743753670d7a9628ab4f8ccadd7322cbef9f893020c2fa818ee49ff467e8f760efac6779ee10f11be746d69b797344ee76f60b0b4ca4d6b7f99ecfb83745ee9bbadaa6a316a68ec093577d87c0b5327f05f6a70e443e306cddae9cf9836ff958186c827c768a3198b2d8ed802aa658e323a8c8823f6620d8daebb84e41e0d764b12fc8a44d342472b0a9caa2c9af78d8cf0424f784b0481d50734b3716229f257470f9362c4a00b671c1fffc85a220733a0f38fee57e7f2c691a4bc9fca257898e10f54c94ed9d634bd3b78cb8f088b972b43410c6bb548030ab6ccc5b62d248e05502058b217f035556354055dbefe2807cefe7ca291e2fbb1d5f50cd424b4c80ccc3439bee413748c6f0da5951c3bc18fc7534abe1df94c6b4a47c369e290677a97463fd188bef30191c2074a810956ba48fa7e0a3540b3c38ff2eead69568d4cab28ebfd4c7527b7107943b71631dfbe679f67865afb03d180c5164c30de15ed4ccfbe9b22b254a33fae3a2bbd5ac6af49c751aff6189b259b0daa00af79b386046b07e666169a542aafa85a4d16f9aca8e0dd9705b5b584d8594d46971d9334072fb4918520f260a65d5692a80bf6db18b081d05e8615d6ecef4db025971b4394b39011b9fd62a52bd915dc4168abe4184474e27fc5d2036d75470aca0a8c0aeb6114e87be4b090a7286a0ede99b75df485cfac4e11c69831de99a66c5d39d4b381a15948fc95036db5fb3f10726f553515c4df6d9896feea815e7aef5fe8e24018ebc00f49b8e5121715640e5d03e2425e7ee14af20708ad9109130a7fa6360eadf95abdda1a5e0f8ced84d78df194daccd2ba83490bb346dfd4dc9db43e1572dea6f5c6b9b39bbc43541a44efeb97b6b9257d606a6caae67ed84a1c89185474458be33b11eb91f4475bb84249eeb643df6d3ee07ba182a99bf0e9c0ceb280474dc8c64475f793d801b2fb90dc83fe1989c97767c01edaea2a85d48ff86f744d93eaafa558fd289ddc6946da574782c2153d58779f8ef413eba8b760417fffc6c59d5a82b9f510222ebb8500492e2578f8f137defbb030e3022d7aa08c204afc258536e6225c7631d1047af27ac06847fd00da7cc874f3fc44933ef894ddb3432fc0cf6075542f2d400f2c3cd9f64c6794e614eb55e4956580df5089bda900ffe3bf6a3b118f71cc57dc02b4a0d36238d5d62b1733112c898b005f763e2e8a78e3180922600732541487e1cca6871f6093f12ab3a73e67e24df46303888437b3d3d417670b71401855c2be110145b39a8cd25cbb3354b42e8899cf5e4fcf6506f59450a7295cbb3775a2366a64bdc8cfaecf44f3766fd52846dac3336cc8e75396ecd22339b5234469e61e4c91de6ae77398be118333f6749572fccf3e027904e32e7393f631b82bb213da963b14688e23fb993ccefa01191c4457a2b1dec3c0aba9c28d3b5b27d5b7db6c74e747560b04a43708131ec9b0bbbd944d0fffaac6290d59087b983a0581175ea2a4a4cfffb6df4a18eedce3d7a1fe6c65edbb2ef8199d596bd488471883b0fc027e97e72074c571602f7424591b8d4d5e0f602275eda3bc677160f177b53aa2fdd33c8357e567f1a0e3acb408ff9c7db24a2cfe71b1d48129429f4c60c8205fe613c884c1b60cafecc38b2dbfbd912d7e5517c46a5b8bdfd34648c7245fbb16d2a1fac4a5ea61d6a8baae83be698e8252d948cbc5e4f63359561c8770271414662624f6a5107b1dfe10ed4d0ffec9b47c0b92393eda5edd5bd309b9d0d9a8235f9ea4fb9c7e15d1a27b92da05d4d28bd4450f309d94aa9b728b68b01d1b27ec9e500a22bd1f14283850be48b8eb4023a6cc6e5594a063704ca7af71c1cdfda59728cb20ee66599b82654b4c1b55ab7aa7976cfa5495a4ca3a8cd95c97a33e489e7b80eba4146d6194567899120502490004a6150084dde299c507bd9f5f7fb53337d9dec05ae0f85f07beb849117231ff3fad19ef604eea686f70c5873863e1264aee9aa0b3a452bb7fdf95481efc2ca2c076a26ba2eb5c015856782a750806a6b34be443222b1f19000cc44deb416ef55dd00dd7876179f05aaf29203a82c90c145690a6ea9db80e861a472762fed3976179a989eeabb4894ca637bcdca0380cffd827152749c182b35c96a3f14305a2ca64a9fc2f8ae9b933552644cf62696965bdce73615e949c5c38dbb5ccdb3820862db111e9a50e496363933b17ee7e614997fe312dd693ee60b8125de8205e8cf81720f49d17def53ec7b1d3def35e18c3e4759cdc5f1879438bc8751ddabd35c4747681ce207e86858f8111d834eff72a9f573f6051c6c50ac511f820b2f0d44958a02dd13f59021b5d02eb55a9e9b82043920e7fc24047f675cd88a3c4238b34fce81b6d2f5be0d858fc2731fd62012665385c0379ad1f22cce5ddd5f63aff41326acb84f86c4b7de8bab750864a1d14d46cd0ae1afe3d629cc70957b071e1bd070cc6b9912c5a3aa1709e035cd75459a94e6c6b630763db402fa7e687354521c090c34380d1f4c959cbe0fc9e39dade684fd6b9f65d0a7ca21b149a3b5db98ea803b31212d480984cb56c01e20438f656a36c403f7e3d8f091160fe8118415e3b4254398b7626638cc620cb06ed0b5b1d8b50246a469c4e1147a3f00a689291324dd68d9577cfdeb35fe9e5ca214a0ea8b6bd7c0eb265749bef520e2377d472fbda0916388abb3874d94bbc7309f2eb7e99dbde5bb4dfe535a6c7668e17d0c139efe680dd1fbf2c92950913d0a3449275b4dfbe60ec9fdf571f7dc78bb3b4e756e371bcc5c9e72cf80f28c99ced5f189e6fb4c5274433bc9146290dcf3761757ed60fbcfc1ea7c7e70c75b68d89ff9a57aad51d7f0c5643a18d7be3d02aa14d8ed01ccbfc62f47c831f5dba2bed7088844e995117133096352d4e2adb37b97046d344111377e0380a953cb1b2dbbaf1c2180714228247f63ff0a2a7091c3c6f8425f66fc6f7563674bc2cf86b8b9a7feecf346c90c32ea30f709b6abaa5364013015e7c31534c5afc5fe8dcbcfb7e1a000283eae1167ef71f6719795925cb47db8a027fede0f5160e9f10e82f05b694e9b0a9c8ebf40d24f2450f3d39e839c64dfbde3d29542196ed24ae36b5fedfa8749a588c38e5b2db087471cf652009762102876c2f3c4fc66bf9ad42eea01a367af12c2e1ec75b959a4eeca052abf83a5841ae965312cc11094141aa6e90ddc718406021f1727efcf259a238b5c0abb410b68af8c02f8e3dcb32a4ecc60844e298727561d234f963bec43742306dfad8998f9604b0444fa61623e394974504b2671a06a45a890a6e72a4eefb61575d5cd6feacaa297ef57ef73b84a90ad1457276f6dc21148afc7d432c1acf5e8f9d8c3ce677caa3739d35d36c67f06b77efa9fc154697c9ef225b97c634e20916d97f4f7969bcf78645be72abdd5da9b291755c906449ed72f6968131c738cd716da5ac45c23522075ab30f6b28541a340d226d812277b3549860fa5dd1476855a2882bfcd7e66d7f08b501dbf45e0f795f7c077311ffa34cfd7f6d0caf19a180d6b0629d731026d44a0f4f180e15820fb0cf410aaf6c6b3057017d34ab84451682e30aab39fdf2a6a8182c7d41feec4c22c6226193eabf94b936c65483c10e5729fd0cc32f5c54636814dff949b02bc1b76a79669dca2c9142f979ff1bab8daa53d1356b35923efa56291582be9d0270c2cfc0af01112388150613cce3b2e709df7ef408b3fce0dfe4b79844d8a447cc67430ebccbb07e93b211e20994f4323e5be2c3b5f994b58b29df26eeef0f5dd526db9bb6c21d0df51a31b550386dd59aa3f953a9ea633dc1d9243eea31574a08c4db19c902a0c60bc14a99feb7431b84bbfa9f030657bb22d04cd8ce63d93092b09bd03bfa5d6b0a11780dd8e703a52665e84f29e0862b44436380fa2dc63eabbe2a87ca0ef343f692c986d36af801b0af6747b6c7422449fdf0c114a85b50f4904f945984bc611e63cfa827b99adf0e99ff0c8071c2dbabc552efa519d6f23b5574a5cf10095f4ba1cee9c00f31ae881046d9e4233febe86c9eec04bd49e0c69de8c80e33750767516766f01296a4d8c45709b9b13488f3b8be13e49da803042721662dc56913e0662252a16f8551fb475bd8d4a58b1eceff77ff97c7bdc27ac497c2e14b3699570bf5f659569dedafa3d93d34c2e3ab3b3cb11e0a2906af92a3a30e68cc9eec97160285a79ae2c03dcaa07faa6f22aded2bc2f6bcfea04ad2cd1281ba3724c94f48dd6ae0b6a60dbf1cafe063372179dd79dbf7da164f2de3880324eb00a95d86c63c01313baf5481c8a7598f76383673556f9583d8bbc97fe703c752b71f7306a122580fdf135fec41a3b777ec0dc972c3a22c68c90353fce85c0407dcad3bfed892881f095e1dbe503e8dd2d2fbb026f0eb8fbf353f2c261897263ba720b1f87ec598a9332d883fb3a37b5aec3a7db94f0d8062fdfb5eb56b9507ff2a90aafa43f57f938396dafcc5e5fc810a08241765a12f6cddcdfabed03c1e6179e993cb337d5e12151c553aaa45b9e63d03c37fb887b93bbf46a5469ff5ff83a65831d27b10db7936011b5299d8a92d74684bb504368a95969e1235222b8f09637ea3c7e9ecc69c01b79056ad00cc9aa6481c52e0f1700dfff2946a3a81038e478b4af62c47f068bea09f5e4fdf868e96a20930f69e2de6737286cb1de66bb7d46f763318e5464091ab746931a1e425258c41eeb125e091b3aa13963df279cbccaa13411da031a906337cb3533cb238dd24595fd73914cfeadc49791ed27f7e02d659a3cf8b8d25cfbf26180d052489460fbaf5dcaf8c50faf140220ab4090794f5655ca9325a2491b08731a4186933c1ec9dae02203e6b60a2dd8cf8d5f7bc611bfddc4808b2eb7e8d7e8dfca394358313b960eba47157a2eba7c3e6975ebce7b9b47d4e0e762d5a467ece3f9713b1be71e6421c8570223c8357021733a8e8a202b386367ce9c7c56e49eed3a71ce7b991c5e8eb0c9ad82604fbf41ca29a1b99f06c90cd5b8dc5b795d1f463c926990cc6e0951c6f2b002e3f175ede225faeca70a572940123183cafc724e2ca33fecc5842f770e41d80c0f6be5a2f3a5fed6d5f0ddd76f4804a5dce2d652681e7aa6f0316590d2350cf80eb46a427f5b1699af9b99feebe03e51e0785d60e2a1fbca1274ba56d330ceb31c43791cb882894fc1ad6d40a641cbb7d3e94f589c8ad6482be88b4cebe8892645b99231fb698c41cf1d36c0d3bffd3e677c9c7506898caf2337dfac85cc90d22cb0bc3306c3747ea84583950eae8cac7d57798a817723428a5612d3c4a6ca9d375692bfb6ff40a09454ff3ff6e50e95bfebcc8d0531e71a3b026ba7acb1385be2c2b7c5cac9ca72bbb1b6a037409eb6b877497f31bbc17b6319b8c8d64fdcdca6a1e1e8dca4f0f4bfc32a75e82566f7b0a84cae16bd566b3f64e01c902e58447341ae8f67b025e9ca82b3571aef25965d20449a41da45f04c0d1804fa318a171497f7de65f68c3731462b940e8a6941850fd3878a8d71e751b7e504bb4af06cff04148440c4cc5f3107aee411fe2d33e1e92bc6b49305e2703964ed0ec98afa93f6c2954ddc3651be09a00f8917687e52a41fec4642ffd9937df6e0a95fba30d558b2185c163dfc12574eb4b49ff51ed89dfbca379778c8725e5041dc1db50135f5d9067ef6a21b40e6dc6bcf8193a9b415ac577ab02e1a08fae32904096ec49df959b5a78890566703864b949ea859a214ee64539443e95bffc44007409d43e402e5fdf501c12d5dc71337edf10d85a16b2bef85d568af92037dc0e19155f8cb7f8fe7bbe3832b796aeaa18574c30a65f0bb96d80bc1cebce59b9337b374a4866aee60c39250f1fe0120ca2dbaaae9a273e5c7e0025d33a92a6053568f9f31c51fb7281afc6de393f9ad10c63f70f8b0b9aaa3ba34e030c5b1bd85df97ef991996451c1e731c2730dd984e33f3121a7fba462d64d6834f270abcf8efca2046a74c8360e9f73beaca10edc8864f71c0621a13a63e8d1d3556e22043593e473dbfb663ea22ceee43ef9a05b56409c029967a8ddda889a6fd05fb6c3a03eea11f1e251f4dd38a0469ae67fed4938f48cd09ad6f91a998f84e8bfd527883df2b361037aba2c6ad0ee1bfcb3251aa8c9d9d7472dc7fd6d253481668c548bb0d5d9aa411b0abf252c9faf665a6a8bed40430d70a342228952b26c556a7fbce2ad6c27471fd321c62535be736c58294ae697cf4ef880bc13d3079068dbe8aaf04b495a7f708f4fc6af35b6e78e39835641c2dc4443e299bb268324065982f10423191a62a5a762afe5ca3511aac3d55d98718e30177fe82e3d7890ba13ecac0a7d997c405612df96ab0c98470bb74bb67fb9930e42480ce286cd420de8f6d24677445768a5d8f91750efb8c543976c37ef004298949dd9b1d2d5e84c3aec66f64c25f43fb418c0599840e83c88a76ee1baece7f69391e0f93676cadd6f0b0187128ee1b2d11cb904ac490e6337ef10d136b260aa2c6923facc6fcb4687cc8351d14255853fc6b6fb6a708ae8c1b5a127517f0902bc14202769bb2d93f35d106584a95d254c4b484aa8cc4ce573bdcac4ae42b339ac9dd78729ec1f2ac4a197d57bbead91bf6a5a90b43decfa81f87cfe2a24150eb04c60f46ec32ce1644eb48707545c6b12d9cbc2d49330d8656eb00da610c6c71b56c24fa61860c66b0ba70a76929b8f3a7d9c0c698a440f37b7458e57635ab5c53b36a27dd45ab43a45e4de0338cf4697117d449cc7a5f833f05f92ba9d90e783a7ec38aa92b3599b226b44717a62e40db1915dbebfbf9edc5a219698f397691cc860ba3ef9e5c404846a587f987b3fa1c24a95f6d733b900ac9e343e3022bf511d4eea5befa4b5ea02d5168cb869644495cf2763b414ddbf6af653a54349bcbf2fe55446ccf1056ee23a2b9f53d2bdf18924248697570594e0eb7a4ccb015f3456f0d85cc68f3e1260ca37c7d68dfb29f62dad51dc8cbb9fe713f863cc793cc777ffede96d9995f80f2d31247f796a4d583d9bad3d1fbd2175aae917302ebbcb9c7a1961aeae335014258a632a5f964e188d1a621acdf2295eb1f2c6e84d3dc0996039a4c3a43c8424296517e929c0ca1a014a018a029feb2f6dbd6913ff6eb8c251ad9e3bc13e205080153bb78f153960c3e18a36483efe8e983b2c0633e97d0f5566b81e6ff66c30077432aaf69dbcb75be73890c18d0602a540c71296bd9a580f33f4138fb99a65bf33c9e19caf2914cd2f1fa5a61055227dd52cccf62df5a1482602638f54abcb52644c3037d6ab95edae6d202fd046ab3eb295b75f73fdb6ac68e01414987203fa9bd6cd9bdeeca57c6e44016234ab2acd11ed76edd093c95b56ceda3b2448ab6fa682bcceec88b5e4bb318bfeb340382203924f9d766f8ee69b07a23ae141d4a06ce93fd5610a0a8201b2bdeee083bd7f46ea63162843dcfee5887c09ed5d79e7af7b5cc8b8871390a2a067f3f7d69c77523b06f8b20cb18eda71e2787972cc2351ffa43b204de1efdeb633f76b6c91dbb1b38a7fbc2676cce5182f78a61e606f61fc7cda6b216ca4f6339b5127f23ad53082b3b00a4b5e7b612b60454b8e7668780fef5a3d3b73ce3bda56cd78ce3c1cb44a08104f52aec94ccc0cc2586fcd7de234d9155ef406f50934f5f3a8610aa97318df4e8a55be1f426642fb2ea2a2ca120e52486b2e78196e51524dd96c4c188e19f6853a1dda3f66e9bdb1f40f8eb80dc4497db7574b12d1f14f00c2e533a883661748f345c7a95afda11088199a2ebad4066551c77317aafc61b30ccb754696ae9546b60e486c3e69cb2144c6c482419d9c454e5fcdc6c32efa6c6eeb31da32b5aff945ad5365f3af8ed635e3f81990cda91fdc8c27273a781aac1c486478e11278644a73587e88458f358f84709dcb2f0fda3eaa461b7eb27eeaaafcf4a1fbf9d8ed69efba01ccc96ed7999785742a32780e33b36fb8d1e2c8d12acfc5c741b8699bef56688939a1a27c7f13923e79934b7ab7d2525620a6df2b859fcd91f0920000ebfb57b53ab9812de7337f3a198d2ba78978e8e4ca16135b3fe942895d3a8d8c2a3eb9b8972144d19b4a5466ce4dd01567aff8a22dd90b03c8d6d6cb869bf49397794b5a6765cf33ce6d6bd5d77e6f67dfcdbb1614f3ef43af04514d0649a8909344ebf5246706e695ab6394058873556cc9a6d96431c646077f902315c259e8dbf37902622d6d01274b9d42e579f79af973850381a2e918f1fd099b9bd8218c0b9e00cc841d10dec195a623da51b8604fd2eb62f6f504dceee63f3e2f8f0285b0504da15d1d9b3a42e280edf97ad72574ae42a25cc0c3e23de353ada8b2a11e5a2d49e4b6d5c5de0836f1afe2f309e26293dab382c77a3e34f0819e40f190af3b1df7fdf95bd3b20da1b3300d20f9e73bd044f2c9664e418c975811b3a494a12e3288f53e89518dca26823feca69581f9c4fd002ff3429fdc476db934ae2c43e802f45e56bb3e273cc42cb2b8831db5bfd877c9e1cb402e98159ff42098497592778dd2a0e4c0e59a40e49af19e98379c91cdeeae08213371b46b2678aefe7dc2de27df1d555c27ac2a4e6aec4db4115d7b2e3d69492b9c94f6e9b836bef8afd5e4174e6df2f5887d28b69430e3e5f1e21b8e7dab51f6b7b1b1049bb51643b1c9b9abcff0593fa302466564c7c9228af43d699a965c0108e6ff7a1dee36663b1212822343e7cde1f72fe57470da0358fa911a9a7a962e200dc78dc49c371a2c9fbc635e3ed7081f1332ba7dfe3a94ce651aa6eeaa5e2ed3822f094a2f2ea8923d8db5b19bb7b5d90a0aa29c5c1682803677654f79f8a2adc28b4f9c0ed1b1cdde6bf63bfa878a24df2c6e1441fdd5c69d93f1473a65221fa564d1b19b0fdc637ce68d592c631ff298f34ae8257d4cfe0344c9581bae2094b2d0c4d507591ce8838e23b73251dae97fda5f6f4ba760eabd701e9dc9c4b1ee13148ea264ee65c1df7c62e5272a247be46b0de5bdafa11a6a37375cd4865b2f4d9f098b07628424569ce76cb9b557cd6ffbba8049c06ef78ecb26f790acffb409120dd58ec3a2957867bab28fbf80c802eef75c75f7b02ecb5b87759e424364c6f90ce0012cb3ba37a2e61a91b644aa9ef25cb4b0bd200cc7a8dd91e43cdbb48f72507dc7ecc7d92bd43ae8eba7a09fcf587ee01e2d880ad4ce3e9f1bf40395c23e6da3c6af4d53ba2102c187bcecf7ea40d1ee087032a7edf103d3ac711d3ae9c402cb40788d8c89673183cd0f062a245cad6321d09824cee805bd765ba52a80c93472575ac225860c4d4ddaa263e1ccd666bc5fe81b44ee149fde2c97b9b1f94235bb5e9c0256aee34b502304245a87bb35e6c1893a3f6ae73c7527c871f4442459830097dfbf290de20196f97bae4f3406004743e4f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
