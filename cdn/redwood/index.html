<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74d4b2a626903a14d2d7f3f5de3f92c523dce9a5ddd9eb4431315e8302c606b791fb37adf43196b6d47eb8b90abdc2659a850378f8b19adde2d8ae5e802bd7d993bf3b7475a05fb31dc341734fafd52a3a4000e6cbad692121ca25c7b3625b2c4e78d7ee6d0e75a22b3ab70c5fd1ae70b55d68d3af904617cc74d587ca96ce6c84cb0cac44eaec44e92539f0a94a0dc681ce366607348f8aa918020d896d64904e0fdae6fe934fd22cb52a55ad465e2e93e9e96ecbd05af6ce098f4ed934bb5713b8b37ffc1d4060f220aef8f866ac884a22d396224a53dcda8c980df8999b86897cf689dc54846d0a3f4d577ea88d652cbd9a21ee9d82e845707560f43b51ff9efe761cfa0f2c6baff278aac322e8e4b867ed09f2ebe0033a5bd8ff8745b4cc8cf12ccc8d70ace0fb2eb3fd4fde8093cdf6115a7bfb9d57807810bed2ccc43d407d26862f45e4fa6f2eb49798ef192ebc2b9cfb25096612a6522d133c87a24a3ee2dfe967fbcc8fc9f92e2b6f3cae9d7a68cafffbeb4aa67291a62dab78c0ce026ae7c3a5f3a0b8e88a95dcb1b8f9ce3203f5db0e8b47697268b679ef3c84af8c58ae45e35c9dea87c4b24854a33838e395c8922879618a634e9af05b1174e93de13d0cf8b5399d00edfb33c184d26cfbfd0d89fc818ec695e3da5064205164ee03563ee4da034766f2ec7dbad14598cc806cb9fa5f8195c2e59b8700cf1cac09d9ab27735a4507af5564e66bedec8bae79beff42c70d20a5d217df03722e45116c7d3384e359f2955908a05aaf59c4d4d3f6a84c2bc4d940b758edf33c3ac6c89bdf6867617276896898053bd4de275df4857c09df23d5da0ad82c3496a043231ba4cc97b37c4a91791f3cf2d00255d26160301fff7191cfd1c168cf643a2b965066ec1f579c6d9cf466c4fef6dc16dc542d466d877acfc1028f5313cd6e19d26bac45ef76250d91a2cd250aed8918701554dae2f8e769e3420eede7315496598b1f1c62b4ad049648330dd1b21c4eaf19de785fda43571ea1a73da69a6140739fa4cb40571418d1d35e82ac298783577ba426226bc48d77ddde4ac07bce0a84a3261ff1203fb13c01292b4006416b097d70a659252ffdff8869a1784c8034fedc52c4e921cfb2fb3599cf34f9d2b0c90a16a1ae93ab25d0ca286ffd0c0e40a80547d1c7794a89dfe32fa61781c4602fa1fc7ab4a454b08607b5a71378b72543a9c9aa6cb12473433e4569259ef0b9cd475fc7ea5d9b435afd1e39df449e9e3e754bdad93d598b9a7c96a4a745564ca37787019e5a6c01297071340595f162f716dbe6f125311b37717fd8eef7178099ffa6ad75cea87626a7c4a69216a196c96781566a31567f68cb67f9b0679a9c0959346d318b246f0babddcc9c08479540cec4f4de50312021de8343497d7da8ad00958bfa101730d2190652dc0f8941a59dafca7e4dfaa6fcbd68bb88d336bc1fe79e242ea1e8e9b1e2219e88548f77f8b20c10cde28052f6de1e7058b0f6ade9fb31f1b4cadab3be560d1f336e93c19a5d3f6cce4c45cdab7e8ea382017910bcace392da52e68bc462b8532579978bd47f4a83051ef7eaf60e92477d416ab96e6e38830d5d0290452c1eb225c597a74e8367d0ec60cf9db6a7bb53dea3ca1b564445be9386206ed976263b60b5b14d2f005964909b701ad1fede442ba33bcba72a058e6d20dcfa80deb698e76659173f1e5e2263067a8e421f709bc81383dcf537b7736b23d3806b74e187956438580ec176a3aef4dc8477d6f5c42fb14cc2cd5928a9c2dfa8e0670e8c7efdad934ad6d42e733157cb93cf83565c89380e35edd4cb66906b7021d03c48e4ba56b2ee1c335356ec74172247fb3ed99b2599b8bf7be757024cd16050de9f34261a8e6224bf1f07f9184a573b1da2164d134e8fefac8256c1ecccbcc10af76ed7381eff1a39a272651aa00b3a6a2203462b7bec7160dc308c45f29f978871a9a16f438f30d27c35891d6f220f59044b8c288c20cc333b98057abe28e62cb89c411ccd6707d6635ae7de855f8904a6cbf172cbae881ffa5ae7b8ea1a1731c142b87295867ed9f3ee9658d6cbf6320a1f2d4fb3e1da5a35743b9d73dc5a6ddec571a9209c88f01e520b85087b6578d44befe1fefd620397eceab7401b38e6d06d1f98de443f2b73e21b607f8b01c108c4e288a0e66c420708582a0fc2e7352549286f7c4bc20517a3202c5c182725c93b9a1e5ae3e191df643800ab1ffb6a3b489f9e17eff35a8e1a1fb46c1905b275ebebb0bf0add4f5c8a9bc5826c560521afda0931bdf224ea0989da46c654283ff1954a153918c122ff2f615c8eac6c28620171a16ca6943c89d57294c376b6fc0b6ab99f36bbb2993df824a62adfb8ffc14b90d558dc33c0d325165a10af137aa5141cd09b45a07bd77449be0733f79ef516e8a1f31969a8e7254b666a44cefe7533953b9fd99b4f97bab6e9efa797a8e4b5263a19c06032f28d29e311212b5213ce344ffa5d087507f35d51578145af8bb7df78c926211ad6074eae182167b38ffc72bc43cf843e971074a095bff527b843fdb0cbf041789b8a00605ae95c64eaebd77dd4b074646aa871f5452666fdb87b5955f5623aa969d64f3e9ca97874834d437132ca937bd7d45b6314e3510530f9169ff83a1225d9de7e0b07d6bee5ca85f24343aad628c94faede85b211c1677ac7603b56aa135b01ca9ef00c2ae298f579b207b8fe3906ed5d58b589b92ce993189d59afc9634d05efed3ee9ebc5d72fcfc3f6fffc7fa78b6b6bc33859ec01bb68e94e4b3e568c0bdb52deca1fbed26ad3f033078d5409208b0147d7c711fc5a8bd8516c0ec2a354724bff35b9bf91d262451218b947998c15056ab07659878216e58927526afd96ec6707713383545ad1021d380e1984e70c8858e3402d0f2db5620e08035d5b9bdfd2c6a675f171ac812777769fd131051c4c8289c4637e70c8efb89f8f9f0c706801d43e6937a0a9ed05c4fcf4dd723cb3870f3745aff01c893dbcb976a29aca4e752a311487bd872b85303e55e05ec5191f12309b86288ce05736e9594c99c39532cf55084e41de73d576c2d5e6839e481647df91263c7652b03173ad8a9ba8f1678ca8870abdd3a8bf69300ab32a166bcc6a797eeb0213d6531dc1a928ece03dac883ff8cf6d397e0fcde10c9e477db2564e22c6abeb32ddddb92eff336576b014b01b62832738f0a2da05235d0baa5ef0612a90c210ea5d0da6bd329e304e75883e7ba46f373da4bed7edae5ee9d80e467e01cb34a8f4c55f025ae11fb5aac26c2f57d2532d800087a387e0741e8c86b70c88799f66e02034b4a4d898b31353b307fbb70f19ad31780a9206fcddd18cf76006601fc7b9e9f953b2bd0c3fdd01f31764dac4f4507d61a4ea04b7c009e6d5b1df3379cb98bb0d59e967b0b741812ac4f4e3e05d23c57a5fe89ab83c80141a8cc552b104f00517d31a6bdbc340fef380427a4b8bdf8c872fbe527b6c338e1c8f68ee1183b074a7e7207baf32276a801a05b68a118fe38e879cd1f6be3c28cd90d31740ec195d2d0a34c4910ef0c99052b616a09d14a435ef75ebee1e04909d4a6ec37c91a1c9b05eb7cc2fadab82d8b8beccb7a2af4d1f941aadafcd8830573f2528500dd3bcc708ad96f87dcabac621e04c3f0a6b0c66adf85b34d7b5e491e0e38b4500bf9be837e11f1afc66a5857a73328a3031e4a1116daa42a0058b38bae5c738099191b5736a0f55113ef424cc4bb8fb8bcdf302759143e134050edba50fbc469881a7bb28bce0899552b2be114fa3dd13ea56a96cbd01e67baea7ea165c45b46b7d3c497f38eb64a6f11c10f9d9136457583864837a377a72c6bbdb5cbb55bb3e5bca4dbc11b224929f61ec727b33bc5bb5daec4ad0f1f05700e27809952c32bb70056cbd7d37055269098b2854793dd08b094e0291354f109838a75dcf9ab00a1fdc4702e025dfc9276c968d9a7307735fa8722b041824cd98b6a5eb1739e9737913f654edc83a43cca438d08ad6b68e2ff28bd3e160cf2cf31fef5cca1db9305ea8427e355b8d5448463a91eafa01df4462379f5521fc3300208b48c25b27eb682660ce9294effbe2f9532ba490bbe565c67b1c718d8705063106dab86279d583e5bc489428d64bfb9351e410657d1e626c562a14a6fdb4f70c6671c5d709e591cba687127a717f05dcd6ec68a6b9b304d1cd580724ab452cf53a82bb0aaf4ddd9d2b9145fff94089efe2b8b49b4045f2532a0161b624aae3c6e780189866d2215fa531733c68633b9d203c2ae61a457baa68228eecc7ea29df7193b68305f3042c35dfac72542f83d7e14cb9706a2f9539414a5b4052883629a33804ef3e28893380c532c2d3e34eefef6b03995d4b5eedb9f443a2a294502ead666448956a4b15f225373540ba29022b65194187b08899412a23cd66f90ffa9a1ae732eaa99efbf72c4ff614d82555588139096da26e840af0b2bc7346ec5f6a6db68921ea3e7cf96f4562c24ff22ffb49a4caec9175cf8711ed09809dc26d73194ad75deeea47fc8603da632f8e48564e44bbc556e01f769d0260b44fdafbdf3e1c9c04611947a7e97106d45a04a847e9b4d81848dd5bc68f78b61b44ee21fc332b2ecdc559df4b55311564e9f9c49a21d1d7f32196aef30bb6ba117d5300c6c615d856be886bbb88e5f761f6f095ff1bbc54ac8925c40c267bd0c28361ac2527b0a8d17200f4759bb80d77a49701eaef936a11eb7ca5f106c9283d29d93680fedc9a91d01cd56d58b9a3d45aa7c70baf2299bb17b64aa909efc77f16ec36d49f222dff92854375b2ee24b832fdf74268b013beec926c68de036562f5795a8b5fb934882d14eca97d4831e6869f67793995ca5b1a028a033918a0bd3b1e8848d6a89e2de308928a31934b5ef4b6722dfe08306f1f1eb5ec7aa0d0cb61fabbb5923765a8579a3944502473ee0a80d999d7a94b300b7346b7642b696a4822fd6178e07cd84f130fa9f52d4271d1ff98c82fef1d9adf5ea04b17ef6a86154bff80a7c29c655a161fb309f7324347f696494f1476bdcdc554163b0324304a9bcadd733bead891dd663b19fe1dd745bee27c9100af2d2c389d7613333646c681ffc9e9c55a965d28fd0f57376b29700f17998d38d6a0ccfc429c6a343cc8ae9abb1c8345f3704bf0364db9e0c61308c607c267c5a9d039b70443ac2903d0c75a748ff962bb7d2764a98adf51d15bb6159937123aa65321adec3fb924001f2f1046d456f35c64f21b914cfd0421c874a96555294dd2527a94afa86f85737b7a397e7e8863f1f0563554600d077e9051846dcca725501904a0cd70646cfb70336128bc81d16bbf9e448495a69f0f96121bed4292de2a72ec72f13727bfe694ea04f8edf948199aeaabf8d5496f0f1bc87db3b67c82e8a79c1cd374e5c3f96b3dc4288099d02abb62f26aae108f840b4076193b7c5e054a6643700222626d92ea6dcafe4e777ca669b2180aa3046522167ba01e96d8733195959eedbbb6de4c7b72a54fe8c7322386527bf771710dabf8705c430d020e93b509be09cbedd939a7897dad8e87423ee3e6cbc4472bce36acddecbd3f56aca8dd985ac8efaad1f31edb906e854ee56e051f47e8c4a7dbfeafa3d52a885f3a984dc5993bb0688d52bb9147cb47962e3108bfbe4f0c9a60604582cf695f32b1aa92cbb2c9d11f230115597f60f387a62a87454897c5ffa598995bc26fbf58f21b68a87d773927b31afd5b36b930ef0d3443a704aca212bf3be94f148801d887bbe04cd6e84edbbc2fc145f5aafa6d9171de7e7c7df6c6422bc1b609d5d5333174a7f354cafab6fb734da5a04ba635540870a2de91d8d3ffce53c5577925271e5dd156d6df720b7927cc0decaeaff20cb587b94bcdbbc1b01c1939bde15ce956b69a6f2ea495a6930c84a398496590d77aa21609dd817a27b661f328e7e29956c09baef69c562bbc12bd5921fbce4838e36121db7ed6a9de39be60a222edb8b9e99474f90ef5a98697c787358af9f789edd9bd68ffb2de9a10d5b63cac17fa5b676479877655e6eb5f24ff69a90eddf7bf517e65c7db3e2330f5df72c9616841c0cbd6ed4890e6880f238fcb8393714779e8822cacfd5c1c34d31e0c1b4851091922e180301e9f7f1f25aec5302235534a22325f8a59b8ed65b8d2a17e4f6e89562f57c50d893eb9e72267db30609d9bd229b99ed685269b416e6a7c8ff170113654ce9f697fbc414e1d070fcd1af3331d4daacd4f5341f4b3c0af8b9f21a360a57f7996e3bd3b3ad59450d9983b05f7b8f92e9b3d4cebcde2b41bd2dcbbaceb366a9078178c76c84b9dd3bf73632c8efd350f39790340c9a51ad90f46eb8b480c0aad5f6fb56ff9bee6d74ae5221f9b2204f24bdec307df491fca797ff9f315c35de7a1716d8c64a14902b139c34e97c9d827c7bf1c04e81e1d33ae7bdc649b70d4e75fd9caca6bf8ad9a6ec0fef8e228b31d0e89114aedb6180a584a72a965628612fdcc6b349432d601cba01d4745e09ca4a2de6a16b7185ef765b3c1c7073b8560f7bbc740e81a02da6ec3304e50dbdb5688541c3e2efe094cabc055a6ed23148f1a265d9696d8e9ad3758f156df43a55f6990e143c8680b2ddbe42e41a54e8c69cd056dc155f8f09400d7363fb8737c5cbeb657e2f4d693c9493be260e4b58050a1791aeba33f846bff6ff745027bb16c465ebf2bbd4b70db959f2c5284569a85ae501c4cfc466f740aa2be5e5ec3dbf43cede75bfae5dc8134d697253ce9a88b12522ca74efeec5631d8358a0c6661567e5b8e86af474359a191f64ec51487e7a9d3de94c0a5f173e5fd26642272c13cd8ed6d7d54059799120130b672632dcd04845fb4ae50856f27ef3d7878d59b55e9465c3b4207f3ca95ff968df5f1bd70d5886e88f9c54699c4ed9326b267afb603a1435a40526b572e90d821c729e54322e33b4b528a45c798e3a1a2fae964404a200867ce79b8307f8103cd3e53c338123840146a8e88b3001a224cd4c164b085be7c470f3bc2aa65a030dabc14bfd2c4757c4b2467b1fec122bede972e8c358418231ca247d0a4b0841f1ed5cd7f31907abe2783667cbe0d7299cd60330e35c07d0deefbdd4fa92d6311e2e2a584198841bd5b42868abe1115a04a35242bf463a16e6db47461ed7b150cec1e20863bb7f672b22dc471876eea10aa8cbd1e0f9926e18fa93847c5ffd89de5c142795a5c1062cb16f1410ece1d98f587f181c298749330cff443f36ca20f4e26b88622135b35ffec9019edb799d496b9a8958ddc0d3c8a491f897677fc0590a1c1e4e6362bace97379b0930b2c2540c9d434f0bfc02e33765b7d39cb79aa9d95933001d963780882c4918846b1e98b48d46a8f7617d25baf293e905f2ff534e982d94cb43a27c02d3c73653171ca1fa99059d97167463d5ac7c9882158859ff7aa0011d10f2560dd92ff47edf278b2e15b51a2d3b9613f726780b0fcaa3ab35cd0a2840361186394b5daf42ca89e0957fc262aa26fba92b8ed2fc124e3276e12ef1f58d30c4a2280185aa2e0e0c7a0823e6d74cc1a723729811a25e851eb7c09adfe29074b74e1708a984c1518379b215a17f6214798c4639ec19dbf2393f0c9e2347fef4ac905c97b0b1b39186ae9df10ab8ce0861a68b9996fa06037dc9e47e3a19ebbccb2fca8e34343d75827a3dda4545919ed325a1e9853a157be3ee769a4bf5750ea00a6e6cf978ce4870dedd9095df3afff88d70a2ec0e3f9ae7ec9a452cf9aa6801e47d8a359705566015129b8b5254ebe81e8dfbf391cc7334ad1aa664d3055d409b2c3773cc2e266304a24f5f551f1065131e3bdbd62a6d308097608b56edcf75ceb3c60754bb295bc334b16cae7bdf4212f551c9a6d6f9acd977cc54490554b06854fa468e45401f9848ba343d1c675c6113c447962bf76aa27c1f4b72d3c07269d8518e9e1f132395723415b19f0a7fd41c3a244315b05e1eee51ae49f53dd3d0fc314b7f244703fab9d0568094c50217d6bf14ae124a614b2260e394f2b4c1dff08959b147a7bf00677f72d6b1db99865a444e97143ec235d9f4a014426d38f2748d75f318349cf638538bec6389818c4cf11858488ab77bece9a287b08e0c18babc354fe15c91968db1485015ee1913406a6d5b5c0cd17f273ce7307a457fc7c7caafaff9cf584ab7f67529a1ad537161d2cc178510f5a2ebfbdf84f15e1a649c4ed256b7364446076ea5810d8b6408de7c1e33b8b5727a76d6a971b239a839dba8593af138cc4b29201da024c70043340139c411faa5bd1e9bb0d0cbac95eaeb6263c485f4a16dcd47ab8ffee467e72d84b324f73b69f775364359310b369156a3b6c01c807600121a3f0eb9609c32e56cde01203cbed212d9d8d44eaea812ac4dd7f8f1def672576ac24796eef8891776cdfbfee9198cb2f55769b1055e4ce50eb3c626aa50ff651123fa3d6c6a308cf1b63056e664b5c6819eccf4dc4cad4dd9be4ed6cae3ba40c4160f0d345a50a3df6743e0212b3882927286536456c45317dc60245be9fc6352b120673c4407ca01711a84c4378cf21cf28ef42f1c93148302e5b4f39b8c9e25fecf3559840ccdbf78cd0f6ad4a949992c0f40e822f504b41932346fe5a8f681c48fc0211e5aa6de98389e229e307eccb33c84ce5ffcc09a205935c01b6d2c964fd6e2276b9964da31b612f39922be677b0e347f4b8ec9fc2393d6fd09104232467931dd8d3e45e220d262d0583add5c55c36b869a2fd1af16cf3b112fc2b2e9e97bdf1a765e3903a2b459b60caf753296016082472cf313a264fd5547ef5135693b2fab8ae8f08b4b60d70be41e73defe9f85e42baa2dcab636ed5a2a8fafce1d8d0b04170af46510998db4f65845d02c2ed3bdbc2932890b87dc720bb19116f4b476518a35ecb7dae88e8c9c3abb09afd3a38d1a0d7830593beb62bc61ac43e33768527a196d57604b264099c51281c371c9ae4a8cb11c7b8a495d832e31c8da2007a236dc31d607a76ee1050a568e2294f71e9c85d1a5a643b91d2a6d4c733bb963f24d4509e357ea29818735191abab1b60844c06a326318e4a3ed55eabe1de38b234927108d355fe98f435870648fd50c91091a1e0fa8b588a75d222149769e5d4c5b6ea30bdd108de52e3e8a997c36d2dcc3714d2e1a41e7dd299d09830cede3d427a53dfcbfe1c0308a21fd31c4525744592118d0f081513a5fc4a8361a451910dd638590eaad8bae08c8af8bd270b415180ac69343e0fabd5195b9954bc03f3e647b6de2adb265930f1ee16645146fcbeb6b5818ebc01c1b69884eefb68a1e23c30a0ffa101b96a336842d9bb160d079cb4f39607bfbd5cf39be48867904c898f58b39d5d4d171904fe3ec3cd0aab49715d1861d133df2936f1227ce8294ec32db3687688e3cdb5bad1248cc5c076815f83bc3b96421fe6cd03aa532364a1fc93488f73e06daa1a916d90158e29ac7107d0e9787f1a9bac51a4353a80f5c55e63174d5f1f33acf2e117d4281bdf13b3b60f5fd6b07871a36708323e048cea2413275c2cf4bfabbbc9a7ccfff688c7419df5665ea042eb172796c96cd4097eb589885e85ee34e76b5301532eb35e7fe1036f6d7cd67a4f42fda17e68927f81f117991f5b3f7101522ea86bf96f2d51ff33a75f39da6bbc7a5e8d4651fc0e7ec41bb2447a7af24a7ef363b29a214e23236fff527089b0e75d75bf07d931842e67f56b107946c89edda727df2e7eed145ccf4d6153ddbca211e22930d3ffa9bd6759c0f97ab3ff24f0b3662c19fa4941b3f63ece8be29b0162fcd9136023e754033283f6980ca23b0c301cac88e381c626cc0c5c25590b6ef3c654cdb39ba9ff0ba9930ea30a12e5dff305b0f1863de3329827edc69c3f3c858539eb5e2af3b8467895a1bb0f3427992704d4b86ac8b66f5b34ece9b6e3a30bea855830c45e65b218c073fc09f0567a2cffbd960a92e9d22b29e6685fce39a5d0aeedbf460b2c0d109fb9f7708ee0f5cf120e4db35eb6672969e43d2a70e68a9157456c651dd45e270a8ac8b87e4a4384f69e84f46518cd64babce93fb73056aca74c885a2d30c61bb9661b9422b2e9cb1f91e0ccfb76da736bfb69ebe9ed27f2a514f3efd05144bfb4fbb86affd0152ef519746a1bd0475220d7fdbf3436cb9ecafa4674c4331e3608676931ff4d9f3be796be862922e9d24616b15dcad943a5628f8a104d03531ba15c64bdab7463c643d5f4e52451dd777a18d1ec09157a34664a20382400aea6a044262c3ef2e51f9ab979719bc336246a32da341cb0018bac467d277867f68e07ee2cbda82fe251cb1b305e70e7014eb2d4ae438cbf0cb799538997dc8138fce48a5e948ab54d1b08dcccd7423f272e1c9f2e8d1bcbfa8a5cc0317cce8ad2f241aab5002338f98f1ba88b004b8908bdde8180ba3ef90aa5b6c7ec9f3fcb0cbe25a2862eaf9366e10688093260891c0b1fb04a2c9f5f5805f7ec706d879f7f91ec9ffd680fd861c7eedd98890ff0b3fd17d802388e059dff3088f3200483624d6528eae4692832aab5816aa6c262cb9469a54e78d69d39aa296a8d1c59d1fef63c2ff4340975fbf1ee38d3dac774152834838446b984394983a7a41eead2ca7273029d7ddb8b8e78b40b058ff2c460cd9ec7ff850e3c952ce5f296152c61856f53393884a4eee8171b5063512ebdf88ca344c7b621a44ba9522ceb5420b75f70e7b49320f8916e89eb2b364e19015407a28e52baff1c3190219b4d5994ec87f10c660318f202b4fff3ab29ccddd2e997824be5e7efd620a9f3c0fd00ec83796b12844e25f89b9357da561006e00ffbabc6feba528298db9d2d05aefe9106a835ead7abb1a338ef6c779eebd4711b29f0a8ada445eb770a4b238286a4e46b99fe75f26b35d8097703c8e8e9491de24b2c956dadd6237ad93b26cd7138833507ed1401958e41e03d7f3baf765ebb4c7ca32f24eded0918954baa4b6cdc984cb28dfa132fe173d865fda8bbddac4c7a147e7ab8c6812e56d8b853e873ce3e491c43789c9d6c9a482742ade2688d6d9ced680c8aa9dd68f532a0809171644f7697528ee1e39446b331424fb39a2a32aeddf6b4398b9137c23224072511c3509a460091b11451dba1c53f8fb7a67f8afba555281823504a5edc921b97f4e26b2cceca275f20469f3cbb1944c5ddf2ea61d3a9f63ff595a30c847aa3b83f6cb062419de39f576007c8082c09886a6a1fbf6b9c54bcb0f9ed209a1d5e9cee56fd12e61945d126b52c22b02e572f71d6034dd57dfd93761c5af3b8312af7ebe84859be3e28df915cc07362e27a0c9ea21a03e14dbcc8fe26df584a25f0b94430872d5c668af0412f70a49c82908ccb0b1891e2b4a74df21c39bec4de08b7c83f266a2174b3641197447312e644704d6b67e0d0df1c546613c0489ad605b3de1400e5cb55a51fa4a972377ab666a07f6f7316c18d48a9f748b1b7f951b49f0ed620c75f5c396f74700a6831208d312159a0f7757f06bffc3314613166b8d0313fa44d4e5c9d3d82ccdf29716becc9c959b76a4135269ad1890e6311750aa9fa06c8f3c62f9319d72fb05e30e9d6084678a0e8ad1e8418d8694250245e51cfa77486d249950d9e487320fa7d6b2f0e8a9c27b1b777ad75faedcc1a69b908c672ae528011b19cfe6923872e6669d3f52cc38b1f9a872815ac045f65492652d3604b6b3865b17c3b5983f6ba60635df0ec923068bd66e79c86e30c3cf76934a233e83708cf34bfce6e96fcce7be2d57511559d48b7155639673d598189c25381df3f9fde38e076b931247fbff6cc54a4a1c0ffed1f409c66bfcf45c419a03083feb664e2cbd242368fe47e921fb7a1cc62c57913bff9c743530fc887bded98d9fba6f85f9b2c6f27a0e7a34eb52e1dfc14c7d836fddcf325a48ed03995b666fd274a1b209b9f4fa28e46a946d56c3ab01011b9f0812fba707eb1434ba03d757f0308b307a00f0ffec671f61b36d2866fa27f55abfb1a28156cd65a8e819ef66aa38ad0062ad6131b0778ed71e330027d9712bc67bbae698b9911cc941505daa1a14d158772b2762ef050bef1f73841694f8fd669d917d1ff9b8ee74c789809064a3c0ff55ce34c79ef0ead5269cc5a77fb34ca4c175df38faa8eead140d66f6947b297f31f354e310821c899aa5708e05c955ccd9040fb6498a308fd8445fb8da35285aba1373e478dbc96dad5c4bf99eea3082c3037677f3b433217b49daf4d2a3ea3106161331be6bfcc3a6585c69749327d0ac655145543ef943fa91d2f1aed26bb351420fb8c84beee08a18efaac9efa67c1554af90207fc8657519ce446734cef49e47a8d7c16c8315f730180e3cd7980d1e68c181fe7b584dfa19524197756af15611d9c5751da3a68ccd4c3a58e1a677b90823ac0ee181733a276c3880d11c441e672a526843f1633bc993acb5ddf4834376dc8a40fca8bb3a23085d9880e162fd1d549953ebb3cb660a84e283e0f87b68f4adc6d0782ed957dfd2f322ad25334a10dfdfe8b2c042b4531e63434c20f2b476cfdd94c70a9783d55bd59ad5ee9d1664850bfcfc7b0b24a24df0f2c5a8733f554652cb84a256aed94c7b709082074082abf43b0665cf656347a563f7334b561a32186950556b1c63277e78dd86111ae386a8e08556ff463e4c4517d7976193d792681ad83229d6ddf9a8105d87dea1c8f5796492c5e0dfbeb743906cfda9d5128df98c7ad3bb264c28644710e9ce4deaf1999505faf4b4ca0f839db31a70a3ddfbea704b13632097f9d840380f0f1bd3b4ad2854bcb04c643bdb86af5cba49b5bba19126283106705d21cf30444c54329be7b23129954e6ca25ffa48d614fff87320f3f4b0f28bfd9948444bfc6e8c18856ef77091848b8779962232af3c5d310b06062aad2e748d4fa34fe131fb7b9e7e880a926e6ef343e5df26c9f72611f2db4754748d7ca5036e4875fae36c146ebd98e0533623d7a1efbb18082314f8855a47c03e87dd90ae9b66e5e61437f945bd460673bb0ebbefd6cceb1674f71cb25a4e47f0a8f47e420c190a6f835067fedbc33fd6d00b6fc43088c99f840e44e6254f59721f40bb0e56c0ba191d6d33871262690a596fbfcac5f772f342e654b50d42ef0c173d59afae2691390bb97dbac822e1753ada4895152756172b3ae496c23aff8e59c170dcee9ab52abd78532dd9a26e1244c93ff12991f2334feaef5e1f8ad9779a04e1d81cad1cd4d27a7805bcd99e273c008bf1550508fe23ea8e9e9825b0504fcd87498fe6b0117ab038a1d9c8a1b2662e1844fda785bf0c26685bc4378349b01cab58f2da5c41eeb11dc6b5f5bb0ca8758a1140ffd5318638ab11fe8919ebd9481fa7a0fa190f92b1970f907452a1cc68d0d29a719328b72e43798b28a2df48c151308c7cc4bbfc589756e505ad015ba9367f28e71c4a55242a4068dbbdb0e53e30eef852d4c49a41de9b2440e2b7eb10eb1c7b0d700ec5807f2c5b317fe2f3d4aba5d1adfd280e88fee9b0c60abe7d32f7882b2118a3fa31ca0e0bb24fd52471e8cda9cf898dd6433fab247bd6570faae98ec36ea1aa2dcba04ce5e31f93d3482060c2be4c8b73890ba2880a83d65304e4caf7b85a22a928efc64263ef5e71072bca78dcc738762beaf620e7523930652f3e66e239a96a1f9c85567e20d57b87934359c0e545ba17424eb073167c6163cb3dad9c1e38e50b2dc3d1f3ef75da0a0da7e18ace0c5682fa7a370f27242ac83f2886976c9b99c8a057d797ad219a1d4756c174558fa0bdfa56e93224d0332b149b8685f370b972fad191655ca04d682c4660f0f2ed172bdf54f5fe85b68bb1699f3797399d9346cccbfa80d5b584c6ace0c947d8d8a80b937d16817a969f865894129f36e669cd0b57173029578baa436529ad632a3850faf23d3fe9a6d81922a0f61bd7bf556b783a387d7916b4fe7a3909b8b6663d5f7dc9259e02ebda012e2e215c45eb1ff503d72ad263ec96265214084379358deab1c9a7c702527730f7e8dba599aa4ef34316d5438e0f36c552d552c6032b41e3a87ffbbcba01360df57d853824a22cec83844f5ed95edd474907bf79189dea74de55185243d980d199bb138fadd2c406ffa68decaea8a942710742b4ac868e18ecf394b62a017e97e32a28435a4b90dc6da20f03ade5c4a2c19e1ea93b0c0da5f7d49279600b0529b28a617ab5795594d4e126fc76f1b8e16488886ae8da8efa3de07a98777c6484bee6f915fe7b3a2f43622ab152214131fdaf800576ffd78594f86df71f63bd86a149a45d0173456a29fcbf8376630bd38a42b521b19d875acea331f3a71aaf6439895f60eed37f43d64070b8d2de0a0fb1eb6f412ce531e7f34a07c47713f03493e82fa63f181c9b05aa728ef08c6c20b3695c6d0e9a70e536046642da583a5d232587ed6d7d14b4ce35d28bc37684cf9eb043216a137a926a940c7878f4aaeddbc2cc613508bb6a758289b120cb2671159ae390f79f96dd9badc17d97af673d71cee6584a4b74432b622e0e9ce0f3b6e924d1afdfa851b8ef404b01d0aa05a6d3169f3f08665bf06e5f75bb572c2c1d7241fe9866ad0b7739b83ef456bbb1a6f111533fa1bb7a89e38be36609a2ce71b3b0497e6d5fac75341968d74e71c410fc4235aebc4f9e786e85b88512bb53f595c5134586a4a0855ac304273317e78f070a0dd3a9c4c1f91548407c5b4ec63b60b85e7fbef92b6543f0b711f9cd81859e0c8f0d45f07f3640fc21ece95ed2234588c387ca5faf097a0784228179f2a48679d75db1e7bb3443e927d0f279ecb19dc20c5ce654747a1f148be946591fdb6f97f2eb31006f608e00621cb4fce202eaa11774f6fb3f9dfec26d186ed196caec41717549b88fb2deb5bdd7f48efb2521b423e9629312c819f905150b1acc37b6f770abce789b4d799a1694f718fc94a118096e524a8581c9d6cba557d1682dfbf37a2126103e46653e9c9860f4fc92721f008b66a18d09f8e89ee9f2f06d403bd89314cce1c43e45b6dea8edce1f425a98ea1b313019dbc477547102103e689b93b57987b759abf830de53488309f76de13971328845f7b8f15e342ab402f64ce46edea6185e373b46f9bbeb6e13143ec57284526523eca1d38483e81780a70b626cff5ff96e71c1cabb07db867d9f8bcac7d95e7e9ed9b2526fa3470edf78dc3bc3b1f1e9d167c83cd9fc103dd77165f1d472f69bba199265c75c65ea52f56d0f86dd8a63963f2ca87d8f96dd48139a637706cac184538919a1780f1a5e93377ccc9e9159fcdd50fcd6c4f5383212f47b435404242d634d66fb42fc1642103aa93dd1ee11730bf70cf3af5090d43eb39064a4879209b21db5653165857937261c4d13891fac3ba240d57780acd132aeecc7520ee88b1903568a3bd71622a98ea91f190973a792997bdb09533181f96646312f6fd53698911ead7a4d8501b9ac159086c49e3de54e4049e8f230c7839ae3a1c9bd24c7391c7954523ccd95d6bf06276ccc46faf9ec8b7b6eaa58b05d03cefe58d076927d67cd57e1ed2a7f31b76c0b55af5b7c48d4ad9a451c7ba8537063ee7b1ecf815135ffd70c7e6419b2ce89a1247c6c1091cd7dba32c0c99959eeba8ee93b6aecf7f0d7f6db8d038ed96a53c5b3850cb1b31aaa54f4cb593b094dc91ca1af0d7e46490130a2db4940b27e919ff588495afb176f3b7f852b13859340add465eea901c5077e828ed1159a924f6647d1f60ed06944d5258522e1bc753926e6a918f6146df09bbc66b02c71f7f4a21b0c74b5a3f5764392cd9f4864c4a2ba88556cef1dc3a0c17974fc15cc1ee507666ee398de1fe0918528ee25c6df7583fbfdd82129b5439b0d9bd8d75ebe421e232798f2737677bf057ba2c5cbf6a8a21a9504c4341f2f68a3c8beba0a305d954bbddae06fead21217624b15ecd3ac37973708673b87c862ce6758b96e33301125c86fadae54d2ce67f293c147656d09bc64d26e92e38604534d7dae06c7622e7f736348443e730b03f43be104b60f5d03ad21c41ec47df98f8d693581862403a1e5b12c9d6210fc44985e913150769cdd557d5b1472e6ab5d24f6570ab1901bc0864c0738a299a41f72200cae6a11601e8ebde6731787cde0af4830e5079d0440c9af0de7ee2022b497146748eb1b7a09a9d5a9e10429e56dae016185e72f0031b5de776e8dc5dd0d48e93c87dc6a27720468a425f8334ea73346e5bc4abdb04a4f691d78e7c55f743885d709298660ca0d6998b9c9184df3d8b89513181294ca1b73f998f944a489772be3141dca80256a5bd931aaa702902c61c849bdb3054ed803c79f723071b334ebfa51696cfe65905324760113a47582af808ab59aac4d5c696ace43d4c3a67d0140f10f0f27e8b9fc80a46d7008276687ddbe0c0fb4c206008c94c764d60d57fc1e8e90656d2b6154478ef6953bc33fcb34cc2edbe68b03d542fe5379e059571fe7ca4855fb581e81c5a2c60d2b960fc3b28af4c130cbeac6f0a26f9156f403773f57f3bad092068c228824f85e2ad58076955e02915d4fe96f7013b01328845f6ea00e7b28695725bdce1a3485b50311a0e4b209e48e5261e4b6a622a5a1ce71e5b1d37030eb13450eb6bb59061c31c1a11755660c4f19e5ec0165216e7208e318542c13f94b65fa9f86a306b0405b6aaae7d81e12f3a5095c0d6928a20c40c5cdb323601f9ee1a3f539f2cf13607d09f50a32c03c0d4a37e3236f3392d66b7a2d02e8512afe2122d45d00c171a9c6cff8fbfb4ef9e1107101aa533d557bf1d950531c19bbe888ec76aa7137bc9e550f747c6c56f9a9664d23c0f39ef02314fb9c1d53b9bf2cbd0368208e6477b5b60ef4c28c68b757eebed7f28f94864a31005bc3cc9f28c5fceec76d88e239317f9595cedba97834ffaa23eb6a09c8e15c3f5f62361795bf007315e8918cf0299d32670421d550741abb90b447fd3c29ee57b043c9411161266918a2699ec4563926498a047c3d57274400660e69b9329af3307bdc3960a16a4bae09fa042d6bade9df6c1c3928883b169138c8dbd3b0a19e82c8d68625d332cde39f0a467d901f0a125aa1d9581178126160b79baea65f062374c260a895942b07bc0cfc1f8dc4cdd07579616410bb1d8102d2ada40efeddbe4a8342843bc4453422412ec6219b403e04befced523435066d585ec66b4ead4f5804adea0f7111e77260bbb2df4469a43ddc50a86fa0f7ce50ce8c6eb8cd88230f15cbdd4048409f47294c6f0f274e1de1d8d4dc4c72e3ca71454a87b2a2f09cd29f0e953e678c37d7081f7050e5b3a05a59851f6536d90c18246dc96e4f7341c4099e4ecfef5484163e70e9bd49ab6e096ed51cb05e7786f7e5d0e9eb0d9e39a101a15aeb0f0a871cc75267e2d07ee5de14088e557439de5626f9150f4b308c4fb96df62227292ca74339ecc203bba5e5ed08b8631909cbc5cebe9d06397da8719b8714255e9041f7c3654a60bd0e8266a6980d4b8c45163e24a094fee0491cebc3426f19231f6af1a0bb662de7b69e259d1e7059eab6ae1b0b1b922effa6ff5153ec52e4b2112aaefb38fd0a48378530cb6d726624fe7c5c103b402ab6f6cee7e7b28fbec0677894fa3341516c56fb17d482352d89a0a07be659a79a678cb3c489c81359cc278c6f6ab928b6e1bb96608f3aaa94db211284b9075f3f2617dcd1f55813c5f94ea0b3bb1e097a213f25c53b50fd42bf48e9df8d80cc810a0a2f20d70bed69f2f4b46040292e597e1d9036e13b75032923c6cb2b232d471d960ac0c158d7ef83f7d92a30dd9a5ac651163474039ce839fd7b642b66f1b562e34bb910d97cddc9f98dcba9bdd464f3c0bf3ca6a7166d2dc626fa20ed1fd9bd729294131001d5497fd8c585a354b91c1c3c25a5fad034d3e99b4729be95cec813e6efac7e3e1257567c65605cd87","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
