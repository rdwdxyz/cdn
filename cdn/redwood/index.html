<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbfb00b3bd8653f949ccb5dd147bc0483730fc3331faa2a46ee9e9afab3a13d17ce908ba0d196c378518c5467198296cc5184c85be9d28bc627103598c6f779c3479151f41eb42756bf5321185678a2c51c1cf74bc8ea73a232b6a430c73ffcde56699445dc7ca962a9c8e29e9e60ab5a2039017d9271546730b1e836ba5cb908fa5449751dd5059033b07ffe308f3ae9edb246e72ec760c78a42ad6c47108596edc53882905e2c812923685d003d185719e190229436ee62557ece18282d1adbc3ea97da1e2dda1d0abcaa4c699011208be5ebddf98403d20826e7b71ce0a4fa354a7ee9942034edf23b6743fefff46c05a09ebf20ed64bbf2c12498efbe79c5f15f5178d9e2d850b5227072962b4e8531b4f2a0aba61d3b77f8ba01cf3f7d0c4cc2cc9829346fd9d724585361218d6ea716f7bed2af78630d405d2d9e229353b180a6fe510ce222cd75c1657dadacdf29fe3207f7a662184b383aaf09adbb8e939710924577e3314a33fb149e57603f7ce46d218ca4068f1bfe2379fcfdc13511a1969b2999f4af072e1849821c3e76dcf1cc7e1d388464eb4ab580dbbf8d8cd2f64ce5a24bfc94c2709c4db08b043da8949b7eb67f3292e8066dc9d2d02babf80f6897da65bfafa0fa28f999faaa6e9eb956fc7918d837a3f323d21fbefd5d40775e536e4e9b03d4774b484289ffa473080fd7ea2405952a9c01f5d0588c397729d73eaaaaf833b0009a3b518c3abd72deef85a146543899f4f7a1da1a05ace0f404d164d32eaa73e736c91d479dbd8644ac55c3dc1bdc74aa65466ccf700bc5a031ba96556fee234b1d21ea4fc13b7a763e19db4f4697373a2f6d648835b8a87329bcfc7032d5355e23d4945479d4f4d12bf17455d8e374644aa4be50b36631ed0760e26bf2dd2a4dc58886045e8eb7c832fddd4560ed74e8c5c09f3bb98cde543c393cef945008ee76b3eb888d4cf8f86ee82fe397b1e09eff1be07c9abbb329d3996302ceed2dcaf6dab724ec829511ed622ea3950518be0c0cf52caf65855aaa1680e93654221d951a6d22e0397f81309dac9e72265ea16e09136c5945215d59b31a6e569fcfef7373c67bf65b3098dea2941b8b8f6a8f998a541b8c7e6529bba0e2db096a05bd551c0ea7e921a94a1352da69052ae7751780f4b70d90863918baa143387f56da2357b126bc394415ad7315a3cabacf0c555c3193d8f02006190d070f169ee06c00011b86ff1b5b8749db00a5b6b81c5c89cf977be0d6b161dde7809ec3ae7dd5a1faaeef4397d337f06ba1c7568e189c0af0324df9bae0870c1f715b9d09edeaea8e23a6b6599cd259abd4ea74a23b8b0f37743abd767b810c8c8c25a6c14ed1bb70ad244307c5f6d5b768a5b289558148f13f5a7b9422f4d6ad027be151b099cce2f437c767cda200ff4875874c1df0d3a01d30303f36febb7e5841fe93b0fb5ecb2117618928eced9bd620dbc40119beceb5dd271d9cb384afef195d200f6c9ce485a89bdece486b1b0388b05d5fdd47f9b4abf506485ca92691ae4dbfa7f44aee776dcdb851896d387babaf1a7e8ab78f530bbc1e3305281a39eb67effc71046479a78b3f39792b26632635727d8f40801a2bcea71f87041b7a863e2246982a83a7741080656f1ae9782973c01a160241f2ea8dd139103a89cfa13111d7fa4fcfdf595b1865e34eeda7718c02f035fbdf5741a141eabeb84bd61d0d36e2bd60021f6776723369dcab7647741025c1ab056bbbed5327cf2f5880607ab5cc61c94f1d193cdaf37d3f9da420961689e2eacc116ff00b5cd432e8914a73cf1e515f9278c59ca1060ac8e248260d2cd0d0a6b9d19f314c5352a8ee9c7e4e028692540ac39c02afb2660fedc2871249c8c75738c90e53800072ec2c51eef0c64c990ec75a5648070f1d55b9242d30038940052266d1d16549b7fc06981aa940bfe937ef69396d6b39959ac6ba8b51739f225af1c8457fb087f69fddf2b823b1331dbd37141ffdac52c80bc9f2f6056f764b964a494d5d3e5ce24704df64c9584f719e90b0197f1472e9893aa561716357d7530ba16cdd01112a29a6baae0aea2a184730e68bcf7c9485ea5ce76d7df2e4e9e07e04db56975bb1ef3c1742c2260cea0b2d31dd8dd44ddda351e688868d31e0cf906193c8e53e75a07e881442137e04ac0079c319b60cdb15e5657872287217a334ce2b8576b679fd44dd9109ea5bb9a5d6d95f18e945e6ac86af604ebe2088441c5802abd65516495bb6c36b48620373c3dc9305783293427af0c811478013b7c8d4f9ab7d471924a1225f498c891f5094153f8539b7eedba044b91da5fbf42c7c1925b0f16eee732220ebf46f139b7ffc2038dfc4749ac28732d6a10073b4d7755d53a3e7e8bde23375ae2af7806540bf3809e87ae3c26542e696b68077120cf7230b529c90d05a419bd8589f0e167074cbd594fbb8ae0a057b90dfd5fba9901a9688d1d44461aa93040b5c2b6b8df18d0446870f3647fbc6a8351b542a822fde3cd8e75305f512e264b79761a23cb2883ab60de3e774a197553e3dbfc7e0ca843c1d351fb8a76c1628b06dbe2528d01c8b333065b387723cdfe0a7d28581078c6bb839229fa49cefa08bcaa0062c8efd78f431d7a3e19101e28672a9f6972a0700e651c597a35ac432885d766bac9097c88c6fa28727e51123ca352cb2f5aaa04bd51d96ce32b11999e9d84270bf0118d5bf55e0b4b1fea9f748040f2040829998e53777a35f2770bf51ea210ac89a24f112d26a442e1da061de30370c88ec7f5e6868c3c9d58fd78a450c22f8dd4245a8fee300014438193ac3bed02a2eb1324258aff2bce36b4e48c1d6e999fa771b1f3f6d393c837c1572c6a9b6291cfda528db7d22880961909de485805253bb4f29526eebc02d27e16781a2bb3c5584487d816a732f3fbef4fadc083fcd2d0cce2acb79b68e2f5fda3882aba6b6a732e868176203b56d847df01df3e4015bdcecc6d5861bc8489e4b0487c0c6f463ae2b8629f2300fc34104d624e0e5c00d162364f2f9d33425e783057a26eb435db98a6f0e4dee62a411e78dc700d494e4e85e7ad49adde0ab072332eb6cd619eaefc9c9890f6b1d9371c2f77cf8c1d8eadcfc21fb63e960bcd1a3d99e0e27cb0e8fc4abf9c534c98da5b0032b849ff57ffc50c1be910754b69d059beb7b0ef7458a23db13c21daf302e3c64252eae95391bec21fd246414caf839989c9e42a252077b630591578c602c6decfd2cc8c5ce23e8c0c29f752ab8111825a2f37cd379a94ab2a1b2d40d82ca3c3b23dd83348c85cfaaa0e35bd514798aca34caccfe8869a0571c353ef448a3a159d81f27e22ec5b98385aacc98d3b40347338cfffd80628271e948ea84be54a997a27fdef2de0adcdd01243cd8b96cd5c6af23e03c3587c9bef3d68cf33b0c278811ef80ab55a61701a701d8aa75ab8171637b9b5df9fde1148128001a8d1e0bdfc7ccb26213e1bc8b00e8ed8b983be288a5c34e200886e0c6b1d626ba8d3d49f65664b5848f8b79e934669717aaafd404c4d716430cf9632f47aa2a9faaa179ad6be9ef2f7e70ef302b3479ae831768572487fdbbd2f2737ce724b938e8ebf69adc5ff74c2b76ccf0989040ede661e2cad7bebbaf8a233d1dc30aeb704bc90ab21a4e17fa45a183834e093124e4594791800d4ba32a60839fb5f169f0d565322894d43b0a51bfe4c5ad0d15e75775cd17f81a1041449cabbeaab52f4b88120257121e59f16aa6851d4a829f9021fa5ada550c9b808c5fca78cc5be907010c9656a9f291dcdf307626d3a2c8fd70f568c1e25d808fa6901ef4e0becb699189ffb5246bceffee8d518a045591525867674538c386e03a40ac377b47c8b1897bf2d3b44bb03f0504ff8fc330e017e62961e3517dc68a0f43b5505d2f9edd6832615d2c3c71c9c04b0fe2b5638c25773a89a484f2aa3d4c8607f31b6a1d1a6ee3faf5f805289fbcf9f6866332389f9fbf607253255e959a34c42eb95dc2b869a02cb5cc83cb2dc5478fdb59c69fcd7e1e74a7f7d43298ada2432c9e12a209b74e06763e857b1cce17b1857c238fbbe252c02298c5eb92d99d50f3817888e6bac5dcdd769b35120602dad3f617abec7b6e14e0bd19caad2b89984913e74e07189adbd3885596b536f35fe2a8019e8f8538cabcdb6b0ebebaffa991f8543776a41375957a7b2065abf27aeab8efd1617106d682e0d003d3318f4888810442387640706274d4a6c45f209332552f3885530c3e974b9580817a122fb4d25cf9f59674cc2be3895f241fa36cef87bb49f06be7258be035182cc34558ca11c0a4c90ef15e1064d6cfc8d271bd5e3f9cbb487442a285993e86708b6579a8fd775e82e8b7cdad486e041f5a18496dc5f24a52f9e97e8ce13016d9111e64f9d1be84e13f7440efdae283463998b0c6d68209dc317afab46d7c7ab501738834ab80dc896da4a832c0caceb4eee951b79d0dd5b7c8c1dcb044b10b2005dd9cbcba5732adf4320c0f680e5596e6774f7cd052153e07bd1f1b98c798ff8fea5571ad58ff925ca3578de6c633e02679d644b42907717b594529c8fbb5bff34e01c1a09aaaecb323a286e678124dbd972c4d1d42a5299019fff86dc64aac893a931b783fa53e1195cf50f6e017517e9199610b4d69aadf3cd21cc72d7651c660f4c8560e7d1f1b490e54e080c210830aded1a1c3777f4b38c3a6dee84c09e9a023d0bdacf36b45ed9fff74e137a67d8515bb210bbbc04e164b7b95494f17582619f87b5ad8d82839dd34aa03b044d5986fb553d384437c3a2d3e42276dbbf78c3f9ba1c2fecb9751c2b2419688cf721b58f0aa758b427f3b60b7a8c633ce9396de52354b90a098da1f2a0c9002d03804cf62ed7fa4d09d7f91664dae78781818a7fc2da66d7dde39676a00e3a58e03eb63ca6455048099556e8e85a9ce454168e34f069040aae3fe9448d8ef6e487dbf7a80855aa055148a303fca7ca46052f20fc87103f5cde4352fac4e913d411fa1508ea66b4847a4ddd6ff74c7bcf028d9f65739641c7983c00acc706914acf97c559be824a98f286159c2ba2d40842e18e09e73159463a26e23bc7a18a7021380db5a617779a432ca348a85572aa4575409577b6460a63240accb5aff558cf18929539bc2a1e809b4cab53920118de10e6e29c2b8a075ccf397320a3e36c470e1a9e88207777452804ea28d10f537b04936410a0976c2aabdb7ae3eac8ea4a07d97c35a238d2e2c1209769de07e2073f65704adbb8fa30c8385930782ff750f13c500c337e9dbba91f541fdd7a0d90b88d7f475f80fd1287bd4f3366d6d4f9531f4bc6328233989244e5b0bf2035da520416a82fae50abe3dd11fbf250f5d0a2973e5f7df71fc43c96ba7a17e441600535a8ae13932a8d3d2a45258510a6441ba75fd5734db1784d4924c958accf18ee01c8058fbac50eaa79966c9764f45bd3067b13bcda8fbd44668f457782ef8bf1b033c235ea3adbe35e8b5036a95fd6cf89b0aae332ff6dd99d4a22ad5d8d3e9469d46d813bab81e1cb12f491d788d2157d955489418db9d19ab482ea583139592ea5029ae9f600dce6fbd47ee8cc226b95c5cc6259fdd7188f48441155db27de062971410a55ec5aaf53592faa7dff0c440edc2722477ee7a1c14a06c2cb7c577944e849693f71e724503ab4b1e86f5392b04ddd7a61a62b9588e35e3388699e9c9c436c2191396ce61e309e0e62bcffa9667c4a77cccef5d59fbba0a76472a057501280bb9e8f5afed5676a04d65283c8ba31e7afc4d668f226c740ec735f9493751cc1f62bc4e1c7b88dc56898b5797fd478a95dc3c8e00b8c1b80e69933a2613b4ba2639042fcf9fbefdd5d8e109642559a72df63531eddea6028bdc28834cc6b3574e88ef3467295bd6ec0a3285ef569e85deb99ddaf5c1c1a9c91e516ea231fadde6a4fa75b003870b6eed5518304f9e7d53e278b32aa45a175a76fdf8e59b3208fa22775d72801ba1d0cef5b756fdf843b8acf115ce134014dfd75796e7aa6e9bd0fdf8bd49bbb8b7287c2109680ba463bde95fa96118693325b3e8665bbad3bd284c54450152131c3b00f46d1f161cc29f43d7725cd4062904cf938df76a5a4ca59dcb63b5235d40606043915f17338fcf84b6be7a3067337eb2ecd2370b8ddab9125d2618046345ef3661011187b556d40f6f43eb5ffa686133a192af4f67f472c1985ed7c8ea666608d4e6839dafc6830282971f4638e05aa81ac6ed3aafd35b488b629c1aad024faaf24c539d9c56283a79a6a079aa76bd21e4ebfac99430243c6e41d16fb9d3ee9d335bc7ac6d496b6d94eda18fc7ed5a6f99a8a2ee3b20da6f464963ddd9e626a776f7c59ec0d9293090b0db2a6fd18d727aefdb5517feefc90d3ba253575bd7f8ed9d28bfa4c73aca906ad0e9a3b3d10437ad520594dd0e73d19062873874c68f5f7517102cf2a2a94543923cb273dd640256d8c449c5c20aa0966a9c7c7eb8fa818dad2de6f53b0f4e99102a2c5e8d3d943af838d39ddeeeab984c2c89e57ebf7b709df4d3647194757c9997f42e15318993c2fd2188ad501502464c9a2979fc878b026aa8bfab63de4ad80e5cbeb6b6526c7ef3ed13e3036592c98c17001408aa4ac053e38846573d26b3b43596827ec3cd1af4214267b69823a1bb3372dd2939b996adb0039bb81379a5c31d9fcedbfdabc13a49b4320e016b5c95705173c6f1e16be391b031c0f2658d5e95fc50f3c723b2eb3a5db1e0442646519ec9a39961bf4307ba6eed7e609c5589719d585694da7261a59facf126d6df7e865783644f31b95135ae4372cb9bf16b8507f4a773194758e702400edd495ae6943a3c91ff3b9940824d0e5c598b0c192db060cd6fecbfe4ea522e3555479b6801caa4fa769eb09e94f3a06402ba15a9512956b1fa59a05b94338e734470d2224e0ebda742a3a26a3ea02106ac595efb3d1e9c76b8a92896eac187b225cabbff70e91614bd391694b2e0e6ddbfe496f04717a990a40e103b96588abf99a84da0e3df2dd48b3740ecdb652eaaa3203385083efe9027ebbff4c51dae599ec7d51094cfc5e17fdb7e8d31759be796aebb42bd5088de333532df9076df9d503075b584c794d01bbe7642d687678bfefd4d368dccae4568e9b1c576475208a4faa3d2b22de9c3a53e8bb5bfe1b469736d4329dca03b2edcd79009b385796e405313a9f74b5cd025480ff0ffbf6448de109ce2711474669a59efbee665244a1a65e497b708bd44f9e9e68eee1d492b41e5208b3fec420b85447d6f1dd556297d8b78b1d6317e136d34f4988cc5853c1f9ab5b2003058cb0d6a2b6ce4da5db5fe255665d50be298fee4fbb486ae040378d8d81774b794e8da08992e46e36ae5a9e71cb6d33c4f48c236aeca74007e1b3e7771f218757961dbfc4f034781805073a5b44659e7c8c142c3f81b7206ce76f8dbfaeae3ef1d17586760c5a3a98dd0460481ab298bcedb7a822e0995e3b2c837996fd1b3a134262a50b9e6655048e60d98b4b9dee8aca396bf29ae3921ac263127f238f867f1d8152603141a93bec6f8070ea916880555c9627f4d64e004d0c3cc05aaa190cfc206c43e584f8a2ff68be669b4b5a9a57e95d00cbe7252cca0e7e4b2e80038bce628791def7d55b6e958ad992ace9552b6c41509da55f3bec9e4a2f83e0e91a0d748bdd2ffbb3a47312802b9b44dd8942e8ed638062f61079a26f15bca2e0529654a36d146c73638c1d2f74171284b51a85dacf99bb9c19225f3c1c18ff14663a1ec4af696e3bf95583301cf3ddf1ba253b7e9dea873f4d3acdef8ce00b62e315bb677ba63311ba135a7459d24602e7c95254dd469ac2374ac26d60f3b33a494379ed79869eb09926038479344983ec386dd45399ae6c000a93419672d0ddd68edd3680e54185f003d40e64fcd2fed98eadae3b06144ed4f898b60c7e8dc9aa6278d93e9bbcbceeff451022d550878dc29b0cfc278973caa2d6c38b36a4a3e73b6ddb2e05558f985dab5413e18e4e9ab22a2ce6b65edf6b73f916e940b82190295a6baee934a9d1e8d3b7acecd3f6b9ea06f38d45d38a487c15f3fc4e4ba89a677440bef208b7e5505eec3e0b2bebac168283485d1c7925e2cb6a91fd8d18eadc13d6ec8b63696ead8472c4762e1d5e5d8962e691e5fced5a7a61340dd3ee7fdd04d4b685495a0b8ef23313f87f0a5c97a4979b59b7cbdb7ede0081fa1abed86d09e0c116c6f076df0bc3eece40ee6efa0d817f49ee79c2351251861f7803b6cb12b8c7238d760defc24d95ca0ca9f28078b730a2ebc5e4e70ab91f420ce53a88ef85045709ac69d35a821272606511182dd3d23d9fa2277a20ba3e2521b326ca88c1e1ee279718109f8654a492bcc3a629555c698d0a63fb0a88355276ae64cf3d950de35b7cdd9118879815c9ae9fb2f2749b429b193ccce05081d0db8b0ea4922b009bd965d705eabc66aa24e739b845bab90a50f4af943bd7c58ffa148f5bfd227fc0f4d3ffcb92496440efa69724ee7865830c1b3178564801e7209aa9c127c6240566d47991b14eb33209ce0bc40082ff209e82268f89bc5b93cbfef7cf4efbb86f83ad5bc814669f76f2fdaa5fc3bf7b53f012e744580de5f98426b0df9d308cb6bc1a2be8b5e211c2d99e07938b2022c006f3de669d63f3d82794061a0c58b50c2aa5b3d1d944ce8aecc2575e93a667d7b42abfafadeb011c83b459913e3b64cbf3efde2953db397ae23f51ae5d96b9ca24f61d08cc97eb23bdc76689ec707721d3c6a13f1ea8662ae0212e77a69155f3f6157fc1a558546ee4c80ce40138c9e1b659ba3b6c32829834216d8856985fbbfb9482bf7af4201a7b9e59e01c86a3fbb5967f87e49cbb4fe0f881e0f1ca94937138672ec1001f7562f6dc8bc17a38cd91dc3f50b4ad3d70d91566b1f094586bcfe2753c211c766a0ded0f1cb6888683e6314921e79245fe8a4cdb2e0a9cb58f958a353d074168bc8d20c6129bc9acbc46767676fcbaf4c474cb2128b5dba20ba939530e03665d2db1fbb5124eff5efb2d2958c22c6f2002492725b857c5c14780e87f000dbc10af12e3fc5a2d413d8ae365be86e63d522d843691f5d06e6ce23b71d41a6a849f553c166d4e02246c5513b148daa1975b75cc76b925bebae3bbee769f66084a6dd7a65ef1d6e950c0607e6a444e61b17f6c7ae41f837f85e1e3ef2c0b1dd587daf0ec89a545d722d00e39f9158ec68421a522f4e65e292ad084421fc3f309f3b9c2894b29cdd1dde359a1daeb1b75cb2fbfc8201605d30fc11588b8f487747def7dcea38596910bff143b58cb820a475b0b1600da48ca61a5d252ce41c70d549e30982ab427115ee64f217d061039f2a84a45bada97e54c1c14d01fed0fac6751b62e017d6407fe04221d5c0663116acdbad72fece3c351e9d41814437d1e36daf5d67697cf7fdb18bc5b45be5182490a84144c07612f445c465b96698163c4b033ce95e8ac3488a9e60a90c7e42cfa838b5d3642f7d8d1d9c9d11f1f39e0debb1d53b81cdcb3b717ce76b1a3867862059ce7c0b8cb8c58837f9a15f12ff15ab0eec5c546bae1f5f9e5526d84f5aa4c776c804757552d60f304107ac192a1926e438958d902fe50f78a1c80422225543c2b679ad22609a0d9dc9c5b90c771523ca6cec5663d0a7a24815f7b55343c4b2da7f4213c28a56b83b43d57d7b384dae4e8ebe5f1d7c5ad201443b998fa72eec64d732242b1ba946332c8ec79c7fcb72c87c3c769de6865cd54c2ff9c2f96460b682e3f364a04c9d3623aca1d103a59e3913e6e422fb9ca2965aaea11748ce9f0ba4ccba9e7b8840163f5c8b289e671602192c667b6fec7acc29afd68f0a5925e55fed009a243ca59bda8f82b93da0a1ea470fa39cf6083fc2fa07a5f9bc8ffafb9434fb530bbb214c0d4d1713990649c1e52b21434cb015e5ab1b4d39691da7c50ae88219d10bb782b91ee494fc4d7ba99103686db264083156427e9b1bc11dbdb6554696b0b9cd1776f6da17f076ec939b18c3711baa5d3384ead048f538f67a1093df0bef618efd749edaa9973c33dbc9263de0ecaf5358436aaf8766c396dcdb9937cc421def028e843fee50330c44c829725b482b2381964b51325a663c31af5fc71e158895ad1d217d6f4442510da61e51e3db11ed1af298c57579178e0fbb9c30108b28c0982566fbebc232f9164f8f9118e27ded0e5cd18f7d0c581cdcab46ef2be2c491f49f18164fdb2c3d18f6873240937d6678339c0c14fc88299f29ee0869a666cb60eb55cc63b3f4f17319119361ce7b88926f3a9f53f3d870e7df00f846af2fe2f122e4189c40cf260fe2657288ffca3d4847fa7b101d1f6c386807f8a2cea2e91ab986ffbff2e6f5b4e23d884a2d0221a02ad74f19291e296b5cca6bb3deeee74098c8f51a15ed665495155cfd9c538bdf37c53a2a53f4d7a5cc99d02d7f2ecf54613d8f355b38a3e841bd9ca3845fb0f4834e287d2d61164fc52150b979de57d479357fb1e8fbb68fba3edc4a7fe9040d5e215291512f421fa0958983f1b5e2f561d029a48774a7dec1c8f987c4001a94bddd68b210ba81838b2ccbb44d1bab657cf2cb42b820e0bcb4d483518c23d7b74c86086a990b1e351b4627bd7fdd171c652bffe23d6b86ef828c88164e9626e7deef1ee93e4314955d9b948e5dbc017f96e0e0df395a9586a04a0ca39d195749e67f263ad5c22783edc5e3fd56a727807e831d8339ebb8b2a4849a8bc589dbf1211af1b7ddd36604c70169181494236bbcdd5e8a7c4a937e4ddafe4f7afe445cf90e3080ef34b6ac543296b80906844330a952bd8a345cf1a6e69d913f8b406a6d7b55066ed96f6c9e7c7a184528cc9f6e4682c3b2d7783c3564dd8b536d441cd6f70cca26afa829483f31797807d49db02aeab6ef069e01854fb46f12673bb557a0c82e34d15f695a054daab74f16abf0b77056c8a92fc3f67e470e4fb199bb5d6ae443461b972f7ac95581b2082f9a7a32c5aede415cc9c527e96b70fc7e660f988468500eca2b81728e56af57b7ed8bfa466e9ca6893760d4234d06faadfad656b7aae706167516c2b0ca438230bbbe20aa729293f805699e723cafdee2f4f66dc7353d5ea760583e724e509ea8b542e9bd1651bac4374161cdf60ce86e4aac917edcdac353e8324374d370e18edbb24995bf44fd6a8a1cd55eecc49c3d0f512c31ff326c3808c98c2a4e6504876d89cffad530ab3e623ca8e252f03da8777fb8a2646509f8259fb5cbb88efdf27df1c6a6abd684aa31627f20ac31961c78e344b543ceecdc82b01659cf1d95682335c7e8259f95aa2557a1613881f611a653e35ebf5e78cff5436e92b1fa60f8b6a2ffe15516b183dc1fd5864c1c22446f9f82af7caedfcddc3b1d6b849cc23df72856d92175fbbcf8d8077531a4d9b2b4f22f19034a68b8537400e2fd02b6323f3acea739646f2cfce52f5810526acbb3a9ef9eab7447258e96b9530393e0dfadfe70e6d8f3f45fa9de3e56d38cb4036ca8db4b3c97e3dc98a6d0ae3328406242e54e08ba8bd76881d35883e112ac2d5c8e70da76c783022802d313961032f2fcf8686b6c3881fbdf4b4369da224a7a3988826f12725dea407c0d47fc1dc141754dfc61c619754135282768a30a37633c9ea5ba0bb3f72552ba68ff01e539968ca9b81c6833ef6b78cce58f025ff2b98f7e3b4b2eb89d7a125b1ad6637cd17d96598af304f5815eb3b95678196ec2d87d69ae30ddfac0ecb6c6ba686f0368b25d05528055f9e6543e29060eb5ee36836818a75c295c03fa6fc05c5e13da7316ce8dd042be68f337ec7e0670a3f013edc5644d4fad7666e784cd2ea0e740daf391530a340e4eb224cefa21aa4439d3c8ae5c51c3f8dac5069d617568e3e72d2d2dc5aa7f77f30f476c05239ca1b761a7233366dd9ab3e2d09f4b0f0aa7ee669b3ab57441915535ee194ed1fe3ae19952226190729f0db6427e177e05eb85404d2b938049d1fa03d15dfc05600885193ab5cba6316166445217893c084055be8540551adbae856d6370c5de6c9a8d78b574c84901ac1b7ac0ebc6edb867c68fc54350bba2dfda1301c2e324c4b563334803e98f038a5cb9c5e3df0abecb71669c0071a4429c3e0f14dee017c15dc9832b493ba8a4c8ecbcd5203b3a8859fe133d4383d8018990cf2b300598705ec05cf2817128776a745c139c7a63fc1d717beba2f4493f2b9fd1ae5f37684a609c0c0c39a02301502f91382d85cad4d05e410bd3979ba9720610b2fa85445f06da6809e66ef5c6f91cc916049ca7b0f0121292e75912d3364bfea1651a5f45be28fef736516ec3280783e57724a1c628f72d3b88668561ee0111d783de8f330d54f5d037d26298d9a230c82cd0cca3a4c1867668296aa699fd017a77b02a7426fff28abc69affeec1d046164b1c9ecf2670c624c96c25993230eafeac7eb72cff6648f825da8fea1703c5a6d04161c0e4937150acdc025a762593d55e4792fdced758a1cdc6b617a6f0973ae3dcf60e54e7951844412b021532cdb127ae7fb52e4eb95a652bc3a7bdd575c1be98f6bb9e15bc1cfdb54aed79470341516da06b1805553a61d506f2ecce12838b3cc5ac285138a754cb0fb076f6d54c4a3a4154e661238b034f4014f56bb505a45b928a4af01f586d3721ab925da510089b91a5740170f98c27d348901724ab27043daadcf5d6d61525482642c48d3850cbd71535e664024f252a3bef03ff856a6a1b69cacaefd8d45246b92d90f20ab4dd9bd245638e74a478a95fdd5978ad65cb4288cfd352ddda78feb8925fd56bf274fb3ef1c3b3fec57edf1ff4dc4f255cea31a1ef84ba8bba0da999a5366a303c8609532daaf95239511226a2afe4c3e9e4dd862a1abc842c281dd785d1ddb8e7d27869e0636f5dd30291bfd8dfd4b08d45f8224940018e315c3adf71a380c35fbf6262c77b36df82e699348f9a3cd84acdb8cbc651432649bc5a50f5548fc1e91ca0c1d2e6aefd7052a19da00f6e57648b870e56e97d70d2d9ca058564e3cf20765c773001581b902a20d0c2e99d2031ad306060c3f9b9af1f3f4b5cf6c86acb5a4c9864cf3a78db1a9be0b3c66b64358aa6e52f915c5c418960bca47c5753b2bf5a2be1d3b96439fc2fc004434cc9e06541698d40aace5feeb8a08ed7f5e525ad42a13ea128bac2b3e751c21e328efb0570e34cdad559a3dc79b994850513b3defa963a1ba0d9ec0d53f8b90456e289d4f9c0228e809e8342579a214eb14c122f7dc2c80b1e9d58a1ff6bfaf654d53c7c4fba39cfdefe85a49ad7ad6ffc5c289be37e70a5f561418dd1880199859e51abd147e30641772c02af5c6ebe106d7c46288aa8f6a7f8b7c996b13f8d4dfa2ad4e61e3bd8082cf4ff3a79dd985bc04b914ea34e5a53995fc04d7e0ad546cd3eee160374670ea593a53daa1fa51bb8f9d45688f2ebd0ba852bb71fa26d498533a2f953e0b62a2cca83a1910967112ccb5e16d12a2b53151b27194bb333ad6232437f7438803c7d885fbac830fba8492c2f7a4b1a85e1d2088a5498d3723b873a51ff6ee9ad5d9823d271c9c9e896ba59d6ca459226db785d5f0a34dc67b3b6a6114e61a84032840056f8544cfecab94a3e58a38b9604add0c2df754b6b9aaa5c0ff0a91070e2a0f1effc49c90fce8335e3467cf93c05140671d4fd404a6fca8be1ad90d9e2290d005f6077e5f6c265da7065e70cfb1bd737833ef9658b837f28d25bceaf99a5e53ee1d56251e75ff6671049131f8f1004d869de48678a8040e4fac727d560744e6dfd13ce7276cf9b2c25ca6bf352529d5ced88917fda9225ce276fc69ce70996f768c5259094c02cd5952753589fe35abe4e19b830c52f36cfda5f7c6a564dfdbed3515845f644ee5a0dcb3f7a9754eb09be297a540636cd799d3603e79e28f9a01ff448bad4384c591e3253eee6c9370b4c5a92a67259d2942d5e08483fe1b290364ee79dd3bfe722bc705e5f3a0df454b892988703dcdc932ebe632dd4ad305ba305b92d6dc3554ddca87627f85290ab04ce6f603fe9852f766a4047fc00486a6e80c2c9e0e75fa4e13b187adb688606395b31c17490367e04bc5fb58484993c06e7b3d51589a47a44d75f9183479f42d5f6477983ddad4bb013ad1ff2a4e81e64e207656b96c1324cea15e2abbc71a75a1719a1d18c5ca12c2aa7b3321d6671fc89fff1780fa2d8c2dd01482f6f8a16bc727a2e6789ab1f8610d236c131494a98f35f5df3fb2a614a5d4e7020664a01cdbba7deac81c5ec77a49c2c606dcab9db6b8d073d88f8913a2e820e94abced8caf67200a06f3c7255585d2ff7a08667189934f71d7c2f5eb1c0dc31e08eb716e763ce2a7e1b949e7d947809c4c35cc1db4acc7493745e2c2c46aa62dcb487bf27b86e97d36e0f43156d675b6af3d26b19fb1638a3b5306b110102f4baff60c6ced8b90298da55be7fc45f323865ec2fe0a4b85dd2ba1e668084049c05fae1e301793770dc9dfb11cf0f347d44ecb3e2dcfe1c3c6b3a36b0026077bd5ffb3dcf915c9e96752c8a30d185f2e88781b5b68682f1e0cf03470b77f9908989ab97fed6c63365321218b67a33c8f4928766b2f2bfc9d726b4d027074d333e80f111267473cca2ccb10c97363a08e9bbceb419895a57f79ba661935e46bfbb5b0666102d9ad9662b0c5c81f47abbbe6e5ff1ccea851b97877b6fd8c11db492b4f434553e4bd1e597465cd3d6ea92b8f17b97524dc3d40ff2ab5a9bfdfee5a7c387d4733770be3837b2699b37a6e6160a3454d25891432c656a19afea12b0f4138a8dca232406926ed7876e2e4cff774e9a1ec3f69ec4cc2fe9aded063e5be9398f07ef480829e15db8e0ee47ae863942b569b2c1060ce507c81a187298de394cae90229e5b6aa3446d672fb7331967d3cab3907217c2c4cf49cf04877001c639eef26ddba9e8b8ebda43cb5f1a007c036dfad4c31ea3f0263cecc45f567e7834807708aedbba45851b06422e9fe6a88b10629656ad2d071dbf3c909b93b5ffa78b166dbe5b5ee6967a442866ccb218153f20126c6ef2d1cf5aec5a42f708abf4dc5fc341112ad3b39ce6341f00eabb8536813aac9559537845b76fb680946dd0ef72ad0a52e07dfbd2a74abb6bc3c891b08da7a30e6cb5042e2f557bb748144fcd76b218e7551dc05a9681d1ccc4dab2f2665a23f9c7e7ac0162773395e58d26e576d92fcc14cce0978bf9cbe9d5f4a4633a8d17e63cb0d92133c20741bbe4006011f3202f18e94411e7efb71b8c5668b7eca17e62c64ed4b0eae946ec7e5f1f82424ad3a94556e09272f7aaedd3cd0bc5c162a4f91094392ed5f50928b37560ca194356eecd6efdeb3394f37e9b95baa63bda5bd305d912b112ac4b9921d077d1b156bc87c509c6db4c113089b674abd85b1606bb953aa593c72a50c90fd795040d844d0561f0b666971644c3a211eadf4e42852f804600a87a8252633d20ca47e94f02944c7fdc0e3e5f3bcf9f4ee3110127860618b9021d1037863cb699806c0719c2f615aaa78ede70289eca6bcb5b713918c895dbbca2dd363a477c1e4d5e029f2106127050c293e1c83d0f58fb50dd0547e377ebed56a2154b0672c105f1d21e2e9754ca3e69413aeffe23a09e9649440e96e4bc9f4ef3cb2ef6b51477a1c385f274fe3541b987f5e3d4411cc17dceb10d0e70170dcef65d60c3d86e077308ce5ac0d57991229d5504e27ff829fef69d94ee468233528be89c5ed2fc863f51d221ca7c29953549de0bc60551eacdb0a58e2fd45f6105f6f263f1476ac43140905545eaef36c0b29504c16ca14e4af4f52ea40698ac50ebd9ca9b752d87aad3a8224fdcb534de34d4478836a9c108eefb4ea9086160c22c471b8ef09d6d0749ab3efd3dc782d4fc6c10ae5b752c3b0baf81fc7d276ec814fbd0de27a01963f6845a2a431bd1718e119807b066b69af34eaa71d04870b9a1b28ddd95b70b7f414704c016aec6650ed8ed0bb5aa94d16661317d6b0128f9db8f2968937aab47a1015259ff5745ffe9578569663ba5519004f0a6847b2b6467a4d00f0090effc67da69166457992e9d9f2ca77f93f36ee72c6630f3004214543d08cdcdb9a0fdd94626a342c805f8b19f395dd9760b22a21f5ecc1a46063d22452c66869180a8de2823316113365a6855311960f4b7fb988d61ef9ff629fc13725618955a257e5eec0ad55858c7e904627c6819a7204d0ee3b718bcba5e3aad5ece5d41ae58491193f5e79c724845ef03d102e8cd02b503c128036910e0e05fe2c0f56e9cb87fd5db7c9e23efa9b5ab7798e3e29f2c6d14aff505f4589d2643c89b653e8b06603d712c985202727130fae9a52c6ffd49a3e53012c0c7c8d8594296d8f749f978389c8909fe828c85be32ad118bb217aa3ebbe56aac6ea500ff34954cb423641d7fd7c4513d972bdbfb711fba32d389a04e28a4ea73806ca5b8f066ce26db738aa0af1e661b04bd80dd1c0f0b8e79d15d5912172afe5a4dd8242a4b2dd3a2c87a92ca75625ae166c13683e3c172957ef9a32513140c58b3a97e649e27b1ddcd536d8f04ca7674c4fb01e9e7e762f5522c3efbd56d68bf2321f569dfc6068754751eacd632678728e3d646adb78bbf329e2baca2ce90007d2d00ea50c9c208d96e94bcb25ff81e9b920b0b6994c0be57417399a5ce06e61f0d368d08d04d43a4ca833497e6a91d9c29b266a4045f65bef4b501f6e8f67ad941fde8e00b349f3c8dd3bcbcf8b3df20cb339f2a223db7dd10e69ae9ab5639db69db85949de5b40ee75574d3d3fe9160ab0a023f151e2c620cbf9d910a1b8ba38b3e711d1e75e3a12ffd1bd7551a6ecdb646521aae3b295fdf6c97fbace1e35081095c5de3479b78e1dc17ab27def99d37ace69eb015e4b1caa38c93faea90d2d1986e1daaba7d942bb7a1bab127a4c26214226990ee4a1089f471c3c87cee2709e6fe45177774d5dcaf77207bd1b49ca204e1c0d0b6c1cdde65a8fca8086fd96435f77f0e570bfeef26daa3d48387bf6e1d032970c89a9fda34448ac24afc4d735399c5063bd0b67fe6b0441d611045376ba6f0774be6b8004f04265f4b4bf8e1a6fd2e0462db53d4b5dcfe92be9e46a5f663e6c390e6ffee46b90f9138242e208e31a02ee89ae78063828f1e9705c4467b9aead3abc9d3af70999ef3f26e26ce1bf43cbba0d92c411ad3404cfa5c4b68d834b8a7937ebdb167589ab6866bd16875f642b5dd6c06b51f13820bd6de6e86666653f27edbd0d0851f72656b1c45435fc577836d7388f9ee4b0a42a0b2b4ca5a8c4b77837df355971ff607c9fb7ac5aec0d0919ac1baa80fea5d9c36e0942df64847e281e7645ea83248ae011b03f04007af208c0537e55ef91ef834716b9a96988257799727bf357c89b4bf5a9bb8d8c5776cf02d0eb9ed209e09dd3d646dd30311daafd8b544dce1881573f617525c9ca2363eeb80cdf122c5fef70ed6ade1767332a9f2f699abbedfb87f611f0d1f8f31d84511f5148ab201fa462d907dad33fe6e86dd085d5250975f7d2793455ce5df71139d71fda4d19e755149dca5b7695f6a9e179127938daa720d7a289694b9b317a850e28d22b08592680b74977469ea7d0619c256d99d47dd4ab26d331b84ea16cff1a3489fec1acdd4987732789df4d792c5e120eeb80cce0a4186a1e281301f212c73d6cfb5781166a12f98fc633b2e07fa066c5c55f2f475b13287d16b67605c22c315197113d659fae355b685082af778888c7469c4f63a596bcd6e2afc14fc94f9b23ee493b69a6766746254a3ad56c5411c6b558a96b98cd916b3e9b142adb2d92c0421c98175126c0b3d05265e240188d63cc3589d6eb04bc57a10b20436b6183a790d146a1eeef2c19370706cb2e6085103c10b23f8baf64d1c7bc56077525756fdee1d8f2bbd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
