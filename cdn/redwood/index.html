<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d84126792195540c1e7352e478f940acf25d197e48b9cf88fd1a265317b3ca677859c7f62df46f7cb441dae10854d37402f05cc1bf3f6b70e87aa900de02f09b6976ec937c1dbd3f84c2572e2fa2a7f0a02b9f628814f0f64000b72680a184fef4f45d53b3c820e607992e1583fd2f2469826386114b1952eeab29519b0c7703dd3ac5657c85ceab4bbe3aef831c9535a50ffce392de93eb5a9a2cb5f2c46166332693545b0f89628baebd26e1085b2b85be10d6719e40c9e7d76e912bf06d40d7f61c456a98c6ff871ced5483406a78ed97f089c0ac2b67407c0d5162cba4e8c9d7c04c81d0472663768dc426d3d6543b96f50be325dce451768d247cfc4056b4a65cca03825839b128f0222db097dc942dca1dfc75324cce3baf941e2bbf25e1c0819167142ca5501cfefe15636e78c33dcf8bbf2fdd2c8e9a3306bad6c46e057e96dc60f9808fdea8c24cac91413289f06e2f3d05ee6760d666bcde1373d3ba269e68bb92abaa2e65a6f5e23f6bc082be7e2ba0bfddc9d42920a4efa230a21dee3b432e43f850ab244562881426ac113762c9a45f010ff669779ab1fa18c8dd461bf2616a18e9e90c8ba8644850d3a07de28dd3a9502ced88deaed3638e662604eca349d912b5da8d8af1d077357b571a663061923732a28b054c7d4f0d81d46016b10e6e0c0b55d99980924355476d84bbcc89001aff2834f25e379fd2f81a180a9ebbc05f1b38ddec4f4461663e594c0c243ed6d96e4898400fb7d585fa7d444a162c016c6df793b72bf4cb6df5d78a95b4408dce7a72bf8849d57128fe7dce182c05cd46d48aa072a45b8500bcda4dd8f39a08e2e1a37dd26f5d70fe0ee1e0bae5240335c783369a2102eb88383f2af7afe7dbd87c7f1c1a29add9e590a142019559399a73e27c6057e30d5d3297635c36687af38f98f59fdc522ffc73e8f7be2d8fee180887986fdc286c8fa6859d0fbf0037ad04b123820331f94e5cab36b991ecb72cc315fde2a6025b86f3fd43a0ee9bf0440acf3cda6ecb4b489e8a056773825ad6315709278f93f308b51472619d754f3548b68e32a6766c1a219b6f8f389b8464d10b5890a436591c1daad9a42e8e48119062512b5d72c64336deb6777df7c9dcacef20e492390a7126d7e409e853d5d9af2eb99e226663b49384d60c64ca134169e1c1cd6969fcbe8114ed70283410cd821e140899726c90ccc71897b9a672d55bab624f6f379d824dd7f9f812bc68221ab237f1b4a6e4bb5af6efc0379e8e465d744d0ef1f62a54b7a7c7bf18d3e2ecdb611fa8fc7350cf87df9c468ca98262f2e73a52dbb1bc790eeae6cf4652615174f11691f5e0c75e6d5fcafe5f5b9a76643c98fd1dc9dfdc34d1ef5141984db646314dbb40bdb7ca2b2251d43071eb09f0c12a356fec4df304a0c85cf3e4b0bb25fefc17b57761661f7df38b26d8be96b7982c3f09041571bba4d1e7fac1c7f7c7af3fce32d4e15c941576fa164ff5646c44325985a0573e66eaec83b6e5d188a0797fff05e1dc2c3b395aae9d2f180b1386514a3236dc69c00bb77021b6ed8b1aaf3a1aaa260ad90336d5a54f113f4240424e613397b4960e1f0ac64b4987d023696317d3408f446e1be760a5fe1983f4032f1dc79be12877b43a0265b64002a863326162e689122c7e2d6d442b2404ef46ef922f81bcb91448db6aea172e258b7009f691c8f883771c27abb290e13e56ecbbf76d31f9fa83dcf5ea8da9903825d458269b0016ded78f81f33dfd685e3a1bcef80f950ada59adc9345b52265ef58323d1ad8da7be3a5a8bf24f281fd2e648c3403bb97a07432dbb817f029c0bbfa21e23ff2473c9b8c3046a3fe386737289c14e12abb3e1012f5d3dd7f7b7db852ea28662ba9d492678ca9299dec1e0449d8b006cdfd1ac5a7f77988c6fd1bc91d70405f862d3b73903f88fe170236db8a838601b2c55895fdd722dca7f99a45728fd879ba1fe296392ba01d10dc6a83782af047acb46d47bcbb240926b76e24fe1f464e8e0b2ad78fd8f3f73d50b50c2e8af8639d50b8349d4df68caba89718e723c96bfff2268a8cbaa7a7c56d6fa2d762ca7b5e622be331221f2ee1fba85d9bc49a71937f88ad0f2db79359ee66c408e265c0516b60e016c7e39dd4882ff9c89c8a58537df6c7dd206298ea6bdb9c2929045346228f681451032bd280a06aa5fade02f78fe1dbca949361071fb2ec3888eceb84bb3fafbe2efa46ab4ff78e72bd5fdb8fe5b61786bdb0962a6866d72df56073ef05fc970e8d653fa925f01d59db26ebec5218b45ed859c5dd8accf748fc80e8e9a528e5f872a4c4135f80607a6535a1861e59c5c111ef4c3da09b7378ad304779f928168256299e2ec10307642ff66317e813e0acdccd1553c804eebb14cf0482f2bb237aace84d669615806cf54c13d29a4aead1fae5661b994d7cad83f63a55e0b6747ce78714b6f16f9ea0c29191f07e23dc713bba0e5eb26431f76a262f9445744990370163f2a20108eb50b67f02cffd0a6d0855286350a3a5b6d73f439e94af4ad3d8366639caa844acb465d2775fb69090f59f86c9993c7b77799e156e97ab17f7b7959392c49fdc3685c87803d69517ae72614f40b490df349a2d79914a35eba61a8fef395159df30ee3bf1a7f1965be3dfa82b92d50f993918f28f7f818c21ac0033f22e072f89008eb7741d5b259a6e937e6b038d20a8b1e0506ae5e647223c976437ddefe97aa30ecf67a559c56e232f8e43116dc753f2ae834591083e88175fe0b14f61e3afb48283c4dfde40dde22d03a26a72909cdf67ea572c514896c8f396399ce4a41717e322d155e626cfc002a4a7ecd21ca3f57944d71a7f56074d4795ba95cf74d5e5261dac8fefe74845bc1d92b11ed46ce2f5071671be5fc289d83fdfc229c42c717564083f69ae2425b3128e9b99f784a94f1dd2390b8ffd71273f40243827bd6eb2059940eb2cf01eb769b376d76a863d9103cf48d6811fc5261f01ea7fd5532b7a51396e427dccb319f5d3185bd7a88b17937886bdea7bf9db00caa068e84228d52255da358503ac60af9754487ff266cc35c95e29f27a1bea590f6337bdd54c1928b5a439514db9989c0c0c04da1ec539ae09d4f6f91749f99fc0c70e065c8e611258b4b0cd47d1dd1c0e57af87adf921f2923f301241d77972009d0dc891841fbfd181bcc99c8a92b60004b64564bdf5f8432e4bc2ed574b18c01e5938491729cb92467dd3a46095228dab0c5351b80e41dc1540d7d9a962647f451d18dd97aafac27c393e3bbfae6064bec8f79605705440dbdb9f6cf2f08df5a89561ca6ff46566b68e9aa9944b3529a787dee6b460d354fd8f76a2ab9d39e169d8b1bed5def364b98b685a396e857f429d0c2c1d48afb48fd55ba01097c23b34e949ca376d36b96ed7e4fba31728339618231a2e1f44c1d270b30b9979e48bc62dc539bbb0ce1e5fcf8acb7ff27d504129cccdb34d65e8d5d75d922d50b89dda2f364fee5561d5cd5c70ad4a8703b0d5d67fe54811f410e9cd9c12e86a61cf5e68196c0fdc6412db77e8dcbb4d4538ffa2b7892c366f5d253f0aadf141164c47c190e3821b250c7a8929024460720c3ee365c744b3981bbabfd2e59c4f0e9d7fe248fa3f0af47d269c0f6b5826a6522102ede16b06a56795b661d1af6f29c223ac995558253a8aa2f2c7fdbe9e371b781b9f60303ce6c4dfaf91473a0862466be6ba23b2eb580d38900e2a12d78595d6fb9b4569a7da9958bb155876786497932656fdf41222ab92f917538aaab7105198ce6c9158efdcbdae090ec496cdc9307e1b4a1fb6ed539c2c55054a32e96dc206bf0cba958ff2a422c368412a4d85b67ab2db81093e9c7562153f9bff0ed16e88adfe61e80e8d9b385fd5a06dc17de86d4dc15ac338ec8a0b1e3d25095fcbf01cccb6faa09fb31df0f1c22cebbb0254f5bad509b1dac873d96a4606166a4970019c8af96f2ae0f925655735994424427f20b78d0330236166c5db506d683ed0eb10f193ccfd1f017a7a597c62e07021cb34ff4c914200c74c44c14b83f84391dec4922ef1c2480d96de38526598b109c9b841adf280573ee57058fd34fa048358bebb02ea0de6c02ab0ba50d29d3f0a5e2afb32728828685c959c3033f2bc6eff83e1e77d67a0fa323166fd0f206040d6212993b7e8d4a5539428b7160d74fa02e0a7b19a0036d4b71f07bf01106526f0193d8b74c7a6d52bbb9e68be2fe2979a1fb5c394c8a08368f3ef3d205133d475074b5c6dda5476760c39f6aa1e4889a0db4d7be50836e03c1613424484b9ee579c0e4ebdf66b2aad8734315e7a718b3fab90663e1b1954b959a3cd197b6f0d11b84a912085e2decca398fc461f5883e32c0592a6903d6b8cfcbc9a355d249434dcabf1c7aac3aaab3ea1026696e55cd8d59f7eceb0bf6a599b6ade36afbbcb15374098bf38e4b4bbdb46b5de5b67186dca47ed10d783630e1c8397659b2cc96998e368f753ca694ec33fd00551fd2074280ed968677d0dc8381ccdcb59ee194fc5589728ebfd18fe26c3dd50a0134c9450feff2a895359f2841896c5785ff90f1b65a3fc12a171344689c28fb1de480be685d44eaeb6407490100d009060b7efcc9bc074b4cc8b46ece0c7b2cc6e48c0487b203203585b140c598d9d2fde517aae70c644549911dec5e3bb25b2e0b798d473d8c35496f4f4a19063c5c535f492c0cc1b82247642d82e2d858b73c4ec4e1554c58f0dead3b0b68bbd4b68ae32d02a457982cf98db49b77dcff0c27cf31ccae874a45439769664b7b955bb709ca4cf8f3e33f6a478491a0746651ad0ceee4f36fb4f7ad18d97927f35c687bded97fba7270ef7bd63926f9fc267aa2dd6862e5904bdef7926e81905a5a1912fffa4e11134f4cbe89dad7f50766d6dcc4242b42b1c024362d27812a5f6a7a262c287477626079d714cdcb268b3e97192940617f73bf2860c740c7b7ba7d81b6cf04549e2517497365a21702e3249ec195283cb54b72ff3d42071f18bd0842d8f5a56123554d03fb5a1b34090575799cc3457626f185578740d4f0f3a9d2cd8bc9132fdee52fbade0c88e58afbafe9872925d82d104997c6ad82e360721ebf79b5d198b23176490c4e6152d0865ace5cb1b4575edf56205b207d83a0fd4cf73e95fe4df7539c458ba764a9f49177f354b6ecf8c48aca210106adfe78ca65c3fdee9f64af16fb6f0ad48b100c884d691bfaee96efb5c20c8a644a78bdea98a0ceb59070785137cdab2c905f99068dc57e965c358966b2d03c8fae2b17faec4257d805fc0ce81cc3450c3847d708d81f3e9a8e953be839584a849b6afc5956a4ade44d26955a46b18e1c862f71fd489570f73421658ed89384781ee9d0b088f1184a8c65ad431744fcca3e192fa1f08437b30d5d93da42d538698f934fa4e61ef423a772bd5c28c1581803c105a12c0415fc4e40e3b2823f3de85c53e6ede56672d2b7c0b2fbe8a05738ca4acf86a4e7df4a4da9b89e6bbb730ca7c53b9caf7f81247f2fecb2a27585285bdbbf117db57c495dfe5b25cbbc2a84919826c8ea602082c3ffdf1cae89e9dd1ad29e7b5310aa330bd7e15c240914a08213bc54bc1f9d9dbad0740b9d5779ea9f8fef6b1efd7aaaa9a1cc2784027eb0cc5eaf64a382f7d27af211ffa295834a7f1093cb5f8d56c4f7e60892ddfbbcc3e62f5ca3833497c4c74eefcd6bee522ba99283f693a2c863de4b9f34e563e8ce0ce769e367edfc5f1efd2f9b37537bbe1f930c9072ae5e5e71b563814aa45554317d00e933507ad4f6dd4d0ffcb5336ceec2aafa671c1c7a7063ff9c5715be75e5c8639170f22ccf9d7dc00b9a42212f6f4fd9dc6e771a3018dd64f381b82cca2c236748a3e3dee6c4c8bc598454a2b70cb508b3028cd0c508a931997a60de870d02a227510160414800d048cb99ebe2a5aacf18b8beb34fb44accdbc1c51f277f1b9528250f93144313182b834ab57f36724e4d2bfbf5feb3202e93bf8372e3ad6dfeeaea14843566be1ebc6ec046c9425e3ec7b1057675a02b3885b3c1f056a38ba43b5cfb885a222f52fa3f65bccc204882a7dbd163dade1a5a3b49530a1e783f18b864e7ea0690c825f0b0c210e8de58ef37a8400cc4f24d877c3cd0fb8f301251e289abcc045a1c293544f86193bc731d134cc19f71ba024a15e6f1464c8be2b7a09f522dac206968af22c7b086e691d813cb9f276202b996d6abd381977bc3cb1e664e0bc88e37e47760deeb609a0d9d928b1fde0f7b0acce2501e3d04542556dccd74ff67f0ece513ef37bb94ff1b3088d00bfa4be718ddbc59e02cf4f023a609fef68c9343b70ed668f53a48dd83a1512a63fd44e316f91cfb6739b19fa68105708e44f9c40dc89a31687b1fda71c081f227e11b6838645ec8677db777ea786f09f936dea0aceccdfad7f9268bf6b1d0b5005e313061a4180bcad3453be50ee8163259a720512bab7c441e504265a883559d3bfe7240c0c31208428d74c050eb425c2e8a0e7488ecc5455df1dc6269468997b5b872029ddd05cf4a71d3b127d4b81d7dea74ad7012bf73875500b950e01a17e628b0cfb7ae0483d9725485005494c63be81c4912b130dbe7eb4fdab2cbaefa6fc1fb3b048a87b56b65168a38d5de03da9736db6a66877296db8e0ed42d1a70321ec414e6cf850b51e970c3c25bc98108fa67bfdfc76933909aba3acb0d9f19ecdf85f0c931f2a66ed4b5f63b042a5fdd062d82d48388a5d0d2c81e68309bb17104f5c40880a7aa75dc40e9acd6ab13032b8946f68225ec2bd9ce5859b1f7e9fa5e36b1311be8c0663cd0968fd6002a30d4b62740e13b2c88d3bdd7cf95069ebfc3fd17bb8b2a310b4874fbd221c7a96daeef9554a36e83ff627da0d0efc9e0c3ed34f1a6cbb161865d1f8339626b710c96ef3004d07dfa62b9f303cda81dc80cc5b98dc2499c28f35e84a95ee3864d77ebce7e5feb251c20478f4da5832ecb5e7b590f9de46e41d559263644582a303732f6e854d0997a9017ce631e51accf33c8a5d03b16d03df491fc6f1e71bf290fe5d07d407d474dfe01261a4b3058db19bf282c0f3b6c2ce4b04597de83cde9ca1a8163fef0a769ff9764e063dda0c99f7f0eda61a726f143eb2b7531f5d731c7ad14f2d8beb8f4ad6b92a7eff16c526948cd3bcd983e5f811b4db366b5b59613705c0efd8c446bc8ec0cdc2c4290ba5ff1afe03310b290212f6792cbd08c74051fcb06ec031f42e7b62ab7794f5b3486ea4aee307abff8d8d41396496451e8bcf0b0e518f5908a7ff5c525d6adc5b655061a50d5622de12e66e4d4eb32275f3a5eb1aab45a28b2badddd4f04e20f625b16b69f4626abace0d09f98723e929a7800fa81dd48e7bbb5024934cb5e5bb38ec561cec107e2a653ee18ef4913d3e6f9c4f265940ca6e78d16b1d1ea7a9a05d9acbdf48c67977074d6043012723a4ea40354e194f87b49e61766c779826ba950217470ef009afce2e502bd667a285b148d3c337d0a73b6309193cbe3d54825166b261daaa6f509c294be9617486e0a00c35421a9d3d905ed8e0f8122322cc42271038b0c51f701497d0cda9da8fbc32d3a911b3f2bf1abfe16352c404ede140fbf0fad3169201e2dbd0703882c0ea7769ec6c22cea1b2e14bc2f3431e5c7542f86a75b7f5bc40664ddee11f00421eb532a9e709fbf08d547d8b9ee249a6b9943d1cde4a7bfdc577310eba6efd485c1182019c28f3f251558706143c7e2b9291ac2a3733625b3b16c97735bfaa90069e7e0aa4f4717bbff79ec02ff0f5cc159486353d5fa2a6a94eed1f220127016bba850e31cbed4bf985b9039dd6baade495cab2997ca719497129730066783f3f09ec5f9829a99cc921b47725ab85d794267d59184a849cd2100b73e39713232ee2260c0416f7e8b55d1ed6d4bdb6042954d9ef3ac3158c8efbcf962bdeeff9d9e080aaf80b4b4493f587ae9f0b9b5c9f90d1ca268c21bfda447fc6a02ccf6d651e50f76f1c7171839f8b51a3ea790f41f09d8dfd00254c734c1c4ed777bc197d2178c3f4ccfd44a2f1ec712b0bcde0e739beaeb512e70125769c18c33e754b37ab4690be11207d94b44b158164f8ac46235b25dad70163b6afc4362dfda9d37b62ad271894bb121876a200e81832235bb59ffb4cebeead3354b72b7a169968c3777f7f1d8bbc8b8cca52b47a18f432fc55548a59273a4e5a343b7eeea8100b5c364766754ff2976325056cc0a33c9f5879258f0067f69f9ef419985fb9ddabba684d8e415dc6d2abb5904a12c026df9521566b69f1cc9c8c14a88c7fe156ba2685e89a43f3b9dd1cd43a39240abe5a15894c46349480a0ce68a1ad168d34a3e122a423f38cd2bde6229b87af0b8bb261eb6c1c79ddefaf30d523dffcbf71c31ec6ca7db32a1af4b500c4f6bf10bc2c240e3dac83972967a9550a6b3946a6d5f375db661c8dbd7ecc06bfaa5d18d2a56dde45266ce087794ba8d06a54b105e2d3bfe19f7f28984a9dd9c1d600260b42632a12914c2fd70ef9b343601e5faada0dfc59913d4bd0b230ab94d4f8ddc683169bcb5c4e0c8782f8ced37baf12892d459b74f1f3cbee6b21c872b78aeef87694da9f71778e29a32c063bd7edc97995787d62284e91160014fd1c63d8df678507f1cd8ef0bcd94ddb9c97df2a11ab1ba51253ba72483a19ae99f77ac58f6298b501908677d857f5b743ad875b7ce598e7a0169cdf6744189dfd7805d3c4c3cd54feb35b5af8553b3ca8ed8a0d94dbcc6d55a74d33947ccd31ab39596beaa0093af4768f5aef65f8bd6086e7e24544aad687f89a6be7d62e176fb406097226dbf63b55027b8fdbb068013d532f20555d4129c30392eb8b7533c74056dff41cc09221c410f1dba63a7da809eb3e08042279313f666772f8dba7c1843d09b76ba3825f723932af449693c06343c45a18968bcddd00fd5d51281b28a5c06a68716b122307ef6c5c25539d196e98aa032c800a61ce11ce9ba481283416fe0bbbe0811825b80410cc2101c74e003ef85834967e4e5971ae2bfe8ae5342ec3af2df7487c8ee745330dfcae7cd677e7bd4832b3f00b37822972b5ad3d9df07e7528d8b86c0bd83ac45fe3bd566f522071c1fd11c019cfd14f508a639db65db3cc9a077692da31600038c291b4fcab699622ce315a968dc14e81ff4523a36bf1dc1b3514300b497d7970dd022cc2c87aad37075d3ba094a34653a05572cbee2d1967ca43ca1999b60017e521269e576e5fdc9e80a07ee7c885578327318390cd8117903f7e89c74fc282160df1795ea39ee56981f91f742a93125784d7d8ae8853e427b5cb31a5ab1e093ba276c3f307e9a5aedf2e0f4e2f12f38f50263563ea3c30e44609c139aca8eac503c82becacee6507511933f52f2b0286bcd1dc15262a45556e7ba797e6db539b6f2076186c1394f8b9f0680814a5c06c9160e70fd9f532804099160fa151ac61d4f4b4993ba6dd4f656663b6139516f30eecc721386503959e471dba71e8c5915e69d99fa79b98291839895461a44f2ac633e0036c495dc15e40b24b984b100a0d56b63124aa31135c955ac538fc8021f7fdf5bc5e7d93379e7a00ed00347d6e27333effc9b93b459b6799d61cf28c4ebdffd6c47ead710e6f5086f1115d6e4ec13b2eeb1a940c7a094da13a0c5e49c8b40d2851433b201f93669a155de8b68f41c0cb4b26e729ee9c761a1d3a63f38e02c92ad7e22bb566d38283f3783e2f89d6cd3c8f7eadd556f07986d8854ff4b6e4320897d431a8e4d99a4494a642d44579f66b873b7a6990963c407035c9803114322bf447bb7400fa4feac602b701ba7963d68841460b5009241b57dde6987dd3a4c3f45aab7d54006e1b6618fe3703ee8e231b7c244982baaf07a9b7b98aff27286b3ce933364325e2f8e3e563b14bce745d842b1747adb0d9b345dd9b049700d00d7e3dace58d09e834c760a9d3f0ce3c767a0bd28300cd35cf95063301e0caa038e383850e675112c313476124e2e0dd4dc526f88fcd0edb93a39ff1d23abcb9a7b878580bf4a8ac39f3880616a375e0f298753cd7c6f8901452c7b619850894c64d408877555bad1a917c51c4c78f1b447f4f8bcd67ca725f63ac16e57869b2d57f4b6a12eec4cbdb8c7a719076c8ab5e415a857a6463f611a27f2965e319740f0e4c9ece981e664d94a344a7e3a03addfed7473e6baf0615040e8ad7169225537e509db7fb19fe1610d9593d19de9514f8a5c5780ff53f75b194c081f84d1c9c09834d37dfcdcbe463882dbfad7e37bf269a10b6c96a211f670342670028105423d6f933420a4a34026fe0dbeb5592a38d45a93439ac2dfd05bc119e5b1abd5b87e60f92656d517bbb723d72f59e39392ec2eca35bab86593ec9141117e871fe35dc9be88b08880929cd3e3b1f643c707a3dc33c9469423ca72d4c066416e36bd3cf20970797651266fdc2cc4ac6aea251835979de972c8d5c5491514e5bc0b03c7d3d7bd9a1e958e9e5b47b28a3b013f355b629e32292d72a9cd0baf6293a70d8694f541d5b5888c3dca4f29226830f0e01b4dae06eb505bdc185a126adc0d8127efc48569a1a2e598b06aeb414f5e6c2253cf4980a72d117c12f00fe2679fea5de32f8d6a7201a300df3ac8fa2e7618fd06a2f220146fab5b4505ebc25723328922645def5d338831419bb340e73cc2cf7b3326d03db9669a965eb72d914f669ed929df0a92971675e769c3283496a21294393ab21683e60d32bf95fbf6701f96750073fba07afac02b071cff387979050f3f6dfa76cad721b06157bbcd8aa472fa0bbf93c6e8cca9d1155dd7e31805b6e97f48b29671e9199d4e236b408fd42a13a26112a7af57a0c239ac10d2d49077c0ce990eae515b6058db4dd753aa3eb1193ea91abe507bc469d3c0c7ff87de0028152fa0c3066a64ad1c5af8d771620f6483a6fe38a99e49a82e293cc7adbda3f7eb6c26241cd8a16fa478c44a6e0d3bb9356c8a2e1e6b11dc064119d8fab7338846163f19c49e9a99ab0f41e6648f3127a451677f09f97047d6618ecb8788536ff7ff8fbb1ab7886246bbf0b15a72365981b6ebdbaf67642854b2414c9f5781144b15e5ac89c19ddb8898c2c7763699510cbe12ffd01862687110ce1354349d29d71426f9961f20243063fe458e36b87fa64a59bbc68c9e49f00dde93ce666220e248156399aac38f8acb9f6d46ebf0a7448cc662c83e5c185ea4fa60e35d85dc2972c345e37cbdbc3dbccc986a36cb08e84bbcbc186385436f2bf0af80c369946cb67d2e4468c93accc8f2bb908a454d032c1ad12cda374be94a74417fe94da6511af22b5b4603de3bf6100b777334db57a19c90b4de3d6d8ab8fd87f76d9486611567dc751b2015839613f2c097e689143bfc3c930bae2d966918c3f17272e02bdf44886b4fa58c95772ff8eb2f41d31bd2f2150549333a8b5458e4792cc5782a3f1d3f57ed78e1d4ccda474991a77ad6d09333779e0047d9d40aebf3b62eb80bb37dc1834849bc66962516167c0bd221782c465e7f722f4367b6ceff5a8508477ae06e7c91774f90f4b4bb8465974f63f4adc1f10f41ad49d8be612411ca396c17dc13ffb11955b6a6bcf75f9ea97f055dd1e305ef3d1e7dc4211eb74c4b52a791ff654774d49017cef80849f197ee7d64f0edb7a5684168d90fd146d0bf0c1b6ea4b457001986febf75c4d974610aac486081c3d65aa73c89cb810fe154b87b3d41b535147d58e8c09775db55af75c8df34c0babfa48abe1a31d1e308a9fae65fce1cb1451d5f2a68b4506fc186524553d56a9b701e35d0c781f62b67460bf425e15739a03df041f85caecd2aa9dee35c3ea927850ba9cdb50a98d98d38b03b9a7a455f90065d3fab984514be8ca5e394cda98f5bd0b9388002849b1f82e4a4b0058b212a83a92310162df56724421dad93e190ed74d5bcb5f19caa799a3c9a7f307a9491b966e4a0bb2613278c1e1f5d62ca49edc3e66b5662f53791d8524aef112eda9e61b9f0277a80ef2493d965d1de522d147c2627fd7bed8127314c64770b8b7fe8a38bc2c9d8be15f7a00d288107b21ece8a34312cd3c3b015696c8f294235a0c4bb6b32ecf1c77520256dcf8ec56f4787f3741558a447ffa3553a727d77c39d32dc6fe86c0f90a53809532aafc6ab09c1796e674c8e0b17e6cc49e039e26df40deae302bcd7ef3498061f6c96d1eb63f08b8b8ca8eacd066d703ef78d9ea928b2a37060419bbf3e270ab5f287e1154964e790e52e1068ea7dd6e35f4dfeb6096201427d08b3b77e06e7aef0bea9f1f381e3a1f93c748b8d69b2bb8c13329090d1426000696d714e981ff0b54c8ea46d83f697c433c87926614342f82ef8c4655783f57115a340ba2829be82bf9cb9acf90a48f54ccd0ce773942a4fc91a1bd946a6cc99265b3eb240da9a959046697b2a05b6e0cc29b9f01486b2148bc71833523da97d29a6525346d9571c61f5248257535836c02046e07f27de4236feffe4f5bd176df866364b1e3a2e9e0cc723e1ddd857732b1a2e206f3ebed82a6d0c8296c221509e3af95c7b5a5394f51d51be137cbb4996a220e4162cffdfc0f778fe2680658b7e717cb7d5891617efbc8b80f81eccad02d29fb9e3b522bdc1fa0ee9620757d0b14a832b168c2b5b329d8ba24918be65df9f407bcc69d8289f0ba707c644afd9fe885e402d2119ee87e622524d24951ba192857e38aea11564379bae84146c2ed95d7e4d3f3faea495fd47b3a889554bb3571e4a86f59e464889396878f3b95ddca960ceec47619bf3ce58fcd369f5f284482d7f79ef11fec4194cdf6de4d7532a3e1e6523d38808f0b19d04ef807a3a112d5d8825ce4ffc767e63439934401ad413dc12383ed08b1193f91798f668c4ec3fd292f7f781ca3333b75a794a342aa73a683b93ef84c24d7782b283cfa09b49c6e30b7d7c992a1c88dade11e67bd528d13f1d819460375589e2291c6f7c87fc712ab978fe118f681a73cca6d4cb6d867ff6b218b99f5c75cc080f130706c90a7af015ae7d2eca9260b4464b71580f727bb4c4f27b60ad2b5785ceb2c7b85182e102d91dca0cae65847784048bfb415a808cc1fcd0aa04f41517816aa0743e03b59c25be2bcbbc624a68f847d878398d88ab6d15faee3a070b85fbc4bc642bf744e9426d7ff57fa8d870ce4494a8da87b7361b04f0f2bff9f4db26b0f54cc213326ee7cd47cd537216f2944a9c0d830cd914cbeaeee8f2129344fe5ea3c10fe9feb5c57f5409b2fe8bd513978c7683f3d3a35590b1c40b7441250e0f2142de695f41aaafd5316997c577dbfdcae0964c96ad9069cbac352642b4fc3fe4be59a1066ff6dd2e16bc04531d7c5e17b4623314ae27cdd7d4d9b97db52018744151aeadbcb399fa7a70d09e11fa0c0549700f7d7576710ac18477978dec5d0e038064f8ddba51102e3c31afa8820d471c83fde379ea4c773fe101915731b28b096e05052147d7af354cd39a3f2a515a8152b5d081c3700f96e5b3cb3c31176b54fdf140d10b37be2bf32d4caf956ca1ff962c74d70dec672b026832406728ff2cbecc993866df7725e7473048aba979633375f02b2cb3e451d7884863013140528445009eb0434cdf11f2b0029259bdfd7fa1a63ca46c21ca8db264db31e0f9ce03658d993c3242d54e6e2eedc2db2df934dbb772aa76222c42bd1dddb741896ad14543aabd2f3fd238e3a5c6cbc0ee63681da31fabebcb61f0b58578d29dca6ea942c41e8d535a1830eb1238973c80bea4f4dc2d36463e0ed32d97fb672a37dd6cd57c45785155c86d2451450663170f6ed785569642861cde0fb7236204f53d266640f36c10b1aa68b4a3922631001f4c3e1a0fe166dc3aa72853d0c844f7df1fea93bd51e5946c580d145b4da96d532c3c105c6188ef38aeeedec9154f53946716e456315f4fd2abc70bfc558f441191a3084f1b4b0e073d6d03973fa2d36fd91a2db60ce0216be12d4f8a98b3ff9c71a2b79eca5e7ff38cc5cca3ac79381651e65fd6b33da9082290a4d32f41f7eb0afccadd5b824d6fef24a97d04b7183ec14b1caa48759ca67a2c9685cf0b7ed78965aa05328b0bd99d9e120c066747136560f530d4d93145b5d4c67b93110d234493e96e96c69b9940031b684fe52642740d578914b4e252480d19c0a22439f6b6e2f10a1405e813bc847bb2fb7e0dc9096a0803a352f84b3874da1958c17af615e8c05fa07f9d87cd263c6cd9fcad98c490f3d8dc53bef0f5e45be31394ece802e2f90bc8e7c8a3418926ef7de2fe819b1a17563a7be9ce4380e760e6021f77ed72af2144f9994112aad447557a34bf60e1628911f5e400dc738e54b35b564e58fc38325fb4804bfc6692a02e0a12de57c9c140344d922fa6d80c42a90902c8ffcc7782471ff102ee1d39b1f30920f6fc7f23d3badcadd6101fb515b462809615f1da089fca4acc4a90d7588655cd7b7700a32b60e7f65ac27634de45eeeb021832c8668ef0589964c9c9e0fba9550703c6a9539e9a439b30483312e22cf179bc8e1feea439ac7e1fb172d67ebd5d7d019d4839b0f0f51d6c51b21b7f5bb297bb6b7d63a18625a38f4ea41fea40b435fc0582f3878888ea2e5cafca994e8b91b66346b31f3aaf19a557252a0c19098237263dec110981828e6d5f59c450b36f930b77d2276d4bb5964a20bc077151c62a9fff32fef84e61bb729338eaf2778d43230faca35746adba477d517d42757ec53000980224c234f12d7b03a596f8787c43c2cfe53d800478a1d9d0ba05752af69d14f76b55ddff6f4bb577a7b13899354b857eccdab341597ddd61a47cbf42652fee2f55e84b75505da0b3ff14eedb3e12ad5584e52517f3c9a528559b4d462883f3bcadaf8c66b0c522c415b3438a46d2bcb75836497319a72e679809d4ad6a4bb72af01f047f03e54684a84bd83aa5895d3a1071afec9b32549271b30dd7c541a82e07fa2193c7d60043086a6be7553c961852cee92914cef0743c9cf4fb12779d5721801ea31510c01c051d9732c47ddae8899b4262d452eb84688865dca43f1e3f392c3d0e98104ce04d0b4da6e9c90afec03969ab5ca72ca1b4c890db65a43b2d3c45c1b340e3bc814aa4acdd63a23511d71eefe58aafdfb22ec5cc36c19844183144a8bace191df98c040155337a778520dfcb50bec83b7c6885ee979ddffa47828288d414325a403ca44857fe2613b87505baea3df0f571b19ae6768ca483d62e7a155e0ae0139d68d8407f3cb0683c19af1b90aebc09c782721fe93c2d2b2554cab261713edc58be5c5d15fb68857a736fb91f37a374416118becdfeda356de73999e429d0d3c45943060414fcad88441dc7101d2db0b5fa94e3494478be9cef5d8a27c3f9baa31830293dd067ee2d6f17b63d16a539d2fc2bc0486c0fd4dbde1236dc0e7829bc0c98bce7124ad39dd4db0d60e9dc8c97d43e158aeeee76e1a208ea1da15133c9fa22980f76411185e5cdb2bec3beb2f801329f2865540a1d77daad3963d4a68efdefabfc79ecafe02c2b7b4c3b594c2b4dc8aac2766c475e4c0f0286e13e912f51a243913f8bf0a5fbf5cd0c8847b275cc119fbf6d8712cc21044b0957076392e9a8369cfa2ee0119f0862d0280b48483a5589652b880f8b8b508d8860ea41803deae613e7cf724da179feccc200e0731fb0f776d5cf6e79052059964bc02c62de0c717cadfbd5c35c0299d2e28539381669053fe0a47767a817acb9f9a8ba6daf4b4b18ca361d913723e63946fee7878f3f88bfd156a5618bc8795eac6d48d42f41ab59bfb396e457e6365d89d1a4178f16654ff9c3d42800a9597563dd210aeb34324877f8ce94672e31ac9d62026a851732387579a07d4fd7748bdf4e9150f1101bd004559b6dc9fe0555341cab4cf47757a8c5d3f1964ff9b29e62d435e2ebdd0131af09bc25f7dbda58326c6f4bb0e6d9753a900b6cf238ff50abcf7f22a58f7571635aa162681576586d79b6c7a3f590aeb03292a90c5b0460dd2f66e44218f2cec886daa359d3ccb91a3ed31546cfd8d71a59847439e4c7ade94f3e70080e0969cb258acc974789371a207b22a379b2fe56b77aa7cf34bebf89c1b016f254d89d10929a47491854cc379a0f8af51d89acd99a932be2a02c1cd109cecce1af595c8addc7aeb4b73bf563b949f54d9e5fb2bd3501b1c53c7d7a4b2731fd8711eeb4d3c4eb73ddfae0bf385b7b248febac42da390ba227d22c7a5f4630770bc1d5f604ca07a036c6dc20b6b309c64eedbf13a1962de45b72c525dacf231d58cea4068ae40200cb3b8bff6501efc663c712dfad80699bc38491bb89ac127ee81d85c17f46ebf265de6d005cf54b96bb53f6e217599b2b7b43487af6115bf4c7819c3beaac68000085fae20afef0da2cf6decbff8df9602235c72f280d12ab64457ed36872feb4ddf0eba6a24366be63ce16d5ef0fa2f83df01283676c5537574cfa259ba2ae593daa0ccc522f39b158af58a365fbdc8915254243a6069f92ae547855bb18bb0769d570e920578be39be584f45ce7d5732dfc1b1e6ad2ab53223a7bda7a06b1e38ed40b313a56a7e7b38f2e24b6973b4f4fdae18208878ad92278103200530b538576912bd83be092d6361bc03ec5e437d7a375657b52852ecb3be2853c57137bce01de42010f3ee4f1045788f27e33c7fa13d022e4d9a7d71828b25cd7ea56560dddfb4ce44659b72f871294459c2284477eba8cdee607806015ce2f640add5c9e5c0724ac3fcd6d1d0aa1e665860fc7fda29317ad01bb11c468cef0cf8ac203c9da53894a4e4706e97cc3fef299705a79dc4bfa22eedeec026d272237875901ba8bdd14a88e5ca2a46d248d7cfaacf76643280d41d555ff4c3f4df2b51259bda5212cfb016bacbc4cd6b716c5c4f7d658e09d6499181d613c275a2421449bc55d67a7b9729b6c73bb778fe4c9dbecdce058607866bfd7c1d75edc08c9618e29bf8acdcd6ff71fa11545e4704bcc69d1aa1aec4e79fefeb354fa337c86a1c49f9d965d9f6cc2df796840020bc045466776996e324ccbeda8c79879b0e1dd6242daf196d07a0e679b760d77959cfce07cb79f86f5c35d97d27af56f660aa6d788dcd6316c342a62b042dbc32fb26138ac278f46201b00d48766d64eb7d46effb98638efeaf02e7151984505a7add35fd78c4a8f65203abcde11313202120a8ea0087d7e108748c62c071cb949bc0704e1a976d7a46cffc533f5553800fbdbc6e2134e118e353b152459e7ebfc2a4b0036ea7ac065a42df55f28b0d74e99468aa62b6bef3bda4654f31fc0c06ba489f40d0d857029369bef26a9f99f22017a0164dc89f557742c5eb0b635341f002b9f84c95ef2629bdee48398d0595f06f2f8bb5e885341040c04bae0b433f1d7265485f2eb1b995a0d28e66f71984ba9a4115da8a99cabd3246b9cb5eb39f0f87493cb2c821f4740d699462ef1610794799623d234e95481f742068af312697663bee663ab04d9659f5953111cdaf3d20b83c0c67c3db544436a3547e924d4ebbb7eb166cf6fb5cde8ca18415f0425266e6ed05c260d99e9447e4abc3d2dda5b1268f2617b7aff0bfbe61dd9d4d0dbcd9b197d46d0c81548f4bc6113bbb4b278367ccde6704a50da3a3b1f3b2b05ace03a78afb0bfb7ead46933ac30ecd46dccd2208dfaea5da78fadf246fb3fe4f7f26e6cc10643fbefe80d9c4734f7e5be7c7e524f4fa1cec5202226d2da3eee92dd055cf134119fcf6745afac647365bb6351391bcca6c895bd5f3c708d225c64afd2ddca84c17b25ce926da55307f05414058aa28c5af80262e337c37c9871dc9aa82b518c93ade1d0342b8e10c87c1f2039d43feedd602b25a7e9f7f0f9ec4540aa1e29150abde5eca6174db6bda0b4bad7d5fc873732a91eb794f0a957827a362cee5b6aa8e65ac3c4f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
