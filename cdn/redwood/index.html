<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e805357a756aa9d50a4bc8430c7a0bd883e6a41ede7689dae1e5cba71e07a2abb4c7476504b24078831a9ccf6edfa2e10223d8186f9942607c976e0347e8f0381020def7cac61559a715abae90756a971509ec29ae3f0044e96134d9d984bbb7774f65cfb2584a498578647417dd408a2c6a2a5250685b1ef1f7e4086833ca2f372c18df7267ee536b984adb5955fe7ff135b5bb8009536835b4a9060bacd999dec73054f05294a6d2b1ea93ff84f1f5391db214b2da69969c5f1df3eddd1cfcbeb4efcea7cc3fab195dd11ba7f19cc4970e32fdf836a2f4040df4271bef54fb966cf74ba7fe6fd707dce18943f77463276a54b2e026d3186cbd2966eb13542abc3b0df4ebefdb2c2f9066878d013c1b8a628c2f8dc12abf01e4120a144b55d46ee14f50739ac9413eb372d543dfd72071ae5445df0d0ebdd5c83893aaa6c056a73b2cc805fb92576a1a178a7545827a5a8277be0cc542a296c54f588adfe32f7a9027dfa2aae2ed6069c678a9e5e3d4a51568a9a93896b2bbdbbde131402bdbc664ce01018f095e4eccde84c9b0bcbec40d66db1949ac2283c1e323a6f58f1dfb42e22cc16e0e8091b7cdd040428c3e6cd30e4fff7ae23b72031abcafd5c1b5ed10b87642906563d9d31f20e9328488c1212844584c3537f420087382ea4a02dc170de1273755f1a682a602f5fe321921e76ba2859e0a1a87a3240dd08cf2300392d02005a9a5718036a4a7e503c08617b06c0d2ce6c5a3e8cf4a5325245b0c8cf3815b62de438f7d869ebfbddb1e6c091e7052a87a0ecc7afd0f08147dc30a486c7dd35bb1221d3071fbbfbcfb5002444ba240aa4f235171899c9b628a9b229a1cae0200afd4adafce88f148854755f52e0a93b700c01b4dcff63befd311b581e5ee125d355dec749012f5c813a2974b7215aa719b5c3e9109ac3da0700205fb1951ed9d23d302119734c186ac5c29ccb67e1f1282e1620dfdc575c909fa96d3f36867b943a493a4059f9a3300c9cc53011f7a27449bceef7fce890ffb2032e2755c41f12cbd11822590d445eb61685b307a75552b2e2112ecd2b64442d78b1a77aba49d9bff807049ca251e3a8fd359cca83e99c20988cda7f138b6c542e738a54481d4aceaa5850331d602a78b45aebf7aae20c503996412fc660c2fe6b5490947667113cf2c56af8e4df9e209aa0809621d00980e7b25d14eb9b40efdca4a102a90c423c20c5634bd10df6f42a1628195f53ee524b9a9d5f1d8c4fc1941685eb01349e23b987bf576b7211083dbddc431b1e32890de4920877b25285b714f0a9f3a8dbeb67186eda46337212ce03ef3dd5b86ffd74c551bfc0255824149f7f051273eb48c7abad02655aa3e5c010f06053826eb9d38da0e81906656d8d02183cf29c917ddbdcea5b0895044783ffbb4edc85f7a2d5a8ebcf792fcfb37349751732724a668693e7de5ce48afca85a001650eddef55024f20f7870589abe6829ff5dffc56bdad56a08c1c41ff054c6ed7d930b1258284fc6f2cb9ee4fd1fa19a2078d5bea21b81b72eaf2bbed22eb60547a99da5327cdaf8fec17778d397c0041c9a424c26782be20ac0cdaee60091faf315de94a20034556d154d5b0df30740624b78cc6fde75db614d11f64866a0fb63651133244474e3bcc3d85b6debc6e32a78cf377cbc4b56eb6511b221f2678fddaac730b04ce63ded615773832f4272ec74025f79b84751431f737f76a3ffc4f806715e2baa5578edf752d66db535dedd85c1e8d1a52473d217b1cb764df4d131687916c24a4ee0bbaffaac79782e995387c1dba7b379be061f8367ba808d9a57c383676fb1056bc4ab364c68eb92ca97920d10ce9c2bfcf6c160821b6240a135343c20e00b2f5cfecc129382a6013782e9d74cbb69463dd266f6e870e3a9868976f229ae7fdf5c3e8ff60f2c568c170b5ae43e9ccefda5f1b351efb9a175efeca5e4f3058b1482b66258f017eb66e87b68343b3974c8053fc2efe1eb0a62cd3fcb6961c7410da0396ff05b21efcb0a07a252c31d432e05f9fe467eccea4605a64c0ab8762b64ef581d0b8af49ded71fa60514384c7ae404604a15b8edead0cf1bda3dcab56fe2389494159595bb266bd759fdbc41a79dca2179866da951d2fc5d46c612b12f1575f9095f8365f9c608dcde54457a5398bef92297dc778651cc94653498edaa6df12ee496beb5b01840f89f3fd57c81bd7dd549dec2691073d6323762a0e96b8ba60f88a1a545d6a9e053d1777fd10cbab709f741bca8eb0ef4d99116e6acae7fcdbb70fd252cce6fdb566deeb7becdab1adc49c29188c15992c23cbd85b413db956322ec1590c7ec14bd6ab22d627468d820f4409b06715882059ca5ec632412789a402d473cbd909cdf91278a3bb5e15e52ab82877bdc99c9f357a7973b8b855a995d628eae1ad842db23f7466316beabe72e26a495f06168604edc07f217507bc445a9c819de9da8adc95550d411b6d1b94a9f14a348ddcf9cf2e625a1fce256341f412b9bb7670f7bddd95eed8a441523a5554c7cc83f3b84c05d3977f108612da8d6729ae13909236f385d76e73cef102bf3080656fe066d66643e193bdb5b34d2c487ac9b2d23c9856e753c5ee62fccc5a3e0640c518c8ebcd5edd92d1be47bf8e45dee1778c615ba41e2c03ee61b2f6d58e26287f32d68208e455608d0149bbdb8b5f35a43de20ce82db7ac74bd1516f4e797c01d43fe6c0c44e24501f9384a1c1b85dd03484d88f36e510416fa9d4f93de45016acfe2830096001dd8039f66f6d1745da315ac6bf9759146907d567213bc0d0be51949b23eaa27161805cf5d7526b837b6da257ff34a954dd9811cdb9663d69031b129b0c353c98472d0389d64882c6cc166919bf3838ec6de20b5708510995a790e9e0881667f47d1a36f4cbd382f24408ba61a6b44159cfc4dc510fb18ad9374621873750641709bf2a9a7dae60ec4266400314134042af9fc4fbe45eb3525a85c2d557fb7e7d575a4dc2d5554001e3c71453a15e2a58b717a244fa4abf0886cb3e6abbf3afb51652c06b1a901b57a03007f147039be142c8a6b2cbee6eb62a600be26c5ce08db8a9a86c8ea72047d4757cef60855c70f35c39d707570340a0733ede46295801c1e5e1d45a55b2a70ef1f7f2171a680d3b6b6aa246ffb2bd6957f340ff66e4512c23222d59070f33611c6963fbced333bcc8d66fbfe6199a9f357e43551ba18b1bf14e3139e54a6d0437e414a142d0a47371fb210cb5d87569f1d092b7e45bbd2415bfcbe16c6f898bd8ae14492d21b2dbd8dc8273eaa0fd5023d6bab23986fcc68954b6f464f530bf2028876c94b81b3c416f90a17d851f6216f10c7e1f345745239229955caa9da064deb1e7d7e6a0b7cac41aede4508f3262e74493962201749fff009fa71f12da1464590c1d2eab26ae836115c48f7646b9b238ab56939a8bb44cd0dc09327549ae40256319ad9d48d142bcbbf202ff8622c687c4df99be9e3131b9030c5e61651ba77ab5cd0334a1c2cf578a15e6bb535d82b10e51b451bc0d845473692c893ead435a7270e8814c628536423d7beedeed6507a267c0a3f2af3f74da1ba4aaf26d2201d4b84f027547adb2fc0770fa2f507f880266e98b6d5db5dc756023517785bf528d1e34a51f3f818338dc7c79baabae8e450cc2251cdcdb41bee49b793560806eec9bd55bff15fe5a24754b3611d5f6a27aa0ecebfe0354739d7c4b908a9ed5699f21dea595db8aeeda15c9e669d1b12dbcaeaec77cc63a7e8b49d9e5584042560bb736b328ef2c4ccab572c2c3e1e1ca77cfa807c6fb91a020d2a8decc573c53477e6349789871a07a512c1ca19a3b1ae2df258b748e8e0cb295d2033acd6452e544a3c710464be233839d695a5b97c513437ef400abffcb1117c504bf9d629daaff4526b7e72233acd4a583dacafc1347187411b9fe6811ad8cff9053e009c012e8ee7b4ac4733ff6f24382d67c877410459d700c837b7397d7fd16b82f0b43c5d8a349fb0534587246a1253a880256bc50bf1c1201f97e02a24e7970d719ce0c0f907d940b0cd72bf9876caf0ce5d3a045f6ff19c9b8fcd98510d1fd6dac90a8319365ef022ec4fc5ddc8c57a946e999e989acc80a66460101a2b0bb91c2cbad5b64b96bfe74956aa86b4b79664a1e47301d132fbd957f8faea513ed6d49a5f611cefa27e98baa9e9a4fa30d270ac041fb142ab0a072084d5e3b83f5b5bd2ba49f0282c9afb536942dedfd6feb4884d514189c93f0195d0043945976c8a0c98c38e994ac76f71a3690e7bc426bedafa7f68c906e9044de093ec2f971c61044764276ec720f3c602a540cca377a7bd564ebe486f48eeba4c9ef296e0e9e3a2bb42c9d6a54bdecd9ad53de30071145e84b6ef25bf9740a8757b5cd4f150542818f6409d47c5bfcf5bfc9f0f3ea033707e02116dc26e32ad02d45450c3bf0520f2503cfd777f9da9b519634ca47f5093025837f21ebeadfab01e7c06a658786b5227d18f65f4a3c070509eed660e0c94a1eb24cd863bd737a905a6b1fd9afde942ad5851e120433dee9f59ebe703a8646cb62a1f4ed888db4ca0744fcd304c57010a7e877d294c7063bd2d2e829c97cbda2202f69da5e7a8ed7c8362bb9ffa8909e825fbd075d2358ac0b5d8adbeb3ef3036531a91a0828b12381a6530724a46aae839f0a3de21a06274cfa43dcbea656f5ee8acac9bace1a5c485d23ac98645f675889681fa023230ae11fcde40a7d137505fea0475d7260372922229ce47a2b916c64dc942f5dc71eedb7b1da3afcd21b0dd8f726151082ec8e17a82912e734167a7a5a8adb6d192c15befdb087ce3a9c6dd255435e16f3f3bb363ea6834e835bc375a4729dbc65ad53b439b3179a22fb0f698de9b8e431661a2f9a980348a9883c568cef7068d1d2341e8fb22abf952769fef97e41bd20a1a531e1e2e138f11cea9e464879e2a74f8bed0ad46f281201f62ade0878832a29b3f5b3852cc6433cb6e3022c43ee47b7c3449b749af7d68755fec5f56f23717ee34cbb7f43c8e9d02bf93958da9890fd93f4e52df13e2f4a8db9db065bd24dceeaa5be97ee80e37bf3a191602999dc9764d04c7e3af502583def0a7e8901ffacbbd1da37311227aeb4b5e88d10c4804a637baca8573524510b4a13dc9dda3a4c669f949688849288eda32db34350f3e43f4b0ab95930a5794341afa5224796a25172953538b1a78594cbc48450a208d1ab7818673b993a9f21a21d723195c8e4fe4bd22e8102d0f6e68b8c76a2a4f1984c2c31d2f8baec0798f5ccdc854068747050f691e298d0510177b8d95ced0f43002b6a2f8668be4ec9395c72c350120c1620ed1c9b46fef24b97a9905b7bda2900c4db2fc37a1c93af8286e74d856c3af593eba600f803d8eeeaa4670aea12e940cab87d17209bd4f0cabb6e8c75d2b5695f2a81c4d488a9e8e4cb50e1d42dc73247757cdf32b91d1e03a13446490d47aef85f863ea3ccfd73834aaabdc52e2ca87afa5da0d8da5ce05bbf88c9f77061c262fd941ee978208e00cd6fdc66601e67bbf4d0680bea8de987995f0a6ee20eaead170e8f647be482ea5640b86a02a5da444293084ffd1e16193845ae340cbf14ceda7c099ed3f2fb728ac640773970534e8ce4ee5533c41fab71113e59b093a5aad6e060b2de8c21b17ecd1007604266bec942d84a398bfe0e7767a88f3cfaa5a2144f8a76c0f419cfe7645a4e1d34ef10e484cb3a356ce6abc0b2d16352ecef3d7b20682c55c2b3b4e0a420c66519f30fad5fa9224bbad8bc79c81ae761b2831bb5e3993467158ece765b2ebb74bf25024639593087d9ec5ec3406325a70f37205cdc23d02b0a483e56deffd6bc91d50df47c50b932f21074749478e4a11012d6303a74c45e7730d14404d1ef96d96509524ea09492de83e5b74e117c06396c5769b56e42a685dfd0f09437cf6bf352200d37c2af12719ee1017385e069c6fcf854e0cec2032532cc8ccc2b4a06080abd2a2646fdda7e49d4625c2b69fe083661f0dbb3c60b2a582874e8d7ea2b21f61e71a8fc126c04b2b416a371fd8906f9eb3df383a6c06618ebff9797af931d0d72c311431df5ff4a75a8c4313649a5a64a8b20ea5754d79fbef30219df4e3dcc5084d0604b4d12d80e0f8cb60a31e312c6ab49075baa3244da7529fe787f4a7c480d970ed4fde481de975449324a08c64a334a6a86b4e54261d24d0b339571afb06ecf6779e98eab26caaab0b0e39f0ce00955975cf2e3247aa5b6173b2e6b927643f738d7ddb021fdb587dc4fd7d9cfb0748a2f9e6a009579ee0995467d8184a6860614e047eaa8f14d2a03b751cb5842e77db9c9b8bc70a8e134e1af23584de47aa030cef0766e67de1825186af189df7a5cc3e42ffe46143b780875ba6ffd682822a9da56828c4c53773bdef3fac1c249b796c9b14acc657bdd56e95c77c80d94bf8f077ec9dc3025dfee523acd58399682fe15e8f87d8d377f1bdfa699b8e45628f86c94086ce49a626217dfc1e7148c36c38993063dab368673356e12a35a8883753db1809ebc4fdfcdbf69cf50046cc5fa3cadfb4a56f018c84ff799b87bc9f721723bc4045777ab6bcb17a01f89020f2b5170eb25987fe3ca5b2f3001d06a7cf542d6c4900ff27b86b1491509956f24dd856491376cc077d6521018dd65ee0c595ca0dc298587655499b9e2345b5802531e34f6b737a8b38bd347b9c3b24247f1c61a260eb6b62d0b0057c46c8e7aabd330f860a3d0f66fd2e3be1f88e6430cf00bef22ff5a70cdf988b2e381c708f937a99d500ce767034ad353e18961af182fe7c4f37e038d60dc95f4d450f7d5690aa7bdedf3c01ec536aefbe5540a221f629a7cae90ff21ecfbe1d623b4c7a1b77ce0e3aa9d51b7e00d52dd39881f660cf0164a2f57bb46a7d2b43bfee8644e668ef9a4a4ed4f866dbee597b621fbe9040e0fe6044d1192abca203734547e45cf4ca115eff9189f20ccdf1ca5da8da6e479ceb1510f0724988275ca4ce3017cfc148bf7e457e473b1ac340826d85aafc184ff9651120e4cbd8c3f992832e33c30dbda02b19deb8adc3fc89d744db29015813f76216d8808a079b1f01c82d9a2689d3d076bc22f1365a45bee94b039f686bce52aed31eb9365faf8e326a3cc23c9cea0db31d64f85242115f1d40c6d38ff1da75e4369d8022e84eebc49986ade1154210b434afdb8f7758ffbe315327c9d9b879929fd7067853adaa3e6b790e7317683857bd2ecdb7c550a9164845434e72d09e1efba52f7289f8b1bd040c565353619b6ba31db3d288e28ad35552600991b99ddbc7732dbd59804e9f16999b9ea6eee1f41a32092059e826cf2f357bc5f045ced4d44beea9b8856f7102fa2d3faac308d0c2be6afe89e22363bcecacb46c2608cbd8978feb070cba6ed47db92fdd7f7ce7f1a70b09d0bb453560cef4cca96eba389f79bb41bfba98d2b6b48f4cb62a6128be5572a2554c8c1a276d47b3f88128a66ce5ba7b0763e396a138df7ff39503a99ba7968136313a71a379557aa4781f7e3ea42fc56f354b50e7166a7ea054b4f755f2b7b88b606ca6657f53f3e7a744eb3732505aee1f261ab584145ab79d0b8e471b020ee57a882aa1823304acc90a2e6a317a63bc2f75b241440b97f0fdbbd87e1f288dab6fe1bfc8563d6dfa476ca310303a8c9b69ff93612f95ac9b22779b561f8efbf3b3174d70f7fef70ec5db3b862f5841b4d84d9fb42c1ec25e1e4fb4711248d80b9c5a3726bd250f3bbba0b9368f3112a08af8804abcb316057b65135421d9ce08737b964d483b47768bda193d20fcc623a162fc8ebfc586d6d27b7dbdd89ab7110581c65f80c6d0ef3f01aaebd472a980f4b2e16e1c18be797131cad51396daaa3eee8bc9efc8b3d0cac9c8b5c2c66f39bb27382dccc552cb7cef82e4af43ee222d112c07b01427356025fcbb01d55e1f7408bae1a7d268c267951336fd16727598a13b38c79455ca97241707de54f3f147d65bdedf3b5aab0ad8eade0fe813f413605a7a584cb35db4b6c2cf1be925b116fbfd41adde7e34193a856c78c68162ba00d55d89e158fc189cdfe56ce9f55b86f452457b50b19e732f45a30d5ad4cb615593e138cee9a4c7cc7953968abeec3719349a60c7d54e7fa762d51c0cba81e39b971e1b52ce449eac5db8c66feb192666dc758e464c80c35d934fea3c247f971638f7d3e50aec8ce9920710f40e434e9b0f80fe4977dcc321270844ecf078ecd5f360e5500d83ae1fd0c520c5d34d1fe539362845e9c93dcde8bc7fc6065a878f5da9d8b50e3e602121867d9c58b626f224e6f5f00f2165984140e5c942efd871fb1c1f11e7716af105f7680e11fa28c6b56d0df098047ac2b842a12d4f8cb9968956f180cc90637b6b887433cfa54a3122a6a15565f9aa74bf229cf0ed7ce83fb72157a7cf3bfb1d0118c43cc9db291ef028b8b1aa97578589d00a49996b40cdb35f9d4ddab9b81194edb80ce2fb16ca6ed7e2a137d0f7f95eb6b26cf1b48c2222713c88abcd978a635fa6d0ebe53736a2d865fcd0ba9c6bae7e850f31b286f3b4ae7947f7d4171ea637710dcae4cab246cb5606612bfb2e3eba3f4dae26b832709ec57ccc83099be5b27d5c21abd7a632d4fbf91091c60654ff0f2d4f705439b895f6c889b3e814a3887ef214bbd51a0bc737865ec05f680bb31d9b4bab410b65a4db08cd96752771b71234a8051ff09ebd489affc2cfb2939f64aa84a241e5d233b3edc5bc7be155cdb60d17e0d015910a68bd884d4e7e59372ab2d81b48fb8730cade9eab5b506a1b5d7b8fe670f8c7d71b98d5ba2098429ece332773a3a56cfbbe1cd565157b1f4b07fb544a3819e8941879ceb8ad9ce16441558e25409befabc0bc679faf8552c3f0e6d6553d90e883856d0e139f15b8fa24603c06e6a957f07e48bfb7d8085cb4b9c50315d8d2471ccce7c0ea3c6e95f873f4aee903ab2ae49c4ec8f8048f562e93c0d3849f3198b529fe6463fa00dbe7b8cc4907bd968fd94214c5d703a01be3fc0f16c96fb31b1db50ba1c1bd7b648427d7527e241f88428c90bbb41a82aed4d9d07b2a3277618345d6b0c516ec6c5fae460a9d7470acb1d733739e72d566ae03680bca2bf62287c4d234c354414d40eab25645873829f2d640d8c7e8860ca126c968b8a2ae524c3bcea79f3063ded0669f62105339516cdb2cbf5a9f84ea7d3d42b894e6213c33b2518b30c0a23c81d4a6d389103663db7422cbac80fea91ad4141d8fb5cc3064cbf5577e27345ddaaa3a2292cd1b2b5c5cd7ee69f08522399fa56e4224777b150206cc47749d9cecc22ba56a303d69df140921751ff4a8ec151936d84e2143a8cbba5e9a8cad1974b668aecf97e4f652f2f39778be3ed63612bd38613f34811693fe21bc9fba2bec3df47b840640cf17ddd45c42b5c1b53d628f82e4c83d9e2204700f98e085e182e2c41d849fcc7782bd27c1b74647ef4767ddb627dd27e61e9ceb45f8c04e0ae98b97c576879fafb4c290b89601162ee3c6b56fa0db2bda1389a9d493e42e16bec9a0046d4df3ca35ada64754aee19523b59132bf46c17a8ed5c1fd9dba93308373add73a0d8950c0df41840c56ab1452beee9723f0696d2ddf5fe442eff0dbb9cb1ea11445797155867d9802c10613b27f8764dd3afbfeb582af18071966730f36e1e4297de7dc965309014c06e90c6e72d9ed2a706522b696183df59a43551ee2c4f3b762b08326f27cfc493c93a4f3879025ff9e210a6d00f4411220a8a68a1ffbba5c27a39dade4bbf8cfa1111c9dd222662568b9c3361bf8ef62aacf32715ae2dd6e585d22d21ca2bedd86080a97d8c7ed4b6a524b7f1d315383275ec7501407fef52b57cff4704b717585c4218118fde350bdeb37697cf90cfb5193f00e554fa15d3f75159d771d130040f0b49a3aed09fdb131b424ff7f9158733ce44b07466c32b1a7bc4f9204eb91c9eb055ebdc50c2f191111c7c8e2847811636bc9c55d0876eb63b9c0a8fdf6bc3219ecc8a536a083031a432c51d4a05f402706f3c6e7e2f7f54ebb896645d7146fa93aea75dcb7af6e9c16ada8d256070c007e1a5bea96fa275fba929aa2e407c68e6509c9a46aa99050bfda5c4fb6cad944487af858e33fc8cdee9220b9d354a22ea6f1c4974a18276f223fd8e5b7a8d3e19223542f8f1fbc14adb0a8a303e982544d77298e1d4e2df982a5f2cbbd314829ee72779e65f505110d39b2b4b18ad497c08ff4386af5904b3eee1bb5766c1ceac579518879be716512f3e319df0a1363f189c28e5411bc74a56702e208ca53fd64fe79bda653fe344d2b67e873ab5c3d18b48ff9d5094245ea20276fc6eace8e729a3d7b572175ed34d201cfc9b9a1140ca96f7627d97c2e34d268ba42d623c09af2a020e1e236e6782cac33c422a90999961004a2dabbb112fb61352ad7807f4847e14af15d105778e99b6b53c14b2b4c93dc62f777b1635e94b8fcbfa42efdb24c5879ef472672218c1854835d488d0f62bead092ab0ca3d0676fce85d21be0dfa67b1bcb8f7775e5793d7cc63f040eca510a4fb479bb060eccc15cae6995b4396aaa9e7b86cfa257b9a8b11272f537680b811e66fe8c053515445be6206ca51d80d6f843486018e9d1715b1bbfbac8f2c472137e0bd7f2b7f19150045c82c99d2ce552f46be494073f4d7959c8b7366d56044388d6ca348f78ebddcc6692e0902525fe8d1bc28dbc6ebbc174c5cbfe473da0c3aef7a241dd9474d4935b5985773753a8e21a2088ec6cd6e5f59238e7c3c6cde3580ede74cd37e8feac7c04b3808b6253b86ddd2f06b9033374c5338557896c1ea9a129aa761e61c078743e12bbdec167a9fe2c355077cf5e2dd21f6a649d8bd34a469aac5d1e768e15ac41528453d39f90e8f566571e26429840d084c3d74de292729a4f24abf58d333eff8e53713381a113bf1f33dbeda235b3e1744e81c6c87f385bfeeeccd41fe15375223fe4920a793c1967c01217e09f19db3b8e39770568f935fec249131a8a14d3b8b7345685c9a816fa208909bbab6d01ebd403e0dd36c630893c973606d9e433a50f23711f9e1dcc5c9871c0001ebc84675491af664ce1ba5de37ee3c5bfd3a9183c994bf58c1f057ce7d0e9dd8d29c4023656cc2fa7bbe8989f4a20f98b1398b73e1e8cd89a2bb3147710ad59a964b22065e5af8010113dbcc623b8abdbcafd134d9d7ab5f8a53075314c233ae4c0c312b492eb64ebe86c1104bf07c5e349e500e331686bf751360c5b3b4ed914064af167a2bb4e2344d5fe87e9dfdd487b6e94960aea4e762ae7a635b7a83029e4821cc880132f3adcd9f9e174758836e8e7ac417195c169320588967b6f80098bebeda5b4de8d73620c580ac38efdefda189d0af8b94ce1a3a1edb163c93cdbb3d609d8b5708d6b95a08de27faa3f0760e596d81fd9417e06fa9cc48e9781d85d9c560ee42d0965150402c9d3c4eb035608ddb6cb0c9ae8a07ed065e8a2833b995f42fa0a6c3e216ff4078921fd05af04060854cc4cbf62baee52263ed388158d2b6fe0675356a0ff45192ff112cb24bf5f6bd088bb48c9e206ee147e6e53b31ad3460f02cdbc3dca18faec3fd8dbc49e6fc1cbc261a5233e6ae0f4c878417879c091404103fe3bf79a2fcf81d02188b74aae6df88f3d03069f8d85d106be3162ecf58fe47f0f3af15589401507b50e66d3765fb0027060965459f47b20f6c14e6c4ab96cbb3b726a3a8594e375504e1928bc1518fd674924551f1b3743964c3d66615e01c2a994f86cc2bae80f285d3891a033660bfe379e27cc7fc54779a5010e3bfebf43daec1c019b961ee43718522e4cd2e23f06e28e8335e86c820ccdbc697d3e90b52fa4ddaa74ea23a1e5c613db14bfbab5da8c65fe0344902580348e23deb07f7fe0d99b00ba7bc7210451924533c3b7cb0efbe387aa794bef6c3b30f500a7ee124055b1ba73fa8b962fdfffda4e10a3d8f12a5c4e9ab0767fab78a75349c50721f5cbdf64ea4d90a359e5b431807aca7fb910bb11e064c53353827fb8aec6043b12b252d7745c8cd2fae012055e45af3365c345e204d23bed4cd688feb96248cdacc16c99973b2a4aa4dc8a5f5ab47d68280284acaa69455e87fb345e55e52ee8312d07a1b37aea5721c2361aeb30c51c540fc2f061c556de0ee7bef10f0ceb5e796a8dd6f97b346fa601e56b91f978354476f95d8f72ba25744ecf57d8888fbac144608455e0b77271f175655c8b81ccc2100af7466ae64d3c7cca3f36b5fc82f60235e2ef6692918177660753caf082d30428558e9b65f3bd9604e3211785f19ee357b6fb7d1fe99880942cb8a1eac24698c379d452779c91e01856698014adb6be051878b420302b61cbd8c876050936b050eeae7274443407b0278fc6dc1ff1e687e3dd190cfcf515c3c8b732c406dd7883a478d6a5f6ce4eed5727affadcdefbd5cdbbbc4c98dcc081d4fc72810e58c00f705e3e5021e5a16ffa6c5c261ec1c553fe4ae1f4df11dc91325f070a5e25a14a1ce20fff022972e78b479ddef2b612973cf2c2a2d3e7cc36012d7a5c6cb57d9586ba7bc68e48a274a4253e3a600edd86fab3d4b05f3e9fd744d656eea21cd35bffc15698f6b5f4f134974e9a278f55f5242b567ce0526ee65063ed25fdf0c65cfd3f90a59d6c19aa72e9da4f0120616e19cffe3277b31430c98b22ad1d29825cf7cc9e1dd4e99c91d66c94b61fee43e0b853c723cef8048527ff1cd715f07bc3e76340e0aca7dedb76160510ea7395b0a897bfc580e0a2cbc08daa925c124ffb570691ab84ef0b7277f926eb844c6ff3c13cc3111b01ddbe3454b528d5215c105393b5cc816b98a03a99275bce86ac96c2f933fca781211ac4ef2863525f561963fd148ec72586f0d082da39b5751206c8b661fe401384aced16beef76761594dd53eb278a17e4b8f23bbf66fa55c018fdfcf1d564627210b8ea884a52f412547dc281726e30fb2ad505cc3336b1742096d3fed19e5fab55f6902149539e4b0b0e2947f8a3c8359c35c5c45d979162fa12cb191f4e8676c6f737edccb0f73f8899622df2c37563cd8f1c32aeaae17c28991b0a3cb2a00d0fcbd59e44f7cd48a9e4c328e68d4ed896188496e2a5e0ed1daa46d5f096736a75edf78e28d646a79132b2157fa15fdb0f9eb397c2c590b467067928dcc8aa8a955f1297853a4114bfe77e1d933e7c2592e2c7a72f2deae7565a27f5d093235637d69ddd0417c6476e9549d9cc5293080b889092302989d3b05150de67fb7f9c48fdb6ad424e5176c9e167a4fd150ae1ebf9a288b2883a122ec746be6344e5af9ff64a66bd38a0b6d4c04bfa06530a1ac712c7805806b4841f5b38b09c571e340f5e15c0e1aae1f876766208edcf480b84185a4d0bd0340f18651311050a421431df45d5daf5382909d36dbe7eae2fb52514e7fdb1ef600c0fb0a55ab68a535f306837ea43c3384e4a02d78d7598f72f0ea4af3249eaf7825a63e7c8e47cf34819416ef2cc88d926f1917026ca870170626f9d4cc39ad24dd4fe3d6f8dcfa4c2b508340f2895bf777e590bc1001fdf4a9206374f975f19d53a0f9efd4f4f299ec75be5f011dc21333e0bdee1c3c2b0b29cfe3e58ec6d30fa834423fc62e9d7375c1e31f10365644f69a5bb258797368fac14359c8b1773477c6b5f909f8df22d1568841b2f206f42ba6e399d8d45f4684e1b429f8bd68158c16d069bf770be53d5f63b41bf1903fc77db1e69639f8dbcd3e717d28660093186a1b0914d53e32e0b44e1882c144d496f82ae09519cdce1214fb06db3df9bba869602165e10cd6f96163268798532d407acc9a15a5d4c656044172de9cfaeadd73519f7f8de7d2ea803c2dc59217b20943b1ade51f203aeec9553ed6789004e12b857e952ad1a20fd5108902f907d411c7c89a99fa79f0b59fa3db712f25864dbdb74b4d4b125d0c9e664378a943e5184a25313fa7e11e1d02eeb36731ec507fb56c068ff557e43fc21444794d041a5ff994db674184b86cc42ed4d1d47da81753287a631ba0d197a3fec7a69647e9fa191cc7fe87bc67d55bc87fd0dbf0366920dc0024fc2d555df1b5de20e09cd1a60864481f7c79a3400adb926aa4b14b157b527fb118206fd48b19f3357246c3ff3a29d177307563b68933e3c557777c8e2d39e31236b5adc2230196e0ba1ae084f18ee713fda713602e48141759ac312801c1f242c227543dbfd45afdc2c7ce75a497966601cf638065899bc8d0e6bcc75ed32fa24afb730cb19a9e9af35e60dee5d775285f2c099d183a0992d545f27af98c188d76c117f27bd61319db45942d19f52d36292cbb1f125a4b1b9a447bacf5e5493f05c06016d1f7e075d8c876a5375125fca57ef0641899a6c74d92dc63584f7b036adce34fe59f692003a78a67246e396c3488cbef6ebe1127b67b93081925bbdbce13eceacc2d03c7d325c8f61f65ff5149e6754cd7469017cb8dbe65e4590266f03d41c8ba97700b9aa4909ecbe812d3181164f43bb90448ea6bf8339d6810e6d45c5fa23f5ac89c8df08f55a5af6b0a8b798d79b6788fe506c8242f5bcc7939b5500297fc4e3b8a99a8fa7359912d1f1260633fed13c139fb90a857c87e84c5888a83405e1f2d9ba64198bc67616a3ff358a52ffe017dfb1757ba6227376bcac78369210e1958969b84f95ce088456987ae2a0689334daf838bbcb7fa4984f509deb87b3b57f66fed59f6255ef479010b372b68e531eb19a0befcbd1d7591fa30868865acae6e2bc30983b752e83ab23387edf2b998568a6ef3de80d1de29a034d909808a15b4bbdefa7564da16ab0959422f5af3696dfed31db088df61349366ff256996268dbdf18711fc0760e238f14deaf5f473e0342bae1bf076247a67322ac2becf277cdca6b948abbee487bfe2a8171f77fb071f9ae1d7f1ce1eca069d0d72fc032a6c465760bd6ad164d556c6038f5fb217db1f2badf9706fab9261c7dc58e8212205bd3c66daa1a3eeb45d5f57f9c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
