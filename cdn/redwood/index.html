<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d35f086e2286839f52d2b0d0e964b02d3c7cf87529ca6a149733644dd5cd4151e95088c19119835d2daefe750d80e63637ccb43ded7df534bfd59bf6330adde1653f742b3e1688dd48ccb349f1ddd7e6e2e56266ea28e54ab64d210c911e91d214f1667dc5f340292b22407441b69c1b6d0e429f6a3e5a25349d39e8c5cc94c54e30e890915238c5f36ba95b6476de1bd1ef6b44b92354c6beab4fbd618169235578942b1231b4b701752edf866230585ddeb2950ddb950f1273579b69d428fc77d772c6fa981e619490c86b69a3c33d15c93578661feb71c33e60c5cd5e205144e2e655acd6eca596565c52e63bb35736433a2e50fd5a4a250d782b53ccb2045de3f3b65d7e12ab5af71f611a920936db39e5f0d9ba570e1452cb03c306be51f58bda23ccd2d13be2d03971959cecb2972f8ad9a598112bd05af65338b6895aa459498074ba4f6fc84c8b9f0afaba51b62c5d250d868839fd02b93d16917051a7b67d49387ab16223dc9f241d2ed16a6c54af1fca8548b54ac6a7736e3fc2d02a58f20ec31f7bba5a6a9536b8ed7c96f845884d1494402f27417386ccb2f909c6a846f76e720107116739f9d360601e274b70bea7961d407be069bbd66cf5c2d9108fdb371a340290a6ac0d2e38d2d013d4fa59745706405af01006153bef19f897fa85a021fcc3ba7e5bfd8e94472bbca874aa713feb0839825ae8515d6d396155db877f04d14830f009f5278a1a65e20616d3010cf0726717f325e42939d4862ae50e15900abe743576e12188d861bea38d853b693fbb6b472db2038b08c5a9008145fa65fa887e2c6d93d6f4c534a7db795448ae1236c2db6c93b05cd29f49f377d8eaa4895c48374cfab50ddeb61b002dcfe0a2c37183185a3c2f04c2b0dbc1434f0ab4fcbd59d63453d0d771c46972fee6eb38f6ffc39dfd87bbcac5ec8c914189d4991f3de2a09aa2b5ae233bcfc34fb91d9a5e1d9c8244c035f34188ea93a85af5bfa3a4e1c72ca6d4112a1b5eeb71267f9688396b1817f8d12cb8e1c7896dcbf2787db5a26bb5b93f5d650f58b75dc3747a8c3d0302871a517ca6fcd4bccafdf8ad1796f033e17f96284e787f0d4c6ab5114bbe0eb24da6ef650e275e063de4bc20ab43729c53d5960605804300348134a4994bbc1bf627e4e805d2014d7ca2da80e73c041907874daf7f06a59bf76134d84fe832bd3b0e5e583ff6c4f73d573c3e15c1c922f5241ae41cba55e590f36c7b322246e26350e9a2a91f3751b00c9c908d240622e3352b0aee2b4178a65ee419251bcf6995d395dfcb9fe8aee54a7910cfe397c12848ab57b1c6c46f19f7827975803013a731369db3b72d95094ed8fa279c3b2a0222016e557ad0d1719005191ad3480c7bfd1bb0714e9fd4813cd4ddf27fbfdcdcde3a0b5b812ae086a3df07f13612ae7fb00313c747752520c13da8dbb0cdea90bf38902d77f6e0ff6da1bf9cdaf54fd9af51ff3bf15ff7bd4cf2922fb697b7542b1c66fd4540d26a129fc3a758ad748cc1d2a6d4e62ddf3e90029d941e8aaa4430af424c172622884b5cf26effb0c496013d9ac3bf03862370319495c85150afbc5a22cbbdd1baf0986bfc7e624507e6371065223727bc2794dce38e0fa7f5e03ffdf964182dbed945a7b79a21b3bebfa5488c426a2843577f83a7b15ce236e16871e4ae358fc412ff050cd85cf17e26427ce987647323d4200d565466e02922ad13abf02de5833c515e775608a6faba92ad4bec03ce0f578f8e51a7a46844c855158a3e53cfc5ed0fe9988ec5a32eb439c897e26ade515412e2efedbb59fdb7946ff8ac0f3bda368c891be30ea19495fb3fe326ae083ea8e08b6ed8139cf95c202715860909eea2e5281f92e24c5ac4db1fb69b064d91e5fa9949b7d6fef4a920a3c28b4ccdcc24039492171999b336279ff241d3e724b527b19eecff1dcaf162cabbbecb0ddb8de6d3e561c5ef74857d629b74201d823c099416199dbf3895b53b97912e4ff2bc76229b7d9655cae26a9dc6fe760175d6b2795872343cd0dae5f9c790244f37f931f7f02299a3a50e265fd3d99d09fc4240dd5a5f83eb0387f431eb246baceb3202c1f5000288253ba48dc15743415cf5e72134ed95c80586374a398294fc56a04646b0b9c6d962786ddee17e08583f11dcd8a8ea4a3bc1a78c11401bb960456f98c81b0c9aecee6ee37c77cf42416ef48b1a27bc3b0a9a4d626e2d66e82156c1c076186c18042d6916235f9eb03e57f7b1e8ab77abc91e0e5358868df16725bb0410d816e9e0f9f0141839ef091724da7a4d9b4c5248395df70f821cf0f2b5fea297ae661868e4aa90f2cea70d63ab7eb0e204b0d44df560e2be90c3b990fc422b0d7e43f096a7c1a8095c145deb527eb22d0b7b8cff2a83508c0d85cb8bd3c00e6b87a68cfd1b4da517cb96d452a6f041ce9e98063c12dc17d54d7695e4b9e29f038a2fe35e12084e5037ed47bb324f188a63d9a2046d2e0ede28ace50d6f44f2130fe0ad0ddcb62f194d53f6d448916f69feef583f7ec5e5492e39051ae1ab391122bc8fee2401fd2e5fe528fab4ccdb35527451f91042aac44ca74f6ac5850ae0ea0d505b77323371595e93cb82d4e80a219113b9a501f4814d976a038238304f6bc09dadd5c773677b49a42611010af3fe4c32aba1a9a2e605492d2132e7288f47d52510ebbbc349f0eddd95121ee76a6aab134ff1d00f92902416a16a5fd7e9b0077e3b82ee2adc2090ad1578d6a6112204c9195f515774b652d3a9771b33eff41b99051180b42357898690601eda03676031ae7b50e5fa035136f5de4da7fb65ca39381a0a5d5585adf10c04800f142c5c6a16f4399e022d8a084804522174f677ece60ce00b5981922f62f9ef45236110cdf7c4ef61d23cee8e0460b34c7d2571388c831a1a33c4888a40362714cab572000b2d9c629edc8cf1e19d62fb30a16724efedca4786c2af6f216309957ce3da74849820d6305020c8362b38a588ca31999fe52256dd36cb95ca79c02ea31d5d2269e59324781454462f732f8060ee09482682c252578b124c63bed0a9fc8d5f4b592319942607793e9a20415e639ca6181b05323b3743b4718127bb9ac2229d2a9702e482256431c6f3c6032d6f102fa9e4c50e48934b0b356e3beed891df10942cafc5efb49fd66010a668fc2bd5c2b265d534417ec02ab46fdd33d954f6771737cc0e57d4382e614d97b2e332366a5f695a0834fcd96a64ed2163fb864e57e4f260a38c8f87196e2bdabd6f16d660c9d311d661d8419d7f21d56cb5dbd371e076fa063672bde5a524b3a5a137d1565fa8bd52dd4e9b160c97773e4cc64a4d0cec67eb88bd190c75c5f912af8d2fda8d63d99bc6f17fc1139256bc8c23842976dc02cdcca036ccbc9d3de560ec91484e11a9b98aa840a415a17ec098be8e09a57d0a3aae9e100203482836a54e14bdec5bd80696c20e7b33877243088cb2616241ae570ab99c543155d678656f4d40625d1ba65dd5d7e359d4045228b114481d9f2a65134ad774001f249f04045380512815a8635381fa95766ea427f767443eabfa2fe65529c1d63940aaf06b4754b92db3d433f28e589e9b6ea9703e2adda7af925941614a22aaee58a6591993b9a20b059925cc9de2961db809ca3e41dc1d7b19759805c0fbb704b82c6e2eede738bb63264e6ab63234d7f853e32292a96658674d2ebbe014dd6ace880422b37c962183ca77a6310e4d4bbb470ed282eef17e494bff9d4fa050224e54ba39d4ef5fbdee61f4152d39bc8ab57e0d9d294c09edf58d9abcf94ce7648dca9e573ed3039c8438fa618197555f78b0273b4fe94f371e6abf845ac3241c8ea471f9d4e91e527ea4941a76312af75891c6f810e28bb2d09c9b0f7cdce3b59bdd4bb1bfc51df9bc376d598e8efa8787a866f0561b39ca55f0c2687dfd0ae2823f096ddb96d9d1daac9e154d097369d444fb884b4af4b4498979d954beaaa327e0fffaf26db0757083e794bf56dd27de49fa4451215cb34b7f793d27914b83184e4aed4bd5b0d908a8cb7485e4be68e7467f6eaa1d6eefd7e83bcdd35521763b55e2e9222420a89fa429f53ae089df66627afc27ce5326ae2e2b919a1f4afe33a3767ff69564d94e40d7141da625199f4c98f647820cb9ff79d3b9bc921fc96ea6f392b5c191daf24e292e9cf50f3cd8e24f6dcae0dacf252600c42d66a3b5a7dfe73b276726c0f938bdf848a91878b2fa66af38be59988976c3170b4a0a1e89240a0a031ed55558b7a705bbefab411e4132d04e73a1c89d7200770dc01eaf2f889e0c37a8e27cf532becd3f6c7f381502650bf7931835480ba1579a07b6c2f60a0b6bc19eee0c4b311a45a7e602979f689a309783ea8fdd308fdfeaa2b2d62d32e70cfef0a624ce157a5d60ff8b8d8ff71f36004c6dd8ece74e3e9acf614cd85f185fbbb399a916d74d80e19f7ecba5a7c9206258c83f0676f23715e3572b6b70f0f731072daea2e8a7223e7430288a8124ca7cf1d74eaa56869f50469ba36d65c999742bb935e90b159ea02f97506a6adccb2757578b33605102fe154513766f8bece094ef61fad27562184b8a6071a7c62aa0491c44f110abb2da6ecc214f296009bc00ea057a7e23fe837c08cc001219d6f47caa1f53056340f3c05c0b9c30d6487e29bb2cba2c54e4669bade27d2a8801edbb8411e202a6d7cd31e69b003a80167346ef187eb4be514c2d53af992316582c079403ef5b99037eeaf5659f10a34a435e0a4cb4621e60e9f96fb855ca773a656e103855c4780ad6dff060ac641d666c49caad378c73db6b891710c8d283481dd0e39db67dcc37df9badd0918113d6582369409a14d3329247901a3d68847fe6735581786cc6de8ab5fd244e8645be64180484ec2aaf2f9a2d7f8de31d8ce43d383252ecc0326bc8174fc41dd8c88b4a154a30567082170c176be6b4ae9aded4db5bf8021108ba84e5149013c6b1c3c7630952673a47ac1b8b617bb9fa3e838cb925cbe20846b66a281b86a03e79b06b53c36e92b8a0a4cab82ba54e3bfba758e7a48765c11def190f921c76f03da008fb9cb915ffa923530de57efb05c1d62ffae680268f941b3e230610ab9b55175c0b7ad1b560fbefd49afc9e50b4a22cf9d5cb4d89b25e5964d410696651ff65ba8d6a81b16bf555ea79189c24153046bd22bbfca2aa7f5cb00527f89280cb627bba9b86241bff5ed66c8a296f0a676f259b3f33159998905c76735fb37e04fbf993a1108063015415715c96a31c9e3fb0b9f77729b57ff47f8f360dea7cdb366cbe376b7f7f3c649b852de78d8972b4cea894afd4f9a7d06fa54dca740bbd6286ece6755565c54703fe10674f6845c0682d39f782c747a04ff8da10b8a0944f87bf0190677cdc8e9a482d29b32326cfd702af7f50e71756975381e0231df5415ffbd940ca354b087d141468218cf201b584d819323319c00038e1ec97dc83fe1cc4b75d293960a32a4dfd656af68b6bbbb8407a8e4749898c5d1106eb74719bce0658c064270abb15786a093dc08aeacecfcd4d137c9eb0613c1b191b0d61e543e64078d757253f77ed346c3764cef38ea2c9ca85bb4ecaeac0c8984663a2c1bc63c9f823d4b29167d749ab166c8b87ff0855c936e248a2da42ce711dd0eacbf2a0ee3688108c4d0290597dc99c6c29fb20b1b22bec65b646ab3b5a6441031cd84a242a78c007630db90eba15837824b6e6a0f5b6219e524ef0213446f262203e119b48840b2324bbd830e5ab39cb811f3fc70296f174857d3a14d5675b6a80db0322916b5e8fb15507a61b95a7ee9cf55f617e53570d6099d81472c3dc90ca0f2a8abbc417e79510025b898299f19c96eda0abb50e8f165e13382fd28d98d8255af54ac4029e4126ed82e76076c81fe40fd1129c89e375b52ee2431d2b7a55a636ad40796a4c7e061d572805dd335bcc9781550855b184bf14447cf47ee512b52b3d7e120253e8cd5b77e9bc98af6c2d7b49b192688e1132101192c349c321eba12d41f46e20b9e48f8a0f8db2b90aa801b3be0690fb0565218ce6c00c9d9cf02d9304b1b2e0db9375511bf313f2fb795016aa45b0e89564cb8502496ed985f50e38e08622798c642c3d4faeff8d5c69aa45596e49e3acd28e9ea057ac03338ada575021d6c81ece9125de6cb02e05f1945b613bb7386e7e2a0f4d00be0c27bdb25bc981ef2ead7c0fbf5a8f057d0d01ab2ba488c9ce00c3507b04c87f8eacd37515aae70eca6ad6c89e1907a051e39a1039373f80190866573b2cd2cf2a7b5045e5afa1dad350a5f04cd2cfb9ede054bffce31f67c9acfa41cd07b362b29c017d1d2e7a8940165195397fc732cd45bbce628784c01b0f2d7536f9d14f42ea22b8c12ba6ca2dee4baec3e4570b1abb7cacbdf0edcc2e84a0492d4ee8d8ad31d1d5d7af3c93c89f93e6853d78ca6c327a1985b4a0c449f92b34a1991488282667cef80845c1f6c35ebfc874ebd56a40f879af91440d4e9fbbf41948998ec6efd4b612dafb26a9871df30240934d87f0e30c2cab55e66e880b897b6fee07b76dfd6b7fc39966cec6d331b5fe8d140081078428f9af601d37169d7b0310307b5797bf886f45af4c4b084a1d8f303747fa00d180c8f2cef2c1a4bde106ff28bc8478bd02721f614dcc9d93ff77aa9fd511848f38bcc8aea05e1ebcb2681e77742efd6a6efd6b9d69d20bd2728e589d45598df5afec00b879925157efbf034cf119c40b9536e79a47474defe3d0c2e4deab37f76c5e3389a097aa7bca5a5d26e1cc5bde3a078f390eba5a82298a72b1262e582f0baca1b9da887a13eef1fc48f5772d69b2d17b6b54f1618431a58b060b099ca7612636d1f383d2abb546603ad0d69e1bede966af1b01d15cc768a1b7a0e9f6ea7be828140dbbcf6618ed74e2470e4898240ea22cc73728fc799125d7bbe2739702fb154ef43ca9aa5da220abea4596c2932c52c486142d4c5e548e590f1d000bbc557e4413c5f0eacd2179cc832fd6493eda368a23c096d89f00b06f2032d81d205d08f9c9efc83e75f13dd376d749b440ebdedd675f0eb88358406cd2087a2c35ccd5ba901d3f2f73c24c3477be8ac73fec2193fcdff873af4a17848b053bf970627f758f65b7b46f68c4c08d2de0aaf434641420f405bcd820a1038f2c6cba81e67f867866a2b558121194b5044efcd056d889db60dc3cc2b60ed9c9253330e8ebda178e610bc973fe13953fdc9a45673693e4330d4b2a63e9dd9451769916050627ee3a02e837da7fea43169f986f600523666b54573cc12bbfa2147a651085fd20f69ce5c061b376b6b2b14f485951cde0be789b6c47e4abe1c92af43d8740e276f434fe81dcff8d916d24bfaffc6a37c8bfcd92bb39c26abb3de23e7df85d37faeddbec1197ad247733129b7c0a7e53a025f09f5b0c6b994bece903ae0b7d2f93f9fbf2f29d667ceb40a569be2cee8b780ea6c2dedc8c253649fedcf94a0925044c1abd1a9a80bf67872cea91c75c29ac28b54d3f3738b5999b55ba7c3a91743458fcc4698a1f8730c46b1112076e26a780bcdc0fe5001971ceec02f7f8ca37d9c04360b3547dc8b4c83c1a04ab9b3a15f2e9eef41920e935e7be4675f4bc1b1db537dd2657530353a6a2a2cb6a602b3e4184699ab989202d3d7b562a76bb5340c3ca9b643a2f49e5a7b04f69a50ad0b410fb1aa460e8bfc9aa7e2da2bded20bcbec5ad212bdc2a9dd25c2772dfdcf615bd4fb0314c236d203864a1bc24671e130a4201aeafd20e3a98e6e40c6663aeae7d28fe9649a2dbe61da65b30914a3127aa1972a27f3ddeab75eef3b7975bd786aea9b7dc414c58aad8060d5014114cd380f85743002b4695ad705dd3c084da8b6bfec0f3c8e7700efb75c8f54851788aeaba7f9a347c06e478034bb778468ce419dbed1e4a9384af4c1aff6d69350bc0256f9304c34af847830ad300eea7453cb7daa3e784b06abc86d0cff681b29af325d127b352545fd15d73ba308d1e37c69b90bb4ace309a2e3cf26e1cdb1149284ca414e72766c1693eea835facc07729470b54166fcf71a59ac1b01addc21a3517e157db0f94cf7326ee4cfba1d135a1bf29f99ec09240eba977239b83df647fd2a12c90a79413f4efcf1506252a3ac55cc45de000eec94192c6c0e5451957c47a3e285a4d5dbc7dd6db3472f0c47cdda7bebb1455693a0e7f8d6880c3b98201e0971040adb230d8c86b4e65914ae8302141f5a57b3fb4b292750cd30dbc7e319992f67c59f062d724cbc50a05cea136f49ee85ea07c67236da642e0d0d261b78e8360edafb645c200599e244606357e926a41cbd980d9021caba64331e4d6e8a1881094b62e6f6bfde0efaf2b31a3500416ce1fff45cf6ec53f6fa25d17d4cde6d80f196cea5fb80d5f33373f29d0ea977b1b3501ff16c3a1910528d391385ac995d07ba63b97f025f74d6f7e5da9f1b3849c26dd06f134dc824b43bf07236209489098571ceeed5c927881cdb983fea971f4f455255be2751f906bbc53642ce642b53141485b6cae4ad203232142b6a73f6ed83fc6a32b7ca6d57911b7afbb5dc51a34475a02033027b640bd0f2f2b0223b1f27df23320af4c4399f3459dbed198d1cf5733877337510026a1f48547e393b128f1c5ca7922be1d811985c30bcb55e0850a87f0ce7eae76e6ad30f63b71109686407682b2e5536e74945670104944b9e8ed2cad68f6496d23835400b412e00569734ff50982dc4c2f9ff5f48536119cce96ad9436729b0e4e91a1772866b512600644f964936c6e6c058a9f394344f53e24a741735eb2b6b0c24e8b718bd12777bb02bb4669941541a97eb676ceacac0f2074d045edd533c51a729b8bf486a125449265258b3e0408d1bbb5f8748577de7c5de519f705a020f643ce1df3e5b26e76f8e924db19554e4e454d41dbed642e63e52b73ffe55f053ec3b1ee9aaa4b6a9ab5b25f9d9b1d76448cc74eb66e644a6e929d51334dfb00fa69f7b9e549de27fa884ed24d959b1d87f16996d9bac41bc9df52839f0ebf8151920a6f56a5e096e02af15438f2964dedc2f4254d031fc1e8234d4337b89603825370cbc1b07e4c696c56ceea2409141cdc1581950bdb1c38490dd3cbe7e68e1b61803dd3b8d8b6a20db730d11b7629362383be683358fa56bb2e7ec0ddde449029a7d815f5b9a987765d63ea8afd8a5416529400ef1b06d0be2530efe991d074c77caf6dd6dc8d191d321493dde20f76910598affffa1cf78a4033136d148f33cfa1e489ef88ab273dccd9dcbee4c8e25a31f0e98ff5dc5e07dcaf8ede6120263c78f56f46e635ca0cd2150cf587c7fd5c2fb69910e1db9dbcb14006bb3d28092cd83217d332d26c0e4cdc3cb96e7a115a2596ced27b6596157253c055e747c7a3f0389754d520706ba9622638d9f6bf5849e75ef3c6da88153437fa5ef2e7912c231e5654ae6171843668bb6650696b839b922a541b9ed1ff3fc043c3652e1149a306f171603ff2b1d8f9f2e9bf04aa74c05774df2743bddb7600ac5cf04c32870619b399bebb777a1a4857753265c7ff8a86938dc971d82650842eb74640a011819ba2f8bc3943275dd7af8c12c7f43e22b86f4c716ae98dba048a01bbb8bd7b7229b7d3809f792431e4d22cf20bf3dc275afa40d5d43fe0eb286648e4c4dd2903d66eb3092012292277cdf97c5d17de6083d93369ca94e83057e07f3cfce9a455c50011b6f8cd807721f9d8af19c95153ac38d6106e1d546338fd92b38b5686e10a94e9ca4e60079401f2fa08b84d0fe17773bf696a20ea6cd007ba18aecb7002650f8a17c312b9b95423bf0c8d56f16f98a08f526fcbd011a49fea2a7912057b314325a19d78d5f895f44eb0cada6d72b7eee1005510e6af9ad49d9f913d86ebbf4743953c6ea6d645c556bd69ffafce6ed1a6ea5014c0817d030627f34426565f6bfeca44818a0ce91f7f03d8d53e94e636ae675e2a2b02e9dffaf11c7736da8e31f58f7cdf30b4be6afbcb779cbc308df36b9587a71b0da361fe748c00a50ec0cacc37be83f6280624539d5ff77ca1bb02698f77dc23ef010884b2d0da516d58e28a103fb0e685eb29d10611991780ab76f53649d50d792f887fb7fc1fe736bbc2061fa59e6d6be6dfffaf5fd314e3013e40f08a3e8404e9d8d1fb6c5b3cf9535bb881fc9bd9442cc5cdaa528cdf15533358a1efed38d1bf79c4c0ee912fd6d7f26c9b03ead6888d8980207c28667a2e52d2ea65234760bb86fd7d528c13c402c3f85945ff183edcc86107a733bf7bceb4195eb295f70c08157de69a8a4d47d562e362145ee31a518eb3ab076ed74679dda6998d98726ec744d8456257bc9c0fd2a32831ca21f681ad58486f201b2a3261bfd5e9e017fa90fa6ede3d053f251b3e81a9c25bef90f207bc4eb3a9eceac4beba2975a6311e0a45dba086b54bcdc11d50e8dd5a9dbabaac4a6b80cfeb84d87b186d90242816f52e65dabbdfa22a50bfae9ecebb98f1448e22aee476674012aa85987f2489c2eb3d81ac4ecce13dca14ecc72d10a96c90038db481c662aa1c8196d150b812d46c6bcf2de0a21324abf063481fd8f8920952acbe711fae5676cf319a49ed315a6ce988d3269cdbe8c300160e0850693de49b715eb6bddeecec123997614bc47031c9fe318941cae11bc7e850df10ac2d75a033b295a0f3e6f2f837634d5c072214525deb9ec2e4845a9f3a237f6f6c3a2cae827fd33a60ec6e05eacacd7d996ebbf74dd423ae38585cb0cdc2c752a71f526216ed75e4504bd4938f69ed8b1a14ef3a44df6e5d7dde557d1866e7de575e9bf263c20113568ba6b7b022b4db899e7b00c00822cdf7a3d1ed990b1dda344e24261a74ffc00a928588e398146c672ed2adb47deed3b550be4bb8cc3be50da5dda3e54820dd0d70ca6a1c848f1e6fb8d51ec7bc29f044dd08b057be7b38a3a93b2c399a6f2d0d9d9b6466247bcaa0a0e96a04039720982b7f73b63bd126449c79345075782c9b642158acc93d390be5fa9641b2d72d89181deece3629d833dea005185993e796ed2be6c7214a0cfa7c2367b33505fdd212b068390f1414540726632c6804dc24694bf948c5f0ff9b0c31317935386eac281b0857ad7feace991054bc36c257f06f8cc7ced3356364390348dcd7d8ac2994163e81d85263b6ac4bd921638908095e4a112ab8a973433f87859aac1779b808a9c75810faf043a2f52330d3a174f96dfb4cf3fd4cebe9a205dab3bc5085cebd38770e5a6d5c219d4a76d764b027a8860f7d5c2a401430a050b80cb6acf1aa4981b2c0a7e825136e463134850ebd265042f49eeac60e70babc93e9e49ae4c72bf13202ea134e2dcb9a248e0ad3129eacfeb5999b26b3f181acfc94d0dcbb4678fec3a095439bd47014d4fdd25702baaae4421f4c595ac1e3ae6589413cbda61b9f874f10a10eba311727e268c5fb76d425b9e15d4a531cc9cdf6429b7fffc3887c85a2cc4f96a3e132e0043cc608bc0777052a835cf3c7988bdb0b3385434f02f6f7939aaaa69134729d3e299845748ab6a13e6d5f59dc985aedecb8469dcbeac07d18bcb4e23d2d467343049eb9d2eeba46f66c0029917651ff3c86bc525754c1967953154ba2bb30686e32b44b4d85d5cb72591126696b9cee0d8e6251f5440d2af6c57c478a2d6364400ce60e0ca090b03adee2f49b08b12eb7c61264ff88b255afff536d91e64fd2874a8031fb9b008f61ee5f5f7ba87b0473f34625129564b104270ac9e4a8ac77b4fb92d230463069dea6b9ea510ed89c095e13990a6a7c15c3e7605ad92cdbf8b10d3dc9de968e4b7bc0416b43ad61a55f1427e7482951dfed75f5167244ff24fdd582d2bc76e8dc8348e5ef4a2b47b15356f5c34e24c3a7194b6f44ceea3c24d4934850536a05a9d43728e807312d70bb95c33840b55adbf5dd0f81c1439377237e5e1d8d35f23d5890251353bd35ea2cfe90e3dff8c03b742cc4cf7f534254a96378000e5eb0c58f332664c7a16ce0a099883ae253a47225b269f4124e144ec23be030b5dcec33b46865bbd06257d5e5bb5b33517206dbde3bfa945f471140657f25e5376be72520d7abf1aee194091a8d2e8becd5a8369fb1bfa46caf96b02211e4c472f9a87bb573e1dc12258a4ed84c14a1302e85c7f9030555f8420247e292003e9c18798d6d2c1831c254ddde67fc6510540a40333802e0a786de2896e4ef052af5e9899f29fecb9dcc60cf7a0d028565ca0aae8ab8f6baf8f7ac54bc357182af50f39202868e55d44c5804644c785fb71b88063b67b6535fdc4cc102258f37478d6a29810f5ec2275126eee58662e04f333fddd2759f38912c7f3c7420b91003085c5628913b26795d36e2e879d0ee14ab2eb098b99fbb8cd218c21ee35417d8fe96a520a74b4f209a66f8d53cf944467cc4e931007927996e77c749dc66e4c3c7aef349b8c02b779615ccf8a0f6cf5bb3869d283b1a593199d820f3c0df96a68dd5292cb29b2bfb7ce2703d2281288c730717a55e7f7793f5526c85b17d46e172b1aecaf8da54cfaae68a66cf39d4bc661e45db159ecd3ccfd5f75aabdc952c64496e63bb79ce4aa8086b2f1243e8bbbc2b3437aad015b193237ff410a0889b65d58d6456abc01b40f30167331c7c326640e0c930b4655248bbb616b4a2c7cc3493dc00db0c4bed5ad34c19e74571194394ef03d36dbf2a2d3692589caf1e29809f353df4e97a406e4b1fa401ee27f01e14ded700d0d151f4fd470eef36d0f0ec64992afa488e75749a03cae4ba36aaf297a940ea011dafadc17eb484fda369fadedbe7664f0f3cfe1c8eb847e8d0879d554dfe4bec3877208feaf6b0c70b9bfc8bf7468d38ecaaf8302d3dd22a94e69f236ec9371b3d45a273db48d273262eaa42879e72e83176cb1d8830a94592f4e0dc990e85a5b70dd7fafc0c6323e720f12394a87da72d34a8273274860c91a234dca513ecf0cafb04bb6fa8df5ca6812f8d16dc44f1258bed89a705a79d69a64b00653c27227d107653b9d1e155176f1fc2400eb6c955d98d3d567c935cd504776664fbc1476edb06c5addaf872fbff9ab44543531e5246dcf04f115e08200bfc2fc443f51cd98b0827f424ed702869f51edc73db31b9499f7e566f69f8054a148355db20321052c69e1bae8d0a250d4480c27c4634e2d268155d6bc8b79fd958902182fe1f80939a1b0a24a888deef2e28c919c706d01aff28b2a8a06ac7e5988d1dfd91ae21e2a6089239384b92521ca097596fc1130164c80cc500b4ebb8eca3dc0f95fb4042b1a0db97497cf99f60049b8b787db42a3bb101a7888511cc0681674e919502ff0b28f47898766c83be8e5ab7b2521810fc4abf06589b999b54702aa08c8fa43d01e5dc38e2140693ee9ef636ca3c70f04637bd501ba502edd0685f77884c143acb683e2d375306a044a4896d6f413f41489928946410d0d18bddabcc95679ea2921e2d4bbcd728d0193e69673996ea29a0ead041c919a56a8cd7e0d1f4bc9c9643fd2140a0a4fcbc61db3816e9d968e2a1e02699e2673a07d40f314e73a29391e7aa99ce1040719c36d06ef004f56da87d4020587c22d2dba745aa8632bad034a642b6c14f1cd4538bf54f7310b4d5b7e59312ec7bbe431e1908c912c0b1a9b94828863611fde47cf4eb10f7a5886b2ee7b0a7a3c1a3d9030a342ea83b4be6528234484d9d2a38c6c18f6404b2caca40d6f3e14c3f854519fc52377988cae8508e1dd4bdb53d7dd704631e408f047ffe2c6c61fbb0122294e626d34d2c91833351cf2c0b75c6de7d187d52094a424f4b61e109ddb51b34bfe52f34e6b8ecf468c3354fbb2d36b1497d983a32f87e89204e8a607d288dc85c6be22f4d808f11a1e7b003825465eb0767a6539078b530feaff3091339a97ad6e10ba07f36778183aec52fdf5d38c8ceb31a19331d8b9957341a9f13075d7ac1fd4beb0100d7022a07132259f805c8f4a69f7c56a1bb18c5f199bc7dfb2192911b360282391f2c530611e869017b61c0fb875e0130e9d8ce88bcad0028540fa5ac224d3f457c0300c49ec347af5eab6dd201946f7d7ba9b87b8f072f8ca1787a4a1c9c29fcd2300e720541f9dfb4abac09360981953713f12039bd8afbe4690ffb0e9d623a12321af2d3fecd842aaeebbceed3e126c3211ce7652756d52a44331c8eba62c763d67f1e18c076a4e8c4c120c94e606a0b44343707221259d681b9111b4652cd71bee3daeec8c617c0f0c165d777a537ad14dc9f3777da241d1d969f6851c733ad68d67b8daf08af374520e49582b72a47777905cfc617b0d6b75dba4dfa2989728751d1617d5dcb8b41028ccd0f80dd48f58e790a545d19e868b4a309982b871eabc219d6baf640a6791fbc167431d11ee239a817b9fd10fb7eda43c1f4b75a90b5145a9cfedd0ceff927c119704b6810199606a7c4dfe6e70a8b1ced9824a2496ce1509eb9afcb1130646e865fb069bb7bfcd965697ec433c41cba119bc799db339e6c46d48d854bb2a4f776f9bd2410af2d9932770bfbb68f9a00551f48788406d315a7621f66f2a12e488da542928236d0336ba827e7de9b5f6a15912db30226dddef164a7b34d61664c166be9ada5b261e7ee78ee06cb85d117572f6f2aa9e489b259e7d942233353c88466991f405056ae6d8e93be8fa42b2ee4b660a1fe16ed03e525a8e27849db82733187a20e7a556b29334ec1f3351377fda2689399f5ff2e0dad8cf004eaed60a13a1fafe596b18edfe0576a61b8384f85a34fbeaff9bd4ba3d25e4feaafc6017bc81d62187d35172f14b4b7a3f5ddbc4df3c42b55358fef405bb6cbea9f66b30d379b3e895a6f6b26b598ac6fbad6872e6d87ab2e49debf9fe6a664341eca731ef4e077fd5222702d3c74ac5d3beba684a6c3f8da3b8e135080671ec56f6a5d21eb12cf239bb9c068723f482a4563ba79ccb7a4e3ebaaf2a2a087cf2a12fa06d8336ad9b060307d39d1552cceaf99833d0920dc2fb9f56434fd091588d6e8f2feb8693025bfc7b3542fbc6bbe6a9d79de4e958076f51eb57781b8a48ec9cbcdbcb50bf38761d2b37eec529970c0e4ffc1aef954210c6fc1cbf6e254c946b4cfbea75b7f3eb60588e5f75f0e9cbb016c26dd533d0d4bd769f3e9c0ddc335b32b0cca46a205d50187bb9623736cf92386e81c2424e0317d0bf4004b8b2baf3d9262d210c734d0bc9c5848956df30a3f6bf9c700671045dc96fc445be8a41a2f87fd92c634d959c75e05a358c87ece05895630bebc693e0828d76d4e1c872a3a75a7e5e6f59f5b52de4223570e0c93040e6ba673e47b7d6e53bf4ca039865d6a2f35ccf3ccc126535562610e2da9552d4ba7aac8832a96140948118411f64d589745c99dd2c3827836ab7bf3f5c2b661aebf0092f6dfcdb148d828ff63d91f58b8441d5100471a0eb2872385fa2b70f29491b6288d0b72f9866bd9432e385a49138f7811fd47456208b6738ae6d371db4c61b0986171ef363f4f01ea11e628caed3f662403359e9b21254128c7956b403311bd05b56a4d134f5ee15676f9b318c0312241f4a2751b3ed0cb294bb89c48880a401bb1a6e9b864e7e35a81edcbf8e37b1a4e01a760521ff31828b633ed79f50399d2c871d5b7c6e3cd4b120381fb756909bc2ef4b4de5b215d8214aa2263a0fb0eeb28c84fc6364d268f8fa434ee7f5510f470f6e6ca309b3b91cb81fe43ee341e422674651d894cac28c521c27f35d09bed97ac5ef7ead838b417005f69b206bd74494bd2c3c6de8a1416f0b0a5d47573d4b0f202df4606c44d7a24210dbf22c804d1983f98a4744bb94ba36c16ec22b0e2fa999d7ca85f25c17eab5858d2bd30c980ee6d43e4c82f1b3a0d0f3cd01de26a99246e1155ff4a976334479f955ac7404fdbd75fe53838cc361fa00e4e8a30c7b2bd135f9d5c4d7ff458098267350875aa4e4645be97c20eda8f12d235e0e8ba6b1733981c42f07f94fd48b05317d5960430f158a9399673f09864f0f5856b14d43d06f20b2ad05377a1baf7eadafc1ac1fbe406f12338e20b891e691897c30fee43a847cb3664409bbd2f4620368056d88f2b1489fc34003c10799d271f0da69ae89b53c21677087845ec393f747b0f95f7fe7d4376b638e2cc3a90e826d6cfd818ebc97014e6042cdc09eeecc7c4919de67c9276324c10fc611fc721e6a896ef97951c24b50543e539b3d604033ee75637223dacb2df0e09693182caaf79f65ff2f87d2e72982ddfe89ac718693b32ac83a4a32d2cb3b06ab5b203d7ecd9831d3b8b2d8b0f67d2d9e895a00aa4577ae3f755c14d49bae322101aebb816eb97dba0b193d9ec0071ca972f2299a9fb0da429f0f963515a9b72f94cc2098d36f1722b2e5a8cfdf84e647b351e0eff5b36cca6e5c32b6ca95d7dbb461cf52c88b6db6fb5a565450bd163e8660508f16023107a8b2b63f750d3fce661b3f608ed411165a924104be24506b663e9bad5380541359d283e550b33cdf6bdb298546fb88a0480f6315b9825ec10fbc383d51752e334cd58edda91ca692728e917d9f90faf1a4667e1deadb86ec36a1883822809bc79cd206ffdf64072b73f4e575bf3df25ef1f0d81937409be0eaa62c02c06f1509b263b3975dd18e54a284e5025675f49b8214e76c1af57b0b8ba0a080936e8256eb63447dccf93e93fb5e7fd2136fa4d23e30b7497a97a26ece91eabcb55115b054f5e3f16b763686a84835d084376473bb769379e62677cfd47880c8156c11c15248e405b2cecfef565cfa2c64e4bdd4c790da86f852d6b7b7b96b2c8e1cc43ab63c8cf2e1caf0f3fc0c8996868e32964fe9f0cc1d5bf386ba983de7b75475d7ecfc7fa4f53305666cf07d5cd5013c24ff0d7eb1eb62ad98af31777e775522f01f45b1bfe792f91d5600b489f337063c64750ffc9d0455ddc9d0a030c1ca99127e28c6eeba7a568eba3ca5d0e85f0bd33a5c5549d1d9c221e02f4f6d3f66d2da66a76e0a9eec1abd51c98568cae99df4ae8fd18654b70726e7e214d48f6a77850de8ffac6ba6a81a58db60e2fee01a1582063d5d7da066bf44db3f4549f4b814c7dad19792a0f54c66acefa7f4a70f55ed3903c9f97839dc4ce47bcd76aa7f0f7c61c27004675d013e9e3ddaf58c86b1c915993b0bb95a4d58bd2033c745104536f38fafb783fd732bf62cd408a6a9c7be1c73ce482e4100b7e60b8076c87232848737284acd80685ed8e3d5309852b3c62a6cdcf8791575cd299a6a34b8d207dd30befbe50d4729f6243eada9e79ba5b8731af39bf2c7de58d73545546c6d67d41eacbc1a270f224648369cccd9bf649f25c72d03f697a589d1be72a5cc8e58c9610500662af4ae93b3127bc255ec31559ddc43a9aab6cf7fc6f37c61ec3dcbca7582be9f99c8afe0fca2292772707041d5f1a19ddc0004438213201980ba695a60c93fc9d5eb1c395106266f79700bc474196ba6a38346937ede4d3651d216666f1ce8224643ec7fc6da4d8841ecb64950e464df119579b7524183190502785cc1c87ae8c3c1205694ef1aa372f7db5e9de07e1beb00f0aee3a5be9166d617d74c2d44f5351e0cef74548fbe7014830f7af9783132115151d61737bf320a38a8cc57d0c9b8f7b9cbfe6a2fed1938ea9b54fe3d0e68bf7091fff138bedffd6a17fd31a40d1947f07eba0b02bb02a194951c9dc85ca3418b2025470e64e3e987a1133411720b35b066f6524e1e2316ff4386d94944df44126e5894991cc1a6deb135afeec57c2a9dfd3e0d5d4b47dfd8cbea7dd028e8a29c5ab4a7ecf36f483a0953de03e6aa995ad17a01f2a83a4b4b5e61850c49e5d323babdbc5c7e33b5aed7317b8fe18250059c169fcee20c67e9ac0feecdb733d5f93fc0b58160da02b5b184437cb202bfe16739a380d6468ff8ec2d7fdbc588e3786d953b28e2bbeb23627d1e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
