<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42a8ce17bfd7975ef87f18f4ead83e40e3cc56c942a4bf63f1451b35b6d5e4c3c289e3c69a97e1760b28c4183cd5a00ba40985d9db12fb68940f4acda4ac985b2491deb46b3347d52fc5e6a66683bf09f7c2ab47c7a71f9ff8c1b5da97bab3f13afb472eade657406957ba8aefd49f8cce783d301a87ea5e1b49dfb39615e89543c86d6aa382bdb930f1beed3ada13d2522f5f914b9738a41a32bfc23894cd6c55aac5f123ce6723b391ef87ed2c25c2a8f3ecfd226ca111b7830640d728e0f66feed26a36c12e9d66b84fdace8aeab8b83a49a89ac3cc096639042035925fcbbf26da503be72a71e7af98fa62cc9f8fe2d2a6e204778a6ca5690062803a69e62e00ec5122cc91fcb183a3f4ad53918a9f92ca065f34546df2cbe586defc4c08f8e6a09ad1d0f740aecb0bc4687a4810c2c254ce9e8ddda562f1798a0eb10800a0666756b2126f67c86d9afe9d17d61f06cd9de39dd6ce57f62844023bf8ec272b242e384b5929325e6f8606600d1ebf2262cbe1300d5eb93a4ba554905c1e22e52c178ff1c9f5ba46283b417b242d20aab9882865817ca7ff7d4a1d04d7b544a8930472cd8fa493fff9bfc456877ad9bbd24a81feb8af2936537e8fd159af097f74a929a8253c5b3ce95b7fdb7e872c7d40e0b081dfccb1890baf39e56b7c3f43d6e9d98d88808fd24b02a99161d376524895d0f449286ada869cc084c12cd5a2b3108fdc60114b6e92e34639557909b33fdb0d727367f38b8bd08f454513f8552cbaab278df43592b54f48b0ab303ac2c05b6fdbe3eef06860064b1a84d4ddf66d54f1fdf84565b9f34712ea7adebe2eb932f15ecabe039cf1f6bd74ec7cef5ee9604da81dfa80bee7d7829d969a87581891eba8a6ca2d0f2f40894e8693341c1291b43b4b83148356b7c415022b706b325e2760e424291df294257a69184a10ad3e64a5fcb0197299165ec3a42429c5a92fb89358182b966610706f49fcc267780984d914cb42d3612dacfd9dad260f35c4bf255fa307be376a5b7f66e094ce95d4995a07c1f9faba4e38a99bee7f0d5a4a73368b288fe127b724eac4efeb79948d3fd3e3905e4889a8b5589f1d86ced873d3715c252cee44d35279a34f22d973919b283224425844f463bc5a4b0f1c197a5389babac97d5c5d9ed64d2e6a7490f07c7105ad8152af299a800242eeb74744cdd0e12a25c80419c29c8ea36c21b088b02ba8bc588317c5eaefb87df068e68c8cab197f3dd12cf6ab543cb5b04b79558493478f0f954a1803a32a291aaf2b17812bf1873e8e0d88573f42c6c60c2a6f5d1fed8fa7cef1d914dfb9241279f5874877a3d65fdebb68019e9dbff386ed38537fcdae76546c907e6cf65376bdc9d323edd45555302f23f290ca01720a522e0d65267a0ebbe80e24323b741d8c91ea2fe6c41d86848776fb24279093a907920ccabb758f12d31526c092f7eb7c511f580f7995178fef3ad8a90fb4f7f173d6d562c99f331e011445c10105d5feb7bdfdfe3df043e029ce789a22c9cf0ec20a559ee2f23f41ddf6e2d3139fabbb096ee67a7525b7db037b41635b7321fa1a8febf9b81198bdd48c968f41d2fd06ce25bf7bf03ab147a5fb44636c6eb3b57d86c687b68a15226327c5f8ed74ddc8dcd1200af9f48abd872b3757dabcd9685d6306106693e713af4b8a4072a6df03f312b44ddca9f8501d319b993b0d990e21d8664c69c70281dab09be6e99095b14d627e45bf1095a2e4e6cafb831699a05f69e70b406b3897efa728125f94027bc3de3354e7af5bdbec1665a8070d3da5817dafd780278b976df98b4d43a2aba402a73f7511b3cc646db0bd094c656f08ad3a6b0049f33362417af7e89dc64c7828d15ba899f71baba942ff323c55085570e8320d9676f3fa1612b74c7ad5cfcf657ce00cc9ee4f1395286bc530088391add71d40a3b0a260895db875c132d6709782b5d2cdfbd9e9fc80b7afc1e6da57d53ef1a37f2fd475dcd6475e1d3286d6bebff956c488d23ef5c5667eba510d97bce819d60531ef0ea0fb6d9e1e26558b65bdd1d536dd18543a1012fca68c1ff2b3a8c41c2b9975c7812ca8867ce7bd6760c199af3c197ef7756dda274c1a3daeef9a867fba15280e3ed5c3d80a9cbb113fefcea48843003f309df1e860b73df8117c9885f59dee775d5a23b3098c8b0c958e8fd46e9632bb2cc74af0c7cd856a5bd4a494da7adbd2a5411644e6f10e972c72860c4422b8023ffcd9ab1162c4cbf5ca6647fc817d9a34c4b0ec3fbe8fdfdec913bfa5afe1d90ada8a06264a5edb966cdc235381cc39ddefcbb64c1459d8239e0a0f0cf623ffe85aaa334e47036a21dda35bd9c0f0a3ee6e53c81724c35163af70261d0e147a3312bad558b39f7af694d1e3b19f120906aca20a8eb1f32ba83351df281e1e3b303285179d607ba023db0aa8325545be9ff58149139f6cb38b82fca237e72496880dab74eedf3aa3e3b9dd4cd73b3bef9ea339db684110ec35ca5157b746c2db12e55165922b7f1d49d7137ade8b4dc8d850ca474179330191358d35dc73d68ff8d04dfb56f0c2aafc35a001dfa7d8564ac3f451cb88cdf501bd50bfc45061a6bb36b7bb505b3e0ef08164acb8df66e447ea0566d2fe2bbf10a1c2fab35ec3395e79d11a774e5f872523d1e252d49a55e2db597701f20b923ebe28cfa80acc3d4f8aa11400ba1131fe19c918a0169d35825d3137e98e7be1cd81bbe60d0faa741d041f8ee260a3fb1496dccca8a35bba29226a02521e79fc4a9b22ecb74296b5ddd37eae632664eea9b0d58cf35c7cb37de69ce2cf7f57f4f1aa641c0060c531dd96fe6c4022e47aae0308e59a248eabb0925495f2a6a0015de77adcdcb8cce6cc7124ce7343bc4fa34bf64f4e57cb9036ffd6ebc0c08cd18fdd117c1e9a6e0567a6e8107fb15765a771ba24bc45216cf7e07abee213c838551d18c95b1c684ddabe09baa7993d8d73ecaf203c144a8d99a0ba5d68d296d4c29d4143b3d45e1bc7d5c34cc9c77135c8c5bce3553904b4674234a2585ca4112dfb5b8e864813fb91315eb019583023c1c8ff57541874864aaafa930d11c4f991e392ea19e4374d059782e67830cb24949ae5e19285f31d45056d23a9a5aacc0ee5e2ab6173ce40e77314bee94e539697b2b7682041e844fe14d9dfe579c4a402b5538593c5d832cbd0bd2978ba8013b3474562c710c546b746edd4aa4341535b4f273065f1621e537e6e13b17801ee2fe249a86e7eefd1010b13b19f0cf9e7f153a8e404f48c4dbc88f09e2752989c8ced58fc286d73bd8376a2876ad56e7f0a056a002c38523275fffb0a361cdd6e5e70f2acb424a955e2a732754d1b251e0c3b781948264e2ba3f83d5f95ec901ca3f2c8e3b8075e3edc71014803a53fad5e4e2d2bcf47d91072948bb5ab885622c7db833943e3066a89dea87361b8b8a0bec9262738fb6937bf7014913325dfc0fea59b77c37fa2a07deb2a25614cf9e7b00099669f3fb24925b7570d4c35044b12e88edc7b1de3f2e4b2e13d9dd7bfce262791c9c856c47787b622f71ad8fd738e5dcfef5eb11db7b369a606f15fcb9c0bd5a491a9b720aa776ab58116d82ed21a7751ad0a004a066645a787c63de898169f3456e42a2a71fb771add20b700bb4276f9dfd509fe0844bf8df2a353b3962cf1f8576a083d1331c2180cde4a5e0b3a718ecdd5a487d948fb5b9a307af6beb286eba237dc5a781f55728061253eea0f5ee187e74f7ffc57931f393f866a3b5510b607c6cb018d0ab5ba5613a8404c896b3fcd162fb543261a8a6c6ab0fd44b8efca1710e4a595c74d3a2743ef4e7c557f108fcaa3d4a6ab09d54548b47c9572a1b1b5953cb501e800ea1ca2805e6c81497457ca8df7a8a3c365647d856894e847e96a0855e333dfe3705178df74477b756ff180c3de23292a5949764808bcdb7ff324aabf9f1277779e204187d4c629f1adf3f16215a8f37b79b299f0f0d6bb84b846987ee60fdda7be113d09ab58501a251149c44ff0662adafef5a7118f289745333d38eed5e7423c8b08243bf3e1ca484d74a67db3ecb0b1ebb0304cf3cd6888f87e30cb70bde66942f45354b6d6a2eea72faa687baf55dcd5f30e3fdd0837c2d3ec64b007c988c210358b67a5adcc5d7debadd2505afe9809d453992587706f13f88fe8defd22ac97e7e21ccccfe7849dada7fdb3fdf90d859f8c83b317e2cb85561e45b9d3a0bc91c9834efc830483c3846c2658ad54ea9a38910b48b96af7e439ca16ba3d09c5910741502b7556a8392916cc5df465728e5276301a7d911e20bf9de39e90838a8554b93dede2c0566cf745d55cff305a999e8c602a5747ad61d01d8cbef4a855c345c3c523b5e7de9e3b5c4c2246fc82467757bccd3862de1dcb68f5db432a88e56ab7d239a4c8120e50434bbc20b65409cd72bea4dfd2f8373c6ebb65378807a90901a5f5221649212aa1619aa5c368312344faf3a747d6fcad6b97086c92f339e93bea0fcc0ac1a97bc774f7f54761afcab4a7d77b10fc400d9c8578231753f2b0ba5ac6b1a1a61a579e432cd2be05b9b7fe99c588a5b841125dada456f56829c1b124ce2e72470ff2630d058c73a3b5792d5bf26544ddc6721efdef08e8303d3521ed9980acf50c144bf80dd35be8a6f72a1044f893d78b74a791aa1b9f9c8f6f309da818725512c44f3d9c8715e8d033d4ce96ce770922173fb35b22b5485af57df76821ea3c9404587bfd08cc53b70bffb2726490a508a87ecdd0b5d9566741c630a47b52fed2c2ee9e5a14e64310b4a7f4ff0c5656f4d52485abec2221bd63575e2a8dca66cb37eee4d8528ae4481db621d298ec63cf5dfc570001fd7507e7162589d9e6af6bba331ca4e3494877b661a562a6b239a2936c5b6b7c716b7ebdec56756d7dcfb1cd5319d95c77f3290553c0a0a73521fe89be7721c4cbb5685a29c54a31547c967c27b22595e324c0ad50a9b1d39027afa8d6b69033cde1c719332544d891cbf7d6fafeb7d922ca2fda8a8e06eb8222fe6e3b717c963ce222376d0200c171db08e4ca680ca91cff580ffccfc69e5efe8640bb7add4e1337bbd5c98e03a046079f5398de1c5875534e630dfa231c9a0bdd2f927346d1860b8f4f1c79fa1f389bc77db2763dab130fe10bdabdad8fd7f19b17682e948d3db332ffd957579a93251e94a7055f5c21c5b9732ca366538624209919f74bcb8b51c00a4a04cdc5ee8b781a2266609be63dd4086d28bb6501064c9cf5e597551fa71169bd15739b92f1b09b824590e0df36c1a175c9d8325b82f44b402702b7ad51302e9c14cdad1c2fd53593a52b9b4050b969470b40e3745edd3a07645b186853118bc6b07b0467302c1aeca61f70ff9dfa5a92ba53afef244bfcf36e8795bf98f48491c254d218e542a249d02228cf6a619c139fa6f2b4057df481b03bf4d5913c8ad0daba49953811997aa714330b8b29c7962bc289cc630fb272d80da59f49ad9327556da09c8e4befecc06be475d7bae1c74f3bf78f491249ce31b039f4cbb80a54e1082872202ea55aaedd954b21f5e089d225f59568bed72eeb41941052f80f6fc1de143386cefcfe67e9291f84c43b94956b18086225c471a837006d4096efa245e70afa1a3a6320d899fdf7650de4cd7b05ad94e9e846101a150548548306a88fdbcf65c751b654d1d30a1e1eb4bbad5bf459151abc2c8d2517ebd531c8752246adb6139165a085968539b444fb991c80d4188da81a870221672810debe60a18699c456ba596488adc582f41f7ca0288e80efc54e2bc1cd7d4aabe63c962d2147b794addd02f12b5b51878e75e99676241fac9fd891f3e237f2c409f155647403b0ab870f24ef333f986a3d82df510d2f66fe13aa5a9b6449b7f2469423e416c63e029f38636a379d304a238b6950e6e1b8cc494584fa94c73f8cc0287df59c064682dae785b4e61c1e9e40997ba881f593e0b08a0c20120577691f7ecb67c8ef8b99a82fa1dad7bebc27f10d7606ae46b64ac06f200ce2f6029a8e54ef5862e85148e8cae0aa7c2b3750e2fbe6603ee2e1fa863f9d50112b0e32a14402880aadb27f8a17cc3171db512205899a0adf818e5dc2b0d137fb1762af59b88874407eef9852ca4e48738e9345e3ffd8061e8356419391f2794c1f5cf2f4ea55edc387e9f21bf8c52792817d4189c7b3addedd28a337b17ac5237ad0803a843747e803466091f5d386897985967226fa537f64b730fb4cc69df98b56aea76203b06e9e7bd8b4cac1a27bd39826652a4d4a2003380efb939948c6bc2b7adc3f30584d68380f4eb9a8cd66a35832cae2a2af249cd14fb2efa2f061194b8f4a0257b6223b5c3d980f5d7db9d8b618f956f02ce1fd590b295274370b48767e8bfb7c6802a24f8e9c4863d4d8da6d0bbb38f411855b7770341df34516e8dde20e21d5bd362bb9fd4a8f99588b20c2cecc5843cb2e2ed62eeefe51bd09f0d4e65b6950226fc2fd07a2ef5810ae2e01be6bbe9f4c3b264a47a7b0fc501f539cd7e0a053118a1c46a022fdf2e49a8a9fdd48b06a9f88d4031f9a43e1bd0a8e3ed0c45b2a90dda7e71469d8f2cc9405baee9989c74d7f43aa12ba62ac5c304bbf68b77fb2c0dac6b87daefb3b563c4e85befe4fb834940872db5bfb0e2a800bce31dfd35e753585cc00a3fe1a1d748d1302b93c762abf428203cc512585a8e0a0a1d7c77c39a40866f7d7977cb15bde63223fbe0ff54a02b4c79855ecc3ae1c3ded448bfbc017818d6240d676569b23ca57a039f824447222f4745f3733369ad667e83911319e0c92f65b44c75030b18ba74e2b83668cb2df7eda5b3d25119c866c4dd55f1ea5c1096b5384b8b60542f02d1f0ea60b6184508caa876c6a547c4c4f2988c6973bed985b1cce86b6c544f3f4ae0118f710dd60cd30cbf688acec1328b619e24e4c95f63b7b2463880b7e8578c281a677812e60cfcd15b93e31d41a7aad7a2cef3890d393505b535d504beee810ab95fa90416eaa295daff7dfd507f4fd2217edf234490d600bba24cc286aadea519d57003eba9bc00aa8c537272a2d4f1010da8073a1d393d998748ee08660cfc6d0daa3a2e92d75063b141c817de3c061877adabe7f672330b2d7162de4ffe4d4c8b2fb6141168decfa6998297939ad62f791223a8de2e797b6bb0ecfc143a547ef1e3aaac4ea83d9818fa6d536b03804c30c579e15272dfcc58fbce72ba486d89cd71c714216b754f491fd23b78d99b1fc7aa8afb3a11e13db3a87ddc1c81df57d0136daaffc07aff2e6dc0d6c44b37dd9cfb63d0535a1a63471baf86343aece8ae177e79b6f808e33f0b0d4d07b59ef43248897862822351f586a7dea39f9095d0433a71b0aea4c1ef8f6927596c7ad0f12c6c45cdf507d59ec4a8674e17bf2b93baf504407a49948407267052912b96d40e49af1d598d7600bdd1a77b506ead26223511bc91bbe352ecc83d4567967fe3c4f02875a5ffa48255978471a11015f1a9499387dcb530e8b6ff3ddef95f8450bf9cfd3e56a5d14d4bddd67723b3da3106deadd86bded9e8ed89bf974bb2aaa328254ea3fd901c95df2c8fdb23e66c81906d68f6a27485949811a28a02ba44407f7bf4328a9959a3db06bfa904e034bb580934baba38e25ffb17bebc40c4299f89bd1879daed41df87982c0ba293f196c5d54df702486f279f571f3fae7f419ed0a41957d6fc643e32cc62fd920443307e8aa1dcf21f13d07a8d7118bd412dcec4d5a23e36dc55bee9e9ecdee589ef3ba20719eb87793921db93360e06b3555784a2331982628b09c2698bc2112d71bcc8186a0475058a847877fb76e28a65963db133836c31ea3f02d6d8bff6076fe9cfe872c1c550d88da11bce51b37919a181d1bce67a1d65990913ac2927cc8a0e4d53f003a679d0d82312806f303d8b1c0d63fe44f68881374bdb51d8bc54718793553ee32b6e66b88ec68c9a7493c7f0748f063260c074016fb1941c9fa7cd01f6022cdbbbbd5ece96d81932dc302807fd61fedd12aecd16d07627a8e9c6934065f3eb87bb090c5415d511e7f1e69d0f3c19f33aaa3808cf0fe2b5388c37203b04168c5eb1a14d286527b59724392ae65285d731694c0ae1e8e3f0ff046eaf065c0dde15fa22db60c7128b18eadf4fe3f3c5015c3a8222d3dbac4240651897f6e992c583f1b5ed6e7e22f34c460cd9d766122dca4827ff6c1e9f368f59172b94ebd2f3cedfff16e26f3c0057121988c544d621cb01cfa0e47976cf0d64349ac98e5fbceed74788073c4058c279e8a4eba173ce1eb845094f216fa434ba61262252093e915db84c3a74f244dbedd6459fed1da133be29f22820446633a3e49b5fe734b2cc320083b9b41f7495b405bc190cef41b2c3a53cdfda20272ff8322429f67c28e776325863ea63211e7f44aab2b552f40ae39b959fbc33e84b2128e602db27b601e084e60f2feb14601dd1312df6209baa714f715cadf9f5dc0e58e5f52119c0a5a423d556d7705d87a17fcbce6b05ed4b5d937ebec63cd5b39a8d3e5ef9649e2a48e82984dc72b4dd5ed2dc1768821697540556f9095d32c5443b47dfb7d19a9d9550208372094b87497e9515ffb0fa05cb8e78f6532f891d870b87feb09d19ed222f085e6c30d3f9993fd6d04ff2221e8fdcb74c5afb22716bff9f2109c949d71d05eb285d7317a69b403224b6c537773d5c482fd0f36f565c79ed851b9d22c53333754df658edfd037412d91630ae8f5eac22a6b43b6b77c7fdf8e533879d03002df577fe17816426e0f4783c5fb3d4f4d3c226852ab7aac7250aad7098a1f176caaaa8c67d1817079e38061c487000d70d2f9ec580c0645d72b2456471dc95f45053b6b61d6ee7b2b2368b5ebfdd406215a0b7846f4d0804a802432f629f5cd57236cc14d17ff13dd30b9acd2410ece7701e1a91a85562d89fbe2058794a88be67d11db3a88d8a9d97e260a14140421e864a882fbd777893fd6c652183672274d3f56e67d6250e8215750fe190b4bde66a3646d352dfecc26318704aeb9ccba51a9a7533841f39901915a04617d9e6be5c6cb22b3bc77e3f00bc4b8693cc680b49ac659e0158c54b9032776353ea224f8ca40930cd5d13add88045ead1e56bfe67b3c2d3c397e92cdeca6a59fc0fc6db500c796ce9bee8ba89538f6f29cac332f149b0b71971cc728e67a841eb91ccf7553989e64c77ba61fc9e90e46b8e8748ce3536858731abf438c063c20c0868e48f350b6f3befb027f4434197a1c33d9c58d209497b8f9143b5a27af0917b107f4522b1f7dff6b01a5092b6c6a2f0ac0dd9d118df3c14b37978e9915bd013e44bc18e8b97b671a7379806c5f560f2bcf3f48993408b8248ccd35ad3e94e38c2030381f86f98062462ccef4174f8ae6d63eee14b78c3271755bb5295c0c27bfc95052634b416eb2b70204c83dfc3cd51d5b617893abb63fa6332e579c7b4993adf73bc338adea7dc25f5ec6c9c28229e68798e5bfc7696ef7c367408db5565727f6744bf14f0bd0a6b6e7911fcca49c0a4b81debd592966a74656e380064479fcc6905ae5a1f152db61b0cb985a72a4cbaed15783fd8dcadb670107b87b17cb55f5ff40372e8240bbd4807e06f66052bdd3d51013aab51883219fe1eca2cf7401357051040e417485282541bef5b47757641c54f00851b833d9119f55c5c6fb31d407f3812c93550402d3ddcd49e824dec88c681c889356b15353ffb211d032b5a7df90bcb798b34384b03fca91c5449b5c90f8481da2a8b17b7cb37cee0be4b568d636790fdc23ae08270428aa22a4256b5fb911f66977463159cb8fbdd858f5619e87da0b8b7542bc291893ae88c7ef0fbc23cc2f6c5f7a9f194078473df7c4c47eaaaf518b139d1fbe2b8300a987347488ad78e9b811f0703a96ecd296f2829574a94c498d4ec23ef0db683249426437c0a329b0a97cb9de5bcb82147be41939fd60bb13ee97a54e672bd07a7d8c7aee903d04dd6989682462561e2893ac62d2271a17f430181810cc6cad22ceeb39a52227a5fb9eb45b2ab94091ddaa239d884e2f7627bbdb5da5ca6e2d8bc0b7870b9d9880d0eb37d3364f2f19d2945ffe14443221e5dd0ddb7f4c3379603336a0b7b08eba8e2f4c286c8ce412204d4953474bbfa2564bce5f7e1e4890ead05a28f653badbb8385f6b4d05d6294c39db8b38e0ce82a96e661f9eb49bd4708564805a46cb4e4d0acd6303e3c6741810ded4271bb7117bdd5771112582751409cfb532512486fd1dc45ab1c17dcbab07732e09bfbbc7dcba2e7e9ea9a70b77f39911c605b746adb160a9bfc12bf10f51e6b3eca32b46f580da0b0516ea2d626440df66c845fe4aa88fc753607c08bf95e1de30030cda844b98994169abdae0a1390ade46e0319abb803b967ee8977e0a2982b00392dfd5f73aaefceb9ee7a31ea66420d7e3b39de3c6368cdd96ba51eba4e3ebc5aabde1a2c2fee43fa438970f17a531096fbb976de34be2304b5d0e15091b16b37e0bd08e693aba4464e4e46e8f13582ac06286527ed779696f8e08b73d29c1dcfc00a00afd8a36e2bf278b762e808719c9937df283413075c6c6cac5ebb17d2c63cee3b20ece98012d3ae8cfe2e365b53bfe37baa06dadf9e2231edb85ee79a25b048d223207a068e1912a2e4c40c1651341e47f2d03fe25cf95fc62e62bb5c3f8d5161b60ca4cfada7b4346372b62fe96237d774a9ec639a2855696afdb33ca0637388b3ba9335b315fc5d884bdd7ee9be43b7f6a4af18f328f6f5dca87ed85ba916b4c9cc52b2996e8e477676e6d7155322a7d9c820808d0cdaaa718f004dbf916ccf46fcbfb9d00cb81af86593bf78e09a4f24e7853b6e4d6abfdc6cd41fb99906f148e0d8e3593d68c4da3976aa135c3f233f87364fc468510d1a85807892014d66611c8fcd125192247268f7cb23879ff359391236441ef053d9fe618f54a213f671d350e0bac7eff3218d84b27347571936a4b367d897036825ff58b37fc28e9def8be094f9c1e67f03e0cd8f6a11d0af72871fb392be0b325b35ed0c1b1bacf4e392973467b6c74ebb4eec929fe622821b5a3c116d2808ee4e4ff3ceb9bd819ee14b88aa3d42a5f38c89030a34e0a12cb4e516498156d7854fb802d367e017466e4b5a988adb98cc2873ddcd385a855297a87dd299b6d8485f3a18ee13fba1f8650f7c75644011188f184c12dc8637acd5e4c115a6be4c21678de31d6a7d65ecec1cfdb3a406d37dbdc907db3245857b517bb5e6300faacd3a69d39d6aee4ff803b3d0c0d0ebc841e6250e32109f92b98336bf039444eabfd525ac2d4035048ddca0c833341a6ad3e4c3c0e1b1230c37a334ac362c1c25513959aacfa64a1d2434dfce6a21c88b81720b4b4316ec623dac0b624847eb077b9998b721027eba61fe61f9efb3494d097463c4dfee49437e658ad2870ea67d11fc641133474c660f780ad79690486e912de04a9a228d78977e0df371e27a8abdb76adb34d1d7174d1d6605be7c1576ac3fdfbbbc602b8c181158aeb9c01edbc44149d9a714034f434cc6b305496c03b42d7fe8598838369823bae22669bb66a6cb3faeaedd86576a7a02f2a1b72dd2672f364da778dfe031115b9297485cfd8b3d8fe56a51ae353dbc4cd173b882e84c563ed757f943d9046de5db2fc9b9a72cb44a1ae58106987a306d14c3a48debe38265dc48474ad26247bd4d884cd576ea482d26147859d8e4a43febe9e73c31a5d06f38c7e2bcfe5ecc232f1ffe094359bee30da33fb378dcc8f4e236f29cdce5e7e8ed26d8ccc01cb387141c6e7711598917aaa9fa950bfd5117080134468dc226375b92f374a4e8a0f8bbd572fd5ec531a0a7122b66b5bea272084040e82182e7b840be1947450f4fde907fb05492f2acb47f258e7f8fd8765d1d40c2114394e1aa3e7d076874ca93c4176a20f1de042b4ce8fd55bc88feb10c23e0cde12e85147448e8adb92191cf6b134c18a95140f3ee8261fdd852d28c0ffb11b66b34f2534d7362aefed7e97d7a694b2c5e7d6eda7b7d400e66ffd5ea9ae474c9ab03ce21fdfb3774ed4ebd6dbf1d778fadca32838075510ee4414cb6cb637a82cccc34abf4f71ea6af75d4783791002388441cd528c6eb7b977e0f70b4a72c05aac2929a38dc4eab80e714765404b0a0cef7f3d44bfe40b2df061c89ef90f64037f7b26d9066221fa4a1cc84c94883c8f549eb975b09097f1c8a6c235dae446a25dc95e66a4490f637eec46aef462181d66d113180df3b1d75157203b690c9c3af4e1b1b6fe6d9ea7356684336f469ff9fea292711b3235edf2f9de0db3322f43ea2bc86d17f4e2546e96d3021f2492b69a669ee3d65696ce02c49fd7c345bc2536977251f33d755a68bb8f6168c96c63453ea77a599d9be9743faf04a963b047a18ad9fa015314c4b47dc9cbd9ec03d5573df598e13981e916ea669473781bb2baf23de9ff49008bf563789d3b4e696ea1af7e056a23003220f45910ad879493fb465653e6fbcf8aeb97f0d5d55bd496a5e5e80d83b7cb7359b4072931d8d6e863b874ac2ff36f88f0f744577ba04c8c6e61c28e512b1a607635558303a64a5186327627b50a27d60f67ebe127a87b2a8b7757ced82f382bf15c000d4754becbed8dd69d7544605bd15bda1b292a1fd9dbe5c987cb12dc56e83a8efa31fed75d026083173e33815d158e57e2abbec1c9897d6d3ac31a58fc748886d71984686fcef8eef9aca52874b35ad075e1f78ca6654940f0ba19faabedf2e92c8101cd5052e7c592ea24f72864ea6a34c84357d80c6d84deb2ed842ddac0271cc16b0bd0548887133a64fbd9d7b9118dd3d823d0947124bfffb2b205c6f724d32988b90645df3fb6c5555bd1311eb2f9cc123031fe416b45c87a5aa1e24ef14eb751b0dbd8e3e5746e7bba38adf4ba50ba797030641dc6baf0ed63a53fed44b1ade36045b0d7f1d7fe2eef1b5b104d5c863962d9fb1960421f60433253902486d5ed32dba533ddb99b8b48f64c3ce13470105dfd1663ba00b47e82a849d1e8c7c1f451657c0f16418ea0b372abe714da54b09acdfbca1d2ff77843ee0d74294deb67049ddb5d24301179cf72b1036fd606a68f68fc78c51bdb945eb241e0c96e4b14c2ec91d5318b0c95c46c68a36aa01bfc76c69cb9c04d8ca3f2874ae7194588512db42b7d26d581c684345d77df10caf38237bed4800e84deca01938e3068d4dfafb090471ba8e1638d878b64587a697934049dcb34741d435943b20131042c25de026d0fd2061d45b8cec910035f87d0deed8b3dd75ec7da910a7b16a811431fe1689678e8192dc0b45e5fe342544980b1058cd4af3b8759888a2925caf47de97524acb60fc4263e8f32f5d36d0c3a78a72c54528c0c5ad24b896aa50803ac1df81abb7809cfe892d72b55b8f98413b34b1240ecb51efa44a5aae1dcedcbf9d53752956dc3b578d6ae49a6027f8fe4a885c2759f0ef95f358fc3744e489e553e4f7ff998620779060eb20b35451a62db8c4e40579266691cbc5f69acf7c6c550b3122cb48b02288e768209153666b80ab2de0d3a7fbe39356d31cf0db4e034c45fd494b48b13f49fe1ac9be67e6dae0e8ac51341ffd6e74f3622452226790cf8d6a90acccc25abc6fe5fe0cdc6db38e18e1c7cee34e6434b7c06d40504e3e06d07e10e337d4c2259246d708fba7f74bb69f7cc878e583ac1fd739685a8d34d3ebbc911c1291ce8fe3e51f24e7dce61b530cd69c9c14a285ec1551ad237868c0448860a028503994e434cbd54c565d9414451038e98d70d798ea3388a8cd70b57692fd9721d79580c099be569dfcefa2c7690dba13038e7f6486d7b433ba110f173bdd7f4cd632fdff44a217b33b35bd9dd4448fdf73cb0cef8f3a9f4978ab7fc9fad5b40224d300a0a5b031a9157a9207e2e9120d95682141711bca774c3cb78eda5894b1e6cdbe0e1cfe19486f57fb808d46ab7722e84536690d804f330988c845b13abf8d250b6248c5ca45ae1da4161ed855e8cb317beb849faad2fada746b0800d969cf291a6678ec9b7ec8cf5c2addd696170334c855fbe762a26b2381a3b62e44e908160bb563ecdbeeaf6c12e8f5658018c2f2e084d156522520de185e9cca97ffb75d6b85f4607440fa594dbbc78d33c30992731210e40bb1b0dcdaeae19c814f67c0a70185fdaed77e1e4aff26924c734178ae0f2b71a394b55eff2615d274e6faa4e58ea0cb53b00d95aa37cb357ee91966bb35e0927e7068c6486985bb2c97e903d0bab01d2273e56e984a126449284f753e35622920c3878720e986d7271aa4ff95598bfbe295679a9365302ce95c52ddc72b22bba34df76088dbfc2a60fad3f506a0f869bcb2d85b01b3b645204b1f2b1ea16e6ec3424652ebf971a213e6d2fb5dddb3e4ab49f17fffca562969dc549b61bb5fc5d2e864bf5248e8bdc83abdaf6dd6c60dccaa65272a1215d6f607f9f52d6cf63c534e90a8d26a77ace80008a80945be3cd9803e9a5dd0a693267bf102c6cd457dc16986f75dc3790e38bfc5d147ee10b896beaaaa15bdab13924726ced1410028f410964bb1471c2900ff3216cd5cfce6d298dc6dc1652b7e48c633aab53fe07dc206f081e5da80f5e1b42972dd1dd284637c01d05c11cb9d3302b32b6d51ad7ca1ce940bc528d885557b451d574fffdc0c74769140c2524d26a80f6287c7842f26f107f66c28b5b2fa2e7ddea254eeed656c2edff56618387c9b39556066c94702b5764439d420a4920df2f5da289f5ea4f5d5e147d0dbe69b8a5ed176f249fe435caae0b0d4053e9b807b0d75f0265c5e42c69360a2023ebce8e0c13dda08df98829253510c1f55940d0c2e653799ba2b5e30785a607efc8d0f67fd3a2526aa0512e030eecb694e959d02403f43b475ebbb77fa5640dfb4abfe3dcf782d514c7f7d3bcf05fab51dab1ed71e0098c80f4eb15b4427b7f7c1740be66d61268f8b4ed33e1f834c2123cf97fd1b16277dfc83ec4c23dae76e609137dadbab106355095d3b3ba453d7687eb8faa5913c96096fb7b1f127f1252e2f2817674715575c2ddc36dae5f391a50dc77e5dd10345f0c42ced7c54e5ade537fc6cbbba329648090a95de0f5dd686a820368b385d275aa2c1b12b385ab1b60bb6181e7e66e0657fb6d1a3eafa218f2021d9cf65502aefab852cbe0c66d675e09bc9275723f9c3ab12781ab7fd8a7e6def122b4649aa3120836ed5b0c4bd2a311f5e452cfeb84bc266e1067c9d7114efeb02c20edbfb5d472e12c64a65c0ed450813fc03d20d3ff509464cdf87e94c7ad49ee8b8843965a6a65fae949e85f2b3d6029da53f48c497c3b3645934b21625c2887c2c63d6ba75d4b98e7afda78426889522b34ddf81421b26e18d388f90e7598c31c6386b2dae091ff76cd09ae9b1fc6aaa75fc5b1b7926f9c4ae127ff89d5b3caf18e2453090d87abb5f6e8983bdc3de496eed6fef72e0547ce6d478175356e8af86726d037ccada6a159bef5bdf7493e0178b5ef4b176bc63f1bf490aabe81a41dd66a3acb88e342fb6230e302a02bfa2cfd6ca6dd11ed4c16778b9a48cec3838291b3e08649840b59309d53b929062a60dad7b3bf7cf86a605eb7a89891b6ed1e8d999e73bac6f98a3da09295894599845c6db9b95338afd235a7a9f6881d66aad4ebb930e4ece89356bc8e3b5d23251de190493dbd507937ba347764a7cfb4253f3560ae7bec757ebddb9063d7ec28ccb0b3e3df6a3794462982479f9eeae2db1faa46deaf7faf0dfa997e006e37cf427239fad9779a6baa4e3908a17deb41f482bdde738506ed8935cea4cdd3a156200cfc43e725f90ce344a4ba789165e4e715505f673a9068f0e88803bbc1a10b554fd956014e138b57daf6b6a866b8c6a81a9b770419125a6e6ea4c88317dde0e8f9a99e6ffb81d67bc44f63abd9ab220a81560596023803a04a0abc0484b738c55eada294390e2f90604ba3dd7c07cb61e05114ccb4203ee47cc5fc9a4a991c0b66a2c4a5a6d894d33bdfce6aa87a66105a35bb56bbe065d4fb07934af9110adce2999bbd685e10dfe80e8b5bbb170cd41447d4c8452195e1328606aa0e9ab708e53b67444befaf576be6c0e4c5fd4b910a326ad2d2c628cb0b03427f96657094b080d0dcd18c411a46f030350653e76f4e26d19b96400fd593ea5c98aced9a9a9e3b5f34cee1e4fccccd9d3ae5b6b4204d80b3c8388e3eb9e01c8611a33ad6f3d656df7821b21d6d00bea03cbc50c605bb0220ebd70dffd7d2909a3dd4d44be506cc1b34702667f0080ef6d700ace0225cf89fd66a3613ff4ac67947d840e0bcf8c7083e7e5e79a2eaf74783cc77c447791c23710ca763033e6ac604062fa948708af981b58c6f258e07120f618d76ff57cefcf1726112732345a69d1f06045ffd9562ffa5a3712f08cf693dc097eaf1d7900092aa30b21d922f2fc6fdef649187a52baf668f2798227fa9b9a18536ffab6c3029161b58f732f7438b31a0e5e70ca08b46314b6cda30b9834c291f450493c62d0cdfc41f26d55115dcac3fc374e0ec74bc1b7d9a770c09a94ff55190ab3d11c3c34159293ffc65872e41c4e8fae45c94dfe7ad7e2aebd12be2da93ccd096346aa380c11f83ebfd7a875bb07e1af0225ab1bafe5d7cb8ec71c00bb2772714c93518318b76e543b9a6eaab74aeae5135bd8284b39d962693cab02a2db43b625ad54e2d6bde977e3c70dd5487adb6a8008e867559805c50b28b8d8ef3a2e35ea6531cabe2bae9211999debbae93b45dd7d24a9aaa30cb4bbb84d12f39083dc60a2cbfa6b1b32dfaaf301efad5381ce8c10c5776073e1f4a0e0c35926e69753003077d184674b38edc3ea44fcd70b77992c73f00c305ebef8c8e84b71abae2aeb3a89abf7585c92f74b0f03ac29ec44c963f0bb63ed7bde081619231d93fd8900f6ec2121a2515fa6bec431db67cab7e7550513c2d3a143cdc2451c845d9e07e0ff31433ce58835214c9de53e27f4d4447e1db177eec4c0f7a2b92cbc4d337220cc6cc114266c34ff982133f8cc8e404b2180fae87a4e7a9e0dd70c9179ac791a4d0b21e29aee8971d7b4ec1d5f786542453e69b776b38e17a61630881d163f0cfbb101448095a6de92c934ccab967f1da5b48fb0278227b90145807530a6336a6c8f959b60759b10bce4f0e2fb2742e16548c820015c84c8e5b5027fea740b8b5343fd43e872bc3bc7ab6acf1323f7fd1fbb581a85bc1725fa32ac6881f23345ed5ea53e991de11ffc598f79ce1ce1227264ccb62d84c0f11be930fd5486fec54455c1f4d42506b986011183e46a92b3b59e53145656e1f3bbb87a96f9090cfacaacb47c0bc9b33b7e1f943b20ed18bc2554e2875c57ea188bc7f0a2012c8c82029c2431f0ae16cee99f364a13f39c2b75944f32ea62052b2e4eb24bdce9a37afe9dfd5c17fbfadcaeb01638e92741c826124f914490af15925d893a81aa1c4a3e862ab374b69fd174c09667d57269156643cae6220d3d228d0c2b123c2f89e2a6f5e522fbc9cbbd5f8f1268ac978e5605870fe51987a1bbaea8179e34327999f4ac6fa96f06a4c52ad12b05a2d9e33b76693fd3702e7aded3b221fc016670a62c2d98392b4088f7fc78561031cf2522f1a090e63e57c8ff505fd6b20aa4ce945f82993c5f7d547154c5ea2b74ecdcee6e1f0a15ce6ede4187b3c102b3030ab05fb8ea64c87c560b94d40e6eee2bf208fd799964f445c22d64e3af18b51533397dfe69151d71273b82a7c2e40c40be5e673b3b8f24d9b15bdce3036fb184a06ff08d7aa251f187ef7305073c722268b43e4198cf3e397b7301554036374070677c73e1eedeba3760fbb23d322c9a1bf21227e0e3ad1bd7632612f9e41f7acf6f4cd3c5ea04e05fd96456a5662d35e5fee67a0daaa9a23748f88201d342463b3ce696dcd8760077ae32138ee1d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
