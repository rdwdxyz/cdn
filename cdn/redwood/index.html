<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a00e36d1bc0086a8af2bc43256a234f6041aa8e607aebcfc719ede0f57aed1f6a25935707b2c3d584af5ed032f5ab8bfd11be011739b5ef46efdcc2e02fa09a192651e4272becc958fe19b0114e3610b8087780617b2843514ee8c350af4ecaae543e54a306bc31d4fa53617ada82f001b4bbf2a52b1b9c2490cdc26b323546c00524a2ce0fcbad60596ffd79c610c60453fe3cfc3102860fa12c0dd632e712d7c121be2b2eaa03c1b0b5080994d95546453dedf51c891a0f518c54da2159bfd2a5384c263d90753b94abebd5bf0a7fc2b6ccc99147e7d7be1a8262e3a8baa6a7b3762f0bcb2a5ee93ff96c84351e39ba9fe7ccea7b00d57fc0e61d1f4babf59a83e82d1ba8a5ba65ed26244bd2247a489e903a38dc0dfdc41165e036efa665de002ec89d52cd5b2c2b154acba71e94b268270a439b8408b7df57ae86c0fb3fe3bb6d7de0a1e04983f3d02e3580d8ffde87bd80a74ddfb99fee0993b894e178568659e0d92f1f1cc050de4b363ff9d55fb70b7376d9895c75c22052de17dccdeae05afe3beb5183d7c917390fde8b03c1e94ad8509506d451b827928c65cd104a0eadacf585d24d9b4a23d7002122bd8296d698c7b11880a1e0a99ac341bed01944dfc7241abeeb0a8229ad0948365d90b7998ed464ea6e628d6b701ba9e609ed142b17eda8d77c91e5095eca1536f3640d8d520457e6d5348c202421fda11292acaef73d0967f58a6641a8e6c28641059288b2351b8d9bd9eb33c9900679f3bec91d2c247266be3ae29cba77fa37de64d7c7d05992bb5f32502e8fda71f30d586dde6d46c7cfd99247123b69a06abb664544cf766c48c3e358ab9f427669b98942b50218c3321236ea19fcd42035986581d51cac3a2cc93e68381b06051cd2cbb93f1a459052958597492781fe35a0cd745b256e80538998b8d20460d272f551e651ee60b805f2a3888af57e2e82d12809c76d8e840641de4ee1442653fc13b9ad064001434fcbb23001627bdedfa20d501ea6b984f343993b79dcfeddb0d787c3ad87b5abd557665a5ac5d0d06f035a4091fda4313523f284675682491c9fc7085bf8fd56939dccf9ee78b84c3a86a151460c70865e3c4a3cd20718e7a5ef9c1cc338e8d7e870c103e5f5c5be1cbdb5f816de122c9314ed5198f3176979531f90404d8aa94b2e8675d2112a2498d7d59bc329b59928d6233f607f43c32e8a422ec3aed35af55329b0740c19022b9c7f6ec58f8f970989451d5830a845b2c97662d0da427cfb5eafdb49ad00fe3a767e9d43f9d08a944815adc4f50395ae439df3401ee30b0a5054578edfb4c55075a637b84e4780f51dfec8763d22eb42761217a1f1c5fa38ee4d536e06e409c0e51e6187fe25112e2db7bb862e7924d48cac92adcc64e78c960f611bb75477b07e3b0ae435f42d8830fa23b15bbe556892d5c7c704b923cbc3cb1bf983afd9841a9951ae79ca8508718edc9342df653b78d5393c0ae4657635858c491f70bc222f366b65f450f731d5ddefd288304da39afe14e30fc5bd82620b3a4a1520751549c342c3b4e09617ea9b6f8e408b1a98bca094012c6a36dee67ffbbbab1813c6828f125232d5ddb94381960a895a78958cac1bb6cfcb5fc8837ab905a4dad21d35f8d3318024fdd65069ca937414306c8f573ff24e69f13b45c90e22de29d28396529085cdf004947dea5231cd6a5ef4f5bd9c64ffe8bd7f70865161bd6f75021fb76c98e13ef253c99139176f4ec8a4353aebe4ae354303ac1d1746413a5a9fe7d66204572c986f49de394593e0ebfa4f16e1309d01935f6f35193fe36db252b07358624bca5532da795427a7d7231dad3406f2115fd5dfed145a671cd04fbc19aa6454635d43f321decbe34a4e313b368e28f941569ad6ddcdcd41bd426b50a7b36130d820102be5fea4c89d7244df8d9109f130a7778ffc7f9ad8b67ce3efd89e2a282b7f6c8c0c26e91c7503d49ca42f59096878a2686c84a1d2bd7683e2292c4e93ac9e22a0aa13543a4a1c6d2f17aaa6dd75bf4074029da4d08b8d0be323cf431b8650d2860d99f555402404f3f3fbf31b90c8e5b4de851a9d9b544af6af3a1765996f99d672c26f844aa48811631f48b025443e76aa2e4bce68ddd5a0af1221eb3508af1fc67574ee28489c8ce68664cca38b12ef1ed02c362dcbfb62d883f6b846f92a095f45cf82ee2d69bba2ff3957ef81a036632b85f96c7726fd4a489f262906d79fd26af0cce6dc151edf4cf87ef4098cf444aaa525e006adcf1e9f586250bf3dbdfcaf51a3b9936aae996c8a7563bf1f104534de279e830c1ded0c5b46d12a713a9767e17357746478e7bb98494e6f7e746c65d4fceff86010961a80010a515ec525da9512372e2ae5c87268f7459d32c1517b5f4848e0d6f7c72460ecafd22014ad50926b6216209c9bd320c2a7144a28980af70822daa293d765c2537b423e3bb43a015abc21397eb7d6b0af723ce4f0568a21e9bc2bf69e798dea2c08ea4fcfd81ff45109ed033b9ddc8be25c5bf8eaefd3211f18042672746bbd4f42c7b3995e4be777752686d7f217e16192ac20e8e982585e6df7c76c91f62758ba244be71ed36caa5bbdad2d2b8bda4ba66033bb0039f792b195f365d26f73244021d0395da1873799c305960302ecf26566219bb65552c35c8958391c887af0fa80df63866aa7653763ef73f9ab691ac11ccb32087192d6f2a4d7c6339829dcd39a9d991cdd2bb0aca8f234459b728eb892aec5299b9cc127e72d611119a798809f153313c77bc916b71bc01835e988d01c01ab729cf6ccc33c18acc53130ece7b11c8e4b6ceb95d534433081ce1319ee77b74baa2053f9d62a95b811fa262b4c93aa2701fda4197ed41b6e169a55e5341e8688972f0a4fee95e876637ea2129b9421845d8d5fd3037812ae8de9a5177e73d2665f5b7658a510cb6b7edc112da6024804e7432feb007e4a99fb24b3c921dd8788930c3865f17f536cb4b730d6c771782d5d4bafa3871af88a5bdaaab04f59662a55ac34460e03298ea8ff8a02140deecb5e3fcb88b02ba0fca3c46036e9e8c679244d787bbd561270258404a090e7b72e8e079af6f282a7377549b475cd29d480dfb4e1fdbbb15d2e5faa07dff1f7df687045f3c7d0605fb072540b3e8809c309f5a245babcc73848e8199d5fdb638d3f9fa4307306327a9f564aef8effa4784ababc0cb09bbf713c212c64cb41a2be6876e2dd377b23804a56c382ee36d1f3d3cbea8812cd1a9e2d2bb044e1ad05448cf3cc959c170b1a540d3f85e3a9d6cb9c5745bfc744a025242e08ff53b46318e5946c9c338f815913d712d8e0d863349e1931013fafc79a317972b3f0d5bcf62410adc7a95ef279afc52d585a6bdec49760e06928a69d7f24cac9ea2458b77b83bd3f63329b460505bf3760c57cf99643e7d9a06f1097394bae9cade1f38d9faba3b45ece4090327cfd104219a690b50fc083127f259d10fe08e6f4e4b49f6547f5c16b40b6440b17e3977c3cc63045209698f9924170511699a867ae02e34bc4cb1aa68b8d004388101efe4a320ed6c3653839313ac9df04fd1259f9eb62f3c91d274ea87da6721aa825110d88ab93b863a998686a7f11590972cec82c7649eeb9573bbf0616bae7ae833ef237aef1b2cde61552c2a43edd20aa6d14f20eac2327c3263fd4dfa8c76b5224f15f98a910f86c7cd6685f3d012953311517e7cc216bf5df42107b45a2caafa1000c7a9a0d0ab69c77a280f55bcb90de81ddf01d718b5548720bfa3b2cf36c6a9e6d2a20f42694503011b083690aba03c25106d884a2fc0d03e69d352e0055c41dd34f28ecf40653826815bffe7d642233222eaef87ad7e184d4321f3d9d112e4d0403922c69cafdd66a529f5bebc7851d9a5568e496af469fa022198177795c71860b9b28a84169309ccb878cdd4d5ad5ccae7da0488d5828f6ef6cb7a7e8dc742814cdfdb9a1bfa23d9be37b7e069f42247259ed9d0cfd19e1d51bcaafd92a956f195b2fd7ee7a5bf78a72ad530497b82bce9a7f95bdf53e82d08299d88a94150fa5ede391ce1c47ef6687719d0349af043a229e3b843d564f71d19f52c6312bdadab40bbe7b50de4366b5c1b5740b1bb95971998364849608174947b8f432a8a9c02de529dbad6d824f39b125c67e1ad961cabcc95f605a039de56b52c5c1c52d670cf142c8676ec4f06d16371fc5ea3be0580b36539c308979335810b946fae643db10f926dc06b1659a881de3c693ca466173e24fe5c4a0c48e87081a05ab75f0972210b59d71ec76ffee683142f60cae694dd73533fb994add25b0d1d9a7232f59e3651a71a56cd0a2ea8c6eb0e92932360bd36d4bcf6d9d4c683a38001e40f450d25761288660c876fbfe8d9c798eb4fa37f272d6b863b6c083c31c48668b1437563bb9bbf78005f4f4a9f42242c0fd9331f979c8b31f0a45b49098890f0696117aa0d34d06cfcbeed0719604d331efa7bc82ea86f251932dc72e4e3c35900e46674ec70d5ac494e3ca9cfd482b4c1a8733c2e1636cc38af95b53a8ffe2535556cd028c8099dc6cbfb592aba840c4d6b05f25bc79d2ef20ee2c054cec3da58d31b5c6b05e8ba1947b1d3e6c1cf85bc0d00b6fbc543dd1da4bf7f1a26bdfe279568914b9859e29420748189b6397d3d5b3f5cd04c5a1b5f52d6362f943de79d9e6ef24cf81d39edb9f0ea3a8a0675aa429bd3be1fcbb02c4b77620f44af4c94640ca065ffbc76ec58cbf349b74c621a35a6341b6da6b763f0d61bfeb2b030fbb02d7dc4656f14b29e9aa1b5258f10c75ff0aa4e577cd0195cb6f9bd135b6e22178396fd3d310189da419dcf7195f24a8d2fc9b53d6e7f2a140e4e1e3abb95057a78f4c21139f763287912e36e14cb2b3b8d6c0bfb3a421607f5bcd357b48343919e852cf391056a48011e93633e9fbf1daac60f7457053e7c0f4f27cbbb95a8cebf10c17d3a6367175a4e24505c67c5bdc3fd85f40a7e02a7a97dd0fffdf5ae3052fc0692c82a6180ffbf457c56570879f565bb38fb1cb4f32b5601d18c12ab9a9a8c2ae161b321777ca373148ba84c4f1dc7b06b4a5c4a1ac20c19a4d125f375957c5776e1fcd456d3e71b5a2d3083aaded17dcaa901900420d9571e20310ecfca228e0fca76a9b5546027eb1835d1bfd0da5b709c7c81f1c070941fd7798d34af273f28277a9689d1c0c04a8a2019498b0794b650e44ad4906ad477cbe94aabd8569636a376152c364780d69523e6cda7f06d9b93148eb258b79179bf1d72caff23eb987db84740aedf3de0a57c41dcfbd1d6dfcb9c210c280e9617071d0336741cff4f3652a3080ba81a08a3f57b7a61a2361e92c430b37e524fde4491099093eb4ee864ab03333615b2aed9a5432121e80bd8704e132d9452710a382ec9098eb4fd2b5a77515b8398da869d2e19f493d0750704a48dd76daf86a87bbbea7eea3f3f28365b47a43b5faf4fff71d7b1b435db0e05675eef91f97a5bd874b840110632fbe0881acd6013c7a844d9f9cadd76bff84e2be0d230b4e2a096570de68995f79a6e88f1c9efc859b9c930980fb0d4c39ca18b5a74ce1d0c5d0ac5b96d0c55019d09b14cbfdde9f9941dade711b5f81ce47706fa661911b50ed2a7f966adb62e93975f842d9cbe39282dde83bc8b3ed35c65990d43c51869fb03e85045d6436688c641ffab11e2f7d375330a031dfb8121af8bc01be84456b10ede38d7ba11dce2b338d744a6f2bee897932551ff64ba4a02c92e8b78abe42d0d111fa564c60025590f55ae7136ca58abaa16f8570a8785148ee68825047c81705bee6ae6ebc937917fbd36b1f5afbea8f479a21667ead80fd2125c1733b463d1b979d6e5337150980f76d9d298b5790eb8dc15218f51f10bab05516f3e50fbd2794c57c2f72fc9835bdd00e7b86a64969e202b5fc9ec60901811e9b12ed0ae5f467ccc2ec7a2be9eaf125541fd613c041d4c0e7bab7ba22ba377529b60d4be6f7bf2d5ed0ecc0eea9f49b5677747c45838316949a574195325858556d1877cdc27b2596b97fa8ca04960331bd10479d2f2569747f34454706c167963b75ae14191bcec6954a267af94a5e10b760826de10538f36a975cc09ae51085082b7b5bddb268b63fc141da503bb8875727fdae068e484373151c38875dce86079c8696c76d24c802be4e2968e601db839b8f00b5a9844dbf170f1dbaf90f3ad0000062c7535af044ac33cb6fd41aeb55970bcd1935930c40d84d49fa129bff5a92027ce1763c7dd542a936ac4d8a4cb00a5cfcb95e91af96e495f236797e9c9328be5c499c06ba35fd41bad14ddf1f6250fea3c56b65a3f848404bcded51f3a1609444e9c59576b46987c03371f1af5c63979b4babad946c699c06a2d66cd693deb4bbc0673f3953b0969f175069974806e2878accdc85b20506fb2d1fa0795b1a67aae2d4cd222ad743b865aabfdfe02931c7368cf0a05cb00fe1d8282ff2547ccc6849ddbee690d40c48fc4cdb3d9dcedb0e36dd011e0988b90b134c130c7eb122d338386eedb7b3d8758ae54a42198271cb8d506fed3ecf62a52aec3f635fb5fafdd059c602d7361e9fa69f3330eb2067fdf9cd5bb72d050478db188bffeb00f663ef77323a3adaab59ca45034050ad4bdbef872af6262e96ed3d9738400eaa060d2f9ba5fe6dfbb21159b4cd3e384d348bb06cf7dcd8528781bd4d28f2fc7d6628ca7a1080a0f5e29e3a094c6e46d5750f52ea06e8b837c3c8bf3e8a8c251b6d150fd3a849799816e1e29ff838256dbb9d59fd910cae6b5b1b2864fa6a98fb56d1a36966a6c06c4f367f97731d57919d08df0eb35c1035035c8e0551422cd24127f851f31e15d72547a43a1c1bf2e2adfdcb8e755027fa8440137047de4878459f4ef4f356cf3ed3be4bc418df55e8e136656f54d93e0c0be5fd0f29b282e8dce072f5f63fe0894c1a5cd3c48a5befa4c72dc3d99351007bbc65839cf45acb52858729e3b10729ebed53ab33da406eacaf1782f4b4af4f453b2ccfb97aeea945abd5882f47ddd3a89481583355c9ea18dc563f4368c8a24b210ec105ae350359d110818a1b302a7a4c1486302b3423d569e0f6571be1c5695c0dd169b78f09a32e4446116c4562003ceb75dc927c9c9c3ac7abb086dd40c660fb350121dc730cbdc5598611afa7e2803ed8381f46e806a8fcd0af8b67afe6d065742ef7c9f7624b7fed405d5445ec802fbdc4df969a144fccc4d22a1157e6895d699177c24fa53547a870eaac4295f13aa75d797468a22ce464c50a10ca2bbd4238e861b350b50df95735f417c29ccef4348a7298528a80c28b981f6fff89be91c9a4f0eaf876b33c234d4c6c7a7bbd74ba6c086ed072f035eed87bb7bc285917ae19bcb913cfcdfe69833c5e6dc9b4ad9517727ae438075f52c1a80d9a76488b8e5af4f757c23a935b05ab072886948e742d39a5a0c63044a17a2a0ee6747a692e39636176882dc3ca692f887b5ffe6676f1f938994e50a94437dfba3b146372bc5eaf76e985b23462e8177192d131f11dd38ce8b80ad5c4a83d27c83d6b6ed7c8f9c72b1c1f6a9edf834a7cd8de8b928c02a085190ad7e4c43152e5044f817d0deeb8f2186e94d99a4aea647e925ba1679013094325465cb442b96dc92eab7ca5a930243217a495fe14386570f95d6cfc237e3ec43e2162df2b5539aac6f4b04a00e0ea187c8079d32a75815eed77d71a6aa20782aa5501048bb899ce33e2dcf8f05bb2c51bd9e82b1f13a9363e0118b6e836b0b190bb7a80aadcb6a1d039e1b08252ef17d1c84a20388871562bfdc5690ad2a8ffaec0cc6552115278d51c3ae29b207627a451a165fd501c1669aaa84c776a637cf2ea6d08569854dab5ba39cb87bab95264d8e8c4f70e65d61df8160c23ccd060d4691b92a24f9e164ca31589fadada2ebbfbb20bf371d5e98cfa39572a8b82f0b343194faa021b2febd2eabad589696c9d569c4e1f3e1475d0776e3b939efaad9636e472e9846fa2dedea46974f2ebf4a68796adfb20692bb157544f88e758e8cb9d5bfd42d820081fe8671ab97ed688af52a0bd589785bc6b1d2b7dd824bf634ebaedd27b293edc2c8eba51914808ab3d4f7da1962f070781577e227e12278843663e97e0d87ea3a910673af1fd68d475b0986ca9c99cf795ff1578b7cdaec9a0bfe6e0618f8dd3c385a35c636cffd54c82905b4eed35e5b0996a88cee7b0f4227d98409f110cfbc524815a4356142f1365557b4d2ca8a6b2fb4e3b30f5ff47fd548dcab3d6caccfab5ce4b811b5d738750b0f3f86a2123256668ce5009f5fa1143dbd25f6da9ea8b054ec6ba38f173fbfcb2502b7c7260388a15dedf842ff7bf97d1fcca5b08f53bf9c0fc8475e677b2f47da1121a01c94976eceee4ea1fc21d0ba7e2d60d8e348ba1c5a036ada4c85b14320feaffbde7e32d55929e865743fb1a27c2d0b84a31b88cda8bb2f4dc59dd4304be23b2d6c251e8dc75deab5fe65b0574bb43e65d8242c4d55f314d1df3690a4544ae9080c930588441dd7d463195ce6607602777979f936d8e657bb103b558ca9bb32f9eeaf2154189eb23945fe25c51b9a9260fe6d2f7d6d806eab57cb1b17dc0673c1826c50c3d01477924e95e9e6fd68b847ce3829cd49f882c4b0616a1450d082e327e155d8a0446555a454d14bed0cebe60a38cb51069af7ffb229ca9e452ba5805ab283a765ba941be623b270a3f864c32299e1e0e6ab3d8d06eb76eb4cc308f82e958ebf6f00214cf812fae59655866693d21d5f73de1f64a0995891d2cca91a52c5407e8b94f6767e965a57d4e8fb581566f2a492206065c49d6b8c6974476555470da959c26235ce6d99828dca607690197b0962442c70c74c9297356f0256fd3716824434dc17a86ae1716c0298ce1a1f2a33f8f7d862e9daedfd0f2620a6523b44b2384af554bcdc81d0be2247e8bed27f7bab3f683d48b76579d36c9f3f21a3208f33c28752fa8cf2dea6582f8e26d72587a27ac38ac5796de91c48e0dd017f5fc0bb693ece5dba01c6984f8819465201fefa37c81f327e15e81005b82533f176298dc87b386052d1e2a3dccf986a2884805bdbbc0d017e3f4fd7329da4eb3718c18f0a87bfdf00f5b7ac80dc55c0d7788ce3b7c0bfba48e960eb36e6b947047b475249d2bdb375b8a0c3159c0ddf93613d381055efa444bcf7028b9d2ad8bb4a8c7861b1c6901fa8ac72c35244f4a9e066540ffe95bfb25f0bde967f669b508b266a016394ac993d632d6cf9f032462ef503ee5d6ac4f974c3b30ad37ba1c0cc54e3e7de4199013af994401c6d1b58062a6042cc4fc1fcdf76ed77bc205c1de32b0287135b477aa62f69ba4dad4ced888d137d98069be55b0b2871ccc76610cdd37adb80893675e2f7191b5d142bbf635b5e9cc0da33ca838cf972370681f9654a576c40e0591bad4e98062a3ab304618f1f198a2d11a3dabc40bd3f3f97d523ce563042d7b506406ab1932d0ff7da674750ab0cd60027fce333af20dcedc936c010e9c5694f9eba2440fd3258e9ee982bb2ace222cbba3c80f22604bbecf43143656fa1a4da07615ca2ddbe275178492f03ee38c49c939f6bff8916f18c8cb976e26a586dcd74981a7a64fa6f3cbc43be1bb8d99cd97804cb198159ec75fe9ff9f80096abaf99866f39e67c075c074440660342ecdad16df2f5d80debcbd16c234fd83bcf091d3087302569470fcf14c71306414c9143de883cb7eccc3bfffde8e037f1ff46572c9ae133d04d34771740e70ae0dbf8b33e5e7b57faeab9b75b35f0305b0776aa51611d9a958d17a54e39d60c608dc4a36c9454d372894c190a620cf443be5ae3f836ee34f1f63d69801ec39478f6819c29b6e225cd540bcad49b239229d90bd6d5e57bb9362d878e7676fe89faa32b1e3dfdd085cc4fc210bff2ba45d3e156068a5b74e1db9bb2f78f49ff2c99cf5ce6ccfa62467ad8ab5987a4e2cc3dcaefb9e2289a9972953be150e894e99e271952df7005e12d37d678e02fffd783da82c5a6bbab9eac4f05fb9f4970888b24e35e67c69ff996d991c3191cc3f2495ade6f94d6788454c70582deeb86269db8f8c769e83aa8cac41cdc06c647a4f95b96c093bf3998ca52c9c7d74d0d39bebc54642e04cffa19444cc1fdb8df09cb42d2d35e81e07488ada5fe0ec0c5b6cb750475f92332c6c5103acfbd4a5e11b809f21dd804004aacbfc4918bb3cea6aa8c90356e787561c72bab0b8dd2b53f44df3a65c676d90d5a7811b16f409b6a5d5bea56218bdc98e734f1dd6aeabe107f83a3956e480978117a88ef4c2d35f8998e1e64acec18e4f056afe7c97eb988f0a64e8334145ded53446bc89d18ed498f3e31ca61be06d53ccf4504dfe8afba5eb47b8b49b3edb116ea1afd4de8ef6436c2131f6690657311a9f434762186b365f0611197fe921738b5506731ae5d0ffbea710958ab5456440d5d195f4d3e686a4b1e3134ee0305ae66d864f244afc462f29ecc821bb0b22136c6320c361fe761de60d307a5278dfa90e56480ebf9d5bbc35c7939176e2e5494200f1e072f08091f6ebe0cf87b2632dc39da46496aae2289aefc907ae567cad4b2080bc50d0a44e111452bd4b4f7a05d956bfc433616d1ed928e518e413f62e1444d2c08c10c8eccceb708d2e385af45bab5b9e653327d5a868e2c461fd660bad1238abdb9bc5005057432bdbcce30505e09ef80307ffa51a1d0ff7cdaa0ff3d31f916cee84f142b96759a05b54755107f0e79266d4ce80cddeb75718d55aa9fca4885e6f56145e704485d8b966e27e6e084b4f151251ef40f155cc129fa1fc4ebb2e2699789b12f02067295892579c2107327399e5da88aded42c2312e22df8b2db29e13556f79cdc6e51600b6c18663a505a3f03f4d1269f8778f02168dbe748fa747bd6e8487e2b5ad1bd4aa3645bd453ad4c321896e7d53af0fa4520b41a4e1025c5eba5717a2d3029bc8bf8e42e6c37bab904e719724808411f9fe64836a97782202b796fbc40beed3512904b3b4285d9f1ffda5d27a796247d93053523545eb0c2d7baa1c2661af46cdfcc3d47385702c58ab4c552c993cd132189f8c62a794103fccb86243ed7ceb9360b659d2b833a4605994b63ca675edd17bb716a3a89fa4730abe9e00528dd833cabd9ebdd7b67f5052eef8f0ac818f804ae57029edd9d62a60dfe565ed75dab598ded76cb4737984b9f9ce1ff5b05868859787d095c428ab91a3cc4b0263f2186c31a3b6352ec367ba041e5dec5ff42e3e3c6d90499b777e181729fc0f4ba4ded7ad8284808370d92bfdf75646077705e335ee6ace99d87ab36cf3ab5d870f87619d01a751303ecaf43083e09488e9261ed1cd3af01f752d6cd3201dcd22a9c69870ce9dcabc832f49babc8d41917c45ede2a0ff2c07d28f12b9aabe01b598cc9d02a9db1704b65f548ca9d563204dba8c9e0cf641c9e2c189dcf5e9b5a9d9e67c56a5af9f72c9fbf20ea8780bdc56d558a1094bd929c304edb0e8260d52aba06d20d3660af7f9451ae31e2dd1e3ce4ba43d333f2e0d293e086b833fd1b1fe70759c9f4063f20251ad54b20fe75ac27f66ac46f0c8574e9d5ebc7023d8cde3295360776a3a0e9825747df0db5821dcabe358a501107d68cf241df51dd2946008a0d7837315d8feaa10afb9f7f1ae8adecd8c85b6af251ab9435761211f572d7ef31660e4ebd1816986d38efe6ca3b6904e7370e24e0f6bcb34cb3418e0118899e61d626ac264c896ef1536936fe9ccedc94d2a29bdc562fd021b4da04f70d8832b6a0e275fb74a88e55fdb79d4f65c0e87d1b72cd85d90c2478a692fd585a4d4d8317aa05260681084410f11e1d3eb498fdfaf104e55216a7c497f447153035813d945b944709ba37662f5259077414bb73d723d39279428ba6b4c4faadc50dd5b871293f6817ccd400b79bef0fe066db70e9763559a8845616bdeeb98d9c4dea1c733c40f70b8d70106fcd047f6af8c47d3612032dee5aa26fefa6c64fa2e9bd2e4dc476f2220edac49aa0b4aa530f390d6108459569e49053e4ca355de2fd5911a21f54dcd9222e310be31c713969c76fc8757565f8ca46db8fb2b9fa8710dd28dcfe46a1878c396b333e4b08d174a2c7e2020ddc6fddf97943f8fffd8a8427c096bd55a29ac376e7dff576c177864454cfd519661c164056e9f7f249c96b16443195113c9907c9a2592ab7b64b55cd72e3760ec3e5b1fe342547cae2e0deea5e663879a9accbcfb31afc9be72b9f17d553070399b4dfb318aa077932f21a5e32d7f4c7c1d5b5a27837db10858716f140db77fd154b267ff4c4c691d7a2ee1fded22a02a412d18f4942aba30f8c8356a5ae02f9cec848240f2cc76f146ee3bc17cb55de7dcf673565f1ca433a928fd0d19f149d3bad9472adab85bc5bbe5738d6566b1362553f949507e569a6100cca3586f952476906b192f428e9bdd6a96246b74aed7bcbf48412bf22c7a28b540c98867d1a3784fed956c33656c059f7932f4f8cdf2f6dd54540b7ced04a01e0886315f8c0e16ebb20fc8d2dcb2d01c49eed9dfecf82e77b65a0e2571ce0891725e6cd98a90515f04af744f15b620e5d1af204b00e89f6cbb204d553f6cc51d4282d95c66f48ded0ea3a5c468dfe7abbfa1e29fbec8cc631038bedcc1d9c3218f714aa9dc35b0456953a60ea889c7fef485cc86285cdad73414e7fb1f100710ef73e5f37020e3094e148dbea49af8878d2b3ccee69a0d5d3802a458d809c57137df7826629bfe1a6966ef91b11452d8a246dea3e21ab8adb08e9eb272db47c6f9ff3549307ed91f2d9092a3f7b8b998d1ffcf1f0f73c5facc1f78702758bc3bc4674ecd5030a7a77c4ae8101a05e45d268bfc3bf92475732a333341349f41ca8edd94c55eb85657377080df3c8edc76907d3947a4ea3a2d9afbe8bef0a63eee500a13fa4e898fdc88c140475fbdaa7b7e857e0f5fcb1c5e3fff44b2e0c72d94918d4773a857eb0c214dbc8adb31c3a520e23e610f9bccb333bd91ff9d06c6ab6ae1a2b9aeae169f9cf4708b1434468a56ddbaf7b5d8833e949b14dcccb3ab395ad8038148465010d83fed923abdd93fe1bd1bbe70f6b18c00054823b7a7c4abf9c52ca4881eaccb63aafcd0eebfd2a08e47e3f718107cd57c1e7edeebf1b482ce18d32f2858451b27fbc5cf4ded961bcb75762a1c5e7cd00d569c11835dc2c7235307cf104c13335271c3c8198cb4f4d9f0391f292e1e5bb68714c282c0c76af7346f973d064b48392fca7d9dabdc6244c66b4c20431d84b5d2e5074e1a4b79fbdf981102559ddc686c6f798a5a0b9a0f015beb23c1cc097b2f15a7b0591942781cd81f79d1b7684e68e12ec8935027628e819678a57fccccdf58eb1ce17e2386082d1649460fc50944bb929599d87f36bd487e0bf27438eb8c24e4cc7ec98eb379359452c6297a72533f973b1fb934fe8b9829ee5a7ec7be4c1e186969c508737672bc752370754cc1d725f6d423ed7fb3a322ae72ecfa1422b6f17fcfdb391f230f83fb436ffa8b1b9486d15da2079a3da3b6f94932a60c503c977a6d6883d97aa577d716cf3f394ead0a1abb086d66c1ad2249ff4c93d7044515d3c9a3898c5a74823d1c2d762f6a9fa221d67052ffb5c6ef3d0528204f7da3fc01dd1d467437d9b2227b3efe211de2b8ae3aee532560e47a8e90b86a08327df2bbd46a1f6973d375f13ae83c8c205145309c28123f810c57c8aa6fc5b312d801d8ac8dc3a8fa4be1f361ca4c05635c890f725192a85924f1ab400ad2c1b2a4d30755606cff332ac0137fb31405ecef0cdccbe42dbc4e29071f19f5803e8e84bd6dd67732decc28b1439efc0d709980109687216d5d72c6a8adc263d58becbb49be31ede7bf0d520826253440c5d6205440b1743a804cfd9b714df6f5f0d4ed86432b76824390be356f9504aa4e16f5b3894b324a5680a80a320c16b2126efa6322e0e4639b99213cdd22cf0a7b0dc4277ab43f208132a32219663a5f51e2ec2c959edfa8ed37d2c08723857194cec9b4305aead33819bcc5b80e1756834d935ebc3db646c95fe5d0031b6b16518012d7d60eba51b9094f8c55cd93df74e1d51a4031804e66881e10d70c808371c574f7a7c4238e421f9a080cd7cb7a7851b1fe43b3b943f41397b91a8f6dc1af14cfe7b6fdba8130bbf31f606d892e48782ed5a460faf9cdf0611ac168c98dc4aa21b7ccb5dca34ac830bdd489d25dcda7de8fbf3f1f8e210fdad5af8d041d4852467b8539a11bde0c6405da82d69335fa27374c148c515c6cec7c761218d4d027983d813c6aff3054114ee210fe5865a5e01cff8b49be9d9b48fd0e1bae4951cffabb6226ecbf126bcaa6c43065037fbba266e8cede80774b795a5710651c31e6095ea582556e91d2f9adef1224f2e4b02f5a62c8011b44f819ecb5fc71c74f959855249673bbe402b6e0886df2bee2eb2a2b62385fd34b5ceddad2b09b8974fe5064fa3fe41693ef41ef3cb3146be5da492a161e2d349fd1cce4fd1e3ba5ada65e35cb0fe56e5db3ae0eed17af45030653c03c1c3de9ca455d7393abbb37bfc1ee46d41459091c210e88dc5ba9c89683e11d90e6888cf99e481f0b0610cddea6a6fda1aea97f56ace647a2bb023b14c2b7770f328679945ac22c0ea870ab33beab9debd62c6ff6f2c1ea92dddd34b14f5c50ecc3a1bdac7499ada0756d358d77776dd83473c9348f8916101403a0bcf6cf2b35687b08d5e7b97121a7ed26d22c6dde0a56b3b7d120ef6be71948e76d5c85614aa44bac7a3fc8cd75cca81ff06009f52d3b02b5538f769986e8e5432dd39e6847797fde639d624c1e9e9bee518d2bb0a6fc8282ccdd828a4ce1935cbce8cb0bf5396a95bfb32455cb25c01db1e159c08d63831cc27b97084bc1a01121fa521d1cf4bf8ef509e59a46bcb7a514705acb7c665661e9923c806f0d46a148d86de2d5bf290ce79612f43276bec03fd21fd734bf4b3c0f5f9152652f88af386b3ac63d8bb97cfbd2f7f57750a6977defdd9921a9804fe9ab06ef4b35b28f655ec53385a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
