<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf62d542ed88285f4cf3901f85fcdaf1b5b3bfaa9d7576a4a38148999643797872d327f1ac887b8f9ff01699ac3682e6b03e16cccf577521b56c6e6db33505b12ed114636f6bec7f2fab4a6f2e20531ac3d14b1ef37688730b288e893965419d829a5b1e8fa72277d519eb3ad44310f841e6f058a98f932ca53c3582a2077f8ab261f7f6ea340aed5ff1a00e276067875bf04a5bb973d73881bf33e0a9fccb20517caa74eef0a4419320c010255e03d5d5cb8481c9b38b6a17e4c060244a0505a8892b5e251b5c870134b918d20149179a92cf0f504dec79a384851afb42b064692efcd7477c904b65181ac9727e38bd0dfbcf345f322e7d2965b759a2f9bbb81397a5cd253c92c4c6f22f32c709c74e0660c01036a189ed4d7251b5c70fa7e60feb2debff01f59a1a3251519a2c22a2185c579d0319d25a48492a9409dd289decd4814622f77f5bbf80a52fa800786fab2351cbe3b132f4ffdd0c82fda7aed11c58a8a91cc145ced728ea3e604b0979793e1af9e7d0b72fcd384a2d5a9502f0ce2812b0b6c1b7e94e29351dc54b0d4e6af8761df79c8243f81ecc634b15d57ab9e1bf72ece3eefd497fdd1f7eb5c1fd40eaf54d1cbf4d315db7cf4f6eddb84bb52a6775667726b853263dff7ef2153334accfbc35673acf4aa8f3b4e76eb01a70d380fe024c3f8eec4c4f59daeb720a099a3c3b6c4df17d5cc20cab1c52582f7dd2e6f90f282ddb5ab2639f60a1cb11545efcfea9d5336c050a28500d0eed13d569de26fd5b80ddcc59218537c2dba4aaf191ae1ebcdd247045aef22d75ad40b2bfd07e29c45a99438ded328ead2ca66e6885f4de04b62087491244bebffb090aa2ffc5fc48c2654548317a422ec6b05c20b0e2219a2717590afad5458e662b07fdbb82bb65eba25cb088e31aa494750a938dd2470ef232c5fa51f0d2fc42be145d068aebca03a8a7ab9f1fcb5da1df0c96ab2e786de99ff1066619062cda2b65168c15ba4a6ed9cc422f2e78e59beeca3a7fd7753fbbfe66af80fd34f7c1d0036db1c395d1bd0b7fb967ce425271adb35fe590e4963ee56ff48125388ef394b707dad183208ffec1fae9527059bd6479fb4a6b1a5575fc6aab3c51d3b64c0464db7ed153eb210a6b265ad05a243618be8dc222bfc0411d79a73b9110284203d28246f0b8ef7a8350f773556bce73ac11f1689c37289e37f97d78aefa1bea82ad9a5019548dd74749fa568350f90ce31ea04c6eb806472a3848e8369c006964674dfc8ade363b86e0b7f58d3e42a84824345469d136f6553d56ef58c2d1efadf80ce6f80b4ddffeb04b0ad78ca8e213f2c9cda2c85b2cb679bd69fba258f04da70f6423e760424a53fcae9c2bfe64bcb0921d8c602e55689736266a8ec4d1ab67bbdc8b5451c7fb1f285571418a26d1cd528c67d6792f9142bce0e8f900304ee433c5cd209973836e38e3e814ace37364a78ba0d13b5aa4bbdcd6b9bd324122a5751ad604efd463904a466f6e9a76800f5c55fd2f44f21e01b6b2a9e133cda8eb241414b6fb27d254d4d3c5d9c93d419827944e332c4fd4942bd11fa97b1731ebf21f2fa200431e8d26345420836840160a20fba4098f8b08c191496b911a6e6d595c15b9093f78d05a49dd13c81c584aa384eb77698ad93519d2f1b28841202b4bf4c0797c81a2f7e4edf7eb41705a56df8e1a4bd2d0dc6fddfc8d623833137ea3d617fe408c9f6bf342f62dac4586dffa538d0783a46527d51fba83010e649481bebc1dd270ce20f1daf1622b3d77a383bce3468607af33584dcdd5e46a94e3b11b3cbee1573991c7d373435d5be8bf2fab6b5bb372b1cded58c2bc9c33c20735b399ffa9b324280a7a87f4495fee87415f646b7281ac5d4f9ebd9f606b0171f91e8734097f78af2fb99a90f0e8a9b312d983211b75f13af376553d77efd9d09311ee94f06a2110206cdac2ab8dece02d02b58ce53fc0c007e29bc4b210e1fc544e2da1df1755bd3930a4f47d33cbed95a970a483e19b831ffbdc00e09bfd177757a220ca8d5d2383812c4721f0c9a041ccecd7921bffa3808b0f13dbcf2e6158abea101a1ba7ed388d1f37bba107910ed4ac8999a53516ba376d25a513bb91a2518bbdb098a6db5773d504229fa4cc5ca441f0503773ce5f228273289a68d391a1a86845d3e286e8556fc8932dc6b85002850e487b9752d00f3f1523644ebb2abd487c662e273c60d3e2adf4d6e7f2f1e56079315571debd1a5a87fc73f4f0f86e02defbf76310df12e87519f4fbccdd10d653a4922a8718bd7f16d1d5b0c83c85b93c361488bd97f330a71dfc74fbc1d8f9337ee885f4e933920ecef1c62cc730cc3f5744f4ede9145cb3833e8a5393d5c63590d0133a1093e64ba543a1b6b4fda0722a543ae715f29f2c31f64af7e3bcc9333f5539df19c1bfd733c0918e0c58bf5438a859356216520254a46715eee1a6f9065c7e1ef1bf33c29f5333ac0ec2b218d2ac99d9d0b7d12760208648fd233cc6a6da0ecf222542f08fddf401bc6eb6b6ce4783ddf188922b8dc6cbd22a8587172215f5a367f8e59be7c0c0eff7eb831a7729a4b8fed774f6fff7f47d5471bedf2382e8cdcb75e2153b8d5d3fd2b4f6f8b8fcbe37f743d1fd0b4752950bd952ca987a956e1a69dbdf81c14fc5de077e7ce376fc4598096e3e02dfa24794d31242567a070765574a77acf893aafdd18476048b95cb2f5d8ebbf8232c79ff8796fa518eb49f9042c5af3e505d11e0db60d26dacac27b511578cd33ecbb6b8affe011aae9871dae92ea0cff5e5bb4cc98ec48b772b33ee9eb99fa2f58b8322c2c7c834b5a1abc1afcf5912d9f955610c540c3e8bf14c85d45a6dfdf9299c90557483ed86d7ae13c8ff01042c7158a680a0cf6da6dc94b5bfbdc0ccde597eb08062e685984afbe8d2dd69dac937c8492ff02d5ff0d0f980f295724a82cbdb4d60aab0b4d22eddef5f462622ebc81a1b060d57785b5bcd375e2049ca5466b9624b7f38ec781fbe340f6242188f179f2f79e29ad0dedcc754d9302fd9a49fb54edbbf20d36b0e07ff3b6ecea4f6bfa20640112399cc392360a18e41944a1b7d2a4c32d7d9978f9c39e27b1e5b53abb687315ad4055f499f16078a71efaeb5f4673d2112388595c114b667777726c0d5c4916ea5fdd04bf3599ea1c530389d389bf9f86ed73c011d790af21b62d9fef46eab05f985119a5a635dddf384ac97aff7da35945ee8d963361d78081fe07366673c293cbdad341320b36e8e3bd46b90043736c5939d76836fc8b6b98e9a1eb4044772c9632e62bf69ee0107e2c9075505b8acedde48cf5c5f94fc956399105b8a91952fa01425cbf5ae6b3e026d60fb9b1e1237b112feb8f2dd6e18739ed7036e4e4382279f73ebe45f72feb51d2302ebcbf75a3602398e59268312651c730a6fba5b4cda9e9f9062d8b6df6081ee022e27e79a652920c45c0d3b258296a1c027ef96afd949e264d3b4369c5ba3fa7abc6cbfa8dc14db7cb23bd39477d21c590ac5f5882a8fed841342e006793f89e277ee92a3acc49f3de39dd5ff77734d3ec6bb6a275b4f67b7b628bb828501cb9e77d4bc4d27680c6aa69a565904a33ec002ae2605281048fb1f5a569b66922434dc4a1f7fd27e9e95399bc93720030233f92de7b43b8fdc7e7eda776ce5f57e90d3f5a309d74a8ba7baa96af6fbf5ba12568b11d5c7f8bede4d14ba3b2527a7b6ae730835fc11d117adcf82774237dedf2abbc4051e16a97fb2785704b2e4149885afcca38afafee19993ad09ccfb17af8262dffc293ed08ec7ed2fa1ca902087efa5eb0f98f4bc3cc391a1146a84853537ddb90732110885f4c5a1e8a28a4e66bc8b54aa8dbb4f668ce0cc4d0f93ff8a65038da24c1fa228f9dbc96b36cfa249f0d7b5506de4df085d02cef9302b99aaeaaa60671428ba81e5a8b02b34c77eafbf69c2a191c31160d7cca37340c8cb2952d4c99948de4eaaf57f9b3c56326b0cd647b1525f401a78880b1e94ff3db7442f111ef239b8f72865474eb666e2fcdea97cffdeb6aa8c3a65c972d36dc80ca87ebc31070f286039dfc756885913f31222fcd369f539a64ea62ebddfb7b88a98e0536fffd106a6433cff03d1d95df0c58bf0d39ab0354474da4607b5d78bb0d90cabda7ef9abb57ef5feedbeac6ef5f2f82355ee18cd71b6a52dc9acc0570c8cafd0aad05958f73253231a52d96d868054d657a80b98193ce85fdf04d6c777b0f7e7eedcb12efcd358ddab4341f78bf8ba15a18a04d1c3f9512f77701593800df32d481effacfcd05f1fd1ddeb48cce6cce9f261d4a3ee8d71a59dfab259cbf912f8972993bea719ba79ac84edb6e1b1c4b4ccb310391fe5936a3329be9c7e6b2888302fc231f4c0e508c78c74d332f6b5c976d67d5f801c70538513be6fd3f726664b90b1bc2061b9084627e44a1c074e2ad5f98eb03edc097fb9ebb95ee70025f175f2934f9dc228043bd05670868b099954250f2ab020065bcb11e1e334b20d32c25ea1571e792519ae3e4ab3f8a8e1d55501a8696bc5ca99d9673f660d8cee3c4ca2fd66538c2939c6c8c888e0e0b1b44c63b2cd15ee34e124c537e0a7846fa7e16f77234242024e54824add226515cf9099ba4f7f22c273ab614f03a905a5f19252fd88bbfe443989fb41d4ae4f41471678545bf36eb24be5caab2ab94e7cfcb28b0616bff910937db6361d180669fc6e8b4463cf86faaab874a4441bd3ac2fb962d73443d504db4db7a329a9baa6e8c4ff3a7191b6d2d8bf7f7e97f61bda9e31d4edd7ecf3c7dabe93764a00966bf0c63117343fe513a08910dfeef654ab456362b73bf1bef4b6067c11eddd228550b39e4dab150bf1f6893cc934fb15b9b42350684a778ad44698da482d36a8d2c6e29e6ea9ee65ad22060cb351cee93b6592a7e0b0859e8c6a5c15b5147caec3d354f3f12ce0563eb344d7ad4a98fdbf622003445c068c0a0594a2863d408f2c7cb9e26f15b6a6a697926fef030181a388ea1db49cddf956b34a15fb92f28615b4dc0851eca0cd03d7fe8097cf79ea78216f37bf08497e51ad32959bafd25a1a111feb4a4b1c8274abb213c60b3db1fbf080a49a97c50ee8afab1e8349eb80315eb2037a01c969675f23b499bc4c6af9921901751094474b022a3b7cd6ba7b2c467197ecaaa7df652f500ec1fe76243a2f89661bf8e9bb8d9e85ed7cacaad2442541a64f5e95cb1c21c5af54ddd65cb05c727a47cc92836dacbe7fca87f12a9fc30ef0133159e38de47ee5ff96143724c0aebe0db4aad5f38015a33f91a804f926db98c8587668874e584ee28a52b73dae3ccbbb3e590a12bdc84428f5acb4529d659673d2dbea05d3d5bb9475a6a374b7fdb2810e4331c192864057af64d30e86f729c18a8113ac97aace0c8f4e6b09ec8be929392462724ac22102274589428f461a30a525ec934ef1374e78bf9caacd915124f95d649b4bf2f526c13c0b9cc45f0c3ccb4e9e327db4ad79cd99342c437fc951d324cd637eaef1f720833da27c7d1207f93f6ca1a5e9ecf0d5bc880824b005b108069154ff6c47e73d8a68c94622d87ddb97b9a739052afb4fb8f1ff78aa36ffb67edf3d040cb51c1cec4ad190d8d10bbe78ea5b4dd041403d925ba9ac3b4fc91a6fc48060b0f210b44b65685fdce0dff50cf05c8d1c25749cfb6c6d74bf4459b241eaba22c24d466c7b077757e59a00e2c7d2473106c79254c8e712c12f533c10f4dff5438bb8437ec09e9743b1f5c413e2353260d68d7c92a064a6746a8ca8e0e0b5b72389a3e60bacf4b199b888a0449a5301d8af98c4e5d5d6f95fbef294fb392dbae118596899dc90231d95b77e13c9802b0afd56d1eae23f9fcc78226e469c4d4a472376be4ff381c63438ba14d1bbd29a571bea4deeca812c1059e0503ea2749994a5b254eada307b511f7b3c5f7c39bbb236803f0c5091a8c34bca0ed62dabe666472a7dff5a01e802f9be56313b6db028134e1128b0001ec18d91e3532de8c16ebc28fd2151204bc6fb58fe633020393cf8e3856ec4bb4e0da5685d396793298a948ce9aaa396d5e7fe1f88c25696a28e4ffde6a793859e325987b13ab742a386d78d1e00ae048bc1e81b9e5326d65c1c52293197c2619c7380583f3860759ec744366acb1dea65ae8a0d51aa803b3296551933906f422f332f2cda2942de2479b4af9aeef05e9821a4da12c78d20d6e43f8540b246939538ff960aa2b3b8ab62625c3db6ef48446cb2729e010a544ba1b25f6c53cafeca8174011a90a0fa245b1a4ac99184c30a7267df0b66849176f29444d185a8b93ff52e4ea2184af69b70f03cacf5b199013b33e8102163487b18d18dc30af8bb354688fbcf4748f5f999101e5491e92b0aa9bf9c99a6b6827317e4d137179af4843552962ccba07eb7ef14fb9ad3d982e6cfb63ffe9c1302355df7f655a7e8be1cfaef2d1977e60d819621116f9f2a3422217d479dbd104ffaf65bf20f6a6d74a1e746e17384249b15ee386e06395f600c1d35b07fa23ea5b5df0335a8cc0c927daeee6b8e44d712f457b49faa36d2159c2dae50aceee7221ac9053a675004ae8d74bc5c14d911216edc0e6ac033ed3c662f8a66dd1e798cc90dccaee14577ed1d4044fa2ebbe24d699eb0f0805ebfd0fb76a1b0ea7c92fba98f2dfde7d2b252d140c061992974ffd026ae00af4e0655604e7e2f42a257ab851fb8bcae9536c67ef9e56adf84d9d3a2d0caa726eec0cf5bb384d3d795e789d9ec7f364fa42364125dcdbc947a20837eff251c4f909d369818330e82301906497c38b6f116a7eef03a886d57168682b854dd5a0d9f797617c183e1783278cba4ee63e34bcb977159bf342755e4dbabc9cd588ffdb7f86387492497f7d8b87653b7ed16d1a3f8035110fed93a5a2286947570a05f58a64dfb9cb0ee1107be9dd65d00b5fb9029259b41fd5f5e252bde52ff4db1a0c854fb4c6d2405ba6e5a1510bda9ca6108e444ae6347bf44aec2f571b99d3976f9b853ef5843031c776b46e83e8fc1ed08358cd62ed09dc7dbc7ca94f3686e2744a8af01ef485893f60d3c7d761e62817cac7cdd54cc55667a4f3887a14184ac65a4e099065ba2ab78befcf9da6cc8d17bd8d11809e3ccbef320222a19635f730f637cb2a3fd8b214ca5ebe21b608cb740ebf7ea8cac4acd52c4ba64e4e31588ec862dd862e93691080ab8f6fbf0321c513df3c0f991312a30f94f0cd47a46615d8a0dc82b9e064cab1144a80cb09605a13e0deb3d6b441f2628d33b5f473e8eaf48192e0afa5f5a3fd7b0ea0ca375e929146a13304d380c375ef9e0e8aed9665ee1b65aad17b7620cd3c7c6f6ae5b5d72008087272d75ab6e9e62bdca238482a99c581cb8fe8e17f87732743b76e81e62b83468b610609f1d4e50fcf4b34b9311daf1c2b066abbf7cf6c4c429a9d19e1f9163c632f16f530df156f862387baa354f9789ca09ec6706d4e1731dc118dea04a281ef41837d06ca7b7008b45ecf6c9178852b4721bc4eecc59fa6e72cea65a923f1b46d6dac3275ba3e4d991ae526b7903cefb0e657a501d9e7946424e20252ffb0670d3dee59b09270afe6719992ba578bfe35670b0680c1129fb39bc4e552adbc77d901c9a4594bdfad840350de9d3b1ad8e97964246d29e5f1e496cf38a0208dfbb5f173176034ab3b6431f288cbb5898448aa3313000a128e5aa86cf71b9fdb797e94a31c4f9edf0a709957ab068d773d6a37ca931472d3fe280a477248621f4bb9439692f18f1085ebb20011ed2a0d25e73c02ae0397aa690463ae541a9502bdb0682b24c99da49f8ecd6e5189026e749b37a13dda37c29c5c7006bc4f8ae284c381cea832714332f8cf5256837981f792196ff8e3791965b676ee7fad82fd4b5f79385c0f54b81a3c1b4b608820166e0ca66900db268bd4e3f11a6f55abbcaba707c235b886f701d7dab04a85e7a5f9372a6a55f16405f9b7e4bfdd8e0b635393dd939c6511d5ec18cf5fb6de5976261159471dfa589a7a0511321328b36e10114ccfe31a770129dee608b7447eada72d1c87d281d6b14520c0739a264c4935f6c91e24917e307c47ac8e0aa35986d1436ecbc8f0edaf03c1d4b7bb90ca690e12ec97150b725655901d4b8f0593a43ff65d810ebdd0a09df7da62068f46c03caa03fd436dba51c06aa7fe6b8c8d1f195be2898bbceb2f84fa3d224d62ec849e7a61d585a885df30287f2634e6ca5e88a448bade97e5856c70d9123cfc347520a9019a825c67ad2ba86ebe8dd47e0a7f1df98a67d42a94f0569a4e89e0f3308d4bf2c4087417fb24c502f2c58bddeeeb3284f0d1c391ce80573f0fbfa5c36dffc44c973c8951877836f6f7ff283b19bc5944e2a15c17c21973e9c89e671b399144c8b5199515fb2e64628f4510cc24f8611d2f7e8905155b852f3ca28e081c6b47def27c8477f4b2ceed7110557307d5a041bfe91a8b244db9131e752cff9a9d00a4c99d7c871bae48927fe865e0e7d2364758208ae89b5eeade383ec89522f86f46f25bb859bee1f8b48ea513aff6b172019e7f7c6d9d2606644fce47379e3d63a2c6a5341d982424dbdcdd667dd84a710933b42a6bbd0700d2e0bdde8e5cb8279455f3126f0a74aedb3c706170304e39998a584444097d8a6c7995584ed4709fe7e57c694489ecc85e6cb4b04245b147939d15e620b4ad191dfaf5ef698e6c172b13245e4d3c838d3b190004cefe427eb939bad0f827bdbd4217cec607cc712182965958df0787ea4a7374f87758be611562c4cbc1c137f78c2d15c403e8a54dd755b3f3737614fd216a7a161f58128e00a7e97ac993414d81885a6906d726010ccd860079997feb69e834e29f7ef03bc4c81bdbc1edf580203cb2d5cf2fee1b9ddf4e1d93103d354b9c97940435b15a6464f4a15b0b9288a3cb02365baa28bd52a2c12d405b11060f24f7381521f7dd22b3f246d4e02dde5b970fa75c320bac60d1be34f7f3ae56e74e5c0ffa9d562873485aa58c4949508ef4ccdfe26aa37bb719a19eca3187e8d409e8e78c393944eae1870b0d217dedee71d1775dc7c0f31661494cf3fd126809e561672358af1324d679ccb79444194f0adc6557794e298d442cda476e15a7ef3740d13874c217220c8d74f3c94f9f17b4e78e62436668c53ac1a70100900402f11aa3604a30dc91f9597608f895eca3d265d9212acaadabf8558b1c42c181f27073cebea898403b079c9191824acea44cdb5f19d6a8ed54d80106fadab194adf180948697dec6b62c18984dc40b8d3dcc7300057afcba1a91f67baee62e175e4cb6403f8c029931301c15d06ac55a46426d321fa0ac37ad52a55531ad9ca80ba71a9da675a56dfd2b257e4a4c5704f3f6bbef2990cdc7c706502c060e095c22b942cf7be7abc40624eb42588c2e126d75299ceca079b767d86c5a66f78643f66cbee0eb6d0ed990ccd78b2923cdad24497be0caa309c634e816ce48f6bf73ab6f8b3c7369319f92c5459f54e5a193bc750dd088cee66140b8dc7600b2a89ed314e8351daa14d760a35e0c1e7b21baa59f8eb63b42492137f775ecf15a214e032c1aba33a9604d899c0d1ffaa6bece747389f5abfa53cd147005e617fabfe9bcf2a5af5bd95d1170c3cd8f105b2c599f30aa9f4868e413aea82a17301b9a96185af38b920b58c94a4d49c823077af321bed87b6cd4c815b9d4b883cb9488333bb3c2464c5c4cf0f882dd1d67a90912a6c83554ef0c7edf833ddad2cdbd3525d1bd24bd2975b01e9fc97ea0d1561e2806d96e8481f75ada677e28a058270f142d3a0b7692c4baff8c5d720b33958d71a3cff99c08267acca275d86f95fedacc2e4f3deb7c7a16f6fb2b95b17deda6df7308250863e7bbf04284bd99f917c341f1e2a5f9a0b2175b92b39d2429a6f9682c986ca684bc69836e69a2540655e31f135a8f9eabcc723e95aeaaa79fb46ef58612f6b02d4c9d1263df75aceaea6054709fee76c7f3fdaa4b88296fc6a313b1554b10b45b8cb4396476d1d44de49a6577c1d590cb7de031f12c0b23c16c52d8b322207228a6ea8416f3c1610fb2b99b6e2bf3f0dd96cb8b125a3112e91202bbc46d2985109eb12d9326e96e0ae059695c544b8973e07c4fdebded9f89b9f70c7b4a3790f2f74bff04601a1d9947d4a892f3d627cf267cbab427cb0402e18f1332e92e7c7fb121542a78fea9a95af05acf0717c202a3aded5c0e1b0e4903c39da2ce2fd9578137291290b9b69e09cf81a8f75e416cf762ef8ca39c4655560b99383fca32c29ae8a850d77b2e9c891b5acec6ee706ce59742b67cac522001950f673615232d653948a9d5b40cc269f3dd1abf9a962d94270a9e1d0f10ffd9d1edd29c8f138369c520f93183dbe3ddf57c263fd2d80b91f446048d3d33c647a13f9d514cc37c75447e434a31f087c26d878966194f52a18afe19306897cb3c20d3e989dcf459c3ccf04b7799e12b6eb0dfe34a61e23191f5e205d4cb4c774e7fbd84d46540a79063d3551c86ff2f21b9480c68abec87e559d6aaaba821d5c61efad1a68bb40499a4c9db8ccb2fd7477007407332947a3bf6a8be24486c2b650f149e11043165f926d7fcbb1d8f1cdc3a7dbaf25e2ebc7de9dc80da1915b7e10e34aeea6b1f6393fac5ced353012414c141c48d839c2f1ba9b6e9efa81b1a635b0993e7930b556f76c53c460e5389c77d20f77e22967aba5328946af4c7fdc0d65e471ae2ea796c615a7cd8f65aceb8fc7605bfea83a17de8701eac3962153b505eabb6eb24a6beafc3382c140079a4a487096f77446541892a9f030e55a0e489c42669f34ef7a0c1ae30da041825dad6bf2492bbed72a808899235cf44d896ecab7d47a03a8820b9bcd1112e97095b7d21a221b2d6bbe6b021ba22b235abf9d2469127201c4e01de45a775e8801048cb819715b19993899cb315e15d6cd9a1c21fbff6d2e0e46148cd2cd2450c5b076a6c4bbb7619d449dc6b4c88814016b9b46c99c8de58710ef406d2c362859ff122d7d770ad4353f8eee6a216881e0d033212f5557eae9924a7bb60b5d5cbb18bea16394cfbc15b01a159e6ddba35bc544474842034a59dea6599f5a632af3554191d444024716b7c00659c52b637e01b4ea7a32b9fb6fe0d3881533835a895fd13c6722283e280f4365d55e7a9e4e737cf11ac955dabf81cd7d173a90500da77fd3e6269031dcc817852eb0f59168f2d2015687d2e01d8189a1a42d4afc94d066856d233c29eaba3177a349d325e1d91e0cc69de1e2e3c7fbf7303b43eab61aa70222248cb219cf2169ea386798441957ff85f59cd36d984e2c765b0e9e9162089e2d53b0001482fc29612c7c4ae937a3adbecf03061d42a5f28f5a9f3fd315ed6dc836334709b7825dfaf25eb8aa5ecb026698d2d98b40ff665307c82fc18f86f42e96006c7e367c2eb8d57c4afa8de76468db7172800c1bbf4a7a470e9df9dac9e896692c95745967d184fa88d38a84088ac4c9b71fa0b9ac31bc6202d7fc659472c085e2bbaae3e2bbc48bb9cc7be8b1966199168be4c783afa66c2b760aef0e95dfef4d0737f86b5cf33490e7d39f7b2e41aba44308e8416057eb6a90191ce71eb3ae030aa6c2299e2d50f737bd92a815c04571ed5865fc00efacf887ff51884ee7526cb19a7dab6954da0da8c69b5183c9ed3c197284244cf65deb27c6e5b422ec09c8eb7fde813309f77a17e6d6a9dc3b2e57ebb80407f7c3c1ee3c3c02d695e7c5b172114c7251baba8ccaa944c26308ccea60bb95e3fa2f452dbddd88b31c16ea1e02a81a4cb3cf01df390f0603e97629d7a8be0b8b5c3ee9abdc2e6999f5a3bc5bb719e58ccef21503fece28f5ad7b35c7ad0d64a5326a10b09b965ea700e9d3a1b6abb0cdebb57baf2caca58cdc117acfee45ac05ea148f1a381f055c864427d48802a8cc23afdc773da5117b2dfe8cf66644e1afe48bcee2a2f96c91fe91727a56678e691a3e9fb8acab638d83c08bb2e46e5fcfcc669d42d3630eb2c6459c55cc20899e32242e1def0df622da24dc9e0da8811497a3c49e83bcc961523d7e4116670ef487629a9dd5d945e88b7e711e6bf7ff57307246b5cb0560b92844a838abbcd36a96591533c9d2bcee1c45cdd384395847ccc79d115bfd7b1a8664e52bedbbbd15e78082cac21f9626351d5d82599871e69255ded67c2f79f9f085712a72ec0ae3c22e93e55756c2aa38a17334cb390790654804122a850b5ca5347434e28df7a250b574ecee92a994b84000eb417cae4af3afe6e1e6d94b5c64d96e25544b37a87811877f5a26bd42db67e8aeda94471394f91bd82e3d3a8df88714055e20f05e7db6ce2c963cca11b8e7204c44465fecbe660a14a71bb1263a4e6488eda99446f44c369b37294c130025ce80bf5ac8bfe97aa72f43e5c9d9549c8359e143fbf938eb572e7946a832ba9e9f30004926128fc3d6e15ab68f33f9a6db20b3cd6ecb24f3632a0d10d142f0e8edfa98d47c8edf6038ee9dff86214275b85931857b08c2cf82fdf555993bb423852cd396bff8194dd270c494e2c59c267aa84497b1b95d6bb8e77555456165f06fdc6c62bb0b8284c7c31758d9e46e91d57ddc59d46b0dd68609272b1177a7d6fd6dcd66da76561702467d955679f4f4a849a3c15f2803bfa8ea61ed5548b7ec0d822693c8d528d154e95bc6945268636ffae510b33464e9674fbd111f41fc3860164758521cf00ef01bea80c13230b805f2204ef11ee0c4fb0db1328a0889f08092231c305b4755a09226c88a6aef45ae0b62cde2ca6eb75bae93edf7b508a18fe6bddd60e87c7ae9fc73d07439280b002262acc0b48f8ac334b0a14e97f8af93f326d884f9d901a2172a210664e0b448840a946d36c35884ebf0783ba876d1f5acbfe2a2c46359820b3b6539b21c6b6bee220de87f53320542c5e7ffdd3056a355b103a4b4326627ba878520bb0ab8472df4cf9170f6dde1cc64600830ec2b5ec0e9020c0cb8c9978eb1f80e8666800aa7b7f56e123626f839dc419610914066477a94e6b262c761f72ad3000dc2805bb209474a81ebc5b5e317d4051252dd5c46ecc2f3e68a1851fb9066bb4dc30ab6e3396b91f1a28c8cff2f543c6112cda8ce3e96d11206b7e78b3ca72976f1623b752def97825607d2ba163e325efd7a00484c79fbda32fabbc5655ea0ced6d44a4d2678bb0f79d93869345e5d1be1486b71171a1f22d19ab80918f3c73aa2c260345df4009c82c64054da3c7aeff4655b3e8288c5c77410da7766bbb0966128ac1018d5cfd663ea472d6156e73a14426dcdca3721e6c9edb39d416ff4b7ff38035a34b47f6d826c3bff227b318a8432995a76d94d663c915e43d5f61d55fdbb3b09d458b25a74d7397bea927d683c7e8b6fbc166ac5d3f2c5a543eb5063d18e8195e22611b6207796f01ed186eeedf1e33a7001acbfb15d3afddb8ee68e2a690a12cd0a1a5786e6b298a9c5f3b908a94acfaff6f93cf72279772969593ea58fd9265b09dcf549b103b130b69109a60041376642d96e69a5f8575dc07ed95cfb6124f5fa7def8ea5255c0c66daca16c7bf4616284245e4276cda6514a4cd0e08513c5a831a34266791508d910d7a8b5d6c5a240c6505848c1fca05763bdafdc96cbbeafe8b7d34031561630ee4453a05ace77d0f26ebec1e983b1361b183dcec6c7e427399c984690be6e59e2714a6ced75d6295f73750a4e6d12b5bb9091cd14ed04c7fba9a0e12dd0fb42ed1c891f24d441287ed12d8338077fdb48bbeb10d95d87469d849a3e53df3cd63c38bedaba7ff7b8fad9b6018d69ded126eeaf6628746bb07f2b2e10438e7b7dae96ca36f73277dbcac0550840b2d9a9fc9b4302aca0a659ae97c912c84f7964abaa2f1420f8acd2017ac5d6be2ebba87aadf5fb0363dd172cb349c5ae0ffc4ff9c7ee88a7cb0f9662eb7cccccc307e03993583386e73622140326df273358d40284ac25df7b8009c9de0f9c55ac2864a0219a89f269185fd92350bcaf3b2606c5540a8e7f18477ecf8564e3dc3b99dd7e6d794d7db2aafa785bcc86931eeb28a87c1cf4ffff8fcf41de24fb4328a80ddb9f72aa60ff2e792919687b345cd67f8644460ea3b151925abd30847367b787be333a02511265d67c50b72b0da0a41501afaa3801278d576e450db71c75b43597e9369f2fce6f0a6d4f4073bbfdce85a38985acc72b265d7d9e5b116d7d0cf71f1d2a842a0217c3f1c6ef74002694082689ae0b01ab5ac218a3f61175d247e1befbcb4cca1133a1b7159a2d35e3a4da1fe8a0f9d08f82020d704d2cb10533c0f6e4061dd78693ca83e0fcbed74e3e246be611b2f55c59cdde1fcc2495c21a14e26ea75518bae75d7c6b4cbbada21d45738f27de398de119d78a8f26b5ba3602b289403e75d14a24db18eae447adf95848d4c2654f25903ed2fcf33438d727c98b72e0d94a7a8d76da1982e67cb7385243ec48393af780fcc32a1ca55ead25d8d7f23ccf28e23235e2d4fdf367b25a071437d730e67d340a72b34cf5f7445ab038a257aa2c4f2f1549bcc72fb9ef452461cffb2d096f313914b5e2dea6fec317e72c0c7e7fce3a209e4ede8e30aec8909ca81094509348613b543aad84c15f069db4dcb38656b345a44779ebb888677849f95252835c7471d37bf7a85b9d76731399b11d5dc592f831a348c8fce91abcfe6ad56ba95fc3c71b76e028f3ee8994ed8d0fbe0f3febe5a47fdca3f7ff6315e6bb01664f15025ffbe258b850a99a9f27986a36f6ba736187d1255b9cd4739bc7f7046f8eb1238d0f5deda3529bd7237ada9d53d41220f9aff3ca6ceebf40d61dc84febd21a9451ab156f2a1905a5594fb7c6a44f715e8af6ae75c2f65059f50508c02bc020a54f75befe0a47b7eba7954c89b2aef8dfeaa8d793df40a2d3b776622f7063316097e96122b9fa3f948dfe4455ee69fcd61089118007cc8000a031de068fae1338e4ccdecd1584983198da35610ed50c4de1948272c35577e73e9f46164fe3ebe3dbf8b96cba64abba4c412fc9958a3ab6263a8a1c06d01d8e99767b5bc3c87e40cde4e61609a30f61937c899e5e92f013a484b9d7d534b805c69925d53ebe4ce0dc1689d91bfe1e1d0cd0a5196b989ac9bc641b7fe6c0c541eca4479a2a391dfefb972ac5d998119f2c39b0f6b14c4de70f3a93dfdcb96490f4a40dc735a64dbe93d573c6d5db9d256edde6770cf8c6033e602396c4b205907f92d90418aa34f5baec04b2cedf8febd080643150672be3d0dd87bb0b6e44ad5aaa3ab617064ac2338026be101db3276929a868a4b1e65e13bd3d55b6ce80837bdd957078bd773c10d9b099f53fb4babbaa8dcac6acb2c98a2bd577156104af43545313113af58acab1af76ebc40d298f6734a04edf3485be67a1575a597ef811af8997d6ca5e3c5352d68c616386be01f7100c56a697a48b78cb843262447176db212e6ae1988b20c1d40e6be770ff7e23c657248ff8a6a3066533f1180e51ed551c336293c3c6ac28d37d08daf61609ee137e84ce668e93cd7be7615eba5f1f9f5ae11fb379e5aa2ef831d3aba36ced29e0ddc2bd90a811575cdac1a9e3954ac304494b2fd8fc6979a22e881cb71c00164d4f8be9a03b85a3c963a938d63f8bc2a3afcd0e6c112371e8c2f9cb99045120959bb6bf4b735bb134463f29a0b1effc3e1a1412abb6f5199c72d8793920dfd14b2ba0797c8c73f3807227dc48e2c2c8d7428d962f118d6f198cf174ea0057e55bc76d7c6268f104fff89f91e923d7a8bc0823079c2a06d89b068d5a85844a64c36c8bae143f115c9db2b92deb6ac9c6c56dc16f90e7b1d86bc0cde58ddfb9b4d0279b381103a3d9cbeedb21fa23ec25688905eac56bead24af7ee00f1fe797b29b3d6be21a1eaf1b2a3edb3411df712362b9b50988450f900175cad0226dde54bba891824a545e4cb04b52f5accfd25206c7a8bd7a21fd866cf9af956b727a3404aea0de1023de1de0b36ff4e75b19ff036d0816c02f8acdcfb4eea6e387b640166cc9d248f4da327d6e395a0bbb067909cfb876a7217cb55ad655f4c7e223462ff3f6cd80a1349ecd364165c386dee2a6f7f8b409113fea8ef235181b459665211949c69e455980e87039618d4d65c005948dba1db40735b249c96d23ca4030f6b909711499432776819df091bad8d881074e1662251045335ada117562b579c14499ff8acc343ce9974c345c784192b723e20e7c08cd28a8dbd252012a785cd139860ea31dc0cb9b22d18d68f6dadd0a055a824ea283f0ea328c4098c598d241e6342996f5413efac5563769208f028a2821e5e354c0da46193caba2c318f46c0924631d2b2ddb77e0cb93a32b2f53155df3fdfc805feda2cc2c4e435d522dc84a235ef00118e7f501165090e8ac90fa184b015f4e4c361484a1917be503cca301d61f53c571048c8b0ff77ddb54b5adaf48f0a19d3c6e37fc8a2325232e8d4e10fea4a4b32a66e91c1e2d9f421344bd0fcc39dc8aad0fd53db044be9252e3b49b43879b247770e016eb5456512c64e1fd5020ab60e4dea083165e2c6f87113410ac5a886dba52f2ec786bf80f3c2ed00ba68d1f4d93a1ac164b2e9a7d728acd82771ed2bc8402347c441f23dcc58e9c0ff9a57b914047bc496ad482203ea687cc45233378cb612f6604389b5c57b9b043706d904e92884c82e807bdc39273cfef4815aaa8bde85c5ebd45802ce36902f1e8c960b502e9302ecfb94b381afd5d7958281548d969cce0c92ab13859f2b982b1ce15b1896b8bc8a0b01e9fe744ffd568d54860ac4fe36242c7e8730f4a9faf8462a6ddef6ddc11ca331f2544568f7c071de226ba7810eca4b1084eecfb534b6f33c6390d59b6a18a7196c51b1de1e3a73b5d0b7e51f1d00a6b13674405f1664734bfd3a2da3ffe6b88005184db8d16a7f11877c9b417924cb861bb86d2fae0de747d95580e62a9fd2e9b231cc6f7e13a97def7a0a5c81a5b513bd2bffbea340a6592226528d09e8fb7e6d358903c0b143d9f30eebef0d6ffc95b3f539fc717d54be806e01d9f720987a946f1f443a3d0f7047d24c204b70d45e58515604a9490706073851255f64dbaf10b562fa22e25b121f8ee33e7e3090c8caa3f4577f125fd4f297df431f9f192c9066a4f147c401c5f547b3744fb72f0abab25a021e88a1d44189273cda02b19a62f20d9f09080d8e050a41565703a7e4fe63ccf1064a11da235c23954066025aa880422755384ea2d1cbdd44adc3b0ce9185e1c72cbdd122f2181c91ee12758552456a48fcf08ac275c97064be1becb2d7c98be4ec20808f504fa6b7b4b6104829e23faa42c87c6e0ae52f72cd05a794f085364d5e4717096d6c01dca885971631ef85c5cb3c88b1d16295b6be2d32aaa8c591412956516a31bdb8e80d81087c52e364ca75f583180a35e5cc2b21f83e5f489052119e80ce74110af1e3f3434db0f314b111a9e8e8d509bfce6818b01d20fdb49e511ae23347b66efd581543f4bbffdd50cecfe70bc9ab8f66e7eef212a072c1bc1c0b97955e91fb6dd787d832b08706c77ceb1aa7b7adcd600a1d9ba246b95b5b6abf641f3384470ecb16aa2436d03f499f780e9fca9eb5d6ab503be4208714e1e61a6915d7cff94c224d59a3a124a030bef79d972be966f0e84ed4dfe9c52c13b4f17e4d782c6307aec6cd89c0e4566689d4cb508719cd4ea37ac15353f78c3517b2daf0651cca8c3aa3bd04c0cc5fe91b42df3a6dc167e8e7b47d9f4a5ade994e1d02cedfaf4ac29a4f96eed89e765b010b139407c1ada607a54b2bde48ab6d5f502e9de12510428a9f2413dd861cf3ac8dce5191afe3987bdf89da08bbd5e9491ff4440b714b4e49abd250a3847c4a6b1fa9034cb3ab6fa357d05930cd244029d8fcd393e891e5e4e200bc9617971c5478c53fbdb4ad7a854341b23f288275ee78d132747","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
