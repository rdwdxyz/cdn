<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55205cf1fb4e8dbad4dc54c28dff2a0fde391b01bbf48f0c89ef52ae1de31e1768074847eebc034b8cebc47e2e7445fd85d44dddd95eeca90c7cf5c510fa34ccffc2055d832de7f1808648ce7b5f0c07fe1ffb0808139d249ad65691d8b360a87358273cb651fbc056aa851e0951085958bedec6100c9e2f449b9e3215efc037563f852a044c637ad7ebbd86d46a0e23eda8206df641c51b6cecfe2236b326fd9831827868e9f9d335c18c451abbdb7864271aa63c2d0864d0b0f5036d59fde03a76b9b16a6cf5318e614803340035816c602a8142e98eb68642e2c4d26581929ec7a838d4d273ad5fceda31c43217ca5fd1dd98fd81c53dc3f1fac8cc3567a3cf8d968f71ba56116164f73de4daa069f19d4efa4ff9f2d60b1f7b2a7c4e7e4d041237c0afeefb4fb8a6bed1b104d69872e6aff3143f377f9c4a251f217c0a4fbea98d60f1f5617e3a416fb04a17505cadffeca91317be25c316948c2013944baa1ad66b87a5bfc1374d8e6bdff34720b454717fa3dd5d66c6a7535181347655781426cc94180ce6a71310a89ea820509410588313c343a0d352bc315652fd761f6165590392be0d4409cf1b83e0c8c9072c495e7f53feda922516591fe7ec4c882951e23ed8d58595cbefb9df7b4413dc6b914927151ed8a397e07d83e6ea1b195c41b7d174a3d8c23ecd6e5e959935e7c571f365fa715bcd5206f45feb57552ad2da19c2aaab0734207de6964b28d166b3f24d722f81064d4566be16237ac1c3d03de3727ca915443093a05a3d4695b4cc4ec4476980c28ca0b567e901b62608ad1cc506c174d71e4527980c065a8519324aafce6e00254c20c4aa4160eb54aa2b50ce0453a904dd81affd4e62f7bc6af34e9908be0eb5ca84fbf7d7ca034a96526e8f67543b1f5fb63653abec3fbe95ec4987117aebf435e29b5a23708628158ae5f79fde24f659f6cb1fe3aedf7816f16d099f28f303ce7bc916601f4494bfc7540c7aa1dab23ab6e710c43881acf2c8d44366d7164fefe2c28018e5807cbf577579a83453a0a4150389b63b5af7b9e30d61d183492561e969f4cc5efb2160ba36a8b86c49c7f511371d21f71606f45dc7fa01bf55267adbd4040063284d3546e27e62db0b5c3ae0065fae50b2defb0625a118dc1fe05adc99525dd739472d1b6bff144ce0b1b2603da89ee49f595deeac365bcd7a555b28c7c5005cd594db51519bea42942c08294a4180d6573b50df7735702d59fc26fb535b90cc887dd3ac037589a87ff3fa674934b1e5068744d21ecb3ef4c8e31e8b6f6422a47938ca7f18cf04c5dbd64a0444eabc2b7262f66198ebc993e210a8adc3e3e74195c6eedd19ace084fe7df6b27bb3b16320acf15110b732c1a62e0e785d77365e4173aa2977d28176f27dde533e408215aed92f9ad0f9102e3eac7f150a798042c1c4bd5d94ed129d552b92d2d903f83dd27cf8217f3532a8eee785eef3d647fc035d93b029a82ac18cba45b825386b8167b3ec4944c8d50b1a3ae307309472d2ede3fbce909ce5dfbafd0a86da47b7b28b16130b671ca8feb68dcbb7fcdb07c4b6204a19c350638d43765546104b54aa933344e5f88bc34a32eec36b96b05273a24011d77c74c8d810debb3e4313c647c4b829b40b057adda2da0f9b4304522c7c3dc3797406e1a1681bdfc378ecc70a1e8d074631855ca30989b19258266df4d0bb14e022a9e8def29e87de2e7515de8faebb1d13383c36f85cc118d9d30262ee975e33aacefb2cb06280ebfe4cd29905a922b7ee28c2b7d3a247b9153dcedbae8226c140b2e7d730f135af54ceb073ff0b8e08a690381489b6dcad87d3e4abe6182669499ca4826e689d7f0f88bc2e609b49dfd71667bc300bf8754fc5a402fd3f63fca077864e881a58ee400870cd320af1129b4bf0cc7d168bab43ae8cb97459d4423514d07b4fe0809b4b621e55601d3a7af642bcc76c76df68f7be09e59ba43016e50b9ca8ef8228d13347dd61f442f1659ae64ccc69c42405b9a713d96bd4222cf00ac63ec4363251cf062faf2f50f2ecbb767f93f98267ed6a5d1db5cf41e44707062d1ad66811c93d4f41eb5b241999df8c1420227ef26bb9a6567c5fc9e38edd849a1a771bda527628d2f7605bacbddbee7c1ea1d953b5078649b9de3137df94c818c8bce3311c31cdc87a464c7eee8aaccbd195b357317bdb08da7534c37208c7c55714ab6d7a6e6541396a367204bbc913d24dff2c66458d7d566abb15d62a790d8262847b86a8f850fbbe579ff193d7d3c0adc1e0cee394706f41a6cd9153f31a547f85b50ee162269afdc55b7d6e4fb909b58e7ecbc1a6fd56769248a953c6fe0674a058ca37ce3793563d8a36c083af3aeb443632a893cf170aeec1b5ab0eee2f79f11f7f070a81a4d2e084cda9e179b1402f6996c5104324330b7fb073f0fe88e0b61b9b79663c7f68f1d39cc6aa91952e4fbcff4ca4f8e606485fdbad98125bad80a152cdf580fab52934171b4c88719a02848f33efea336155d3cd9723370bdbe0740d6fcd5e846d4b8c0e7e81d8b94c1be05f540d3464234130b6429fbaa4f5662a1f4ca872bf5b0d599f36beb2365ebb31da465dd7d0d719c5b7622d71919ede8a78264b89f17b4fd657adbd642a856cb9d4fb7be6d0113052c75de32d1ac2c791d04c748697323c6b7ae7323271f2d1f85850b69fa56797453d077fc1a14980a4fdec7628ff73046fccb025cadcd2066760f70bd52aa39537ae8d075a57fc5ec8b2177800df34604ba12f892c8fd0764dad05f87540c2a766b02642edaa3cfac6020abe271de134601ffa10d9e6a36e8796a29c7a3e4b0458c5d56371bba2e7b81a9d8f4baca357f2cbe76782db9a94dcb28c0ded3a6ce792b0a7607f908146844ad0d6ff63ddfcac84302e4a2645982528970bb4e57ba5aa29c12cacce3b07037b48c4b2622087d6f2e50c5ce313dff9fa71a0b1c7d2a4bc5a52904999afc613267c7a6d0dc882202b3d8d4e332690a62ba8961da522e131430507b28806e0bebd9d1bc9ec2250c4325004f8c6e42d7d53c634b5bce1ac6b8bf6fb4bcd398789ca0955de384a5a212b3f8f6f73e6d22e21465a6a2284e64e65cd824b08b21e64892964530dced17794ac5edb23a0234805537656b327a9da4d3d62b856eec0ca1323cb3a20b467ef49fd9f043d0fa9a319c871a888e74849e650997423ba2f38a2e13c81b844e5b852ae507315ff456e61d87ab774b2f313dda20fd5d9952a0a1980c4016be3a884cf5aced3bb3b68e1aad7a5c2494aa71c0a9e6776dc5ab6648111c0322ebddf5c2f39915fc977a05644dc25c3091260a8f905a4c9ba2d189d7ef5d8011c1b5fef9a9cf332f60ee1caef4675c4f4dcde15d1d4d4a60bd8468f239a7a38587621d9dafda3e005d09bf8694999737d9793451eb5848404cf20b83516b737ae6d02b82afb801033141eb3a5f750c55a77ea5181ddf4c4fe1d2d8e8adbd7a3aa7bc627841faeac8ecd3fede288624e8f6f254ef780dd03a3ded29f1aacd59167ac2d2a5ef5e8d9f30bd90a5f7e458287dacbe78a53037d81ffef51f218f136faf577a23de83f8f82f21d47bf7026fe8ef3176338373472dd1e1039c1f680d7425bd637c115228887fd8b3866e8665e9325f4734921f683869954fd2340faf9bb300d0f46fe557ae00e883fe55ef3ab564219e789c3a8c461361018ca9b6d21165e5fbbf252d8aa133b82b756398678b5a4b558f108857f32f57f72fbc2155d7ab4f9eabc2bc29df4db2572cedde55d06273ff2c7287d36596906e94663f8dae6a7ccd375652d099fa43538a80299687dbeef5b6f562cb9066c66448340763a1f898d9bbfa9ffdf4d9e3ff7ffa9e77a8490c8b5706ea1c2d8b6b765c4df7b2068aa19ae14d0c2080529b409b741eef1b383f91ce000c52e486c6dbc4217ecc161abe804e717a5ab5def91cb38e6934833ceaa9ec76cc3ef070e0e46ddef81169b5819b254915477711c378c06e4f4f29092c6b3700fbad515d682e01a8fccb36a20948b60f09c993adc35a64adc54bc966fce1632d139b2ce86fec7409bfe166c625b45d32fa3da67bfda4d1d9b91a41d39be4a7849c7b57d9729b532afaf55806a3f7252cfe2f48798135f95f87f2d268580f7b070c19aa289bea9f1cff1fd57d7ff28e3bb11406975198233d9dac58564ba22b39e41d79a0feef4b713fda0215206f95df3354bb97a48340f16e38ee269c8933d05dec3ef37e868b5a58906ecf15c566bda8660796275171f5ede7efb23d3c2ada2bd58d3ec1679a7cf40a195f02b28ec784f779ca8effd867b2a3402d0064094309ffcf122c42e3a78621deb63a9819c2c8ffdfd62666e86fa6fb4a893a14c6c65f0ce8dd2c5e7c54f3c54e88e8af092097848d63399b20ca46dfdc3c654cd7e95d730a9229c4eaee28f29ba66b44ee4bed6be8f5d576e7aa99b142c3c3ca8525548376d3b8d21929da5fd8ba08af76f18094161b034e4c738f344e88aefc207fe15b9d99ed115f510817a3ed457826eef854d4f6fa1c492c7a5ef28b593c15fcb0b7c391bcce0a0ff033d0b48f207198b6e456a597a8a7e1406d40b91b1ae24bc542345a56758cb6a9c3d3851e6dca0b395c63910e8ed6a2afabc3a83f2b10a2cc044ca22b975c380381ad00477a83ad518350beb85d1069a0cfcc0f0837f5670045706e4e5aa53e7c54717ebc5a6bb63db15053bee4cc9cd80d5f8b32e7618a3a6e8532f1b3d09cc4ef76ff7cc853a64a1016d42c0f74d8fb6f803a21e888932c0307f30a8218f68dd67ed2d704752696683ed1eea51dd759d448fc38cab91f6d164a65474f3d146bc9184278bee573179fef6d20a10005ca1c99dd2433a5471733aff41e8931261722e25ca9cf1bd871fcc7a8e85cbb66c052951f7949546f9a83f5ff0893c88c6ee403d345a4ea6fb9ad19dfbc536277037979b08df0bb946e1b01cd1a23e2718ba9f486be3f9a9af9a8089031a9668ad8e0ba46f486cad8afa3c21389c0a7aed97f203d11fc1d3698582b750f002737db2f9b458e72c0e091016b851e9045799b561444a0d405e58f45d3bdce13db14671ff25514ab3d9bf38e3b9adda3e4cf19c5b7e7ea5a60e1f7d4cbc0f5a20ea7e832e44eb9bcc34d797e009f96903b26601a93310da73de62c9619a2de2a4aa6c41b7dc54b5277b83a5f39cf45fb2ddc412aa7055af4d3d01ae746c35fd78b1bdcc1a7ce41857d366b6479ed00a0be23e147c6be648e37c86b89fe6adf6ca828315b5afe537a76149bf0ee66aca50dce9fafcf238548c66c042887dbb0e082f62fec939daafb2536522d0d295238fac2640f752cdc2c4b48faabe196142879adcffa06532274e2c4d1de0dc62fd596549bb2771c756be4149d8e017e84c1bcb31ead05e8f4d20971c35af82e7ae231fdca1af5aa26f8e879eb939dbd10fb1f679dbeb3009ad17e07d7f2fb347f6e1631b6e3ec08bf471066b13480f89fa289b2169879923d16bee54d516275a23a238e465c262a525f1efd49491d5bce5f84f4059e0d11ae06e332cb4f2ddd9e71b0e830ce42e8f7d9212daf34a674dce7d7eab5428be2735e5826da311e9939540102d0831d291a43249bbeaaac34c49c8c82a72077eff9616c6f5dcecedebcd386c6096bb4deed3499f04ddcf96b634a78a34ad23ae9cbc9580588c50f5998822116231940eee6e53488cb82b9c3c741bcde92ad231a00c95f51abf023f44e7cd9692baf9df32aa4d5538d331a358634829cc0749d56191fdd8abf96443119f20f5621902789df14cc895aedfbde5982542d6bf2887e6f6d32819a18a3a8a198fd468f94fcf807c221493aadfec4a84d07576b2387352b70de6a86c525205aebfddbacade3f373474794eccf97b5182a8f073b7885cb236ecfa7687437a85b6939bc1e16c9f078c4087e6f78f6967d7fc1b180b8a4ecc00f4975c4f2300ee30e85912c9290f9b3496458784a871858f871a6b46014164d1e4238e9fb8c314fd088b58309e917d432cf6207bfb7cc1eeb022bc1a54f2d11d2309e1535e0ef0e25103313e6dc39d01ad0e3bf27dcc2d38e4610b65201e68af685b9dfc67347c89fa0e768fb6fba6336839d5ff07874f985b13e6c6a8f0037f9aa7e9c26e6032e70df85acebd2654047739e2005e7ab24ecf57726bb34a927a0307d5487b8d9af3e3522b7de1476cb0d55e105394bd043efe81a459f433f23920ff010afaa6af86e49fbbaf4d0f4aa27643417d9f25ca92e3250c8e9b5589841bf2682c244aa97710708242a33bd9e84bcab4b1e8b9fe95c2392ef44cec542ff9e819d6f2edae2abdd68e1d2ea2286626be825688bceede18a75ac07da4a37de8f5a07ca6ffba8bedff706d1dd88ed0d754be724727070701c62b0c8a080ae20c61a55a118d894696bbab8b307193b0d46eb90941206ef1b10ac5ae8ad8b1fda9ab9dc7078aefa2d47f43e8df5ea17d1fea78de6855625c26c803b9dac6e01aa8ca14b8f9f9d40f2e25cd3112ae48a201a8629438ad15afa500627445e57215097c72f826f3e7e67f9f9156f07f9dc11aa1f393dee50d03f223e2cc69371b93f13c68e38a85207dfa78f6cb57018b75b047dbb57dcd98120ff1a57140e0ea007ff315a7e7449d19fc3f9ee77d11b2e598ebd898f84642e559e0074c76a3467cfd6d7d48cc9fa28cd8b97da9790518ae283f34a03e2d5d0facb5668c169a9088ddc78255adefaafa75f08e2567a3d82e1cb2753c5111a38382dc02ce20697969f8e45ec8dba55561658f7e54cd9d6d26a34a965a07bf6479f80f3138b13d345281384ee24e577a4935ff5559d089c999a28bef77a7cae796af4930422daf5ebf7581bc1907eedb91398e0f0c21034602efd07d0513e11b0dff419ebe33b34a0707cfde09532d406e988af0a127e31d4975513f8bdd82fdfec234898fe732e720a868035dbdd5bc84d0fb1c4d5e37dce5483bcbfa485ac8cd1c5a8860c31d151cce159966420cdd7b38df8221b8efd48fee95da06181d33bac67d5bb24b6f11d389dc2341ae0e96bd01e4b069de3bf0f17ce60945ff564df7a980a4b9de3e6a5c1ec071c80aaea9fff40ff3a52ef5a83daab15bfe0744ca62a3643e667cb1a954ebff2baa6bbd3b35f323e125b08d4d6bf18e7e52d6a993cb37eeb8f8adeb710450103d30c834b7ae9e0e72aaeebc26f035b25603de20c28af15f0b7093fa5682889d3f99a233ac0202d91ec5c22980d927f0cd272d5f69d80b2f52646438d3c4715a2ac698d997124740892a49ef31ad5a51fec4d34cd66e59f1936a23e0cdc57b8b3a53b88410f904b3ea0f076a6ffdc3d4da7906a5062c751a92e1633218a24827a8fd49a49bc10a84e373c38f940fd78b65fa966707e5c4c058d634bd5d013bedbf07594cb7988fe9e8cdaeb24b06f6d538dc5113bf9177bb746e22827837ef971c7328f8c0a644a68f2965ccf6ab8ff843fe45ea5cd53eea12242c61c45f85aa57c2cd1235506dbcf3aecbb36dfcdbe2588302447fed879d4abcd171e79260720f34cf104e4871f0d8e6796cb1a70b0e50f6d78bee7cb772ceff6afbb70c77448f8bd0a94f173bfc82b85d2d890e4c331405a58e8337b89982ff12a3435502353f89e444aa75a6b33afb3671195ea4f2c6e1630af011c4aa943c4ca27192b42feafc3a8e96d7aca917d6d774204d18609eaaab578286577ff01d294088a81040c1c9005b99c61a95c682467d5cb385acd7e470b9d0858389a849e59974a9d954ca97717e1b54e0ca9d565ef0dc90a816e5db56387f5954285576869d0bc1d354ec501e69b462a7e56fa49e7a23f777ac534e1e21ee1ffbec9fc7b7eba0c86f4e539e909dd509bb0839d80aca2270bf7809473177795c9133ceadbe0c0934286ebfed005c8c7175571e9833bc1bbedc0787e770e7ece2d703b5749e38c0b8366a121984729e8e6105421070fadeebda22d7704dca9414fd40a85a72ee81c94cba508d484c276e836301188ef4e9a97694710e6efd7162d58be0aeabed4927b4a02d54d93328d54c677cebda6b0ea2777446d143f04dd7de5ad5f875785acccb4bb3f1ae8e71a370b98cb687bb983606f34461276ffafd969f27a0274598d3b6b32c310537928dc767f11ad4990dff47a22c6c5c1963de1678e2a768812bd32e911696f034af1bf00b2fec2af62dec0fca8611a977ea26fe04aec3cf30a7815771532482f75695ba878affabbbbadc35e04d378d8a0f648d953fc3b5d3d11aab33b5eccb1460a7485e3f04d8da15000534ce642e3cf97ecd719ad99c48a085bb392c9dc23c61cc84a911dbb9ae4fbdf3b525b9ad71436e109bd679c835f26a2f3d9c4837207a310609f3acf8e9b0c15ec927e338188e9d8e93a0958d0ae830c6adf471cbba8a8cc8207e5235cf84e7a8eef690c57733567cb345cce4d16a371bb1176499884fc2747a83162e2954b476b4ec8d46cb15dd3f57aac975c354c9d7524aff45ead2e7fecdfe6380fb50ec4057195b33183879cbff411f473e529bf91e0b18fd423dcf089a9c9e4719add35447b73edc7e750b2c02896c42d8e39bd44c7982a2535fc8a74258b77b31cd41b2f7020c94b63d5b468a5d53553efb55a9824291f496543280e65ff3dd1c959408fbd12de174276d659711fcb6cc120ec04250a862a1d20d3625c8096e484c16a3a0c0c061b31e7b36bee17c5f6145a4b6cf9800e2a2621acff1d916b777a2039c7adb7a02e6ba9d824c46c4e8920228d1318326e4fb9771e78095c859ae052e77f5215a713876ba5b92bda5b78f6167d9e561a85c8502d1bd23af7523711e8e1ac10e5e13bfc8475bc4c9deb2bafec8cfbdbd8b35ec4ee4ecb315e6f6a17935cb3c7db86d1e8dd954edaad973ae5e706015f8c7ca34b75994220b78494d517f648caa644410e30e514026b17ff15ba84344959efe5aa01c6e7ab011a282a98d7bc17d4426609cf5e7544e1402a71a0eecb51ce3a67ddcb02779176616f0d049ba09ab51ee4cf8105c595b8aa346296faa91cc9cd1043bf16a07d398525f29112126cac82779e97f7b666fcc55c74c7758fecc31de9fcb59f239f15819ef27a4c7b99dfa7e6a9c199a00f267a6d13dad5474ee10a374ed4d597ee0b1b4e6dcff17e01777d75fb7326837692811e73c5ccfa58a2560a7b8dff378ee02594714151c93ddfdc012f65be0cc975ecc45aa27ef1f1c585df50f3acc6a4dbfe23275be4220031f62949fd56b8acdd33f62ce2d84c6132cb02fc5c54235799739cae1fb55ac11c4bc361f91e7ac623eabf9e0e69a58c7b0decaaaae241b81f5cb7171fbff79981416d779f2f234dec307a71b3b39bc1b4321acd53f4c179880efeddf5778e1b2efea8c926ad2bf68b93c8c645880adda007afd510455d203265aafc15d3e974598f465173cb6e5289cd31162b0cf1215e5a70d10541c8d274f6635bb8e2c35843c746dc8ade50e79a5c28350a7ad7e1070ca9a9afe3e5b6d96122fbdf17890d17c4d809dc83625eeda6d86d96336c11a97a9b797faab84c695e40ad2a2dbf61fa481a1e95c3fc531d06918e6b0dd92c7fea6f885b7d820e0438cc6c014899f13034d3448b17c412518bae68f6ce70b5f873f705fa5d5e9d827e1454c2b37bbf7a20d6e0fd4bd5f422c2b984af27f2a8c7112df68729d3ee8c3dc6a99304713a46fa8ea8da79a019807d93fb6b8417c76ef89d520d0024f8b54f91c0ee230f8fbb06a1696de525352b5439e8d7d0e5fcebcc2d47db6476eeb4b695dabb289d902fdeee06a008356b9298b21f72154ac46f9b40973a11a97c0137e67e7fede82eba3b6636a6770232127a207c1158e16606d63e36e027dd455aedf6883dde5c8290e78bbe4d6f29edf4ce89b7644245b69c28d2474f41184089b17c811e8fdb6c8c3535179ee1bc970303e4b009290cafc71f248c07ddec901c39080c8316d8eef9cd5f1b2f9330b87b21c31d50e5abcaf928a5787180fd1562b588fecb5bac16fe5e61e1f963895b72ce5c4a63541aa9b5a003fcdd3a70c264479ba3f69757582c64bae6d475409250b593743a433d44e0af87931a26b36c862bc9cf383cf51dab2d61fec23d65c1cae105ed2182abfb8007c39ea40af5b7b5f3aa86d1a59d98443004fb0ea847472a07651d78d8d9e01d9af28f3352fcf9644f9f121b4b2fdd9a524de842800a70702fa33e198af2f73f591ff773b32380f31eab84baccac734429775e154b7b619d2327e6563386b1f614a55247d4f0bb45e2329092533155df88df2c87ba622d36c188c89b51692a11ad993de9fdd7d71870a7be814c93c0587ae156581ff06db05de3c172df634c1248761c58c235d36203955b0fb284ca1e816369b2cab49e6912d379969656dc53e43f6a6d7022c549f0e360898aee217c666579f337c84031a1296fde0684dbc14458534ec9adb2ae89e83e9c5b45a146ac776acf0d12af5390aa74143da490f9c67701ab6c9aca69e2e05a1f2465340ec9e4a343ceb8407df07d5aa15b9e4ed96975bde9b18640d5c9d0f4ce559d5ba569c4ef2eab401805a1e2cdc16fb4ad05c08896016d33376b60f260e2f9f5592998a681b3d9749b233c6a92859698eefe6e4c90a794d580a6b4290c9008a11d3da7741289a171c2cff96ef4562ed9e9ac919379b8544cf8f70a2752f8b577ce14abf4f6b4e06ddcc2e8a7401a6b6ab9212812dcd7bb0797224d9240d6e535574e423825e0c8ce0e6d3148ad25ec83c7b94283d20a6164d2c401fde0503c5649c602fbf3a69efa95fcf905ce7d9ee3d2d89499b4126285252547381a25bef615f4c73627a38b876136afa5bdddc457a0e762e027e61453f03ac4f18f5db4e36b03ee419793618860c23f02711cebb3f749542d96d51d617e40b20084fa67146c54abb93e8cbf5a232088b5f0e2bb9310bf36504e67a8700357bab584ace9e6bfcac412ba50d38a07610392858fd222847984caa9e1602d53167e389edd7a5b85eab7d9f90d20c429c84b6dfc72db9852f8cf0c8be9d1f0f274a81807e982fc2767707c1ce3683dcbb96ef22e8c797d173ed49191573740777a8539e32737ba36781bc9390a44b3bd605688bb222862c78b807fb41d0ea0739212ee72a142c196773629023b451a3ae36086e1aa1f2fe4538a617d17faad6c19b8a16277fbf52ff2a4c0aa69c383b58acd6b2d836362c6325b94b8118fd76c39073b6e52da0795060ae9d5c9b85b9bdf1a2efea8dd112f4b0495245a43077b60bb94d335b428ddffafccd29a9444ef02ca1cf0a874cb73d94db99807c2c272d7f7b72b914f784ea717922ca8c2e5b76c8af69c68811b9699ea12b36e0943923c4ee95e1ec3b59a12939303f6898cab134cec732be73e87ebcefa59575beeba56ac33f535031f736772de46115ae4deda634448260feeb4a9285b6d9b07844af63f6becebab1f20309fef9d74ca83c708447623c28d18ea2ba8850762239247e4f1d1bc40dc50924d4ac1a8d379e81c30ec72fbcb9b7142735d416782ceff3e62a1b44def3319d1b92263c83e279092f6f05238f42909dce217e0f5a0f736bef1d4d7b5e0d31876e7885b48b42f5740989ffabb0e94799bfdf7dbe1c2d2fd8ae8c7b360844214e2eab5f013404ba38b32b32cc7d05471d6260a727b2787d4f54a3486b28d9fb21368a3f987372b570d84bbf9d3434d100ddd60b797fe516931915f453a6e8e6d6f9eb4f68c3332ddd87a16fe5f7f943e6f4bcd0bb54ed2830c2a09ef40871f15ec7297b5d1c21dc5ca61bc08e0928811eaf3ca7dd31861fcd80ad76b4ea720c02520a6cfb071f1938614f7e464ff08254fd64f8bf1d47c7a1defb51c188b39afbffa1914dd0af85cb25ddc83357d3f0fb8730f1b89b9b23af6f4c0b141fabdb0d46e6395b48455f4d15f3c0c78528d782ca9d6cb9e050db3a45007058806ccbb44850cf1e9abfa661a591b377c6e641cf32047061f32ebd396afc1929f6ea46cd9259b22d729b6b6d6dc42086a011779dfe44cb67ed7ff3f2ee6abe786704349c3cd6160a86c34690fd58bc79da3dc0a60a53e4717c6b585a3ed013126f652a89a0568810b2bfa498aac0351e0b279ca1436900f366eaba5ff07270597d191631302b7e2b8d11984e48ce155e1aa08b6db29293a1ffd399b2ecef5128f0955118118cb23af668d7c52e87955aa956499ef796bf715f43b3e95f4b8b4935595d54cd2cfa05c031a1da395b631602067feef99b45f9dfa9bee58811c2188d46179e712259e0812f283b0793b814702d3edf762dc4e0b548f875dc73eab5e1fa270f2921f4a09dc78fa6aaa96aa7d9bc968208e64326c24b0d25c340d65c55298a35b7fc4befbfe941fea86131018d797b27c9f30f37e08214984496dae271670eaf02c5561b48a50c1c3e7d15478b0b642e4df59123bc5670b79b9156e09b313cc550d6d9ef815754e70bc9230f650b18116413c700bbbf573e26575ad72a3b61f72a8224b571c0d7cc84341158b00627c83071948ba39d6e52cb23143bf40aff5859ca7035434c0c47df0cbc4d19dbc4fec42cbe3aa22c09241ec5ac61888c3859d0f8b26a15fd56e263ee9e25e4fd3b5fe518618165becbe9fca0a8010de9e562169c0b0bb87a1b03dd43b1e6d5eac08888638945c0d4aa8e454b813909e7404ccd20483fe4862a0880fb73795a04b12c1ef488229f9475de8210a71a0115eada64508dbfccff2669aae4770c0b32c3ed48dc91b399609291f7546cf26daff274e45e4455f57c95a464754001809f572cccd7d355225444fbb89236b09439628ead5838875aaad649c9d832f0b6d0157c97c54bdd96dbb38cc677a073f3d5a4dc0fbae85bdd1a75e2702600653483561e3589a0e75ab723ab5a87ba0d6b7db974e3dcee3c31077f7c896a211a3a9541ffd81e77f73b27d92d43f370cf42793b299458e9293000c67e6d11c2a06a6b56af34895f278b2e618abd24b66850f24f53de3e610d418432902732d1a7c8d7db3c5a454f468269e23a6b67642c02d5fcdfe8f6a8d09259268c468d5ec7b520f0f81e4e83510ce110121e9a28431c638662e1704360ea738bcda537ab7063a1e77a59eb12ec486971408d0331a88461c1bd95e169a5cef8b51418554168bc78f829d75f8b1c9c6c3f561b9da8f469a38c918fa421802e4aa557e67608cabfc392898f25a78e1aa49ab03776bcbb4ad7d7da7a0aa47b0764a15b67937ea0c59496acba37851fc98afe6fb70a3aecd2f9589f64d019cde5375325712e0ec3f1b4e6fdce358d2f72e890ac8e6d410b49552fe7b21c651b16ef9841db9cb18166f1d9bb959ab27baa5d0e113efd85876441e0ec92f5f3c75e721d5e67ffa2865bd18916f3fbd777dfc143cf9bfc6f17c6f754a3c85377284f883b95a76b2ab67dd04fc33671bcfffd40b718cfad4eb907e16e140ab672bf5a13249081ce3f684dbf362b220024c801c78e08b5f22b27937ad09d64b3c02f67ff64eda0419805f8c37f6d3181ac9c7064718de310c7b0be72122d5af162e631b5144d4fa356cd6461a5c3f43770eb43d4c68f11e6cb625f24c905049264c4037583b7049afff7693d38cce0f88b5480aacfb52458dc394a913e86f25f21a3c563552bf7e3780daf281ff47d3237ef44bdcf2db4d351e495aca41a70dd72b7bec42f47a730686bc1e5066e305f4e26e57c4265d2adb64b22152e5c2fa3fc564be2f72457afc2640da41a3f7f6d04c1b5c5aa3156b2cb0bc21cffb4c1f6030e210b2aa9d133d26e9022539b86e914d01c60c8f9031b3584fb24ee5cc9d4f35781d1938b15c6e9497728d8c7b6a11423b1d3381c28c5cb468aac1172125d94c9130ad2c57108e633952c0b500272f30423d68ea35cdd3ca20663c4190da4799bcee27a03e58aabcf4b4cee17aa241cc216890d3c5ceeb761195fea3c94a39b35428b99e981eef665f371a2f3160db9afb9304e5c43e1263041f4c114b68e5a1b4178b6ef5b161e5a38dc989f0484cf73e10f3e58a8d16cfc3079eb32e9f0b9caa98269a0644d69f4e98bc668c41dec659c24951bbfa6e98661040ceb43f6777ff78fb601d599820f8c766d46b28eff77d295cd0f25ae4737c216623d340f1d11797ee02ee6d184dd176257e30a59e0a9db15547794f5496ea5ecbf36634704dea1ccff2bce8a1e84d145a9dac56e8c3edb7afb0911e51d333ecd6f56b78062965a9c5e9774a59244fe5fa2f04a69bc5b9c4d0d35119c6daa6c0b88df0c8ed68b5852fad4f630d4747074cf773209283e1d4505b5ae46963f1cb871ccadafc8e43d66698223499915d8e3c718cf35059dc9626cc58bd576b05800ba5fc6963430ea3481bfa81ac202083b3aea4775a1051a0ccde6e57c14ff29c1c0b1c19e00de36d1cf6fce961bb49ce77820566ac0813870a8131816cbc2f6612fb77da16ed47fae2d8c50f02349de0479ac26ae1f9308343827d4de7cd7a95c2af35b320cc146a9454aa812c9ea0e72bf6c3197f6043f0c452eb45f20304f9b6fa948c9133f1cf76926c71fb2c07f7d6da02528645ed356b20d37d20a16248a6472e5342520b9fa9e0af2a9c79f9832d83f79291c29b3fded007d8c2037226b0db974523a5d90bf7aecfe4a3f96c5bdc0b0eda3e5b7b2622a7793c840c8fd2c6de08aadbca7b14c04b3be42cae8258f0571619b9c7b4473d9edd3d6ec6898566fcb0a05c8bc7b4b16ba5a04e3b833f73a9f86748dc841e9f4cdc80fb67ae1315f6779fff7181a9ed52314bd104465a5a04f279fd127416682728dc50041591cb0bb16703abcaa0c617c040c6c55b2d975245380872b99131081ad179c166226c83100801f0cf5cd707ef6078345c8810592e13c939d6f77f4e5ac6f59786900d970c6119f0f2b25b452de76dab6a10d48d830d1a4e5e204b4a76fef01f1f71694a149202c2afd4cbd033eedbba124b2ddf284d6c3e3d0014fdf9fdf699b4875e4099a70fe770ad6a2810b2cf7c3d04f3f00c7769b44d59eb5661252312dc24a18a8ca954edb7f5f4ac8472048316b66670352a23bc2539c9d32e89aba2f4816","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
