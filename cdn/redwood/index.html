<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"80e6bac4a8167a18cad4e44f4e26a1f4d005f9bfcb4ede65db5af7aa68b2b1d54e6c998420d9af2141a14a106cd5395c437fcd2ada532311747699df7094f2798b75a2e9da3188d1264bad941c2404f41bb8840d81b21bf815267c8ef546744eb312477870da764fabc894cdef0cab21458c7a9fb991099188f5b8bd53fdf7515e7146afaa6b5fcd1986492e35205ab97ef85dd1aa8b519fa0b32da8e8c8fd75c8938a972317fab40af90e69c75bc0e6107bc35c09fb8a5fcde71cda36347a513c982ca2b15ad54d83e67e9ee531e5e2b33504e1a93c8f98d0df94e9ce38c454f411e7644c6143418ffa7d089c32b610ceb88e9590fb298287f028096b2a997252c5855ded611e13d360f6a6cfde711d392d53874c113514f561215bb51e87ad7c8339d154c6dee029d9b08080d3ea4a8cf65dbaabe33bc3e1b92742e4bdb78cf7e33a8e5e449f0065ab28b14d738a7d2af99ea20dfe42db5a25ee557254542ccb1119aa1be2afd8f47078f03d14d9955db183a7914a28a142ec8ca5e4a9f055fa93f88caf18fbe07f47f1706654f3e4ebf655d6a2ba6cee320d29387de265ec61d33861768d1bcfcde60e40e7626394ea4f0e150b23c7a86c8fa1f6e4e66437b86c7ab3c9a83638edee1df07b23eacbd88c7e7d40ab8ecea9b8c94651152c7c2f4a15122ac2b582880ace195ebd8863b22e1c05598ffbb8b0a93fc9d69881e7213fb5c5ae32f44a18a0e641ba12f9bbecfe186dfcaac221644ed92e9dca654ecf7f5fe6c4df7c9032c22c6bf8f4c9919e76d941340ad96ec8a2a2435178e0e4a286d8b93bc764289c2301e336780653e975b00e739776d421fc8657b5198abecf4e62885cf0d60fbef6cf317352ad8026cbecc7d6d0b052b96cdb7ffcec35d41f4df62c478bd7681d8fa504a0fb417516003476606175beced8e46c48f1a0a38a755b2be7844aceac6854ff64a72b225c939fb7f6b16ebf3398eaed4fc5b74c769a224a9e0ebcc60a04603a580396b9e5e694be5976cc105368e9a2dbe777c2e94747d9bf7e707a2b8272504cad7971f33923571c78d96e0c2cd2115c6eb604068543780da68bb5a9dabd67e2e10482a029211434894b4be659e647aee2da94d2d2ff10bccf272253863ff546979c0238e69fa78c9111232d2c0a6e640a4db4cbdf3289ea57e926f2cbca1549b1587d4bbfd0b7f898816405598fbafc4631077145898b151294e26862f01bc6a8df6a8b76c382a4c7efb42b54dc1b852b5b412e782b0fb8c08136df086a8dcc7fc1bc23fc499bf282f62debbadad57e274c0e66c90a487183658141486a9f0b40463fdfeb4e9716988921723f11cec2979948a5e777d4bdf8efc5b70a661ea11ace43375aa1c6ee056bd39f3712f8bb3ebfb41d4b527187cbe4d37f1d4be12b7dfaae90076b2f86fa3e75259b64b6e6cb9f091b456069504268b5068c34bad323ee268ecd3438241dcc324b9164bda2a519a1a4b9c4d3ab406730d63b71edac4bad5f9b7f28a50b3f09ee9e65073fbc2a0198ba8db63dcb0a43fcef3672430c39b0a5fddee664b488b9fb913689432e5675f2f9601d2a5395fc79d96ac7be65fb715dfe8c72205812d35af85830eef8ba67a627039e7eef45ad2ef61e3ee3e9a218a53b90160419c856c22eb3f8c022c2cf06577878e5c35f28cd574f5b8e2519c39ab182524e6eeb60e61f1fd9a8d7fb169b41e536843eaaca06b886766c48e707adf2dc6c74f97567f95c5452082b6fb1fb7dad67323f2da186a608299b2f7962dd87679e357282281fd42377e3fb4f08cfbba194c137c77b745d6d699b1fa3c90d00c550c3c0994dae3e7cf2fd3c155f89bf42757713b334c16d727097797c061c9f378e0ddf6e7d0ca2d1a2f40abd90acc0c0d915c1d3ad9dfce6d90e831ede93a9c55fdec22610b7747fb11a3a1b5273fe2a4b58d31e9a6f0af1b8c72b8c8d2b21b72acd62c803936cf5104bf1cb83e8b7d85c521a8d059bbc51998eb873a5c9b4edef450a8ab0e2c749815f3e7f8daa403cafd186ecc55c56215ff7a38ba97c5a9193447102d234d728325035df9a513d096118e1441ce5f397c0037f20a8f409b188f67213dc6e13960129470523ab89947c1968a59a85a98371ca19ae2febc99ade3c00bcb1c61f4e99916038e57de1d97b11f2f8d1bbc5af4260bc072da6b7afff0f43f67018a7f2178654812b2f0eb61f9f59671c42b78b3604a98addef0921a43bf74a8d12d8d7b0f98ab3d19a313a76c9b192c5dc1e34120ad329acb22a35e56a181a77201ca18d9886d7b021104e10a089a26144890ce3d899c5fe5706763bd894c7905d19b212a39012ab2a7ca294caa9ab4051e52b247208970e5abb2cf117b70440d88af158bdfef725fc63c8ce95f7122fb1edc8645c6d2d4bdee669cc4be700efc465c74e5fd57d775907d156280b7e93d6ad775dcf49f92d49ee6ef17fccdebc70753e79fddc0c72e6d759bbd6b917b6890f23975fd0339be2c7936942e36f59ad821b839533c145be7cb81e40000402ac6a1337b13f2755711565b2b4239771936ba66664205a1353071ec5176fbd11d24ef627a4ec1f95cba332adc8a5ec9b51b291013c4df8f54471cea947350ff84a5e0f1c5b07c63bc2e28160ea84805f754157471c710c74282c1772a2d384876417073ad9f5419a99f8d2ed256c2007370d77a5e3d9697d63f99d4caec31e865e9a892e6a196c5e46f6ea04a5c901dcc470dfb21672af117ef3c68426538e3b0df2bedfb30de56f2fd9833291a89818555017b7e21a1084979b9c5a2f1ceb27be54114ff28c4768ef1687ae3fa80ea43ca7419095d99d9117401e22f40ce32b7dd74897696ab9de451545ae418595b9c0cf0a79cc4dd593b378bad62ba7ea6e1cdecde70bc152bd061369945a0b3772f899b56d3185a5940dc06c2ef893bab26eac58e1a5f4eab7600520c156a19f7c3dba8818289224a5bf8e581e404ffc831b9d7dc9853f33f7a9c7b7e1f8f95b343dc8c7da68908e8596ceabc6fe64eb4e58950795bd5857becc1d6003e341d7e57e263e43fb6257ef7bbac894b728182a730979196770c9b2c3b999b849cebfd3bb89fdd7b7bf7e050dd68a3945f359bbfa55a4e159b1b2cc7cd0ae2cef55e0964d7d73c84671f485e9a83463526c3d2b8478a14458b4f25cd648ed4f4c4595f68e6f18b61dd8a3caeae0e3050ad5b1036edee2d3ae988750db9d39fc48f2c0eff55c777c069151fbe16d8d550059a3f0e86c265a862c1033838332cb67f375417356495264a74cbb27c0dd871aea9394f16cc745d253b2304edcf006c4fd86af4102cf01dcd2eee488e57ebdc92050d1358bf8ec2c1a92f674b8657f35b380f1967eb2495c56d2339ddd1709a1895fba0b26e57a7e0debfec5241c17d888b544c64d1318b9bc5937300a4d44500607a38b9cb7f7cc9a5aa1aa6bc67d42f4850ad0980bba034943a839011bbda23292c5aa39dc69c24497c9dec61ffa019662b53e019927dbfd6981c0f29bb8d63b474f73354eb231d143c10efdb5c2fcc4083ee0cdec909129b81d221f482596d58d426a6bd46e6896e9906ef38c12a5827944bf6b1cdc1edda58bd1a3bdfa2b644a8d625e112c972d7d43d53bb686d469121bb8c63b9db7d635ea3a5e56415c29623e59890b3e1166a38070f2f183f7833823f82fbc10739e0b03ca252906876f25a950c1b7f5bf62640bba0b6a8b41affff110657c57d2c18068d4083be3267e1160e492b5a9d678f7a8d4dfd5fb05f4d042975c958980d7096d31d225a3f6825ac6851fb9087ddc9e648ca6ae86abe6ed437a48579a835b0e5dac739f7afe22b5f48d6f5e3abddf15c6fa45c84c2801f157d867ed70a0c5e878b6aaed23f2c18956472a20bb8ef87c50a295adedcdd811d87d60829b18316468b65015837a34206673ecb785904a48edc367016a755ce56ac3c65348ef0fbbe38e82760f00ededa993714f0dab8da78ff22877fa20b6488278cd144f81c487c9b074fc487b2cc1aa783313419e91bbf1608f9af172705e2d71c91017acf8e1f7684d85115c14dc6f0dbb811cf20ff686803c08f767ed7fd513deb5fa229e774d4f5340657f9e9bedbdaf63d6303bcdaaa996f3c317e8533f80bc81baf8de3ac96f9493fb412c57c40cf848e40cd6d88e048e45dc55e2ecf3cfa109fd445d33c752d43707959eb28407c5887d4cda9cb328c44fba762e8749eae907f73e17edce83c80d28196d8c467c21fbc559552b6685e3bd1bc9f12da72f2bf1338f596e3ac01b315de4d9a9e94c1f8d75d8deb047097a9236f655aeeb796fa1ae61a0051ccb46ec61562c694bc3d5fe9ccafc29481bf5fe66b97c7ffde669d34d830218b895a908e8b19adb8f3825b02c3a21889a0e8e493b5ab06f46fbab22889d4d7f588dbbf3e699322bb42e0031c40ce7a3b5ddaaf480b62d97f44b60b46e29301f2a64ac64588ac721b619c09626c3489d6ff4c9fcf7a9e355d9c378a4edcfe1ddab7f34aa5a357edd56b784518eec2fe448e4bc22223beaf2c19893656c8aec833ce31e4f43e64e7a40cdb0aa9532e3388ed89ea1aa2237e4a55cb11fd30ab3772dbbc3043bab92a9dc323f33bea76109f9b7ba10272c59bf34d69813942c2069fff5426b825bc2cbbb646df583e94ada7799175432b1854a27fe20e87d26df67dc5438eddb06978b82ec1e394fe811c370224ea4283fb3548bd8ffdb48586e04b3f48d24d1bf7392516c13707409e1d5edb111c43154216bda4807aa50ff49968053390d97450b4744f3de3411f4368604aa6019653cecf22dc3c2455c935126a460d20b49cb0391a63e297ed7ec460c8fbe73379a23b23288e0b5990c9297ef271a03b4217d8d9257626bd9059fc20fa04dff12e909676fcdc6193471579420c0d7835f057222f4acf5084c91e76f1695fcf20c1891228e778cae6b8bb79278e5bdb94e5ac838795d05fb11568c52cf3c8131d89b2991f91507e04cbe861c12cb3d39428a1a9c07536e67ecaa6f0073dcfb5327e93ce7b696d90e6069d37f76591d8020f13f0dc71698aaca25731636c3ac06d6a8bfdd2604d36c891a07fcc1ff905cd0129489078b49d2c90010f49c493ecd26131f228b6ca16e017386e4c99a1920636bb7db9b3fea7131f64a7e19eae02ae0d56b175a5eca417adff38ffa6498268fa3562cd23271fd456106131cf72c09d23b4a2cf3e6c05223823305090ce4bf0c5cbe8c25c118f52e3cb01f80e862dc41eb7a9d2f8281831804e6eced8b45cf272e3e7b37d4dda1a4ca482199888286e84df21705c2c780f8d5dfd5436ab204323153657cea908dde4cc100ad5bd48d8fc553d241ac73a31fae9b3ce6cc24f83b8ace0df5b5c8e670c0156e2c72f67b225dc168dc1373f208ada299ebd1a1dcf6894b98e020866c6082e8ffb4472b320fc1b6e7552dbd9f625dd37e59e5f49935de76c0d613cbab49b560f844a926131c9383f45204926ef1479317462c0fab2ef606ecd2da27f10c0f98231c61a9df693fb998ed7fbd69834e2200a24dd28ac778a7cc9428023471853c0feb5704f246d556786ed3cae7f436c65482173e42b5e1182a9123b8e5471806b31629745ff24a5e7473830150bd8c78b8622f74b229c6e1dcb78fabea5af83537810d8bfa86e080f860e82cb5a5d93b8597dd2a394e60879da8eb80886cfaecce1abd11f7d3f38c35d599b45a63262007fb08c64e921471a77f98eeb85acb9b602690e05667b7a81cc945e860bf71db53ac966faa0e4c40eb3456cf7a8bde8e48518a84c5fa3e353393cbbfaa17ef68765209bc8ca8ae283affe68c3852e65cee641afae9d8741772516836a74f1cfa067d3a5b66583ac93a78d95a9900dbb76328302858fea40a1951ce7afca60729d66e2d135d779c89e44ff75fafa313acbce8a93cd713c7e9a0538f11f1c6e2854953b0f800673d46de74eb10bf406734cc4fad3da83560cfb7ac42ba9eb7629cfcc8bfd1f6b642b24c2d954a28b98b40adc3fefba227ff6a0d0106fc671dd3944e91a224125f86e4d4fec5e5dffe0827e41c324323f0f4591f6d5d063dc9b0f0aba751d78b651fde1bc4b8240f1819c463c1b037dc2f21760aa0994a8d3e5b83d44471be66822e3e8c3e85a7c8bdc3828994cdb27ee06c73dbb80d8738688cb011ff1c014424ec29fb1dacc0bd70f51cf5beeaa27809dd94d573f89ca9cbb5b6507285c9194951f9db5b22119ef377146e575d6ebc23f17b07deb59114765dbf1eba28d4aa28612bf15efb947a9322bd82d8f375ef0fe52576fc2b36cf690d632afeeb88f24899677c13b020ef0025aa82a8706f73b38bc7e2045c6fd374704cbd7aa0ba21ec741f70d3d11e641c1f65ca282d7978a323ba1f75d1c71fa8ffa0d0f3ee4b88c1fb13e749f24792f84d12339a08388c123d3b6ad1886644c60d0b41dcfc77075d3519089542a133a41a26f0d642137c3930834a8cba7e281cf6ec3a56b719bf15e1251c70f50b4e593e7fc8c85091918206cc19a7a38423c193601bbabc43d65765fc9cb111e70d5bc404fb5cb955979d493ef81efd766b8b35df423d712f083e89ee4f78e91be47332d488c0cc15d0070b41d5c304ea31bb775ae86ec91d74f853f2aa66c246ab6863cbfadb008fd200ffe070cd37fa46b2245d19e22c6d3454d2a708c9ec125dc32376d7f2750bf60f2d9cfc8f47e56ea69d3b92f29fa794ef4f2cfdffdb05d329806c8035ec25809dfab4b7766bcc3f98169f26a0ef8280dc6699e9503f6fddec5cf3cb5dc2b1a14eda2e63e1d2256fd29ec16acee2f916bd577bff458fad9601dfad77f165ff71626019d0ba72c959e309b81c3b62bbc2ef17f826c299921a994f155edb311ce04fe4831cb93e343e1379f4a7c5928ada18d1eeb8d1f531a2ebe208c8c986840fab7b2278c4011be0801f8106da8c362acadfd8b79d5e535f06ac4a772c0e15ae13ce0be01f0f7269e6a2b2f6094d075cce33c0190e389522478dc3a4ac5a7d51f8ae7b5906fafb5288432975d64928ad980676e0b6745cb8568a295a5725d0ebe49d644c2766fa1de30c4635643ed4b45ad65e8a06ba9e0186d117e1fafa6f7722e0ebd2e0937e5b63cd5b70d29a9df1e90ea2f7f117a8d57016fd0d6ee04b9d6994f9eabade3b9c1a9be78f9011c56f6bd78a97037b77beee6c8662c878c9aed60d3da5cca13e9d189c19a008bd9ff3ff365bdb53058b383711f87d7e7f3b97c69a943af9a49412798cab07ae0fca8edd093bcb4c23e9283e4615c9f4ff45159439288e2f040290e2151a2fd11c70a68c03084d08d4e51514a74ad523b1dd89942e51d16ada4c8c717bd712748212efcb68afc9d082a58142bc1aa9c6969cb15bd12d6c5d4acec758ce77f3eb660f15675ef6935e6a465629657a0ddd0fdc883212a2aebed8fbacd9a0e797aee8683716265064008af10199305554df422be7870c8129bf0c1cea9aa937dd08b0a3a002cac5855ec1a70ec45c64562b5e46c8d12c558cbe7e18418ad0b43952a31e7acb9c2ca24ca517f50f79cb57d266599ab5e90ea63002cc6d69ff0e7055f6e857027713851a7dbb42083d198d5bf47ccb277d2d388320ff45194e0a2f3621065085509b1b4d778f62d3225b7c7690d34a9dd85771730659338be9b64bb837a7f39e949c91cd6de5dfcd20a7aeebaa865268673149223e156b354da1400d8dad37a333006eb0e3716bb47d19289fe1dadfd93a1757ea09164f2f1960ce973980b39f800a80245d4ff0feb6fccca6294567934c4c2ddaf804f3ee549c80327b503d273c8512df33104b89ae981691d881329b37240a01a2ffd069b78d4b57b123acac3017b781d1d60e806b0ee3c3ca954f28c06e3de43d25cbf643568976a7b399290d609d67c3584e4592d44699a24166f9ef39b0dad8624b5715b83d151d40749947f7b7b1a674b3935669b77f58fb8cb7685a5ab017e7301d5fde808fed9d8b5fa0a220f35ec1bd2c3e577997805a9df3c0962b786aeef3236842c66c3c0453360a4fbc9ad69f8015db376f8fc9fd969486786496a566bd77fb3924e0043c7d0b2eaa82890cc710afb585a462be78483fc5400023e494b8314a4ebb73dc234ada629f8875a1bf1ae8c54b5b47e33ba5b4b0976df738b66956fbc050b4fb0ead31afd86bee64d5352c2d89213c9d98f59341da8181904bf33818e7c8eb7a04155e988792c99951d0ecc3a38e2aa1329f6a145330396ff077fd463eb92568954c02ced32682806b6efbe86129e33d88eff4a768b7bc861a58728ca52d44136e87effd9f6fef97bfcf68424f80366dcb2ec1353c6ddf290886b918e36d8a699c21a69ea9ce6897e262933668b214378ade1c66c69521189d53f03569148d1e67bb15c6a8678120e20fab425887c126d7a94e40b34f0fe9d58e27f4e88c41e6185a6e97383946e60881c82dad2b7e9816660c0de24ceee5d11f891068fa8e8127170e29b781ce615ccb5fd129fa05e555dd4bcd3aa220fc1151f17e9615631c3f5c6ef82e913250dcab781b163a7f7cd8f820a375c9c0dbcb32d952553be16c483f744e6d9b51c03cdb41b4fdaf915cbccaa2ac8962cca6b8420f7710a961b3d73a508cd6c8d516a28f006d9591665b08dde4ff664be86990592ca77bcc6fb9f21efd11f5ac37e9b50745a9342496ac4d0f6d437c6c57f9f81bc433cc7c5c28dd137e01709f0be991411cf421d215af832252300d26f9c7d50a58dafd9ad4e1f2669ca34c8216b677f9e18aea5c67ad3c609691148b44f64dd3d6c10d0a6b9031688d1127706bebd088ca20156d57beff6174dac8f71bfda7f39c7108059d8eaec2355c6494f5de80ef806eb9a67c5dd25fd5c07460823cc139352e0538aaaefe24220aa19c33f64d436b187b66be43857eadeb1849946b82f8f7a460d937cec1e5854432b7a401361a50d4e1963f385d31528e59c09067b7e2cb39f27482d0e79342175d889db8d885dd5fc9c200dcf3bf0ccbc97997badf8b119ab947316800bc34d42855c4919b6cac0cea941df1a699464acea26c342408d63aa928e94c889448ba0b7d1842ad27d74c91a72faa457fcc473a735d60cbfe9e47e10f79cbace51badfe2bfd3281b4f2a6eb23b6b7153613761bcba6f0cfa23c7c3dca2aa79f03d5aaa813ddc3ac991b147219763840514b1b4aaa0a93592775b06823f4e4a0bad6dd69d4f3c8ad7a5d815800c61c394c57b08516c66a17af052147bd7e076ad31693c9b432f857a0a44db9a50fa98f7044013af7dc5bd52fd551651ea0ce868f6dd393b865d7125b570cd9cdc8eacd938aec7f6e5a611dff0d7ab98414f63e34e37ea246e2d3a30f48cbd64f038a5f25d3b5632ac515f14701ad305671ae8f8a394fe05c3608ff171ea257403609b039755af9804ca30c399aa5898ac42b04d35b7ab43a3c710baf1d2e14bd9a6a2ed1af5efcddd9b73c594f5ce8bdcb3ffdb00858537241a095aab4ecc4fbaf658816032bb84f62df0d3622873f3c0b26905ebb14b6e9a60edd80609c0fbff2210616084832ad800731cd1b81a1b6dc3d99269a7413090f8cc0fa78698ea3dcfe6ced65e76cb75007e9377f9b04e02c907b6f940f3b9da94e314f824e031919df55c724a5eaba4a3d6d030b36f1b42b7fc5eff913554e1908fd565f7f2e058c730dbb37325ae18b8025d1a2cb2521552f65731a9e6444509293b1cdef0994f21ce07305492eea3623b99a2e1567914363c6b4f6d0111731acf2c2471ac8b2aa36f5f0e1caacd8c2060c5c690eb89b5038b58cd2c77488a20fea84ca6682c573d39d418a4da024fa2b5131aca3a955aacf920b58a123780b6cafcde003480aae4060226c1b06a1471ef09706f90b21f167207060a4f03d34d5314a546dca924087b7a417aa2b90e7572e960ce169ebc64460833680fa700f59d97c8d80c9dbd834f80ae55e423950fcd90e3c1c0145cd1fe34ace56d20dfc4c58cc3dc274f94a13320ae0dc82ac54eef0e27075f010ebdf7fd60606343aa4ba07b824ec6952bea59d340f376b8a31be0a6bf13046782668013b6f2310f79db19c7be98517809581d746a18fb73e16f7cc05d6e912069d04d81e204a507e8aca347389776216911a3e05fb919bd3a04f1e0b81d61361bb8ec06a8a7dbbd1aafd43d0062b1851be71f8c952bd004443b9cb679607aa5fc0d0b9445fbe920ef0d852453e619a18b615021857e8298c8ca32971985c3cf131bb98055c48fd2dfd58c59a7352436af4210f15c83b43b0ac7ecffab2b1e6793309b36372189e3cd225a631c8c9e3a1c41e2c2f6cd98542a2537655e2223d8c3b89d3c3f1754e1b3e4e96d2094dba03bb59be1ad8542efde83c66adba7688adfc52333302493b3ba1b2e5973e905f3a92debbc15c46338750be87e80f2a4580cd53539a4a8ab510d3a5abca731558a2804323476f45fb46e3af922c4fbde27e6a30b876094335e7a2b937f1168f8bf18ee8bde281d371e5161eebc4bd96d1252ed0f84e7dc51d07ca54ec35cfd44a54ba6df4e0c7817784264d9eca205fe3962867f5a94fc300f3068e3e4ad1a9c3c98282c41221278dfc1175f98ea6b2c79ad8e6cec4d9dd70a458c7a1a48254cc6ffb77ab6c5e83cba0d314e83f7d74a2f4005203286068e5f04d74295b4ae6cd9b08ed3ff088dcc7b3c9a0e959f6eb67d7b702871e9d1a7a0711b7cb0109c18a333000b85a8f8bacca936b9f6ae4b14af13ffbd10f7f8d38a19e2ef437a2ae80e5c5e722914585f93364351084756b999f69804482c9ece94676027cdd4e24735c69c296770aae49bf9183ad9ff890d29181d447904c3a4a2baa9bb51a72689f046d632ae369a7586dcbf2404ba0d09acd1de333275afd27c54f36f34d15a1d6573be7e8ac298960a1f86db0e6cb9f81a12748ddf47814b7a39145c0cfbb98571507c7bfae4c43253d96d27bb6a02abb2e01387c177395f3d72962a8594e6dc2ad2f9d26de19ab89bc9a4542aba1d87c6c3853eaf9a33ae1735840acbc313aa4556e4f36451d2ebda4ba179571c9bd4ed7175b6545a314cf19d173088e1380711fd00fc5f1589ed5106a16c3861e9ff5b0a8a6fa2e048d51b9e154600969832a3a335e0013a36ca15e5634152bf457a0a39d01ad536ce778d27dd957af4f526e7d677fd9676636cc38ad00ac3a16ba88e704502ca62209db06c840435ca02488e51f5a926fe26681c8fc146668146621c01d0bead02104ba00eb2d306b288bd1a1d5478e2fc65db36026c184990a097f0c8f3d09bbd05331286ddd6b87dd348340dbfae868e017e19377651e70b0ca8104e88f4efe3ae256a607ea7342698e5d1cd773eb5a5012186653d799a675a3fe850239ad9cc68f25bb9a0999543e9276a6f737bc41b96aec569486395576c4ede7fbf538061c23c0fb296f1ba730b76aba4da0b08d40a90e49c4032ae8819b63bed65da136ed3a7728b468ca041d0baf5c01bbf5e4d42f5f73eea127ac154432564563bda8e69b00d8b9a85533b0fdb33d81c722727217101f5ec214ec027ba67657451f13f2809c342949d09759785ffa17a98472f9f9c7d2eeff3256d6b45ab61d6deeff3109554ec151b28d5f5c0e2c8938cca38e99ad2a243a93d612fcd25da6e92a1dd67f3c8158100dc65d98356bcc1696dbac8add75d7e1a112f6d6149dace0cbcdf3427590f67ddff632dc7d052d0f3fe71ab19a1a9ed41c04f38c20a5053ce14e183a5f011f27a314f517168225f39810a2f08a89b6f559de92df3ec0e525a7676eb7ed1fa436faf32c2e63eeaeb669aa318af95289b70fd657318d97d0896a1fe2a178131ec1b1e1f4d5523314b2707a35b2d5a285506af0482e83fd70023ffaa2bace979ab7378e5baf79fd67fee9adf54036ff4719225355b278b5f94ab73ade16069488db41b2eb5e6a193fce8456f27c34a07a654401ad72d86219f1eced0884681c2171dfb1a72805263b3291bd6231ebb7634bf88f84e9babe1937c68b8cf6f47124f14a578e980641e7d38e577ecd2e8fdcb2093b91e6e158e7b644bd3db70fea030443d9ae7ab49438e995513fa339f4396bc16af0ebeb436f0bcdd6c7eee0f4603afe5d9347dd44ede1a4979e22b420bf9c70acff055f06f22cd33e96e5c6a72d04ef7076740f0402d218a526cea5e5704860beba082addf04f8c1030cb5bad2507775d9a7685ca03338ff67da98ed3529d31ad644c908a720f32725ea87be5eb55dff3c57cf0f3f1c6fc10dab41b052ebeda28722941b2fcc64eb7463d8a1c6a7e525794475c216f02667a057e730a726bc4e9456f568676e0738148cc1b6c3bbfe9ef16bdd9c350f709b016af99906263d3e0246ba1656d8053a525054c0e4f0758bc8a604c26ba30cf768eb188b4c34eb7d0b792484bbc90ee7615f1f4ab623231f3501243da0e0856aec6ac71ba2edf74e74270afb11f6bce0510e9ee28fb03c9ae0f30effa81c3d762ff2f2f5140a2c46a2c7b6738fdc42a85a5bc3dc8077a8ad260175be942167b8381a3ac815df7a46070545431e1e271a081ab4ed155aefecb61311fae4b26e074f6c0bc9778de4b4e6865286542472c2b843e05bd3935d0846e7651ae7a9f517c3e76a4743ffa7b1052668c8e98f43525d72af344774fdcf2a926fba80549636139dcd8ba31c995dd97783e360425db449d6f4582206303f296b2558eef5db41061ffcf2a42e843ef6c437a66f9744e0e4d1438d0713b5866f10a9dee58fc6b9618ada6960ea94d27d9b2aeca781c5381b8f53037b58d4ec7975bf3cd5e613dba5b221e3dfe295ebf3647d4e8c16fb951f66334cffdfd6a08b9196b2fe2f4c81f0a60401765db85d65d1d4a20128d7543af09c20dd72d87dabedd0eb4b4c1e7c720c1b55e1b9bd704635c2bac9e99743954de627da7c79522ae997a26afd78c996e5a174a4ad70dd20e78507ffedc10a54a1f948f50e90065738c579cc11a069cef425d54f5563de7cedcaa2fd15360d2ca93e7620a6e23fc47fe6d5476821a27e387bc6c048554262e4057db9b3773724e31c5d20be92c932e91fc441f15b7f0dc96ffd0d05635dde6d5700c4498c4a805612fa381cac40925d29cfc710b859fef57d2515da67c5c36f66e6a5bb4ec2de837ab54f2857ee1a8458b0648b46c7a5b14a091f36a7aa616a7c0742a0d15ebf2d6b5b5162ecf1f976322b8d76cb5fe5bae3f009c1db28f742119427bb22788781888c81d71f26fab54194f0c7f42a14d0c0345b5f7e74a700dc605b19710354b1967bef5dda4a9ce81bf975259471c22aa1bf5a2ba33e23027df8f1f11a302b09de31cb55bb5425eafaa53c739eadf837f73e5639e9f6069967a6f0af87a6a5cee9ab5a47a3d698888b5500846e8c5eaeb87b47bd67abd5f14c580b7480f0f6031a163a7e98101e6e8ebb8cc5f906871d779298f33db9a38fb654577fb5498b8ee7079ff2b44965f0ca9c57d6f1646862e7eb3cdec0b59f0679d6e1c38b4a294ca18804c277cb28c674daae2023dffa06c7135f62126db133cbc0d2c3eafad6c3e1346583f179e256b77fe8299002cf467f8e6fe7d70116491ad53bac4cd5768f6fabedab9eeb21414d077a2ab2f000ab4e33b8fcdd43166694e6937c6dfc2a0e3c98a484ae94014234e9692edf6f56ae62757fa23e641cfb1a7e70ae9c7be128aca0b1397ffdaad7fedba8b148c3fd23a6dab5602f9586c78079d2c3ac8a60e637f58f3422ec80c63302f9732af5687ca8e89ff531eb7dce33f340b12430e7f248ce4413f143790e44fb844e2592f8e30daf6d2debe8c3005be98d06331e71799599622ee0c6532f373a9dd95d3791834f1795647f63462a6dd48f20bd8fceddff1687e4a27882e8109e0df2cb901df11495ac5302e41f201d4607a813d62a025e2d29d767694ae6d202e97e4bef59a4ff6cc11125f4990757fe0287b0d13ea8725d27f61d72e1a11bff47cfab4d17837ec77771bb946a6497dea0dade5b5491fda07712681fc33f96500a2604ddbab2e030291180f407f5b77bcdb3036524e9717eb68ed8a26c452438ed6bf13bb54fb23b4a0fb8e83697a7ac33788d85d5c0b6e9e56e4917bec04ab125e01a9c77a7f466f5a11d17736a54e37c858a80934c857fc4872fa6c9b90e180987c77f297ac68b4284c6b0b721ff75288c99f20c1f475697434b96ff308f33dd3565cc13a7e30b2b9273c4f5e159af4084f637558d359f7aafb57d6fb17452119244ab27339ab5a84659813bb9d2dc2026723746d783ca3f41b013c33ad26d20272a696487275f30c18e90634535ef06ab086e1990db03582194420c7085b594a850c9db2c0aa64102eb1a3dcc1a0b8e34d4e285f0e5a419762296015f69d49d6d242cb89bb6e89944c60acd3e6ba52767ff33aa0cc9db683bf5f00be7999c790b5899951ff59170aeba351c6a41b9c072473d365a8aeb8804b4440cea0527ce4a0180a762efdd1f0bbe11ae640c7c217055e27b02eeebe7428d090ef492612b50aba282503d1fb0b48a175c2f0507053b99266c991bac9887e7c9d4328d62ab9eba0ba404e79cd307b3973b09ce203207d94e52746587007105ee18f28d5af68e749c2476d7cda763210566ca139fd6754b3f9bd5a2797fb52331da2b9c3cde116198b1ba17cee9032ba72d1038136814b03d2c6820a7e08775fb215199c27ccc7736389e378b86dd342d55c81129a35c2fb4806960ae80d74d426f17a5d407586638fb294e55ef15045f07e878f6e1765c4cf6b8e51defbb9a82bf23fc6055bc101ecdafea2583976eac3c782d39546c78ba1572aa4315aafb14cf15113252631ee18bbbd7767413c064e9b59e491f744a7d00a6f9f4d902be1fc938da6268a8b62ecb684e549b193cc12a77651eb287216d654fcc3bf38f0f5dac9405af49d594ab2444edbb5d0e4bc318f06cd521e22c41d449a37ae38fca84e41ef0837bd15acade15ad3d22528bd32204ae4b746ea08b11bd2e65e0c89aa9d4469ae13c30febc68e5c8fc45bb688b83d5cfd157d618da523c6d33d75fe9c379a9932e99dd965a8a238fb7f371f712a3d0ec85abd14b3f7b29b45a550ff69796d8d60660c655213f925f04c3f12625defbc41f4c89a497efffc33f5930c431f8574d28939d97428e34d9e728550b2ffb4d9aa86186937427842f812928b2e0a2929bf3fcb29084b7924afb9f80d7304061912a35713b1c99d62ef5278f2bf1949928315267a022bb7e89971cae4107c794f6b897d058e5accd9948f3887e90cd4b6c49d4e05c9ec874c5382fbe4d44af0eb1f4b96655faa077a5174bf2110e026b6e4c26df5cb36cf848a6c174a5dfa123ef769a91fc3d4c8c4704837fb13b61503e7cb067e2970c5e062054266cbc17a52a2f8c31a4a061a9e36b402729bdf0c165c1405d48e2bc60804e1c8b5fd0b46b0d9be4f4ea2d0fccd8346a94d93acd2acc5e2d42cc245889151f9c2dd1a5403b2ab8ff73df870dfe12ef987291d3b1f9234911222b3caabe8df9b6ea351ccb3466dcbe796c5aca129230802fe0e11b484275ccf5eae353e8a593afc2c1bfc407227130a3dd757ec3ebdd9aa1fd2063d709a52f5dc3b0a182984e54bf5df3ce85e97e5638fb6faa34a600318c11558c53a753704630155dfa8ffadc57557c25264a5a943e4d808bacbc09c400a45048e396886552f7a96e32e546fa900c031b68c76a1658ef2e43cdc1bd1f188660f0719bcac9f180e242843efcb9c0e8166a4e1dd99ccc087d783469f932b6b8c7b7b41351896946fdb66ad066e42f5cd2ba727c12a05785a9176cd95197c93a9cfe3aca7de0223f920dd37bc493051829d048f3d40dbe069c6c2f8bb8ea227243548a4cb56b0fa118c9399a5aaa50b02a7135416804a1420a33f0005c839d7822736193908a8dc2c817c93232bac6e388e6ae3744a0cf7fba5d1370b1db32f74fc7078cb119cf7b1b1c1101398d16e5f9d70bd356bc525728f63d56ec72936155ff329e90b8923813fad2dbd2a16d1279fa2b447fb1b521b8a1a444509e23f9e6adb945949fd2fe94d0d5fa0a4c6149b84604a2359adcb9b8fccbd626b31dd741aa655a6ddfce1297cd41a89aadd7dc5665d7ba7bba74e9f6ac18802578db2d6cfbfd1107c97f0881ccd0d5798a6ebe66130198937ef5c526c78fd8496a230f29195b4cf141f7a6d57f87581112522252a45bbbb1bf563a521a92bb9374fa192d8f6aa6e28889ba05865536f4fa627cab4e44860f66a4f975dee79754bbc393d415d841dc6395c015aa98f134a248b916d0373ef96d53dbdc63f140f11d6944187d69c8a0a8e367901f4597eb0a378cb7405aeb9a2fc1eb5834382bb4712ec9d6798775cb6a39aa250d33ec065e670d0ffbaf8e1497b1297ccd42f520bfe49ce304654fae25a97ef0fe110771d42640bbeb46f7474094a7c7b8eb675250ffda774a7831df815e21d605f15f5d0b1831396427c6a0b19d5f2c89d1a1edc156871d6808f068fb626f89327f1a2eb1f1dcccc150e78b1dd4df0e099bf4b0bfef01fe4396a7b248086ca9c73f929ae1d6ad79a42ed0787221a4ebf1610c72ec93cfbbd041eac729c63ab29243e749e1f55b4a4ae923e6957675f676c3c19c221d22547a405eee09912d90eadb2f52fb54a37d054acccbed8909b1416da87e29d89d14acc08022e7250d4fe94373701989e2f857c37d6580482702972d3530d380882b180ec14072d0cecad69da755df6d122a72d718def9cc59fe6926b168c7821f41dd5005b1f07892c30ad22bddefc74d4f4b5f245dcaa71ac12fdef2376d256bb2080cff2378d3343bb385ead09ba061d32a7e949a1522370d52d122154f8877c95061c3e4dfbd70186160d375a1e21a838520d165bc4ed4be2567c97a2c02d7ba3790e8714e5e9ef02b46dbedebf8a10e732127ef9b5a6c18705c00da45cd0adae42b5eab6cb2ee3fe61dbae95213ec356d45844485d83e40f33798abb67e1f94eeec9914d1073b64a8c4617377c15c98bf362b554b675b5ae2c4d3ff42b0bab86be47b7735843c7099e9a980cefcf7edde3c47d499b8d5312a7d03c6965ada5bfadd6fd74ec0780b99c2e29e3a0630e7dc067c037b8c3d1fef92951be58f3ab333be8ca4b5b1918b1ce8079ad206e6c32cc17a5b82c3e2b5607e73ca1a3d5b61f85ddfc21d304b21cc448dde0a7e6b1a88face8fd39405e83dcbb1716e87de8ed8cda908e558412a705b5ee12d52264ac9abf0259c70bb93d6a99a393fbd2576b81a67c41f6386498bc554ca3e64793a81414065e40dca5db1c6c33e7114680885b2d9fe839213863841edc4b26e875c90281e295d66aa83bf29a940fd349fb72e2b35fee088c40dc769d110da42e2c91c0537ac7ba6b352920fb9ce444ecc84f40341370d1ac0eee106531f2e3f8ee72713caaa592dc0ab9ee8d94025ff4150cd264f76a099a8e7556d1348b19df3d8e7d9044b7db1486e7b7b18733d7fb61d90b1a34f27bfb929bc17e846128b3fe4319e555eea2486603054b5348a5a99f8a4488b3b5820ac702ab530c5950e61848ad2ff4cddf51793abb42d3ba30d95487c80d9d9b92952dd6da4f92c68355c55ba5262c3d55e91e5221013ccc61c15ad1231809f6b0d8a70b6a2b692a39220e9faa960be15a4349842306d7c5027970c92e2f76cfaa8ee5bca0de7a014b9feb4e7e2cd8d561af43af078469fc11d9e3d84c67f19f25a2bdd8e12fcb9b2f6562ae698758706b1a4ee3967d960f04f8d9516f6df5656c617cd456ae3cf15b4683cb480e26cc1b0634f73cef41012bfbe0a3557a4fb4ba7e28ca62ca1d349c3a02ef9684babea7fc3b18ba01a1bc77aa859bbbfa3957734e3c2fc7292d0575772b3b9f8694385f0c6dfd48723c6c5a5aa930296f00e1976b4433b8c1b693533cda087ca86927816eec54cb9e935f2b8adf469a86538d554172c4d64a3b20b35c39a78f871a00280448","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
