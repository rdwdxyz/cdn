<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0779dbfb124f3b18e22434599a1ed2dac22fd4ccbf564ae5f6d407fc1c629739d4d0484c6f75224df2c455d6af6dbd3d791c5d80c55dd7a256770c574062c88c18c48669150dd96a38e85dbd7c2a277c869e34d9236421d230cda73064b3df8e1d592668b0c7e4818a8f490752dcfa2ee0c61b3c6bd226eae9da38f1f8796df94d16adc764bc1d4f8535ef80c677a146a313f98f0e3f6a39a9415969a817fe95319a4fd4bdc6ad54fb63ff53ee2b5f4f56e4f33753c36d4b233e3683f068073445b8392f3d52b2bd98119f5cebed8dc5c5912ba8766f1a7ec8effadf4523d6984d6a6d07d6e6593b6281447dfaa3b2941c154378a6230ea737535b0f2f35f200750b5a84e6802caeac0935b158f475b45e428d9873645887e6beeb0a38d2ca1d612d278fa0fa1c9253cfee02e40461eff45065a4c58e053fd048dcd75e0c37ff71346137e6c1c0c0b1b076b88bb0972a678432c24907db8ce8ccc9aeaa0056743a6c7a64ea15849800a36ce308f5b6f850ec708bda8c1a3d3c70dec58a0d4b80dcad74839c941d27178cd25dadbf12d06642cb6e9650cffceb1d2ef53ee9ca47027f1b718c580fbaed3bbab8d4a26042704393a77d32c8f7976bf37ec320b7fab2a13a271900c175105730dded32947ac82d2cc477bdbc511580c5262a71678eaccadf2f0798eb9731c2d1dd90f89394b583ef867e2ec09843e2079494249cbc831bad6f1c6b4d1e53d5d6624bb09845aa5afa331ff954ebcd784a0322c6710768d4421a78cd4aa3a7276d8af53730481128792d72c1fe26622282201c36f304b6113f23deba4978ea7cf38c97a6b3eafcff5bdad46587f91c831a489491200148eb952d319f514f748a7e1dd24b5952a0de67c24046f6d48b72b4cc5a0fe1bd6bcc69fc348f9f7d51adc0fb06a9fcecd84aa3e0b95f26f294ee032d5f3f48d3e452aaa18ab11ee07cb33ace57fbcd48d5aa9fbe8607851b04627167949efa89ac6ddb1aedb157c7dae77efa76f980bff0431f7bdfe9cc64e0a4425409e448d83a422061f0260fef31ed5e87203ad4a84df43a2abf46290366c0ea64d65aba1a9b60db20cefa1dfaa9979961b0a5cfff703ccc2e89f0f44876f4d5039ac35940ab92a2999828149ba7b045d59024ca7692bd0c16165ba6c7fdbde099f88ab8a340c38f127019a0c15d2e9de799a819fbf858836a3bc475c7a0d042bad0c18ba8aaaf33d1d4f40d87a7a87601cdf43501ca3a1d6ae5aa2c370f6df90d8408b2bf235bf4f9088ec127d29f5a5e7c5a63d2815e9a1ea65e9941c8c2fbeabcc77d5b79c8f70427107c817f8e65249fd32efbbc5c12fcf9e0100d32b8f29f0a5fc7a2bcab36fd9e082350c2002c7ec3583d8dac1a3a9501f5e04daaa72dd3c060a1b98342de28740fb2867bcea8d6a7c77d95b2a94126af169d62610f32bd5a988226dfcd58b791414524c05403c3389d87f4640668c93a7f16f91d8ce06ffb86c2e1fdf0413e9d14fceb9828394a4985792e2118650f758e7682aaa22e2863e13dae9db5548594b5e3c2806080ddd4d579c6a2f2ae8f87e09e1dea69a259edfc3c2fb5e2c398de50e8b80d39cb97b0674bc59a81fdc8ef48f246c4e456d418b0acecc3221dedfa8c09984dda0e8c15b6bf6b60bfd61486ad593f213278a7b63d4fb6f827b636968f57cc6c5a11a6ac86a91801ffdb616b5a826bfa06f1c89d7f986e8eb2147360306efa873e711c0b040d3eea47cea72b8be42414266a041caf745ad44c6493f70b471eeecf3ec02326f8483bbb8efa65098b7d8f6aa45c5106e9245094a75e36164542b5cf7ef26bce9e59dbfab336d2f57c71fbd267c7368f53f242fb9adb443e3ec48309009b3a1f677033f5217c7be4c237cb4b74f75d51f628c7acda89fcf1394711af70316f336d8b3d58ee6d29de554d3385365d4ef020831e9deaff5bd7db5bed96e38768aa85ae0d9e83454235ff42f9f43028363e4f5c59e3c911c856cf4c118f87cd5906c0212ad723d83208fdfc4963eafbd7a8bf7d391c9f9a636ed13ded7862d936c3d3c03505ec20738b08d2285b18b06716d0e8bd1fd377c6b7470a12b43ea0bf363d7202f795b30d6e20531079a3a79498ff8640b74f30e1c59fb797c613ce0aa66c094f590ac54939e70cecb4735bb5b9e7ed7b90b0e00f4564214960f1180b7504239314bfcf0369d4064c465cca7920247fcedd54cf3e914e9ca1a1543b59da5205e19acfc1965e3ad569067fc7f3b1d2cf8961656ccacf5cf3d603e0ab202226bd1968895b155f2529a07cc54dc5b87a0f65956b392ed983b9088e755c697f64ce9f6658c95a821bab4ed5a544a641f3d2d992429838dcddad4a68e0c5dc63de18b2100ab96381af1b135058f0978e136c2bce0388a85bee9e7738aae4cd50282e836e0048460d22c453e96f75d2b032cf02269fd08f6088725d5f5ef301ff06d908a6c1203de5263e314fe2d542dd1e26544655a3ed47abeac3d7d6b086e21eb97bee15f6cd530f3186c09d902ba7a686a901468faf056832345979f533982f2750953ce37c3940694e658b7f2d89e70d6d845cd44dd515fd23e9735fbda6f9dd79a569dce142bc0b64512b6948ddf80fafaa93914e7b1574d6e4a4c76097b85a48b7de8a057fa6e50e934f43767af75d42851bf9d033f5d6c3591f9b07e9e199eb1f7b1dd149dffee235d7ae06f03397101d920304e42644c30bfcb550a84adc5b2d92c0fd5707c9aca0f454fc44c6ccf7a5a9dabda3cec5ddef39a43ab058d9717f474fc9bb84d91d279fa8c89af9a64e13cc02fe5e08fd982d614b749bb47c7cb38123ad85a28b3ab16b6b4240d897a49a8f5090e9b94642c05149e442d093a62052a8deb654719e308efeb42788b4a5a98cb3b3650b4444a2039403cad055bec4afed96e2818ed73d2ace7d503512c29cbb4a673c8cd7fd705c705b40ec9e3fe7e2254b5da04f7e6ae8c7fbc93a1dbb47734d4028616fa6548befd45e3487900bb601e4aa820c78bfc47432559b58a82b8b3fbbb2f92ba42b85852ff3dddb121ddda76c14c2e9cd097d433b72e9f6d11a15ed452153a1ecf399b2f9ba58a17ac5f30deceef1a883dc6540cefa0053526d6af6690e014dbe01fa1877985ea2ea4489ddd5f5ac799b2dcd227dcbe9948ebcb7f172f9783a4f0165b8c45f0e0e9683ee0dccfa227aa675ea35906695db351f320f936f92218571a7fde208c4025bcb4884382c350a36b5855b4d600fdd2cb720c9ee3e1d1f88d56c09028a5b36b70ef84bbcde8c44e74d22ba70006321ebd1c2a88be4460ed2c073b535c3538b01e06445f195277f4a112ef9fdf8a1591168b9dd738dd82c2c6240c474cd20321d7746b20a8fa64caf243f129dcd133b74785c42d778f999c83ea0fc0a00387f6b48fd28a69fbc5d1aa17d4a61ec9c0829febd5e20887d2542e747a29870c4eb844a30ad6eb4de4c26a956c30ecc343cd8537a24aac0fb36b6d1bee4deb1a18b305005bd952dd9a59917444da3fa0a1dc40469079d8e857becf20555bc982866edd0b0bd1a90ffeadac0c8d7a34db2419ad97f9fe7c74e030ac75d6ddefacaadb256e9d5e0fad135d99c233c324c5b96bbaef7b3b4188ef9f28a23c6c720b4e806bfc9a2ff2a164624ad46814c789a3fdc9e886c91449fa2c20568ceabe4f9afc9358b6ce0e6f7284e1f6e9523ca573f7ae322bcae4e939822e48dbd4305ee311d9437045ce08180bb91350b0d1319f92f1e0bf6279e6996f5639ac9ceab74fcaeb91e0d5cbad6f29360bcc3f783cbc5ef0ddb159e94571ac43d6a6b05ca963def61eaad8dbaa54c9c11b57379d4ee7b465140db570adf9c6208fe66dce1b58db02f69d2b18be84c1692ef314fdf0fd23a3e4ad8e3462c7da4aca50fb9314eab2f3652391651fefa30dd195d840250c85b66fd7629e532a8471d153757ee22c26ef0d73726cad64d6e15ada2dc621c51fcbf32489bafcc32dbcb39b22cbdd2aba854f6bdf1a4a02cd25a7b9ee74cfd6542b2b48074306ef89be8432c1470ad33d8ba01686bbe7b1f47a558d5c9617cc6e07afeac8ff065d527e873d8e6babaab0c364c21587d352354b53bdf4871e1fede1d2a4cc93ea115f80b6a6aeaf0773c35380ddfc6356ef4a7033851c7c3cce214e6abf730d4ba6f96a9d1255bcb9004ccd20949078bad018d89857d1e033718f203926a164d05c1cb8f845e366c91461006e12eee9288be5720836ba8d616b58a56f042cea8f75f2fd539cdb6c5486656fcb7e3cbba07ffee9bac5fa6bee6d7a5a262c27b76fe9842c0d7d8c698587bd60369121d7a8ea29ca18e465d56c6ca19ce84a5b3e2816480893d55a2c57eefd9355a5d0b666aef5b0dba03fc56ac764bca9bfa8a26dd17cb1d2c3cda8ccf1a191305e074c398edc88d0c6eb1ef3834ffed2dc3227a4fd69591e791c687d21677bac82e259eb213d4a76011789a2d765fc942a99e6e255a9cdc340073e8af7571a9a38e026e1065972005254107d2255722c4489e825b746bbd5b24b328668367cc9b052923a82745412d026768b1658a1f5d59dcda51386ec2d43184d8d93fc4c46bd093c1f3efbe07563713073c5854916765d11e19558ceb51fbeac51d35633a0c1c832618469d8b06855f6eb98bb89656aaa7c106627647c82d2481f02b6ce9d3502293e605df40e5ec04b50a6146bc1aaeaa65e0287ab34e0d6b049dd81009376ae76bb14692c0ba798c38f2297894e7bda94e4a5c390d35c07e27038bb9b4a8b83d7fc36a48d34e998746ffaac6401f81e26f325f04d73a94d40738b3cb3a8254dd55dd207f14127ef71310c9e8315b4f64e242630738bfcb0a675f8375f7c669383ccdc4fd9691c483af25c777807c5b72366bb2d281f6f9f49542ed4a23d6b7a3f9887dfa0ea1bc566659e3a5118f65f8015262ac0d44397e9be0209f0dbadf9c657706517db5a46de36064fa618e2f1add8926de7bd34799223f004606762398fc5e013fcda6e0eb9e603180f191e5b1714cf7e9fddf8d29f0e438f32a73afab6d031e1b374c85b1da6f8ee9d928d6d3be5fb84216700e33f88dd6b1d5b295986d6dbe45e18e66b7ea96a5d1d806b204874c2f3f0e2820dda23e6fe39a23b9619f4a8c94b089fa63e0e74dc124d84447847cf2e0bb7af9efb7533773a86c639b812e6210fcd24630aa62c07d2d3e973bc1e915ca06b02c7236781b1d116616573e0772b7d5962a57378ac1caa3ba1acd3c8cd95b96503a426854dc115603225c139b2ac17286c955fab628b89ba6f7a7410918d419c974a2c70b38fa1cf0aa94ec725175d039edc801e01c86a1446de2ab816b9d6c299e7c85254cc90045abe816a0b87230032c9fa0d4c32ebd90e91fdc0eced58a43f13c640519323ec79de490b4b504818c0d39d9eda10ecd355093f7e345e7585a4ace3fe18e8ae4e297e2245c73450d37e3f13eb4bd8fe988432658b446ca8e62469883a911bd8bed5aabeecbb98bb12e0bd1c2d5a60c158532655a0e4480df5e259d5868accbeb940f6f86df33a18341feb97c77a8b271525275fd93b4da2c299f5f97062a3045be5c5cc83777e1ceb5fc619fe39f68d619800cbcfb9bcf61f7706ada929d5b362302633efc0198f4403e5d3163fa1479a037fd06cd5de88bdd4366e261126d061d86bbd4094fcf7fdd6f62c038afc68622a8126669c54736a92e2b9d11a68e17488a07f321f4f66dd89f4980a011cc51c43c7f15301501959e111eb06f6cda3a26dca7d8be849e86b15e16718f49d113db6207cc2198da0e9f809ff6b8f9911020721c75f30b59ee44d17722c943bacff06107227fa1c9978a500f944ef6ae69ee084a112ffd84d21be4cb3f34f6ef1d2ed198d8cabf58b0f6db559bbda0ea52e468a679dfb9beb8150a9ec5817550d17ea799cf9998e5a3abf33fa34c3e342609b29ab6bc229668c660599dfe20e8145c366fb5d07d5aca9bb4e6c36384f3b440d31e67ee14b45fd9e53b43689a07e95343ae68f61fb89ed5229af98bde60184eda9497c82cfd836ad6f68d5a2d3e06073c24521e48bd2a1bb2d963ece56222889939099bcba0fff085906b4c59f63d4baa161949df41af86d867086317bf5a1d25c4030fd277ad55511ba5acbaaa2fc8eca460963dc84f9de89b740a795205ae7c8a516acd437ca92b5503d4889305dba95a4b6b370de666e648a151055c12b3f9c9e56966d2a93c526241531a441ce13da70d7fbffbc552af59b2864390bfb27a103b9763c4e0d697ec4ae66b12451f834a44272b89a112686fe00002b7e936cd343f271876cb564f233dfa8d784f8a9161dac74bcec372eca664ceb2318c0ac8ee6aced8f3c920ea0307f9272ba375a9ba45260d7d99e7a06928a60e3e871e9bc2453ea8c6a69c252e544b47282dc854ccfed87ac78f4d9000ede89436bf318046c14499709e39c0fc2a634e5ed3cade02d74689cabd7d5b6c49df59734663263aad03805e5fbaffe71ace281f631172b9658e46592577f5bea97fc8b6061be077e3f1422b057ef6eaca23062dca7dc727c8b1cc5c991e5834df1ea7aa1f7013722b1fc0c52dc450e8f1d488f6b569c3a5d714667ab5ab3a5b4569719b6d29a5df834b8fe4ba1bc1323d13fd9388ef45d3400e33be1f97540827f2bd7cedffd50174576786a0deab0bbf081ce3e45752602868257f2c793a2bf9f00a959957d34a86d6d3ba58e3c96c909050b4a74efa352e7817dc7a096f1c35e8fdb5b79fc88eb186f290177da12e509d8a4513eff2804e0cab96eb4d12d87d3163fdfb4c93919ce7d11e62b99156e6cb171e733a4a2a760966e9b99fa1d83f1b6f3cf464e33d335ea1bce9d8eff928380d92fa932102d451aaf15ed74fe5d79b1d00cc2341417ac912793091c7fcd37dddb63ccd388b71cbab2d720aee21bdd60c2d0ab7da1b39c190039c859d919a510e22fb82a9e89018d1aa5207f174a7556decc2ec7697acdcaa9bb4b405619426d9eb17c29da6639c9fc19e396e4b2bd5f0ee26a65199ed78ea039160d967eb796265278f8c105503ad1652b6a7cdad5287460e1879ebe5db5ac6fb76d3174d1c2f272b8e2a27410f46c9107bacbe5f302ba28dee063152bd1668fa657ce20b0e7157e21a51eac9ba2f5fadd42e762bf0ed4bd8e0da83e2e4631d103c6dd8687b157e05edcd2cdcda30a77185b777133877321c0e2f0b581a0d2a45c5e103fbc328f21471f04d14decc9c335f9325763ffb936ff2ec67c72985103ea4c573e13fe96e1ee99733f0bffbf27455aa8d45b492ea69060cd107c63b2ba0ff0e6b4adea25d78f24387d3433673684f001564b80d15331f90040143a7eac18027ef21e55c8b57940dc5796dbe9ae631665332796ba8929515402423094221feba75b417de8090276574703d5800d6588e17fddb5738f5560646836589f5f9e07f6f4f6114b85fe81af1a174948a8fffb9d740feef447e1e112509e79e897e60426e58930ad78efa93b19da8451f388474ddd7687303c0cbcc219f1114b220a6dcd45c527be8ee7eb905c7ab2c79640303d2ed50a1fc687339659f63a309885232777b10fe9fef1fb073835c60ad85aedb9fc96a7e464bbed217da1ee07fcf3a9e17b42b3d96cb11f106b38f05a771282842d77d8fda7d9f8c6648b4c19a1625ebfe6441ec4937bfc60c120aba1efe8e85c27ae56dccb2dbee9f5f5bf844340beb3b6c7286c778495f0b1caece5a4c18e09cb45785f74450c4ae873d06e0adfa3c637eade645f3a6c0ee9764b52c186c08c377f9ab425c78ead4103a14b73eab0c2b67ced8cf1a7e0ecf8f72e15a8fdec2feb9429fe25fd6fed4d4def474c23e529e8987c06cc5437424bd94ead2953222bd4c084db8120f3c6dae1ab8e3df2e47112f3bb8ab62ec1db7746ef8eb1aa8704acf39cbef1d1f5f238581e0fc23013e839528f5b031bd93be2d328acf716061fade74159ff96fee0630b8b36dff9983406cd006253752b8f3b66a79ddfd974274238471200842b91ad8c180046b932986b0b85553e404e8fe837f5a01c10f03a7e366215de1571c7f79373620f350b0863c162b4697ad6f54c34c8439ac9415d4e77e9d9c0981ed3ba251237ed5947ce62f6c1bdeebf5c1e994155e8fbe87569468d24b53d733bb397432902557c2d99befa7bda18d5b2fe61a5b54d19c6eb018796adfd816a95dda7f9230d8b72fd1580fa93e21dea82b2e3dbc18398ee05941681dc9229dee33cd45daa302894c253854661ace030602ca91a666292fc2aba5a694750a8dfc6e76ce9427552b5c83fd88b22b2fadbe967ca9604b337095c8526cfd24e43183e52b7968775d763aaad78707b5268ff8ec35d74e46f945f90d5367a7eacb11f13cee787033b8da8f4e3f68bb5f89f2f09a5d9061cae1f362035a084a963d79072bfc91c07fc22f671cdd71f277caff2a891218a01843ae47c938500036609bad76fe978050f075f2b696a2257f43b80df8cc0e3abe18b039858ffd33a6e2ac3efa1a16c86b9b071a0d0f6872ccf50485c25e82ce6fc41cd0707a6d772aab8d7e9dd53a6dfbfd800ff75a8f66be1129b7a81c837710eb7c508fb985039a0f5a1dc38431d0c699f03394e526559906b1973e32a19d4152d4f2f819a88c6213bf95cc0f196942e512a65bd5227b168c00fa44db0edff614f8a267854389fc9b74524ef2c15d86fda0f0ca3ffcc0118410dc62d94846e875c6a26dd9966dc1091b2aec95c08e7083d4a5aff2e40b02d1156dae1467a12ac73f1a673cc7879490b1bac98139356d9c0caefc891a8d38e9291f3acd5039b3181c177e1f213c67a51aee7f9fa9df278990254df9a1538c13cbfb86673d91e577daf1a78e1e074b0ce0b11996b5ec4b601b72622d544d3a035fa907af73a6d562c72b108367283e57efc77c234acaffd4f4b7b897532f9cab5ace7b0d27bc8b9ff5d3d4e52a2fffb92de74fb13e14152dd0b04789337419c8c23c9989e2f9dcf36e78b11ce68c7ee18dc4df9987c4887552abbe67a0b57ff14c0f27f34ce3d48f7b62b4f19b746e20a0ef21c09a910b97028b35cf123b55ccd2d35dc1a9cbd756a1a8db4ffe56f3070c21c5809f1cfe0a66f36a8fa6d74d73172c2e889d67ef84f19125f1cfa1718d843c840efdf1eadbe386fec1b7c47c9d619ca13e56ae5a2723798089766e8816904e6cd110b40c9fa2a1ff5b8a0762cb1d7b37336258a6f1ab92f225b9b7284b6aa07b52588197c63e46ec4c576f08c0eefdaf18e7c3b4eeffd9cd025f5d728d3da0fc8dc56685d92cfc71abe5b03f9195901ae1e471ab0ff9480647e949ec795e14329ba6746917591cb8e0fb7711cc7efc731f4757a24df274170a1f5444c5098bd3de5a2ecb8ea26d99089a083e045f9cbac74a66e173ba52a550424d0e6087a8f97afde0ce88d46ebebdc0e09149f73a746a9a24e50d65c3f6e3bef0b9cec353f863be96566b38526e1584402e08a3f02d2fa12fdd8e51e17c4fbcd345e80082d3cadc638f25e70fb086cc4af3bca410be545fa2d33b3c722e35a11e1158b39c8ca6f051e332fd332c3cea4c4e26364f8c1058439a6d3109884f1d0f170833b589c0c9ebf38cffba91c3236032017f308b0c4eedeb8eff23839baab920841b28d4805ed097cb33d2361a5f7cc954f7676fb7269e423edcdfd5afd209e2ba4825375e8176f2a686447b40a0ecdc7a9fcb6e8aef2c1726f6e1c04f9b1e92d69bf62e75d2bcceaf222683634c3ac50ee4a66cf5d6fe7b66da97bce361989a8d0d0b1349b53e66185548bf6b770455add5f9c55771f3d4a914586e1dbbbcb763feea0d7a2d22ddd6db5356be5d0323d454bc6ac41334317e6b8a69c93d4b74170e92d9582b080081d5a0b288a419abdd2f98cd620113c56bacd279689727ed6d5faaed4426c9a3093cb4829923c1eb87a12ecbf832b43808de6f43ebeffe91ee091a86d9d10da00119cb2315479c7e55b9dcb60ba2a80115371edd28c30f933e34fb0e9a45dd39b77b5796f279c0d0abe1430fc40095c792874ee8691ec456cc61db5142c9badc4a51f7dc4db4dff0a81cf8af038a4edfe09752e31de0ee939f9779b5d10a07136ada0bd7e7988aba45cab90fb03cdd248e65f3677a1ffde163301e603e3e13b4184ee712fc05ad1d7aa1647c1f21481d35e76bc3c8a4d4fd9d23acd9f5236ebf98abc30e3d2ebd878eb45d0ec21b7bc5991bb8911967992bc67016aba62dce2d12896c4ea27d86048718de1484682d5eb7e371961ef21f64b2bf34f31db4ea9c519d5c651d4bf9d300f2a32d8a6d4767a3af4e792672d3e2a18d9478fd603b7b384f5c616a58393b6122309fa5aa5b428b692496dfc3f6b96d517beee66a435d1ab272b9f7f6197725a12014356973ba8a31c1e38b4c565d91c01a6da0970cc26c6002108a63ce4919eac96d8e55ead0acfece0b7c0001d2783ac6268eb9e669526cdbee847515f25ced7f578c8495fdae56ebb466406da8ab9d6e32b714ea7d0c30a0936030219b81569c831b9009b624676705b266c97f9e3d63508f1a5b0e7fe0f29ca19760a7b764583827de93d553da62d3505e52f099c667050a0372b971f1a1a7eb13b22b9dab273886b9995a308ae7c7d2001d07818b6347ae3cbd8e4db3b5ebb19ed6c1a92723a610e20766520acb5cc744cc61b779dae4361dbe58dc423284daef1d60a632cbbc060dbe067d82a98bf95513d157328bd7abafa9142a1e59acefaf77048efa0b9d510034446a20fee361c0a2a56fceca17bc43ebf6c17481de6c3ef1d84ad963fa9a36096f5132f81be4a478caa9ec79c8fea7f96a263674c144aa4869dfd1da8a83479210e37a72a36aff988d2e3b0efca877cb3e14c7b9ca0f3e0a41a06ca3675cc5b520a27b7e4da9b9c2a348ed18c5c90932741cb1d7d5cf39ca9e72f023762f00f741b8da5a799c3d92c65c8f0cf2109ada948a055d300564f7bcde3a5fb80978468dfa0a8f9ceeb5f9cd48f68bd353e58aff12f8eab9e279c0ad01554850187a231591e623a57e96b0c1f9bf4e9c00f2acc925b2f7a8d496d2207d73cba93b3385c848e022fba2723f9741ef0a3f8e90cbb7c0af226a335aee57bd85b147d90c86e0d633c1ff667d5cf2cfad80e9cb94163b180febd2c28bbbe64bac539d9a40ce760329552c0f85183927a487b4e0054972d7f6cc246c9d2e5ddf74bffc204878f80c94183f8b3f8eb6ad24b7ad602cd7cc6d93a6736fea9366447f12fcd0b0223e539aa79a2f7a873af4679b5aedf46b892273b9691904a2a7ca4cfc9d85d717e1b430d25496bab09e06a8c8d358b814f4eb46fe5ae5e05d8ba52bc9de0fbe00330fb23ad51fd4e6bd9e2706ea13bcb8ca1cca4bc61fc2d30e75ba5cc48c0f22abe2964071f7f59a8c3a8eaff6798a2841e42d2dfddab435a0a7541fe4309b01560aeaec538d9c8ae0b292821d93c7c33815b0ab438a009080ad6266078d6f82f632889f6d4d1e2fcb6f4c702979159ad0c97b300be0284bb2df742a08c3e690955ddaccc83f5464252171924739cfac33de1a71a28a2375046561d6fba17083b8a227ace98622ee6a8f6fd3e7e5e56474dac85598ab35630bae3933a24e7acb3fa791c18f346e4194f99e0f48eff636dc9f468adc4237707dbf18028036853744f84f3d1ce3415a70896a18ac1e989bee225383c6a3854a47ad4d0812154a65fcbc78660a6ffa93245092cb53160e75cf34b5b8abb132e8c52950ae5833e8e2ef0e923f97a38ac38f5fd730b7b00a61fb5624e9cd08a4287428d702878b8a5cc7c7ee8758bed289773255a009cf3aefbb43f9603f167a343e16fc05af042c96cfde172d8750d4b18f892dd7e78c98c98fe9fb5c9948b28910c7eb3e8be956659eb16c6cecca0d34038b13768ffdd2b7b3ca7fc27d45f58508537ea1815d496fa053ea404fdc8b33d993466c896d20e6058a35cee87f1cc16ce0bef303510700a974ff7fda2748ee4c17c5a2e39b4237e0f362857b87fca2352794e00084118dc20f45f581856f9b3ac989f037394847e41fdc8f753b5df40b943db3040425add21ba3e9f98f833742f085c143fcc1df5e3d5ab8275fef2db094e8c485681b12c394be91d798e95bb54ee320675d48e16c4c223d640eb3e10022d2fe08d620309bd102cb98344f19c4f429482d74d3795a632a5eb871a5380a9f2d521cede0d4f0dcbf1d0a9e5a53a5e9c4c256f08ab7e0dc2d43b99468de71bed6f5f57a2eb3d50a10ead4bc8910d7cf7f70d7a0d1ce784196e7bc7552eff363d9ecd82089b230ddec5bf28d5b83a8a497a0400c10d2e7a038c504244ce74c3a45653459fad7752fc2624579b5b910a84729dd692f3db357bab10c165829ca3ad30a3d72db38270ddc371c1ef7e0bc257aff4d044d2d8f81b5946960bb3450a737bff2a04aa5af7e49bc315c622b9e8778e6bce2733bbd308af4ca92a680df54c1ed1afd563e8d6ef7c4d19963a97ea3524f75250a1c2131b8f58d99b70cc810888ba473a59feae18eba649ae4b64ba91be0c4bfc9ffbebf6568941e354bcc83588c0cc1b2540c07e629452d6cac5cda08576eda806727f0834fae71ffe855647a4412cc1c21ee60eaaa46eedf2829d1e3e753593691e7da3d5e9929a98e120635b47cc8f1bc766e70b50c357ae7431867938eb8cb51b1bd2ce0479eb4ee931f29c3835521bde9652dd4ae955166740f6103b390e85b17dda5be46bb26eb07951162c27bf599cec72a2eec0ce0eb81032b60be9233eef70e36102eb1039f93cb5da0ace0892de264a4c1baa7948309ec30b9e0100f6bed2665e50472e57768648ab35773c911a8e0e92a47534fecb9f4c180d8ee157325997a1ccca61e0f2091fe83fbe7dbd857d54925662b30c3bad057223d4d7790d7b6bbe8953a485addeb253c4d10427f209f4262c52013270d0e6637d6dd619d24873f01b5a13ad2059d25303fcfea78f0529b89a469b4ac6fd99b3b7f82e22615f37971a859cb286cf64c7a3addd86b291a1e3c697a62767227e4457565e542ff51ed5ac249920319374cef3d0847921ab13eef470dc41d384c5da4aee64a34cf29092f3eea54b571e689fb2df07ae94222ab504a2182001b3ab341d8ee7d999456e16107ce84558bf126963fc19f0627ef91731462be8658964a397321224ff7916b7e0a2c802b690e2745dfd77abcaf51db9b8359aa7656bb2c4f4971e32d318debc7d7ac2835aa22ede28032009537e049b9b534d4bb050e5ab5c18763eb1e5e4b1bb77f637e456983dc2398bc957521f5feadefd1aaf40ff71e9d14ecf2e609883574590c12a684b6b648fa089425b94c8077af8925241ff7ff47eb7b152823630f57f2eca5fc9405bb399ab7de23a000d5cbe49eaecbc4df6dccc0cb9b3401a2d71a0bc83a6ab2877618e3934dc0d272593ead1289eca0a475a6ae036129f8e6540ebf83484d2f16304bfbdda954c7c604dd1dfdd0a500266b6241d25ba585274038b342c26a8d918720f04267321e816517f9fa66dfa4142b66d12108067135d637a56c20a70aea8aaf0b14ff09a48991ce9cde90a3dd00ec196fe09eeec306492f1c7896514cc6b77febfa650064ff980b100a37fd42dcc142dba90e42787218b6e44926761eb0e0feaa9fba2d5bd80de3e9723aa30b10db3b3a345070f127c73337dcad2bb8c3d2054edd3a8e6f88a417db07352e29d77b45c0ddcf2e10b6da87c14e7df483ba586d03b3cec0ef634b0359e3e3047b5c6a0997837b378e336e42aab528b019b8bdce243fb61d65b4692dac2e7394ba0bc78ecadb77c5b76c7355f0495ea9b9629158c0fb41e43f6930091415d614b46291805a9f8deffe004bffa0f976527f26100b8fdfc60e0dd83749bc8bfeeebb707bb4c76066492b2137abc4f45e6843952e5477f7a23c49a69e7fcc560205b1c0023bdb398d863af1074505bacd771e362beaf0b667d96bf8a3d60c115be21e4457a25a5f081f812577ed6cfc1e56ecf7e6554446cb0652c8cc9e43356beb6162cbd0ef77059aeac9c614291b321ebd1770d4e6890c48631d2e83e9abe2adbedae6d764846fc4390e7c92b4588aab81176548e0f1b2130ffc2e9aa516dc9897e9a6f481914d3adfea8c2777ac16277b6ac0d186e89197d34919eec32b805664492ac581fff407afc22da90cf8dcc82d513fe6c2c880ef5bf9dc88e19fb395e69bcde8c05f88e24fd93f36777f7e6fbab8c55c5dd274e1198df3a741ba37ff84bc57363d49a6021959db90344a8c98626c037c29b3fdd1091705d5695a3b070fb5196daf70ad68ef80c51f837b6c0693c5dedd38f3d7fd4d3dfaf3921ffbee9f57928854b83c7eca06538118a7b854d90dd82cb273af6ef912d53da799b7526c755d3c5431714724445bb6a15c58f717422c1e3ff3957f5c80142d2112f988b9333f5af5286ea64152d8006b0dbfe0d1959ef9c8eec3ff7764592f7a757654cf2d0e20d798c5d2df1e10ba02a5b4558f2af1ba230eded512719f0d42c7eef8557331648000040c44c891fe3b1155f5a7caba16b7c05f800654ef243488aaec0a51bc51b3098af8a5ba62486c8496f060dd4d86fee54313170ad9478aac5373212d694e9d781ab53bb73b995b5c68a49fd69d3fca3735ad1c6de5e19ff4becca8c5f8f752a4a608915c6daffd30338a7da0270deb50ccef7ccb1f5dbca5f191fb7683bc20fe1872eb7fd2ddaca4856c30e930fcd618a283f0734af5288f7d7b3cdbeda1f4cea93d1da66991111f9eb44712b50365986d1c66d6eabf31ff3e9b3a44faa277f4605fa5a5d3b8c6a17332f5db8f8d538f3beb51a7ad9ec107ebc09c01d555dda17d193debe169636baf063590027f31197c7a06114cc715d607c3d9a2a9c29fb8ea3936bc2047dc224ac515aec109d9870e5f8cb2d4fd9fdc4515e34abcba414f5b9caadf77464691975bda273fbcae040687944283c2cd55786079f9f8bf0bd92797713aadc4bdf1ac59d685b513f0e23266b4f835dccf74af68a6e6f3b94e6ce3531dcc77ba92b9559077ab63cc93bcaf4485c062ff43168118","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
