<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a998827106a5065592bfdbd1ca38f9ddc5b820ac8d02970854f95c0e2d774ea276074956ce50f6c40d4af7fd74158cc3883b7956e90a477eae40f509a910d65c07447542a9191aa0eb9c474c679dc719ee395385367da48ac134cb75356b7c4073fc65512b898263d2de521b3b23d2b088a1aa31fe7585db98106bc74b58abc49b1fa844ef07d260a55780212d82d7f76f61bcf435750b9b19bc81e7de94162051f2d29fe60dc6af6b388b631edbe245a17d055be62193457b265591fc96bc44585d2af831f629cb91af0100ce1924c04531d934d3a7a65f65ed1e3212b1b93594a9d635868e5c4ac47d9d71fee0b4dd9f3089c01b75693aa1c95ea7ad4cf4fdb8e550b996b372ca92f7dd070dbafd31d53c869724c59df6cfea2af589e5b0a64d058748db06bd3562a3a9aba966e61c7bbaa6e59ca6313e4598c1aef0b482f447c9025019d1732716b8c9efccff0c565802e137fd53fab46c1b69dea3ab8e2bbb85e8f415606d41eeb3fdf85ecd64faa333273d37cc5803b2ffadd101cca7798e7b638c7aad4a77962a76b92b0ea8dd56b6038f7ae2d78e61be4500b6dc8bc89e69271724673cde26f9147bfb3d2a6a1f32aef5bec64bb1a4e2d5659fb8e323a06f709d49afd10a279b4604bef794ec0deab81455e22dd932432aef746fc20b79818bcd624bc8aebe6cd86673e56ec2f915a213571cacb178d51a4f3cb9229448d1289d5c678aa9292f9a63a24d5eeb968fe673f619b0539d0de3b4df93e4a1640930ec956e96d255f62b32bc2c89a151ef993c6bf586db166ce81e9a1b8ea11d64d4e69827955117ef5a4327448b152bdcb4d5759453608eb6846a20abef0cb13ccc4229ed954e75a42734229d6b4fb3757473d3fc827cc38ce27bfcefbe54ad071ce84492a429478f3bcb2f07b7cc8c5980616667be094770e244df78a847a6fe1c6b5d72cc73ccfac05d69a9f579a904ff1434ea3c57e14ab11f7e60167aebec87bc8d488e2b40428041dad15d7124441340d560042fb4658a8cf83b570c8aac647b58a621a4c74c09e6ddc9925232f0c376706ed57daf942e12aeb169b49a7dc631815e8d4736a90b24aaee7604025101805ef60becde4227614b5211ccfc123877a3a085756a695ea632487d0931a3b16b29aece932a6a699793cb7b4137499f020b8b4fd591d97d82922f1ea4c0e6f0bf4dd9147ada0960f7250ca0969865d9c6684f03fd2f1484f9c4ec073158a375063eb9ef4c30f7c001bed60fbe2a154533ea6a44fdcbc2a68a46b1a3beb10bd323ebccd11174f34c2b1dfdd40ad045ef109bd57dd8ab96e9db9a8c4ca10d33ee4c069e31313f4ae62b93d4a2c2d9de3b48768da05a7721a0fe5cd1f73c23397bff7d15233130eae75de350ed6b8dd29937c1b9876ce967ab94d02e2fc7f5166c3db25b6e42ef570a2ee3769a5054d3c1ebc9502086862c116e7187521feec11cf80091eb19d056985a3d188648f324dd05ea650446cd930270fcbeeae9936e1077eebbc0a2cbf565f4a2943d1a99ec21ec482272379c842fedb7c7867cf2ca5188767d1c67b106153b547acd3bd3861d8ead9aadaadc8c41e34a0e1799a6070748a611439653735559f643c65548a4eb5f82bb5a844fa2f13509677b9cc875338b5b07fb637d911b090591c018b33247f8d034d672d11f7170e3e70b6d866a047958a58c2e0ea6b8c1c1292d1c04158e638f8f26d8b8c8db58c740dbc84fa772f122e499d27a9dbf23450ffb6d95779f145b82328621e6db0404ab461f9c25791bf7f6caa146dc8a6b4197099bb727a0779ee21cfd0e599440151a18bcfa05642d3ea2f28015ec05bd1ca3d7b7a9c2e3711bef9df220d0b75455d8624068999820b3380906c675172498203ed45aa09506397111438cc35fc76e4411086ecc1e3e1d77533cf343bf697ec97d77a7ddbb8c5f943b5a0063e29a584b2ce71233fa03309a6c996865a0128ef042b4bc8ef7b8833e4b347fc4a2a214c020724a2e06cf7c26c8c4335574cda0b6d61325a2a0d4944d6b977392708f393d2785959edbccbdf772d19d6d1bd4de8cdc16b1c5116ec4dd9960770b0d46743aa4c0d27b77012d3c3380a36eb284c43932e0c29836eaf333f43648557c2a2e95f5951f323c18c4f807e1b1a0c7fff5a5e3dba9dc9cbceffa76d55b6d9866a54c602485c153f1e0befb322da0ce855b82ded2ddb03d74cbce96292324310386fad24757b99f5b9760394804e23450b250fd1c4b24c1257d3d7d732a69e3736810280a1ad9e42b00dcb5251f19ec76152e731e5be05a1c4d31bd259c4c110604159cbd2ae14f6920e4f2391467d5fd1673bcb3856a1794209171c6d3a8ffc0d7f7f07660540120d5d7c3f15fd24e7290312cc634ac39a52b4b712902b2e15e0609977342f5930121055ed576ed74385066b60403766d18c1072aaefc7c96c331a1775dab6d3844c8ac6bcebeb8da22bb6a5135ef6e4975a667e7e105193f18834fc9a0f6fc85d25b6929b2981910052ce71782705cda18873965197619667f852df39f5f7ea9fb8b30ec49c12cbd1ba64ed8445b6198aa84b56600feaeb329da150ed8c0b031ff2a487e1325ec4469b8d5753336d77c7b515ef1b94ad44e214e742d5e5a124b86f389d982db57eb271de8545c890f8c4454c01e6358277a40f61365fa3df1026c22fb6d409bfec8557c63d2e14fa8f44ef96621d21b444141a34f1f1da6cec934df6450e4448fc9e1b8894d6b591c53c202dc5bc5d2439e94c6eafb69e7f1bea36af0e57557aa1657b04e7847a9bf4d735a586975376b34e3d03c5b315e38688d0eb1374c10ca8c58a5e8e005111a6087de9a09a6cd499b22953be94ac8e4bc480c10ecde7355a68684da8e755dadfbdaadf83b8b84a116fead1b2f0574a97fae93b7182c6f41190866289bc3056a7b747fb4ff39c65e30b23ed95d1a7be33bd6a2a88ff161c182398ce458238083582c384f958d339bd3caef1c12af378d015ca1e766e7d8e45800ec094e6cee76609b6a2227d2148af1debd3ea1926dfcc2bc6f3f77dfb0408c69f667fe1c39f341e2a499732da9d0e3eabeff2272dfe8a2c2fd5fd76eae01885e6dc5c80377cbe6d45ec673041a36bfc3be02519e0d98847df3728d6832c9214f13612aea6ad617b505a1470d9c1929f5644f4ae65dce69800f2675d9605a892c60012afb6fa9a8be79cddeea7e45092b6d79f16363fd29c06f85eab11467060720a9a96755dff231752bb23e9fe55b8661689dac4bbbefdbb0d069e7eb24e6f33f22c101233baabcb3593263599617c2f1edf7f76874fd887d96da7d15d7d8c28f01981da82e7dd9922f0fc8085c5172f815a828043aaace66b7ae38307325323bc54d54a42981106f7eda221b549578c3e68fccbce1514b970e775e064c6f43e8b4647435226299ebf3e474129c6ab4ba7485a3a11e570149c1ec910b497587b750e74708a19a23009a399375169ac19463ba25675aeaa9ee290b852365cbe531aecaba9c61766c5c585a70e67010a9699c8016fe99013769565ffacb37eef0b5e2d5c7d9ede1f779b36c2180bc181ec4b79f3193323eeb50eb7a3e288bd88c1d4ba5de00f08c6618c3f37bdc934ac2630075ea267b88cea6051edd3e7c78c33756630449e156e790ef0d63771a2568f561eb2f3ef451640f9914ba9b182b1e88ac4f0bd71be0f3de63a30ea3504041aab5d12577f5089343719472fc9b9f3cded199422f43d4eadbdf23d05ed349866c9cb3e693fdd724b9402ef896b12375765f129a6f047ee3c3c6de94e0becdc2a8136b751ae8369ebab84ba3f4b62763e672b88eea398a1197c1ac65aad80723965db9b56b576b6da3359839caca92d908aa1c76a47a586d7760bf4c2bc95f8849d18562f91be39cbd976b1500a67b080626970377fad9cc1c36feea1d2f6b9413bb2701b317f2808dbc1e7904d067da0ac04f1f86a1c433cbb97353327d54c03c2a8e7e0cb870f4598250435ab8e28548d7cfe56770dd0727396f994cd0db138132bd282a8472fe87538a5d176666d3cba04fd1a27dd2526776858479e9dd4d9b1a145f62fdf21427af4f35bd900d200f5271e8d199cc1a8a1dc29bc078478495e7a514cfe299dbbfe28539401349277ba6b857e2daa4487a7301a8653db12f69c003942f474b72c0436dc24ae0c4731314c35e064af1a15d189f7ab907af56c809bfe89a8720340efe0887722b38452c7d4809a2611310eeec3c4cc6b434de661325332f9fc562dbdc200dd39900e878e13a9b36cf38444e63a352d80c8f49aa14afe982270061c088de565f3bfb6eecf8d5c05241b25ca38165a9c18597ccbd8e3f545226e8a3df39d46da1b543edcf5181f995265c63225ab62f75e693c550a86e49fae144a374147247df41841a50d9b7e63ab65946ccd610f76931f81bdab0bf53a65db9aeee626eb62f13aaa5fb73f8fb3b81ac9816b2aaa373f20998903f2bcb44e548285192736239e23b0b0bbcc6f8a17902fa5b7d6dc2c7e8802beaf11526c4d075e86e5e92f89316580b163c13c7beb5c36b8497cc3cfaef236874aa3537bfb352654100e781c3af612db66016a5112acc4be136ef0970e94e4261e3fb08dda71c090fff8836ea5e3c3abd4d0222f8fe5b050ebbe85ab0ffdc74314c111df0a95f3a98fc8af7d4f7f56e45e7f962962110f9e2cf93b1819489f182ff542b21a133f979dbeaaa4213e0141de300ad2acc95d62a1b35a19c75ba3d90dc0d4560e00c0d0e4211ded6df4b638cdd30d746f31cea618adaa2d68719b1ddba87af51b25531ea4654c664ffd35ccf6dae9243728c16575b82a77cb280f4b1843219cf27f7c34bbee3f18e6246b7196f7f80c1f077dffbd1eba37f37daed4c5c5cbec0ab3203875e0ca3151e212fb7753a0caea9efbef2c88fd0db3d23ef2d91b3d54c5c5e8b601866f6d7ad5d9a882d21c07a0a0a089e33de7238971e9cee072890cb2d5c8063c1ae4683c094f56643a228ba7cbdcb8e53f7686ee37d5c5a9e197367f9100179e58490af4974ab4af12a458716a04d3924bb6bbf6d819367071bfbdd92ee9011847d4f437d45ea2a26b828823f0369d460ccefbb36cae4f9aed87d3cd6c304796a795354fc13afc30a1eb262b1d7526116d803be6134fb393ae7b226bfb614ac23580861e5cf2c8e3bbeb72d51e652e55f318677a806e59ad1d354b1a979536fb0993ca8a82a755a1a0140b125c426c779cf68120ee13a7d1baf22db450306d29ae3a059fab1018015cdef0a638bc2ff91b3c0a7dbac39b0b31c176765e9f6bda3e5753fd0955848b712b62fbf372413b40fabfef2dea4205eb79de17503fdb98f76af7947e27d29d750e0df1ba157002272487b803f727600a793903e0f8be5743476d5f802eacd15e6eeffd8a86d87a0daafd7f57843d503583d5f8374d104c2c29e242127cadd407ee398a8a248487f2838ec62f6762c7116af31dbe4fbd5ffb48b37d9d5a174a8296c6054e4e29bf98a1fd65e7278021edafb830c0beb34c1e8ecbfde22d2d476cc3b491f605f185d9fa2d24f37b41ad2868305a6655ee6093deca9b308c8eb15be2e15eeca8e3a1efe533da85916a11650620e70ff4454d50aecb49d3af5e437ced6d009daca6a5825f4456235e302cfe95c6359cd62ad206e615627c41c8c508cdeab3bc5cd3f3648c6ea3871b2e36dbea5b41eb0dd0b8ec6c4c3a54bb844749b103ff3712e7740ac1290f04041133282bed413b71782584095950d9ea4829ca8b8b34daadd48e274d1f1eb8ad21f5f2caee1faba7e1190b90925156e8e6d0bd7c5e2ed0cf947c3aab7d0da213aaa4ecdf91c76b5072d543968588c51cba419c42a062fbf8ae202800c5fa6efa6fd79072808a45f873f97a162ba51bab20f561829e5048fff475c24c9af016f7092e1a64305a315054086b96ec706d92d6f7b66e0b68fa70d2482849e33674cbf6d9ae34c91540f92f5f5230bd103bc8ba47106ab7127521e32f3184a7e558e4ab96d3231f2e34effb5b83f2ce63f8fa9878bc736471b646c432f5d351828ceaf32910238c597bd302abe2ffbf4f84893629d5110120a31149f401ccd8765c13a7b693ccd5be32a057933eda71e92065a95c4951768d5279c5ab5b21aa940443caa19ac653f17c204de2dbbe33901727d50b71252e6bbbd65ccc5c1bad7ef48fdaed5d0e3d7cef54789fbcd4db2f6c355dbe92d19103fed4a1e59117f66c689bcfddb1a664a0374df1f84c5aeac86bba286d89def186e46eacd859c6f0c06bb721df8ad027b2438c50b2fdb98d6fa910fa7a4b6176c6d6fdc3aa4734aaf9e2fd29666917d98edfdade77188bbd11e11a1bfd4bfd664cba61eb3808cbc1f9cb2b1b0fa57e3e237f213b797a2efe022af5721da139186df38c02f9e6fc3ebeaf1cdede407e6e9b766790b97c87ee70c7d4d5a34339f7e47a937c859f190cfe588c238ed32ca71c527ff313058277116bf43f01e4ba2babd76f4f74718ef7cd7a92bc6ace9e0ca9b44e2914ef762cd85942d16e736f4e1c7c2a3e622d5fd671ff31cb21475d0edf34c3058486e288c5e4578fd2bb8dd43e466640ac5de5a9c1fe46ee979e64c8e35b6cd41d1be608dd42ccb7bac46a33acd68ad5ef457740f72c2bb9075c9522437e6f9fc93f8e9b9da4745cb8f2b6eba4fda588ba98a16edea1d7c322a02834ce53fea474accbd3d22cecd9722d2ef52591c71db6e71c4887cd79c744ed639c881cefdd5c14ac735b1a9e2ebb5670eeed1d3b11980769a4b1457e75a401a9bfe2541c961f3fa8ee1873730cf151d6f28a60dfbf33337ee05a83aca52ee7608c13c9d16ff3f3dc8f1168116897e4ba178f2fea1cf96f0cf375e1f452a475a324e5abb0eea4b63c4b10f763f6adea03977583c1e6a9f4eb074fb26623d867fb6d79ce181436d5c821e038fa9a6a284daa6695dae7869c879a77da12f1f0231b2f9d04f0ae31604ff28f3006f5b2b209434a7bad1a8ac3abcadba5e14702953cad668089fad07325995a16d205105fa97e89104a8c59ff9e9b0c27382292b3bbfbf14abf7c392dfb26c266dced45bfc8e7cec3195961aae8977290e9b7f856dcb4c6eab6c01dfab7d6fb17445377c7853a14667bf21070c1fac8710a35e6ca3ad9adf9af6c76969aa90e9e79170d3de4e54ba7bf3e86c99cc6d5ac448c7c5bda0108282cbb9d3ac7a5f644dae7957d33dd80acdec8ab4191d5ee2d05ac5db8ab303dbf5a68b672fc44a942653cfd4d0f0079135931287ed00d86c28fabfdb4c2f84c1dd55444c452609ab847e723c0ed373ef13fbb604dc023d646359f4d6142fa430f92ae1ec02ff115f7dc011b7dace3d62407190a4fb035522c4a310b06d59360dd0562479552faf2a2e802d0fb5b9384de430e7b52800d7c1eb2ac373baf032577444ee1cea4b6997695d44401d9cb76fe047d0e3d4c55f71698ff91103324f592044f50b6d888ded2ff8b080b4b09dcddc0d236ca38b5a6cfa85b138afe11b89decf4002977907af5c41d84c0599cb5d00ac6e233c51d7dc4e3845408be80959c7b540bc8de830496671e5eeebc92aefdf4a2e9027cb5ee40f682a1d041c75f22c512fe6ec2c9894e90b20eb63fb8184127a1dc035de33e82ec00b2955f36f6b1db6d6a2f991fb02bee2912bfb144e4e9440a51482a8c29e80cdf0a496180b3dd93fd7cb1ce45373be15739d0448ac3a10b31955e7fabdd6f53aa97fee15d4739372b70a19ab962c075be15b18fe44079d635c9aa14d5ff0ffd83a3933129682b2e0d594f251028a216419b31139f539573763fc0f5280de1f6c6b0537ad845ccc6a814cc1d172c0adc88421a562c8d00bff7edf3fc1a562844e77a3bcf409a5a5afe40353464fd6ab0eae5ff92e77f724a91dbfbac8c6f594d42682df0e8cb0ce21a3588a985784d729e8fbdecc51d96c9ff41576eb4f1f17c7f42943ad4695719fbbd622867bc400ef12f6e7727141b1e9d11f0e9a722a3d2cfa051703ce31dae1563948fcf9be7389535dc2284343dbd3441ae59ac0b0aa541f3e5d8cb8994f2492ac8834e1361ed608dbddaea5a87aadfc67ce0184fbbde46ac4efc615c57647684f5605c73aeeadebd6211fefd30f389efeca6755e22d150f000bf7766db063e4ac748f3a0081287033d2a9b1ac57b599b69532064cb36f28ced46df791c8a9b045485924cf5ae37055c6d0119fa4ecf3125c6060c734272ead2f75afa75b5f3b726ad19915d8c21d492545f4ae6d446aa15dd6dace6b5b00438918411681ca3662067b221377b118a00f5eb3d0b7f9bd9d6492a2c84f6e6a77b33632cf0bca38ebf5eb757b25935a91cf102f198096f13ea7db6b615d84b748ff1ef7c676e556a52392ece1aac331546843bb14526677c429575db92d925ce6423c129a4cf1d1335a15b07223b4fab14a7ec814bfadcec0341f0f6e12b458755eba06d70659fa3ae24258ad9b84203e1000d1888b478ac3958c0a6269683360387d70e32fe7cc6301907ff49c198ebe4a68c0a14a17f25e8187f2b2a4b9b37f5a3eea29695daaf55915ecb71fa0f242f961ca746095292726243bd6af7cb79d918faa131ba8f67fea927a47e6f700f7236fdd157e6eef8fbce4625fc4d810b9637c918edafcf523ff921ed7038611d93b5ebbb336573a34c873c657a03b466d62a2bffe65e2df3f9b12273f9944b46e60348df16bc52f810ec2ae30f64f83af88b0894c1523a75c04b18db0f11fefcbd583a0dec9d1251d3293ebdda8b2bf8a89bd19992302004186112867779d1229a14a3458baa1173335f07f51ef33e4f20ab05418f4221cc780a4382e6545190c882785d6858818a374c6ca835f6725b15976d939001b061d3f1370636625193f5c684208d652b563fc840d4e73f7604bb9d3daf1c87c09f57bebe691d00a8270f0587ee3650192013672f295056303d7568fa2e9b3c06dd90186588b32642e93830f185ab31eef423422be97cbce7c4be5317c9e794a9730cbc331523ffe8028756557e16a541a8e68be85d8fee04ebcd2f302154ded7f17928cbf1dd6e8dfb19eabec85093d77db54a69569a7690045397e1664fd6df7256b9fb875e7611b3c6dee4856521e83c58b1f00d51aa793669f10f9f2a886f69908b2b02b7368154942de3a99541335eeceddcbc73c271b64631efa460c36bfee0a7191b0e536c166433425785868fde8ba70e778fa20c75c0db4539fef97dbfb2784122e9634108b1c9358c597114ade5a147dd8e74aafd2743ed82f5becec5206c9407f68dca67ee6749471af3aaa156abd55cb7f6c617b4f27a88eeb91487ab7ff0e9f62ab931e894163661bad5061ee8862e369fe9d5dd9d51934dff3ff68629a5321b4f1096e57afa48721196289ec9c8b71ad47f9ac297922a7aa8ca3d9e2b882df98ee87be2a2bbdf6ad18250f4ecfbd41d367e14ff0233671b960bc19ef68e19c8671b240f025b123b7d9e3f3a18a94704ddc2babc3ef1cbcaedb17074b7f855cb073f5592c0da174a6bd334389c69a617493eb3088a0cb0f183f40dd381df39c803af727005b97dc1df333dddeaf8b21a99a6564b801e173880e34be01c5f5719002bb798ed7335637979c35a08d32ae8627e3ecd4399b3a3eab042c01201d95480fe1501d75f5fcee2332c79fecb57e337d27bc19fc2c5b01a98ce784340b815a5be6076dd4685265b2d48124dd67ec7d4171891b5a954ee84b95ebd965c63b2d1c0d4d4d8fdcbbc06515ad6337001ee386754ec9d8deb10fa8a32af1846583b6fd62293e0d3ac961579c1dd23f97707cfe0f5bc6f94889b8f1e8cbfaedbbbf1bd46bd4135f98b1ca3a4ce09346c70f4fc00ee0105ac9ace234dd8a401f09673429deaf505421985146ffff2a9caa39ab87cf0b0b0c6e9f40c94824a4df126f694a04108947db9168ccf480fe8b1bc92b2a8765a331a77ee18eb180fa8bd06816f83022fa7fdd5a4881ed29780e6ce6ac5e6d61b3d535d22d683269211fb06eb2b3b181a0d925603e7d19769886a0b867990829be3d6d18ca20249f5917a236f9c88c68bf7d792b455ffff037c41d539169c22fa0c3da469c761679c76bc885cf3630363a34b4ea929d0ced1445254bdf4e66a2769279770103229080326a86461b576b746b30c9adfcc31e3a2fd9c24cc04e096b65220a61016852f24214893c9e98560a2cf95e0e9fab9e781b949baadfeb22bdd44d2ec685404825d5f6a98927866e89333e57aa3d41f0a02f29257e4cb76bc95686ea6873b48af75ae36efb0183bca259a0310044995e469ffa7f72bfaaf7cc09a3874bf045b01ca9b5a7c941eff1cddbdca5dae12e1d8e5d93dbdcac18827c5fea4b588d6218f22442b36b0b23c88e058f5b49f26d1316fd71840bd14d21e9c34de943f29120449cb850037f952949b1837e15b71cc78a2ef82b7049daafc143b63fca46408c37c399385223aa9c370947ec205110e258f6d499b2dbaa9c3b015cd35ddad52126a02f5edeee160d9c62d3b3b53ffd98836b9cfe7fc87fe9a59cfab29062d1f5c07d801c8bd00f201d2697a55a4c29f209a732b71c1fd800dafe9ded3f50d3d662442bee87d52f46cc3566d22edb890f090fcef547b52f906864e944e222d02a7431de3b703e9d0f08a4c5946c09edd95a22410a8eff7fb195153f1369130b8311e713fddf500fa2578f6a1788fb2c9cbfd6e198c95298cbcf7fe2f3376415746bf4dac31ac94643413b3e1720ae391eef65491c2675e6f107ca8d38156435a79ab08706460f2c58bb143f2a96bf48486c5d8e24477d7591c57b75439754426003b2fc481ecec84413ea09948de709112387cbfe1989da462e4c18369fde71fd897e6d4e2dd479a64f93b8200a4d51809347226b96e9ae597ac072db5bc05c65d13ca7681513b4fec45b92ae01f726180fb3410bc092b2ea2e1ed45bfaf7ba7ff5329f6f6e66475b727ff87e8b14ff079abcf9e3bbc280143170d33f036b286c0da2e4d670059595287f5939559c9f085e89ff44e697f03a35fb38d2a19eae7a4a962bec4ab6867eb48c85ef8629e0705d7b6aeafd3ace2d824f5f541c6de9b8aeff26678a13f00831ac1bfb9d4f283b0cbfc00d0560b97f077b85c65b2f9c86367132b90b07bf26d583f1d0636de4ec85848de31a4c8a315aa23343e6511a34a73b41a36a432abb2fbf8df0863ae79c282c67034eb79025626ca5578fe60e1a2faed2c12718257f011b801ecec80dd6fc647ec702b6f001b4afaf0d39c213e48c9966f3227285b117cb1f8c3b4d42df0737e2ea7d73dac7da38020636201614faf263b0d9ed40a7659b2bfc14dfd5a3dd05e12bfc66490815c13c6f27bd2d60e1ce9104ee9f7ee4ab9559b4e57650cd7a3c532e8f4b662b4df16035695facaae199e9bce368395f71bed850a306c46bbe4b9275991b08bc3461690b87c1c8f06d3222404dd31f2633e2c0b7b9c489faa25e98e542f74334ce18b5e4709cf83c274004f8df47edcddb9cfb5a79a2f910d5d02b9b188da348067785d11d093aeaa1c1efb9300f403975e02e8d1a0d6b034686ffc0deb7e3d1348f5cf36367188d7f7825597c33f5b72524e9f2a8349b47edbe2373b0823fcb3c9a342305065e32b1a5c0dbc9e9bba6f338bbdd729f563b14affa55ec7e32a828fa7e7e62a97679533e2216da71eb04f2f022f19c92917f9c091b8ab1c83b58aca6586bc72dcfe1c0ee2685eaaa122180955e37ad6d14ede9cc8557dbb93346214b89d7fe194afb846061d0668edd1be344d66670951092ef3d728772c7c5ad52d270a3dbb1baa7346d0221b9d4152ddfd476d4eeef7a8661f4e18e7e05bb7800ddacd4a9db28c483c0a4aa7b63f169f1aad0f61056ff041456dbeb44c5a6e8710c37668bdaf59ae5d9da825a873bca116ce1219c1e896fc9ee4da1f6307c2293f199e3c46b06153f08e13bc39bfd1451c2a0ec34746ea9290f2fe1a2a3f754732a7b9210de95c653cb95542e0c077154537cb3dc19530c175257ab26eb2d32cf55d16d618bdd9240a22b632d7e72d81212b8ba6bf4c3dd4838a4522ebc60a5ada295f1d9bc7c5547eeae24164a9a1ef995e2793bc213cbdeb69666656a48b3d41ac3f530f1a5c201fee97d10727adcd3277a7edbca94af329cb8eac5380ee16359443f023ffc41f6811812fabceeb445d1e52d54d5fbc6a4f312d51155dee27b56e7582745b1345dad113168115438bdd918b246c5781d005849871910d3b4c44b10fb01390bbe4fe4fea87e9a5575df6420938d6691ed569bc01fdc0d42b38366579427780e295372e8e5deaa4396ee41698d95994280af31ccc01fafb17a3ef08b6a783ad39c4614e9d208a68ca5e5d606156dec27bb8a2a3f4815309dd9e832aa079f761249ff453deb3b7bcd57039801b9e27522071707081054bf475ba807dd7a365fa4953d8d23f482ba249b06900f6ab4652752d5a76349a59bd3f860a4465b5a65d1dd1a4247c87861ce2c50da6b0f8b6f02ef2e436d276d7de7b865fc9962a092c80e770a9794bd9d7899a077770e0219a08ea0ee8ed781f067900b33891b9a85316ad87f7fdb656ebe60850b2cc41743a0e161cc9897cacbfd1445c22bcf31c2b8711145e981773d1a4753920b0990a54fa627500b27d1203357ce841cdfb46866d5a683ee3577e15bf2f7f6ff4910247e41ebb4250a6111e659fd30a32e222007e8cbc84b4a068385874034e6a4fbd9baa58eb9cfa1b920fed01e0fc7f630e2049409c8614011498b3933f89cf82a3f0ef58e6b2798a4a974cbc2f8caadc7c270dd7a85fe4ae80e521728bc6520e023ac4d8a9ae2d32b79e1e4575454b8fb59b45808b0818f37791a2c3a3b78ce3fd9c0ddc07d71d4b12453f1698ad4bc1e8a9607eb037c3cca5fb166dd8c0d62ee075c43c5e02716f1b81288a53a48b489d46b5c95e5d261db5a975c77290f73f3090ad042853316afe966d257a5ea2df78fc22af99ef647078b0c3d8db7589d2ad3c6529f1b38dcd72095a110a4b41244264e1d36fea6b17cb72fb26097d3b0280fc9c5136a753d6892a54b298cb1dec946b0713b60a9221d15b165926565bb669f049ab00e7761cfce4b906fb1de1ab3dad22ca764e3f753d99a8796b16626bfb065f3b2e757d6fc40796b2893d1ff92068ed492e15cee6e5ec4282fdf3bc75820aca12247ec83cac1d8a2523aae53f44fac95f5fe8471b22c35e5dbbd5ee929fff4a47a51a414d8d568e9bb9861fc0681c00691a9af87231f14a0cd516716e19b88e2cb0282c37bab7f867d0ab94274c1124e592de9d71ac8c03bbbe618180510bac8bb17c48321e1e829e77a99f02f741af838def74aafce4ea9ca713c2efe6c378495791d1dc422fbd3189bf0c75fe987be6b3e43a7f256d84ba42e02121ecc1ff069376cb60301356cae34ae3a06d4f031e5c6f0c417b63c2f09f7b6cebd7988b39c4611a6019d2bdc410ff76d0b9e1efa26f8b373e84b78b00ae80e7288887513c9219dc48febc6cd1be74dadf18c0ceac6b1e3e212bb5a3ff886f2900e98a7de2164e7930ccc942a408ffd8b6af5a4b49f2ff47e4bfe82d60761665f43313cec5873bdc0ec4bfbda2fd3e04c9c5b727d7c7657623f33670de0f9c1fc69584fede1587576efb7a35186495f984717b082ccd7ff22257c985d6d14ff94a6e33b9a5ae390f3b4812bdeed62597b42dfccbed6ef7a5131e78d2b7e2c33f1deccc397e27af30075cbb6f6e6b9614c6e3afdfd213527b82364913ca6b028f02065a9c4023ce4f889f1872c5413964d0e7b2566205b6313dae5c2585dae78938eeb43165d28599720f34253716fef5a43858f1f9f7e244bb3582c77700c19c270ade9c96629ff2fbd9839858676d61e5bb6857ab896302d4e034542adc558feb648cb52897c06d56b508ba9cc4b60340a80784a2b2dfff32c5fa9b6a2a4315c284e0cd63f6bac17e10c61043f3274ae122b4584caafc274c2239d01a4d7af45b7d42f703ee477fb85311f8cb2f64a996bbd62bc7c75a7abeabadd575a8794a1a8bf59411b072be1acb6d050ff3def96f4dcba3c5c8ed61e7c4acfae05b79c3781e6eec4af903c5cbd135c239073d5960065bb0800b67c05a1ad37e021b1d0b4b00714678d5f78be84803e74cf7fc24f42e67ac0e0a13dd5bf5bc70127e950697edc47724039b3d6f53c234161b29b23824901f3377ad99e80de57c233f39ccc4da2cd99d702750e29f0b28ffe468c73a351c4b4e32405e830df0a5631e51bf94e6e0358daec47fa8aa7577c6d61eb77a055781daf163f76721c61133e12a776e625e25e778a28431662361ba19d4ca6e2b735fc091c7689179116b18f004db3a88a59498ece4271455a8a3453a8a48c4c4c3f8ef705cd33c5df4503d8aa279f5fc730465b05815562d6f40f13b2211aa1f1b678ed264b2bc36e44b3a023e5e4103a69313318ef288fb8fc5e1f1b635c377a54863e4d1db0eb7f7fde362ea87652c7a08bad0b0828f70e0cf21971d56b921032260812cb4a3b51a182a916345d718979492485f92f676f6b81185aa1cf7b540f979a70f0f94c69d7418378bc48931279e9bb1ef89c7eaddcb101672601942dc0d78043b598a001df6a944a838c51002372594145210d501ac3e5309fda1eec315242ad98892aaa3a57ca3ac24a95694eb95ac7b636d83347654f00d2fd0de576f3858723906c5e6fa671f4581770f352e395bf2e4db339ee6cd99be91305a45cf7b9fc27b1c7ba75cf37a3bdc0c05a60f67f75b70a9152ba8a52ff30068b96c2f71317cdaeb765613f012df2b17d240d5ef04babed2a09ec6693f4743efcb6464e92edeb3da04d2b57b2f729c7df7ebc5ceec36a39036a2a85af8a4095381b41c763cba5f3bcc7e25aa127d004374c20c4e0e4abcc2f60d01c901424bf099e0a8a621d4b39e80047be3c0c38cd3d394a91b546a193eb0da9aae7a6b483c54e2c06de9c259ce770c8a3f773d747079753752b8f02f8d653ac71e70b72342aa7972c789deb6aa64555385a4eddaafcc4f41d889efd1ada3034318c401bf60b63e1079d7ba3863396d2565de8d3a5654838bdf3f2a3fee808b099385ba4de60f4caa6a129ba4bafb782d58bd8560340257477141906ede6d83d6747724dcbaadf8d319db851e7586185e50f9f31c5600c6d1e2819193fc07c11c687c036928e8955919b3a9eb11ef126397792611fb639575f2c26b5b5b48b857675c8a5e42fa8b2d96f467c35f08a159dcb4b3d7e795d00a28936ea0b76fa648367ccbf685f024a72a8f09ce1a90fc93cac2ab3b37bdaf921b4da4e6ab0f0bbc4694518fb671d7b9380091cc7d22c265aa4d2402a4b472694ae83ac859b04da7093fd7568cf1119164caa693c05f71c41efef03f838d16fab3eb3b96f75ae571a05303a85b70dd7ee6c87d284fc258a601521bf4593dbef53b68416419f43c5eb1b16fda3f1108418e027b85b765fa7174dd6c8a5a115345b8dc375d465686e9b217a011822ef9078ddb00dc20f6393bab02558116cada3b42bcfb31ac66d2a8a1c96e373ac19b8394ac9710e0e4b8e0520d633a6f74b70b4a5d6d780a880b603c731a87392d6b677d64ae51142098d3a17eb6f631d3979bcb7da9cbb71454945129a0dbbefb05bfa7424ad1497b26a4ccc46698a0301f4a6adc9049ab8bc4b2a607eb160f1bfa121cb6a1850f27dbd04fb997dbb75ef56d3e13603923dc8c7cb14abcda483d94529b1d7adc062aea71283a474d919c25c771984cd555b5a2259b2161f9dca0ed7d5ac69f48c6ccad1aea71a92394234d60e33dec8e3bbe6fbdcab7af26526286950b0f0268129e5a630b2bfce7d6faf9c3bd8a3ca1b52bab62801badcb323405fd9accec4aeb6e5065554a3e6f15986b20a44ddfc97130cf436f46d5ef6098eb0ebe10fa650a55e5ef535836ce5e1b99d20073794ad0e9f79eebde6b05c93764b793526b8fcf38b181bf0ea2d0d3d1695b9f8a04502b366309a5f0ee8b815e5a07dac7e9c0e46466c6f56c8209a3b9a88aca198f2a513816fb94b82a849bdd00322f4f0b96040dbcd49d50ba67dd4b88d6296c547cd168f2286ef0dcd9a23a3334c9c4c7092683976173511183eb5e07b02de704255e02240099fa38d68c6c04773dc7b876ae87d59a715de6575f678ad46de421aaae9e4ca8435b0bf38a7dab0c0eb27f03f812740d92c3a975ce531e518cf9262ba3ee519ecccf2ca5697f68c605324757a5c6220621962c27d6eadf908fd428c5e5b98f912a6dbf2cebd1b9a425127401d9eaa4841dc2e9ccc13b206732d9bbf48312f43a1a3016170401636c098b404069a651743beca07725b3006a1effb291a1fb101ef3ce5d07a504027fb2de2a165f1933181fd12d1ab796e468f3d55616baedbb1104f91530814624c047cc0225ea8b3701879b683949f8ab88199a7136537e6e169837051a523e6de7e1958976f95b3ade972fa39d7a840c733e0a0ae4fc14fd93cf99cb135d8df50db735cc39598bf81528021ab071a7a41b85f7c660281495fe47399698ed8c8abb100e3d818ac848e9a2af5298cde404b1c0a2b8829ce2ccda90c4e8c4162ca500ae1b3d72ceea2ee3eee1aa38c51767f9c30bbb9fa510cbfbac4db69ec99be3b9ae2a766e63252b250d8a5f7590722aea8cd14768a5b7061caf11ada8bb012cf40efd0647ee572f9f2543a0ac4ed0a598dd559ec46ecd8eeabef9af793c85b9f274b5ca73c40328f487d62834cacce44b66b1e0d3399bbc6ff953f35202d347a158b5d0ba2a1f545808b3b5d14721dbf4f6ca2e0b58aa9ecebb2e16b20a5c19673c6245eb4108b4f976b7963d9c6d6b55280b370623f0fff2953b09ce6d9574168070eca75668b16f9f74e59c3c34f8426fe43d936aede1ae52a2ea949da65642651a06f68ad2c41a9c085a039a2e27ba758ccdc9580c9f8be5e644f37dadd280cdbff51cf24a7513ecb72f93e5a203cd230855a4ebb7683c880ee979ed4a961801989ecd499556b8b5d953b5af4e487641f51028ae231a3915d1b54c402d79c3b779a640d600d03730a03c9d535196ddf38d6dbcd6bdd18d57bc7f4a26d527d9c0ead397399fedd736cc9cf2185b224549aafa36230bcf7fc686af17201270139683e7f3226a387237c8a26a7d2c40c6a9ff49b2fb1dbcf80fdd274f954b99ee2a08f9c7ecbc13b0ebfffc075a452de81dc949c1d0de42be4b04129d6720728702e1e1ce7f345fa1449b9e3b1040674e332d7592e4c589722a5f7d2262cde2573fb607b7c69072b611af29f0709b45a91aaa1c791e38e7dafe03cf432509b3fa46f8ac32e181cc1848fa6644b701e3ce47303cd98314319a3def2050c52af2e22eab91b435955425b19ed2cf1d63b65f9495a462e2269c67f752b44adcc0a2dfadd0945b765e8460ab2ff374ccba3cef9471701ab80748fc3518287b42867db7958bd0436266333a4c3cffa4678bdc541084cb281df9bbdc7f02763a792dda60f875315eec0d3bf3fa1289b167cee0eb74208553527239904b50aa06b797d8e5438f00b4523cdc41736b5d1701be28c235469a82d62a8a480a66891b5a35f4878e552335da4004e1295c04b8fd93cf85f0a5ac4c892a3ae97c5a4cc86c3f247938733f659778bae7b98765bc1767d19aca185ba76c7889d5ca4750b34c69d698cc1ac1aff612d0c9950efe7382ecaeb1acb8a48840d644b0d6f0d249b4d0b591a27c39b80f843d0788f13082b474da95dc21e01c32295c4d0b2b093d4130c242e813863d826e8dfb71e72bb6fc048c8e48c857a462a266b51e4f026c64d228e4c35d898bda190d221705c6de8f66402d14d17f93ade0c39fc7662e438eaef662649c471ccc4e682d598ff474c273e5a3c62c62dde66cd1aacbf93357aa220b85adda4c2e19fd6d33074f970e04f89b43f49371ee8329da848b9799b9ce7b2067433268c4c12180f278fc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
