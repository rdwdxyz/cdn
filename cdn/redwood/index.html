<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5b3a04fd00c7dda41cb1580e466b9677ca845b695a796041e9f6a39e1e08fdd714d99b748d6cc17a9223e39f59a4214e8a775e469ba2ba416c8dbae917f856e5a70c775045283eaedb76682945c977b6cde2a4248d1feba7ecfe0391b8790602d563ad3c3788d6a795df30b919af7f5a91bc07987ef266ffd1bf3bb464efa5fb159bf0ac76ef6baa48e955f357f02aa9753b1610091fce335291f6fdbd53f519706ce6094cd93f76204b3162e29af6c8e9eab6d497483f8253568d03201965f5c75bb32c648a13fa87dca04f986757f08ddcf15ecbc078b4c8b3872966e98eaae37e702fdbc1ea788d39f0971c92abf7f131b6b0cfe48b3395959a8d0e1ae984e794793cfb0fbc7edc733893c05044fcaff4f91d45c12d17f11cd37d3ddea6ba9c2a27eec06db347f2c91e112adc6b1b11504993a2eb56ce1d1af2dcd2bcb2bd1c24fb077645c81b00da699935ded2cfea22f9b0b6e7892d6af87ba9b1793f9a547b6bc7aa91dea42e9076c2c17868c48bbe9f2fa39c8c1c3652db92510f6dd980ad5c9e1b51f4030ced797623eeffc73702b9d7dc7ab27087d09bd94ef580bbeb84266ccd5035754a8399b129edbb1a223b5d1282157903e351df0853101793a6425f5776497933486ec2912673153307fb987f693032790cc985e9989ca6f8ea0504348ce70c4cbb971faa4c814eede33156f2e097915a8e83b5d21c137fbaeff28882758661f3513233216952926fb1fe6386681c9f1006cd882897b83576d15e6e6296262a523a0433a188b8486e00de37dccd305a932f4a6618c9952fbf45b40fc1170e1e72b3800be4dd0d606ab4e951882cc930e166831f880437930aefe2ef705263ba33205929f354a14f2519ff75288f5043579c278fb152405296629b03bae2218a1a46404b4d35b733f85fb0a1051e2afc922dcba76310dcc9f4178239bdcb4b28e7f8bcb77f112504903f72d63992fc9650c84d2af5d16a0846a74c86f4478e23f1714fb40e3586f22e4e520ad29167e29360b6cafd3cb1b903b4166dc13b81a6d1086da97bca6673084d0f3519a0972715dc63e56a8dc4fb5998881a9c3e73cd13838776027561d39e019d1d7b8c85c4ec61fa828b556f0e3605d4e75637ff87bd94b0b58a7930d14a4dde0241b02a187b1d1273d63b928416437e1d3e693c1bce020a47152bae7d1d4c109ba676878a1850a2205a113f399f342d3d2b6c070d018bfdadbb539039f148ebd6f3be9014fa0b6235ae1c4c53f43d9b64a125fc62fc37929e7158832fb9055d1ec81b0e69cbe6c1c88a8ab48e1a47b00e6d347385d2141f0fd0d43b11de047b9de07669cee0365b0b1c90281567a946c6f1a569ddc06d86dee31e176b2966aa4ab643bc48f8050749cb260bf03df82eeffee87e9da1a7af6857fc39bc8c183286b3e80903fa9485afeb1094554da67e8795dea94ad76b57f5c0c36d6dc70628c2d06a2ccf37d74293e11063879b8f9e9b618c1f824482ec7f1603ed835997d20f29724544f7ba717d172a24f322e5ac31c964229aef6306c7cda0e3e68928bd1a91623a5f22dbad1a15a24292bce354f78915a9dc7ae64f022a214105fa6e39160932c7bb23b70e3817c619a57cba51fae40ed0c04f2637f510ec6285e407b5a09452e3197b666a180f5b08eb0aa2cebb6790840c46ecff160b9c85c795adf92e31d11d7d138792b5a98cfc4efdb329cadfc8647074c2e018f787b2b2faf10b7cf25e6f8269ece3d00bcabdb9d43a9e9bab9f89fd33ca33e6693656794ad6a3a31e0bf940b6c91e65d5a985c3fd6e5142d7ba24073037c8f8a2f88d1854f49198547676b6e30d22e6ec25ab32eaf1aaf623e1c369ee40362c0ab34870760a1c7e3bfcb64a0082af0fc84f106790094f47fded9fcbf9f3ecae8c24277e66213db64af881a308158787d5c2b9113bae31817076a1d90c54fa129451a236c359046f5913f662d3d249466792705dfd9eaf08a813b049f09a3b706875c2e75136727dabce6a4dfa16dc46f07461488cec5d7bbee636a96dbd44733eb36dc56c905d5418cb8744ca3cf565d1f9272f14256b705b17972b7f014a57f7d0fabf80ce0d718f2ede235fb6ee961e79139b6e7030aebfb143add582a8f118e0213eeb7e4dba70c4fc3d0d02a7af0c5251cf4f01a363fbc263c0d37f5f6fd28fef99cfee40c32f53d4eca73cdbd311d20bda16c274563bc64baad17641078b712045874d5220d482c59db44608b9cb2e2edc0dbdc008c5685144b54fbd310fa579eff91b7c347c9c67504939b61994a2875ad8a29844928494d58621fe24daa1e23d921ea0b1df18e9dde83d1b29cd0d32e6b0ce640903e9aabf138442fe7c88379d98a22bc01ada16e1fbc62dcbde91241df60cc71047b3653c87cb65856bda34ed6249570ddbde81d2c79e51c93aa51090ac38a3fbefdc2d8edde9e789029189069d224c62f5aa86dfc928936cf3465e8c939dd5a67eaf34379aa3b1a84d70b83366629586b588547d78b803ba758ec3deca614e57db03e1d958e852c31b99227942418b68975809dbcc72bf3c4d7abe2cc43a7ae5ff8e17d6c432959eece057d430c09baad7ec8718e3e4008ef7e0f087190d17d7ec7a0ad38dc0aeeb05e988618d32e6f22970912f7b582e2bbf1e1032d0fe5d59e42976f70184d6e83599b9bc269b3ce1b2ea9c0977a1cfcd22df1894c22b7bc61dceff2732f399eab726d8a9c218701a402d4edd5a080808c2e916bed88492a95ada1d55e2f32c09356353c2047f925d6f3b258a84f75f46b137ee9e141baae442e18a491103e6b0b9d88150367f0eb0171d4ffade7ee8ad3dc429421c7e5a8e47d0a79e9d8a69a871d2cc6bdbfd4fae9a4e3165feb8ff915bc24fe508dc9d6dfc287bc1943e0416d1d78ac9e1ca6f11f7b34da55be5b22c610afffb774dbdb0c381bad45bb5eabd280090b6de2dff4a425cd69fd9a2d416ba42f9b64455d64022525aa2f40e288e83e5bbd44232429c288f4fb108c9654d8e70a123bfa1487512f2d8e0d3e18d5ed84d9cbeebe62505756900bdd659f49c6ddb39c43ced6df801f2f7bb7c175c64d0af7405bed543cdf04b5178b53a61ad98aadefb16eea56ebe92e56de6b4df1620a089615fc9aea7f48c2cb2e76a802823c1b3bed1a0a74adc524442b4f4a23eb8721631d925c265049f8a80bc84c6769992f01b57b4c06b5ff410bd7deeae8e7a52e078a24c7906b0b0f6e246f7a0acc73357d0d01c85029b1102bf4811eaf85f87997920bdd8c4c2678904162d0f94194cb811da88326cebae2997c607eea4a0ef22b266933e0baf7619b1ce44aa97573105cb792c99c0fc3dc16242bf128dffb157444ef9e6a4067d471255ff9a9507d4e1c32ac17aee553d2eed17ab22dee576d061dcf72d9c695bb827c357f7cb73e71de57f4e25512f6d751318740127799f63f72813a4c02ff4ee7874165d57d156a444f385aaa943ec7fddfca7a4b65eb5e952e12f83e537496ec4be368f1d36584dcc7caf276c8eaa4c97cc23d8cc465ea28b75724cea35444c106f4df92028ca0ec44f4b8e40aa2863737231c05432b72efbd8e502358da8d025dfda238eadd07a61430ae91c7393b1acdced826610bd6a776978ac36214882cd032c66c450f25b331ce3492bb4b5ec8c45b8abd9e9943889ff78a796cd5d5d942fed1d68971a694d591b3ef25112bee2a039c6cbd47efec466e752d1aae63364a9535d14cb4bc9b20766847f0fbbf58a8d225822456f306d7e390c79fa630e3054118e9f38fea2debd5791d352a149b1cbad6eb86274b307e43e3102cb27b7528f40d7cfa820ef1307d47d7b304f6098059ed730a2ee0019c39fba0bb31735cdddff6827487ad6cb8e6ed7128fe9ac8553e61fba61fc1f9e5d7f275b09187af36baabab3902340874f895a23e16ed46ff2a2d018324a58841cbcd775b1d25cafabf3176e9040ffbf765dff1aec520c440bd3ed56f119d1fbe2d90f1beb135c309c1b9f7588591febe1d3b15cae8301e560eb646ecc5b7fb10af40d582659e84eefde99c51bc0e8b497ed1716be2ffa1c9a09766d6a01b182bac9752e88eaf2637ab1c4ff021a653949a063b4762c8ff4168bf082d3d23b70af5e5c229c637a16af54a2f0f2d98602856a60439b0389370939808b9421ece0b63b871e39a48b1871e0b63c50de546873fb3e8becb319aff39c4871513ddf8842234abf95e09a45667f0ae502f52ba543e15fc40e692478b11515cbd85581ed935fd3fe7c4ffab4cc64fd42dc59a906e77fcd9c22ae57818d097b174c35cec20351ee50182b5574cf74d77eb120c33899794eaab31c7f00039859fce5c494a23d100bdf04b44a469a5e20abe955b7e2d23e80e5549770db14cd7771e0a617deccd8e06b0481476c9e8acfcc22a32f9fadee3c2f26be4ff6462755828946321b6784c396f746a6483ebd1f83052ab101cc5f8932882d7951cbb1f23068eda3e4a54849f01fbd9c812705146fa340549892f6d2ded19d120353881bcfc1661373e60a5b2640b1345a4b3c7350504aca22c6250945eca676dbde34eecf8d39c7a87f8ddd4e102499193909de7531e3ce0d097808cf22a44a0d13b2cfd1524c6e539c2fc1a02536093526565f1ec1124f9bcccb54f6f536a6ccb4a6bd4a9e121f6ccf275da2709487ca789f82cadf4c5758e22bb10fa615cd5c40984cbabe5e7bda78321be9e6aa81d4dc75b184f64ebb2c0ee372bb15892b365d41172877f3dfddd688f0a069212c0b568ebaf175ce32bdfa9a2348171c5bef78554b038c149b26b4188ec683792c2e86363a695963ade55195fa0deb862ce428d6333b68b15d2db8ef7bfc3a8655275fa73292a8a7a91b268b4d2951a4012b5b3b67d08de07d0ba20775b0b97c0ab60334580b3f6a68cc75694666a84f5b0f047bae632cafd74683d5fef061c9d51c01b893399a94180155c35ed17a2640d304fe6fb18d37d23ac7b5b1857bafb238bef976574d2d41e459996446e05587168a0c7582a537240b40b3d83c5c7fef6e9886d155e3d861bf20f3ebe68f10f5f4c85c4698795dc8fe09cbbe35cd28a4ee2bbd6a75c10bcdd96eaca3994eef145a7852a13c440fc1bd802db295946539cad05f1b2c2231bfcad1a51b865f8735c6b3d647bc659dff3ca24017af73e7021e5f21243f1a6a4b99c7ff11efd7ec8df975789af861cd77e3fcd2e5a0b53b4d151b15a964a0d601c5d691fd6ed9271afbb2987af5ef9706ae6f121cfde086b5c736af122d55d6eb313d15a98946cbb31890a3ebb216dccdaf207322b46bafd67305b075f5e0e761d0ce5f83387e19cb4bb70864598a6887d6a4043b63f3594dd33550e2c67bfe26aaa52096869367cf60813c14b651d8ff5ae13ae83d10060f2d372c3a797f6a2d74ac1c336da0f7fc095c3d8e21cdb32811b896124fcff38a9d223876e1bf3ad832f395531d8cffaeb104e7813e8245dbc94406cdbac007cc2cea72ad60463e61dc0a4d640f7ad692538f794a6fecac5b2650b63c7eaf777325517b22dc5142ba3b90ee898aa93856fff8da5f4eb94637cce5c3648aaf6c20e8b1b5cec3ea349d69a27c76c26d9dec4c778d425ad4e368f6f0eb99f6401bc1b7f871abdb2bf5c4dc80dc576c4bb2103e986ce6fba198b6681d17d2bd5b083959b75906555310d7e2c8a35644d7cc1e74b1f9cde7261d6db6f51a7e5ba24e572bba92c2abc976a9909eae7c3a83b3fd96c8fb8c4d75509c5b677796550262e0e0dfa6decdec87905748169f0651dbd7fb0698f7d03fef9f81d2faa9006ee5a7277453d92df2058a168f86e58b9e9505e4da76b85f6ca63ad0772bda723bfebd7db96afacb90adb5a525de0fd8e40d0d8f55d211d65fcdccac20acd7e4d313302fdd254ab1fa828db09e4e9cd8645edeefbbf2b8a96279b4e15c7a4eb66bdf77c0b2137d61875b4a11dc1992ad1f59e47f195df76019afa22724002735d03d137428071ded640c07dff3e2d610eba2fd09571571b89eb327efc860f6519a7035458fd52195cd91f917bc670affc9646d6e85a5cc4694b05f0b5045fabb98da5fd41bb867a0ea826f13a6c4aa50970bc69d26bf8849504a115193f424d8e2b09b1753f690c915a351829a7d6ebc11d9791e8f337666c6a4bdf42843f698e505d5947ec14888082f9632bbb0f024578648f9725c2a17abda4885b0cad77b3da6f9a6f32ba884c9f4507e46ab395fc1fd04fc6428809500c9d7599521be068e47eb0324bfd1ec9ad47753658d9cbc41764d42219f27a24454b04a784119a256923a4afe18295cf1e8f4ecbd91133adcbb4a259dbcb1ccebda983f49efeedbd78cab298bd9a22cb86f8b19d8658825c4c28bf9f6785a60b8ebda3572fcdd755f6460542abc3eed4e85e44e4077eddd60396d39082c033124bb722f17fa8e97c0a6c139c7aa4bedc661c9d3ad635b28ac2c31928511bfb68e91f4c5c5197208d1e9eaaa37cc3d54b981fdfcadae684f6a45dcbbaf133bb3f671bf4fa411df1dc19361fe018f0e9e3eec46f4fee6d3ca180bdc9d905d358085cc01a80c859921f5b93841d34588a19aa42bef1d090dead0343066efb6bdfbbe7328563d0259351a3a2d8b201c1eaad8f38a5fdcb4a6464643619a003f680abd1f338bf8969e8300889375f25bbe4d7fe4808f63f3d75b61e23f08e4910939cd67ed166c2f66424983a10d2dc867d062badb151a5c9e201e359d3eaf4a2492a4978448e7f7ec7e728f6965ec0800e7b303efda169dae990490fe636c50796c5ddd6b76b5091b2f160609c8faea6f41f114c3a55b100f2b80f52022270801794aa4c6024f4a8efb1126a460e2df7f6c1ce07d98c2b8d2b45365c62611c91e27259f4e3e6359ba671948876042eb7558df9763b7ffec23b05442df37705e73186ed5d84751a45dbb94953fe87190de38addde7e5562a745b788fd712a3ce337134fbf4e1ada7e47e0ba98f684f04018cd0907321dd069c04d12298c313c31a8070d648a6c1d6da447cc37f0b4288e22bdde3376a131614a7ca6b1ee74274d1f706611979a29f4ad03badde16ee1fa4620a9e3b833a4a89947ac763b57e7f40760bdf2228b8e037c7621c2e2fc4c14d2c6e1f51e9771667a0d77d86900b4d9eba7414272a18d2b4d349007554b7c7ccbfe804ece64b7aecc7ed59e284f6d6781dee0449ae20492a30df7307d10670d5f8eca630fd98ba884ef439c728dad69c6974303c3e39d9d9b499a467678b8487cbd315cdd8d603d6f07423757efab20bb3cd5a8cc09344a01fc5c83cc0f10986e6dbb6e58b5b6b08b199b6601a1ab56595d5983055b20a0551bf8595458227b446a0a42e29a1b45f3a1162cfc3c079a0bd65522b71873f74d4203e45c24273aac954d73aafa90bb457b5e04ba5af87eb3f830a2f99670733933a500c2f02ee2fdb92c41dfd4835fce9aa5ab75ce1ae75ce0db5b011569d44daa6eeb07f3ddb60e277f13b6f4a70101d31a9242629036a927c479354520d19b65be4b752571e112830968c1f3bc88cbec1a7cb73094f28e65b952e070079a3aa28b6a8af1e506786572e4c78b3843ab7f5f2e622c460f15b0a96bef31ecef7e4e48268f8017c53fe61cf959f8de3dd6eb30a4b12f955c27b743c068227d7b32e4263b32d6f0a3619a8f624f741c256eacabb0fdcea217228bb3c398144869bce9e8ad646ce3e6e9dc2db976bdda43270b0688071e94dfa51e620ff406aeff77393ac60b85ee4d501dd2f3ea5995471ef123e991b5b9fb9545bc5a0e142b0cfcf7fef686f0c34f418de864375890e1550c1fc3c6193dcc3050f85044b3fbcf6621fa13dd04976f84fa9d4613dacf1b87d357ac82518e5e8037a6978ba993283d71a53e115b8742ed717135e7bae40de7ce142a5392241ffcd4697fee7181b29bf19eea5b33538058db955b424c3ba17719c073f9ddca99aacd68a416feb806dd13072d13b8628458d11b0ed2b5a8836150cec0cd56782963fd240784360a73c1427bf2250624d66f4dda1876299c8e15fe5fe9bc35052e55204fe7891489954e7acc8ffcdbf9442437c70cee21d71a914cb523cf0eaa5a3e6701d1fa60ce240d1616e6bc4a0faab70af85631287efc4d78ccf36db3167579989eede85b37d1a00414f1653b273cb6eecdfc074f321ed2e734a06c3f93a47ebfa110515077b87786e49dad88c875a690a77b0a5fdff8fd5685ae2181ac199f9cd79165e2379d0f79aeb328b68eac76b4358bccf08784019c615fdf65dedc55ae979af999416029c293b8adc7c3cf31e939d10d13133edd684ab77f036ca2bdc479be9c9b63ef8f3df23db6a1e36db38b4a3bdc39d35c3d49149fcab7dbc40c20c514429203d71b3b7b4aece34ddb6987ec406a761a1b53fea203a5a7cc010d63e6cfb8929648ecc34de1207a1e88690156ec14ad657f8c017e6037e94484e21296aebf81931d3ac8754d9c39437b130aae2a384e3bdb821f191508420311a413e8c11e8f5b32f647d5089504e5b6d65057993d656dffd545539c2f0af19847c1c43339c0b533c650a49e6f001d8add145a2a478ac8300d9125ae698eb87a4b14be62c05a867fce5e4688ac515c31777ee96a073416c1a90f9769131bdb6370ac0b453689e8e52d7a15a4667d845576ee930cbfdea7990b6464a5fa911dce160dfb7e65ff4836aac7ff8febed644d16ac508011cb420f3e1c992949fdfaae2e09834f6313f26eab10b9fe4dd82fbbf5413c5f0876e01aa83c6ab7e53b546baf2133cae25393584646531ae2ca2382c511919c694d58f55c9eb228d369908049acfe6d4d00bd98da4b698765986ce0ccdff80aebcc23668ba8dd8a8ae58f338678736ba058ed16c745b715f4b764ad3ce1f39f1df46f0feef12fa34bf75feefa5512e667aa22e7c91702908a9c21c135528ef1afe6a63ba0f420d8112ed65c54c06f8f7fe1d1429edee61fc012de05fbb6ec6fdbba6c0d2f7f6f651df5291153df3f616c23945e8a4151249c272c8a4e8e0c49945b64986e1e2aaf229a5508eeb4e04fd1a5b04d4ac006eb9fb65d0c671c58be2f16bdf7556f00fb7bfcbe828a28d823f14da920fd76e2a296a5a43c040b2a3bf07f6fdc5ae1c4d1c42a9b813db198e703ad19395b692338f4c7dbf5a31803723de4ca18f366fb4b629df4cd8b4d3aadc4ebabc45a041e5f43e1827e3c67461c5f86126c0e80def4e981dfb5def6e2a2f52816c0661dcdb089eb21a8c1383a69f1d21b2ce4623cc88a72580d9822fe8a9f199769150ecb4df84d40fc571e3fc90092bdcca60b96725d7415605ed21b4471010ca047cd769c69b117a25d40f94863a974b076a088b3d373a1c5282e358c824116118973bf5fa371fda9fd9fb76205c512d6e23f767d3a86b6f0832913c7d10445f0ce9506c46e1e1fced902fc18ec1a4a3cd8934a007bf2541876583b0de46be8f9624047a3645b216b805f5c330e3ba3f9273cec8ca2dde6b0bb1c5946b6d01e43f684f77d31bdc124173296c77024d347cb1a69180d9f7768744675bf40d8adda7e7f3f6fd8058dc6941eeaa9a8d2fdc1753c322b958fa19bf009ccb3bb860d07f85280ce937bec3ebddafe6242ad65f73af9087207fe5bb4baf8579b3b43a986a799fba9b67e3c323bca4045f448a58b01f0073fea3114758a2e6b96832204fbe7369b4d178b2b671a0d92b508797e22d75227ba5450b9abfc9089c5cdf17aa6d3c9f5947454e237786275a0d9c378d1f7c62aae21ecd18aabec2d01d716b246617606b726414fdf0b0e1d8c286efaf821a8b4ca0c99442fb1a761122a3fb3ffe156b617d853e3e61531cabb6a09d56c946319f0f380006cf39730f3ec38c4b4accf4c3d3a9994a29974492053d3a25ea9a04c8c3dcb1736ca26e685fe78b8c47f5f7dd2ea9c4eaeea1cc5d418d24346e19161726821416c39ea16b828b86f03ca3d6076caffdfd3e429a7d61b329ac8aa7d992a1cfe67d1f6d73214f547b49548facb60001e2ef617e0ebf7dd5db872952b8b319a2cb86ee96f81c96cb372baed1dd81c6592628c1867101a56f1062c9d7522b6c7afc3fa4594a037c58d07857cf3df47fbb8023a23da0f8e11a385b50ef30285b2aa284d3120234c00bde7634b92e957af722af4f51b6cbe3619e3108284c09e51e81799724b65ac516c880858521bccf4e6dbfe0ef511fdc1c559cfc281cd482568b86bc99dcec2521d1870d2d802b9f030fc3d9562917fdaa077d40079eb7a71a69aa18f82e4db2084d308c0d78ef071fe67e6a64ccf950620a44c6a3e96b74e8068727d90a2be884a971b6480d8622452127cef1ced11b32108502c4aed91b0fb69dff2d08ad4423015a5ea087de6860cab7c6477eff9733f402534ca04520d7bc1502f5e37c5d2b8ee0f8efb3cdbf254a57b12f0d96b359b6c24eaf38f2b518de3bd4c00d79c80f39ddea161a94cda79d61afa9b1eacc822d9205c58a955d7b12bb6b449eeef171b4fcd37776846190579c224bb2fdab53f6b1863e06c604346a361658b9ad786fd66dff4fc5ef3c28cd6bf2a9f791de916a87d4e26221a9bfc381ccd116c906c15ddf10244552473f414907e7d8663b80db5690506285620162fd43da456335c0a5f7c26216a5efe99f900d200ca742b119e5ce1535e334ab2adaaa778450a96acf9d8bfbb3ef8214a65d47a3ea96330f796a7b649d62d1132937302bf4b136a69a7a34d0ef6d8ed1bd1de16b17d5a5b0ccace7e78a4b67e7977059984fd26ebd5a8f31bbe78b38893093a537650c18ec1615fa89028cddb3396d91129221cf6fa81a0cd9d3a18d20f22b27068bc7f38be569eca01b430962bbdfd2355045c735c5f685b0b131afd2c2cc55f1de4b63dc2f898e7d51e60d86d7bd631e363388155d2204d4162dced80ae376e720524e31822d59ced5981b68974802a2acdc5f1847ac05e5f5f11843f60d99d17cda44e3a8ad679bf4d7e10b94330ec7ca9b50d337c845eb242e9852e8e1cedce8d4cb97e668b5a9a72ef1a804edaf32b61def4dc0509cbc635097cde16573d90ab56ccf6618cca9c4e4e2458e3eb4df34f6d36dc8a15e95f3146b91bf6e71a72c5328eec653271c1ca9ed2bebb7a6ed76997115c276af089a40ff1340afb1c678e1811c71f1b0617221b3dd051400fa4e6bdab7653c5a84025a91e0fea4abd2e9b7f5d5983e038d2b5d58ed1887df07764c90862e36033dbcb6548cc06fd456e985721a917776f1911cfa006dac240365b547feddeaf60b0f8d8f50e02b1b02668791478bef09d753d4efffba118e0427290e967e134e2d9a6583a1db19d7d4eaaa8486bbe9648613840c1b605f328a30b27bc9437e71d024898d27376a6d388ce59810034d9a3dbcb095dfc9cee39e7b73163c6543591cd02fd4dc0f50eaa6f00209d1ec28b89971b7dbe5a7fcb9ab74192cbaabedbbabe6dc5d98aff569db536283db9275679475e49f9f72c2bee1953694d043a3c237a4e755f24d8dce7c5007ceffac964928e521838928507dd9ebada2f38ffe2f24ccc3a6413772aafac8d8f614bf09bf3d963965cc226c8c8f7bb7b42f7b1f183d5cbbead160180835529aa1c1b392bd6754b70a2daed8f74d42633d7d74522ebd19e4499ec73268480f86d35f0e6c34e5501c4f45859b789072067e549a2318d4c4ec87ea07834845e6e57e1c24f8fe2a7e168a5e7c28564a6c1e71328e0c75d1c36ac96acb2b350dc6c893f4c12f22cbd01c8725611cf6c76564d52a4bdc934f863d03ee859eefc58c51edd2beb25d6c409fa628c10431a26bb1296f55a9e8a30fa7b6796026d70f28b5da59b44c956e3d3b1489a9a168c55abc83374bb74d16cee90dba090bb2d1ca37c422dde0dc0eb5e5127709e9f6f5ef411af725d2708b2bdb69704aacf3f70bb1e3728d980e87d9656aad65feb782ae5730a0be8f331f3fbe141de64da900c454cddebbab77c7ce608019a88f4aca7430964e20e3bed99395de05bda4a2c4194505d6b9daad9cf328aacb389753fd47a2c7830b79b55fc909d70f6143ad64801d35d96a20285c12701cdfc3975a95b150d97fb46f4822d9bb5ddcee4163e575859e965d37100955d2b2b0c774bd2ea36684b5ed4c2c9fedce2b0beb6252ac48a63d43ea2db0e0ade5ccf2931b4fa1bf3a52841877f9302aabb3ce7b6289d8723d28a6494887c63f132d0ce04dc7721af5892fd5e7615be3b66e8ac581690c47d7255f39d2de8c9bc80b9add81b18b930ec67d2a2074ab98e30644ac258fa42d510c62b8670c05426426d7d81f94de048ea00815001473d46c0e44bcbce6a43c3dcf04e6e55ccd43ece3e858aa85048ca0e7795e40d76cc6b4ef019287ec02ee42a1a93cd7d18d3b0309816745b23d64fe5a5b69edc79c3286a3eb07842fa1e7928bd69914e122d075189d07737992f7bf20f8d85d585f3d4d0758bda274f7b3d693e472699c4839a64e587d7707260601820afd5cfb5aa277acb2910c8831151d90a5cb5af6d3168cd8311c646a0f915d75cf8eee001ac95803d9894543dbf6ffb127e92a7b7a01888a2de4a77ebe1f791c83cf74f872a8f4b2887708ef27767419508a7365194aeaf467b9b48328edbccacff6e294af90cc88b1ec812547dd1a024f31369bec5b675a1accc44b30d03c5bf058ae91c5322bac3d74481d5ba5fff5775f8a8d982166e880c573d2864fcf1f3c75adccbb9110a442e16b12e44e5ed35137974f8cbf48457870ea7716f9396595ad8bc3cc32b6fd6621b31febdacec5e68fd254a4e9c4d75aadb2581f13510cba9426c45709b686ced2424f4675ad96f48a76a9388ba6b5893a11f9db0daf26f4d1de536faf54e818863f78ed0521ee9a1486755733ff4f3d894ba80cd565c714431483d42cfcfa6514e2d9b1e7c4f89eb0a57c92d5fc366aa608c6e4af80e65c75c0b1cc17aa6cd7ec04ef2df48160ba6af302807b53a66a9f69191a5874ef2b90da1c61e24e7b65a83d794dd19279cffa90fdeba24fcd41d49c0722848bcebffbbc475305af9f20cbc3ab1cea3f023d01f38657dc585a0ca2a7016b78d4a81d0094131560fbb4bc2f28fe4e71daaa20ef2b7e328e1ee6d93d41991d597af6496f8bd933bf13db56705edf60f322b2c945aba316add47671c831ba1c95aa825558f2b97c1937ee692a59c2f614bcbce22bba9a3dfda9e492e9f189c24fdda67e65102ab59e6ab7e56712235bca3a4fad099ee32b25e2fbec4b6218fae89bf2d7d4cdf49d9ceb5337e9e5439e2f28f6f31df1c7596a70becf9f6ed4504de4e9d2460226f6304cb691089f5cdeec67ad0046d043d96cc4d64c3c57b3dd69105d1e8008b01d2cb3408860da24fe1c11d2479b3f81d97b0f27bac116112e0585c488d401f49570fe537f1454dfa113cb02e31068facd4da15dfcc48f69c214902929b2af3b955bfbfc65795f6e311449d3319f0db5b7d1f45173ede687865b90df4840f05b50f758e139c701d7ced573629fbe8c3c0998c166ddfa2ef99de62af147236d52153451797d141f2b7266bdac54243e93a6573c272bd5c8b2df38439770b03b353973bc6513da5993adfd1b4d82cf009739078c4eef45db6492a32a4dd67de724e853a212b04408163e58c4e08ea799a5ab8eda79defd62c64f8bea1e028a0277669852a8265fa0f489bfe2b6a263c7a90f13c7e2f44c591aa68e26c4aac944e1849137546ef76d00f0986229495c54017c12a72cb35b75c966de115d9ab32aa4d200a23cd9b2a2576257c1273d0cda5bbd05339450034d23d0f8227bf2931164fbfc1220d06c90dba92a34105c30f893f1df02fc190a7d8494d62827e9cafa10945922205e36a4a00eebe0527d1653069f06b38130b91090c1c1bf02cd482fef6227a0c5ec08d4b2e9d778522e29775ce9dddbc2fe724c222779c853ebd16ecd5b34ac76cddbc656d6625556bb1a4962c7a68e115a442eab1027e1b5fd0bc123a9b278d474f942b6f846decf972d46c05d9368a70bfdf833dffe63a977654dca48b4ea25f0cf16026ce1f7304472e0d26943197c79d1c62c6669d86a45ac4fd0aa776e0242e3c11ffd85c6172fd748e4d67002ccef3288611f247001ef8b5331d041744c2a00f232de3612747b09b42e09f5fc1422441afe8ba367d59ba34f6e381f4d0a119d687b5479114998ac41899d49fec278295c7c0029a815052bf07beb71bf8085025c8d2088fedbfd3bd945a3d48a4d1be257e26c84ab67211691339405ca114d8ff3ad05a891eaa3c09632606e46a4312a13e48a2561f67f71e8224aa7784d4024e0a17307007f3131f75494e7c8ebb5d48200fc22f300dd69e8ff1e31e6c55ffd665cef52aad63054024034d0683e6c250a9941517bc42a6e867499e5caca5ba052ce1b6d4c814515f49a836d0ac4fc3eb70a48284dfdc1319dbce21ef6985c0fc7c06ffbfa473de6e0423fbe91772e81b7816905b64145d4292c304b9963354f0f620cb5549ad28e429104c73b1d8d1b3ddb500a60b3adebffe398e5daacf3ff7df687f27a9691e1d56d2122de590e924a26569c7da25319b498cc1e1d21aad9cb87079d56448939d53562ebc9d2760777065286d51ae3d89c223baa4d44f4a9ed75b25c6a607c68461b572845110a0126d296ce75d175fe042842360d9f454cf4c132c6a0cddf3a65dcad6a0f2ba7d63551fb05db62db87216bf33f34d2cb23f2e24d04780f4ce1770b43c15658adc6ad51f1a83f844e8d7d76b7f03230c33346d7a5013386d95ecbeb9633d3d4bd7c93a2bd39296c92d61e80909392e5f8a20c59338cedb235a6083b243937e89296ab4892c713c06ad2a60fdf3ca2ee39ed786fcf2a0cfd8a80fa8aee46a4456d8aa8a42ca50cdaad57d875aec7d22f9fe969dd427e5b03165d1ff460f3a3faf0698ca9756396cc0093eae2084bb0455b9dd921c05dda15f15755c0ade7528b8b8967e255594ec2742916ff0c0728863c3aa4e301b784ee8efb7b354e3be2f6632a69aaf36d5011ef3977c7aa944a3f1feea2abb0129a5ee1b0327645ef9761225df8bbf1365e57c7547989389e6086dc91510d01430ec89518fa1ab3b6e2bfeed13d067aa9f453793e696c7aa48d3eb84129a0fc7896e04af7c5c27832e5ac6e59d07b73a85264279b7ac92530f16848871f918dc0d74e5f47fe8c8420d94f7646738f53e2a0eff28d7e9b57096ab6d977980070e6807bfa17cfad2f1fbed4cf937d957ba21168c064944730918e093a36ebd6428ce1eb498bb4949f8ce67c3d9aed3fa5481411d25603d2f72b461c44db6698cc732f628ca3dea55b0fbf459d77a0780a959c9c8ce4463e92f2b75d72397310417800b996584de61c4f86641a21fb58d82b98d2457addaefc0e0287217200d8347c3f9226ca492710c654f0a649f80c8bc5aaac9407f3b5ed87993235ee649dce4dfb4cedc2b19ce099f1a2b1bb1fd8fde7b35f63633dd363cb1521ac3aff380c2763f384e376ab491d43748466feb6e3f3e23e57e29f10ea71c5e09876df6663b9ceedcdb6476b3417eb95cee97dc3e233a83f1e859a2bb7ea463c7f472a7ed4958538f3db67bb25572953838d02cd00b9496d332b8eefd77475179d69a2087a5d37b93b612d5930e6fc33ff1b0e3808f23431dff257b0bc0372657af2b01459453066b2ba772c87c7cfc1745cc0b459e38d509d3b5169d8c12c90594778f53acfd6fd219510b41e0a8441e394ae80d83aa77b6c3cda83dcc42462d2a3beb6869618ed0a1233f04ab2b3a29a69d454ef6fd30aca1249eb80bfc5ae7ebde0a0805c2ecfe6a9e691efdca8d338668fc205223489017aad8ccc77ca6289adc10b3bbf4cd2c0a4278f56eb3d66580a9c49ef1ff49def5b8f5100f95ceb14d6448627e5d9edab078afafb7f549f4f191f368ae8dbd0fca0ad8c6dba8088798c0b39b7d134581343d6e95e2bf5a7aab6b6f3e191252e5ca6fcf331bcf6d58366387c1d40044b70ccb589d58864bd0d676e0aa575d4ca1333044015190b3b01029544ccb2cfc2e092a3c796bc8a77df03181f96f61971ff8f9e93e7b6cdfd1a952c4788192bae0c7ebcfdf4a55083d3f0b77dcc5de44937f94a313655519427f08280de70e46a147eaec2273d11dc659d8e1607651a19d4c563ef597b079a2311b108ceb66349410d42b30d457ba5180ae7c659e1b9b1489af9ac3f7340ff314af8adc81a1818dc8791965aee4985ffab518829c4b1d74379d34db2ffc816e1f574487c5095902bf560191259cb66e586084bd3eb2304d353812538ad76b552fb7b45b91c70b1e91709486bfe12311a5e0119a753b1fd12f9754ba8b97b08209b5b91adc09a281b4583707e6ccfa9e82693f44ad6c8ae04383e679daee0dfceb0eb2d54e63694b51c1b1001e7e3a9ca48146359813663e922ef829abd80b938f2eca72c795e1b347d5e3ee52954ca1e6993a6f737e0062c1bbeb24c16c3903da2715b54f5d4917e289d3a4293a1ae774d0fb48c9d36202101eb18cca43144e7f2442d0b1328376dd85836ea5921c4ffac4996cfe3c85ab00cbe02c07f68bf86de08b4352c4a88ff169a1c0dddef131928f04db1c2553d41c43f4cb4a60ad7a3f80ef452d34c35ac8e36d7b85cc26af6d4c21342dd95f3b043909f14af61d3713239ef8e028a48f7ee78eae88aae42499355721e3f0aebfdc0d85c7d23c7f4b7e824ee7fcd85271f6672e0b087982010787dbd9c927e5af66a2deab5c9ab0ca14bb9401165bd49996ee926fdefc09ff3921560f1617ec95eea7ddbc955badaf68e0cb55f69090ccffce9cf9b00914c3348b59954471a6193a9c506c5b9384c63d71bac9d2ed2cce4b4ed5f51dfe5d8db032bb5c9edad6208414d57e573aa7fea7984743cf68d98e25158ed2c2c526751f6a8a99fa44e8a42e1e5abb3db3712e9719174c001498da7b41322fbbc47ce986ac54dc6210cb6169283d98d078fb13b8c2fb2df77d6a54263de31e6f215fcffab6caf516ce1409372dcc84517752731bfcd675c1b11bb033f4bf98a0ee4d2603b750d8da917d1e04b818b1d075dfc1d5b872213cffef23c692ca571603b48cbaf15eaf8ea1f9723757400387d181965c00ae1d2cae29848d53c3ca6afe87eeed5e3362b95d1b42b9a3794f106db2cc52c46f54116adb220d6f22f0fe1d0f7a6dcc3d85ab6466b6653745e968a60a7220a66bcf470fbee8a142bfcb57fc6f5aeba92df054b3b3bb03e19b90972473c5b6cdc7c5a8c66756047cdecfeedf45b73e4217e8ed8fcf88eee08f31f1117faec7453b2a2e04855bf6c7b4ac5b196103c7148411df6868775eaebba03f6b10e3ea7f773aa380b3c5b3b819ed10189d90550527c80086c3bdc746595238ae7da319e889f1fffee70de3d421f8625d2eee30574865c298574fcf7b132322cf623dbf9e7eb2c3c1b06cdc16bc51b8236acac634ee787f6e675fb3287220b105e4fcd479fdcf03a5643d94d4542c24fa4da5bedc788e8ceeee9c602825eaa5ac4226f5d4ae7fa6299ca9d80751d05d0d5ed19d8c1153ade7b0fc2442444b12995141e905a0968fcaefd69a1dbc869825a00c50fb25d30f478c7f0f26da6a4d0617b06cf54bccc019af7c3f905beaa998a7f3000fb6fa0af980dd8121f54f21fcb6ce610156247a2aa2253341459454641ad874a1a6c20f90f71f4144eac1e5393412670d8f233b1d9605ea571d66ce362ae591cf61d90c9631f59c341312af801283f918b1d185bfc393046960d83e78cbe0d0114642bda29b1519664f5c80d7fdc20e993ca5732c29adfbea38b1ab3b1f9a374317f945cc59b9c031c00438923532af49b7703941e63d26583162f82357b00400201903a912b40c7e89c42a0a94e06f7b24f22f2b5d6794425cfc63017ddb274ff56f4c5cc6a5e8de1d823cdd417b44f9abf930a94dab1b3c06aef39f3c783d91c31fddd48a0a91aa308deb74869f611d03679a7b4920d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
