<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"190ebb11a5f57ad8d12e87d558a01b024f4d8a05c6fa8f51bd661a06743bddaa643ad78836234d2cf02a482e28244b00050c2575f8d147384499ac5db55bd34d1406d01fdaee9bc21066764e124746b8438c7e296a72b3e2fdee3621c13e7d54c5c10da4a96f628339a54017af1058c7aa60c660967ca2b66d64e4207ed14e550681c4b21c9209bd312db5b017a727f8f72f5e9e264d2d1cd475321c54ac550a1ef56b8268a8474a10ee9dbaea135898dc71ffe20c168cfe816bda49fa82c041a4e1fd2d93b9126285a5a93b32ead407c5c85bc795e9f0381a6806df6f9919fb8bc422a3a671b78d24d77d0eeb04c325e83358403dea1165dec2fe209b8054fa692f2316da578b96b860acf0a38b257d5bb9531e24b38fdf8eed5620fab3acab9dea491d1277202d2c2e28a556e037052c63841ff74cf9007818331d9ccffd7bb24370b04bc570952935187a42e120cb68fb85b6494b41e73f625faef17b76fab524fbd44b30d77ac147422959289bc8dda3aee4fcde0d0136d28bb52d824da9810ef25f9696e9ea4c1b4693af515cd14cc6edcfab39f9247f4d68f979279f8629cf1fd23db96afa4038e97614b651b0e30034c08d9f18208da2890adc001a0cb13e024406d974b3a195758e5e4816e2c0824bf5b2a6490d1a13f4a29885d3e50b14cb190451ade94fc1dbb8f78a2af908fbad624fc88efe2cab063a17604f710bcbb5bd69ebcf3136505bfc71b997cabf5cdcbc5b8885682e2cd6dfd24fb3b2ffc156aae0b809578859de57b260ee804a045ee9f5ed2294aa73e5fcc09066d97a40aae2322ec48ae9326eab55c59c902b9ac3cd9613b6a5732eca04c450e4fe60014572f667139ce7ee6a60567fcc72d00db13c80930c420c22e39dfc1e3441e97a42d0d5e6ada9b554f3a196d1533edce5b429520a5b71a610ddb147a718a8eba6a7860c4a4e80d43080daa0343c11d12d58fcf7b8685395d19062a7e156f518ca7e3e52c4726fc58ef4ab00905954c1ee0e8e919ac16e3aa300ff28edcb861d9b12c64df568bd9c53ec53afc478586b29a8eebcb1e854e28f371023fa34b9ca73abde703beb1a551744afe9232ba8fa0f4ff67d4ceae74d13ceca485d04e6277ac7c31f73ba6b1394c9f670b0510e3fab2abc8ab0551e32e98d371880e857146adecb089fc238c15383ab304fac45f504d6f69a99b65ae76fbeccfd368fb5f187c0eda2b79fc5ccda7b9600d74a5d3afbf9993aab8112a1f3584cac5a8775d3f87bd7b69e01110a20432a862fe914e302023f0146f2c56d33e77905d5dcc061fd8ae193ceab2c3ca7a9fca1b759d34dd8e63389a6a86d955ea1302c4f4cbe3d34b3042e65e3386b5b4666b1f08062fdc4f2c1c758780d479ba83735f69d4e0ab1f23092c5f43c826412f623344781c850340d1be5b2ccd5bc380bc7433cd1c7e922596ff4001b3187340a67f7b2c08a1c13bdd5f05e01af1aaddfa6918a58344537079ce058f52b61a535879e842c76b7dcaac4e7e5472960c115eb724f42efc73f9236235faa1672dcc471dcb60c6d4157698c8ed85c891f3210a6e7d1f56f3bbf85359c9c1f2a56612fad3b0aa24d7020d87b4e97a10c7cbf411439d13ac0eb5d76ad0e4c5c56635a3d4b0fbafeac24d97470487141ed4463039781321ca9eab50f29072908e959df5c177e6bb3a3a0d24241b1aca9c00bcab4e935f2b8aa52f476b4d3d60247d825943be96e71ae923bc4c71f02bf6ad920147ea044a4a2c89292201b20b519340b9fc84a606d8d99f5fd0760c0ca4697b6342061fc25d6514bfb67f71310809a6475ddf39e8f80a2c95939f7d1a7dc105d51f77c293db3a1a8a808a961b06faf1c996fcae90e7629fdd183de41173455099aaad4b38f3d8da64957d9a27ea6546df79283c27d6d09a2c3e8efba20dba19a1edc0101d28c150c5fe5bea55a383fc0deb590ea8a53c6ee2fea8e56fb1130257b7d96c61deddb43a9b96ec6b2b36bb3f2843b03bf58a32504a7e70214dd6c7a8e0a459f454e68f7cf9acb0bf54f131e2423491715a8853e2fb2548abf26230a513e6b923fb9e9b72b44fe594be2c7877a4bb08ec21bd13961e2090f7bcf0a70481618908c6e5491e56602c83bf091576a20bac3f77981ffbe90413e5823824cc0c31aa8a3c807655db77b162738d9b6b057d2b98d837427d5cc40781bb66e81b09dbd13e0d203683b8f94246fbc894fc2a8f6c88dc054533f86e6ee2cdc2c43af0b0f32eec110a68be2f85fa829d7e206dbfca85931f5e1e3bd3f511966481e56c6f154d2a4877caf704ab30823f49044b6b01ba40427a1a425b78e23e681ceb81ddadc98194a226c033fd241657245d64cd30a83ed1f072c2bfe4d28b2c862290d3c50237e220eb55884c40fda45d158efc9fa3951b355142dd2f78bedf390058ea5dcd6fb9925c8ca4f821e2d4787de1e04c97e7088f40a8191ccbdb367ef8bc6494850095cedbd27f80381db4fde1208201d9031fcebb49db56238e86a26c743d3a91b85c96b58ad4f572743bf5284c941f699e918171ea22b6d361245d34426ad33da27a44191293b09ae178964514287ef139a4c9fb1b21870e1509d723530b40bd1e7ffbbdb8913f7ba36984035025d796c676fca3e89f5fb8b77214f146a95ae694fe02a84a9fe198001b51539104d55ea3d9e65abd6ea1d956383c44db9e5c7a789b0fb99d9453e8174a7d562280af4731d0c5fda61778cafdc54cc71ff08fdc2c8f07af154e38d65f981a7e1ab94c98a5ca8cfd2fcf56470762bb9bee15d9f2442aa8880311fd6109fbdf35d262ab064042fd53cd4b89a6eebefa3b2bad15002244ad544d7fd0bad71303f6a44024cebd1ece027c3f72606efc3781036760000ea61cc5147c529538a4213899a6d63eca2bd794332da6fdc137fb28a39ccf6124673eeb685b8be5906b89798dbb6ffe9975a435e1ffdc108c3cf412d746581fe9c62cbcb58b68ed0ed1989949f758d305b9787689bebdce325ca304dadcea1ac12aefbbea1ce84657621fef73467a90ec4ba006059ffb8209ed3e3bb4b48c972ecd8bbada0c42cbbcc534830d54d00368d8228f1c16d433980a2d96eaa585fdf53324d09772e4a1d31351d8815c376399fdf19b711e53a3ea6e5ce054e9b29eb29100e719935df0cec1e147e38c7cae508feb1984a1b4f75e67d5777c2d958c27ba6bc39e896cd25f58e320fdaa54fd3b06ba33a604e4ca85899667e5576b89ab41924dd42aca4b09225d6c1d0fb5786521bd811512cd2b7a8e460edca8b682bf2ae3db550c860aab2c6e8713670e13b95805883cf5b73cae250617d6498b366788db631a3bcddc0601cc61f314a7c3a53d13e332b93e57ce69b50adc5774b715d617384e049a4559eb78f237a4bee6ee6917963c5932b55f38de0e614e13e69afb4e8bc806c81a43af74503bae148c5bdbfdcee8ac2c6487778c2f1c2cd65120bdc3790d34faa7cd9ff99102d20183a0385d1841b8b4c98a92ca14d491fd16b7972ad0612a6abc6dcd4b5c81823df50e8a50d0f43cadf40920d41ab7ce90bd77854f5cbaeb4aa440f1d4d8722992e6da6f28247a088e5432f2140a675335230182002f8b31107599e4734684bffc09a067da65fe83bd813560249713c2e5a3163620e46713888f28f75295f7a662855e6401a5ddb7cc69e588462452e0a2212201cd5bd233921fac940e7abac47708ed3406c7418a794067ede8f1c7c8ae178e003122b30215e37781e44c30364db9f45cff082af79c22a2340cd2b12138699256ba53b91b8c223b8020e6232532d4a6e4f9affd4af3e60e1ee5e00732aba07d617f30eade3a44fb5beb17a18c021c0e3f08c32a66a51a1767473c9a72c4ba20014ca32ad1ef765c80dabb20c00189ae492e8b733657c38d479042145baf4c0e720cb3946eb3126d9baaacdc7e79824d1e51b0b78f6155507ba407f982f4e8573d7a95a0e329cb8ff57677b5a57da06313112f6d3a8826e709f3518e1b653909a4f740527b146c204f13e4635ae53ab2d80df9f6611fd92cc46dc4b8ae83eaa21eeb9950caeba3ceeda2127e290f5b89d4d59478e72d78728845b7a6b77e67fe05a2013b6de9a11629ceec165c9f0890095ddfd40871efbac234d4dfad5a6b9be8efe6af414ae646450cf7c973b3fa022495c06c08603b3f2594fb8620be33bd9b4741cf4d79eb3efc8c00c31f0ca9e2a00db1150a56ffa436fe774c4b6b71d699a150e86a808f2469a699e0c8016cb77ff6bd2ad7c34bfbdb03309185005c3016646a665a37e082c274949f13b7575ecfd94ea5f061f0820705c8e29876f080f3c110670cfb3fc0c362d3e058e09780f06b8a28f3d2ae45ffb08244fa17b41f796b637d8124ff89f9d19f316b81516f2c386725e996843980cf5718d5ceb78eea7a7859d905fc21f1bdd9470bc74abe768bcfbd0be5fbec27dfc02d16a825b7f7f5a2930a4a0620b3460cf8da2acff585e5db14810665d09e660c6ed9f5899cb33f36e152dc6bc5adce8d0e3ea9828ba3ccb53ed8ed643f10ff96bb51bf5b71464fea4cb50496006edfee11be53fb901b8f79dc1c3a1908d5ae2b9a59190d393b90d13be392aec63d2629f9187dea365eaa557eefd590ee63cfc885fc2b76efce6321ce836d00978f1a3dae046052bb56bcd4cbac2e4ba282cb19d005a5691a2cc3a7d63822a814c5c209a860c5b57183788cb1fdf0a5540e5829a65610fa2375072b8e00a9a32d18de74f4ca4cf4c480568c24328ac458d0f3e8f59840ad9e42b49229d4b5dc83a81cbea38c7bda66b9176068e0bc8fac8e9d53a8e55688dea26c68bec78da3db06e3c262fafa6ec9a993c4966b39b024b542a15369ece63c834800c39dd31effa4fe36f2615dad5368e4969f202684e0d43aff2688941cd42a4384a303f488c40810fcd1cd5989e2c7a360fc80765355ef88ed81eca9c5043000ad6aee1310b026f4cb00aeb89fe4fab1722658dad8274b4ef8621904ab7ea76bfde424a67ff9e098ab2552f4a7ae4ced19db5a82e2fe45b3150347ed3f66f1f6fa39cdf2cd80704a8c18c51d221bead5bd220580924cff2ac153ef107a2a166f17098ca1e510a44ba7bd075daa10d34a371ff456f4e7058a198aac6d2837db484f29328cca5bfccc0ed10ad149c53e3ef1355bc9c35acbe8afef91b283a1f07702f8171ed01c92f5fad385fd59ba8afb45f0e0cbb5a29436276c49ce5950d98b84f75df723cd2127a43519d7ed3b77f5e42295d4c929d89ed96552a00ba0c2f9aac3f7cbf22ea4e83370e45f89d5fbf07987ab864384286458c81540ef6c8447a8050dbc310a9ba6f5d6bf2991ac8876005c4aee9370b1974ed2039a71b0b3fd8137aa9bbf82441b37422589becb591c5be29693105e1b99ff3de3cb3415f7e19ea9d6b82b3df245ca390d62da2f81e75b2ac7e0cb010e16eeb47b47de1f4d003b73c089166f3ae85d05af95eae4498f732d7efd12e49d34e417547066a7da9a1adeb3a7fcc00d872eef8dae1dcb48df0761753afbbbdd9e3b78544326c66754e7bd44e2ff6e516f2e98ae28c00ada3d630ec2ad7d12baf428f2d0d94638d497dd387777eb1e44aaad614572ad4ba13410e38cd46394ae8778f4ef511e768d9a74ec09548fd960ccb29a923cde6f91b38ec0215fe0a5bda5816af9a0123854ea5eb4d305f107cea9fa6058466bf50c4b68b00ac63a9ef3a1bc3a1f815c5999222ead53896b0e3f3f79632f965606a8f44582e4219ffad47f094f0921b81e3e16fdb6232790fb001b127990d4c1bff0c401bf7d8fa4b5c72d536b2703553b4385e1b908aeca424ef3458e6afa506da7316a017e5c77a0caf087c44d455b535733682c3c9b4f5f1ae1527f5b4be5b69a7c987f506e8c73f774c63e0260d5a0db7fbcc4e672182668538453c57ca99835aace5f40926df54a51e558cf63e568b2543c20de4f89f8785926ddae36d1628267466b211922661af0cbe4d3957002f4c267711625d8f0ed79bad4cdc741c297ebdda3643eec390cf99ad486ab3e317267421554099e47c42762c668ca63f8578c710f8b57683ea713bd818dbf9b3884f5b1745dfde9ddb13ba4558ae36d88909b05eb725cffc998846af630a6631a60d552cbd8b0cd65b7ac74e945b3d3dbf5ad1b88dce793a851c6a95c2161071f1315e2b7d1b0505b29132c296cd8af43b3d0891402b6af8707bd5db9aa463ddd7b98b8be19fb0902eb74765aeaae9ce58cf72fe2281ecbba3c4c581953f0e253a86a958f1ea3fe74fed4e90c023bcada7d777e12f7de9f1d656b1356717f6be52421b8bd98444e1c858d1f68b8e339c0f6dbfe00dd5c951b023e5b615aee0b07421349f35ad9c92ae797b602afec50089077d36ef4de359c5acca789439901d896ceff790cfc71e219a3777c360fca343eeeab85b9b968c39b51683bd170f23e3573febee6d00f734ec52979a44f1f872c5ca730c6d53404f83e8c52bf2c7e8786a0574d48fc84c033a56ff80f62d8cfb6bbfbcc57f99b8d724a05b7d077963fe81de9ff85ea2d149e5d5e5b7c53f82f4eec27c6af8aafdd704664e779b576b7a0c2e0073afa6572776b6e0f2aef727eb1631d98a2c8a7ea3242bba972e638cfe9d3922b4802341d0be189ed95bfe7fdbfb708565216a134467ce7257f605fc7689171a772aed25d911e2878e20b48cfb9553c0a4ed351ddd81341e2cccbe095849e07f5da1244066c2ae821ad6e6b4ddb164c11bbc1b5a8541d13ea429d212cfebd987675b83a7b162b9b052f7bef7326bd9d882eb531bbfb2b9e25ff855606cf856e34c38fb4e802cbbd0b204891fb9f85e52ab4c846ab25c0b2ca6d7bbbab9857227ef65c2e0bcadb26434de724a8a0f3eb11246dc03f9fccd2413500e2812f61f72c45cf72e56d1ca96ed02039e6004bf22e8b15c40d6c7ad8c3ef5fa9d4f4aba21c775bc656ea8b9ba071ae0feb7b162d5b4f91b724460f237f70ffd63b971b0c046bd9b4cd6557c0e2d7abac189d89f1b9d43afca07e66e9165b1fedc4480b72df3cda8eee22b3bcc8cefd405be0f27b9da6a00efd037efe9f3ded154200c57f09a9cc33516589568d74cc399457ce02dc61043530320a5b345e0f52cab2f2e1d506fef39280c1ab19e7d477cfd3f195e115562a3cfe834e7703b376daaa6c03efb530519a25a657b3d0996cf25424e91f36d4c163c140b29cfa1040c1be1452557a8c8deb468e9cd72a6628c1696f6673a929761511fd039959be5cb1d16d71742b1adb9f6c830ccfcb1c918f88197246ec91383100f01ce380e4ddcb7a6384345bb8d6af9346567915bf6086a19e458c8da957e8a896e18e04d4b410a5bd0873977499d5492f88221aa1481409aa382da323a76862483cb5732cc3b184f72aef1e36a62d122680425da02ac033c24569cec85dd139c9f662a97ba930fe20007e80c74fcd2bd46158190aeade0bc0d797a0d640c158ab5f05d5ef96a7948a91c0896adadde9fd800dbaed188195bde4d38083e9fd2c51ff0a0a7744e68a55965c636bf3bb4fce49955d728cdbe63d216ddf111b1a7ba0b0c78d205599c96388a3bd9909800527e14f205d21ba3fbc65db1df97d433765dc04e7dbe1c0c23acc4b91e112a8e49df534a0cf8bec35df33a658030af535b08e9693de58aa0c70136925738a7b05cf9dc1ec30ace72074ccf228cd12a3a16c01bb780c3b7981fe26f5fecdc47cb5145e4fa8c123c5f30465bb780374d1235f1c0c5767f0712eb82dce0ec03c6b85759da5ef7352bdd4d5c6f44764707d30c1896a3b845e235507421c3d38077e9b4e47444b2278406ece34c45f70457cee6142c649a005bd85fc300d6cfa3c53346e063a1b3e746c9ccba66b57b9c1d347ad9a93d410ac8f1615971085a7f051cfdf3b7adf1658f7d56a1141ad0b010230de40cfdd03d2573a92b6b108ff76e0682a8efed828a8f1607e722ee9f0cd45cce79322cb8fc8c7adaf2e60d91fb035ee3b4500697d08e9e8499688922548d27ade348a82094566fdd99c9c16c374df57c8eedcb5d869f2d5819599ef17c2d0063df684f9381a9c29cbe5629a1a55b4aca0977afd3150a573fa9669ee39961282824dd22d84b7a700340c394ac45431b1c261134a43f4b8f42211d9dc66f7e0a47efe1299855c560a96a5f29ccce26790791b034f800c7acd006a0fb334d9021fa63f8d1a8f12dec718158d313fe4cf4881e83f44915ba0f4d73e5b32b803df5568150d04cab93d2bee1f9f3212553f213f25110d0498ea0ee7d8341d8a2ba931a28579f3838cfef042865cca2612ee23443f097cb3be4293c4ff2e86803b2ad429c179939e52a25a54e7256bc4f875eeee49a71f05681e7b98f37736d4256b5e6ffe3833edee744ddae886cd71d40f07900f3d33dee09a32ad87b188797b6c83a138da45e40e66a493c859a60cef8100b8ad4014ed55aae2c7ad4e9159f8caf88bda2a65e88d52ed0e9742d177e38f72fa3eae1b6b1ef93ddf32725c41cdfb336755f3cd22f73b21d510a4886b2109d6fea785cd364182fc31155bdd714437773d9e47738777aa065c66a3b87952b04d042c93fe03f21d8f7cd8dec6353c6c620bffef62ec272ca1229402d1054d0c73d36bb2be7a2092b67212fa4f0e93f24947093ceacdb0c35b6a1c2d9795958f27b6b251d3e67875a552eb9d08fbd9099e27c54e80563cc82b0e8aa69b8b07f04a9a85bd3942cea275cd655e17869f69341d933db7988df8372d148d67cc83881d7e17a20f9a098a8c0e59056105ab25b91227a43c5dd77b25c1f2c4adf545154ae904c0fc87b68774b0aaa13eb5e3d5497fbc5f3eb1b07d0feeb799f162c1a8d6a3f48e7fc5f00d87cf5f743d4309fcaff56ee6544341a302aad37ba93ef5912cdb5aeca21f3028cd18301de732886796aef27cbe47bfbe9fbacb9cfc9ecd930bb8e92e5a36bacc89d22d8fabe9dfa5189b74aef0cece6c5f0c56ba8194179429229025aba8bb691b65d4e50904b7c495b88b46bcd853687c0434147983dcd409b2ef2de351809551a15d7af4a34cbb83c15a728819b2dbe9dadd19e563bea49ed37401a5f35e20d89decf2900e2aae04ea69c4fa3729dfea8e01c2ba3b9131e24f833331063190952d1bb02399ace33d0cbcd66336e170914fa4ac0ae17b849fbcca2aa0656cb630dedd27bf50d07f4d19e7ffe458d2ecdfce8a75a66fe99f218b3993fafc7f7f3c924b1d617f3dfcf594df7a0c4ce013cd7347076ed3f173761e81eff56ba1d6af704e19b390e522e368d14556289021af8bd5d9b0216b302185e74d26e7abecdf17428ff320bcd7583580ddd4d8ce4a0cf2853afeaef967103ce7380d65ce19c4f104de662632672f0ec89f7b59f56e0bd6a133702db9bebb38c29218b35caaf8b2148856590a6fc40ffa46003d301b8b90af6e2e49875613b80377469035b60266f617fdcb8858ff68bfbe0186c4cd25f0f9f4215baca4630915128fef43466aa412dc75c7f57485c8ac295d0c231704ddd57db6cc0b4efcf00270e77dee7f33eaf73ba281fb8b23e413d9423db52d1071964c4e1007481dd5a2d87ad2063572df43cfdf3829069cf4ab32a29459eb8b840092bc6326107b1849ab1d10132dee8d749bf718bf27246aee73f5c8135127aad7720c5c6f78edc97a2eeb02191e3a41ed0b76cf99eea159c8a658a42f1597fc08cdd5c85fea30026c43104be96b86759b7af29bbcfb226008e004f047ccefe58fa899a321f981fe5ec8324dde16f5b15126540b045e40df40b018ba3cda2d0b509b831d19dc0e1e6c7bc9890d9192ab0efbd5ca07f15ab0fb877a43eca73455d07f0df7a7a6683a929fc87876a0496c1ef7296593b48083c75d29c211ba9969e48051135eb6ea40b8d5324bafaf48a49f483d5bd637a4f828582f595b0079f4449bdcdba9f5c52a578673f109dddcd6e54e38537dd33b607b2fcece1b0e4cd8f8a88ed12145e89e4e3f6555008519b5dc6ae65f7306bc687b86923a8e9476755375261ed5ca114b02ba7606fe6d9ec128448a55b30b30f21e87b52916e0baf97dbc5297ada90ff711b07cc3ee5bcf3004ac8383992c452f02f1be9331684842e4c5ca32d4a97a664e96016a1fec2f9c2e3980a14274e192cd2d6554d83538c442e3d754f405c6d13dce02a1cfcb31ece8ce13cb42c95ed4bd31925dfa791e59a968027cfcdb1d639116d23c3a7ad0762fd6bd2a86733c92b3e5f5e1ff9322bb82a8e5d99323c40b4a8e3f7437e737fd829dcaf8beab7a58620f3af4d40d6207f9820d5e2df00ae63e72f2746301e11ed36d9238787f5110da878149e3a4cfb77542648d8fbe5a2c9d5d5e88bbd57a44127dbc051ed64a614ba0ad378cb1acc5848084ce91aff27b1f97b4e0874b4883344239c73164b463f45c48dc5c324bc1f62266444d6b87af4dad591a4f77edc41d7aec201de8f20f2f4f466175cd2433567a26cf769087ba047d9de9e80095126be5947686f9ed68cd56afe2eacc0bfec0a0ddf523d408c9876f0086a0c6c4bfd75c17de630aafb3dcd368f7710104975c46e956fde2f4f463363c5512da5cbf4bee2cbbd94c3c5e70fd2c81553d6a830c1558980e1ce201958e23274b85a5298f71da4ef6942ddc3b4caf9b677a4a7d3a1b8ca5e048772eeb58e44abae0807910f4d3fc1b779dbbc399058205b8b6f8cd4d386f2c874f475bac760af7d66af6e9c1bc887eb40630e600bc177a4cbc50b94f8f703b8fc4789f889c62d9ccace72db26a2ba1c654b588cfc8f4c32077fdd0c9019792267b1543861b1372dc7efa1f4edf0c63b396374e6f5c210f96ad2bd8f95cab478ea1839882d76105da9b6cd134b57af124b7a20067aa01fb5da3daba349f4fbc554cdd700501fb4ea69daf2e38e0e4da28a2097b3d95e62480eb5ea4ffa9b678b669e38062bfa30da9b715fe01217306d1285364401991308f2699827fcaa87ef6d2a54f2d55a1f561598c472a1249545d0d8404a29fc46fb276526452d1170cd8ebd45f1f0c63b6214e3e449841b46e24169a924e5fecd0a1363c7a19d57cddddd3fbc644ef5273fa0068e25313c2ec3a8af413d195d045ad9e1c984f747c1226a061ba754c53b33d1c4d621e4a7e55c89cd6d635d03f835a5eb249784323293d555f7060643931dae849bc5fd4862b8a77d17b0f62de39a742e47ad87b74b63d8755fa263b6356377f7681f0b39777507cb30ea057793b1e1920678ac0818cee16b6fe4eaa0a888289ac29441b2ed9ceedd67603ffe71264bc206db9c55e967c4fe951839abb4a2098ffff3f7fee52f11979ad9bccdf030a6b84a72d4bfeb1844a63507202e976f61e9bb9859bed44db572f6872b60f654878049398e3a18b5e66edb094bd28ee0c00773a33ef3d3183df3c6d2fec52d0e87ddb5a44666d72660ac378fba617434702e92937c0b998f2bb0b36a0ac412290c39efaf023eaa09dfd463c3db1c1d2624958a40984d6c06a822c5bee9fa6f17ecda190bc39824572222c534ca86fb9be804a279a14bb9ffca1cbe471c5575d74dbc135844062e09448346248681e1eb493a5632fa3b1bd076d79420930f74f9b6f293cceaec1754b7703134dce5b0c4e1864f052b04b333a5393d5cc586c2b2ff12b9302ad70f4bda3f55d2540ad9fe215a3c00d89ab99e36009e57956bc20862c9d0cc2f3785550d926caa396ac4e1a99123adb952c2263ddeaaca37501afcbe6a99a02352ff9fc45a9523d166dc5e81a081df7a78b9b2c63753bdd76f976e4d4ac61a29a79a04d1a4e6e38ea62388020a7fabf5a014cbb85c78decc9979db2af25180df9b87645b5e3373756cd68a04ba8a842922000bd53a8b4a8d3e9733a388a78c24dcc13fb369ff8a7dec0c4c29c8e7a01381e91624b86b10ff1c3edfa611337fff10cdfa4c8c36a7760c8a7e510d9ec8a8462309930207378fb8af97a0f2063a85b909b7a75fcd53381c26d4a06171361814e6d7f229724d956fb7fcbfc7858671d1f90055d437f3b45ac99e454c501bc6252ed31734e61d2d1894deac37156b739a735c565c32d88658b26412ff6740c44d8f8a625e8b89a0f8f0b4328c9902230b6d92cfe05442c3099f997302e6b3c5a8a5cbfc3eb92afdec0c5832fd8f12b2475f24320c89ebefd17e4b5545b913225d965154ccfe48597324e17fa394f160adf30ea3ccc81486ef5a07785e2f7b0be2b5b7a16c32f219af335c73103e0ca308c60d614073c5956c73c748e7f19dd2c0d80b0c516119bae1074babe49fc23b0d347b2733f4bdd8c81beaf233a16be382092791e487db76dc77d9e4632d8cac047fa38702a4f8f2d104cb2777ccc6d58cab65e4793a3c45e38ed538c76b2d01f3cdf4acb26b2af7f53e04ab3fb6221102897ac0fea45a46569bb1203d5c01d3bf07c7c76d9b97df7c57dd4abfb7dc1fd5e70cda188bea92589326315ad3e18a939785241dc2f411bfac82fec928344e6a3d6424a95d39d84abf8edd54b61f0534fd761dc0eb7774853e1527b7368914c058cb4a4597432d82fbe5a257b1b83dcfa50d395836a17abf236e4def34dec68a9af903a3b98c2522565fe44cc8a0419c68a89aa1dbba02217f50e6793fc1e16944511bf3bc8ef4b193f9cb4661db84d7db9dd1962ed175af4a97c75f0a9c1aafc40e5afd710da145788469947cabcb13603e28e7d77c407d5be74f91ff421fa4ea3893bbda0e6bc50f143044fd5c1f7989d1fa321549750e31be67cbfd33c938e895341df08d2fddb16e7eca808c1b27e86b9db34b30f7c7b548ab084a2f75b072a586fc9a436d3be2fc072d27b1da48ac1b8df3399be44cdf12e244a1606145737f4430be4ffa99e0cf39a10463d15be09185d4656f538c1b1f759ece0ea8d5aa3c98b182b9eb78d8320173a3e6989575636b208a7d2e984fb0b27746224438d70de1d1dbdb7263141d2b8e2aed7281a38f4e4d912229bcd9bbd364779f460256d8bcea296fb74daca9a6996537422799102986af4c1487d186433c11b009c4b627b061da52f5c7ee525476b5b0fea19e656896e544ecb43c5f804a6ea9f74d656024fdb4600db6a5da8a867e2933c0d51e052a1a9222f9beb7988eb0c4037957dfa625fe1fec75ca751c13ec8a4cfd5e2dbbe37047b025bf7ef267109ff2ad5c026e40d6a02428680fe5a10a254703744506e0732fceb52f50817305c7e5e1f78763ba58ea4539e962a0c217fd84df478556bcd785fdee4dd260db92e38d9c476365e78620fbe34e20e02b409a2a6470403803970def5d3c0e0126ceb790d107ab96acd54880dd86ef3254a0e6e86d2785bda78b5b4d062883605f323530b4f412f5d946c79b4a587e8b01a4c736cc86509101c9ec306799c93f5dfdd8e37c4ac16351de5429dbb8d7b681c657497b98729d5c76196a375821e20cf310f337794ec5c929a39a41ee384d5a90db30e9c1e3039e129c657cadb3ae5afa790abf232078ab39a69f590f5127d12f5944f963d0ea3f2bf73a1cfad23937291f81d4acd0bb7053db0ab236649e3a4a162d6d0447c409c4d4248c3bb99865c0380334d83cdf1ae973bb56ed6345e49aab33590c7af93777063080a94e7554e3ba77d497803b6fd87105616927930975c04000cb57d8d4818db4dcd7c9416e3fb86aa628bfbbc63ea7aed291be3c4c7b1597fcae0aa40bd0ca41701dbfabc82ebed8ba0389d2e0fafa15180958d53ca9fc0e4041b8fd0e48fa2ac91ae53215bab831734994868f706680f0727345b4427952006ddd72431f5c064f1f55e153d4b1af8e20f86a78cde2849a9f55c71afb976be5af2f3a88d86649bfb2f3e8fc08b58d7e079d3007f16c134425e3a1099be53d59d7e858f394586d8d87329fd0afbcc3cd2497f498146aa6f71767aab69de12c796251643add9dda374d03898f330e8203ee377b92556d1810e820d601622aceea948dd54753ac627faaa6ae0246d0cd81ced27d38da961b7bfaadd5b20ce64b6851f6fe3e5966949d6b5cd4521d71b0434f6071e32e1b265678da5cd9dee464c0c3cc897710e179c470bf864590a87871c973cebfe5f1588c2411e0467689bd584f8ea30239889b33c386a25d6d78b43ed4d0f333b7f18893490fa3a72e315a8f6eafee06dd44b13cf63ac52146d67ea4c3f42c20219b4b3f0fcaa4f03d2538bad46d3b88d088540ad40d5fff9285a23164e171c4a38ba6657c82791dccb5ff74c1443cdad43bfa5ec2d010497cc2c89d2677c2541a3f20223ffdde7ad498c97f9dbdedcdad000dea398bbfd08a7890b3a778ee00cc258bd3b72bdca9c0fd766944db1e65f1972df209a1e896ca9b327de1f625621f741e4f08d163e196a585348de13821c2f3a0cfa80abfd7413ee35a126658179881c319e92dfd1f2fca3c17b13715b0979ae7591b11943e1d027a6299defa663b26ccf5c6644678231ec56e03cdb71539534c701aa0d0d530880070e049e89269dab752a559bbf0de35fb4d02817781cfb502574fa8b4b0df4783bbfdc6e3e7ee4c6f0e0ab10825bf3c63b602c24cdde1840cb8a3ad445c423be71ca6f7cb58670b4d8222ad83c479fb8664c3b62b592e95ac549f8a09a60ed3713fae28544f1da5c13a5c708d15727e97a2ebf4df3231f34d272368b5f17d315004da8f880739449acde48eb51cd4b4063e4c3f7be20e539da882fb4bed0578c382a72c35d93fe1404a544fcd1d4bd6b6e43ccaa91691baeecc974d41dc20a962506fe095f2c7a186a8e412001ea5639903dcb62d02ea5e0353692eb303fdb3cf9ced3a93cca0de9244e9b373d8aaa8549911513777c1c2b6fdec6fc5b460ddefe7efc4852cb8c994f9b321403342cc2764547ebbfc4ededa4f6396c8135fc89d354bcf433e7f644e6ab52f6eed2786757c4697d27f3d11873d84f78a194a93a9fa3b6d551a1f2ce13945f59dc11938860b84d424eb3d2b1b689a17fd3c0682a2631b68036b0427ed868f5bb263b41ed9f09981549710f86b9e3f1e850223c75c6ad1da2f5a1edfe5940556e3edad3d8e17b333dcebf6c7bb075160ab9daa9edcaca0ccb636f5af5d03a33054dbdaf1c8985b6625208c64fc2646d48b03bc651856c381cce07817e80901dadca70706a6c9fd26a6c952905e64d5705a669d876810d61741b4b907c4843cace732acd10a62802ad993e831bd890c5abbfd0a5060c928f404e435ba3d848fb5ef59eadd2d13ee3a9fc7377861577291928d7861997d0a4cb6d6f703440a872a30c7a3d00927997eca58e52da1163ee661d6bf153a912074d1849d151954b46933a8ca7caca3035f237240dc9d8646b0827e743dffb859d8f19d095c99e7c9c5a0fd51b75222dc947d8fb560ad0f5318fea578305441cef3cdda71a6f7a7e8bd5958091e528a1b627105be39d65dc200db084619833429d0e018f3d1a2cbff8041fc479b2bedbc3a6854bd4dca1a904dac32cc8b6186f555bedcf130fe111e806ee6a7016bb4442a934ab4177c91702e1f3e4327da298813fdece4ec8595e21e9b2d29ccfd6c2c73aa40155be56d36976d9a60f7d787ed7135d86c48f0a94aa967568052f1b2dd944d995280d534fdf996c0f57da0bfee49b4991e16dcccd0b4c4deafa2d3280bb68bcba851c119f63f39da2ffd86f0827d5221764007d72558afd2af77b0bb9fb296747d97c183dce0ada089a96a37a85873a4879c39f698e4ea57baac942d8d42813b19e486def363387f5e6b8ff6d67718667c6ff9b740f18ad989aa3c5fc5a39efe92dd852825d9bf36fd8a115887297e6f158e307d24fdfae38d5931cb00c7d2ea99a1f58d8a2a87708739a75a82b1e00d2893b9340b6542ce00575a92188f4a7600cb8f801f0e68b4bf73c5f13c31fe13bf4f0df3a5ad85f9372ddbf0270f3710a1b990a029ffb662acc5488b28b86c53a449574c318df5ae5d0ec3ee44dc1a515e3f91376622603df128175ae34e76a1f79a1c135a8462765f5e240616073a089995e6ee2efbbabcedc688a3ff3b3784193d9a674f7449c260077c80945569414b4a031701b27f715857327235be8ba4ebab8eafcefedccfa1dd6417902bb78d69e9181a772ebc91a53c883a7759db8c66c63209faf915d7e2f1162184cf46abb36353937dbbc39ffdff3c713c9b329c086a1f0ddc9ef549ae1acb9b6fb25171eabe175fdf4ae53fc8df790d45c071d7b9fc62915564ddb13360a081eaef3cc2d639f066e1efdc2718cbce8e4981daeaecf8e5c65763c5eec16c963ffa897049501ef4118848c4670094205e697965ae953e5b48254725ec5f030e42d682ec854715b21e3e5ee45d20ba5c23a48a45315ce9a0aef56810a678cdcc4baab9791122a9f67f69db2ca734c6ccc2ed622e4cfa83bf74ba5743f6f47c4564225d47b665f7781f942650c08a00c07546caca56502127d5422b0601e9f057be9567ea4fa8c532ce84368cdb5dfd3d709ac73b272bb2b4ea205735d9c496c4ef2c96c18e5ad0c802f3f93b99a343cd1d7a8fd95e694de0d30819648b1f9650eb353088c2a206285239016d403654b8e20757925a6c76cbd026b6e00279d2849b8e339e88a67308a4e36cd89305f7bea00d7683b61c8e848f485315b4c508aa23f25c7a4142673bc2653a97aae0de0e6bd2d26b92f1805f97399952f476acae16cda0065de8b0db588090ad6c3f2a0a28a6e0c443544cf254a687a9548dbf5de6c97f85cff6ac60d5324c876f70707e7642437fb04e680f03c789b2ad5bbae4674856b5b6cd0a19e845e3ac25fa62fbb59f8f33a9cb5acb5142f40cd0381e6672a095b6e31fbcc907fcc8a3982da9cb73c8920d142d18835701e7f088b506b0fca3c7d210d25f435bc214b808ede64b5d5d0731f7a0b8bf7e02ffa152f3c34de3b7b37d36719388b32a22436ec19174584f127149294a509449b9f143adbd87f86623b3d909e262c9cc686492e8765520c4c2ac976e5b422ee0e57457aa4245c544476647b4fffc5060c41b1362ed81b9d3e56fe66b09adc131b7c6ac3bc24abf2e8985c57dd4a67da3b50788a2161a67d7cb169ccd26808167fb28f7dde56677e4c7eebc07e7f54864c5c3ad5ce979b750e87a9f4662be17a79cf1fc9f6a12db6495fa09fa24627414a3c0fc76c128b2a47413b33ba6eaa108561e6a6eb27e043a2af31e5c98c502c3fb6b19e360869a6fc495b430befdc4775d84ffcbf00629406d72334aa1505cbfc60792e3e576f925a6a75cd5dac3940df6001f206e108082ebb05c2548760e09eff6448ee43c5a21b27b2545934b220aab41e70c35b594ff27fa9abf59c23a7b69f3fb8286d874ccff73b181764f21289413513f6c900f2870396de61518c1711283b7377e51a84bea7a7fbdf12b358ab9a85dc86c6dcfafe58f07e8de9b531e10ae253434f8a2e388fab87e6da17b7c3b2eac557196187f829b43e291c0c677d866e19bebe984ac77ea69bbf5a96610ffab68f71c21e9f060e403dab510facc634006fee045faeb6ef101a6df2606263005839b7f3a38076346acbd41120bbaac76f38cc9dff37d2e5064deb278ed00f7bd69cc885ccadf7b2e2a8cb916ccc257b89f97e76e248e94c6df37c8a31baac6ab09cb49bdd9b80d92b3e0c99d7df93ebd4ee050097371267250122fa44b3572a5036cda0a3c867e3ff002dcffdedbbeb1ae5d2d323a1620d33e6673f226a1b46648488159204007e98ee4763aeed98bf2493b68900598a813b74522c11dbc8816e9aa4ac64d9723cf0ddf18278de24e8c2f71b0c53700e7a9657617780feb9de376930a31269a90caf641d54c27e26676cb7148d5448414f692190bb02f7070c72e238910557d0468ec2a32afc51df42d03b634e93ccf8b36e4dc28b0378b42585dcaba7e6cb45f6132e282c92d65075f0a6dbc7c9b5defe74441f769167a490616fe682809230f8eb319f89946a87cc07e58699026316bed88bb01d71174a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
