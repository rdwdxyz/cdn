<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b909bbcc34f7bd9a40bde87e654b79d7266cd92a38ec2183834280d100c07be7db2954fd4ca92615e3384d3f4247cd09024c9b451ae37ad5efd315d726332ba0995afb7f82375247852d455ffc51e3fa3816f938b5482d348ab2fae6fdd823d6e1d97d240b393f123065e913b72f0c5eadc1ab0df1b4a6e421ab8ff747ff2ff04eb2cefe211b489984ffd7d619b23f5c07e4d9f1db17c52e723282ed5801ae36cc06d29ec7a2cacfbe199a6cb24ba205e13a8004af4f39c25a5ca1db03061a73c871181853eb4807a0b6bccd37e9f905be7b8a9ec976d2ed453354dcfcbf3b1077d564ecba35c4983289a81ce9028594e9002a7986144458ea70f02cd177f3aaa73132126b0d17f813e1fc838570561dbe000dd2743edd14f01c6622d1d7236752028f1c88989e83c82ef435054e36bf2b5d9232aa737e45f56e09870cce9780b7c52ff329d4faa98637079e7d8f8347271b3d8a5715b0964e9c62df11a037a333d33feb09c4d4dfc54ab46f75f40538058fb0386d75b65036bbf75a64624c19e8280408e79c3944394cc3137b0a06619247b4bbf049e4863fe670d514c7e97ee92834b28a63b570118d7981ff7d9c5d3eba0016bc8657a3fededeeb28173d711419f81042abdaba7dcf7fa80f45ce7c110dfdb03806b9bccc99af45bea8177b2382d516a4bd5d99f489458aeb04b0c4881a7d87e1aff438eeb8008135158189f4d3ec6f8791f933c078fa6065d0b0e5d5bb18ba6f15bb1b6649f48d0d52380f016129043057a697271093dfbedf6e457ba49e80c8d182be0b03eefc487596e8d44414a4a017fc8386c04a96b780e378b5facdbdf66e816de81cdf7ae41f84eadc37e445627522b2009dd6d9f4b26b55bb4c1019559d6996daae4e804fe65e370512ab30af02af003b30839d599497ee9219bac15a87146da7c8cb2ffa51b52f35b588cf514b93109a69af5e3a3a65fda37f5e227badb7d3381a187c7c28671e79659b84d3f5a4ae150152915b67c95f68bb757aa380d467886e90574da29aed74d37e1e8a68f27659e606dd8d56048b58324d1bcf8ef4fcbf057b0e50b0a970cfbaabab05377a25f21efbf913e773044b24225705804ec058726e498e248740a060392fb656b56b885439d452e523db8cb1e7888d8fe1a147c3aca1fdb436b7222aa0de21f100e93d80bc525502a62a32f42f9b7886a2b7f7185fabb6e0f8856bfe4ece38f1b4001469d8b748b08efcdce65ed0b967dc7e08bc555ae74c88d49b85ef1d6b52eb336b47ce45ad1391348426ce9147882c5eef03f8c75cadc7a8886c1a229586cc4452a1b31279ac95a5c9155bac7d3f6ec370a5eda4c1978f894b9e39548ee1d84a372c034ef84376e996b0ea95d6ef43f219cfa806c591c8acf087e7e7bc30656959ddf2c4fdda538d97c994ef3e2889cae478d1ececd21c64808af38721a3309f315ada2773c8f8e12bb745deb690b037f63759841cf0a3b1fba246640af1edf27d40c2b1c206d06aec312a8d2fea623bed3ef64b1cda035bd72f020609c282bbebe5e6c725ff7f7c1319e884f3d6e0ecd6b24e3bc0bd761e9323b08f60fba160d186558bca1970d2663595efbec5ee21180175ebfcb1c7034c448c088dcabd4fd861085dfcfbcc51100502e89249778e2d1734d02d6c9e05745154f777b8e58b7022c104c0d5457d43557602fb027c89e862528c50875f34bfc992a0d6a4c0ad3d6f81acce3634bd9894f3afebf3f2c0e8ef39c3f0bb984c246f445ae724da1ad051c5cadad7bf56662073d8ae8e852060fdbe680b3fb0af06618eef6f7ddb57b4728a86d8983d871e95a7278b8bc089681e94339c11eb3e3f687f616c75f9fca8e5590900d92f0ddc1845a245f4bb5608249066cae42fd3b3e8909d1559839bc4e62f3e11575a656c232bac4ecac8e1d3ed53fa6a7440ee77544b15c1e3e7af3f07c39a014b053e1cb95806d35d1b384bcf56ec666d37e5927531973a451f622a2d7b7a8621b826e5d231c4288f8ccee725b357071ec26746d7136f17bfca28759990974d7ff31638633b19ee88d3c7aaeb27f01f748cb138b93f41acdba019c47cc26d0fe816c3b29dcdb2d4743ccff6a1f14511ad3a0df177142e6ca29a5e2fc1105b42481590dd82e19e8dcc967ced87bb7222db11a26cdcd104d1cb9cea203818a4890a8dc86a4938de2987aa69dae7569da8eedb4a1f573012904fc79357007bb293461363eca34264273300369a5f9dfbd25b6dd5e0aa9699b61fbceacbd4f25b1f6283317a18723596dafded0e943db2737f8d4113380d9b7d12d5232a3fd68a6331f160cd7340a4be76cefb93f4bbccd6018214db15eb0db04619b29b4ef7b54804f10e27e5825702109c164db39e3a4f9f070c2d8ac3f912943d51de54d8e925937a91b294e67606791f7da71ae0d6f14cef011cb564d6d66e0e1a6e1a79035377866839070a43727e5c50e4299526aca6b8069d55ee0700d41dc206f3cfef2ec7612301bbde615e310ca5485c4e13cbbdb93221a2550236a470d7fc25a95d15ee05aec0671d94958e6887df4a7bd046d3d17b8ef142f908c7aec85ad42be14b91fc4d12247d6e72ae6fadc395620b86f1d75579521c64c7b28b368df0dc5852d22634fdf9ae9dfa4bbe3163a95b79c66b5054171514d089d4a86d53efc77f8bd4cbd8aebfba6d8272c91b99ff5093bb66082a776866ae32c941c0d8935119e94a4a552009188327855760c76eb0a34f58cf415f97d8fc2e035e3697eb33c47efbc2cec8d9b03faed3e9d5d1355b4c12bd699f4b6a91b9be464ccb30d52ae842a239ff62d317fc66c2931ca987fd8bc2dbd22beb6fb5ea6015e1044338657cedacb1712e87ea5ef57a49ae50ac1f4e89eb7fd540ba8f6cf55e92d58677323bba8b49addee83fddfa8c11738f65da6372594b4d9469d41380c98dab7f101b2b9a46e50f750bab1119a00d4d0e302e3b81f2e9867646062f0ae02e0cc6986ae55d6ac4b3293e205844922dc2d827f62862bb4ad40e12e67973d67eafdff8b20ff8054a8e3206ef46835631a0204cb315b1f5bbaeb78b646289c180d40ffd9fe43dbef1cf87aef64551bc696c2ffd2ee619afbef67b6770f683e093733c54b879c3473483ae83e0dad7f32f49e33f2917f6b54ba159c56065e6ee4ada97d2af44e22e1f74bc2df7485df3ac61df3c2671f3085319e24b1967ae716c47e3cf3d39eac4273fed0baf7f4c48822aa84b1c74f810d90dfdaf32f9dde6c2396b4ea732129cbfad42402a271a20a58006f4f3e7d64c800fcdfe17bb2cbadd3d64273d15217387af6ee95d4ee4d994fbfc8645e54e11ada33c7c7f09bbd5c972d348eb9c6aeab2e855fde8262df0f25fce935c44d2722f48dd0e1e1e9da49c43676e38106db38e4ab9992d60c9c2981be6654f23b5b79ba24695f8d1b5888b6b3e9a13ab1e36ec89a3366102c180429933e6ce00de639f4932c39e6b92ebb2a0d3118f46bc9304ee421bf89766075d76da97266d051279f68641b61fa36060b1f797740215599bca9483143a54735ad3139709a74f8ece3884a101495742f3b3114569bbe4d9268bb6da549a676b2f5fa0dcae15881c4cc5b4a07c5fc6030c60f4351076c5bd4427f49f795fcdc6d4803d61c68b888312a7afc654cd87ba9c6a17ef798c00e4c269e247cd79d37ac7e6784f2b8e869c5457cea5c0dfcaa7bd49d49e4f5360f246954981a9069dce6585c49238545c889ae0579ec2a11c18cc3ddcf56f7ece599754d9ca1c169be6aebda638eec5b62d1bbc5d3d649fe217c561122bf0928c6ad4fb781bc1a895d70e85cfbd595806ec5cdaa01d4d834b7ab236510b13fa2920c6aa4d3ae9a433314c9b6b2ec0537d2f69867702e669b3b0465d9b0f9df9981066b36988ab3e06621ef86fe9748573ea67f9e51f2595fe0a1802c255e1ec23e8308b06f9b6cf74e1ceaae1f79486bf4e0c298d18f3e25606c8c248c7dffb609bad38430c603e976f24dbe1a01975cf4751c56e1ebaef530ed596783c5477372a09e252ca2fa1e9da604e4058b421362ad53789590b6929b2e8cdff3371abffe0609e48797c1da33c21550f89885ed62458a6dae6a755bf9a609d0b705ebd88de3193092681b9931d4fdf0f90706e6bab99827d5563660c102c259c68938bf1b70e5ecd317067fd50ae013151c3d22579ce755185c0b6e2baa759644cf8dc0294b41d44e0bf7e4356200ac0552ceb5653f5cfa4cd094bea9ed152607f7c8a3a37efe45469cc6f146603314a3ffbc93ed34784a165786c76602f4d997b37219aac6fd38d5f227a8a2ef20b232700cd84860e19bc2651160c9df5c475c83b5daa5f35454eccad70ac635781ec4c4e88394194dccf9ca5d6b5eed6e1853f7c3d562fdc2473b8ada1735b74a0e97331b5697803e542da9826509112a40f37357fcdefddccd6326a2c4a9710c08e39a34306d4f6c1c07bc860fc9f81f71d31a1ca00e97d286ad8de9f3b84dc55fc0731e55ef9ccab02f312f543d6e89578e48226f20a4e2deef9693ccee9e93d5385f5636be360cb6221b212eb25b793abb4455d3f0b75d7dcea9a0dd8976ddd1a7e9c71c1b445ed508903e9134be30db52ec00fad541f55fbf321da66c0b7c220dccc8beda0ec740f94fafe1942ba09852822d332a53928c54ffe3291a8e2106e4f566825b772a484cb094c5af727e5c7b8ce3d1108f304146a18ef67555b14bd67977e5a481fba04ffe136ee4fa2b5901e86169052ad9f0442f080b8220e27ccea1c803f0928f8ab1adb09a012c8af9798fbec99746badad4e0ab025c65b7fe4ac3692882320bd5a39eb9adebeb445e84d1939a317ca21827d3b5a0e1485ae053285d6eff8fadc0eca39fafaf3cd855676960d2581b1621403cda9bb3685bfcb44983ca3823d2f2e3cce8d80f9da6df7e1f92908103cf332032eb38c05e9ac1ad3d7d97ff036770ddb2ab2e194d24eaa0799d42798ed597d00530b413c44fae4f8b108ad461988892af0bdb29ed402593b490d1133078956fc729d3bd1b6e5b4f40564e987b59e9a714020a6b689b2a001443d8dfe7d1caae287e436d7db5503fbd748aee4065996ac5e45edf1c40fb6d3b707105d5ac6a07f45a3ff97c67345a8478e187887efab346ee01daf061672854cc73d958046f6a95ea205f0e96d34f454ad30162f8a394d1e6a527e4ea8c0a8c86f693d8673bd5ab6a1117870d1a844919fcca10cb61b166eb875b429e4dd1eb1dc6b825ed7c5fbade8e043520ecfe52dfb3302af16fea78b8152a176bd1d11f8b6cd088e9500bec7fbdc774c7d77b7c4985d12039d8dea9a50de0c05d2a0d0252ef969c8f034fe20ce0e747e70eb4412bc5549fa8cdf4babc86b27f39b160b9cc5fc414d5b277bad0f76e3af21fd40af541c886d0e33ecd00e1d990394d0ad4c6e429855c96acc2d6c4fe025c28416332e4e95f77d59fb33a36bf5b9115f6e33fa5b1e5094df471635ee6101d04e2f3f934d70270114958b6e4c81fc09ac6ebb1d7dc7e941a26c768c8b36ad3c57d12585f93b2af6688e85883ab378fc9e85809338bb06ef91af5ea7b88ed3275b38994a7217aad2f46ae66c97475db72de99311e065dfe75cde1d442c5776d115ccab659bb0b284a10825b28008d0a495c08b55e7836ecdfebfe3cb317e6054e97de4fda659ce145387b9db9916ba7bd335f1f69af86e1a2147bae5f39654afa2969014e717d078e6ada5baf784903dba14c818f03bff4c2b33f714fd12a152952cef425f8367a8440c9bb0dd58f36e03090596df67cb82ed025479f86e0333ee1822aebd09e676918a8744e897fb0e5785cccd2cc21807172a12e7cd3c2a74679ce686b9419d1d724878af239c0bb2fefec0252fe74d24cb3dfde3378cf4fe9674976f0357e022eb1693e771d6a28ce8e1377383d363014202fda483cc8dad4d01472dde0257d511d3ec16fb9b1683e5b5cbc579854f0810a29d678c758c7cf6c9b3aa9b1c448245fdecee5a454c852974dcc4702ba0b26c599c0e02b6eaf7d57c2359abff116671b25edd32475bcddbd01d7f3a06a5b8c08a29672148d4473250639b27b3e26b150f4784104647c0782b0a8b3bf5b3a6d5f71c895a3d1749ff5ec401add9054e0a82bc7fd09fb66b6a9569d386ba319d70362ff7fc9ffd30522f8f84c73646f884b0c31fca1fd37ad1f0062e88e9be9f4a4fed879670ab2e3b22f3870b3847b2e40d423c0c3ceae7a42a649af3986eaf9b1f42ea8cf67e37f2934a1b2269a687622571e0cd0b1661959de6e253abff98756ea48abee279e9090bcde955a26a42eb6c593a7138730407235e3ab8391757d17f8001bf1777a8565e1a4a388b454e5d3158d2b5845152e5b311f903fe259810c58bfbf1eda21238dd745f5b0aeb2314bad5d0d3b35fa5688280a0795c62e91876e2bc0b8f521b1f331384af60f7cfaee481008bb52c88cdb04a8f0eeaf61f1fcf1ab1d87da563431d7b4262c8224f97f116025c0771b0d24282bbf4800d09097bc1e1a0db2990eba998a76d5e25f44f8e0b364af97159eccd793985f520f8b4ad86cc15cc58bc0265b61fd9912eb4e30b0c17d3d68d033070bc5be4964d49cc8707e98b3bc80d0ced656f55609c709467edb3b4ce75e4122d531b138380d81261c2b791a42e57ff055768e2d41efaa6036bae9a864a88308e38781d9a7495523708be46911aaf47377970a85c01a7099e470b117e520688cb3832ee8fd9ed12e054a910bfa1974d156e2f97a1b1fd773d6bb5c97463b29b0549d78874f36488eb6626d4f0a59be8e824eda187eb64f96c3b32c9cb31a82ff5525c75d537060b1362c7732dc7584ab65e8d9a05ab1b2e1b77eff3ea42e928f704962e8e547c55060c11f53c21351eb20fd485781b418c5c77ef45d7e76556ee0011e5a1e00641766a370a79f82a042bbd84ac00968c637a634108a491ad37cfc4800e1f526f2817ba0b80c3b43a756d7f8b5b1cde36c912f829ba7940fd25dade46d9b913f872cbe48c82f78a083cfcd26a4156aeab720d6863359bb1e9477139f07cd7d034e8c60863d99baeb3c91a54dde06fff7000198fc09c47b2f48f0e21f8d8fc92e368ca46ac207533ad1acc0ea8c75592e9cb49e321668ac83345398b31a181fd270458aa32d0cb2cfee6f9642b5253e9cfe1f0da9c94ff680681f90cb2d1f3e3f8722fa3187c3dcf9008e28fb20dd7790dbe1fe144268251d4eab29f3eb23d41a64315696ce2f0bee3e234f6edee8e677b01fd9b671457800799c79517ea26fa4f848038158dda32cbd159401548f28ef78cd30281ec95c591382ab905f9af860f30dc77280277712aeb559546aaa592955553bca1c8b7a7f90624241d3a8f5c5ba090e54721e67e941d775f0426dfe5a5803bf7a16fc6ebd312585eec9cab6fbdd0bfa30f7c0abd8cca9a350eb5fcf91fd2efb08e22bef60bf4b6b04cec08c0632e4d91b44a7adf6b8bde82b7277e08b9227c2c76e6c164e39e7f713abeab31be4448607d8ed6388927965e7bc19e19d668b9f571701e04de09b8632eb780253183264375de20e5526fb278a8debe7ae8199ee65409a3993ec85d24fc04606bafcdf4e21288ff915aa2f2bd7627427aed78940f6ec669eb305f3abe497714d86f389fbea42445bc585e8bce71bba4a258234b4f78f9f732b276c2f7433f0d1686eef36199f3e706d621c575044c448d3d990aab6229147ccf7c2d4c6842cc095498c0802d649ac399a05e296deab1449bc6b5791952b0b3ec88fd37a48f126598456b750648a859ff3b8be0e81b6e5cf51fe25b23e2d1dd7cca4fba78ccbdf94eaacb16a0488f147f67ddc8ed9fd99015d8bf6717c6fa9b371ba982c8ed1d059a614fe6f9ae1e300274a288a6d7e06caaca81c996999ccdb7872b4ccc5d52923fd6d1cfd0d535a3a02e00a18a6965dcc99c1202513e7b1ed39cdb72a365f65191fb7649881e56960cc49f89eba4553e1bb7f35fec5161527f70e867e61bd9c82fbb2b4edb93edf794b3ca4bc57faa678141fa512921a3646f019f987ad7a960ed2706da131ced5f0cfbeecb7c79833ce6524500d25a1a8522c7d9e969f35025a7ce50faa0656e717721a17058034563deaa0b85ebfb13348f5b9239e1c98bf903f150881c656d08a512326ed6d9ab8880016b582825cd391cf6220cd6135158c2e626a033989cfcc61e3c958e2c532ad74ada8eeb1690c0593364074ed0f77313b13aebfc959bcfd713dd4ffb9254bb6b8dfd7e4894345dd2dd65186afa8dccbcf673030121e6111e4550c69da8b8fd386f5224fb015f8d48ee7369d925b88383c083781cd882628b53cfc80ab8f47f49475deadbf101ce5067f24682867d3df5860606a3289e30236009ca9c0bc7cd88c982be9f6734f480c5f62afc56d27123f989aab36c57c6296767801656857abe8a70e1ef77a3795bc8db67690157b0611791a236f6868969229dcee5e55bc75a63738044e32c1af50a62ff6aca04e405f23d8454ca338c0e0246bf68bdfd14b4dcc7dac7c19246b0d5350b0bbca4b7e2937c4427a4fae1c89969318f7c516c86570be8e11a002efc9ba9cb200c7e150e93577cc4e143116a8c130621f1402f2ae2ba31225c3364d017a073246df7221f3beb967938ca57521576b6b45b5d19e32981e7336a4612991edec18acc854081944f428e6175e345d884727f7c4d98e2cca77692e7ee7cad12d0bdd31150bd02396e8d0556ad12741ec9b11a5e2af92c480e3225c0b5e021cfb0d9f1abd6bbcf680a18567cc5b0c3108b9192cff81059be9a3e4efff9cc2c00b7f89b96089426d97358cd1d34c910fd0618fc78ccedce2766ab318d313297e7d223db52b4c546d1996f8882cca243bcf78a6f538fbd0b63c6bb7308ec6e6590410085ec28427dde92e51b270a60d1593563bae44301523da92227e18714960a0dbf764780a24d7dfcc7ffcf69ea011bbd740a978c3e4b53a7738c05604ccb74c300da0a62e1aab00c09e7c88a755aa7c01caa4866977fbbd056dfeecfb6fcf361fff4f72574cc2b08ff659e83c1df2dacc25296aa393f3363360af74158365a7441fc54abc8acf804527e66e236959168f2986ade18626cfa1bd246dc44409ae92b099f8f6def3f08c486179a57444dded41c777a339bd7c7a4f1facb52c879ff9c39b11f67c2f75f4f822743ae70301c54409d57f96e2d8986d95d12d6b52455ff833e86ba3dd36e7bb1f84b8bc33ede7ea0ca57df2c16dbc5505b58c3ef722313962ab4177e3699d83aa96900abb576cdb7366c3d00fb66beb26163b68bf51552fd6de4163719b0d3e8f0e1546783499ea40593591de60959caa3d50b9eeaf40e115a10842e0f3852e51b241fd64df9bb6876d1080013ee9084424e336926bf7d218d8f4318e040c34c9209aad96189f020adbcdb5db63cd745fdaee4907f712d7862a995ebaed6f1431811c78613b5af21d328cf05d0af19d20b7ce494bf4ae93cf6a455a869ec8449f0da11116d5520677d1d80367f411d3202c8cc03df2f5f2825954c7718cbdef9ad4702e92f8b6eee2e8e0a1ea4b7c09d7ed6755e0540acc6a3ca48a6b58567c710bf9cfbb3b04511cd60941c12c0c3e5a1240989297ccad960ba988374c01a015b26a9fa0ddee73cbfc73aadad47b0709a130f2b15cb4ee1dc07cec8f87f4cdd3e053092d5e14712fd6c36ec9714f697f017e854444cff1d2b9b1300ea8626c1b7a87602d615cb81582b1c430ce71a6d494140880f08259aac9c1a19c8ef95adbd3007dfa64a88a30b131b7dc331c8bcf0b247aa9fce204ec46026fc98db2dd3a15a9eae2c5a7893c52ddda7c8f0059a02d25f0c541e763d0e24a8a0f18b104ef4ad3599e07bc171c46a0b0e573b4efdcd72bc8c77551e69a50cb47d2a656782d06e77803543ed6f84430a7679f23f91a642c6011c757d2ba7827a9a0e7a9498a57174d3d35ddc1d973cb1957a712ad5a4bd314b86f1cda6b948fb15fbb17cdca859fb454b4ec4ffec4ba6bf749be15672bdca0467bcc0e49f7d46467629993fc015af8071ca8be4a3e1da40e60ca063120e0f7d16178b981150755500a358595f7a76f035c2c44ff1614d87cd018c9c6e6ecdc01f46d757a0252c5a123c3e20838eb5b3c6378e2cdb99877d1902a91f2444fdd21031bb761e442c23c6cf90da210711fcccea6ebe9d4d36116db165fa9b51cd20a2c09ceaa11740ff2b2b8d2f3278509f9bf67ec67c31931913aa5e22ebfb71d6fd11ad6562ce279367c021fe7195e7e17a8fe5c1af3a0c907102072fd73e28e5ae900c0b9175b949e4b97377f557e11a3723568c858cc5e94af4f8480e1bad331efc6c2b4a635c4cb732fde36c4d4f8db1b1eaa72c6b0f4d5980b4229f0b7550936743f3a15cbfedc1f49d47521ca8d410c96ce5a5ad210abb50e9bf6c5d2e54e6ec614509700e0e1f88a838e8afc0388cc7325443ed2413a5198e25d4fc6b412a57c3569014e81f77b5c6629a0e9a830b1ba56c4318dc2b05a3a7d62f479a285e2456cad448e2bc8effb39024590256606748cdab0c6d2ee54c579c4bf4c8a6f16996e8e520b454d1edee6dfd9f1495315dc78d3b04cb0dad4a1729918ec72f9c4d9ea32d78a62e66925b6691d6694551c7e47baa113510ac516fe0dd6fb4dc2d4e53302d650254f7c295c8655561d0e17ee489cbe4d1263c4a1430c0d5c4125574e8f9f66e1522b2d10de992df448f06cae33b4fc89b4f4f488ba29bb4e3b9fc63b355311a8e47253677de4c8ce63cc98a984029748e30ea8b44998b8117f052c884154203ddc6bd828be638ca403bd9904804a7b99ec5ee971e8126fcef392b7ae10ec278e8b69a0fb59ddb1e9797af4bc565f67f920bba53154dd580cf56481f87a5c1dda6f1f71fadccc765ed31701f51ffc933d21bc0da240a9c224187489b27560b905eefd7e0c6f53d6eaba13abcc4546f9e6c0f0486bc6129bc04bea749afe5a129b54f430947ac90a454d22806ac7dcb1f4150353e67df4242b2c3b20e406f923ab41423024b943ff9bfa811f38cf56ba82ea8822aa8b266e4d989ab58b042220beae02c5c21425be0d1c8f771cbc49dfee4beea800ed57da0af93e4233334f35ce08e6c8e9a1bb2e9a2015160983bdd6eed18bb095fa8ab1e802dbf47fab67485bfee08f94586e0d9241fe1f73714e21ab5624e87fecb693eb3ccddcc01581f66c8a463ea604c28e9623df241ae2b3bd0367abe156970e446d6e7f928a665c9a5a051deaa6ae2ff7d503f815d62a8d672bb3d3cbc3a9645e2fd6bfc6b17fe490cfa63f1047ca29a9f9a2a0bec4dea349fddfdae9f84e6aba61fd69b399a06a815bd6dc7cb35dc7597ca82bdf55d40eec74b0a95e41a3136a110e96df201df61c682935c3efc504902d2c857e432175850ad0a1d32590fa4afd35718c7948aebffcf6fd77e902c524b02f1c3987304d10660ce21728942da123ab41124d8829ac0c2be7c09cb59f2314805874397af8c616b03b9bfca4b7b98c283d995ceb52b5153d026ad73423af2a518eaa88ffb32c39d4951192ce3ea7a419167180ccc6f4fa276a15a02c5a3b6a027aa7057c0afd176a5643ce58ef4cea8e4f8ba22924005f7dfbc4314f900b0e6ba11436ec8bed0dcc071b6f238f0b68ca64580e776da048be8643765408d6a3e152e9b6d72200d1f5d6ddf1f34b0317015e7ba843869e9fb195db2816f39ca255206a6c21e02ae97c05c8751c5adc1f8cc0d4feab7b8daf05adf2b09790044e01ac735bd23587ddc09184d6eca8f15b236beaa2513c504d1a98ae84362675594b81469328e92ffaf2d2dabc861408c71ee0242eafe8ae42ba53da9cf872d53de9ca34d89439d0c3feec955b354368652f849d4637de2484d4d49e0bee013404dea2163a25927f4f6b2666fb31fd7a4c4c4d99812496d1a730e6c8df355d33b54b88b65dd748cbf69eacaca3e0bb32752b58acee83aacaa1f341a0ba94b26299edecf52546e1aee18e4e2e6f2332ce0de61ac45db1e32a48ea176bce6d9a54383c10eecc3cc379896d273921ed490dc8a1975543ba799bfee49c0ae77b88b57847cd400764a9678df73df4e4efb64aa2b9e906aa263bf9f520ce716411664ddcf35fc31f12418a5fe4b3b7f42877711e833e0b94f585c8b5c8a832f0ffd0268ab08f1ffe6de1e9433d33f729c2e6f9af2841bf1d8d34fcd7e9c2d5bc49e6915e8db426105b805f2100c0f8234eac5ed7c50136bb271198f7a7d67d17519ef0693cb1ba4a539057dc8738fbc4a94718e7a8933da453314d27c678bf33c87c84e043f3433e192dd8310b5e0a1c27d76dd8c09c5db9911c093434abdff90824e3abad8a198f4216a65deb2025f895f23db7059a87fbbc20c97f31af7b546ad4e15db9b812dd3b0be94e8019a6825d771ad281bbada85beeeb210005d6de0b8ba31f2cf5785a18f591a5d98e30d1c175688e5ed1191ac57092975345dfe4bde8fbc44aa907d5fb55546991966c6364c0af342eaa2c98bb7dc6ffef851e6a373fb136a9cfc2c57f184d471cc1029af653d379223ccf49378ded0dd89214441556433796ce883f27ca87ea57280d1fe5fc71448f8354f562cbe1854e5ed462ca3bf9ac52fde08aa5e9c9baec8b790e3c4e7fbf416c4e747f248cb232eb71bdeb148373f0ad588ccde5b049cc51f2120edee77fbcadaef72311fd45acb3cdcbcbb87d1aa30bf265d5699108019ee108ff7461e219b75fd848004338cf1e1334fe7ca434e3ae567359e34c5669a7b202d8e496d4579b6a5b95adf1f096b59e57cd03cf394dd0ba6015a906c87da8ac457ed0a6fcb9b3ff65e08188a8e225c183b40f4c095b28837c98f2bbba97e823ce0681397e8e84e4851abb53c0a5796436939079e810367a0873fb581cb8c3738df8c0a4c44ba2bd139600618259ded5abd4210f11aae9190a8d0d7856502367db42adddb63913483cfb7cdc1af2f8d7db7605a91aa62c85a8c9541ba88817e0e9433f0db0771e6ee3c9abbd9674e506eaf42e59b32ec6b5386c8141b5c0ed15b0197b74134dc2a4493c41e5ed88d5003e9264372ed553bf597e4d0c6e4d949cc63e3a39c4cd4431b3262a2efca1cb5f407cb46386a77aa1965f8c701db83624ac80a76f5287da445c49e0d7b6a0304076413215f79d885c27a8e8e503ef232ad548e8bcc59367d594574ec2521bbb4940aefb5fe4f77d9316a86496cfd4a1241ce39ca2c175fc723912f0c7d28253d4437bbdca13521f71495f43188fd8a6f760529064ae98752c713eab3420b06aa55196773e55b080c132907f4fcb9828f6684f8872fd8406d8ab3be3f46e2ccabf7fc8de2a91260de7fb8cd7d8afeb4c85ca357c4c7903bb2e41b49f707f83c5b5433a115485186377890915615de63dd2de8ef7ced6e571a9fa51b01f9a44c17eac42067050b3809606a430cd3ff526c87187b37ba5ee61041abe3fbd85da616c06ae815b73fcdc1f20d451ac0019f77071d6180f7f5f8f1e4ad9fce52c75ae8906670fc4319a847c03119bc5e799423ea07826075968dd92997c61573c819672b4c3b3a7b8fa8b6f0f04d4287ab8c7fdf0b924ef3b78838c4e05cd5ed672b16f40cb20688de3d343c165b0d8fca0aa5c895539895500caa8be3fb635177a1d346e925be144eef771742d329c0a0285d23b962eb12c77e532c6ccf86d86f99c1346a889df66aff2024c817d1defca510ace3ad1923f8d4828428566b068cc8286fdf6fa103035fe20fdeca81f9ffde49dcf374ccdb2e4e5caf6c26a266efb81bf37e38f64ecac1558b741b5c4fbc115dbc4d389df07eb251b60a172aa25e136b33035e7cf84c84d77078d6c6c6bc61cabcbd70014c1568423c4332498542307a29cab51a51af482c09191c4cc24a7db9a8c4469359fedcd43fbbd816d4fce145136121a9c7257f33416cfcbee4ce96f2967f8a85dfe6e1f0697bbe3d6fc95d00075657acb7dc4c94f2774f72b6ef917e2426e156be852df76cc2b8c4c1e5314e68fea23e803f62f015fd7f14c30797bdf7ca533e63b31737098cfd165d8ffcc53ca27505bed185ab1699cb3760214a73b906bac28ffa7e8656001e86cd000bfdcf11565f9ad95d4204b63940f47294ddec814e4c5226fbeaa7069f03be35412fe95f01ecb2ff9ee76808edbabbf3bb642d1ddff082bbdcff6d1b2a78231fd12b268dbacf0c4e16587097a000edf7c4c6225019dc74aa526cb76ad12961f388dcb437935716fa46c9e9e78b33d7fada1681b896cf8d12561b03d6733fff3f0ef5a1c05501469417d429112bb83dfe99c963d1259eae7c6c56140a84ba27bc9b60d170a30148bd17b46c63e3d88b3f615d742bdd6bf4f9c1b8b7cffbd1e3b3a6ffa9f3a4b081398f3fab4e9aa475bbf762a6ec00a6d8817c055ec9d2959ff1c43ffa29bc148a1a4c2fd8bf103e61a0ea97c1cd9ca2f65d2b2520d5beebedb186ed6e5a9d6aba9b146e1232f64cf02decc2ce0c2b1f03b458d17afd789d6f9035920cd1ca283af8290219191a919c41fa74d8062ff32414636b47eb0936d226478d4d80296b7e6e9b66e6991e11df436867966f40eb74d97725b14fe601cb4f4a312f18936871a25990de5f4b0f450aec91e248a8021e0a1f44c16b0f305791f35aeaf2d15c58fa7d1076c1ca5d70dca8d87a99cd929c3628c86435aa76a8dc4f34cca2dc4f3f60db0efb48cf356b62cccc85a24716e040893a8521286f609e6609f207bd7244e6395c7786d6939f65b43b46c9f525ab5b95362a368a5249dab6842dd686b0f29174ba7b26a4ee8ba65f05f7fa8c6c26f76136a0c1350ab75cb718aae22a2e34a7f140ef90ec96c89a566b35b13954129c8ade48a3ee287ad75875884c239a9a49aab991efb23f7f2c40ccb25a787c34c4cd1d9b6aa050c73fb9c4706d3c918f9b5e5a1de5a23b306f1da98ca6a364cd69f678c63e25d2abf74b5532ad6b2c2bae32744bff4f5c541ed3f08fd37d868fd5ec8356b8eefcc95ef84804c710bea18566593d8fd802ed5a41e3643eb2333986fc0ec26d8a2f80e0c3e3cebf664279bc0d899bf03b0bf40039427e3a91c40dce5e0e2eb09fae77ecdfcf187b65519a0d9084f1dd92f3a6dc68ba334e128ca1e06dcf9d98569f151e573df2659f12de9780a6475fad17689b61d4615fd6f21395239c56d4f9179fb73e18246950b946d98819d2d317c85c872715f2edd3d762d322fafe57d2520228382dd0c144db9eef9f96c4039264d1ba4c70ead024d95c73d05e294f20896ef7e5bc416f71d975ac8f60f4693737e501fe5bd44725cf7d8242496f69751ffc24afe51ea4d794ecb981ef1d8f2b1aa20e78354bd9dee403fa773cc81d264362e7bc7d513eabc0ead5757b86c9706c23295a9f5ff1e14a249996eb8f9ab79045695c4ba7ec746d348b38779f477bf844b5546440722928b342beb7ba43986e66d22981f5e4191515d0d7a5da2800b422834d9e3f5e3c7bf8f800ee2efd95c04e6f19c98a440e741fb9e4d986c204763e9f43901fdd70262b5ea560100218e13ca46774329dfea9938ed0e32749ef5dc3fd438f1dca7db4729b320edbda5a137d32339e2b90843eee2b666140588694e31c6d1adf8fc1f142deef6cdaa67b0a5bc6a0ec7724179d67ecce08de7e6033bb5eff013e94fe37c9df2449a4c0bcad9ac3eb2d5025873446431bd4f28a110e3956a820acf5107fea66a112067e41d56a52df77d322b8422b9afccf5955b2af8d54a62f5786d8cfdfb2a684a21fbff7df0c56c378c6098964121aa1cb60b23b06cd0ec2aac71b3fb6501e2f12a6d29066f56bac4503bea0298797f4d7b59ce9c20ab3888c51e536fa9abb35b7683a5249b2853982700b925117eac5421cad55b8774f34e8d73ddf546214716c6cef039fa1da07c5c2547359c2e27022f8c21c5713865bbd7ea16a1e13a1c77f29fe674c8e521c4356a348a71b5fe2c4f9bbeba21c12d84eb4149c12eea3702bf5488b6208e53c0025d57cbff7c2ae693391cf00498f6e3395f1efbc84554f1844b0c5d4ff7ce36deaba9120877c577fac1c45fa5610310df14e12842df96d513f40876911d73d400994bb6a50138d9de1fd3c379986bb4b722e76d9587cc80060776cb6b874af291d60a3b84e4aa0ee4a9c4b51a972282018450efb7ecf48d093e471807388de3c2c05da9fb29a7b9b67685c197705c56a3f54f717c4441a1a2ca01c43c9d9222864df47141398503bd0c245269b51f6bcf02d014894d0d65c5547e015deee1587ad08d552c636a720579af9a528fd0209495e0af891e43cd8f4ae44e63b960b55113282cc2db59497ed94c7dcda637fa6374ed2ac86a79a688941d066b9f4f7aab198a22a1be18a75770fb16f9d1fdb7df93b2c64c31e4e6ec4311811020f8009eeb29918f3c73fd6ed8c0577f6e62d36ec9b0bfa512d046ee02f07dd8d45638182e2b7d707d42b2fd4ca9410793e701ec16bdeb8aa84dd18e075e67d7cfe40123b5775e12b5fdd3fafd2ef3ba66972e72dcfa76cadeb66655be78b896bd75bba352ad59d09911cfd38ee1d57e904cac57687bab922c440d668f4d6f417a83b90e6209463cbada2e46087a1cd5246ea65db21cfd766a1c0de8b70fa7dd22b52169c3f1fe5afe4bb21adc60f4a96344c1e191fa45f37c6de149fbf85b309bfd0fdccc9e15aafc0b32dda5e9ecde3d90212075e02f0d25a804e9db9cf06850eb65461db5cfddcce1170518379c35d5489b580b7eb8e35d37456d3b33dbf7c7b1e3321c23d5c86f92a8434bb66cea67ce4d3532cf86255b095d3918b1fd867893202f50c7601bb587d783197a38905a8957364807d8ef1f90b91ad3cb9930eb97665f40acfd5373ac7336841ff1274f9f4b69adf5e76bb2f9349610af63227d7b58c5d22929e0624b06cfc9709cced309c62f126f019749169f52235ead85c826edc09e6f17904ccdda51cff754c4c4d4558d9fe6d749fa04d9b487f3b4fc37eed9b6751c37d677916c3120c1484913398eda57c7798e2e6eeba1abb3bf9e2bcaa1261d54cc37b7bdb3a60c37c3ad31bfd9331fa7290302162401493524245e0c0374bf1a6449b766ca4c4c2ddd8c81b35650aed1a8577ffb2fe4de73705bf436f672c338010d23c44325496f57103649a6944804a3fade1be683f936dc319c8c79b8f9d25384a6453a02e33b3f5eb68659caa6891ca6d64d574a6393e79dcda021496cca1f9ec37c9432dbea51c091b1552426a7e518507bacfd8e0e2f6602f3ab9f2a7ca9076aaea6d824591d4150c9e8cbcd6d92524e74e7b4d53b762ffae1af339379f04ab28cf58b59c32b0f23aafd331d756ff3fc41aae000931339dbb0131f598586c224703e5947e7029c2d4c05468aeefa306981bbdde166803860f409c1dc5045d3752b6c93d44eec4a6bda10c67bf0bdbc81573f5bc583a8ff3807eda0514c78e028d16ddc43afe44ea4e52be77ff0605ed5d795f5481cd363020f4568bd627cc4653a2d88b72e331dda6681755e94bea06c49f87cdf92a5064ae2320f748b4951d9bfc5f99dfcfdba0441f8dee69efcdc978fad04dfb83bd04f4aaf0fa9ae5b4e72fe715677817489a07dfb3eda705e588b058bb6c6b44cce9e4b89d4b247106d2ae1e1e5fef91469ce94850c804df326d6b71d459768f1487c5b1259e94942ed009d6d5758dff236cc3799827d624a831b5ab08bf354589cff9c7b04b3cf20197052b7d22ba91d9a6b098231c3fd40a54d8201c2ba409b61720f72a11f36448e53503a9fdcf37fa01ddabc89fe9a068b8e9d4139de320cbf2a37cb32f5a2c4dbf267f43ac6e06339a4a4631e137b0ae757102f294691d503885f631ee74640a197bf47343964aa6b175ac679f92054605e0354af71d2d3cd685ce4c73ebf27c4ad89874ab5f106cd5de4f58935721edd797a856e6817effc28f2cf7479723a0aef448cf9f3edc251ca8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
