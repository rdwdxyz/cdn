<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82d163b4b299639f2d31eeed26333091a24bf2df402bc8150a65afb9b740e86412eeb088695d950a95eb907f73bed2dc0a4bf90a522372e9eee71c24c4f64361f921556dacfcaa468e136afbbc4955ea70a66527271c0a0c0d2eca995622bcf47c3eb698d0b42f73be6e22e837f30ab4854b5236f6fb8b4b4ea7c961b2b96899b5beaefa5f732567f98ac176ad642d44f94cb7f3a7f259b19e4cc867e78a04c8f01697b841b55f29952e5b8a091da0439e144650f6669caeff4e718a372a7a7ac12227fa308059b3efbd2ff03de9a9379bd177399f52e3e8829d342dd6eef84f9c86c18f9ed383ba4cc5b4e64288e50fcc7d0cf03fc47bc688835ce332c96545ad33240c03a048c810d22b0f98dbb04ab0e988f54655d91d982edeba6cbe19b95ab02786db86fdae1fd144b7c63299818ae1e3138628962fa3bc8c33b10624eb95e72784a6ac5a2cecae45b4dbdb97e3677fc0cfca5a40f44691e08c8df6aa601c34dd35372d435120ec2648c20eb6882ce5b76fb5af14e08684fca54c5e0d666ee822d61be698536bcd300fcc536ef067c487a66561e546cc0c2bdd7ee65578d6e98ad3e03f4185a91555a6ec700a3125c69398b81e47e94dce85e3c1e8179f840248aed34828ac253cd84bc84f27ec7eb8bfeb1bf62b0e62360ad853dddca0800343bcc382b3527af4d4cb0448e155a9c22298603068a6aea026f965982dd7c53cc7ccd5a3ed6e1038e36e938ea65e63939df6f625df44071501bbc18947bb709277a90f8e12754f7460b1e4a4546a295678e22563ff3d7439adcb1c7c0e49ba51671fba497f626e93b7c69a8f1633283c36811e4708f7aaa005f364a6b752e19b7510c8db694a58dc3e874de6b81c55a771e2564bb2af360a63d80c93b14f1db2f4bad08f4f9706af97d216e5c78c6cd1941370fab99706ba8337942a5b15a1a7f749b616c315e2e0c12d422874f2094a2d376661cc8c773f6065066535fa65a110a5735c4372ddedd9e9ef6db91d7005a5530ca1fdfe28da956801b54b23b4966211d4d7329e3be50417f9ab3159f4e439df387f85c5ed0de6a982216b238f82b34715f1b818f4fd8f10be0742d8edf39227c1b74679ff05157f97b7d5db326672ed2a4367c8c432606fb9b6dfc5518e54d6df3824c130ab968eb3d81c48d662e8c151c5f11505731011e26078f802425eec8bb4680e7c09e6e5a632a90b0d75ee3893953e8f8ecb5d107b754824616385517f7c8dac6b75035eec1e0f2452bd75fc4c5340a71dafa3a01d694582b1df7cd96b4d30c8140113f9643283674082e4de98826bd484c7620251f99c006adf636d66dfa98ebd648058b052fba1c67a65bce61b975d4703a68ebfefe8ac587947aeb39e01041d1c902c59eda864bc21cb427aae5f9aa3e777c269d86f6fbf37b2a6da421ffbb1e0c0a9f04f1d3152423c06479948c72d20a5931ba65fae2b71904c86acc9796a8a00bd3d418dc7fe4b2f0f3f36680305792b40cb9d9aabd81e55a40907627051e4575db53b06f1ef6160f761ad47bc947992cc59c89816049c3c86661640f7faffbaf1bb56f4a3453aaabe55f948a8c8db02a9d106f0684f6e2b252e1ee1111db4df7b67967e15b0dfdbe1970303c060fae43cc19f272ae00adcb37fae8e29031d9ac500af0ee5dec040c1b4736dd69664b0a9d00bff518d3e0268d473225286df2b8991ac355139cbce585e8a5410bab0e80014f8cbb28c3e42aa5abd5785d630ba2889f2ca8447d0f808574a6f057ec1920171016d3881f5c5901600b57cf7ab4392ab9cf8b7dba65bcaf5dd8a75b596b341c36343c556c1599ee7f87da258ef395f891f2e5ddf38450559ed34e6e8674993f28fb3e1fc99b9b3e8de71bce2b4ca4364fdce94b1afcfda207cf0983e49d6fddfbe12169e653b49db348f1bc6e084751bb9863730bcf0d5a76fee49face0b557b596a4fc339a6af344f4c941ecccbb4ec29cce63b958eca97f819abfc6c7fcfbc98edbf30c89e7f0860c52c2a64bc1dfc262a7ea1d8b14e6e3ca97926a11b2677fe7e069badde5d34907912157f76a6e305fa9ba7a9c5e8d703916991d318f33646281f807e96dc745853f5fac5fa650fc6887cc7289fddcfde66227b174e7b21ee75c1c23ead5ead8f7c081d07ba49fc158fed5556f45c09e3340ac9276b4a7e52da9f6c6b3801439e8ce344469a6579293c0b9acb754d10437c8975d389fcd0e0073436160827c867c3d464a1a17d848290f35fc8bb688bfc1bca81f350558f58631d00c4b6e6ab75ee90a1a0405fe1dd1de35e9f3f52fdb9099ba797fa9e830552a7a1e44b77e282640076f6c136b5ed1d11f262e99dc45fc0540af9545454741062c21509a51b47711d9fad41e6c4ed547c7cf827971d1ede2ee9acffd17e457f6612c378493eb87ac01581e0735bbf047393398bbd1c0856814a4407229e1385f132c2417c175cbdb0e6002ac6f2326a32b43ccf11b3911021f041b74f50ee8cc5ac7ce71362040b6e9316cdfd2e8418a614a290cf1601c11563e41cfee2a09e9e9aa4ed852dc9de44a92947be65ee63ed440e189e674855707715a4c3eb93ca0d849b51058b85ceef779b012f7bf7375c0307f2476c3b9aa131e803fedac669d62d5740bd4b58ac8d4bb4df08f76be975b879d04622beff1bf31d8c4350a4252f7f367228ed37ab673cbcbb8a39daed4d05e97860469e5eb352528215d1ba725e7e4ac7ed552fcba4b75be1445b8b93573be79895c7f7ca3a91a55cf5e10d0f62dd1667c43f106eafbb810832850ee196fb19669a5389ddf073370ae2ca282c0340c33d64941e5ca5bd1587b66ceb8e09562cad1ea54093c17b5c9e7c34fe81bcdd4a03bf926e2359d95f3e6db93fdad2d56c9c48cec67e714f178173e07620d7b4029dcac1a3bd995bf724da3396009553ecb9ab28b702499e5c455947aff3c3447634e77cdddf0a5b3a5044e31fa22a056bd37ed972089bd57921c00a994bb63b1410e1320a234b746647e7ffadab6d6477247493bf9773003fb929c4a30b83f7b76eda2a52d73cbc74171e6f6d9efd841a0b4a6b7c201a22bcf4ce7370a0d091753dc78ac55b176d3c6ec7d24d6c8ff5e9916a1b6fa17add0b9e47f5d87669a9c4e21673888b4c9ba12336b21f3074e0fc54b634382ff7b2b51d0fcf1ad57b09236ea7ef4203fe9369079bbe982c737248c8aa1fa323256fa10117be369042ef0a2d0a1edda28a88e0937d22f9ce55f0fb81b266e82bc35c713851e657b06430e12fe2759e754f0c4fb7a4ad387b2bdae62ffaedc26aa6e732bcc8670f51949288082a3c36b811410b503b21bb9a10b609e75d1dc2b5a8a2261edaa765c8d0ef1006ab5bd32774e6cb01c2a1e891a98ab5b309380d1ce5d302ae853daa29d0bc8e784266d63638329c2cabbddf7a989be9627e76fc03b8a9ee842f5a433cea3e7377e3e4380726621b17666bd92514064977b4274f89bdd990cc805ae23895759f53de70017b2c3659030768d2905609acaa076bd0d74f7a90c844968a6510f86879c6dc240cb990128b4cd40905bbf1e7179105c04760d21bca9a8a272b22362d4d3fbe6238fa5e485ca92171f1c6146e535b46e176a099abe10410af9a1235d5575a0bdaebaedc2f13700c1bfcbe9e058936f5e0ab31a1ea9fe0077240c253be8b174eeab8b97a3d248f8e0763494031eca06c2978543613aaa52a23b3f96de3f321e3c26ef195b2d2ab289e527c512e793290a0914108c64692605f29f759c0cd7d809758b45367a81f6189b18de7af0e0238466674f7caab01167e8a85fcf4ce700c8e86b146aa7c1837ceda0b04b83de42bf7ac4a9dbafe029d7b76aa6bb97193831e84883f251067a9fdc0aeeb4ae33521332d1473c72dae85035d57f11842ba8323ed9eeef6791c4aba57e9a6f6678fc72c2791e34e19055c3e030572bf04ae488da1e5f744f5ef7b9e0888926cc0de1c37ebf6d3bb4d21dc9103ccbfbdbd7e154ef5dbb573a92ac3ad304077767b940ac75e09d2062a904d7fb9c5048c55ce58b5e53e91ebe8b0c93731a7f97edb6563027d60ff66065d62f111c98fe36501d870090867f176549c3032224972c248bf5377bcd884fef19a2b4fadac1a560ddd42300c0f1a8473f8c62b7d26cee1225943c345ec8d796e9c17c04b67a2e9f1a203f3dca4cc8988cd2f5d67d98118bdd755098f3aad74226a277fccac000d67aaa31412781d76b28c5512a2ce6aa069845164e56f0464402851ee329213de8439fe60b3de0d9a5418b2b648f3c275f0d1b0e8d465efcac23cb8680e2cdf92add1a0a497e5df9283c28dd071de66108d5c3d06df34f33a1dbd56d2d18f29a3806e9c946c910667aa59cad2c70c069ab4c0f0d2d79b82c3756ed22cdd691b0ca07e16c63fe1442a521e650c98b74b3784dff9aad4ed3a1a731b7ce06205d03db7240bdd37fc38d67d168bc87bb6026d0de8356406aaacff7cb40e3b36331eff360442abdc20824809bdf0e5f6bd0f6f1d7d2903bbba55d729d2cc3cceea2ad66981dfa9ed0792c617e538d0acee915228627a0ddbd46ec965fc9e4bf831ff85fbe07128f0972d366ff65b0317a270914d54ca016cea96b3e1a352bf4b04c8f38e8a4feddec9a9f112d2c69ab5820b6cbb8befd3c012f146a87034d523a8aea6f53f2ae97d2a8b3343b178eafb35bd50eb60da678792f307dc2807d8abb85c3cd037b63a7df9109786f93e5b8935a348ae162742eb1ccab149d024ec24a50708de18b9b9df6221177aaf97ae17bffaeee84f3f654aa64ce76e7cac9d9de826549bd941ad20e0e357c6f0c0346191d2b3e708b3958fdacd4fd07615c6dcbb4f37a9a21ee19b7fb86af6617c616453f496fe97aaf8d31f289178dad34fe68e25d288f99fb5c144ce03ad09995619001bce5c9e54a88bc440e6d673391ab9a2fc9a503cfb4bc25e2e5110964fbea73dd5f3a5dde11364908e4bc3594f62da410ff151dfcf26215e460c4ff7178c573fb7ea4574bf9139af58be13d204254c6651b5cb446e66dd07c2b3f0c7c194d357146934f6bad0323719df7b86a964bdced7b8bdfee2b974c6701fc7d2ab43e287b33be8b2ae4f87bc09deab73707ffdfe54faacd65820b5b9b55a25a420499979be9c9cdcd82bd3ac173105fdbc9f5ac6048be5772c407952825cd909fb7624b9de21f5887425fc0e05e52618338f20b3544d61d6eee188b170369cc97c1d681ef5257b53eefb0b329d4b4ef659996bc7e52c96f12fed6c0d154905390e6874e280d0f320aa25be784b4b2e1cc7843f26164df78832229fb7a1cc49d493a1627636cb8513174c12b6ac4499375a315931381f9a18573e761d5e5e81dc99819637c45f8a995ea8a7cbcb65809eb1a27efba4e6f1476e82dd56714a2f33cf9616647c067b46ee95452af84b12a96ff6d228c3609c889fd88bacde9639bb799806e01aff63bcfcf013f14edd6fb7f861f41da515bfaea53388db3497cf9078666dab7ef5cd699c18c4a0e611d131b0e8b4045c4d473f09b816a9e3c8848c9da4857380b87358a50a5d99ea33c9f2534f4704b530a35a1ef8eb9220cd931f28945e129e27a6e2221c81840dfae310a4ee015837edd713e6b370448e0f74e952d6792bd228a0045cde4081f8bfe6223a47237afacfaaa4b948b2876680a3e22f8f81e53bc933811333f9f5efdaf4f2324448fb53e598abf93a218b6a7f44c9404230c6dfe49de0fbe3eff2a7b17e4a06454abca04153c3d7073af6813b834ecd6d0e0ccd28805cc8532ec1acc55c38e83f1c820773cea2c7b0bee88fc76b47921e397f85e222cc768d55eee8b1506eef51fb46a32def32bd710b67c2eac929b93d2d137ef4e3a95cd0ce1f9aac3e812a88d684154710a7d2359067737d4d96dd0c8dd58687e523ef28633611582f4822efaf0389c67ff30638adb8b610263935715ed37c75ddd15f20799014f5764dfd176cba55c557d1b8635adaa24b855e4ad83565c0ed3cb6d2fd9dc346d195f8d7da941bcf7fd4a45d0c1116fa0c0c7dccd13bca99b8b74b1ab336d31f9970437c8352339973d6931dff59e9e74240eee2c4c0452844d97cad7f58188fce597c068917ca308d7136dd177a5b53f85c7a0dae5853a145a2c9d195856b445b0676b91eec17ea917ae8fbbe396275a02c1e58451e605f86253118c5211df9f7ac96b19a4dd457f60be4969e4cf29604cae2de23f6395fc67c20da8caa115948d8ad0009525f17bccb5d16bb7224dca8db46bd099b723aaf5a2ae3c888fa614888c552c6f74496c4fb7f675cfcaa8fe0284f3162e23aa84a15e3a697dde9b9b0f325a6891b97614412ea723e26e78b76651b8745766b846b86fee024412fed2fea69e73737ca7382cc6d00029ce557eb1ddfad960d902c74691e5c38eaf0d0ce0eb6714498ec098962a3b1757d738be6c658f12769e6fe77317b82b88153bdf2d9c3e127a350d8a8d7417eac98e46269b570fdaff54e4ea1a16e880ad8f280ee6f7b75a5edde72bbfc7347439c3e2c0c0a7bf8bd12d237ff0405bc94d9aba458b220d0c1fec84e7739b7f7a2308f2ae9b786aaa18c7a759619cc0c526ecd2083a184c4f0748e24f2db83cc1107975ddf28ad6641606c126bfff6a70a1fea7458d982253f529d5e1c6edb64f3f31df40d07a309f508d8bfeffe28c3311680ea66a272a3d9f120194772e85cf965500b83b4cfeec9fcfbdbb4b1557cea711d7a55809fcf291561a7b18b43ee9d3e78af1bc9f9cffcccdd8170a68fef07bfac7341c96f566fc148bffd6c7f8e4cffe5c58d44a165f963fa8f88241fb06aa9de9e9687e7c8309d8d829f30587cfd5501eecacf7a1068ac48dc1320d51797e20d6fda469054dc1e22610f8ba5f9204f90323d81888926eb0ea933d8e41cf789e009c8046eb289851f549ca7a1a48cc932f6806d0a412ff0ad9102653389bb4b306710b239a0c135b09934692704c334ac5057ea54c24449baee35867016957fc7c45fc214b0b27ae94b8e88b2440f17c6c2a7d13b24a7fd230c45942dd63fd07107c9984d42a7d674c08301b72f6606ce0d6a1cc8353760980cf5e6bb698b4101f44ccab08bd6021e8a567b5f896ee8eb57a2fa6d950dcd74839d394977aad762cabc0c05047d231f3abf66822ddf6bbc3f8a8b19f1aa3e6388d5b30aef5509959af4f8207c8e428d525a48b5c8cb8889b8026d60e3eea0a1ecf9bf979e7b48f595a24e7ac4b3e0d008f0307a2080612d6c60385de51f909d6fa5d43447a04dcaa3cb45d0c5a26dbd934377009fed1c8c2643ff9d4d1bdbeb922ec4a76d4144cdd9a4d96e9773b9bf8d11b0b6f3213aecce026e72dc133ada16cd935afe89c3d66a485e54709f83297c1286adf04a56302872f20229f63fd45e59edfa21051bdd250ea4423a13b2ddbc1cdbc10970fd813af46aec6d987bec89079d37eb4d0febe202784b98280df85513a90b43762eda23196d1756a17e086985d87bb3028cbfad6a0f1aac99c82d2628e4d4ba2677073d0744d2427dec92c2f22fc667ec80a8f852666aefe866e02508a7d6b5fffad2f63dff1bf3cbef56355b5aea893514cb4b6a6830e3579118f951cc34b6dac61fd74c886abea6f4349958f40e48ae819770a4b18e35b1b80d5d3b3ebb5fc330d7d027bad514a3917f12cad20391e5c847cd185fae81fcdb00e9debae93bdd50545ffcddb35e9f888d22cbf420ee1dd2d7d46b9787987d6d085605f61b6368eb40121ceab45837c464317ef69234731027b7cb1d7664de51b54fd36423f740d00021e869fdab5b0535d989a4dde509a4e33ac287f97ce288e3de4c8d85d8ece09044de2f21d0629a37611c75477e60eba5213f14fcd6e38809cdd75ac272bc93ed6b49999e8b9fe3341cec8f84099825b95abf581a9727b35aaff693691048dd527485a17eca332c50690b31a823b84267d54187f04fa9025d646b24aa1ce4ff234c53490a618e8052a356fd0493b3d4652e2fe77a83c5985248d94d6c7e0adf7799fc2c7bcb1247ed1380a078da8d2ceb8c53404698c6658600c0eaaa5ad7ac56c908b43e1715010fee57e7ac892cd8fe46cf69afa6f95e87a800ce8a49f110ce0f29b37b1d517b1d0f11eb314ead185d9b234cb38d5206b9143fb592f9aed98a8a7d6b29feb5db31b074ac7871cafd8ebf33f0fd5a0dc9e345d9ac1ba58f0f7c19e9ca0e6ca5ec74e333b88ad7166e8f2bf63cea64fd699e1f57f16fd64d61f6288597e3d3545ba460fc8b52383760e856afdbe940dadd6d3cfa719112a7b19c03dd8f103ccbd500ad457cee9f3a9b9f39ace8a9b83dcac59ceb90895b5ff76745d330ae2ef5f7ac86f0f666df62f181856666e95a1dff0a4e63d530360eda2013a4804470dc7c3a688f2461a6a43f599c8dcb5e4989788bea2d7eb6b3a423e47c13960cc8791f14b1b9db82a8ff94acbf8d873ff6e0b8944e2caff629760af8ffd837a3a9207f31c67f24b116d721ac08b3d0c2bdedb8226c599997f420c7b29028160963f537f97c9cf35ae9a8210d59221bfb2e2fe0b73fe6ace6e63462af84e0ff19406a97f7d16e9124d101bab4d9c9f583701aff9262aefa24dd38ad914c15099d2c5a8764961e5b8f455ebb3d9a09a7cf3def21725460e4c18f92b71283677a388a7b6dda0b43840da992fac7f52429eaa1e9c917b743161211aba6c9e125d259bf7df14a4586a60a7044009e4a23d013ef4525625015b32f33abb26b0feaa7384509abad58b4977b725d9811d3aa55072191cb6016bff591cf704abeb737210cbc000b1a39716e8f917a6a6ee4e303069bfa30185cd531f408e7a53df5ad7493ba92edf3936844c255a4c71c466e2925f37bc27405d29af3a233ff699c602ad23750dbf2f9bb07fd7afe3b90cc912161ec13c4827e1ae7fc3db1bef1f43a15da316aeb7faada815edd994e9926fc135e7b9603a3243d55bdbd2457a52b895c84913eadb070e40f23bdfe7222c9ce738aa3e5772bed9cfd45646c3b67f8966f3a2959234ce1cb65d31c76fa336c034a09af3df802453a2d4782a70366094c17863c86d8d0ee927fdd0fb606a79c244d44c7ff75b1df5625d9104ed50205bc39a969907aa88935ed6e6257bb2700578dbed6752c5718d03b0db076daafb4e566c223f9839bb467bcc299bdd7d0660f508cb355e785bdc53a299f84de8253572fd74f7f9a5bdb20b3c3458556d4e54594e0b2e189be8097787d1bb0f264e815a7b7e9a91a08caa2b6669688af538497a568f1b3efb44165bbaabdb25de33f021d9b05dd50b186bb4e37a20ab3f1ab5e23ede0f542ed3511552a76f887a3cf5f8e270d8d167ac1c864f561d1a7a082f391f36b3e2902bf4b1e02021c226e349fa760efd8df782ace3d73f2dc68e61e602f0ea68c106d9e9e496e3cab4f4d1714a9d3d0523c66f242e81a25f1fa6bea1354d27be6e88eeceed13c8726a78524ced97b3900b6dec8f2d3f8823f2a79cddc95569d53dc76dd0d8c225d3871c9de6d534df4e38803c152f34c2f0f97618e32288b8b6090b53a7ed9100336ea0a8fb509f64be5101ceb874d8108223572ae668a7b2dc20590e9b587e45687e7b0b49c0b6e9c310c9817dd3f6330b290a73f2bbb1f09b41088ae19537828c162066f554c040384d0163157cc941f5ca38d5942983a4052ab9f0c1aa169d8484946499d7a8b403d662ff488183098bcde70c3ce82fad0063c1a37b228866519ad7393bcef0e43de0961d06071a7a36b45da1ef761e2827f976ebaea8c369b8975d2c94691cb82a48199206d3c43f477f16299e9774c6cc6956b34dd5b84a56fceecf688591e4fda666527c6bdf73a4c8902fb4442728ad1abd99366a930e8e3494200ac2097bc82e7c7d0d7eb2c4a903ff93106ec88eee58b209a4746b2f2a92d92dc3d0616258f3dd038b0e1db4e59d1da04298afd62c6a3ab0c8647ce8526b11853b6250f6f2c77a582cadeffaf3d9de4fccbb67107795d37019b33b89fcfabd09320fe25559d62cd5d08fc832d1c68db16f58c24211a88b12e0b87c451a405fea11707a2beba4a5ed96148819b9d5686bbb50fd35f017aaa7a3cb0b0316eff526a3dca5e6615da4f6c49f96ec6dfb7035d7b87025cf245e30aba4700f91e630a1793b5e4ad87b201bc91f930218642a5b809dfefabe8c52aa06bcdd2c697efdb7a35a58a52d6e6a61b22305b02aae3cbe5a25fd2f564b281ecc1dd8d776380600e35b9e9a2727ed028a5efc10edd0343cba8a2d5f6d6316deecb4fed9e8c380a05d5679080a87fe76fd9781cf393ce43df12fd3fdefa50fa8ad0d515be4a4924ca79768d966a8252aafb0390cd3d94a5711182794453b3cd065b6d97cc69d72f9f459a01df836099ceeb41adeab473b5f834821d1ef95f9aa594b9799b9f9c99db890874de179e4caaeeea1a813a70c51c377580624bf072ba958425ffbc7d45b9807cbe83fb9c5260d0ee6b5b1c8fed6f32120a71ebafb5c148a8f4493f09a95b294f3ebbe9bc618a1f385b486935ceaaa2cfa9be5fcf54589b179a92ceda0002c6cddcd6680da322adf0de392815f51ef3e62914a0d99af7e72f3db62cc9d2cc2022e38132dd5901cc6a01527d1a77e8250b1e12e6226a745343d249275ce32bb2fcd3ad5bfa4e98812eeea67810f404e25f59b82feb972ce179b7891e1c9d60e76479d2f56cc62231b9be06d9369770399d119a97c5e5eb1a79af2cc6dd14ade7205342e6ec4c4c560eff36c57b00b6e695cdd92af1e98bee0ec1130ea24d83eb8e3cadd7efea378cf05a187cde15233d5f28b8f8ced78c57789ac5e4cd56bd30dbd25e2259d933d96d1701b74304b2abdabcd80d8d8fbafc269234ebb1179dc0dde3a6ecf8dcddc526ebdc5cef3a8aca559e8204269b2d5df84cc2b177f94c2f5507ccbd7ba61a884e72d471bfd45affcec86d078f3f07dd50404135ecd03e5832324079b112afa5fdfecfb9d3d64f6729b2722101d5a2f0017eb17f0d3ca6bd81d4e52de383400ea67c84854570ef8c7bfad9bf25c5bedc9eccdf5afaa2bf3ef26f05d97f911609a1de51f7fcdcdfb4d3c50855098a861c5e7de04c8b66d191edb7990a092d95c6818e908faeedf2a4637d63fe91973db28bd460168ad60313e83e4b294cdd6f186e431ffbbfa1dbe8585477158d632c4d72d9b43508c983ec7d10831c780b1e21ae5d3719daa7cf59643196437e1b8f59eaa2a5733953256ac442cdeb14c63263c2b1472ddc9eafb7781165d2f5f7f9d3b33b3d082ed84742cbcf73eb683c6b1e4dadf3dcf05d7cf9d32f96896133e72b2ad559cb2abc535ddbdccaf958b83e1c85c2a1e03560d3bbbc714a0d3e9563ab64f5a2246e56694e6253ab15d71678044887de4c15fc7c1f6141453d2b17f6633c5a119a848765bb1f0745a5a91197e46f144980781c5eea7b707145ad46a60ee5009c0134d1678be998ba41d2a61fe5cbff5acae145efcc7de00de02c0d44031aae5c5b93cafd9099194724f44fb42586f9da0df76de5c9988ff8f80c31bbe49e0b6ec910b2c48f847881e69b4687ff5f26054b1cc61b5133849a83f07cbb92f148ec42196b691bb757bb277963caf8711f151c7a9667afe7e3dbd56fee1d87cb15a6fbca792d02bd1a841362108b223e04bd22e0e4eeaac447ab2aa3692be395454cc825529037b14498578535f3a1c03a6d7d588c55d449eef82691ae66db63855fad9c48999252f76095ef72cad7181225d89a4f0e771aa3123fddd0f917ed255c5f48a61d5d93b3ab990d0098c3a157000822f23a153fb8652b0205b540b83f74f62f75f636ce16dce77891e2ca8fbce79348399f13f55e01074b40f551b762efa17648e0f01ead4cdce1f39cd93a8b948221de0c9bd6a2f89ca44647f1c1eeb11299f3117365ebcca0d73bf704f7654c4750d041300b9d3e1a1387be5adfcb7d02c566727bddf1ec5169f6c08c72d80e3d70f8fc128d70c8ef58897c2c5c867448dd84541a6b102aae34d123ac1f1eacd50310f29b9fca0033938e8294cc509d368f2851d90a22a6c8321aea9c5155d67eb5cada7ba0c44329bd171f40c18f32d65c9372cc95308418983338c9329c9a9e2d70c5954e8f540ee06195696586030d787559fb10257249d518424b2f06c606e54cd1d0cd25f16c935c34a2216a78fac52e27c5075d8b72eb2d0f754f815fdb8c2c4396beec40b5c5f6d079973534fe8f31977e4918a64239513a6c9c3dcfabb729df64e9aa97f6936a9dbe2ca90c582add58dd5248dacdf79bf05d3e80ac10ca1ed5c7371496bb7184c5484566f7d7a2dd038855d4b3dcd192726f91577163469a0d6508bfccdd3f7f0f6047b3d49504eab9eed477b229d73a1a2e124d59a8ac3130bee15cc66f39d6d5d4f2bf9a276835cb9fa659eab14a14a7bb9ba49ec949272a2b1d6c1b88f0a53c880138a9e085f376760d151f1371b3225a1ee2e065545c046f055053905f990d15c65b00330bc07ae4fbad012ebe416f3148f4a7c6f87ed92a11c9f58add307795b735555650ab9efb3c49f2fc57d0d3787417f4f68db07520caef579699d95189e52ca8af39018cab8b43743161b324231950ff2fcc32b9ead9aef3834109959e0d4c8fa7eaa5109402c06cb8dc103072738ca6eb08e5cf92a93a3fe950db3d2e643626c9a72957e3d4ebb76046dd40e64db23a4d34881d9f31c4d9fe1182f10dc9c156b887c8d85d9433da2f7ee815c645de2fdcd3618536c9aa266bc8aad7c128a495e7c9e6507a6ea0a498aa2bc35747ddfa12c410fe39c2ffd65ee0ba0f71fd817f91401d579fa34780d4ea86e0bb0ef1a8d61449cb36b9216241b48c6d3a843a2cdc0efd4c70641311435648c000c6e66ffe2ef0c6ff9437d87187f244f7d2bc741c3e11c0d6bea45cd22a7eaada12dfa1a02e9444a1592c31ec54d52baac3fb9d3a3e3c28f314dc0736173ced12bc4277ca9bc3bb22690a2c637a158ad1b7beef3b749b41f0942380ffd5162db7a031de147b5756853f470109ca15e9968470fce07ae20383f082ab4ace623612d156bb48be7d3054be56b9cf69b7ffa5d42a99f5f87737775ad16ad2eedf1bff5c424c911c3eb2428854009f80ec56f9944eb1328812276f67461929e156e03b4a6c6aa0b715bc5f940a48b2892d43167bfd524ba4ce10ba11ab15c9385c3a51f573abf94bb8fa39f9ef3c7d98d5aee1a540809989904bbcae22a87cb92c853368087e9acacbc6294368a3c1d4a6bc093fc54464ba9c503af5a1b3286c3449d6c7daaebed75890bbbb940785c6b88bfadaede1640f7dbeebfd96e44431a50201c6815f5a4e0f8e6c225954bf955ffb47a8eeeb6f8c69a21d643bde84334a922c7958d1859e7c466e290d5a88ebc78ed3eb190df0bc0beabc2d36f8a1596bbfe9596519e3370c4c4993bdfe8835082e9cb416731b51a6a1c6e6e142113b5a70dc6fd5b78903df5b30d0a516f94bc6e89316d44d693007f08a9b864618c9d891f5156cbfb2cea46a35401c3bcb72df2609a8322a063576e1ab92ee26a4074997cae8f5fcce9650f898a9fe2330e971a5169d27e1ed9ef48128aa1aeae5eea076471a1d6beffb4f939056688a5515287726df573de15b27fb41c1780baec9245d72d8c9a31f922043faaed830953d2fb76aceec4e79dca8f60b729461071319442f99254be0af2bc1b8043d43a0a3b093c9ad9196524f964ea01a342c981913c3deefbe04c1e044bf6b0934044b57b156f8c50f28897486fc7dc10a9b6d0815669adefa67ea4e8b4f766acedce6edce1f87ec4c8e6ef04a31c50ee876d4931118926643672987a494eb8dc749ac01be47f7ae7eb45e34b9af849fc5621762b2dc1074fb293fce25e2868169546354c3604d5ff64297cb30e73a2e3ad2b292ab55cfae91cdd352ee560fd2b775a25cbd495c91ca3aa35c94799f058014779991121e0f04c28bc8bbf30ed2a38fe6546e8a2ab804f717f13e74d04add0a48e81ec104bb26fcba66f0ec505eb8e44b7d7fe827f3518faf629f2b1e08c305af24a998297753860580710d32a9f7165a82be6d88b8eae0a747054ad534e12a96be367b3d5347024617880f050e18b33de810e547d1e8cbcec7104db06d68d8368f573df972c91cceaccd2ef50ff82527aa4bf7da4928954ef44c47569bf8f405496bde452f43dce71ecab4b95632ffd806e478f738c7c68cde4e95f11e0d09ffa4840626c5a334cde8e0f833060daab9f93f2389cc867ad62d1f8d64347486c3f7129c325b303b61838e4ac51eea331946a1557cbe62bb00f0155f0b82fb2434005840a11336993f2b24601a90774a88715a9c374651e5b8a94014be0e60c671eaa6c349405082bdb6a51d63e65ee1005d9cbc90b4e8cc0db1550fdf7a8206e1972704270741251e315b8d58dc4916604ca5eeb2084dd2d5834349badb25969bafc6f45f3db23a65f30f653403a220fd5bdc0587c2a30738ebd65509b4feaf09c06464efd9d0aa27658060f38f4bf964c0b98272e9d222f6544d4586a09f8bc549281fff30a509a9e7f5916744ad18d908d556a3b395b32eabec05dea6b645fd7dfaab5705b9b370542799a85ce46a596fdf46d3cec9397d47f9e0ca83b5033173646d7c852a2b1d3b11ae71c2831f71917ce099d2218b73319e118315a5693dc66acc6ee16785270394e3695108a805f95aba543e544d5d4e10498158c6ee8393b2871fac39f38699fc292fc535b17f4111aba50a30db8356ab44db0efe1decfbfa87932ee1ba6af27bf2196b2cbc4fdef46481dd9ed36aa46e9cec1e6c2fbd3942ae44f7135394431dc89170f529baaebcfea1871a0d2b1cd7a7f8893364fa3daf0bcccf53428b64d5184277e0cbc34c1a9a3fe9177d351d8d920163dfa24a53bbbc411e2029bad8d0d1b631b0997d7449d03e230be1780be3d9131fb78bfdc4af9efd5d4b6022e9815074f2b4a265e3fb85d10d101424a6982b09bef359dbba1b1f23f563c3745c3ff6bdc8af6ba449d882cbd59eacc0e4219be54d9017c6600623b94c6ed2c99d01699be22850e3d5cc426498c7e6437a698d98e99879a84be6d6537836c108492d1a55559f75a0aea8f3b034085f897dc2dc63a36967ea67e384a7cf339a224d5be79bb3ba8ee98110af7be4d0fb529a26cdb87d6f2f110565cc2ac194d01a3120abba02b40f1ba889e60455b260703eec0499bf7cf5ac0a6bbc20316130b5d0a14cd8d0e14eca7c70a80eb32bac2fca6c11df3c62a9a3b2e126fb674731bb0be27a10fd227bb47728eb5979ea937b923a79d366bb314ed12af6ac91adeb2df79f2f5eaedf20b5470f940556d0f3be88605ff8e66d1840d79da4ad25cf595ddec89a2c72b0b383a9475e6b194aaaa10850c386d14c91d38feb2a23fafb3341a3689ca9e9e36bcd14802e85298b5fac4cb6b0ad619c00bc45e89bc95b74f15e38f7be84cfa8ac77c2bf175062d999fce0c22cdff2c091862286a16dd0303ec5f57662428b534b19e4b89e455b62a4a210274e5404baa2be8a7e67e9225fec202f64d79074e6f29eef0dcc0d157f5854ad418b0ec24bae0ae565a31a9a3486119044f1847b239bc212876e452b5a8b872b8bc83cdaa82ac634b279fabd386310147813b5b6810061ab853fa6c4e3706aeea3ed2f5706cc0b33f1f1f68df89b90a1dbf8faa426349aa936f24a7287898eaf64df63080df3ea41a8c492dab9ee9d5d9e994603aa25301a0f0bf5c4a014afcdcabf76e5b6b20a3623904150a8613b3dfb2018c3f5570fb27f7de5d9d3f602d6e922c45ad52de46c376dad152b83fe8acfbdc4350d701a1fc67754d1e660b82bfb34827c69f48dba5490c1fc905fae00bb5d07efc5549c9d7ba27fe28022d8000c92202d92ee7f2eccb4a0e8e2ff5def8c4458923c5746e431f7830ff7c915f8873f693fd12738319808a9972b8589d3a8075ab0109316f9e8a2ff4b4e109065564037ac40ff674d505742d3b22edb1fb491ca53d00cf80fa13d41f4dc5b3151402f5a29b72b8853fbd0fe62ec33e393c8a25dbc9821a2d8e92dc88c3ec0a382a489bf35c3cb1807f5b13d2147b8d8c25da7bddf7ea0e63cf670e6ede738b24070c03919c5351bc04655593af9f8df6470bc448519e591578fad61ce818a741b038b80f9feb212f234d3af779e7b297534c830a84798aeeb7aeca6991d55496c2e9e2e69ca6a6e0132c88bdb7b6c2eb070b0c3ef78c0c3756eb2252168b0304e964336c1078df89e1a50831d986674db5e1dfd91118469ff8ed24552eb22c676504cf3ed54678ab9ad48b4a14ce9e1fdc3e3290e4cccf9bdca581277c409a1dcbc14b84a7c8379ab927d091173ad6291978a9b961fd607dc139315967555d52a116eff9f4933d6fdf05cf8b1fa5bb073cefbc539615c0500e41a413a339a5747a899f550255339cb54d91a6ab01ca86a400923cca8b13183df41eb846c13bb33eea6f48406ba7f499bacf083b15d176f52951a528f5d3c93e46e36d25d4c4c9f986d174e92998f4fea99784bd8a31c6ae8a3f7bca9cf33e65a9b5809a9b0b86b1ba9c65e3f882ce2ea2d4be45c178f077472cff1e5894846c106fa2acc8d75f054d4dfe347e2c4a75a59dc09d740133589e4cc6cac2db2e4a16c29ea3d65895c94c8b0c64e1a3184f884e433c3d995d02df51f45b692cdfedd49f638d77710094b46467ecd0d7e4c1dc2ae4529e6f5c6e569b8cc099a519c1fbb8869f61b9d357e5efe23f0e6009bda9a7a4f601c66747fc69b511db86a3c8bf95b8c555d77725cafb5d6f6a625ad9820815681f2fdab2f96a77138d3fa1d9a24b7ad89c37c06e064f8614789c37e1aa14071230b673debf24545424a6cfc89219471d57178fca736c1bfb55490509927c288924834cfcc2fda5ee6dedbed8f652cb7c905c2bc5524724d5447a518dc405af51ccc6ac778d423a48a72c5f2f08f10134eae75356a671dd38a0b2ea51a1b923458115071e41b8e647be75d57c0c16fc1d713d7bbd338402d1d053fe8c29fe545a2633b9059fa7a79e07609c6876d1bd2197b19d80d8f38773549addd15fdeb899239b8771df20319743e833c7f22970850ff61956d557e05952436e3d1e856784692221eca8f61ab419a6961237505aaaa9b351fb2b80e997135512be432e56796bca63bb9fd06603cd2c0e37a69f0859941652ddc180e8e00df671216baa2439796b71dcfeff6cbc485a3a71c70afcde2913cb6f5b242825c8dc7b3ecd30781fe7857dfe4620d0da785df4abcf0df8eb7ab6a8109314b342370bfa5ff9e252dd817eedeaa0c73450df4538a1955e320c5e4bcc0a85ee39a44e53a77e9f808ef02e882c0177e4f8c2b2a897c2f7e935bf6fd1e98de3533a5b8964bf3287f956b6bd6377e15ec3e2eda7da3248e910e78502049784fd4285d04461e421a288c75e9a9952af98a43767dca4d454190777d8e4f2af943f9e31153d65a38d35322f303d05daba8a899a4b67d9c8bca4236bd2d9353a76c08c1f652e6857e15774f3effdae1945dc2c484d12f724b6721301851ae7e44964557b4e6d0bbc1e88cfc97abe28b5c37d84fc1ded404cfe31ba84761088e49412469aad65121ce722ffad20176a8ac73d1a7ed8841b31d2b3568efeab80ecbf8bdf6078193b52b39bf1ab61c4757644360cd66fec887c1bd368f51b5f7072210b4ed4e96fc0aa6b5457c889b6fc818b968345a73bacdb1e045d1a112afa8e4ece4096c49263f2a59aa94caccc54ff3c3ab8e972b3a037a96add4527584549a4e470c8395798faafabe2ebbd014b1992ef53bb67cd2dcc979685e2b83f1679b57180b9a827f4ba408a467cbd54e5de7788a917de503db8208c9f1828659d867841feae0beb042af3be6bb33c66c30e022629af0f26a4bd6b299273adc98c25f8660974096d568fa12531ae1893f8c43c2abbfbfddb719ca53fbcaf3752a360854a5b4e52b9569e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
