<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2be2a6380957c07bff37f15fea20b8a70d5afba36b3378b5fdc63ad4dc5cd1f3eb8477c0f3df6578c8cf3431e20da4fe1e095ec632096ff212405ff31c7ec48914a90a486bbca1e1e698f6d4edaf63cec85a2cde7ba23138232ba4b3098040bae448a323428f246bc5995d921d2c3f62037353482dc2adaf63161851456693a2665ba05480a3b7dfc9362e00980d513e8dcf14ba33868aed7dced0a32e41a0e687fe3095e155d368d12cfadd7f9641c63dfd8b98fbf297bc312a2cd0ea6229b8b4b67920564b7432edee8ac3883b2b7560f91d3fb89b4d2f1b38b46be07c8a0a302c3d3005f599f3cabb696d2675f2015c1e9ae36a746250bdc202b3df88678180cac8238adfb56ef3973aeae92268f11af06ee6a2f542cf1fe9374bea1986ea2db901513d71f255ee249d132f1bb867d07928214e632a40255789fe9eb3f01e2d9a7cebf7b28eec6b693f86ecf503d88725ed6e6c3ecb1b52439e1721ccf4e07e9b913ce6c116a6de5e6ff5db325ddf1ae7a7351aa8e4739b9e82c5628663c2515a5fa1913af8679c1b3bcad11e5ddab053086c5aa7c75a5ffe02005e78b28aba2bc7fdc500f822cf6de1c43a6a95c7e455b8a1dfb21d0c474e44ce9b7e4e69add0534211061bb0c7942c81d4f14e3e7dc7961d15e4c8415f6370a14a5ede40feac9a28b7f905206884b4725a82c849e90013bd287c59b908875e97e97a847bf5b750d24328b24a0b48deb6f6e806334cf25cdb99ec5796be919d6ce928870d494b48eadb2c3c6a347389e7f0a33a7bb4a4129d418c481c7f3d30549a3fc1ffb22cc327bdf2057db8f724aa229443d783d28e37c9b22fb4280ff889652bafb5f5ffc67e1baaa6c4c1ca4d9743d50f09bbd5553d5a2e4165ada41330e5a14e8dbc251957a9e8825b3132b530268d781028384f769070c8b5a7469a8785c4c685fe19f6138b95cdf6fe55cc882dd5e62ca3588a8b63b5109b4dfd8a8c000dfda9d42f5665f7cec9422b7fc51c7730c03baec997d5d8d1e815624a24ffce7ac774315c303ff3e47bb29a0ec98c615e2ede66bde3576ab2316a693a0c0518d07c51f94737da118f0040b183021a178b383922e9549075473b8172d29a25b4b99b4ff73fdb335424069b8adae2d13eebd6ca29161c11beb322690c46bd0048bb697d5dfc63a9f2b941d0ab70068af979811f4a4385421d8a66a5365de3a39e872afb296003d3687e435fcad0e784e4f6cfb19af5a3366a9afdcf9a2752fac608725293933ac974fd7fffba8bac6bf4ef74c618300021af4d7935fa3f31edc3edf906336131599cc368c3a80004b12e98afd87e8b1d9a9fa6351caa0d6fee635c6445ed4b628d7a8ee82780c36e7186f02c0bae566ba557aa97d2843fa4976b9c6bea316b6af3ab12f59ff0e25f8c1246f9f855377c20125f0f1a643302739d71e9d7e80a5f9df6cc766fe87b7a290058141133eed8cb04651704c563a609068066fa9cd9ab3e2e81c307e5e02d98bfdf86be5c6ffed0daf9a5b3af4a9732963ac110a2fb86df3f02e81f0d2bdd64af9de74970cd63e5b0f70c5f8c8f9361fc5d7a85be19ea0b01932582f346df7928b3b7b709cf46599625698d772d7b1f52ff1b8edb8fefe509fff1c3b3db0dde07d80813fa6498442e63f525f56bc8382eef191a7e4032df4af0aa0981688b87a759075668ea9d19250d5d16d1ee3fe6aeb7c9a263fbeca1c346ed92d57e0179735ad14f8c18bce89b1894e71fb6f7436a6656ce8b8d2f6b56b29e1e4b25f9031c8aedfb82adea18b2ce27a8d582f78931245ee42e1db09ca64863f5b86b9707cca7a35b1b6e38756598bf6e27691e69c98abded45727e36e935fa58e553ba38a85a12f5eddd5c222cbb6c841a0b80b5b11f8e8cf7dc4d87732a16c459b31a0e6be79c20c6be3b4de8eccbad53aaa6123ad966d71a1885ff12cd8452231a1ca067030ab2876bfd5c85bbc12247872381cdaadef70df7a77aab34954784878d57795772b9374b4db497a0430056237face639fe10706045916ad2c078a1cb4b0945e82e5d1aae75fce0a30ee1559eac6adf9eca92458c7cac428521e2502ff270fba8dd8cb0e763411db10ce908ed09a6d893ee25570d70c09bdfbe7db53accdb1fb036c3fefad55c36f52744555209a1bb2da28005d5f684a1f1290422df250ba717b1a5f8c6638d840e66dacfa0566013595c76064a7b4bb7e4f4f653e6fe37519dfa050b07664b3865d006267f5ea82ea9847296ecfe159ccfc78b098ff717fffbe1432982590232e417abd506c15685ecaba146539d02e7b68de96648139379c66b61183efab33b1f6fa513d8666d4febe7f407f9ec537619e96c332efaac08232ba88ecf8719d75e47982763b82ce571498328093df1e7036f34e25f161a9920a7ff8526261ea9686e70f291dc8696d3be3e568c5fc072525bd621ca282cf674eddee0edc5cfd77a309dd3bde38f50c085649eb8fd577aed859721abd11618d41f25539f813d56b2c73acda0ec6e6463aace4d27335d2a011fa053218933f650c235409e32e971c47d65533362e6108167fe760bdac2ed50e0832d6f54f889b44238aff4cb3e0fb9c553122533ce8fd377abc883579dfb17f1316dc28de06e761d9a2c56e61baaafe72baf3602bb32e207f1fb06ca4c4c42f5dc394104b319cd82e58eb04e9cdddb3312c1f2438241e36aed5c4f698f241a0f22d3911d396fea8b8c7841ac4d03fe2370644e0cc3992778155023d31351c50509cbd5084aad326acf12b95cd78462884988aea85c13855fe12caf00d1707eb6e8f03e326cb381864dfe810818f4466b7a1ce0dc5d36e525330dafd10f8811080a1c632a321362bc785656aa33269ba2b2abb841250be0a88dac4b52bc70fb2ec944d1b4a81296345ddfadaa9f31e31c218558240812933dace5af614f8023bfb683a31c003723f06f055f84a25be0deb4a42d81eeb230fce174ad5325236d410adef5603ca232a102bfcd7df1b9550da5466766865b1959f9fb842a9ef5480845df2a3f370e43acb83d55eb374130b17cb7b7d7bd3fe85d15f50764017ce7fb22b9fe5a6db8990d09433040258183f2478fee287f30238f68d4debeb5b543535e7a3e4ea76a0b8a51c98bc1eef84444474ad4d3f0923b1ff255554c3c26d081a10b8f3aada8eb1f8ae856cd122823ea2c8b3ce7ab936d939d417806271aed2b3fcd792becde92eadc91273b4bede7f02b30b9d17696fafe9fac3d2bfde924406bdda4c732d8eb532b8968f1384f06a32d9c84ffc378d6a1c70e5c6ab725f2c677369b4bce769ea1394fceb7f2ff1a0da6a770ea9a1342545894521cdfcefc48a3934a595ce6e7b0c2030fbb5c2e33bbdeff6ca9ca0ec79996be85aca7885bf3f76f5f08fca7aa6ce044b6b732315d95acb1f9aa0eaaffea478f44cf462c1969a057dbe936a89add4f09aca829a5b7ce5d8f34a8f474bb1078aa6e3122c0637e68b1986e359cc649700510007a5592f611a10480f59d09617ba5f64e43a98dacb3f2d5438850678cfbb5536662485099326959202e5ecfeeec9e76d36d3c013017a6647dd94a8831b9c40883668483a2c49d3be2cf7b14fd07327605dea54b3ce49f48f7c1d1da8fded2f9bf9f0bb29d616823cf307a6d576b3200d62fee3bfec6be4ba433f310e9e0b3894d8054499e2a62a5e405bfab807f9755d47b7cf150ebd4eaa934fcde5028d5d89bac78a0a85d3d24467322c401d7d70c5c943feeac0a533d20c25b561c941faa7b064d9318680735e4552b5e4bb5e65b0ee6c2dfea02383dc667db969bda95cf505ea78611afb72a7953b0d4277bfc89236c84ac410c2638583fb2cc50e7755b6af85dfa7c586cd9ff45acc8433443c44c972bdec29df83cb199e3e8c3ac46d5a6ee0151e075167a2f3d6822e957fb35e296e98ef137a3cfb5d8a987a160edf6bfe86043d5790e1da074146d0e39af6ffb5e78ada7d75da98f9736fa43334fadaa1c2031ca937d91d1a252101e8cb7151580ff4362bfc59b7618272da7fc84968541f05f08158da236e5013f7ffbeb7f34a69f260d1d4fd15de580f11aabf446dbf6ee0a35233a4c2ca87ffdfb72452ae0217f6ba265cf248ba533976f33077d0f14bfbd9a13782f7adb92f1d7b86f49697564f956225001d28ade3dac17c3ad9a64c1707f7d22519b3663bd0dd6ea9560a13068a75299b851c201c2c43060c11161d1e988eda89621fb9ffd3838247be21faafe501b423c3c6f428c9ae50b8e0c62a6c5ad17ee34ba8840311c18905fecebdf1058eee9fbb3835c09cfb58880654a19bfa8004586b3cc76ab7f544bcab3e0403fffa4ae35f5456c32b792a902095944afa69f85223a25bc883ed5324756173efa062884f709e2fcb467566637d38377d956d01f70bb17a8c47ea63d500ef6167f8660460fe3727de691dd69f3edd73cf8f37f7d87f680158719b0b18ed100e0a2515ca8d6fa12c1d2570d9871a54de3b61549814db17c0407273f9aa1fb156d8364231971e7475dea9417b04bc45b409164ac53d98470f87c50e37b81fc143dfbc0e9f1a9750f2aaf3f58ded32c8532d1fe3c74230d5f30f2898d77c3c5ad231501b22246e98ad3ce1593ceeeee5ef19822b04197b09b68e6830636686bbcac4d94695c0ca44fe3886269038026a1427a04567ca0d43279edc222ca538f447143baf1598c84c78e2986aaae2160851aaad728f2a9ed83fefeead4a1d4fb84066d2eb125eab8c1fa7753ba3e70387981a667f34b7f6349185c2df9efad32d26a04f6224f84368dffdad51b458134e087438078e7520c148003b935a48971b480dc29152b8891b5b10cfcb4044963a0cd9e20401b47a2639fa41dcc20bb3d362f1899b34a5d6c130d73b0c4f27a8b1260f9e5e3b5546d16afdccc5fdf549a1f907a2de82aabeeddb346b56953e85d7376e94425848b3d2487d37b87f3e8311d29e722c747fb695cd2f04a36a8c41b03bc8d42ef9dab6973a8341d94950053cd785ad8c398f5bb9866286a03ff1f5db24ec55ed95246044dadbcb2fe8fe929cf5851af86f42028cba9297fefc7a8714247213b29c611153663b39977ac2f99d618013603ceb1082a3708e403332a61158d68531e2f71faa831b1a062c7caa4185fab7f58664756795f4949bc067cca60df81315c9899ff2e586095fbaa305781bec0ab49d111325069fd6f8b1a4be9e679917db3702adae4200effd343f26d5ecb2e79ef8c2a4cdcde2c27ccfc71af5b220f461eb9f7d73081b8bf88640d9347fdc670c6e92d4e307221cd6ee661b83b2f08c4ceb6d1776bcdddf6e9e790c18b09977e7a105a7ebc8a2443bdf37e69d68d8d5d458968a1e5b0a49de9140642ea43b1b0f36aec96602ac681a4dda7eecfe8808467496b92760812a5999c975a2b8567d3083b540b29d490d74f33131441e42c27c01710bbe0ce179b57ecf96f568762adc197d1e289f37facc75bbe58ec082128bbcf458d4fd15bc4cc0679d0aa52244c541320fceac4bf3777bf36ccd4e73b8cb6150d9fad3cfc788400535986b96a5c964529de3c054c8bdf9da25533311828c38d2ebdbc55ee4f3d2c77e996efaee83fa7bf7eb8063edeab72c9dd47f4166961bd684ebef9ebc57be2853efdf14f03e48305f108d603a813ccc171e114fe02e804307ebf959893a3d193275b822072c7affc988368b82325529c3543aaa820132cc6fdc44ab8a860dfe1f1b9b256c3bb591e3b075513388d20e7050aadf4e91bd4efff77374927a0aa804fe6a474cc9ccc2c8b4127eebd07c6410e974f5c0ba1a2271362abad014077471c2172e3cb499d217b8a686680b20802ed145a096a23358e84e0f73f7bced0f0f1413b5e4b3cefce31dc7d3f3a384c9ed69dfb668c4a6ad42445262a019eb15f3772a60df03d876b445155fe86568e58302cabdd5f868afc77673e97024568a612c90568d95c26744e3cea5d27af686d39f0aaac838203369ff76d93002c3d066b7ac3e473941fd75243fea95af9b5fae00690fa6812f389dc1d6cc5337ceb182065b11e3220a0006629f9608e17381222fda84b9b7842c601e7953039ce5026878337279f9fd7ca1544074a84f9ece1e8b61b01f0031b982de89bd295bb9d0867d3e5a32ae734589a046aa18f94c04d0139f949581b723803b0d863b9a3f22e0147c8f3322649f75568abc1420e7fd7a4a587331c6203cdd56d9c2d4141f083b89aca4009aa7b41faa89a3358ed2bc079776c5de91090e6647a42ac473463a3bb1de61bc4bf5bb597e7962ef05a8cd9fd6ae6678332ce876507596378d05fe477dec113428a739ba0ffb307c03d1403ddeabd14e634a0a524224c2d84e39772e62fe7e96cdb0932d46809e94aa257aa1e89d3322371cc42353b714a48b4906e7f36f9833d2258c2c4d96733d6298feea94d45ac47eede287257fb928227fd6aec98e291077dd05e6c11e5d39a7f9e498ec51c7dafe4c17c58da900aab21b12ad9e2bd479efdeb0defb9682e883a4e967ca442c321aeaa97c7e74fbd375ccb14e46355a565c51cda75102749b1a73ca91e92bd9ff7c9d4fbb2b4795046ddbeeed627b709918355d75b97fb2d91b22acdd5aad5d0148f67694b319f3a1a25fb984f5e1920aeddbf6d2ef7c120e93ee1260012d3dd079ef3019696b45309f1bd4e2c4f3a934c967cb26bb0944e87ba9676da0f9e99afa217ea68cebe701f60847646b5565b1d4142f27b41f96b76928ecea1e7de2264dd6e7f487f38cc2b6221974f165b36ae52cb0bd83d53d778ace3c9d29ae5161506b9090075e3f9bfd9346ac0781c99853dc70c23761283fb07367e5d92816c90f5dd462419d30e2579578756753c9cff5dcc3337db29412842fde2792ddf22cd3ea5a85f3908e4f6cf45d8cc8cfab62e391841a492b5b0fb879256d016b1fe3cba9cb4e25b4d48c17cedd98fab0fbf7df5c81e87da2cd14c5e29caf497119651f6298e7d6641e5e92f5075464934e6770dcef01bab0c3704965ef66d705b23146b373cd56da398b175e81d3199fb2e3ecfdd82d1e40003166832417146ff6ca94290f3eb457ee5202244636fbb183bc761391f5b8fc20e54a4aab8299ec9b8d453a10eb0ff91bff0397f5779c890b8729147251f5f10f04455505be7f27e3c386f0d7343be236fb614284b28de5cc655495c1f956d9d9faf6304ef0439a6b538341b006335ac3718b56c1ee94f840d349acdd2dab2be589a19dcb00b2c0760be8e1b35359f9909c303d71f8522059076e96d91737de24b5bd5eb9c5a6d0a34b20cb0a1367adf7fdbb0ca916e2594409f76cbd4bfbbabcf0c662ea127a8b7cbfee1f6956600fb2bc2bfb2faf16b7ddce0b099fe67b33911270ecfe93e23f833eec5a800a72696cc20436a71ca793e014cfeac760430257621b316132534ca8e6bc830a55ddf0f424af402d2abc9801bf61ea7593e78a2dc864364cf83318393e9324c556f973c78b7e9444c09e28ce0f5c7ff7107b37f2bcd7f3c081e9633adb8a5f1732caab293bb4cea0749830685223c8e3c295607bc19f99a47a0565556dfeac67f929253568b26fcbb4921223e94a61c41bf1f07db2d9e3c1e3b15345ee37d96f88ecb382d3c9a07d72a7b4d10aad471a7fc0cc21514a94cc1b606a678ef0302f5a23de97272f1cebd03532b3fb79688331e50e07a2b306108eefa6ccfa0044a7d1f02482c0a31140209d532e8b3e1408dfdfc410a66307abb0ba5fc5d4d9e5bd5c1bfd8f219f51b278a2fb68b170adeefa5c9d5e88936587c2ae060047ff98b4b6d3bc047041d9cf28eb1610274e12d331b050f72c6cfacb840c4915979b254fb13b2dc477ed96be74db3bbb9cb3f58b49ba982726bbfd72bf88aa96e14458005130f0fb7d29f22eff8e2cf213af42df86b97062315b94de704f3345f58600fa3990245ca3da4ab7a46c8e1e56d715e741adda0acc73fd5d42a9b6399ba118f218b30e660b0cba171ccbf8afa6f756b8453766566cf1c664c9eeebd5fd3000a9f2b578a19153a820f580c00bc4c16751b7873e249ec8bba249ffb9082ccb47f9183f111a8a2199f9737f0549da0a1b058b63f7378649a4174942f2372f706b5edf3254025a8470fe772943f74b7794feacf4a215285a2b37562548e72acc6e600530177cc5898d163e7510c431ac31911feb0dfe061d506815fdc053e9b9dcae6e889da6b51258cebc9e7204e1a9ed67d2294f75cef5eb38f50f62f995744b7927448a0e6799c3954425657d13471bda6926a932e2842a6f0274f4daa76c03b5043cde58dd7608bb0a8b5cb1403a75e05411ef2fc2f5c8db6943b9b904d7243628797595534719199e338098d30e1bd688d46328212fdc33bf661c7e425a62feb36e625ffd9c03d87de0946f65b612234952ced2c56d994c52bb4cad27ae4464ac666837b9345f849c166619d7a8f8704634df24d5c4b298a5b31e59a9792487d76877fd2b94dee101543cc6968b9955e1c6dd5b8d1449adab947ef815a86c29bc614101b4ef1c6d3c84d1e6f41a538546c30cc0040d50d4b1053601f38bcaa66a047c4ee2784cc2cd42fdf54f072f9549cceacf6ed989f133ba1b4d4aaae5df608f179e1b75281151a9c07f7318c2fd1090e399ed40ba48fb5c95ed460bdbf6bbd263c3766d61b4146211c853c5cd8b48237b61fc4085b8831b086509872f2583426430aa925e2af2f3a9ef17fe4b9905d966bd72cc153d170406361d4800197bae99f04986021f3ee13afffed528533d6795dddb63ee017064ed96c21bdd64621f1cf7de58f15ae20dca6508e89cc521d80524286f9dd4e47b72e09f2031ca83ee022a15c51219cb85ac404d08b1e4bcd0caa3eacf922d1fe712422d4be4fb42cc519026e2220d9f2acb2743658e614e545e5ed5ee1198abe4d713dc113c85191b6205911eb33da49eb06126348272f1f51d352231b0be0ce3bca6e2914bb0dc80c3141ca3d086598f58adc02ee43e8b2122f9ba424ec0bd1a74ca20b872a0132fe6b488a9d9dfaf352c8c186bb3ed0f8384409c21ee4f8d489a88cde93cf1dc112e8dc84cf8b0f8adeca82c001487ef41c11404919db5b08b94f132635fd92eb00d02d112e016002be52948ccc69839f2492545dc58bc11cfee7376e84ff8044612342b7b8ce13d4aa08757adec8ee986be3bb98561f6cf0290a23224f016a3877fe0283585da27ec178e1cbe11cba00909a776f60fad43051c5be597064cfe608084d16015074f313d8778ea7db630a0d3e3a5ae37d703b7a13e8790d1ddaac17d502827ddd6f5e7071a457d210cc565c0a089155a8387445b9a654384aadb462b3c5243c70419ee0861e3494957e3d35bdb70c5adc83367194412e7d4b02a80c7c8dba90061c98703e41e3ab30ef929e2038e8d256c88aea7bb7dc0276a6de7896aa6224a77c08e2cc4b66aa28f7ebf903e31dc68fc8b920c37a24f414f36539fef63faeec505deaee4c71fff7e454b7cc8d7a09bb4510e9f1f071accc5874428fa07fcfb64814806e4b1461947dca4e4e77163b6735e5cfe6add2670b408600c520432cd182ff99528e63794fcc279eba35ca64a55f3fe13d55df881ddd9ef72c0a5f82743fa8c689b12c4e98e6d11af9498a9c653d46d03e79ccaf92f5605ab0ec18071bfac869ccc56d50f217749f5486fc4f3de2c9b19104d3101f6b2ad53d9e02c3a4bd8320ab7c0b26b7c699369a250d56a09771fd308ebacaad0bcf8e9dfc0a8126c1f44d7ad5bf34bc43a02060e1ca68d3571b59a8924359e472b8ade4c2c6541ee7f22e9563cbc5136cf3d5757cd51fd454218cdd4df5047888c1d7e6459f5259f863f50a44114f66924bd6dc99c3bc11c605140b3cc960d00a114cdd7b5eff863113eed286c38793777c31bd1edae996fd9e1dfa2ae91acd6a37945c431b68401b953150c2d30ee6753b8a6ad7d09e74ff4549ec96f6ea77e920537cedf46a2421363eac973685a45334fc40eaedd26cc70140bb731274593af5faecd854604d615861d743647e35c5460f71eb62b39277a79abab3d5e9312600d07976699862dd82b7e5185c7b66e837ce454de64ecd305011ad2afeb1bb5f7ef32a82a3d9159985c9c24bbf9496b4a851cbc2ed449a6eab9ec888bb2ddfb2b9ffe1a1adca3be1ca9a8d3045ae4ac42ad425e3d09429bdf7b653debb1cb3e4b232ecbc760e0ec4109ea1d1c89f0bca70e95564af536d81c7bf5e9cd41d36bd3dc73c41f262e81019131494bb52fa44e1ba9099ff2e91452ec05940f325dbd72471b08a1640df0319a6c8f721631ea38c63ad1c213461df23134fa3e0f912c8b2d8d907939d5ca6f35b99d13dbb98dbcd6af2d971c3d74a5b3c130af010e0cd96cb75f986f061ee3334986f21f605b52afa8eddc5ec2b7eb7c4c5e66c789d3a58a3b8017069328c6752441370ef7d3e22889b952d4d8201e8a4ee5bd8214c37d535940fb5e5c8d0b2dc234d1f1f1e4924772979a9c143417f5da5be37bd7ab5fd54d9271358565dd92dbb6cc1de260fccd816410be1c5676ae5c62145167b12080f4c447f2a665b96eebde1d1e28e180c9e27cddcb5003412b5fdac15e0b355b8ae14cfd54f8f51e659998728e2800a2eb634aca155cbb3179fde834d4d0d1ea73a9dd1df56527a3d64ac403f45b12e6813758498ad9f84f2599c1dfa39945705c5ae546f0a7f2c54cc6a9b4688736f98000f102fbc7c61b6f25f9642e3d8c1a839f19f3bee090e7ae00ea19e4a20fade0037bf589761ff907abee64eef3312cbb6ed060572066e34a2feb5c1904c27f03281ba12e04b25f1672e827e993d91d3d6f8757d086aad07336da8739cad383f830d3a02398cc3abc642f2806665cddeba14d4942ffe614699ddf5e785b2093e37eb2101313bb2fa366d2cf09577ef84f4ffa641540d9a11b0ef5aa5c2d107720d3d78f053fddd782e5237f13bdc470ecf7d569515a75e23f51b0f8a1d8eda5db25ce7768f359a5875846d52c2f295fe7e35824a0743eb80bb442e8f9e35009e84a5a27ccf9b0799ca37b386da437d9f9d24fbb8e26d1637d80f1bc169501a86215e69dd8b21ee1c260bcb9ecf3c20ae62c8026fbb1e590a49b4f9827c5f7c1ffa510204010f705eacdd704322c5a70259458c41ab9447ff3ff702d5aa1f330cc82db925560a3c59e521d9f1e563694af2b2eebbf07fad94857fa2a11aea34dee1ba47daf80266a23a6cb2c41a2571e76057a46b06be1fe9fa290b713fb4d5d047a8d59893d6fd302e6217a101f0e2137e8b0ba0b8438e29f0973bd89fd7111d38ff5d503f4eea8c588e059befa0858e3c2cc795f01122f0d909725b41581ab73cdd280c3248eac1fc3a30c66c1941cebd7fc2f6fc85418ace0556519c7580fac1d66c313a9e6d6c313b73102d10c1b2192b2bbf2b167c3671040168c6b54741d9ce223f2e9b9143f053798403572286d068d6f05076ec275c058dd0eaa08a17bcb44913c7f669c32479d22a373b5bc841ed98cc845ceb423afa24644af7db0f92dcb9246f7f529bcddcbcc23e6ac79dca81619378106b865786e0ea037e185bc741f640dacb53ee590e83a337dce60a0ebb27a69087d3b5d359292734b72c84a46ec131ad7c3de1ef62c0047b344f3694c3a473ea2aeab5b37f124c094a92ae753e7ccc92a8d395554408db15a75978b4751f2cf2b3143aaff989cbde78e0fa1b14629706fd07a8e47ec87729557efd6429528d91af3d65cf20735564caf902c31a5be36dc273ce7ce77fc1dd27af46e797a4dc4610699cec795e25a0701421fe3380b42ae42c089940e3ea4885511f8a1f8538d2931be02b02b1b446b4eb1ce8c48919dbe33a13aaaf700a0d44a8848e2336efabc71e376853731de916df5ec7ba06a66a7e541707f4f62fac3a4c2cf43b23bb680bf1d2e45a9d762961c471c91f3cff0316993ddcf95eb9d9a7592948c2e9d2882ba86c3e7b5daee7da9de4d721f53d31b69e2e44c221e1c203c4d3e4d7467003e02c47cb6f8cd6f113ae48d2345452d58d2a50f725888745fc8b532ed16d0f91b80d10d26b2d5227a30bc62aa0f1f5d2e2179e3bec60d9dad519c091fe22a3920714310d5fa7aec90fb82da180536dd5541dda5f4859c24886b16acb5c113ef73c0fad0414e9d5e92ad90f8c2669edd681f762d152ad90cb08faaad0a99753fe573501a0fb0a18efc063ca64a21f7acd8cba82415730d4247df4165e73abd62f8a94b4f1e561306f123122d0a698694cb009eae3f54aee8224755e55f16948932fa83f2b95c70178e2e9712d463517283779bed106f99224918a64c33c7155fa4d572ec0483eafceeb88796bcd7035bdf48515f5efc4cda7a24360b995c04567c030bbb8f4c68877f1e7c0fbf371b1f226ed8960c3827e8818b29e47037c40c5e2ef6bae0d14c079d82335bb1d8ab828718db452948b4e3ae25844cb965e00a91cb5556b000586c06676359dfc4f237bb1619d31e60d13b082eadf3446140c5cc322ee8336823c091417fd3f2eba1f9833315e10730b230140c27df4974ab0b73e5e8c9424719bcaa3bc676f2092c33e514e16339752118753c0519b66804343ff9c87175cbdf32d4474cdea218ab2fae95c29862fb138c9218eef48b955ac01046a8d1c30f172ef6c3553f578f34c38e6f5c0550657338a903c5b8ddeb00f2d358aa78fe74a99874734e7c3c473afbd43b7673ba8f04ed883dac1fdfd81284b8020322342cddd4dcf8923001f74d27324e2bab9b02a68de79a2ec357a3cb42b46aa88f66614b26490ba4541ba0c255ef7b15e3dcd387d95152e8a3fcf28662b16bf00b7d1291b4c08276806c98c2a1a79708c35b18dd5dbec2dc456814e0ed131c406b7d7a7ba9877e055f42346c7e0c2f3a5fb6719c18059823a2352f70b27175965cbe4e7a653bb0bf09c4ab26594ab228bd002bbca57b3724942c6eff0dbeb897e1bef6d42febd364f6ebdcf669f2aead2b842046b1e8632654504ac1bca6632a6783c5844e578d2e6bd7ed34ebccb4c84d78b7af4123d9929b2e36efc7bc6d4d581f5d32ff7572b0ab6bb5898a6300e8e518f9542c8986a6317a1805575ddfab135b525daff2b15ac707ca48d0f14debd3a44dd96b1751ae1ac816bc9322a2fd281512f94b363c1632784858b45ee64d1bfa6038033697e5e7c211f81a7f23b34d956a303a60bd0e83607218f4e4b0110a4c4c5b9a844d6bf3e1ad050187b4dd50349602a3ade4fdfd45b7bb536747e6af9af4249abe08caa3ee0d3b0926783e32ba241b5c48cde9b602b8a7c370f2c7eb73f6b0b37838c3496e4be91177a59ed2549539359fdf1a9be4eed396f00ac6ba57587d0fb05d51c22ef2caef299b965bcc94519bb4fc877a78b2686943c13a4fddd20dd55ad545480a115186597ae4d86485d1ee9224c7777f758bd297d618852f8f166ab38b0a179abd0b50ca1dca2ec5e73889742bb2c36bacedb327123a2d4331f91ebad254602faea1f7f8a16fc5b310136fc5028905e971d07383be28eae65288a192d8c47f07e59f694ef8ef8a011a8f9c71eac665df75ac7accfa6da2ad2af765a77142cb3e2afa3ba20648eba26650da8a82882398d999a6b75e75b827a5f51bd854e46b73640230f3264325b9436a9eecf8781cfb22a1d3dce93fc08e4ef6fb6206084f3e0e976b1c39ddb2f0ed5604b3dddabcfb7ab9e29439c5f0bca14b311eca803317e756534119f99cd4bfdb38b87cd73f3c9f3f66c36d56e2b42883e01a76fa2f69b507677dc28fccea3bb85d874222ba94836ddfbaefcdfe7e31e36b330067439a3efbde3eb05fd9e80a6a2089ad70d3301dc4aa6241365eefcf50458e37f82584b15adc13f1492c367528d9825a6636be013cf881eff5c37052516436b51bcc7e2db714123f6b379562598aaf0408d1ddc27e54be98f345bcb2a6df11cf2f67ad38b7ceaf2c598b2e8f4494be841ef4ca4a5bb381cd9742421ffec505ed321a348b214dcde5d99b3110c056100539bcb3958ae28ccbeff359d42271b0a0b3f97e5b109f0efe7cb952388da0a94c7fa47b4111abd80af1f2e70956f78df16e9cf34833ad8e101501a6c6c0c41ea17017408a011e0cda405bd27daceaaa203c354aea3ebe4f89bb77ff8e99183e9531395da690b2722a126404578a25a11b67bf963d032aaca20ab9c9a3cef544d12688707a394e94ed3275006745c7d8899a2340b32968dcf91a4b992b27005503878e27204b312a24b26f86981a232569423d5f7a384a630c283bf269fa65f7dd0ede4baf56bd3600e196c5277f4b0ac22936848402d010fc1dbd50bd69c79e2a2ccbb19a98585332eecba8d2ef25b1f1de2efa126034c1acb74e27f0eeeccaf32d61996da3cec853ed7c2ea79d5799a8c35fd19c8d768e5d81e8406b44e4c73036fde2b25f6c2e9a257b0555a9aa2409a4fc158fb2e4ca8463cd16f360b8ae80c928af2b4a4a3757cea502e0a9f00e07a7882f28ef44f350dfa8b6c74c6b134fc5499aa4e998ccb129962e42c53f1ebdc9474684a59262c67b47eb65247b3cb3a277a7f6aa8b0e4fcd8e1b7d30046f2b0b174536e75250919c29e19b38f163339634d669ce3aac9d0faeb26c3c5ef20104c987b015aa9cd8a06584c7a0481d3d3848334a846679d5612fd52c2cf40b7f54d03244599ae276bc0f63ed6ebf72282072d66d020d40f1b4df21e4ca00902f2f8afbb4f9d61f543f9c2f0d75e97c25e5e706ff48fcfb275c2eed85c11b46751e69b549eff78310a8399c110553a7b730fb66f081043db515b9e2133db4538559e628f76c1975b24192a186291b8e54b8f5359fcf01fb8d091cbc1e772009de363b5c13bc44f8b9ff653dbb64eeb07cd6a72e9e182e5b4d74aad866c6ae765e582a99591de66ab7c5ec134acb65920744193d78784afb6575021b8e4c6a577e7651e6d650dae7610af04b9897fca26ce7667f5277779049bee56684f88f5dfe429966c6ab56519044a364d0cb18a93cf20b0cdb32ba368f8bf6095fa8a3464db67eb5077409a6ad3475f390b6db41b5bb6b7a281742fda7b3385fd20dca5ab80e3107dcdf336","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
