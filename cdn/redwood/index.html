<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b80333f3e7096b64d674dd2d85514f1d46ee468c0a6962cad975e32a40b59261f9b7eb0d37001a5817e7072d69ded27d1627fdb3c4ad3ec82b19f6ff8f61595cb3114a9d842db364ae4ecc9e165611b8f873b6da0b34b7f5be1ccc06b111ae2e6ac55e1f385557bbef08b7cca64b6e3d1b63c499a836d66fb88ff0da3332a741dc75f6bfc38d1faa2d9652d860d3ed6f313f18e82ef3c418bc062966dec77c18df110f146e44e1c1d1c8792aa1c2031e7642ea55fc174e2a8c6dd0f090bdccc361f9871556974fc9e6770988083891f17e2285685d2e6401d347c6eb3b341b79330117d9f5d6b08e4991c54e97a3bb3beb70db55d30c5089ba685488bba096ca42c74c08f420e86b892f416eeebaf4bee5cc32705bbc9f508f6e4661399cf94e57b9917572cae2a2a339690e60550bf553389d9f16c2157c9bc9cb710e3f24d8aece582d8bc0398ac5433dd0619040b260f37f30be37ef98c67d02f1083f60a20c7362a0b5682c8e230f61e0adc5a13654819c51a5887098097124917e188cd33d0b5e32e71742669dcafd1e2aff1b5e35dbd397d80d8fba45bfb8621b82d0db637638af0999c2d91ffc9a9c67b04b34888d4b740890c2634c35996bd7c3b1220898e07b968febc4fbdd493092bc8b2ca766819000b62565113a8793730cb5a418485fad974d2d5e6a1f9ef4948ba42bc2bbf8fae4dd6768b9064f72a5e59682d0f6f7cd9a44a82a28123bfbf45baf4578d2acf656907112a3dc8cc8ff3188ab192c3202ce44368f0d6dded5025c084f4969feb29d23355e62fd0fc35958318c98dbb2565b29aaa6fd9f281f54eeb66ec95fa4a4ce3985b9fc7cdabc29020b1c148b685b9395347323d44d2cd62c643893a74b2f956418278c6a5ac3ccd2635c304e20ec1754de6fc01a4807d01007fa6c644f4dbaf6fd90bd7f091ff2632a3f4c91a901d7dffb5a5e65a762090db97784caff077f9154fb9158708b6c10614edd0f33e353537a2ad0a009d1deab0f2aef4534380b4a731742ac4dbd46a2d34cb2d00d26b6e28067f6292bdc6596d4f1bec41133c9067032ed0b39481fb520597755cc0a7595847c23c3692e9e9cc3edc749ed09cbc02a5e008d1c36999accf409eadd497e9e6d93a19c3fa1421ba79c792987b7f1773e8ba2ca6273772b03ef451f987348d88f2b5aa68fcd5dcbdd5bbbc9c434281d8caac9cd81c325f7b68c675e3454759394569262400020785f76ca45b04ae0c18d3c6b4fec275fb5b44f60fb6e359a09a2a2a78889e4ea7e67e5366411ca1a80c1c1facb93a2758b15fdfbbc2874b78c296b6d0485c51cc7e743c46aa67e2fbf432aee00dad007154af860ac1e9498c827760997f80605fbb9ef4a84e9b34b803a3845c48a336ab9401ff065d8638c6f697ba6bb7972e11fed93bf17c613c4d7763f52dfed0412e953646d27700008db7ee528b6291e8fb1c81cadca5f730c169c06329bd327f94e863ee9c36e16b2086aaf98ac001412ab4fef204b4647333a3271dbf522135ecfa054cadef5e7ebdd25115cb17c3894dca2d2b9dff4c256087140ff886efe39e37037d6315bd90ed79150c2898f4c363580ecd9847c3840bcb39dafde26dd2b2bbaa9438a799bcd3e14caca5c69c03b14c6c284829fba9603424586a0b75a462b2ab471676cff75ed0fc4185b53b10e8ff3b5549373ff1297475a02a210c14a470275760fce3f0f329b3c9fb07a9137745531ef8aee6e6d55fc1ebc28bb12418191822f018e9e52b341df097c189df48173993c31089b5aa901bc5c24701988e3c3c78b4bde7f66abbf44248f6544313f242b97675a44910519b6553ccc9dded16ec5579542ef1d641998ead3d151a7912e8077b555f6bdd00060030f38bfadc9a42bddd32c7a0acf1253dc27f80cefd70abfc0e3c116b59ed5373f6d082d4623be74151c3bb7363168edf00da99d4df10ceef43c491f09af9f6f1bc595264a695ef451bfd93b293a28ead579b00dacec9ae875d07a85147aeb9dcea4feb196cdb95ed784ab501fee73ee9eb6898ddf5bad7100a2d3818b11814c4cf2c415ca4019e7908f0aee070ef5f7535d63c54adaf2c865c3c2d2c2691a096a8db08d6cf4453634b47e935f0ae67263aa4da316e1d6c00b1c6a74129bb79645784bce0009d7dfe66c75a621019205fd854f137564f6472813fc76767ada7ec30e01b5a788664aa0a0c4d97df62e8534e2b416bb759a6eb5db78213a3e5a53e422608da0e4e26ef5dc04e9db3facf111764a346c376d1041f0bac918e50a2517623644c49888061e47f5fa865e5b090dc43c779f911666d8bb3605fbd0eb640b07f9b0d623162777eed58243e9d5d3ef9a51ab92e461d895d0e40606a598f7ac465f4afdbce500b51b6476a62f83a17b13321ed4b9ea2740cf7a292ba41dac4b8db485af907f8d1dedcf0cad4f96c943870340d400312d52746eb6e280fc6dc60c53e654bf56a07eedf28bd2afc70048eb778f1ec1317733ecf25eec513c0b43a9b198063f2c26765ece611dc3e1cd0001070ce8a21caa7375bbec900058614a837efdad2df798a2ae02b83126621f0ae705e875a3d907e4a0511cc8fedc128a6d31ea105fbef69eda63b9a109525a6b13e93d0a0f701d7c7d1f51602a8d39b83d0711c8306852d20ca7067c908003faab3c3134dc758fcf46df89814f06358d9f965f68d27702243fad9e62bd561e0de7cdea5ce5115718927b0788f88d17ed6ec74770a99e5c76ed12f2d4a0c5761c44f170bddbdd06638b16c79cbda174f859a792da147031a3a2261c465be3ed35e39d0b8ea251a7f26c4cbaa9639448f2482df09f0afaf6fee1a2a6c9d06e11d6056db446114942a95835be48feb5056586a41767a734b0222d15c6065f1233571d6f7715d1ed2c1e7415c324138bacdd3d331b27361c32e03f3d4ac67af0579de1d16f71026b0317bd9c58a31e7ebfdb05b51baf121e6b06a6af3ad95961d6298d8bdb3782ea928b4d1b6389890cc02d49e27b2239554089b72745c44f18975b9ad7dbdba42c35b5a47de3d2277e8078a942ea3c782bb395f93b49d3a9141cfa95089987045a278efde4e7d1a20eac46e6f5dbb41c54cd460999cdb6250014606584c22012ce1b9eae0aea767c634ccd6b0588ba643589c4061dd84f3c0f97edaa8010f13dce1133f0a3716c99c4bdd454084d16c7126d636e880c6c6fc1d45a70e33584a919d41715992a4e1f357145af21830da7aac3ca22e97e9c796c37193f2ebcc0dfa9d92e9952c0e639b5d708bea11539c172c06b83ce4a20a710522298cd4f3bad1f8c528bb92920fc92c64f45d784e16cf191a726fdca56f37230daf15b8ece0d99d761744386df83b65bb56221b737a689154ce09ac048cab723c3b818c5edd7d735cb80efe930e53abcc95d5904905404140df90a269bb228455147201139679978d6a8c81f69871a3716ffbe4fd0aa861a595c3485512f7af68968d397c623847e3f69ef1d33ed0ad6a555a09cd8ba02f5858b38ad2b5face5743903e84d49d3d6fa0532e0e5d2ec9d01ea2333e10d2583a8449ff0011045a3da6a4a1c9dd5eac6348e89005fdeed86085ea6fb7111e1b35b655d19e924fd736dc5c60d131e270a7ad608493440a9b73fb3f06c2a40bcbdc6ce7f9eb2f24033c5e08292031d6348472bad3ec272f75ed9a92012212f7fb240edecf944d6f9e74e4a45c112b1ccadd16ccca7cedfdc9db9c9f01c34d4f659e41b83b684041177bb6f09298c5e02a87524c5b763c01c388a8f3d51906c281d63cfbc2eee4eab2376bd08afa1a4ca49c4ec9efb761615fe25308ae960596d37fa096c280376813387bfb800d6cb3c641dce7c69bfe2d168f632f633524bfac1e7192b9b82438c0ff848583c7c5a3a5989dafeda14e3a555006aeb4d20cc2f78236f6827975fc29e2a81cc7ed61819b3b9cb8be9e60b47e301df5cc518ed313c3932de9d9c5e287912fad639eaf97f8bcacdfa1c32f7e169d622cbecb39953641c198fbc2b242905a40f1ea06b19bad606ded07de7e6546840705d69f4fbc1929076fb1e0b7793a83d42f43bfece57380b2c067ba2aaf3a438e75ecd865a0cc28f4d43327507e0e60d162c4867e587c274d40465b101f6a63c25eea1d3b95bc5c455793b27c3fe1558a05be4a60477abe4841902c6d020d556af6e1e56c9a6d08c48f714face9bb1e3755a25095f472362cb9678de409a79f71ba98b30170661003d8b7c6fce8651ad52b702a5df3ed55a5b8b08431ac97f10f806c5d608623158eb1e654703934de784181fe0be2745c270bb8d1fdf343180d42e00f0765fcb859244b7382661ec30b73f44c226bf89f0a74f63a0a4679a5997b4c56c7c4b667417f57203efbe9bfc7597755daf843f1a8101ed36493dea68db3848aaa5a71a442c8ae1126459feb520596c88f1f6f0a27f76a1d273e0ee1042b1c1d9a95a1d112509a3a53a1c8c73a0fbaec21abc3ad727bbb18348df41efa48df737cc1828bfffb279c27f0baf7b2c9fc8fe1b8d0812ae86f19df01132552236778e2dcc1ef6ead68a670ccdbf1917229caab6c3f82d86542f7d062384bf40e93fda03b03c5460cdc94c0cef05b890b67c2cf2c79d81e6520b3c8c6d4956a0aa48916b3d8286d2a512bb1e056e08ca1b21c961ad7c6dab66b241cbdc0f19598e06eec278fc38c681c08597dfe6637adabd82fb617f121355712ea1caa568400a9721e7b6588e99a8b7b7fcc2ac1a765bb781492b2845c46b0ee34466d364c9202073bbdd671068ba501f4311fb845403f981fcea73505dab99975b0460f3b7096639096d38ebbf2ecc7a67a3dec966af30eda07b0aab3670e63d0cac2b20c10394c7bf004fa64a5e56e8210ed5b7b9d7608d24b0d02626c1e08dfc9ae124c35532dcf50f0b539dea9c954a8649df7bb08233ffced59ecd2acd72622278dcc44ddf923194810a5790f9269ebfdefa581deb3b2cd38c5375849310009889e066da778797446be3239ff8550020c9f6522afa359b054907de46e5ef697d3b65f7688b09c624e7337c8a541c99d7f95612d65e080e36ce0c7f67ffa0e1925f527f75b991f76cbad455e9de7916e3c71bfedd4d19f3d9f400857b5b24fef1fd6cfcf6721fada633166ba9af7e78ef6e39afd31abf4356904b8972846091952dc4e69d0a4f0658718d3372a7ec880cf3746e67daa4a666db8a422e6df15a476c178fdecdbbc2d5cf49b9f3d394b67e5b3c48e3c1948545fada0e350ee5c7172d51d6596e7d6d229ea1cf5ee4417fdefa4117ac137fdaf5d18024690392c7fa327b859a4fd937d55a9cb9cf540fa528b23e2cfa6bad196c0c14677d37a7418bc70e6f61857a6f2d3d46b4bba5115e525ce4328b8640d78d819ac3f88a3937fc03e6b6ceb7b2acdfa6970856750be0ca0ad325db7561e8a640303257bdfbbb55e02405345e5071b3532967357661afcdb6636396ee60a7bb44635ede4d8ab6984917a98355da583cf232901ee8843ca5be99dede98aab63d4ce3f8b9dbf338c39508276e1d09e187c61e8a9426fe92be3f143ff0b7c6a7aa350f6a0fd60baf61eb5b203e48fbfe7d80dc4f8b7d32cd034f32ebf31f4e1ad2ff65a08badb5dbb50529305b7a245a292fb3045ab87d1ae1f1c0180db86c30d865480ac36a67c56535f113a7c841728dcc5db39c160916ccc8c3ef4e20aae5e8bf008bb69d762faafbb5bd6f954dc9f51703b3667b99d339a6769e82b0bb91ee1604028e4b90540be3a54056fe2136f06bbb5483ceff31c11492d150b1f2a8cc9b1e2971fe2abd9a400af17d779b48d514ba49ac4269d400a1182e39054b3860e4a76b45478ec6c79a41d5bdd9786cb05badd4c5e8b45c0dabc72975d74d9b35f4da74a9c00ba5cfd492d541c1ae861f3506b772f3b36370650feb6fd3486f7130f5e9106b55edbdeef4508a5c15a20b5226bb7f5c5a4893c667813a349c30e3508305271f979d4143af27f7dfe2b2f1c7c10b58924c1628837c5e0c5afba9ac26dd2084e43cb7e33dd8159b3551a023acd9de7a2dc960c83c0a3e7430db6035802054100b8505f274875bf226d9b638bf2806ad033827f9d9b49ffd0593d6529ce5664ea779ae4fe3fdc582b273f6cf30cce34901e4a6172ed0bbbfc706b427c880c532dcffbdb641075576254c1c7efee09742265028966728d4a003af1ec6f1a7d6c3b8a8659016be0c88f272f4b91d9364f1fad3ea4c105f095608c8ec5b5a4300f7c024eced406e35d758e1406b065d47dbea0652ce3df2753f3fabf5e285705a98e933c0f3307f105125b175113bc8b278334245c9eca78bd1d6e8590a7928c465d4df4a106760b80bc853bf8496e8301aa0b625a2c47b9411114d91e45cd33782c5ed3c6148a92b353b5beb2bb6ba21309d31c7c0f374c3a5a8a661986a122cb5856ea230bbc53c92f6a4daa31b5e21a7dd2cb212890453050c6f6e5173bb256925303819f0b54d3a55de0720bb9ae4988c2f985d1083479d569ca7be676a4d8d930d84fdbae183e45504c4ffcb0e95ec3c072ff8aa2b81a9848b5051b4601633b6b6f388d6d2eb887bdaa952750f164317e91a40723297ed497bd07fd44419c029ee76096d45ae86fafb4dee72fd4ef2e767be371785714ce6bb3317742eaa8a35a6d8e38437aa472f82dc23ba9e0f34d73beb3ab6e9a0951e3cc24caeb27e479f0248f2a6f153b2e956218ca25af6912e4c4b861763c52510ba3ff11b36fef4bdece527b6d68fa74f4c5555e82e393a17a7e20f91283b4c7a35f58be261a9c3d1462daa173490dee468b58f271637cd51bf04ec0378ac52897f1e95523c6c5e9d7bc69e1aede268568750bdc4b583c2dc3c2d14a6dc2c4256ee6a6f9b219b91b747c7da0d9d42849ced712e0faf8486a1503919cf937088b5aa8737d2bb51cd9c31f6176ceb965c142f31dc577a74cfcd1c9b317ba0f7ae4c689e7267826a215b55ec4fa22cae50c60a3d57aeed33d0be08a2c29ecb8e5cabf1be2ed235862f4469592816aa150462b038bbc20c0d0adbca673f6161ff9f97da275a771343239c03ac6cadbbf2b4bf292906f59bd01729817d406c3bc8ce5407d05c701dce57e714fbb82841a77543b5d48d6a0343fccc3da6d28fc2fbfa6c6b93307272774a8dd7dd7f1868f9681e779a823c71a879e3d825941b26ef33cf1e0db44d133c77b74aa0ff09855dcaa927d70ce06287086c3bca4cec2209479c51d20deba01ff2735081e316146aa6db27d9e6734bf479b4538c84b07e8c44c9ddb59e97ffaf07b13c9363267f2df8f9085fbef238cfed780e7b542e6f39ec6aaa6ff213d3715087403a1337d37dd20464a43e490da55c7446f96ba2c4d3e7db7731ab1b4fa1510a7431689613daf05a0198f757d531c0a9a03f71eb9dec78cf5b4b406e2d23e26216df5316135de1abdb8a75544ee05c92f937ca273094bb38a02d0e0ad34820b9ca551e04f0f2b468d410dec3f6919819bfc05bf98e78051bb29dfcaa3b5654b9f76391c859f0b69c8f77d2b091c30b8c4743fdc5751a8d14deb269b95e5afb681f3a4eb6036262d9e8236e1b81d3aad303ad6ae29d3b5782c204c911f803907b570928bb3cd61d2f7a6f918f501015932b4c1721d6eea1369931996bee8e4fe3141144bc359e0b7a30354f02dcd7594fdfdb2fedf278f7a05d5fd1a9ed6cf451a8c514d43eb84d7bac37a8dd1f54ae49f4d7e1bb54f5c4f2a65978fba6da11eb07d9026abe8515ad312e47bab9a13baf27a2f50c8ca319abb25493b2a384cd62fb6396dc22c7d883aecfc1a144356c3da6efe054c3db7052c4e135547b1d70f0b9f58c77e414b8fb35d13a5ad84d217771f3ee3cd93c4a5db7d3cc67ff994252f05f55dc865ebc57b1b51d880a62e801498cb130158bc9ce9cd0f7093248066092b215a199e2c8f313350ebb0de3a05c4d88579e7cbff96025114b1b375a550a3d293a4a6eb4b832f16a08881d028bfea3fb7e12311ab39f34800c468d01ae559d8bdd14711824cff778fe7846f4d6d8a0362e879b4a375845175929140bb0449fe1b2c33613e9810b8b75ec3de98c8c7d7d9947f671c5e3a32a02e27532233726b8e2ec18dae80c179884d9729461d598d69c7c7a17ddcf1dd7ea8c8e79346792bcada8c19987ce0d75ae4c53c3bbc08f1f37e2fa1cef1fd44b68b515b60e1569266c2c1af28df6fe6427fb6bddc1fc1d7ffda382c4b2953501ff902e261648d3c15c6201caccc75da060c95600511ece7291999eebae62d301f9f73c4c0cbf882446c684bc31f9914f79ca135e3b2012a33616b735ca361a4c757ff2f2e4dfe540d9addb86e647f16955aa6362d0e05f274756084d4ec8f39718440453b65ba47be4fd9643f560094ac6d3bfe92127d08444d6630334d1e10e1e7805bd853a9362ad31ba441c070c5fb7aefe84f4b02bea5f012affa6092a7475bfe1bcd984d60b0849b947cc9be88d76fec68c1a0b8c4c3eeceab7cc9239f32d3091d77cbb347e3efb806f3177ac3d10a1abcceb3e7798e266c9e516a7af98230d01eb2ff7b9c00e85e7fed664d362bbc82ab080402f3158bf34f2f45207471cd24508313e6540b110f4f5d106ac7cbf7a9cf2e0409ad7b8fe58d551ca094e847709d3722eca92e005d4bdfe26e7a3e6e065d7620272ec44d2cbec264f909c5bc9e8ceec3737588ad4468b263ea86e3bb5963a22603530979571759a63c3e3cf69f3cbe1df9091e55103e1f6472e0d16d79cc44091b061f9870857b5528d537a87f673314cf3f64c55a028c7aa31f6eacd388b045325dd23eb5c9ee3911788068df8fe04c7170a22a7224c8d6f3e776b3c1446d6138d14d9999a7a7fb7f2188dc5af05c77c42e7571b1a3c0c458f95257d6d3c811be4018d074e7d29704078eeab9f62dfc658c95ac77ec79059e31dee3f107998cfb435ce00554710d75e209dd386d51d0417b460740d50c69c9d13498ea8c42c9dbb13a692480fb0be2095450e03f5d1775481f919d050c54ad256474f9c99da8a515eefdc02a268950b715926d4fcadd265bb9a36032dbe532e1c7015863c402bd5c7139cf8a7e8fdfa2da1d9525c5643d074c76baff89ccd177027c4d7e20fed0a7f1af4b6d8d6a49d22155d17e8cb1d1c5b9c130056f57b34d42417e5f5ec359f6d3c929cacd70125821cf045e56f40156403475c1832195763e364dbd2f8140fb8a27b58a6f22bcc5b4926760dfeff57b4dc8a9bba2e049a2fd917a3cb7b86c2bce3811c0685c4979cde22ab6ccedcd30a3792178fb646e5b2fd918db153bef03c347fc1a214e79547a81f0e39122c8db849f5a9f416cbe4c0c6c4c65a75ff913d275d39ae011d5711233e8cdf415129ae455eadab6a6cdf51d5191cce4e366b06aae3ec34e055fe084857b624b0b1c2e11178f7f35d88a34b188e079af3bab384391090967adc952d3cde2432d691bf49ad202d54610b95770010b87b0f52406c556bfab15cc00e86629f5855d3755d7ac0f187daf65f89fa1a8db66fa017ce28b07f688f89cf0033c8aafd788830af047b8570a888df55208c9fe666328640d873fb41867cbe71a8db023c29f17fa7c7b8c5a657b04a8bea450ee10ff46f893a3924bc3c86f6b252c6fe2adee172cf9bfae7d4d1adfb77a2cf9c2e248d1c620d6db28335465a5b6a150c524a900a144fd9b527c0af994c0c99dd703b71894e1f14c91c6f73465f17c8907b0a81319ea79c2d91d8403dd472bc37af38ccbefb56f924daeac93c53f21908f7a828aa97ef2505ea4dce069a67327f3aedbe9b30b70f43b1718e87f84a2694f9546323405e29584f2f2998bfea7380552e438c23398e3c95a159de88c9e9e3707f114b28db6325aa4f21d23501619c49d4dd45267b8c2aa6ebcd1e698bf0d221cf952bc6b1ab9320a7e865a03e5bb7ba634a2c5663d494ffd15edb1cfbd8dd57e71c2bea03b8f51c048083f3d7c0aecebc1adfe4567ca3f44fceef5b4392653b1ec2a1e76cafc88bb4845041bce0f5547b6fb40ead7ccce890ff2d67381c22fb87fd1cac1430915ae36d48011dab49fc3ab93308b81f19a1339fbab0382148fb78fd3f2453d9715d3c1621c309405a4a4edd9156094a627b8de234d9ab4cb11aaed4e79767463c6b3f8e117e01f25c46739460ce47f199f76758755ba5084dc530cb0662b55e1af64dde9f16467271df558dc19e04db49422b7ce4ff7d0e48865d8d0a51a1de211e69c87b36073de97ae8e58de03e725658cac2c16d1e94dbcdf8fb755f5354ed774f23b55d618606b837a063147b4341d99de1f27d77bfd4be3e4cd34cb81d61b4d5cbaad726ab8dcbab7fd3bef514d0e79c6727b17ec550ec3a7e8d49994370f1ba2164c54f536c32cad600ed61cb8e04e59bdd7ee41d1de4a890fc4b65862adf740b1838ac1ed3123614165addc00200e10fbd509eecba80960b1cf80cf62778db46dd967481b2da61868ed25af0565ac3d4791a0f95417ca2bcba8fecf3d3f0f9d11292514f4e8553ece5f3beb93c740756956a2175a6ddbfcf05c32da28cbae54e55de4c621c74638be3fc5b52f38401efc9f21ed86f0a52fa4cf88817c1af91f2c38e8346b3de168e9b160c2fdd848325559019f13344a49ae6fb44d0b7567deb60da8af6e1d1fa130c1b0ccbbd822f5114bbf27471026e8f0efa18a4de088cf1b93a033358aaa9a828f966b9d3f569b86225b2bd16d8760060c3d706f154d294fe510e56d78c484f68a1bc747f0d41705f51e97e588755c29e2f19bcf433296fb5072044761568f0b42742d5154cb39f3d2601895fc59fad17143dc615e99bce3f6f046a9381e6b075b09e1ca40201632141b94e7aeff217cae59cc5b67bcddd8f7120c8ba5363dd7f1e5eac008ac58f0e87564151cfc22edfe325151aba04dfee5cfec72491888af606b03d75a83eb1c50a8d1db1352fd9edcb370c23231c66af60b20ec4f8f37ff1a4d4cc05e79f1ec8a69c0b4ab56d3de4f3fa71d15ef520a02471708258fef81b197aa0843416ff7f8a3ce674c109dc4eba935384c6a4e9705d7f97e06a3f37cf806bf60c861660c029971334a771b65c4267d79fa2f4b7cb487d54f8a263e88ae3306d94340efceda98506f0b8847cb5038978a0475a59fd6912288f6f208a66a4ab0346a5670a91aac46597e8f41a0727d52388085e8d57c9406b04a5ab1f92d75ffb5e33f70a9ed064bddc91b5d913bd5057c9c95ffc88eae545dec64a4cfaade2413c7c6eff96952a1ac69f3849a2c3fc2b5adb34924868e14ebcf6d3ca123f5567881aa6e3da84a96505992be88cb3cab492c1f9d8cb1156903479ccd6fb002b7c5690e288010c8b8326e804c17c36f65825b14c55cef431866f584a6859cf04646a3b8702dc5aa6ad325b08f9fdabbcce933ab46bfce75a73ad8c13de64b8e4befecb4a7bc62a2bc9fa97208afafdb2f39d8aefb1802582a63caf2ea6928e00e3051c1fe0678dfb022373b280c26ea1dee4ccfa1b36305e2eb2f8a2fb69c9b87971a40929509b62c447a7469f83d9eda773ad65075085e350c1c9b62ba4ab629f3e3266bb4f4603dbf22df432993bc8c08f68bb5d677305dd6e082cac71071254a6937d7d94d353c9767655d56f43858f1f2ed5a86cd28f0c747bb34c72b2c7f197e4566d9441b0a156070945c23246a1a95b998be69f231a3c28cfb094d330ea68d301a0555e419ea9ad22eb19e4716a233dd8482c6ab830f91bc71f4014f147d836600e9e6b2e531ce98dfed4ed55bc4c8744d9b073fa18ac7d707f0eea9fc7247601d3e5d029c6d6fe4e1b0ad5d097e5d88b086d7620938537280bd267189e555a6038625caa150a2a50b897bcead24427c38789cfd68698cf06df68d38cadd26ea6a7fb7f099b0b0dfa9b0c2e97626bda8496f183bc3841e07fef2fdeeeefbfe46757427d621041fba76ff760598682a18472876e3056fb975d1345e814b9c3f522ed5c87ad98dfb0d9cb5da6226a523d4e3ad77a79db3771d312698eb676c406e08874a69dc2e299d1085213e25e1375f2a2d9dd759d3d9739719c62adf20164035a27c4ecec8ce08d38d2d3e26611905942c6921f2d8aff2c5a6a68aff0dadfeefd9aa60b2f5bd9f3eea8cdc1f7a2df5b74e999ead946ccbaa1417a70722b0153116986853f0bb78e64ef431a9facc5eee034896703e81533aaeac35f32e362cddc6ffbd224cc45fdab67c1f9b7e7006df08176a40656119e78f275995d6fa3b4f5a2494db0aa97f7e733aca849a54186b6d09803cb1f127d2518a085a1cf6b0c1957e98360ec50270aad582c858c8e0332dfa8798f4296c7fa92287eb5030a6ce053e92499d570b97ca3c382d49ba1d4823ac5c2bfd3998607586c9902848635bff930c905e377fcbcbcd330b9ab9929b47fc4c7d3f3830e2773ba41027a3ba067034c16c32d46756a4bf0193e9816588e7a43425660167cf46ce410737fe401283c51bb8cfe577bae5a254d97bb24bf4bfa7601a42550cc97c17f632d2fc4872b9511f5c912f32e8b0321fcb924a00c864af5a79283e3009ff1770a5e61d221c91d42c741f753bc94ba76cafd0d31b70b0e236661d12c29c47b164514958e4af51caad087b682085c2ab881211bac32599c6bfa862f8183837ce125a32bd3c2ce9291c2d4ccafae66dac6a748be1d06e2f1e0a42736945d93af695bbf473a07d8816e82be5a2b1c4da3f627754f1db31eb4db762274bfc00fe1601cc59b70c9184b25f48c803952837fbf51352e04b199be278c559295bc2e342cae2e7f1339411a2b193295e00ff8424b79798ed3052e5110457d98d1bbcae5c8bad0a08c5e78491f35a2710981cbb97fb93b76e6fff5e162362508b9fb147de909a2d0a0b4fa029b1c39f1da1acf39f6dd72a3c5c63636f2150e545b502511526f00fa9183b587363e6c0cd2c0cedd7559bef90bc9040c58e7a1eb814d3bf69162c94c6183a03bb75b6c7810e834576d483d2723bb2b27e5634e41406246856a3f907b7cb08c73f4efa0875a4aaababc1f55b12bda9d5dcff38f0d12c51abd0b2111791f4161eeb5288d49baa75ab35cce1a1684d372d1b3507e3ebe0c2dfbc18f0082a297e2d3946a0d13d53b2f73bfd3f8ca9ac05ea19f5b2a912e4d1f45a76eb93e76879e12bc9c8d0b2b4cb2eae40c3d860bf615e0a910d0b758d8885ec7827081a199eeea2732ef6c04c9cd9ed8d1a0cd3d9373347cbb33847424e30b9652589f9d3db05302d71f5db3e632a7e277ec3e95ab4e8b01c01d2f65e4eb82a391f9262aaedfaa6dcf01966d7eef167e4d325830dd3e687438f6b6870b6fc4fcf4bfce3af32b84135a3313c229819862fe020ffdcc2d98d977a6aaf615d6e06b7670e46eefce72914aa7652a204618998bd2723a78bb7fa4663cdf2710f17b6f97555278ba4797219a3c5d3b8ecca6995d2c04dc933b5e55e34b4f9628c7bbb76532f76f6a019740c59c41ce65b338e0603e9dbdf2c80424cb55668c0f8d27430abc69606ec0d4600799ac0cc853f75b2b8eb20f5a887ef89b958e594a6072a1a7a46f4d56e08e283e9afc3dd472f34496f1de24896cd4cd7ccd1de8fd874450c03ec0ba5338c04701d32e84e81499f61f4a86fecd12683fc9b10bf439fabfa634559e1ecab0d8e4f8cb68df6e3ca0c977b70c389a49b9de5d23089c2c8172d324caaf078006df05fe87df5b8de6812b18a7bb2c6168df3794584d44004537cd23a8f2a7068561893b9d6348048a54bf67997368e45e4a056b0e8ead709b0f964bf103f78849bf16e6a22e20aeb1f8de378f5ded8578a9b2ba54b43e473619c3926ee27a35899745d35b8300c717022a388368f132ec38060e477b939cdafb333a8998d37a9abfbd67efd2aa068dd9329d5b275be21849c96d82888c7efc6213b79cc08ea9665d66d48245afeb6f2ad5ebb1c527690cffa989fc22390c037be0c202f940237d1bf09f55e9c56ad9b0779178f89a3e426e5d3f0636373d7b24502292bdb92634f0ace859a6531d0f95c7c94d63c0ede11fc5cc4d0e7b1b6279f17982e554759c2e7bd3d932bc69491d6e401514d4da418904e1563bdc2f259ddaac40a82b9a5a864eab89d2c6ed8cb6248cb86b40ee026357b6f0e4dc35bfaee260594079d8408c94aebe0a28d2e107f1eaf826f166ca7e700e05e2bccdcc9749f78f35383feda2bad892c133c489779c56700c397daef9f0069d6d1d55e1c9beaaf9bc103e4423c64f003e9adc78cf96e6a27abb838a5e486a975740591738063b66fc851c9d5ca714a88e2c0d2a88aa5c5f87f5d2d65a4ab75f50349a2a2edfddccb40b845be0cbe4544f98cf169a626db7031d50669b585af90ff180d61c328cc044e1c4abc03c38b907f490ac2fafb44abec989be4ad562223bfc005b9e28cc9654cfccf2539dfd7929dd91b6fd1eab14dba33760ce0e3e9726ed6666ae01a434b160ff68678b7a2671a56e23fc52c2cc99b9bbb6b7fd86870a57386c87d81e4bb3a06838a227e3ab1f3a75f38673995000466083efc07f781f31f5f695487d9dd001438de0131ee00fa2c096afe655d5f4f6621936723a1e6d86ee34ea28c87a73b929cd1f7c300cbee873930452ec308c11cdaca944436f4a94d0d98ab58b3e07d5c4d60fa3247c384c170755dce3a7035f75e6f825e7cf36c384e131a277dcd6332810f946600b543b6e5a2e5770e1f3a290fe0b8bbd9c39e7fc597f427ff8815f141476948b3558a6c5dd56c8a356bce468092017a8bb3fc85682194e453b9ae692cd37a7a4e38518d7469c24c0b131a64e9a0314a6b3db4a974e5c8a236f0d368fad593911a1d9a40e0862db72572bfaa1a5e78b0f17b8c9d05d8d483a841b47f65f6f9710dc2f88bbe61320d76f88992debfa46ffdd3d6dd8ce11d89bdf353cc39f48f8c807567d88cb0a79c65960c44c366902733584c1f86b7d9aee93384bf1261e77b905870fbd61dca18485c6dea5d6a9eea86caf1356a973a44d766c5815701db394e785b351e76c046a718d06a7e93dfe688a8ff5af6cf60740951e2b530bdc38206087e660a03ca6639b31481a3ba626505079f82986907ba937093273a262f40b06cf2e75b228211847c4bd7fff2d14fa9ba78cc0178dab209a978a97ad06cee4ed7a7c33ec8e02aa2a772fcdcbdd1a9b1e11a76b37ca1273a2ad08d858cef66c6e3d60a7e096ff17ac363ebcdf7546d02a2e32b4fe7454d9e9313d3ac3a6fcf68188e23ff1515f73850f1ca1c54c8c745e4da402e34c7acfbd600a6ec6cb6553c297e81fdfe2e98b3882cb4a592e76966cddf23f4bfad255c7af5917ac788e1808214c044c1a9291bcea722d9d4761605b90f1377f98b43c47d3762dd7e981559db53596d6e239e9925bcb8810c0acd9cdc60518fade1c33281ffced57df4dbdfe2473240febf35449ffaa969f646f6365c6ec687aef9d34261326c73897ae7ae5e04bc37dc139fd9417580f273141477511f63862e6a79ba2b3d0d5fc86907c50d6e896fddcf5e61c066120e133f55630ef54168c2f3cb205193ff7b5980ee58d7e3489ad3021b6575de716613b78862904156905c9d0458663ec629d92061f21a5bf00262a88ef331de059e6b8d828b310f615dee1b1ef30ad1a2d5fed2d33d025ab3abe83b5426a89671b441d53193162ba7e93565628fcdaaa25301e1cb753c10090cebaafc7b33c9e48d7c9a0e229b1d226d65b8b3e87e7e2c09dcd1321067cd83594d7edac4dcd02ae7fdf410ee29e3a6e9901c0048fb2229fcb7d0a9618a8f37350cf22bf97982196538b8b2ff686bf3026870d9835b51f41ba9203cad5ecf6efafaa758ed73dba92c699de4e2f77f107acbed16b41802642d2627db12b53bf3a7319ed38c24b9abc38454ea4303ec7c6c10e4cb1b4e1c867d8c547ac918899d5f57317748826628956192533748855e6107c2e4aa372ba6d3fe4f25befbd9b8bffe3b9781633a10683c7321a1a8d8ac9d8d20ad014ee2459740e197eab8fa8558b24507685b12191e4c9cc949851d7249e148a56a0ba84a580955e2d176d155ee7b6f400cfbdca00302d1db70cb0a7a8296bb9bc9109a8146637fa3175afb31af75fa35e1a9ba82e491726eed763944cd0c68398e6c5a1d129a450e3ba211a54eeb6cc3bd4d451b23bf9b268169c75e47493f8f5fc2dd092a05659b7fa90753beb6c13e672b118d2d24649e59053d679fde473301d858cda9d1b0f4caa3b84eaf1cb37c8323d400f1f77efd01308b5ff1c7ef898ff569872b636771b5d84819e9e1138ca324ecdef39f30049b4744bb6863f61f6281a46fc42cd23c35e0b6f52e82dd4dd9a4b04de0f6182c27bf05a5d4606d752c62084693a1bd9ac04e439ad0830bd23e44cf341ea1654bca735d603b06e0e24781389b004507dbf8f6c00cc35149705a7cfa85c0c9b1ed3a855c584b7463f0aa495a533fa9cb84090e1989f7284745641cb3e7ba278cd415d4ee9d8ee8e06de1b7491e145b6318d629ab2d36659653facd855646905b29fa9481f575ddeed9ac68062232d6b001406f88adc6d836aa8637502c87381e2fabb6b756b9292c53de3901edc721a1c93f930f49d8e0dcd8b10fdf9227f46c9c6d0a2214654d40a3e839eadf8a7edf4e9662226193e0fdff9e444cc47884546a2a631f6f83606c597b4747c768754070a9ce7b74d0a2dc69ad7f1e3d2ffe152857d2e74accbf46006a8a755cfdf7fbb923f3304d68969ffcf72b40240069569d6e7ed9209d2eb88601325fcc753801ff68fc751f757d6951f8d413d47bb2d8034e17cb33b277b92fe3321acd680e58a13dce226e8a5e9067affeb05066c4d41aeb350a61d04a1b6c0ce381166ede5984536f6c7003eb3717dd6ae425009ab527398dbda18db49f0d4ea76fa201cbc4702cbbde9d1c3194b9cf78ab7f2e2c9b82d9b5d6ea9a3a437996bb1168cfad227fa43111403ffed387967afc4e947c0aca7accedee37e98b0aff55ee978ece695bc97dce2c97a3b948bac800688ab19c69161412bac7343a183630d0da63b08d9c93f66f11b6917fcee83c557ac03d9125e1c2c142b7faa3cac14a0932b272c102f2f602599095a825cffe1bc76dda3adbd0530b945b8f2ddc19b2da25b57e7ea893f0b10d9b38945286f66822554bc0c9ef31debf410483d164d7b9157ba4cb227324a3250775afac7c14358a71eabbf5e4fdcddd7aedc54e305a948cd750d75ae4bf395a818fdaec4ccbd1328b7010bb403546f39e772d3ea748ce2f156e3162f4912179324fe85e06d5b3ed7cc0bbf36e9edfbd88028c300c2c9de29161fe83347e2896b32abb2278bbb7947a19c2176e73c30869a2809119181e4504b416226bf9d1d44c88c9dcc4d00b4351143bb4feecce5d63238f749e925b1ded224cd6b99b256284b5a67d4c254ed86014963640f595b73be0b4b388df2ea54a5a5046be2faabcc3e2b41f938fb68258f4740661a4bbbf9b9ad14f3c14762610e11c0841ee851f8ff7727fa9a12f4889deb8b9cadac523f9fc49b6f18b36aec79830f2cce1f55b2c6da2804b25dffba1b97b16e4e71084a4f9aa0b020b6cecef96aac4a737da75f9075eb5c5781170a1c0a68cdd324ba73157629d0493b647cdc580b28a9ec995fb0e64e5443e55958a113addc3697f2e28f85a145a7b7b9ab6fa7c07d3af6f70c2ddb01ca54c22042db10ab948073f862b1ae93d4e0ad5045e2935cea2fc0b700fb11f69f5b3c5679cfc16cd216c433ad99f90c221aaeec8c5070605165440cc9e7b0f3a30a46319ebf0246e78b638becf56a25fe2031e6588dc1252112677d3dde8202e08eecb9d9fc7091f76ece3948edc68794770283d47aefc7c718e3c17d49e2547cf5a3118713494a9baa104c64b9409b74fedcbbd301f1ab021e8675ef5417218f8e56170244281b6b7c1abaa1205d80c1fb4b3a220a4dbffec47814431ddb2779399be8af634f6373db24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
