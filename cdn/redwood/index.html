<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b77d6aee7eabd3bd38c2de067bae47f73f95673dc2dbf993ee6e92942a62b2854bb946166f139bef49adcb263210504b842c8cf55060efd279cc185033fb461e18e52406230bb0458b3e7d267ab227ed738e1f453646cf0b8a7ff54c7fbf46ca2695f255f3615f147828df83cea25da2a0d999547a4acb8ed4549b4df066e1a5f3da20611074e7df603126fb82550d5a8ed131ee9d5d7e5ab5713c046cadd8328c3eb60b63e2b382a1af64c26c60d262c9e924c27b1349635a31caee98652f44f91208bbac4f02ab8c278d0994c2b7327dc4c99c7036c3f776e2dff717652549f0befa594a3958de146db187bf8c55726e3b52c38d4a33fb07d890a1e2db7e68346456855c91baa1c1ca75b4fbbb949e67f7fe0a9c6908495cf1cd8800b7b75308af21014b7152005f4cc9822a2d70f4db2d557ddcceb2548c7040b1d666c3afc420adab7d1bbe571c79ce75282b15fa5be31bcdcb6cc9bb86db86c8d08359a0bc5c9c12938d8b0d23a76748f02007d46a25742096ef12f124fc690b6bcad11eb01816fea863ffdd89ec93cda2af54e20e9cc3da43daddba28c5cedaa587e391774d3d8748c3dc307c94fa16507f65e1f90c35e20fa1d8ebdb0fdbe73285f009d1d3fd24dcccc715e938f9b86446d21c713581821b12742afc9ed7857e176099d80cfc2f4a4a23854d2cf20727afe2e8635ac32b0309be8d7a0a0aea1b06770362a575c3d4c44340ae0cf2c74f9a04e1f751f70a28329bfdaabed95f8ba2c691d3c827cc17a90a542f42b3605f95b320bcccd216e19047fdff95413caa7dae40cb0a35490252a15e7fb4b48ca1b1e6d402d829fe5367bc824642fe44b038a404d004cca2ea43259a72e93dfdaf04bad08ecf8c34b4f4943447014e770725bf1c9be3b34330fd4d2e779b9b4284498e70b5f37323e8910dcfeba9608d6b61146c4756b4cea359bcb82e19fb6e14015dd00fcbca4b7ec2b6d829dd03bf32ae5f8ae223e2b6352463c15645884a519c4493857e84da78d6a707bb31353c84f4b4be39e1f55eccb05d0621255c89c1da50194a0fb2d65ed89b7df94063a55981513825647e0c9bf0d3214c8e3b0bb2eae6e62ce3dd6368a1637343d5bb8b8611c281605c1a2ffae61b4c83075a91f0c30936a2a01098f84d8d3fe6477e53f110deb7dd0df85e3d62be25187d66bac8d60538ff6316dd4249db860ca44b40bc7afdd5eb03224e840d3339901200f742474d9361eb12af8e84e54108aabdb861cc5162856fed2aeaf8de8c610e5afc08ca21adc96b5f4c547c5d96ad154077d72327d826fc39aac2ce0b5ab20eae405024a4c0cb59365b5bad532a64f9d70e8d00df56f4081d1fe2d841c848a9f8f554079094bd4a19068d1f19fce4e7d09e2a8cc11bbf57ceada32f1384a0fe86cb47d3729c4eb60c93751678a94277e8edc1b4df0bfd4247f5b52fea185685cf7f6bd2f2734cd8f7fd3c2d4fde3d6e40f0e0ad626e46f39230e26686285fde01d4c3aaae8442ac39f2f887f9b5f59a9414d8f2ba09298e893072c3da353dae8492a42dae8cd0a510b1cd5016ff255f060d788720d3f052f7909833ccea881ee942e6336eaa0111bcbad067248ba73ac0a0a3d6e1d1662bf282666cbdae04cebe92919f8cf3ecfc2f5f6318f6f7bf27397b736463e68f94d61da5060e56395e292989d873ac3415e53132e5d08471d9c6c15cac42194b1f104c2bc1464aa479f9d6d64edfed886b6c4ebd3dd9500b0d77bce08803992ea6bd747a8f7c63649d447af16f48f8ceb590fcddb49e547e302df6fa553c2a9a0b443632ae66416cb9f90dc2a2cc59be3bca84260ee323142a06bccd2a782564c46658ed780cda9a2af133b855d95ddbd12a1193451a1e00534bedba254bfec8e57eb6c69c5177c1bd6af2eacf3adb7a928cb6d3f6a9132e3bbc451d9255539dd55275f236fda1fdbd90ac2eeaf7144512862d5dda8339e7090d476047987fc8bc62b82e861f4cda3ef55b29e4cdd975cc6f5990b65751d37f28362d0e3616d39f97161165ce49904742355f088be3aa68e0eb0f390246c107877daf91d7782d11efa69678c9fcff79bfaa56389a8c207c756dea151f16675c5b00740fafe8773e33dd829178fa444591e3d0f4e85cb8828f1adfe2b267aa688455e7be24c875ef15fba004dfb4931528d76a20b9845561e8a9e3fd4f207b115befac54270adf36d0c427dd6c634ea0d258a9bfc74399834b612507b7aaa9d7e65a55251ae46c83a95d611907eaa3a78389353c470f0fe369fa4fee55f6c21337fa50d636cc35c0b763e900dc4c71924d2d32be8feb07d01639f12fc5cbab9b090b60bc59d09f3d2ac0eaa0771744f9025ad99cf2491f141927ee359091dd50e00788e2f2859368990c90aeb1100cd1891935a3f2ea24d79fe75e4954d3a542ad2c22fa15a8ab3f330cdd4b4b1842608be34633a1280dbfa2fe973630b0bf059a8168a23e76d8915c07e93bfcdc2ab9bbbe9555d7a4ad41ece5a502c4fd749c2a8a8a8dc21d7d38c1a98f14a3b8fa4640f0d2a81a68b709c41e0956b8e556a88fcd96c526587e781b845397959f8ba858d0feb9dcc091a07bf1250e08d2f85066e176c173cd64129b05ac5c40d50c028a28b5eefe50b0d70964ddc1de91dd7f53d73b0c13882ac4595890dd9ccbf6068520b04ceab24d840eb91d39fe1589cff3535ee76f4b02ef233daf04eff4a871fcd945233cc0a1f688fb6cc53b82f07b89c28d7f9cee5de06921633549233bdb3c0d8b422d7567547b7a1f37530944517419eb415954ef9dbff558a140d53f4fafef00297d0b036741a12a4948cf46f6412740a27b843f93fe27972c5b767c1737ab1a3cd882a2dfa7c8afcf91a5eb0d9888174d332b4bbe80c7b89bf9a2108436fb3ccee128256f2d15f7620d3804e7b3e2c345b780a3eb6b2f656721b222fca24177f488f86572024960bba8982c5e6fcbff53d42209932640f8e662d830f2204a838dd1a562ac47260c280bf66c812a2f20f3173624eda841479b783f61913fde10b20d1391ae704388e163659523982d4224e2ef60bc0848e57af85e7b33b65fd12704f2f1f7d32553fb062ba8c00cc47fe744a772afbdda594190e7f8ef36be9e3bcfb0fa2b2a79f6916c645e33faae4c8272ab745597ae74cad5d580aeff771be09fa243d89e18086fbe3cd7ad2998d4e6c6e93990c2a26246a395cc8798fc2e0ed47adf90eed1c40434d4dddf55a3c028d3ef0a8b30e2c0048fcf4a7494c4114380954b66389fe7f23f8904d4d6dc73484cff8bd40752aab2fd8692a594d353e8201e0dbab59ea59a8874f168f3fe48b5f57fd61f5f5e56f584a92bfc02db76e412e3556797fc232ca2b5ada5f4dd3c49ba273a1e464131539d643678154932de8eb19a9106440c394d0b31283e02802595480ebd3b4db8bb54d63e21bd12e20cce50beaa1191510cec4726d79233a7e99268369e67d24510077277cb91cf24318cf85b0fef69ef2af6cbd82e74495e59ae3e01776ed3dcdea13bc73ccf5f00872eca864de3e21cbefecdb427edd6a98964692ae4d55ea5dda4deccd8aa7e5f1c431a922d62bd01aa07070af58dc4c7b7a3d14dfd26451c07742b1bdc93af2867c57a739de255197594bc2e5ed563078e6e77c31844383bdabae535f70c3538453bba7a7917b0096a08617ce88f18cdb7a8be6ac165984bef5ce07944e03ec1cb17eca833e8a314c457d8d47212a37f98c8fbef38e1a5ce5a23eef0b429b8b2876c729010cf9a664f7677c85e1649d92fb16eb3dfb015ce55961f7b81bca0fd1c7ac565af2fe8b591e9bff199be05cf23e80d6cfcdcd1c610e79e7d6aea7ac28a693fb21b0c2f867f5fdc4461d8dfdb793a57fc0544fab0bb3a4bd2eafea8dc0da32c57224c04e16712e21a7ab6663df70b654e7bc2316976fd02f25da2e9411ecc2d5da6d904373a7c50ebccbf5a5de7703a01a57054c3c1934f2f85aa5281e7ae9ea916ae9fb082ee2fc83f6577becd24df1a9a88e05a29a6269e8c11563dc9eb0f27e63722f2af4ce47a79a0c19967ea83fba4dbd35c93acaa15fbff8c4394200a155a546645e7838138110404da9933f6e63698a89bd7d632d5b236ed853dcdbb51824ba086d62d089f3c7b03845638caaa54cb921aa8d0c7fc7f26c5ce0f5c422e2cd18dfec4628bf1c9fd226096ee659f671009bc89bd1c20bee780b64ac3887a34bf203f54b3150fec1c5ea9ec09a74966f9813a23507c300afbc088adbbb7ea867b0ce12d86924f89cc3df199092b69c5cb052c7af6418bed18e882091eed74fa7ff4a43e9273a4e3cd5e257c410c875ace117c10c4c7e380ee882fdec16c86c2d39f682633875528b380b564f175ff3aede6478501f33549bf510cdcdaedbf6c43a8e44106b51f0903d9af005b598b67dcbf86e3b1f359a7733cbe8ef60a03dcce958ae4cecc95ce3ef06a64285284de29febb0a27324e420927dfe4d10972a7ed261cfa0dcf797687e3465e51633dc564c878cd8577e442e3dc67fa9b1f7db8d88648d5cde5b8f8ea05bdbb26456945f9d97f8ae982f706352013c4d8bea2da8a27b70e4c0380635c479660059cd206b8befa701ed3f599a8d51fb51a7e216a5ac04a2d8dadb7880070e0a0fabb9b0e6faa108a3a2e50efcb662818dce998cf7c9f529dddb39dd8bfc0910c2cb41e106014001bbb14a74c4cf554e5248f78a4fbb1f30d299b378f926fe10ad59c15ef9f638523602f9de68624387def392505a9ea716c7fd721f369f9caadca4739fa7a32b1dbf65f06bf72cfd5ff16f0ba54e95816dc4b368ad8e9cfbf9d3dd447a4bf197c9c43aefbe273dedc60c014bf85bfb71b4a91385f312b85a31d56a3c5ae9a86ec47220656ca6fbf85e377fc13c46ddc38720a3133f12d4640930bb496a97e197a149c2271a282cd7879efda26d0d0c1d74a07b5db166f410250c9c93b88d20dbab56c29a407e37cf2fe561fd847d79b487a24627b77043fb220b37964c2d88bc1717019770114c42ee7dedc76cc0f58520a09099c606cab3fdfd3cda749354bcb518969581a6f5bb7955c9b26a5e4dffed178b1b96c79c4d6c9d205483edf2170f451edd24b71170925793f7efe6ed60a6c92d818179f54184caac5efce274ded2c14bb6c7a6cf0e612356233907dde9f84447056e47f89eaa6d8b2b1d26e96a4a09de1daf77ac685b99dbb975bd76eab39423cc5b04154ca8f4df2c82dc4377c8a8720d0527967fd24507c4467cd042c70939bcbb5d87514af4dbbc52054bd0f03e62cbe28e085c00e60674b5014537f3cfaef95b46424e72c4e3d5f616d392b82af10f106efb15358ea10abe3509e6e2e311ba9c51bc3ad743f555be0eacb1646183c67dc0ccfde4c88b10751f849c95b6ea4077a2451639a0495a14321e5ab4061fa8d4af13cb6fb3d6f5a6bab0180bc6c230232bfe585afcb0712a0d5615edf773b76210b88a1c1d5efbcd44b6773ac7cc383237fe6a12f9883c5aa16a163b2c6f2beecd7e599030b2386dc831ec9859a0675bc5b97becb016bcb19a428af2f5a370e7003ef743e8ad792ec624eb2647df9d0fdb4d35d9387adf13f913edbd5352abde29afae10fcd8b6198b71cbc5dde17b7851ce061ffd187dc2f76952807be7dabae80e46fe561440940286fc6629b356d871837e54702a8ae4c1a0d5e72dde365e7597f97aa9a6c8408e2ce7fc9c2af95701fee345a870a2f3e4c32972503fcd12184f50ed557a4aecce8657e36dddb34997637143c00438fdbf552ae87e7051fb18b6708a149bb2edc0227409038b1d8a4e164066cae2803edb31b880b08341c8d86d22355e9e5e5957f42ccfbf34c80d0a86e57eddff869262df375b604cd7bd2bd32f98aef1ddd58663cc459965540e3e5ae5bef1621781a9c9bc6be8addcdf1c642c37b6aac16e6ea2c3e954325a23490ddaffe060aadcbc28c8c7feaae2c15582da29fadb60e820d2366d3fcb5b0fc56188a7f177f2b81856eb7615107ce68167be6607555cdf6bc76f3fcc07aae129bd428aaa2ef5b49776be46fc7b2d64f4219f03e29c2b3375f44d7af58ca4dc81f9c183324694dac643811019fc6215cbfac2585f4f78d8f564e5565d7dd61e3c7b762af3cc19104edc7a5b2eedfbac96e06dfe2ca3c4bf4e11a680fa0b9ea1834bbf6e612e17a1071c28c80f84d1f84cc390f3ac95f68c682dab4dd4a3fe4df43a38334a1f30e3529f70c472b267c360315c3e55517ba233812eca10fc93392d9da476b970837c3c7037e6ed7c28c3c21c66fd74d346724d32008c251a585321a624bee65b808f25c45996e5f07088d278bb923fe52beb6044c0e1365c583d7a4f51ecb383b53029a1bd5c5f6fb86313556e0bd306d999ac1c76238bcf2d7d9f1d7a29be59a8e852510d63cb14f19ad8a3bfd9706d6d275e3f60e9f9480b4ec94daa1478d8ad44470eb1a14d8e435f3ae5a560a4fa443e6fea52f62b35d91f9cfc5ba8be1abc59f090f39be55c324c0493a7d7b529db5d8c2cafddeb0af076b357d6a4ef928d0d90be937ef64406888c006291c1a9f95f15454e8882708b679e9cc6598d63d988c703542435ead47bef895a0ddae7047984f2106cd08cd20f7a57c5f9b0a5f1851f126892404d11ccd022b36f8877be84bd21b095a372da9bf2b9c4efc810a638f7d6520efd336b0b5ed62bb0a566e584b35c1b860f849bcd7da476e54333b97828ade165e9bf1cae731167ea113540e1cffc7d4eae541afd53c0ea4e2204fb26add34f35f53e4b6044cd8dc7cb28fb4d5bdd786a5ccd45cd3a0418e4515322c0111788f3e839b1f457ea3546d1ebdf0caffff8857e2750ca787a0f287ef735064293fb8d1eabecb9c02b4c66c99e00a74a104136fb72bb6d75c1a2dbc352bc8efa425cfc976a33b60eb05fb8237edc8031a7cce24b77d0380e20cebff40ad8408c6147f7a3cf9fab58317aebeb54e8051e17c728415e8daf71a1a0e02c4754590f3f566e3410591b499d9f36f3b4eaf792952f06bc05168e118b427802eeab5acdebe89cdaa55b2277dbf1ed1ffd94fbc12f32c99b90f4b2517104c007437c84757f41dc315085f83f694a7ef39a80bc9c0cbdd8aabe181bb4f90e9c5364dda70841ae964c42faf589b9ea34225205b38ce15d582d8cb60e9aac8a36b093b01e6a78409754e9af6f69e47d8c22fe289548a710550d71b1a662681fa844214621812071317ad2a75e82f4f5c74efb09a91ef9d82c36c8b44152808a8e038dcfffb6e3931f2c2184034125d63d4148582f73641c6be0ec702674c4be5fa36768054a925639d0f254e674637913590a0acbadfb8f31f1703db8292884bf8b2ccaf413fbb3956e211bc88a7ab87ab97d7186490747c410fe050a2229a6445e552e4b7a9791d6e6b09c866d54507b089d53fdb8f260ea9b84a5559b5ba10c5175ac9b2065147c6cda25dc847f4130f4b0002b68041b7042b03e1ce9ab7ba06156c69726588b1b9f87913a61858ab9e8b5f7c1f3ebcfe5fffb92a7598a2df0c971ad5fbe64acb4ad8f2d277042d2821f7f3b0e9b9abd5027ab1cefc2bf1ae30b7b59223f6dedebf52df9dfdfde0c02620c2b4295cf591479f4d07cd16be1bced1aca57875321d2b2518eb85bb8643c49c86e4b866e22db991200bfa85056cc5929f22773cbff33b88f9949dc634b1e1c929ea2747a28dc8ac5ad2e406fef1fcf8a731ad02b3ab6b5ec85255171266dbef1921bda27125672e266637120b707d051ab1e58f697b3d90cb836d9c40b6ab4108398b3c20c17bb699d80af60c7106a6ddf5376540b5f42ad741825d2f633e7ca5593f887e17729ac9e1b78611b3f48e3c1c502f2b8e248f0d36c69ab1a71ee4848ad876549b8e0bfb5076517665b42a486da5ceedfccb1a5a2a82ec7d7b5257614f040993d43ac2c5df6297579018faf3d97568a865be5a25ddcc320df59a6942c31116e95d478034c9d87aad622491a800ddb63daee5a34bd7ddcaa43edb1411a91374b1b3116c7f749a818221c884d2589728f98f6eedb4f466edaedec788e1d273521443128293b25d3f3c0e506a4210412067de6c9a45526b84ec027c11310f4dc19f5b0933207a8feaf156e1a7efc76d1189b2a836aa1e39abdc8d315a265d5f4d76c2dd2e557951d9ec98430022a1de797bcc3fe6df860069717965e6e7ecb916793e32789bf9221cb62a3e73737c73c083b4fe04f264651cd0e466e3f8ecad628b52f0a2e428636a688a14d1ac04e4e093aa4b11185d3040161a0f95a48d18264ca9c8039ed2001976532766984bda7927d60f669cb02a4785d2ffe27f3b6fcd4269edf00852dadc5f2a2aa46b82898e86d63ffdc4b16dc0f8bd37e15df34b95f01cebbc1b372e3aa64ea8d02676a655271b3ea9c9fef09bc345cb1cbfef0a1082903ea28d54b03e0c24d7e287b1ee6a6c83b85561aab20271b965e2b461ff76a54556d7f4cd894b401138afd89ed2fe2b8ef9b26d8633687c22ee914aa7f038b46986d903907c5f655322d4ec25d401d8712b5afe12a2c38f2e1f95409e60a9bf4087a596518bb874fbee0fe0813c94a965b17a039be7bc55c15027f9d5e20417ecfe6cb129b70ced2822256c2a6579c072620cd78eddc598198a43131ee2f0172b81a72c895055ca793801932e97c7128ee6b7e0ba91983ab10fdee87ddba5eae2feef2cebcb32c8ac751b5763a7b79bf1e4a4d44764a1af477fdef725d01ac87f95be71aad508ec12890c981e2b42acfb7b5d002c677c6ffed8e8c5789c86dbffc84580a200b00a8972e14e5c2c1ca159e5a5d81153e6ac4ab45854cfa53535956b06f1f9e56519326be31260259cafbdce3f65389285b4c481cd6ba8cd24f4cc3afda4137f4a66c66205e1506696a3e40e1588c016823bb047c2aeb32b0fa2d9b8091bacc8bc571d0591ddb90916136dbfcb5337e06d16a6f32b138c966fc2c3b13665be417bca791e69d761d2c33441a5d7e8c026e251b50343bfa3f6dd78e4d5432fd000a2cf067d5a1f39531f4da34504f488ce344d802f3c4b5af3fb17fe3651cd228bf39d2291a38ba286e7edf96ad2b210b7d5a3f323f88511c845d4663f6959a273717bd67587a9acb2980a41f8fa6b5b198e161cb7caf5ab12c2d8ce630ada248149245a277427a1c8087ae8a9858ce94339d9c834ff9317db86c0667b099dc050c10c0d7ba6c7f2ce10fee497172eb156d2478e4089e61471ca24484a5283aa7410beda252bc5cbcc3ffabc22230414fd67c67016c1365b74d6a7a62cfebefb19c7feb6c4fa5f064af6ece619d068b35cdb89ca02c4b2c52f3dc1979501fafc03f0e59300eee709a2adf155dd7a24f78d75fe5c620d65046b979199ff7d54b493546e003bf0d3382342f2addd868dc919644aa64f791545bf47b138eeca2d23223908c7694f98d697ff888e13b3e7ce665294631a18c21d96e83bfe42409e32d1746235d28783a2708b00534116af95021ce1ae1c14b7f382345983ae42558b386816ad5810f77417172d47281c9986fc4e19d54cefbd79bf7dd16210183dd29a0bcd3becb7a6e118f52ef86ad058aadb9ce5eba4dbb88b07e5467cd057d713fd1307902182b91e0cf30b49639f941a24d76d2233982908323016b8a7f5cbae60878a69ae1cafad90046abe7cdb53e34b982b51d8951a04b45ad68819f9f1499df9abd5f834515277d4e05ef5062cfdd0915f143c661d4f1aae8b256746cebe4a2b2611ea71692e282450d36d017d50889de18276db6f3d32b6ec69f043b7a7efd5537e7c44f0adf1eefe50111fc05f419cc0e1a9e721082fdfe187821a56fdcdf927f0a37ff6322cabeaf1224e0414d7fec93e83278dac77104f3a48442004dbf33667e44a84c072c6dfbdbfb9d516f1485c021b2387d3edaa4a6ea3f0a77ce4541c9bbf8705cc58f756ac765ddeac3f549383812b28fbb2fba903b4c76c0252622b6739db850e81a2274a16f56a96d81fc57e638454929178e3a9cfe88fd33c8758df5ce4f93d279065c8dea38c5003dd04e0097ff3f5a8ec8b123cbe6a0f50ae8e4216b77975cc9ae8e2d90d698b6785c8d5d7d085090a20ebc805f809ad21bfb4460b9b6fd58a95687afa5faeb1f550f9e20594a1cd9cda1efa517a6aa6df4667484c76a2318af84847d4804fd246a0d05c2864f1711ab915c8d44754d6f7e8b7a820616ca8a543721e70bece07bcb654b935e3a25c8049076b6dac885bc410bbd1c0b1004a861b27b8186a7096e5c6bbd2c742b05f1f1ba38646f1447adce5f0cf1e80128426e55378a8f270236705113569c06c08d1eebb98ca074462c85fa9d710ee959b3897065abc20e37d4ed1f907a8f1e691fd3bf7a892f4a80b984ab10bc7291d39e5ac32c1a174a13535d230ca6820b9b289f30e592e94e40dacd4b99428971113515205ef8da0a95102d2f6641b7ee83cf1619c2e8ce3951e7146f994f227c271c0e829eb1f58df617d01699186812b099298fef36c54a975fc63326191b928ed72c244ce4680e27373d2742c43b47bdbdd895c93b9810aaaac2399ecdbc9a9ca3faa8da4c636984874dc491bfb7ce80f62855317859e7a0b78ce9b0c290790e971dabed8598ee60d16ac4096001ced56dd7123c38c607bea26051242efa6041ec3ed6a466623bbb300d0e82a0e37fc5870fc86524d81171fb8e3b3b66e9fb68f4d426663404dd7fa9d9f2eb74bf1ffeb1147b3e1581819f84ee26f83f7f53afa9c95644a49d9e0418f4a3f745936e1961c8835b4d252f5ab4a145791cad9f3197792aadb4e335d914bd64a8a8632f73d4feef58cf57cba7954359497f0ddb5acd66c94868f8a83467fc00d8c46467804c0724bf60b64ace7d05381e66af5c658587f9c033ce841f35b940ff4a24281c7b121900ce64511e1799687790e6064c471dfc04a9c1d678999b7ca0058fbf3d8915af5762e3d3c4583dbfddb32484632292939a7d2f321de25561a1bdf1ca1c3387167c7ef064b710cd8426af262ea327f9772ff79df74202ac1f1e16127a2997545c1584499be9bee7e461a43cbba3c6849e48901b460620553295a68fae78d4f9d988d4d39c671b58265941167c1c09d0fc70aa48b66afff7cf88d4fe05a64a3d531724022aac0cd62542eab00440c809a054221fd4b4f69dc6397edffecbd35e175ba9c8cebe16899dc2b3d1f75cb65d746fe3ab33fe25b7d9c665d84f45b0de0e49eab98a908f9fa9d4cdaf5639870d90bdfead61d2b40a0b41fb64a3373f089f9ac3afab85b7bd0dc2ce569fe8ab869e3e01e0824a5266dcf243974ec4a3fa6ae7d9f802f1a27e783fa48aaddd3924d47f2a2f0768e591c391a447095ad49a8717dfc7437dbdfe21164e6a46a45e6cd484a15e55550c7d1385e87fe8b0a50a2112a6a28a65c61ac1e3cd476571e5f076e6da340edc6fcd4b9d7371b2d1bdd0ef00fad59c53266f93a1c68f029ec9ebcbb512ae0d64617f7979bb8eba3d33034f3e91504044d1282512bd553bd9037eaa883d4fc9684b3140fb7e37dd61c6a895858b57afc580e8cb5b4b97d300ac577b067f758ec48704ba53896db1b4ad90cb0bda6838f2ce1270058e08a11e587365e02ca0ad81d97bc7c136dd8d37e70d5ebf126d9ad1fcb55e7f5f9e1990aaa0437034c1d85b74c313b099404c9af0b5b30779abc2effe0549f3f0b1aef9b804667694de1a3e354807648cc0067c09e5bac6d216292dbf9fdb6c59739e304b1fe5bac27e79ead19eac05e496fd59595f15a817e90e2803a32e09bfa47fa1da9dd48e07df2381af8b930b342bc7fe6ad5992ba0ecdfb00dfdf26e66ae9fbbfe05b46313dfd8c377beeb9dca4e13b8972fade00ed67f915dda1143aedee7ed2e271c5046e95605af06b11d63fb0645b3565c6c29d31f173345aca4b670a892c68002c9b341e9483badfa268efd1a7e3dd1282e997b5a1779d67d4cf3f533cc6e0dcc42ce090d6e6fd4a22c6ee723f615c810faac3474a6fc39c42fb64c30ae9e8d19a61cd151e46b854cafc9eba4e60898f2f851d3b4d79cbf0e7375a717b1831cd54410479267c4b103c3112f3d39ce80fbf4aa31fa7fc4c2958ed3473783cc6f2ca72e351f692e1bf865d06d0a657aec6f4e5eb4f5a0117f87d74f279cc9f33aff363c89819167cf95d61c1c44f4058e5ff09ded9ece1deedf9e2f8f613ea77d2b2764a2512c802ecbe58cc40f9c614be94203bcdcdb0d1f55842e7355620459c0d1751e1150c3aeb30453f81efb34a1769cf56476232a4c7de87fc5b11abf67beeec8b664a2ef76a4121193c08bf7e8dfd8b556117d1ab4f7ae10ae61fb8493f672a8a1536d210f1776417724ccc1fc1b1f61484ddd527f03ed3768e791b5da578ba942a8b8376d1b1cc58d2b92a2c25ab6227972d50700ea87e3bb27476457d6eb43695bb8d2d2e70e297c5d524804a5cfb51c5a346e1c5ca35b2f7f1c9829fdfd7df358765c6f4a2bdaebe35e3b815964dffb7d1b0abaa6deb60da01c5b054f1b4d467fcca1cfcd2cc015ad5eceaee051b6e6bc1162d72239408dfac75a33ab475266963e9108e83543159e905e82b573b171020a58f8daaaae0125543ec49458a74200d664daab89b753dd0081b5d0fa80b5fb8cc5335cc916c0a3db7b915271b87de6921789a28635cf37c2038bbfd3cf50e9d2ea6e1260ae0b1001e7e092147c281c821273d38976fae8b86e26948fe7ceb7bf43c081123ab22f4c71134506b7637da56811392982315a18e754e63ca36de7867aea37a5d779144022387c6b28a5bead2ed24370a4e06389f607b7dc9a1ba977056abee6efbdbf67e493bb52c05ac9e227299dc3d2575017cb8fb68e2e6a95619eb919999ea666b4dc89c7591c45b96467f01507eee0df8bee4ecb7e763be9a1c7e497cfad0e30d32249dfa5480e07e5c403f33f95d6b9bbf8fc50f553bc41c0977d3eb555937b79080ed3728e981c7bf575ffae4a8bbdb6cdf0ae3f3a5645a38be23eb101c6dedb85d250c7780419631afe99c52d3187a2202414f89a4cc2d8c435ad74389888f0347bc9a460ae23a0f586aa4d2e453d5039961e9463cb0fb0b5dfe6a556057ecb3f03f881c2c9cf7de60f2a3c95558b982c81d546a990532f9fcf6e4642c37329ab77310e6ebf940fdf6b71a247c0ae323630b6438bc0b34b8fff5f2dfccd6d237fe0b39b23d5a7bfe10db0b0ec252bc4f32fe31c10a3dc852d955fc27b49decaddbc673a756d62c95a05a720a6b7119f508d2ba056fb041142e2dc419c4a389faeb0097984089daa1042888e3916a4f863453ac943838b08f86a21dcde895dcbfa50a67f8a75d29befea712fb8f15d1904b3dbcaa8b4dd81b966847c876b861586538a31439e11556899eb684cb38a899362d34996f944c07d7d7aeff6ce0fdb977426ad129dbfe02ccdc328a978e548ac8725953964f7c31bf803421314ee8ea2114ef61d9ba3c1c64750bb2f6c61d0723071f74e1b47edc9c0bf226dd9a87317cda057232fbfe4bb797765f2f907d60d5d17844c5a81dfa433f64da79bee6608c022f497286bf4b3f4145946c3984e15c616b0dbf483ea3bd8fa34602b19fb7aecfe07dbc3bb081e80de9b08ffddcac403f00c48c43186d18b67d499024bf98afaa97f555b0b6e0028af73b08c7b01053439e25fed4a4bd6e35e074e0f4b6d358ecad5cc4e262a9b5a319b74f0170e3e505230694526ca1fd3c380f4e317bfd5ff21315d32611803076ae912f80f27d3eb5274e8516ecdddc6c911d7e92ac28b63cafcc2da023a0b043aa9f63252e8f64c531cb4378f2d4d8d3fbf7c14bb1495cac92d310feb89d2c7a1ece5e2b506fe43c04b51136c44a6ab9fdce09f871ad2bb5c21656462be42639dd901e07f05c8dc1923a4b9d46ee05c15365db005ad66349c393eb6adef494693afec40891e1f2ab6623451d6d7f354456dfd88ac684f3eb74b1cdf048df882c2bb1ee137b659fa752b874602d89b20db8cb0ecf7386c301222bd72e124e86406d652b2e200e836559680518621b562737d3bd3370da881de440f77f84b9ebded13dfcfe14fec706ca3767db73a9bbbe8f3087175368fd65e435f832d231a3a38ce81e0c9dd97cd53ffb23e123423be61db22bf21c144eedd184dba77c82334c4afe1cb10c7899d73e74375c207aa02119c6f3545699a0f8453686daa07b901d4b9c24060084972c6867f8a57678d334cfd1dfca774ec39d815cee2566c3daa36527b85c76d666af9d5c5146ca89cd293ac3989ee26b54f14ebeecbd5684a86bd542fa477f1549202b78af36ac93f7364c971f2c7c2c577f05fbb4077855c2f28e859445fb118040718def80ca422952511aa957a3271d9433f3df1c0a9d9db8a05bf430f51e4aa22655c1b787327bfcea83db19ced55bd20307866717d688455ae31fb878d340add88705f92a5e5f7e5f4e049e60995ef879764299ec25b9d6097cca670f3834d7e43f58b477870c0a37d09b1a4d5e19e8f1613f22189d7a51f86f21bb22222e0e281204e6026dbaffcfd8df73839db65c60ca9cfd929e69bc55a68ec4f102b0bc664e9e20f395e9312d57c53711fedf1c6a65a302b20054f5bb76512e73ef8b26a5e5b7b376f24c4c9c5eefac224c96ccab8d1c3b86b725e279ea77c42d03f5b3a2520c72270073b2fd8c587aac88d33d40238ad68ea9949ef533985d53f3e7325894600405fac72a4727f4b4aa02cba9038262f1edb326cd634051f9880fe1a8b497956ce3ce6d5966008591faaef614e946dcd5c138483594ec162faf4a5ad3bb591ccbd087e87ec5d6116d4e6325e5e002787822da43f4dbbd40db827c3149d3f7cf1795071f43f4c6bc53a389a5899d0ed1eaf7c13fbac7fa50797a24d7ca397ed969436210660bbe23b5b6cfa6b4d07d9b4e32440fb31814c8c388adc377ea62851d7e7b9bfdffe202e73352aa09642f78e75312643a33c321aeca933f1353b303fe856e09044816ba551d482f0fc87ee469d276c857100f1e2356a3da2729cf70a73df157a1e882cc22a8f2d726c3386e348b20c69de5796fa88fc43916e268a7bb0dd848ee1f672d3fae4836b907b2d9cc5db9fc7876fa72a6140e47a9470f4525c00bac9fd4227aa802c697bf0dc47a620da0112932f7ea88b32f8413cd7e7e7d2558a097fe4626b428fac26369b6c2017fea31ae0c821bdf8920d65594150a136c3a4e95782f6bf950284a418c4183cb7c81a6c6f6bc9078eb97e8bf0788d670b85053c18c57f41473ec9d877d39d1c81db3dfb56a818c15dbeec39cb08ff81fdc50b4252fda3592223b0b22e6b32f94def5e0a2a1a87f4321e4229d6b80b37bbcb4a1e84b55eaf5d2a37fa85109de2136a06165aa5ddcd1fa8b34d338e63e1a60fe5dd109c1b75dd69d9e30f6fed27736af9fe4f877264278a10d93297be031e5ebd1b4be199c0420c132cc5906826c7a0e8560f3d68689bc51bf752738a3ae5e78ae0578c2418be093fbb944cd093b96ec1c0823a8a79b65e01702eacda09069cbdbef2511b7be21a08498dd4f957792ba02a61b85d65cdbc09e4cccf755ee352a5803fc7cc2f492d67b147983cfdcc51a939f5eb0a5a310e3251ee27b598d50ae9e95f80ba228838adc67c6b7c7c8dd22a494a190320067e4e3d5153a4c376286221079a0b53b286c1ee9802a7ee1248b0f8b36d140182196d3d028ead0c51e60e442c6f7d38c2e4db53e65895318cff118fca095ff115b08acdfaff682bb2a4b7b1490102b1c9483bcae07a7a0bafa2fa6514a8a5e9e5ff7ef39fd6bb44523624d0c575fb23895bfc8f3fe1a6b636cf288a0686ad5aed15c81b5f9c4891772ce70d3585488dbba5852a9581ad161753a76081046e91bdec3222e15126807531e57d38526d687d0b7a3b4c292cfcf38c0511a92995a4e71745b3b1051aee6abf60e8065e2c766dbb728f4acfe22dc74ac8826428d68688597f78d55fca41d048a0888479acc156e235b1ea88e4c019a54bcf63b053c78a3fcfe0bea2daf5fddc664a96aad0b7dccc55c04cdb02847284649c2307a4ef2a38b85a0696906bbd5a18c9ed52735ca0763327150d25c3c3087f45fcfea61a630fa4bbe9971bd37e9472454c8b8a49fc30841165c799b4c09183761f02d57be9c1a9b88e6aa392f0e9a01a5ee04f8c65538545c0a946cd17bfcdf84fdd3eb7a7aefbae1d586af3322423cf96075856cc934dc7cb975f813ac9fcd8d51df814c7480f1532ed900044fee1a36659588a9cb87df7680a12a96f41be8c35ff8bd456ea19bbfba5a239bb7ee9f5d66abdcbe574045e14eddf6187fd5c9adbc2a555b90a45940df8638db02d28d1bd6a47ae67c2ab6a58b3e2750ea3e6bdf1fae166d66fa950d0bb9a03ab74915e6acf8519f78ada9e5f9f55e31d8f1b034f3010c62a66c1bcde270a1e2a97ef856c9d6c53645fb239dccdb4c481b3b4f780855098381c7415c788c3207283b2793cb844887ae1f54a68d7e3cbef21cc2c0f9257dd4efcbde7dfea98990f3c9583fc3452254d67acb320580ba05d90512bbaf56b34aab7b01e8f48949d4826f2617c83c4e7d48833aa6d5cc79a738731979f724b05b0bc9adc41e00c74dd7bf014336f79584f8559492031c0c47cdf97b8d8ef9a004c760bc72466995f0f20a7c9338ba8c58015b2459d8f70d67b541fb24a600e7d0a709a98fcc370d799d0bc316bcd6c1bfd9b688a79ad671abe3369735bb10392939e9645bdfd80b92ab096bf0b064e712ca608791d279a8327ade3791654555670fc667678dbcaa1f88d8ca6ac37101d705ce0202ae771887311418d9c84ee9e3b8c45a6a78ac9c39905733d1af3d8fd89b7511fb54e286e924448064b93f80d55e487511614e5e35cfabe34a2b599ff854bdb3db1f8120115461272de9b977143947dc3e57ed2bb2f59e099e27e7141fa72bbff3b8a9b0f9f0d4219f18454cfd2820330fbbda1af8f1988a1b7ccd7d80a9f3ba8af50e69c0643590dffa367de7a86306ae1ecbc9fc710638a6dc5fc466cb369ef8e93f8675cc02b58a8ffc67c0383e28e15f64f804317fc179b9dd6caa78054a0ff4ed4e954bcffe9796ab1d1a395eaf34e12dfbba802708b1909429cca2a939543b4a13d63c930f5482ffbe826239a7b7fb6dbb7478d437b372deac75072599a6e7aea8c42fb5d81840116f7b085afaa04c1a5b10d382fc011e67cb8cfb973f72aad63d107866920537c3924614effcf29bec21f57e4e6b5af7734ae8b6cb39b37a3f224be82ddc9c3f1edc52675b51d9a728bdf31a1e435f90340dce99289a7a8916b6fa79493983f66913c450d860bc6656a9fa8e60923628e80885d619123b93b0bd6b03fc3eee14902cc53bd5df3bac4432a3fa652d6364cdec036b124ccd2b8a799969a4d4ba59518ccdcef083817f40d4baf13c590649516dc4302a3018bdab771adc87a01e78414ed85adcf5f1aac2752d091fe58a1fa73e1f4425308d26b0d3a6632307ceec60d65dca7027171ec3f3d206537fd9881466d11743086728ea7bc86a69e15a3a6420ca5c4ee3e85959c369d4099bb813d7be5b1c53aebc164a7742bd2cea9446845cb7b7d5dbd8ad1077cc4e3331777742f9956b8f2833c1e3ea0a4c7998cff8ff707b4eb30c2523293e1b326f5b7f53c71ac58ec0513fd696b3701e6acdfcf24298bdb1a1844d026c36546740e405e4423303468c321abfb6b5e8f8226b82d5a59c1a183801f6f52007c1223404eae873b31f26599924e07747b32a65da45a15315035587bd3f8b1a86de930bb5fba1fc1f31d1c7297564cd1a90d322f66f727781bb1c5317041ccf6b35b8339012954a823d2f11432182dafcb14d8dd17506b1c574dccb0c849c51fac1fea0742be989e49054358bc4b937cfc2f48c514eb69614288782f1d1de11d0ed1d8653e26a55c7217665d9fa94dd8422bc69460792ed923c4c4b0254d6f8c59c3d47d2a7c858583a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
