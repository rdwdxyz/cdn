<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dddea456170a20ab75ddbf8d59f96d9fb93d7ff254f3e583bad130341b88cec0654e3ae2a040e7533c9f053e1c229be95504513c571a48767f4f62e9d92bf19e302bf18028c1dd4434257e6091071e35a4dfff315018c9ee5d850bb67c39355a0e213d7dea297d9a85422eb01fe75764bb9439a17af303656dde54e47393e6c0516bd49a3433953cde05186306e71b49213657974c0e8825441eab782c71649398ec7b51bc14dc8a2a3337737f9c00ee40b07a0e813e5b03b5b943b767a220bd3e68b215d07bb4b8a95e69afac8a456e8d9d5f9463ef66f37f14102cc0346b5d29768c41b5a7e06018197a52026933616cba37a850d31fc9c4789ee5de9c64f0335a98f9727c8ec18452d76e5211a7427d0c6ff2f8631648c4b7a25802981fb1e4ab0078108eb20676efd00be187408d2dc02d1f54306969abf52e534d7e0573b4acd6be10fd33667759a92c898b079079e2e31c6b13019bb6edd0b47ba9f4b6046495da44b390ac8709fe1f269b7c256589422036cbaa80a1a7f62fb39ec4636de4ed3b3fc87a2ae5d522f43cf85f8d4fe1b8077f539c78ed3d3e12867e4c0262ba8c9fda3fcb06bb52f2629bddefb3e774cf91107ddf55e20c5fe711f39c95a6a5618e75f4e22fd93bb7ee43f53ef482374dca50e232fbd302287205926e0554da364dd8ed25e6d6086a636ce17aeafa8a078ec47cdd114ce8ea5aa586399eba7d82be01af3969f6372a650ff8d3700a9c0512b9010012cc26a642061b24120a8da0e12665e2e91759b8741c9f30a524965ee6ab2c6826efa588f986817f13211d68a5c85dd643cefbadd327230dd975f6122ef64772ee64e937d8479b33621257fd460053a9a5dbce4b14c40bc1f34d6dfd9e98ce2244b3d9f2956c7a9bac6d0919c0369cd091921ffb7352d449ea7ebb201445f7bcad0b3062e352d35fea0d35afadcb579d16afbf7f4c49c52bc51633c09fb081525a87d4423e49723f5af8a18cfa7d9a2b0d7d0d6eb82559ff1e034f26500bda444188a032573c12cf103d2bb44fdc194d458db1e6dd399849c2db8a0097ebc38c0c69a7c20162f53b5f17c29431e27742ed02e1fea8e757b3b8ebda87dfb79926058add4acb7d7798bab58d33946a11d98d478ff7eb785aa8c0f3b970bfef4cc9103e1b4a6b8ab3eb65a47efdb1628cd12f93d28a7c591f40460ef427b8ddb41b23385aa1c96c9345de561381221cd81906e6e17233b1a841e4d4c14401d08bacc9b0e7e3f65c31f31f77d96164130bd06ff1e7208b745cf76dedf108ae2297fa64247ef49fe57d58f7a33ce1c2579307d111c3f2e0682a11f41c00bb409d5c52859f142ff7baab264d65e4beb9c1ff1945616bbe926e0a15ff7dafd2a07b57a37fc85699991e9f8bc9fd7c4a32ea5496f1ed2f4461a681c8c5dbd8362a71fb0d8ed4b25c99cb2ef1530d472af869c10ad0b0c96d908fd1094cd3ba3e33fc63f1bce0139db3a2fff7c016d79492bdfa62df5f553f4bcd4ee9ee1da238dd28d8ed89445fe5e814da2ade1ba5c9fad29a2d74d4ac127cd7ae16d9e73d15920f8792a264d6c5ab360a06ed46024e20a0d5b83a5a12cb582bfc129814a30df56b7e8455d5dd65b4c75d1f1636834067b1cafaaaf286c5a7f960a080107d8a7c5315df1cc66c66c8b6a15562e6ba03ce8e408d83701a8fc703cc0e0945e8f8114e3ba033a209c77ac7777ff437145156e141f80440e04d00982d48664721b53617d9c4d0d763cfeaaa017c49a491b0a8e7a570f19171d4ac857b76387c064d65e2b70725002c34157c5dd36302d69ceef9993e0ac30907ca68f5c36bad3bd4329fb78265fd9cce99a25bf1d0da9a67429a36c3f308ef56af66c09fa77a27f43024eba7cf3d63f522590604f78444ea9423a6ecb8561d9d89d521b3acf72990bb461cf561d3283a2a69515ba8c868eb142c9b6b3baa3cfdfed007abb85f4ab918ca11c7b110610c193c336db6a485640f1ac46a885fa6200d6ade41f4359a9a7c6b9271ad06f6c10ac1812a1969b9827492fd071428400335382f33e16caede74643a39c3d1953c37fabea122ad51d3469671c47c428fab8959bf68f2e4eebf8b22c5ef6831e152eda00509b5f609b5f261da1c536282abef63d56158b0ad60588e24b04bb61a2638dd36b13b96414414583360ac52d516262cd0682c49b19dd320171330026484b2c4cb433be470480d27e31b6825586229428dcdf3d4cd98249461a0651a281b9b1cd546e90c2ff0454aaffd0a3b3efc7f1fa11d015818c5434342402558dba02ca2717141f7790e78f86db9e8bcd5daa907cf58fae97b0b413e9062a18c34173f725b13111d4a4b14677be7d8b368b916b4888f1393ea149a9d5d441baff6c806f184d5d146c184b55becc4e5faa2407e04a846da00e0a898229bfe49ff5bc863bc9fc8bae0b3679b4c1ee6a7ac63759bc64eb31811135c8fce1368aad8b829650a196edf86a15b0fea574e699a4de56d97084830c5fbc78c3e831e676b64ade09ce36bafd4749e745a1cdc0c33518a7fe3bd623153edb40bf99b81e298ced7f3c48123a6dad241c51ddd0d18bf6d823407543d9a7fd0f715945d5c268191cb06e753ad0f6a591dd8dc29d6e78280a28cbcde757157dffb998ea7ba6e2b3efe0e72735946e91c03363ee67861fb82e5685a4d882081bac50a1b723e6253868e38677efd63bb58069ad0f4659f4c0a44616da122d26e451be9555b1972dd9e118d23c42dbb04d93bd5f97420482972c8cf285d53790d58bfdff5e530d01a7f120c48a433bac51cd08408af1fd41f43aa325a3eefb7638295db37dbdf3f10f2eb4e7f3e65e4daac714844ca39bc284ba7fcefd68909d97dc50973fc218eef6c6ff60451c44ef1c3d1974bc882942a7984f05470df3d2229078be77e24d775af0db216686c93ada1319d0617cfb14dcd80d9382db12395dbb4bb7d5e6d16ad239ad365f803bdce8764ccce51c67db317321968f651b4306489bd17e0ae991aa2779930624071ba8b5bedbcfd9cfccb2065a311565756dac3607ae840c9d38e777a0d8fc15394ae966a4b18ec263c59da562d5772eb1e4f350aa0f78ed136ef3b3469b79eab9c3fd6847b75ebc308bedcc6cdbef576c38dbe5b420840817c475ff8266aef1343d04c9c1c311b7bfdfe9e96e9b192694958d728de7c5743c771fcb57468253fedb1c164b1c566c5b7587a7425827e2bf78352807413d7c5b3b90b7bd30125f9884bbec9f659751c50c76eb1102bf10b818ae6e83fda905543817cb1353a7f780cd310985521bd8644b78c71d2f60bf998c02885fca42f6c6e1a5b69a8dacaa81cae9fc8c2686e2c6d9f7fa0d0d038b1a26195b2dadd7c2a1ac9836ded45fe054b8e5c2643a6fb192815d0965eff04cd168d4e9b4a57f544d209efbb441c9031264ac43b23c946fc398aadf32fbe669d2a65e28946f39cdd6b681f3175e79796b076c8e541f818f69fa09870f8b275f06ec150938913aa89590bdb7005b4a69d24644782386a98fd072da5c601f01dc7f5ddac5dc43098774e73c3acf625c30c8b9b21bd4775791228a08e28c3dc48bf934068c4cdb793fb3479c758af7b7078877cfa7e6471c6bb83c5b067fa22055eeb1f74c74d4aec82a2f450d5f06992504f3401507b33ba59f8038fac37b35e07b13e731e38521e220cc1c1d79373b641cd2e03ab2904f2c891f0e38ac4654c60709af8fc6b9d5a28f62ba42ce11b061a66ab7b8f7668e992eb5dc854a9ef06435c4e467b212f202e2de6c41f765aef12bc2bf328fa6d07eae2c680a049bee81c5e38c017ab8c5a4ebe4488e01af0342a65d43521a650dbe6060bf43d823d0d7ccf04d539f1198826eab1a615bfd5968de61c5dfd52c7a7c0a5da7305a7a885f1ddbeef674ea4ef1b4c219f7b5ec6428e1bfab879e64a1704704794dd28d5cc86566a3eb31cdaeab28108ece64d6df5cbece836656dd14b7338c017adde4607e4b2320e41e95306b5a27fc1d81c25cf7ecaddaa3cd6f59ba5166e01acd72a05a8439a9c037b291c2c4aa3b0001dbefae45671f8b7d0695b8964ad135cd3ba2d290d79baf4e9ee8781049d149f1796aa5342c95689cfb964f56aa076d927102016d9e108e80488515e433d1ea8305b6a60120c5384220bf995081c838b948e87985f51127e14a673eb9f41dafc36a7e6a0f8a3b53ea6c3adba0e9491d6aecebae28dcc4b6bf6f880e014a00fb03e1f5455b8b020e3e98a5cffc962bd73aab3f9ce1c98bbcf5092cc70e39550091184a07a484d5fafac13618cc5a50d8694096c057bc17cf675b3174ae7bae2c8ab63653eeabf5b588272078c69353d19a6c59e3d3187bb604a7bb61a717ff0d10f0f39e7d9eddd6768b0fc6dbc4a105290be51038b7cdf96be60b2ffd5ca4357b13ae78e4784d82a552d7358ab944d3c4fd3d55abefa31258c3876d42a1bba895e074fe0050f02a21f0cf5dd05e0428bee96e70946cb2508455cc93bf904fcf83c12fef9788faece2709851fefbc2ab32f43626629ba600d8d7e897bf6f6378ecc897bb1c786512378c146b204d8b126a187c745ce1927b00b2fe6a2744c5953ddc6197d6c4cef5352a2061d551add2c3dcc6fd14116220bc20a628a6079e21aa0295aa8df11d4a53522b003cdb2a3bf70366da99e99d8246a9bc735d56397f02e41dfc131c71bbefb1727f145e238ac61ac31de45c5d5c662ffde89be1d7bb12a7d8619076bad3899848ce580284df50ca8fad74ecdfedac66f22857048d6f5a23cec9bc71171198624624f48a55eab5f696ab053fc7a7fa8b0fd8905970c9df35266d6a6f903bf361f788236e25bd22f1b4c9cf46fb45f371fcd826a572955fb760b567c9050fb797fd26ba2f6de2fd1ceb0f99a0e2ce4a3cff3e339ecab8f88cec482aa48737883a6291860d9b91c0990d20fcca904be7565b29843b24e7a75c6ad41a46abe78ddf392cac17956d9c4dfb4eca02e50edaf905707c77b05e8c88b865a469648913a122643f449eb042f41e3338fd78e936025751c96217c3a6160e5128308b5ab3e99d141bf326a43d9d779802c3c2ab5515ffd1698b464cdd9854e75f85a3a3ad4d7fb074c20231c897fcd468ca04719b82e1789842a9109283360c36854b5107622ffe9f9d766bcdcfee6bac39f3c4db2010f7cd17382dd710b9675ab560c61a37240f698b443523840e429c23f5ecf3e12e4761efcebff8aa8729f7f5decc77e4f6907d5fc2bdc4e7d55b552bccff4f4fe5c1d9528bebdc9f81f775b8c8453126fcfb1fc99dfeff58387bbde0a7215972f49bff7f6148ff6931e0e15552ead8a2ce1f2aa9eceea83faa725143615df16935c8b38926f0c11cadb01bed45d8e042f801c85f64cbca1eda12f32f85fccc5adfeb1ec388e17d9d6e37c6256ce04464ea3b1ca6f0230e9429477d7525730a5e79038ca8a33de01619cd5338e0f796304ce2bd89b69dc47f240bbe92b79e12e4ccabc372e5b4d404aa564803251a33d273faeab8ad25f116f4d8f54c252ba6531cdc132bf37a8e585ad2006f902b7068b5eaf30e9a8fad11f613a55eec458514088baeb8833ef8cb28624f323e677e2551045cdbe18f7992207e8e7683d4d5c7cc29ee0e5ee482fd8b748396d59ed15026bdafaf917ebcc02b55009d4628065563a345d74c8bd2e57dd055926c30924f8ca1cb9052e3e075f0c43d09a73dc8b40f16bf0b9c45300e0430ef7ecca9f5fc8ca99ef1bdf7085dbf380a7872b559f930369000cb3ca1ba396fdd36623be2dab6e55cb6cf4d9cc405ae9aeb7e22ad0a3fdcc7e341ab4a466eb242886484b258885939c067ecef66e8738d850c4404576d77286d29ffba0f729933bf17397d34c13752ef820e56c20d8d1ab7c4cb420ce47744927befc1691ee408717a77ec7b64cbc63ec121372c1863975a12f912397823121001ad5dd3456016da8a737e25dfeb98dab7b4ee91e6b9a0253f66a5d2b6980d756e92b46ae26906529ce6c75a849f89557043f8b899ea09e72384f7769287dd13ece4c1b0e74714fdf21a16c9fd65644600f719187cb09b29c02c579027d66862509d67ff984de292cab898ccbf63796c37cb086c3bb9355d6a66491b856a8a081955d6d73e7670dba6707b6876b2c57bba0a895c336ff805dd38ea62e1037077dcd9068e80abf9b995116bb093cda9d96f7e26e65fb69bab3724b5d86f5613e9655445c0adcd5b748d14c74ce47233adab5d66010e8f742faf51316efe9b35435886ec2cfeb140d7612e65a95315f7eabeb1d9286afc02e33e0a9845e6df8059a2b2d47224bd58768b98d1a7644959934ba310d0f5ca6cde7ffa58c48c0cdbe33f1dc7bbcca61052e0b95135fcfe40c25ffcde19317998f338703259d13d3759d8efd918d580296a8a5fd6bb91e3b624d57737e993f9d8dd26dbfe3e6ef52d8f7beb978aa25c69912dbc2f1c5f2301c049240495bc91e8d6d89c788cfff5cbedb4a3a152a2e04a1bd932163f8f985e79189e3023d206942e00698315aaf96d5321dc3b73234340eec585d070353d35152d14c43d6ef3ecfa4bc3474d9725c885587866e4638275a05e23ea1f50df57185145f1171fd140caaf516247cedc66696dc8d128fe6059885b90dce732406eea6ad935a7a594d58a0eefe93b077bffc3486c5f2f1386c81aec2cd6769a196e51196cd001c8999afda626767e6927af7a6436eac0791853d3b4da7aaa7f2d7350e3ebf6746bb39fb4dd28cfc7506d9be3686455c9a8cdb7089e891e8f9eda4a6b39f8fa6b6d3a34b7814155f4cf17def17c192dd2d1c4516bcd15cc7b5cfd1d0c568d62801432705bfa637c15cb4b9830bd54a68e211024c5b23ed789240fa0922feee15f4efbeeea04300574ac3fe8582cc9dd1f5bd40ec83407b7ff84baba4bc53cd2bde66b4b45350d811830488f21fdb4f59cfdaf9ecf101133469e684e96d33306ee3524a694ecaabc03d9fca9c4286cdf6ba89d17a5e13653f1dad1b4ab98adf1809acae96807df1728c0c5f4a001d8dc34015730ccc9fe64b425ed81c8d69bab679e676885d073e71b7d751d0a3275b93bf4d947897f60ab4c7cbca6e6421d01a43cac4224f0719c04b4a8ecd4d0ae02228636efd98b8dc3617b6e68e11aee866233d9d92f57da8a14eac8958e12b3b1ed400683008d32f3e19ad8afaa19667490e321298dffdc9cc8fb52af6591d233780751d17a39ca3f2d95dd37a04e82ca2cbc6cf87546e2125eb9e1305a0af188468a98e11b2d1577dc0ff4b69ac8d300be97a31a98c65d01def2a33e084f16750a75d900ad9fe10fcac09930b95dadce34ab0e08b454517cc057818a8231809f8ed8c04d0c7fec756463b363cc56b86c675811d0f5b5c6f2db697003bde34123ed94c479c7ed96fdbbb33c8d1f04f75db9bd6c85ce0448752bef535ff620f51508974809445e3a31c43166bc0313344e2e88f071b14628d8b9c2c6f20376dde208504dce773b625cccbad392b18337adc49c986866f4bfd283a272a6f7b11160d7f93f0109a3a9edc92203d1f789cf2bfe91ce995912d5c1c722e0c94b0e1f454ef17312b872d4b4ece603f78e4261457f4decd7bd7a70c089f33fd94d69dc2766c3780b8470eca029d5e4ea0a788bff50a796ec000113281d499f2785750b21fb2a5e1d37f0c59c9864b9ebd5d55d63ce747652602c40634611d23bb71352c71c5b9e4590a446c226a75933089f41c787fb0dccc681eeb0917b37c37c6f7ee20d2198746f649e6eaf22d153621ea42a7efdda017e5040a6f2e291533bdffa65e7b03af7c07b962a495a4606762dc79db5cfa10db091dd73a9863daa0cff3f3f389cfb120bda4c3ccf9d67a28e540198ba48fb613232a6519ef781d50db24d2ff222c54f8e8cfd49ac4a89f8ea8955dff03f7a0d24e98cd365bbe46d98f63852b43249c22014ee041f8d178bc068476ce1ea880d534e584550fdd4c4c5d446070b3315193fba56c567a3b9f2344a4ab41bd4f6c2928fa5d9a37396f91f0cbebe5783a4fbf43413c2342efdc8f43dddad1cb135aa2a21cf1863e4bf8cd3cb006db96905363ee8ce3bd50457c7910e22e08eca0fb1746d79eb4e76643def9313e03d7c8cc3ac947bdadb7dc004a72bfd626db304a8dfb70c3e949ca95e2d97b09e96c837bf2a4024d4cd30909aefa5fe04b9847b22c95e126a753d7648286429dbfd794b8447f12d55d6dc5c4c7248429c86644d01bb3194e63a4f3ead33094f926e39bd381ec02911191b2b1eb05fb13a0105befbd20ebcdc10b4e54bc256366a03d146d0488a679dbe1fe6f99279ffa26105b2c8de34495bed646a0afe4ddeeca499eb254a9bfc0177977ca2cf40e3acbe70d5c253e0aeb652175c11e05d19fa9f86076295f39f70103ca20e263bc07d3cd83bb8d5d85753656ace90afd47daebadf9fd3265c4211d1421407ba64662d934f1179debf26860b03afdb1cdffc496f2767390e0022b06de88cddc9f1bf5fc0a93a5cb9b6535c1a4caf86d455daa5542a56748db0c8c9fc4559517cd1714526ac41d67e2007f12cdea8031734d81840a43153a66524b87f21a9b455c54cf3155074d64b08be403621f90ee780a165191236c2edae9a05615990859cde77d8b2a46806c2ad514746ffdd23846a9c29a63f75751769244430380e5acf911dc8a28b8d630b8a4649f07acd45dc227175ad46ede191867a9c9e7a1baf4574cd145c454cb768f7c2b76db6446506ac21fac8865996d3e4cf72cecbe1c0a2db74b203cff746b945860c12a6a7c80c23c51d4b2fa43930d2ca00cb92d629f7e87c19aba2b05114d146d6228f9497c29c9909aae998f260b02b8f46cff61d5918750f13f7d4494f5db44b7185350953afadcd97648bf553e607b95f935fd58a256926c9ec359d9d0cb7013acabc44900eb10a41eef9adaa74d8c0ec6e7df99a856f58c6078b69dba272eb351c6a0979971ec4a8c0c3bde93a34b022cb1b41ae561446ea0646b05ed84b9e6ba933fb26786dd3b1062977ac4b00d0a685d3201cfd75137dc3a1152defdcd0814a7d8b0f43f8b61c5b513339837e3b89c8309af452c1b42a52469b5af8c3f6b7becd750531070ed4f48d2c85a0af735dd8b8ea106551ed28b5022a8cc3540170865202b3e9803900ed3718f5f142693c401eb5e134edd1ba1fd1b5a33a9ff0aa3ffbb72606ccc0d53f7a86558d7c658075563ea050770ad02f1ea560056c9de198c4d6ced8fc5293a27421d014d18aea6c5e1c7e8252ab7d04d853b8c9bde47c79e778a7ce3bf387f337cd25c2d556f5554064fe126d255ed1faa71456bd3fc8cb6758644e0467de2470759a967875ba2729c779f8a6b37fb70a792c164ecec6aeb615e41c476e3033ee3970a781af80636c68405e61e9d7ffd2c96d7a214bb6fc693f7ea1bba25970a6a339105671342f3e723df874e83b1ea2ee172d6dede967adf0886e93d384d0e59d1b60ccbd29e8fff2343b2ed97e3d3505a86a8324ec18dc9058baffff685d891773895d00c6fc8a4313477d355d75b166355ec2ffd0986b35c3688dfb408b3e2005cf588d4793b0c923c7f35398f1c6f15ccb4f1dd11ee203ec662f5d349c5a31385084cfdf42e8705f2f9edbc2feccf4111de12c98b85cbc3865dd3b728a02c77bbb957b97b260f6f9d78381769c79837739904fd32c24c1ab307e651f63913119c8b9e0c5a5d9de4cfebfd713135827e15563aa7bffa562c48c2ce5c313c4183c9e9408743646a7d822ea64fa8e8f81e609275e766252c923cf27b54209072cb0c6b6fdc1367ebe8646d872c5b0c0fee8964f66a716c1140227c6722b1896398de84d043f713d89bf8c4eb72ee5f7a43e1259d183388ba7a8d7f5ed94f5ca33efcdb54886f0a89176c86e8b5bb6fc01d5812e4061c096d35e05c9e270e51dc6d666549471305223f4e00a6e0b1b7529abccf2bea30a751c5a3d163d6c9dac0c93997b2050fa878a341864dd6d95776da36c24747a687c8543ed55d5e7b996b879490d6aa43b323a141c375a92463e10dd830714ad1cbff7c3f564841d2eb70b053fa8cff7fb787faa05192315aedc9e0a5fb3a515c59cee983da874ed09d7fa35041e039e495a8867ad4cdc7c079ca28c2daf3a8194c270c09b92f6baf17ed997fd4cae3237825a0b583cc6f0050d7fcbe75f194a9c1a12c66499dead0ad205a0652da89744daa98cb4fa6f2fdaa9cb7a3807572088eff77db5961ebbc4aa78de6681236015dc69de29498fd919fea34e7d2d4756520d0e2d718f03abe317f17ad115c62e56a795daff7126e9a5cba3acf97f1d33a744daad47401749f4ed9ef5c7577909008cf49046d58eac45b19dfd0077271c6541e8f68f848a1800af7ea3864931b3625f54b086fcffbfa575d6f943e478576ef04e0747f10d74e141f0b7c365da54505f49c280d63df37d4d7cb1a5916608fea472a77f843b4b4e150b9ec97d87951a48503ff1681856b6908df28eb893063efcea323dd29ea152ffb721a9d5983019570a2d2d8f4a9263464a9f2c2b2414d8166e8ca03e758e4ad275cc9f6b115b356b4bc0aa017a877e8623da53fb87b3b20676dc40f1e30e53ac9ae46d6df8fdb5806cce0a0414dd9268425bbd1ab08750b44916fd30ae94b52a055ed6ad9017e46c8e2ecf216ce5fca3d3bcddba7f62103820059fd095da3407bd15db8233ab003c4f970ad499954f8bf96fc8d8ea3871c5910e36e687368817416930be53bfb8dbe5b9ce3f2fc63f5bf655f5d6dd2ed22406dfda9814f6beb78f896df05d3e27fbea641e43516b25ece161a239306d0a3d33fe7ab8c7a59aae2e2972373b1a6d3f062f5718f34a12e7e6e2a79e5e77cd4d8aeeb9cfece6cf964cc666374536e43c9c0440e45b98cad94e3bad94b13af3295778c3482057dff2a7891cccd52af46a0e0497b4c30a3e2c1830bc290cfd7d9519f67d391df2906886e773aac0f175b28b26243392f9aca7d0988e61de95123541544c980be3c1a561f1592a115c5b77d1d5ab850b09dc9ae7b4aa4b3782085f81122025e26e3e70682e48bd8e6482864f8d13a5e00e95ccc547c11c83d5a8e97358f68bc040eaa55aaaff537267f59006a16a30ae03f501af27060137c842abb8c4c0846d727027588058ba942afe888356af12d1186d4bf9bfb8f0fa6b5ec2efec1f129287d2c47d55197ed7dc6308641cb0053732eba807f23711853e4745c7cba19f933d8088545aedf45103d885033ecc9f9489e9cc5760deca5ade09f4fee409dbace9baa922ce0d0e77ce1aebd5a2325dc8567c068971b33a7d884b74743f133a3d7e6e8e01c5aa50b76bf79b9ec0544efb0d23373cff14558de9e7c4d0d2fbbd4b2873ccc5ea46ad133dbc433867685b2858e1eca857344d2cd98da149ae1ec83beced6ee92eca0498b92bba6792cd4e78b360e73359129e936a92691caee31418186584bf6f53171f4de1507f3af1fc1fc5dec2a04f45446780417261e82a9129a5e27bff042a3178aaf52e8e9df2c930c27368467bbab71ef06c625031dd31a2979bc39b7708c8ce31247029284acf133d9c8d555a61821198d9698ec34a05eee8a71d563513978db49813e83c16016aab1e433b7cc3db9e1d8c18c413e1b07a2001323212d6867a568873b5a792fe2f735e0ff9c0aecd302b8eb296273358736c73b56b602523a94b8dd39cbdfc2205f681067b4d44f2e2f7c51501367b896ab8adaf2f50f786692d6565283e1e3cca9dd5c7cb4344e8f749846c9c758549297d30859a9a676b7471fde3512038340b9015c0a7b4ca89a259875bdb2aa84e80c0586a3ba1c83c6303a84bcb8a53c4114e0c0d1932155a5ed4befec284f165c40fbe2af7251c8cfb5989bc29eda7d689c3754cb52e011c41b92d16899741467a0772f16034a601ad3c1b726eb8187c74928e2a80f180f0e17be7b7814096490753ca2de36f5abfc78509d95076fa2d7c36a8b82452454f257a2a07c0e89603a0be011229c82dd1a6e0dc97453d3ef39aac96655bb9db0542886958a479f6c38e7af21a36ac9c489ac7bae1596ed2df1eed16d8ac66d7a32a5c879d8a22fe3aed42437b5a1b38744aa7cef14190453fae7672bde16553a8bb1e6c4b4288927e7d30fde2e1660a682193aae7ed950d9d7c4510d96ab60977c1d14926373ab66ec4ecb6350b88b5f8f8b5aefb65ca8bf597be1fc1d18a90cfe72d40c6f1fc68950dc1ed55ec6518f374ee9d24ae1f5c908a823406f409812ba790c3e281c7f6f1c56a9695bdd5ca2ef83ebfb545b0bd62e78cce6b572e5938c17793315a6237c3c554085dd5f03717804c820562d6f9d632900319700df57443d1026ea519a44d03403f1d7f34e992e3ddbbca19dcbbb6286f24182387c1b587321f9a74f3731818240013430d8d7f4a941537276543e123bbd85d6a00eb5e8408a1da44d8173b3ff1957f1196dae2638e05dbdef3639def89ae4cf6e550516fd5502d93a32c27f0f1bb3768c3d44820f51f49fc68bb3234f8de7cc3d7acec2c7779b3f276fd61b5f5ff237c7446b3aad5e1753734277d00365d084ad81db25495ebf2cba7af4e8f1d0a14f0b7b368dddd959120fc8890635f0a685efe81c66bddaa60adf1bde2f07530823d2eab6a6638d0af206a3ccd58009d5518d3eadd2f739c8ab1fac03f744a4487b35cfad4b8d240dab5e0981377ac2942b477be1d9194cfae91d040b002da172fc69d5d1a3aca1f29b9441347b7e0e05a040a52b27493ef6728247ba9918f799d57756cdc4aa7bbfd53710ce8a98f8030f49d2141f666f9f3640d5e50c1f4bea70eb946a40b046588a765240f64eea3224dd847e5128066a03e65b56052d5b8ee7a84137f6c43275cc0110422ae86219936e539cc8e2168bd876e9ffb31a36b2a670ec9945677ac11fe95fe2a9622c821757ce66983cc920e0a8b9224e59133eb3d35efa871b0534025ca5ac435044b3c97c37b2d99bb585c0801be57d9a084250d7c205f05935f9938807d56ee4051faa106042e5c31955a59f986f2af89a37f0c3805f1864320710d6297a901c8f158cd6b50a61da03ea24612b98d744536488ae29689ab378caa6ebdb243e6d7d2bd34250155d469870e368d0d3b2b79a39246688edbfae8e355f7aff3170ebf9bcb1b6098a6ca77b2e244f596eacca92bb70669c2825039be0b56f0c46835ac3dc35b9b08b295248c9218c0e70ea6f16b17d93f27cbc6bb2782f3608423e34bc588a22a16f62bd75254d42416b67a8ac7f75f0334236a2976499e670a28d0137259df35b7f7bcc2f71e5b4b178778046159e1cc9778f2e16fdfad7cc21a05d8d24c84a1415c076d782d2b7bb93c31b0aad90729ae7c4d43cac10d0c016f8a2f4745d708306340e11ae2e55fd8cb064483a34b354e50bb79f82c32d99b4db590a6a0f154c91b48ce6d5ec69dca6409667f348c24be989e4546d33a500e849ea3549e6672b5490418bddb293f4ea5f59e6436b5633a588c8ae3c3efb196871dffe05d9744cef7d26e48c8bcb06eff2199cf918fb47ccb257be1e29f52b6f978b0286a008ca37b1447066acaba268d31ae09450abdd2762036dea69fcff5d04374091c1f9be758f4bbd1a1243e6cba77b6c73dd2232c1fc2304335d71b26a6167cba0fc408ac59c0dfb730f61f9f35f1c322d16ad2b73e2c5591b04f039110578d309bfbf43c8178b97a91e67e691ef371a884267f94562b1b9601faebb318206cd1cd50251fb57658ac99ddf05064ab33df56937ec597bc267bbf58016260c52c4dd121322d325257be23f9df00e487949bee1192d2d13cccea30df7a72a96b70e53679f9e3128456cddbe07a5379fe1dc07575b95e93cc14d53277d9424a3d84ca4fa056989a21c58003e9336da1d298b9b98c7adeee6a4a38cf850a1f01d4443c40f44a4d0fb67ddaa9541cf43f56367a8a75992af00a52da3b5b5d653e91536ba2e49a021c1ad7a83c78a58417701aa7aaa2813edc7a49109e3795e3a34ed35d6fc942fa3be133659d38bd252c395d3345be37f688cc77c512df3700fe10adf88d82bdd5c9dc7c6cae3a3361b150bde2b1a994d489aa8e9f3ba25d1b42be5caa08b92bb102ca21b68533d589d52fc765d6e4cea40dc5390ec8e8aabd25a127b507eaa94546a7a06d4e9e1c386aeb932ec5e3c347ce02bf6cd67319e0f9a8a4ab4a7d0e3f490174747a7eff4db4afd3b0e87a079d23af8b8df5b19244aec32e0eb50b675925653d22bda681a5cd45ec9da295959f2e0185474afcfe474394dd1814b3388043c0469d938be865c1f775596d4fcf5e818b867bee80b39f70ed74a3e375ca2ca58b63df4a0b2dc88cd18d2e9c348a7232d1edb7e313313c0ca8b688ae98f43292d5053b5aebb0dccb07aa28ba8237bfcb696f7fa561f5283f2bf9530de4967c2dfdd1ca732efa2fc8575582426e00842bbf7632207d74e873a469babc795c87c89f62a8bc7a45a62189be38bae2a875e80f44f0a1ec7d4b6a28ab015b459121347adcc7582da9abde32cad89796e374a01d1ca0fc36f05470b2fa0e23639154fa941cf6f43ad94917466ea5101c2d3307e0c120411b4c362090b6b5e11c24585c1e488e0441522eadcaa10d46359a5e465f84fa6e8e69ada84044a4cac4531d7852f1a416b3ae0a9d34ddeb0aaa6715b245ddff6ca122d0ecb8c660618473a96fb8282cb9d03722f0c1a5293a39237f36e2e59a44f9b0de4fb4cdbaf5c3ad2e8ef466e90ae3aa3c7a25812b27896a96b762afb5c9ece6924597a1bb98692bb562a3d202db59d00e4942c6fb45a66dd6cc8ad0a34dfd4c786340a0be033c6c9ebf7ac002bcdd42022339465a6a8df947c3dd8e0d92bb678b21e18907b64377ba4deecb9d6956fe9a2e757004e69b53efb82cd5ceeb0b551a6bee66060fb60e23bc4f4d83393919c2a2c1b31d439689596a473ddbb901a0341aad243d1300f0e604dd01be3ef852901ced943f67ea433f2e51c3bc6877cf87df3b6ea3f06d2a007a75cc740e5ad66c1a9b850d8bb8190e71eea40268cb46c3682c752e6dbe928089578f7d599175f8c47bebd6fdac21f74fc17da916d9750ee4852f45ee74d08093a333658bc16a0a22986ce561e87bd7f3ecdd23e2899243f9fa6623644f1b68436e8b01eaebfc72280f41bb31cc8feaf48d3d64da7098201c720675d34fbc581eaa162050a51038114004e1bd2e43bb0c3894d5643b834601262336e5f2042ae8e8915c5912a31f6475a8528b26d0b87fac2d7d2e697dadcdf5e5166b4afa9a46a52b26fc35def7ef6056e85456e0d79e596db512d34e29d409aa80e321b5747c3501575f67d564550acef3a687d3b5ff96e12741b4caa7e8fd98b3cafb5013fe9d62817dd915e5f56048fba90f491f50f75df4cd2cb0c92e64bd134f24e1e291f8445db874189a48bbd28f05a956879e497efad331b31f04bff569059eb69c37f730db630ccf39b7e5f60e6bccc2f3e89263000e05eb82bf60aa5d17eb24a961a50ed6e55bd303c9e02da34f18ffdc850057ed1f1d5feeab9cd793b4d7fc68a12401a5f6f2920ace8388ec7eeeda591d8807f6db8bbc98aa46825f14641b5f99a81e26c308f454d1c327ac18cb8b66dc64584177f45fb8a900afe9e3411dea6e92482c2814a5b592f467b828807816bcfacc2014035c527e76319be29b580424c9872d02084766cd94f6605f485a9e9fd6123dff46f8f20f69d368825aa6511f24eb33aa5240f585f185f8b905292ffe3c1e80a9fab157094fc18098c691bd9d8a9a519de20baa906ac4b34fb48d2a57afaf93c854564fc2278cbca9d9050580a1da1a6ea2543785a6cbe78975f19cfb72ca1869afafcd80205a1701504477b2e97d9b77287038512d62af6730c75d7943df8b5510a4619c724b23e1dcf582722fe800a8b076bd094b1e04a51d407ccc3850657df4c7f3cd32e0302660e8876951a90495850b4a56cf91e3ac042df3ef84d863b2639fe124b9fefa8892d943de7de273521eb298e75a1064e53fc27aa5e58c3bf19a39331f23c84d68d33eb575bd6cec5910f3029e086f84d48fdabfd8d8330a21efef8434f6602b7e0735b808fbbde08d8e690a0f67f884ae635ccc9fb76d4462676c39f7fb7a5bb98e30eed4fdb37719a7ff3db626930da40344157db81999e1d9dd48cb04307c83f2f1af7cffd6ff3ad1bec09f9f641cc8d9b0cfc5cb95a98ed3e2fd521ecde77c265d7a211669032627f4e76b2e88310edcc587953060bbc1868fdb619526c31a9646127af7d89e6b160a1d94f632413913365450ba73890276d78e9a08b40a1021804deb54de73bec5cb34a0f6159d3e7e01434b9e87923e800fa897691f58a86cb6537df427e143aa1628b84904433d955c04238280cc50959ae9c985a11563eb27602e81b7dda4ca682cd4242e5b4e3dc8d5ed89e1a1f0c0f24bbaab4ac7340ad18dee2dcf6c71c5087a849eb10874dd7add39411a6939b9b0ef6f528366d9afd6ba96bacfe6e1cb995477f1978b5ad131b29b396cf2b9e937ab64d40bab7425fa7f7ef213376dc272dbd5d3a91bf3640f0a944777fdd53581d4d4fce74abe67de104671491f99c18d305699bcf7996edbe0fa098c0e1d5193b1f828370f30f250cd06464a96f9e2aa73b4457d618583bc16844aac0c909713173aa9d200d8e5c7f6d7989ece161870552daff71a29356662e7891f200fa7670064739943a3928436192a654f4eedf6c2f0594c45f042208af60a111cff4827da82646179212470ae4efd5c219d9ed5f5f1d92980233a5f14e890143f2fd514034743d058c2e3cf407e270261ebe42c1b353ec002992ab038ed8d3a6532aca79c35b5f7b15b076171b797e09ff7779a976f89150a9373fba45a69c6d2917faf41632a43a0601069151d7be367fe49b9f49be3e34c947fa2278649b7f0a6c21f690ed41b9caea190b7a5ab4d61d554e18487748e1d970a77099123940d3fc843d2841c1814d0ae7958bbd2b84ec3ba764d35c7989eb266c9137210d47968c130308bea97ca0e03c563fcdd7cf552026051e12738e233bf6d3253983e9f3bd3e63acd2070cfcb240a5d61b2365b7913631a1e0ec818d37a037fc1078decd527539b513a39ab0688420e35ff25fb845c1c15f8215c532d3c6d2d7ef2829ed64d0327f3d50ffc0fc3d7c808f7a95fc4e10a4759223da6bae3407236c6fd65c03195d04a14a2758c6f16aeb90c02e8ddebcebb48ee4cf310ed204c7f2a2054266fadf28c9fdb6989fe80c13a6fb531b0dd478241deb8727573f31e0ac701bc2ddb0560e03725338967e1a68fb184f7f0f3c3065fde2ef8cf8e626fcb28d8f6e86cf393561b61b513558d7523f4f4f6f7532d2f0ee0e01d5a65b13c759a05fab6dab6f85d3a302ac1f91827595fe92f42680f685eb0777ff75b65474502f6e6abc5b8914c20775a763c7caf375aa5f4dca5c9faea2377d9e1c26e80d9c00cf7671d48f3cfb5a992cd9de818e69457a50c31abdf52f5b505269f842614740e5877280ffbbd7db1e88c82535bf4d145e4de963f2c986628a499c6876667f51f23d0cfda9a539c896f908a933509d66d735f4ed8af80406e95d1fcc2814a6f65c4a11fa7b215b5d7006d4a8178660e6a6f793995c64982c2299919ded646f4f72e54c3f41a3cdf8ce4122f8778a0e0ea521d5d59040609f12f8f9b270fb3787892d88b41a6a54b7ad5e578cc204426c50e1063ad7593e435b5a04e368fd8eaadbae1632970dfd3340e74dc651f8133085dc933f5f089c14bdf0bc65533be31d2c76f2957a230fc5ddaa5d0a4323431d59c609323edd4ced1dbf187907b9cadba9401e300ef8c2419b73485057ab97ca5573d21bfddfbaca5731078b88a1e6ffc9b44b1bbd46dd37c86c596c200165d8b3c9e7cce76ec80c98e26f632c3d1f14aaaa21b0545bf358a8dc12409bed337134300bf47a874a4448ad06c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
