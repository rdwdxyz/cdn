<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"375eed5d67cd9ab065f7eebfbfceb7a5b2ebcd17d94139768de6956533a18b8e76f02a3be639bbdcacfd028a637535a956534ece74c3f12714bf989553fcdfe2d906b3e108edd7df0a8f97d121577618714b87dfacdce1baef9330e171e1a7fcbe743c47837d0f3f85b8b9a7b9e2e4ac91f72127306929ac15eb725f1fa6532cce3206186a4a74e746ca1463a93024c8c13e2248ef23f81a2b1bd8883c4af294632a96a32d7aa4653f63b6aee43050ef5bc9441b7eb231c116af7bc13b40c67bb38ffe545083ef10f759c047e4417ff837eea93893977869e5e942e9da0d2fc4ae05e437373f216d61d908862a53e6340041efa7de118f823a480b956089677a2b080e92b00858d74029098751ec69951276dfe9f19f355d6c5d9de61006c27f206618c8d577fa1fb046d0201be22955fe826fdd375493407d0d8594eac01d418d9bb6b21ff98ae96029aef4f4d2f18039350d8af224b155becbf7cec40fb4bd39f28dd0b9a23bd30373c6351b520a3498c639e6f9b9f0ff78bd35c4e25619a8b786fffa0083725aa4fe7b162e268bf9abfef2d7cd7b8b07ba4db57bfaf9887062635b661bd6c06c44d3fa47dc97e64d17de2183325fc7dc4c3186a5d1b0de1176a7163bc6cbcbf12b5afc7573c898462181b495f4dceafe18a4aa21d3f151fe1b5613794bef9f8bc50e594181830deac054aa2b8eeeac31b3c744b676849788005e242c65200e0be5de2cf828ac1af8617ad2a17e4b3b965fffa1dbbf935b815ba37aebde318e52dc9ee95a6284c34ea1627085db3877337aa91a0b5ae822c421e53bd5799564e3265e914445697d3224e4e795edeb17c67cb2fdb1c9d7a82790725b4fb89df7485318108a8ac184676af918dce2aa8ff19527a4900bcb4adaf30cd534416ff9192921b68ec53611ff0e7d88a0e9bbb6ce21f7139d611ce1507d2925c7b4067c57ce6cba88ca03fafa5b288c68930b7f65e801cda9380906abf65cb6739117112e8f8b421553c00b0ee5312be9833cdce217e755b8088b2da74fc36fc17f8d73e0572e286ccfa255d0bbff9db03bef64f86fa2286d7610640220a077e3bdaedbb810fcd8586f042463f0d501ee2aa7d190378a2937b5032518c5b6baf8cfb304dc6c620e3b994849ccaa1c75ba96eb8c8e3104e9440a1b060964c7fe738132a81a828828fba54e63b79adba39915aba73a13db8be1cb21baadfc7116429e5f1a481e0ec3f92313f03f8601b5b978c560ac94e8ca7d6fb0dc90ae7fd29f1c4e38ff9d78af45d44083d6b805efa5ecf43ff02c61d562c7d0aaa404d93d3e2b3f6dc64f60bd43621305b17a51e392eb940f5d3cf657f83edc5fdd37f20649e1b62dab7210a48cdd443e8d1669c6c1f6f9923e6a431b484e755afe14a47bf8500e49cb3d05a930663799d775a8db52b271fd554ccb4dea521329b0f5dacd2c44e16191c28ae2992c78a4bf77e9a6603e0e62c4105a7d2b7999d5a8ff7fb6b7b77ff3823dad93236f578c227723254e02f51d30c5fd1c99317f5be7461d36f99cfc4f7ab75f480f0ede235e83bd7c06f6a0820169ae17dcbf5614013f332e3e36dd3c7ac7c9558b42bb1ba58b501f986d91dc0d93e47f927aa516ab483a7dfe9bc3e2da3570fdcd36022d214b12095f95e88a883349e1d06b94c7196f8885ef6348aaa5b2ef009bc6666096e64e5502cbf377e84bff57c226fadfdc6d4201b16cdfe59171019a78f88e09dfbe6cec903e8e873f92696c9f255e3beae2c7dd26fe63356d0d1d5e13eebcf8d096b0221be5e88d4f400009134f567b3afd23d08ad711a355d609a6c22066aea8a5e62d358477fdff48bd421ee1f76b64fd465e8b8cde3ff1ea3ce218d6e4277e679503a14a2ca932f73d1d9a0a7ca2d6fb54ebbcc609925bddd2160ce75f666846d759a68fc2afcdab55b02d7303216e783f54c94850dd32233b5389c2afa22845582be55954c386c3fa661c80741fda6e7a82e97d6dc329da34e46159491f9067bad2f33cf8b9877b6f9ebeefbd37fc539ac547583a8e50edb73240de3c566bcf24ef0dd0111fdd2054dce67c5a6f1fb44299afb6db1b70596b6f09e0af4161fe631048c9f7f8be1fd8650364754426e1001df285a523c4701f675c93f5f4d6540cce11d05f2cc2ce6ed9defb8fe527e11ec2c61054acd82e174cc3a4a64294040f7435261cf80da88de02066e30448eef78d21b365e50ab1fed6f6257098b82795bda722ae0f3f7f5ece54096c8b5efd746137fc573245563bd22661f58adf22339dab39f73053cf71461bc4ea281babb380d1154748a565dd6d668668f34028aa5083ba14c867b04ec2b8c6c65b7cf2314ec90277e042db5784d0e00c82ddcc1222285bf9cad44a4cf156905ebf872278d6ac8015db83d0d9196108de09607669c49fa7d59b4e8ef58d7e94390fbffe71fffc6c81340921f93bc52d1f0d7f9d4ebc8160e135454db234a222c11ed98bcd1d4fe9a0702c9f9fe80fa285df06bc7e21fc44547979fbdaa6c81c4bf4fb47618ccf96a52c22cf276623266465e10000daba4851fe45311a908de153018a6aab4f0e96b0fc5fffa25fec288f68f88b11010f4a0e957277ce3efb45553bba321f2dc5dce2764f32f131a540f6fc6408ba531f04da5855a4c4acbd267d18fd9e10c5136045a2b68102efc2414dcf6d3a923a37e9fcf5fac59fea7bb50c1c25a07e94245f9554499acd8ad9ee9210b4cb227a7fa190025cd679093c729ade24282f7577a562cc922e1c096373e35ae162408bcbb143e9a5ebe790376dbb0ed7a22b9731c5425c65efd3f40182f0109f3c2dda72c8df3022aca2f2416020828dc08313b9b68ab2ef075b33da9a15d3d11ab8df736b4ed6fefd05f245b81411fc535deefe552db9bd86bc96e541095154d570a210f40e39febd6331e855d09148f6179aba4e19a360e5395e8e110081489b836452bcfcee357c9f965583a8711776919f399853ae8c1b441b9926e634bb1efd8c4176525c146fce98978f44047095c75ae6e265d9dba7a80586d48a08b95c84be93deb3d681bbea85db77acc02d2366deb48ddef9c537e09439930fc8f6c81b3dfa9fb1c5d29f33d26ee88fba84f44bb1ac20fc0b61dcafad75c2b8960fb3046fa9ffd09b4a3d34ba60e4eee4fdfe3b6a27f0b56c0ee9b511aa9a7da3151bfc56d16ce96a4f08e4e06a4b3d699aac4e3458280c0b33e7d49b2885cd392d67b57f839de3c25d20efab31878aa8ddfb227162f6de23a78a229bcb19afb37a59500cab76a4f998cf51da2706223169f443887405af71af15b518e13d7ce36c58ff194d29d0ba4b0720bab02a6f7cd0b77221d5cebfe9d024a4dbf72aceafe770d76313e216996e99106182dec105f3dae23c775764d8037b55bb41b736dee515e715ead67c385d88ae5966325b1e746f4b5768ead2fbfe79bac5be91812c84a24d8fccffcd700a8d88d29483f741f002c8d0aa5577efda88ace93f0fffe0b3ba19b2b8af2858455d5401777d315a5745c87569582021796637e16cb2a04695bca42bebdddffc2a13692d6ffedd7899d6820b2dd7b4d14df1441b41e62fe309453741fb04db5a8eb22b482d54ee8b88b2a7304ac989aabdc8ca8173def97c028084ac19570dad1f86986289bf57bf68f3e01f6d4125e4bd2a7279603198ad81e75487da91e61a38d4d452ea8c3aee81f78c15aa0b602751598704f4a27503d5926deac46b70b0c3d19cce1a504c1b458ee9532cbbb654158933fe6f08c100858e1bffb0562158e9feab74e3b0c2f30c34f04aa4ced394753fb96f47b0f94d29f4181a2cc118dfdbf3fb079a612042e12f2ca3f34374310c583643199f5677d2936649a777f138ef9c53e6bd19726d9803c5eeb2a2a742402557b133aab45a36169976d0558257fd134ecd75bbb076b0e8274f8237ad601d822489fbf18018649136815c93d33122a280106cf05fb7acc531f68818c1879b33b97b65d9a0e813a8c08f55a426c423ec03be7e90234974e12dd9b9dac6ad10ca939c674a5b468722fbbf835d0f069b0fa9541647d0f08b13e15989f190484c8862e57a1a45de4eff02a725b19ac5aa1b70f0fe1eed413aca8a0317270d92fea11bbe5576a8d1368f6eaf2dbc2ef85cd0c2c5f5b3d2695fce94a6a4e4993829852678a42ac8692cd345060087c54f0be853bb42792cfde08f8012243cd86a9f5d65bab47992ccb42887012546b02e7e627e7c37af1bca9a58198ee80c6a41b072dd28ad2ef2eb9f1375b78b1d64994dc8f5d1ee6e5ad5c1081793b9bef25f1997288afd6a48c69f1544ac45fae2fbef1d2b233b32fdcb3783b7cf67c370a6bb91c83bcaf9a3d67c409ad90bda98112d49e65d9c8228991c188f03ed2096ff610c1ef7f8006dbec67f7b9ebb4063e8c653a2cfbf85d616b5270c908ae1cf780ad2423fa68f0677570a0b35b6d8bcfd5e16e003272417702ef0323ac2bd28396504d607479f60994d0cfb46e1ea9812784ed8f1ab483f293f773e81387efd16bf2249e998c1fc28c7d80648a65bacf9adad7ab79e7b6896ef810a25384add6e5545b012e3c2a34e4b47430effc8d9ce15d849ea252975a1e3fc3058a2ccc9fccbbefe33f3a19d4549651de64ceaed8f7dca7435ba4161843aed180d38a97a61a8b02cc6a27bbc101dd3bed92451f255f6fa00804a046f234a20d61f65d667332b066b94b6c02ec66d438784c01ffc8121c24210ba3166c5c92b8cb245236cb7309ceb15f22c3a3ec2bd4e8031919c7a6342b3a440e53089c20a3e5e80511b8aa6ad8ac53a846e6f127a0a99eb8378023b5d46adc8b79add79ed55a1104b78f45f3fbf1877dc9d668c3b099eec6d00773dfe50ff9e8f1547f4763c9fd8d8a89d4655ff417ed3201287da7a3f701e5ecb0e394622029ac153d0393844979eda7afd7eb0cf0e85dd4f5bd5f75794c9edbc78397037267ea42522282df3540457fa82ad9d938176af6d30cf2e87579777f8abdaf377d8105fae79a31d451ee53ab1cd3c84a53b7ac792c87d0c56a813df3a8a5f8a868c60b63c8f436a3bc9f76cf37b4d2723408a5de033b23391a837547fff99b38009ad80a4886bb86d889a20adad9bc6d52ad6e45f7389ded1a09900f89c1b4f6444754b167c39b6e8e06e8154b738a1eef2198f36ef9217d6a1779ec633b594014db1cc2c3e497f963d4abff5b882d66d489897b979c15d313c7e180b746a58fb79641d7a0cc9382b3e4bab8239bab5e601274d57243a882419359ce739141b83a589641617415ec91e67d7e298860928ff94b495ec41a8b8f855a0f1f8e3bfed26413b8ec58c6cd10e08df129a53b8ff70455c9932d4bd91b31b5019603ce3ba7d5731dd6c0f4eb83fd11c2273ed685b456947cbe05a581a3a8d7f24f23895d596e4691cb0969cb278868e1983b16e94f0ba64e8b02cc8a0f63e6e004a07e5552778275675e7bf2a60452a3d36eca0afa414be24d592a133e3d112d78c4b06385103adfe83964e1ef2a82c01d31e4526e78e7861863c03df453da85ac207ba31897c1dd4f191a2b87ae7ed6c3473675a8509cc2aae0fab31505359f2eaa924b0631454e6b78e84080c19dd99778bb56ffdefd6f92dfa2bb1ed2382dadb3093d029db4f8dbb76af01c11a551b9dd247bcb8d6c2ea140210f986a15fd8ad2a6fc6e284e8baf09e1113b82b9810a4f2df4c2d42ab6bd46dffae99e59bd79df219546541d6679069d01b68aa2b335f5efe135b301595e98db54e92ef6545adff4c8ef0619bd83ef400379cd695c500f50bc8c547d4b0f0f7ccec35155cbd6d1628c4c440d80d5de957aaca8431ad2bfe17049c2de226350250526bdff1dea52c07e8c1d1f11be6d6ba2594ac64562f828533c0a9b32e0b3b34949e29d05bb8d7481ef4234f95a91d007efb7f374faaa4379b955a7b8649e2bede81f19b50f251e55ce094de9a385a814c345290cc457c09049aa6c89ba54a275a212536b29f9082a2282a98aa736291c4711e46fab33aaee6456b9824ca2376f71792d6640ee5b3c299c13563be07ca3607a7b5a75000be45ab7d4764979ccc08aa6c786a1de8252b6d2e6c309bad13ec7f041352eb07d4432c623d31140f9cde78e727984565ffad70338f36fb3a66d5a8893017084781ede9c0992a7c6b939d8c856cbf33aa7e11dc92a7a400eb683008d2d31390260facddf0fb858b909b71a6f93a60f450eefe3342f8f4840c406b4ed43b91075ff47feab77e43923ed67253c27f67be323d3355a5f3218885e290ecfecf5a07ea570f9b87605e60c676d99c81810e54b90d027bfdb0fc32dacadc4fa849f40d1d2f2bac962ca429162f836b88d01f09f0d1c2779840991195ddc67cb10f6994d0c9a4f426b1543a329d02f6f71f4cbd2ff9a72f53e342aa7549fce3269c065d13ee04b0ac82346e01c98041f90dc05de0cf9abb5cde5c59bd73037507c4993ffe89bc87d2995a81603a7eacd1cd6d4c8826c0e9d7c5f393a78f5d48a12811557fec9d35ffbde490f1b50d74aa968c18d3ada6076e85a61048c4219f5360b19d8ecaf41a9be863a0a3db1c2d66ed38c05d9616288cbc70ba167b61aa9581b8716a885988a0a343e7aedf64c1e7f93050f5c8d219a67a294e3523f84e6b7c2c4a767c27f58f183e8c5d192ca4b7ecf3463e046db406a5b85472d1bac40db747733270502c052aaa3725af39a4ae904650481cad47640dafe7d24555ddcf7a9f5f2824a8c17b6999d7fb86e3283612f1b886e51bcf3b1ff9b71d4a5efc8caf0023579052036fac86ca3ebed44123e5e2e496104bc91e0134791ea7957be99cd434638358b68c152e0271db2a9e55cbfc0a1ebf64d453d228c5c4451e4ac4cf4dba3244e8085b7adad85e7a546c61c3540af10bd9a4669d32c42ad60e3764c11cfc1368f883eae812c4f5ee8667f8c81575c7f33ebb72b019177fa370eda5c1cdc6a13900acd48dd1298126a512ade1eb21e83ec8b187eab3ac218533fb26949ccd490ed22c8cc319bcccdc312d6f869f96a67ea8c1272f0d4da3afa62faaf9db46efc5c46546531a10518c4de6d431aa2343f8116cd050949b6d91da1a291ce27a85e8c7fd60076740a806cc9860c10fb7bd158f38f0aae086b36becb21551282177a5d575c02be9f1d588ca5e461f1edfe8a32278eeaaa5ab62e5befa0d4c6419517a187b0d7795903f0e7592243c8b0d9d1827e1f33a786c085f4b3cc9b456a24e631f918db63b7d852639d41c9d5477fe3e697aa67e8f65d3029f71e752ae24f5d76865e37dc22952b2f320a3268f71a0433e34573fc47cc81753d4a3239e92a4cf87b6b2b2558db08210924636fb946f3bc7a228becd03e717ac77789b23f450a571b96591fb1bad175d33fb2e312fa9442f4d6b769d334316b04e633292ffbfa448c7d39d7637bc0d43b865b881c2103212a7f73d7db6eb13541cdd6890ddf74dc822b4bf6995a918c8e123617d5f58a72a1113f7dd71906b684b57aa6105b8e5348bddd4152cbb457063e782924c9c64a7415fc1bb647776ee2e8a495c13922e963cb526099e62dd500fe5e21e6129c0142dd4ec0ffcaf5e790dda8cf1464bfca25d3421bdc360d4abda713e3fdedf5c61c8b3fd3b44d05758788bae8a0e6d367a4bd4338aea757be1c52fc1c270aecfe8d2853cfe754f0c03c3f9a3b7d0d3677e4ea389a87c01f20f4da37f8afdea7b955f7bd399bf9d6c3bcf558b2e0b698b18c9072fa7d46e3e3ee2a8115557ce819f80d6eb36a408f6de125e2d954e3be03410cab09f8125dea1645b0ae4a5421dc1e523fb9bc93a0d5dea585804099ea8435d1651f01bd39f38749263ce954c022759ca00d471b4b033bb71216481651f1110b41f97e911d021dca0d71d5130658a0191942254222cf95d533a60f9ec6356903d21deca2b2e3bb7152cb86823ed351899113f9f80dce5bd371f688e1d3cfb52d6c3c4ad7a73568c04cbcfd4d37f5dbfb5d40667c00ff91aa6ece21596399fb8cb02be4407dae66622d324408e1578495edee927e51347ddb8b8784a3a5012a0d4759fa2c434eda194f0ef20fa4fa675b0b8d31462a5b67c8a15c68c98b3aa1f9b6d791e0009135097013afcc4b1cbc873e2f134570a4eaafd379666716e1b07c6031efac5249d4a476c961990cff4d347b294eacacf0736891b9ecc04f72e67727e43871fce1966b94751f33ccfd4bfd4d0a0a756ecca8fbde40581ab250c2b5f8bbf7855abf0c6219badbf2e09b907ae4d55fc1fb25e3212e72473177b8749e8b1cc2bad3d86873f86cfafbc98714cf754ebf5d3d16858819e624c3bf22ef368284057ddb75036007f0754692daeb871d3242a2e401076861f36b903d2a69f1ef087277834e2b3051843f8bb127d91119d53c2649cfd84bc6abe85561490f4508b4938f339ce999f3cda50b0f53ef1316117ee76e702d08bbf5cf8c3b918cebc6de022ed18b087990f99daf378d10bd935ed05560ba5f944bd667228fffd68a00495afffc02eff987535cef14becc69ea58f9bcca0cb70fea1bada3f20490f45aeb4a11090165e815911815a8bb1c0f6859750d0680a6e796a1e5e8aeaa7eb16e782fff3efb7bcdb47c571cdd4b4f0b7ec8d58b73569410d806a04e6201639cd93c9221908be4668e0bc856facda7351d5b134eb85947f59a828474c171e9cb4bf3987743787d52a791da263b68b7e49924c6580a5fc2ad11928ed7c77ef25b49dd4a53a9fa6f29a73076ce5be95b8eb292a621ba4574196d8affe4708c8f54386e8639eb5700feffc7a3f2cae411fecc9e9e2907098f5d066b381b0230820698485f7df142af0b897ffd6e7f84fec59a014520d5a3caf5bd883a54d56a7415a6e63ce34f8f598ff9a954a6d0c31a376bfc9467cec2c8d3a5d589edf8a91445a888f59f476d89ec2a40c6bd33d7f54b5ae5b9160034e48651163e80e874b52f7d2428005a0d6429ed6959639a55ef5cdb92d44c0f2ddfab65c90e0809322a5b52509d81feb0e593793b2de5db93356c39d0f081e8a9eb5bc2fadcf5e3ea77160b5bcf59013f7ef5c5f94b4e8033aa068b9f17721493fca4e40bbc2e6b427cc2f172d3a37ec26d9efcfea1bb2fd13da5c01cc646e51d31c6a8319d1c7166ee7554747bacde18f3c4a0bcc5b36d190ffd6dcc98d3ef3d5519eb6bc9077ff19e600a81dcaaadc5ee6f1f095bdad57db03cd8bea99a99c87b43b748838245037129af14bc49d9897778e9957e3707150b051c49e30e6dba37389b37e46f0fa70426e2c315667e4605f2940303b2ada708c77c3897b1287bef369014b10b1b3f2c0ead05ded4d6888f816f272d5a4c76b1aefa5568d71c97b33d4b34766db9fab34ba3a40d67526aa9a50d4ebd4dc98db1c1cf42272656bb5a33eba2ed4c62527d01649ba913ef17f650d9d937d0272e3ea4e88ee505520940bd17fc04ec982001ef1a0c70217709a859426dfcdcf63c46cbcc091baacc41a0428dc910e0f043b4c0fb573cd358b80530cdf9af1993b7865f746c65d04cf52c48bb29a752c88374f45c19b5b0b2a759f1382ebcaf389834c2b8773a7b1aca369ee3611af9ff27ea512b8817a462c47f1457372d1e4d7b9215ce423f439e5f8a01b66d6fff743339b818e0a3a06e92fc756806202b8f05ff629037d1df4949061453abe4afc4a2aa6841ac88fba566d17470ebeaf22aea6dc2785f602102a67f04338171a6da8b3fc74cc60481c5750100f3af6da71fdaf8c7a8dca23018a86eacafe428a7ca77c878e71e6a114cf6d353891458756627dcd86ace39029599036dd0ad07ca9ca05804d59a62c48f2a98dc398d35a947a752f8d6c2df7c4a3f5f537ecb552d27b6a442ada08b0c70816013682b580acc9139ba165cefa98b428fa9e057f89a5880469eb9f7ac37f6dda7079641ba3b59cbc38f1bfd35233df49d8c1127ebab5d3595ff5fb13f8f27b93f06664ba9a5e5d2f280c39cb0d9d7ab8caba95281cd4fc56167315d182c2aa76ddfe992815cd184e63fb337e526c97a3fb74c2ea9e41b1402a4e1098bb69c12882a3cec566c3c49b49670743e57fa698cebfcbfc912915f29407520cf4a1b20e70f8fbf2c3c9acfe65d1254b1bb85c9123f73abfa1bed539bab469df4b46f2c88ea218047d0f1502ecd74916a8c790d35583d7530e7c22408ddd2d1d321c15c97f5290363af8f0b5047afe7076dae9c9d74d3ada510d0928d3f1bf85911a507e158c010213ae1213f59c772a9d947c0b0c16eb4afb4ab28eb723730409251529033706a042efce76dc1ad832fe2e6b24dd106c329c0dfc8f69eaab899b9e6cf721bcb6d82986ad41f36569d4ef620eac14bcc5f1ff5d7379fcabf111563e6dbc9bf56c47e34a888041949962bdef95a18d375325dc7b2674dba2d14b5ddcb5632c7be0676f57dea3bfd616738d850c95316e94f3b928a3c421c6e8fbf836d6a3c28ec7413c4e16c6e219049defdde626fcfa13a4c1d9a0e74988faa2a50bd42360d1c4b5a675138eb408f17cc7490062321f21b868887495a754c40dd8846c7b694f88459d8db878405f5a9daa279c159adb35193bcdd4873fa4f6cb635f51905c71532e9b769c4c68bff1e879f0f9cc7d4b169e0dae87eab718a8d8e97f7b4a277a1eba6ede8b5e43483d64a8945c7b5cd2727f4c5c0842c54943064dfde5a7286921f26fe861bd299fd8714f93061699ac514cfe2db8816b04df0e7e5d3fadeb338cb160c63337a606a232e54ee1ea8f11b17e38067bdf9eb5cf728bb749c76502010d946eb7685df0b3fe2dff860ebf4e65e14a7f6c76e298a144227aef52e8816e873e72ba361bfebebb1661301a2faca7e8dd7a8e85e6510d2f0097e918f79805e45e006d92e4c9150a231e633a67d0d5e75ee3874dc191a6e64bed8729c4802cdf92382c828d7214fa128973f3af8be5be8a3ee12c84a03b34e88970b7292d99c264bb1d50f6207ca38ae5051396c4eda8bef75412c4e2f9f4845c954c2280e9045088ce4094c771e07bea17465930a22da15bba42452848773733215954c1709a05aeae7ddc0337240c4dbb8315b1a93c15d748288a6b252288e12a68529e93ed4092387f25a8465121d19216e5d85f477850d45583cf4b8c2dc3211b7b5cfde8b2ed4951d49db7324eb6afed49ad509e907d4f02fd28015f2e7f10518aacc9ee3bc902509b68baaf9303fc1a1c8bb1946e608e43f42253bb0280fadcfe8616518fa19207ac656cd10c1a1f81fc3b77ad0378524ad3a0d31116be7f7d44c8426040c622cac0ad9e2ea521de62320649a46f417c93e26ece8d45f9f88bfafc0b02f459c66d6bc7f31e254cab54f407e7dde4d3a729b33374c2ea087316c857fd0af88f5fa5a87c36902185e8d8fdabfd2063d8c0abad02890c33f0974b69bee45b6e091f97475741361e2dedd4b7c6f32d273f346a6d7c67912b0b0a5328731d3d799f274b1f0e70934d6a16d838070ea33a9ed2ef97550007bbe1eeca7324ca11b41dbd79de522bf6f61fb38e1889919cc20a00c17aa5dc75fb3e4a0615140d9c8f455d1615cb87c4323bb73b43159068baf2992ee6183030d5016dd128d30dae95dac090f32b64e76ac29ef52d53aa52eaf29491755de1834c5ae729d3d11191cf336fef6be58b1cceed1c320dc8559d196812e696c13350a07bcf250778c5036c1a374ea6e797c3f8720c7b24f5f54d0f1039fa0850ade47e0353ecb88e6433d736287e9e9079953ec0d8989a7c1eaef32b4b8747bb30496efff6921f770ee713032c23939829bde6d72b4cf5de82f6e5161868c560de3403134d2f753f0129c03a76e09ea1676c160693c2187bf3af85f56abafd6967d0a523b33529823402347fb8aaebae695671908417c4ecc7b19140215d1d124a60c4191c62b0b67d255c677a2fa09db1f2c04ed23689188e0dc935fb3e087e91b877553e3914c2778c960c0fa51080c86bfaf300c9b91d8d3ec4d62adb8d0cdebfe75cdf33d0f1ef70a8e3003ac57a61fa95d6ce0ab963e716aaabd074316a5099c55c611196f1b96c31c08a9b2572232123cefca6cf0e65e73c0b49a20b6345b250dc927fcbf7fbe600df9e548c65502ee553978ec4e505142adde8c591a7fc10db94b88485b85b93544395e2b5487182ec7f75bd59cf11e2916bea0b5607f20b79627197e98a6a90c1f87b61af60617f13765d34ac817a6bcf00d9a98781c29bc46b6f61dc6dc1d9f6dfefda5f697b871c270e1193745eaafe861b567467402d9a344a2b9736eff95e6a01e1d23bef2b1602d602c6d2102b2b212a5e75d7df5b60d642973770477cf1b32033eae954364bf8399668ed4942de2e12c3e5d9a42c9973eb77a044474c7284d7775c62b52106ff379572192ad6aca14e5e1225ebd2109e5a6819366f272d89570f1d5d6a83acfb46d174663cfea4cc5d5ae4a407a619c9e9ba2ca3a3beec3a448e0a5e4234219187cf414a96eed4afcd7576cdf35d53fdac1957071de4b566fbe7ad42aec3ea006da2873f63f47cc5323c56ea162ea3f02183f5b99b24492a28f9878b9faff58f06b66a282d9b8b9c94c1ed639eb2076b7f2b5dae08e417e7ab08af99d3b84eec04544ea901fdace72bcf2d21f4047c4a734169c1b708a8b2ae3c1ec214c723c9694cd2a07b5c38380b85ca49ce716fecf07654fa10518f6e302707fff302ef85ca266a28381503e836ec3e8d588bf09c99aa4a5cdc1bbc1b1333b9b27500878753a8967116711fc2e60825ed5cff15d85644a32f6745edfa4ed38e176273db49c306d33415587d7c3763850872b0db398b25beb9af8f4ee36996b2cb2923607086dd52b1cdeaeadc7f0a6062fc8542490b2a34a88275f50257ce1018a3f9756460557c512dd66ce8215bf915cf4a47d2223908f3a605a76c1abd460b075fd3221f71be41dce5b00ea4b2937a8ed47dc94e5a0e21cfa589c69124dcfa1383a8759e409f1409df74dd7af8bd87ee88de304e7d61998e7ea3c79b82206c9e540491737de589af7de3117ec28d476fe1b226359d6c1f55fce449858a955f4a1f9996132b6d57db84b5e96d8a3464f9a7f8f2d062ee4995c3cefd0fa9fb8be99d7db5307c3f9be4c82c0f44e19ecf4f2a7f42feec0ee059406fc35fa691ad8949aa6c026f0283f15833d387eb976e510c208a29c5c82e9c141bc798e6f3b885d1b39a903657764f2de2c9faecddfc31f2ba9629eae7ca8fd45234194c70c9a3a4c0dfd793977a6572ec735ef6f704d55e4959c97d80b4106d554f95c97b87a1649b60213f65730ab0a523993a50728cba99cf5782f8fb26bdf375788567f2c27810902e83bc2da75ada74e7d7e52d450f1486c4ffea78d97260650420c880caff748114bdda72e61a66f2045e26153a1194aaf459f41f890aa05cea6a6d83557a3a4378c1396f9ebe42a2f0b5abd5a43ec03f3162cd19316adbeb503e24399e0801daf5da9f547cae49b732df92150fedebbe80f361a2249cd4ccac6ae2b774cc9e185bb6ed0257c7ccd54c01e0777c9d62a28a48b2f3d142081fb39b81723d617df6416809408bfee6a695d1e1b3dd0a0ec8d423edf554749632cdc1d05ff222b6d75d193e3ebde850b1b56fb5ee77393d3b6ae7c53a19a5455fa739efe41d653dbb6b12b18152ae4036d2bb9d91779e045276f462c18f28b0a83f08a9cf184a450f28f11adade111f03ee86d8fc86130d5825ce1b2749634435db1670676c1cd9e238b0b44d5ffb318bec826d8526a0ec6a68ca304772d396ff36f9a4eeac27d13253cb22e8ed82b302264705227a73cb39912b9d7fa1818521ecb4b2369229f572fe0234ecb28b52e6be70db8ffc8a94ec4cf2389fc50a578daa8cf41a118ba9c9fccf04359c466b8b03be40404fbf7e0371c2bcdc3715c4ac954208b7efe2489588f0f19031ae9fa53266257782c2aa36eb98dd2f85941b9676c77aae4c7b84b7b23ac744cd0d971f9674cd668786fe88b4f60466cc044eed09aa88ca7d7206174f05eb41223dd1cf687d0d7002e3cf5f53deaae6f48f0b99c841418a851d22c5cc2c0f3a78286ffdb9c448adddf050caf2e0479d5cdbf4985e8a74f5b0ff5e2a1c1f1156b5a824c861d252e8ded28ac57b383903572bd0668348d97f2ee2e142dab38d1d68be4a44d59557b3a9f694a0b2be964dc9767f7c276ea9fbee19c3d178091983bd6315d5377ef5501779292c233b81982e72aeb7fd421f84789bbad59e7eb1a7bdabd2d87a7f0357dd66a1bb8bd36d38f8cd55f523139998c1043d19bff7e1003cc9a26f5460a74341c64b9e921e35d5600b0cb5c4af51a14e983fa6078c29c86dfceecf7b3f40baade8071d8a92c30be2711f51f659ab709a49f0ddb8d77aa3a7249b1eda24eea3fa93342298c0687db3bbe3564383ed1dc3abc7d5e29df2c50511d2943ebddb1a8b5e7e9fcd7fbee56dfaede2bbcac25f8cb7479be39f55ca7a0de18d9b417c19f4d31ee461ea1bfd66bb151452c83244da527a79b4c8e75052a865cbeaeea8a1c05198beba054337615e2ded9de9e4bf1005b1b779435e6ba0c217574e504a7ba924daeda5911688ea96a2817ac0c6815faea42549ae64352006f78780af1010d49f48ee481f56119e9d06fa394048bc64cd84112a916c687b1fe9d1757a8471d699f53a089ac26455d6cecc1639afaaee8a321f5b28a4fa8dd349cec76a03e5d79456219a4eb29d02c41ccfc4914ba8b4b339ded01f75c4a9ff2e0bcb9acbe075f8385cfacd19fc71db6ad3ce6fa0d7458133a55d2f6a49584c9290751cf3463a90d9119c63f4a61becc73720a3ace4fe53d9a413928c25b44e5c8b23bf171bb88ccef0413a1a163d8340a554e8c2399654eb4fc2da8780d7a89ff5b7985c212a0ac870b71ee56fa0cc9ec94575326c268f39e5e04fc964886b0e325b41643bb15520492b103ed0da610544d2ecc66fcf85a13a6c1d79a2ab58cb52fd893501730eb7b81f700e426b0c6129c1718c1530620e05527975c2f4703a57779c9cb4c16a691aed1d81584d4a5d3afb007c03e5fe98555531a62469063932b11ca8644d493597695f94c83c4be3ac5a6feacffc9f72da28d55f18f8e6abaa2bb949c4140a00b4f2116524a54c362efa48a315ba9c2eb2c6c4ded1ba547df4c51cd72d942ad946233507abf5747be98dd56fedb0a41cbe779de658f2eef543f2c210a159021de01712aff625ff3a3e0fd4a19cb403c9bd6e3a375cabcdcea435a2e568d63a4311697deadf244374832fd9948dddf9b85dab6cd264719c6347ef49801bbcfbf4d4bc53b89a606e9d0bd6ee699d082c6699b4a5dd876def174a42cd53cf289bc4c6048ad36c4454aa949167f67a4535f6ffbaf1196acd7c366484eaad75ffd02bc2434680d1d6819bf15e5ee35a7e330650dae3e0e47fa10e5d6f7dfab7d6b032f72a98187f257c30e466645a5fbfc6680f84c8c0f6ed13f882e762efaf44d3f76b7e7b8a15929ce265d6c3dd8fa74ffced84056e8065fb5aa9de657d10af336a8e0268a0ae51b9de61bb21599b9b7c23a6b3bfde34c11f4e219840755266b18f0859f25da0c6b6d867a5f3219ef3d4bec69671a6c166c7447214304a7b97bfc8666d39ae672e7a909cbef3571c9e43e02ac326357d7f355b7a6107180ebf9b4e84b1bef2d7f6e3dbd7f3d56cdb346bd217525f26e38ee64864b8a65ea169f3d4339838a042524e8560a19fc47f5a4c552c4ad92a81d71693088958c4067fe48cf3f10a291d54e9055b8a04c1cafa96c1b863af205238151c1cd0549b3ef941c452b942785d2ee2e0aadc3c3f04ca6b5d5fb17620e693391080b6b1f6c2b28116873ecdbd3ae92c7c8fc6821f7dcf3575b0f8f96ec68ae370b903375d0303c389b7debb0b22d828a19ed73240d19031ad2754dc6f3b1b64bd29df9681901b972ff51e7371fe2baa1ecb3861d26c124df78005d75d6b5e5734f0235757014e505e1296bfe7631afbe08d00ce389fd18429aaec6332120451ed1d552c0cf22aee5f6b8acbbdaba4c28db298cd7a3d89c751eb43011a105d8b738730dde5b77974801a9d442f09dbf587294ce3ad4daf59a46cd5b1cb11d13370af2964ae3a7e57d6715cbbe311ca8e983659d4a825c319c59f6d1eaba039888654c748a44dc5f35c0c3a1f470cb2c40e86f44e59b589cddee0743a6ad2bcaae9261a1a9c95b8109ca2708352f6a20c3a3c0d6169c0b20cc34e7d1c10fb8e299688889e02c347054ea4394a371d2a59f7f7dc42db21100761f2a3f8ac6585f0b594a15aa3b04d173c9521ae9e3e0adc1ac36dacd7b914c7131415b390553de48371343f9e29e1f1d8d04fc9fff8a272f317855f8a934405e04a1e018dcc3646d54ecf5f98d2571d403e8d97211bbc77e9e54d95d890911f86659dbfae186cf1fbc1ef2985e2961301a16aa15d8269f1e3f887cfdecb28cf10b2abf13b2f0d1fac25d97dfa9b53606d05649cfb4d891d931e5291641f8ac1fa1468494ad0ba4697b6bf13bf1641e3f6c6965b59fedaadc4a4a2d56b5190cc66b8254e38faa14be0d3677617db923c36e6ed28da0db36ed9d64ebffa60e06a0cde193ca6a5d2a3a4be69bedfe212fc3194cd80f1ef400518c95273a71a37028af4a5680a31805e5b100c49c45a8d6e3f7b1a881e6da6947735755c584c8d93be6ad0bfb240250fca3bc5034f43d3513df11c643074852e780c23080eaadc3a231e38d0accbb0dbc675da607bc8924b6c4bc84bcd7430564b511c8ca2312be9dea13f51662e14e6e986203d9e027c76900e0dcd9b9af1ad906af319983b50213ba067e25d61b6365fe99dc3da5f589787f10344640ccb5f8f9a6e65393fa76be7cc9b4e7f3d2cac95274d24936b5db4d12d6bab5e3be5ef0cd9818df85dcd56d4a264b7f6785a64dac6ad4efbf846836468cc7ebcf7196e4238c154c0354aa0536b52a86e8047826cc3ae48e2d94ba7536d7ac577edee5ddc591b26705ccca84bbe7e4f48f3a3ca6a36270f60ca6a6b976563747eda05461899d5e248af88529c234c3871e8d69a0e9a427c0a11dbde08900053e7c8a14397f8f67a954d8cb45c19e17df570ae89e4d39df29856067838271e9f671841a09f97fc588b27ac36c597570dfc5f08fb217bb531effbfea3032d7a1420690db621d89da8b3d510c70aa7257076472966a0ad4e9a0d215957ff7c95709f8bedca7dade337b59e5796dfb9d23cfe898cdb7911095cadc810558cf12da87ce72117fee367653d2c9d60e8dd48ed43d532c11e50822fb8fd2daf5bdc0c99e6d0f764c3caea2cfde9486f7855fdb4d617a7a5587b24da5c0807d98c5cfc87c3c20a619cd40e4a9e22bc1bee7b2d2018ee4d18f9345b418d0c24543ffe24a8143b8e8ddc10f75c9bd74f23e4c21ee1bab3b714b1dbd5a96ee24841fb0cf8f651f8b8988890187f04b7959ca0b12fd44f5eb99ea6dc8908a76a7fcbe4e8d48a5fc4ef48a222206d3c25853b636cc0d1b34578df17fdc4e08eb2212d9b4c8f9dcedad0b83bef3b9d02c1f4fb918c6a1ae0edac82a08a8c24ae06b5f5284b48b53308ee5aa9ea71cb3fc377b94d4762cc0ef3189af3ed6a0d2e63a21cdc5edcfb49091ffc289c3226ef43d9705c19a779a574bf27fdad678490264a4794c8912ecad5675a45ce39cf8acc9ee0318578e8acb724a437fe5d9bb170d3cdeb8918774ea97b91c54f13b9476aa9954a983c7b79da099d0e1f66d321051f8bed0b989fd60a395c990a3a3617de39d2a3a004df6af68a8648c11ae7695fa286786c9652a7b04a2c93a79f9d149e70558cfbf8ecd768d5d14276dde9cee1b189b26eef2d1ef10951febfc47f70c699275c1fbd00a94988f3cbed74d7228608bcc4c7db616a1b371bd7b3885c46c9d6146b67c20cae082c2dad8cc2fbd4e403dc753fad8524a618ebaeb98bc1708850b307a0d4b9173bc5782da6cf6f2abda184a35ac747144e435db6d7679b0641d9c20c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
