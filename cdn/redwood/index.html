<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46d38fbaba713939b33a90986dbe23c49c6a987acdd5f8d4dd583a8a1a9f152c5416f2c684ca6a98684d284b4e0054c9e0d4569470a90082fa1a212203edc607aa689eb3b3e3a0fd3bbd67830fd009cdac458aeae79414bf2e98c53d58dcb903313dc57a624def1feedf4a0db2c6121c5966c3ccbe6e31eb437f07299da498de6d7c3323d3bad6034d970eb265440d803122b4d668e301fe3707555106b8e65f553f8cdb0d5500e261b942095399c3f3b3845cdd9d02ba12956ede8fc6496519043407ccd6a2e4432d266eb06852955ca4cdaf22990b9070f43fccead8453052ac32e394ba23067558a77b0a3db75a80326ae9d5128a2c1e3db530db6d61aa6732a43e7fad6400d387682161575254f0bff031ac60ff07bb330907f31c261df5263dc936202d4a0fa1a4f3ceb9c057f557b8b8910b3093879800f844b476dfe9742e4ab03b4f28c036c36c94533acc3fd1c431a65cf476b55f6893b2c25718ab6713604ba84a45263426c15b4a9a2a86ab52858dadd0fe2597f9e04fad1e0eea7d43692c27b8626006030ed1d1a7cd22880c0101484757192f9490eca8db7e7cbc46fb038918d90a6d2b3655f4f0cf0072a6b54512b5ce2947276569212ed57340af2229b6437f05206126359a7d4bc7866d341a4fdcef6376a061fc227d654b3e65594bf785bdd49b58fc29311140dee9d84e94192527ffa6fbe6d0cad173e14863cfa46d31fc8783c531d95d2ac22ab6922bf152cd9cdc257b14df7ed5133e0ae7a77f6a49a78ef4abb47e2e95bbc34c7e7a62a4f0abf8c6974d08e9d01211ad983ecaeaa648c3295a2f7874409dbb82af38ce7e3cabdb59fe4ecc841d1744b4735895c6781f2d7ecb6348febd47b4c6934f8fb3849b0cc77c0629ac3e49f18722167940bcb443ef5fb7e60c40dd772fdb127f83ac9fa2d8ad757c86469c4be8238f5ea69becf467b3cf6f4a0bb0e5d67401d7e27972267814d53379173af2c9f4eb25adf8c4a85dec4bb8c06cc9ca3d269b53c461f1e2934821d2683d26389b6d2bd6f0d35f9eef4788da8a09176f0ac00546777570dcfa5717125fcd30286e76f1df5403112a70ddb52d407f5ef8902a67ce6c31f19f72b76aa23cab205a45b0d2c1d2e97ec784f92c34af1ac212a1b7db18fbc6261ad693164151ccd33c238371000654b50d4d56ff7bc810983e7144ee2d124e3e582e2c9ce786932541155d31ef6f47cabe11306b9524c0df352dd0d349d6637607fc9c8ff8323113c4262bdd2cc48f57aea47b811a53932683ecf4be9da3d8c3baf35af73c95892602343dba7ab961fefc49517d1c7b5da42f8288b7d8718618532798a3d44d5e852d5af39385446e8a5accef360e705ca971e84cb17910f0daef103be8fba133bac1758e3ce8a29eb4eeba7f3a9654a468e0f0bb17a35267a73732ec842647e938919232c977e5c224b260d09606af41731338d3f644fec52666f4e05f5d388646ffe4cd374d23dc745f34c5fa3ec242149e4330cc60a91ca5d0eb056cc71824e2c8797cd30ba37a603c64f11ceddf541ae7186cad400afa8556b3175bb89ce9d41c2c28c5bd4b38689a56a60c8604ce8dbe9d2113874ca22c53ea09eace3936c2e849bc62e03dfd2263111798b7cc0bfcfe235796553aba4d61cd03a92c86df54d740fa920f29b2acdd74e68b2215d39c909aaf458a8dfd7d45a9cbe94f4c8336acb494a2ae20829a7f62b20aada6ecb2dfdce1b2c30760a7c2f404862ba3917c96c092bcc8087232d7558d7afe387212deb8f53e99d9bdf765156679f12c1aedcb621942d3089bc11704ade06c994c74b972ea338ef5de91524f8cac6ecc96422cd21f45452619b33ea93188b09e8e76c2e26af87c6302732a4254daebdc236363cc79d06e63e6c8953c48011ab72a7a8d1f02de0f9a4546b5b74365fd26bcee51e1ff70115102ae3b16812088221740814a412fd516c30a0d2956603a4161066500081c289d63b520c9520d5a36832876cc1154d7d2a80d52d1ee0296b013dbc6cfa7ad78b77c64c271d8161e89c98eea2cdea4f2ecbc46767151e169612294515a948eb57c232e779625d0eac1da2da6975fc8ef153a3f9a30af52be9f2039181323ab2d08392396c4963042053ceb826bc947acb9fbfa8fb7231f9ea699962acb0b0577a4638812db64995757d46bb018d2c3d6d0b2a14d4ec29f533287adda647976a526cc59e9cde454428617795b4761e3dc10e80b607ad63660912c4f806429fa25d2161ec7e7936044beff3d1e78604c8fab9147da7215c218651f76cd9541393df6a6a7985942504413e07ed7e868a7b1409d3cb0de2583c56419062b56e27574948c58abc5ccbbed69ba3d0ade7f3df3ffde25b2c1087889ab3521d7de34fba7a63b085630aedfcd2c552241c723212a21c3ad3c4ee8c5f47df1f2b8831758663207be92e328410c1a41c9a28fdc940a8485f6804060333c6dc300f9b882271e7b85b918ea491dd666fe5ce359c08402b54f6792b627189a84db633ca522e9e9772d351ba0b669ea22ddbbda536aac2699b18c9250a35fb5366bffe55797b5261053239d88d98057c2fc744b42c4353bbe37d7462a2aca6446493d88e08dd61f23d1ee4a56618b734a660f068233be973004f1849de5cad1086d57a131e884dd265fdbb7ee390a14c8a2bac5f34408a2591e01205d73c4b2143fc81f3719cb82fd36ea1db5445f0900abaf5a3b3cccafc2e5bca47a581d8aa100c2f4595f2192cfe9cb95ed7595319fa4983b452310cba7d956c517884edc55705e132f55facaf183c8640011e844fb8aaba5b58f851a1608da0b6c27b3652c5588f0cc240431c331f249cefd6f442ca72acf9f990f23467eaa29c9973c7e2336d83662572741f748d7031f0735470cdbebd3a8acc65acf17ffefc3d4a1ba462e67cd7df66f7708dfe512c2c84d3b7043fec068168d17a153f175fee4949906415d850af4abb0b8d4f73ffa869cc8e74ddbb51f3286a95d25489637791b109f3425f86fe1197125c21d867740a15eb5ee26bb096b7ef4f611050a6ea16ddb8a8341a015a293e816909d1a64a8ef9e6d6a378761d9873bb2e62634499841aa79c7af256e92a56c7077af2d1d5d20bd38295de315e2b39d890e2943c824f94dfaf769ca40c12aa4a7690ee6c61a00bf0fc7dd1c96f5879f2811c0b54e6b0f7c331ce1a6a0edf3f502ed3c7b1eb2f1a907518969cfb700a394957359caf5ffbdcb84656f79c2e042eef0fa702a815ed573db5419f390af42e91110e0d0f2070b3ff5a9fd4d8b65950981e617bf6c6d18c3d9bfff3fa0d928950cf7e69ef313e6d97dfe0f79c0f35572615cf193b736118d581f625cceec3d26e96a4e04836266e47063350ea141f2ec33e1acd02b8ff22846852aa5ff1e75e434c16697b3959d62817de9353384b297d6d74b7d8666224ae5ca60b3c0cb7b85cf8e535a700b8c20cc2e86546fcab7832391c917c7e0905da1dd8e347695e614ee5116b46dce53a5178108e345b77989afd31489d37c5fe6a3306c61c98bc356a917373382327cd57c1de9829e0f1d95806be0d957a04dbde5397d45d22d243721a45e369ec0d5e6c0b42656b8d9b6ae90960b888c7b0256510ecd4ba326bd5f25d9a5dd8635ca8ab0b545dd88aa127a411797a954cea09af16fe192e75b1de2f9df15ab1850daa5de88f70461963bff5a65e9b72dbe5d6e28ca4f388fb7affd9f445b2817680cfa8b4c592996b1b384239d4029260f2c998016fe0c8888868915f75f76c516334e745ac7ee53df0c37b0b6ccb714cd5ab005b75fe411ece7b75fcf042d13eb178021bf614e3bdbc27af296d7d8f4974f9119c68b9f96c0548ccd63c7e003d8aa63955a230639a40aafd94fc7d4b8bff600b7fa705a9eb77e6aac56a31948c0cef6ad2ee69e7e3ab82f035b926f22fb413ac650a00178cbce8b4f07c32fe817cb93bbdeaa852a2e237092beeffc57dc57e4334eb0a4ace5b6d8f94339f46a1925ebc5e3a81c477622a3d987c8cdc7a0618564d3dd89be0b81a805be360aeb36924eb8571846c5dee8f405431e4084ef2eacbba57eca71c96b03c17e0f47df8eaa0564eb3c46a1ea74b73c349d97293dbb634d716216efddb25203b872a447e824989325c530e2e4c39e28d8af742c7019932adbd34a23efec1034df2172511a46e04d147a0e9917b3cf4b850da873afdd19fd9a8f7a21a3e148d4886d2609c976d41c1520500595bbdd6810419dc33b351c05c56cb4937231be9b30f65ddbf7c4e0ffd6f88e8d9f45439fc64ae9b2aff18d6e89bd09c06646237d5b9ff7afb2d0106aaf41aadaa21367d64a520f6b6a6941d6968ff207d8b356bbf7f4581b05af205b9999bb78e50a1acf8eb14e2ea69f5dc8d03ea0a0a651a194daaace907ccdc713f1e97e22a7fdef3e681a949a3bc388c1bd0d9659c17bfc841e06a8e18399945ae3bb3913b40c6f12d7d85a2eef5feb13e77e854adb83612608205d6c05033dab42427abf502c4cb1f48f3c0751ad985d2d848b8ac1273cadcf9d3c0a9cdc9aa1c6897637ad1f42df50c664b11befe5463afce5e988bb820b2223d6ce5af5e943e417be4a6d2e713d52e3df604af94a2e9050ae8a9a035d059632d3c8d5ce26aaf68113d2e29e0b60e035a36b594da0adb17ed01a7deecdc3b89319c5aa8d0ee032878e04f870782234129d917e9f426fb715445402a837f11639c7760022deca99deca4997e03545be341404768e7bda29060a2e46cf1e980db24ef1e1bf84f29a14368b2d94b3e12360b9039ec5cbfa2eb35e636e81bd09c4701f2a6b61015b4d68c7ca401334d3914332d23e6931fcaf630d60e6df370d199807249b1e53770f3fea52928128edbec650cbc48a63aca8888c1aeed33fd6f03fbefda40c260f676613912119ff11c9ef668ae18b066e02a79b835fb4ce4495337573006aefce00566d12b77573f81163a0a2de4ede7625ed7f979844fd31815e12122842c232263437207c5cf8f40f1b9e1553b864c190f244bd08ae9d62209938b8d747f543dbfcd5b40a767940b1029abd762849129c1fd0a21ddbfd225a17ef02e276f3abc716e979cd95e7cd366c4da8bb94a863f1bd2a6f5cd6d7b58d7ca0320571dd05aba82703ffac2699b97a6736ee51d89a939d55114b6884fab5e9b67d026528a466aef76528938877afb2cd1e60fa69a288b5005555026f192ecd46e3dcc04fca3346268b10c7d502e532487c1fa8a637fee6e0a750a98dd5142cfdb0c9922d84a0cc6d4d75ffb367e6c269f0be7a58087a940f4afa51b05434758de07531c060b299b038107748ddf03242b5c783734d03d029b20d8c80153cb72ee0ffad0d75cdc659b3029bac98fc907fd7840f2dc058ea075036a0ac25113f9a004e64b83e31bd109a6e2b56c8c8b29a9e714e6962e116070565bf9f497fe93092f96c28966d834d53a16ad8c35ab086364dfdea2710a59b1b79c6655769de1b7f3c41affb00392f9ba851b457e1c0c310341feff4b8019b9355696914ef4eb0d7a3d1ef73375c8af1812a6c7745ba9e8725642b12a0461b08d19f6f1900b60f6eacf72ae1ef61bbddf7b8bd476822f060b9a0d3a5bf9449c9f4236d8fd18b6a94570553b16b4bef966874c607d97b608e2b460f60fb2145a888b618be8bba78e339c98a9b6037dd91df5ac062c234b61ad431da216375f920cd878a605ad26fb9d417a0341609b9ca400f73a27c701f120158f662af9edfecf6d17d46e8a1a3eb5b6ccf1eb83af9f3dfe365fe3400c80e156292a7142fab60b6cb5341394f83f200953f1eea77ffc4df069a737cc40ce62533da126bb43d397035ef5ba652d1b2071540fa05a7527314ce0ed3ab3c164230043579b16b12c55371058d3c182013334d84e9717a0d65b4da973097115e1579a2c2d56bacd5bdc903bd538163d89cd4e46a5bc5861a2f3bea92747b7acaa7763dd2da7b1abeef14f41f8861ec47210b794e403cea6eb0544874ab033f3008735e5dcb9d52e87e85c1e942205a01d175437418165fca13e5ae6620d4a8cc8c758639ac9d90b47af0ccc84cf3cbf6cfe2e0eab8492ab701e79b1f4f4bc30965411873cdbbb6e586f5d715bbbeba01bb967b884a4e606d9adc029a73acec03406214dfca5cb974adb6d913c04bfa6c7abc9e4aa144a9eba474988b76916428210b8171d74ebd77953a20448e41744f5dc7965b389063893b5b4f63b027875f689b1f283241e4d60bee7f71d0595929204b4612e30ba4e199ada975951f6aa76ab8222767132627e47afac41b81b06a6ca01e88e278c849d3248af9671e17366cb52f351007627c34e123af3cb3069cfb6e090f33e8e7aaf0a442ebe9a85f885e81ac02636cda547b5421f5dc8021dea1fee79e43302058dcb45907969a5bfedd593c7e25ba6f5565a376b16f6826e12e452d5c61875781c077ce49855ecb1166d7196a49dbb2a9d5f851986e4067ecb2c4427076289be2c5a8e5600b1279118f1ea4b32a991608947b16e4eac86298aa9938437949ad21a5072674591b8acd353b26b57284076d248e6c1f2527bf99ed7ffba9ce4028ad3e7be786e25a000f09c5209620524547b6a8f4243bdd42300f1d7ba79e8a1f9d5ae04525c344d466cdd251d5220f0dcfec06a8340e7c2e7345dda6445cef13902d6d6d323433e49b585fe4f6e7adbd4b1bb888872d73aaefe8fa882fa88929547f814406b3b4ce79818dedaf6e94b8650bf2ba03c66b046a6495fbe58a8280c401910492e172d8bb184d61aace8900070fdce0a1a7672cd1c645da5aa76024dd3571cd1dbd8809dbc24224e96e40bf9a9595cac2601a0d110158e4ff04caabf2463f1e23c7bc698977ef203e6bab6e67d5c3be7dc4654a519993291dcbf4d05d8295b644f5547e52be0ff3b044255ad9e197b9a7706492049f2c2f97d3eacebcab70d976743c8e4b5c16eafcad7d38852061480c82cb22911859b2e8e267210763f2f9199651eddaa00b19914db165bf7e822f2c78b94915f7ea041262936f9982f4e83c7d0a422ab51c6979c9e1e4e4595406f13e0bcab45b45c483f8c9d42fefa6a5160dd438056814fff40f743a922ab95743e3e0b497241e91ccc1c95c4366c7ce8ebc5831758be4ca54d1f73d091aa785a113bf3fa765b3e9e480a6c849aed407c7b21292e5112ace358985cbbce363af6e70fdee618220d7206c6c804573b266d4f44fe877eca5a945e5ac472f875d3ae77c831ded8f05a9406088bfa06e324fe7280ca9bd19cf785aeb3abc27a371cc7239c910f48fc2c090150529c2c8b701534a1f4dbd5b3efe2a7cae49dc25aed65c97509826c663d988cedd977b1cf473a8dc7d9b7f17af6a771201c208e6ee398c17450baa3f812362463275dd310f0a37f2bced4a0daa45cadf769e3ced81dcb23928fa57ea645f756ca827206f1fbff7a37eb9eef1157aebf14444b1933e6cf5c99bbf6303030c0d7c518739a868cc3d26be131b60d6d1bc9e3a7a401842a433037d56ccdec5b76723f3ebdd2ed538ffa6a252742ea61654d52b98fabf3d796600189e61e1364961efcce1703558e9275fdb86bcfe40cbc89b7c97d311462e6c4ee94f460f98ef8dba39c95457f4017a8fa234f4131388bc346048764f0047d370f206bf35d903a0a3ddd5fc9b84f683bcb93ab88dd4c803b94f5109136de13f346685d2c1fd9a9321b55a516bdf94bae69ea91586aa0b0a20297eee994533bd7e6da515f1461f493c5e8f81f0579d542059e46f74b89dbbf78c141765b14eb5c284cf8c687c986c58e22ca75ba61f5d6870633a19279667e573280a61fedd5fb24b7c47e39aca25e86e1386fab3312362915e341be15c6bdbc901a09923f8d44cb382d6a6be33bc3e775b7488a48892f941036827cc5e8cf72237fcda36c3964acfb46e4cd890e56d6585fb3ae660503035488328593848c92019780635706b1e6132ba7164b6a284746d4cccfa9ab14c288668111a5180dffaa43d582fdf5a18c10f8adfe463ec0cf183bc685ab49e6fb5bdeee08897161be000239a7bdd853aac045895e309a5ff101c23c53f3bc19c5366aa1776ae3ae149579bac73c8b822a9b9f5a1b95e1f4e8b354b0e15f0984992a142593d2870007b14363b66ab2c4b96c96d9442bdd7782a9160a99978a58c600bff1dbb0f5d256e5aceb01d3d70eb396102e8fec309481556ef1fa9de417d610a82d773616279337e3a2bc4d319746a4b6b89047bab55f7ca542d7ec884fb4f359e1a7c30e80c8577646a101eee230bc298183de15b5bc8cc9af4a74d4ddd1d81db99dd3d352cbdc1f4e8473a57b17ebe00943c9403e62e9d6e8c75ecfa9b338ec3a5dc72364ee2579742e7dce387cbb541cb5216c65ec29e68284602bc3f82ca268cae505cb7a1d5221d8a43daaf34e7774d4fbc66469ae967acfb88e6fa6c2b0b42a0cdabcc3c660f48862c2ed812e6c46bd191c7f6912bc905fe63cda95033e504029ce1cd6c6fea3285ff7c717511076859018e5dcc46a29f926627ef5759a6ca251cf21ee13a58e0c87a344765addff8e4d35767b76eb67731c59d9534e2ef5de3248a561245fc8a9086b3582a049e7a67a6f0f5bfcf78414fbd36ed3b914448fe7f7a4ab1cb8549bca81edde8c072cb9d0fed2f84466c4015e7baf972138ef594cf73e4162dbec631384f31aa85e9e653d22e7111fcc2048b2c158cc2ffa9c05820a23c244fe06b0ea8b23de0e312672f7b0d8f76339d93ee9a44e90b66e8d739b4eca79955f33c197155235541d78a9e02892eb1f42d7fd5033e622d099b7091fb8108934215982f800bb7eb89244782e6cb99f4ee8f6999d0e83a3cd74696544862f1b800a1d1922d449f7e64fb21e81943a770ae85a6dce4013ffb84a104a9ec36405c08427917123670ab88ddb38322d6436134dd183a67566acbd8fe517a492af6d030bfb15e1c3681895f56df47d26aa330f78ad1c066ea1b25ad64ee5e3cbc555670043295ea99be5d40568a05dab8ea5f60818b34061153ccc8b02ddc847af28a0c66c4fdeb8b6c94638d8147c8d3671d864e114b9a1588a7a0faf4f1248dfd6e6ce0805a2735114fff6afceeb3e28d057b7de79aacfb9b1db18b69f6c968bb843673dfe6cff8996e750fb5ac9bd45bf5e327907702e3f771962d821b0e2db2d8aa7efd7d57d4c6d4821c307179abe9c338cac5033c829dfe86d9c2a4d97d9212eff580542511c2f9486a4f42d33e858308bb85555a0228c33f2d7cdc7bbb01eb856e1d5b974e47b071f0b099eb01fe96b28b1e2b1b1af09fc02d889e4e954d4d5ebcdf9fb49a306091f8522ea8e20b42ad5bd5a3d322c2e4563adc796e17f0e20369129494f72b5e4929e65a0239e91690c9a09af83b7a5290d6d9277eff4111c8ae5de0840db85a55ecdcfa276997fe061c946dbc4a60a66aace20b5531bca2db2d7fee896dfd0aa495aa5f0338b57ed27116dd50f4aae8ed5bf175be0fb50531f070170012c7cb92724805661057ea71ab00f8eb65034422ed57a2602c9320df142a5ec16cf4c246f1b533b35e32a64ade09afa3f97a256007d6d86e94cb03c150aaa15b0104cad8d8fdc085f26b940673ffed90a10f47a59e4de45349381879c58729e28492ee7c07dbd05e7c72dc58190768b0f995f84c7c754ac27796a3de683555ad1e09cee15b14f43669106b6cf71e6ec1d8e7422b96607e443795c273b2b357e05b355cae7c5470f8c31ad07c2875bd83562a86ea4cbddf09ec7d75e39e9009274f7027e1d6e08c8623afbc4e6cba0a7ed0af55d059ee5d8bb7e9da080340667655f2d788b08e6065062b2b261530b62a6d6a1029d63e937c5a409bad5d2f13d7d481fdb4970745965bd2524a4eeee6b4f6a9514f5d87fbd61143d13c1177e01a63790d1c4227c3326e7ca629f6d828798ec654e6a54911ff90a9e227fa8d4428dc87f280b19ec01bd409dd1960e30fd7331ca9153092a42f2dd7e0a0f6a25b6e98a508dccc799022b51ed143f201045cade99823a62a2ae740b0f9c4d619869712733da2d14d4452024eaf8d0656eff0dc423924d47c67fcee2a3ac25324f6b42db13b8efd65fae09df1313d77fe73dfc4a24fdc645372934b942ad4320e23d0e86b263ab4b3239252afdc5e621eb8c670c6be3a757aa3633a51e4e949ea3ef2f866038b8755628861afe587138bfaca69ecb7b27b4247ff7655c10da93f702ff167be8363b4423af6a5a1a76f105eaaaeb0fc131032f4ca2794043ce12ebdc0e206dd9deff130e2e861f1bc94130add9619da9bc80a5e94cc0519d60a9b0c0d471b201f97cc8a3bd515abc7ab40de5b585ff96e5f3426e9570077d1506baa0e97d11524195f84cbdc4758ce09b31a6a490cb632b0198dec1b81af5eaa46808af0f884fd6e07176138c7a4cc7e0df853a93bb66eadb51be1ef5a7835274ccb0668317a1cb296b8173d5faaa03031db63b060117787bde5def467f1e7e61bcfc88f4ef27083d44c46d6df1a80ab04905cc87b46146a36210e7397e189c0f34c2997aff6bcecd1a705ad796b11315e706a59bb102a211cbc3310e5916b0e0636cb6cd2c532841afbbb4b45f391547217b30e3bf389a3c62215283f275d49a8363b70669c1b1d352ce5ba0342277a4faad003f7be058d8c265c00f38ecfc08f647b37f8e1cb9a8f0e660edd4eef5a14ec7a8ff88e7f721e495ee179835a61a1136c9414faa196764b3f3ab7162d29095abbb9dc3d802c5cb073e152d72a786807da02d5844fc837cf8f6edd8b4b5ca7d1216faac62fc75ae9d214cf330ad293de87ad1dc32ca518e172251bb89d401e51b202042eea6d57f18a4c2f6cbd09ce8fb7162115ef2564ca64b2291ebf8eb09937e1e982e4ce6475ae4e3084caa141092a6a2f26c13456ec443c90a65fb39cc7845725e7731054f0fdd18c2253ffd2e94be7b20616c0e4b70037c90ca5f317490221d39bdc95e6a4a3af248807fb38c4e96bc08a61f8098a68f58a1ce4ecac78429c70f875e5cd632cd62f8aa81869d1e4d4beb4dd7bd7aa79e7c55e43978dabbd1512cfdd83197fecc5495a043d75b596a051f5c59b391296fd9638898871e83ee1c8d2079228624a3ce057b0f1d14d4035b98987eaffc2f5f1cc7d39801e26ec7f3cf1f91fc4a376cbabaaef71f13ca1273eb08b8a119b27a6f0d2307ed5b99317f2e4951f66fa9196d2055bc57e9d9807570894bfddc24b83a0f7bea092282d5d20199b9a677012b2f11bd63a35925fc97d6008fab28dcca74237ff6dac73f26da2fbf9ec1093e51f7dd1457a4326c7dc25f4ac55bd48d8a46b117d44f4cd4d017066e5982a9707cdf00f7239f8d7e79e3e2079c245cc555d9571df81ae71cbcb35551219d76a0fbbb21d050055d4eccfca7c850ac84cb63aaeeb96789ba4f052a6ac06a2e2301a0103b88024fdd3cb2cf32c5326b840b96222d4b911d86ac7166eb8a8142f5ddc92deb4c1406aed5d8c149d77f02ef914224c821e8093d278a81af3ea681b0529f08383ae68f60d2393f1958906c758ce9840f8a69513f341e426c24f619235ed63ff5f84c579830a649d8baac136e0c68dee927d8d17e208888588e402f8ae9c42ea850d7e5974a7d2e9b4873544413ddf3a156abf2d0adcad2e1a862d94b99e97d107fa49d965668d88d4dcfd6bcd0b169e1f600bc208b5b08754a93a186b56b35c33e6acdd7f9b7f88c0a7bf0b1c7846e542344ebb4569d3a42c878b71376fed2607b594116cae8473a87d576fddebade41d60bb1e8069c72d2c7144c45e864e747be50f716d0d585dcedcbd9315d421eb7e084bb169ce853600e7fa489cc0176b7fbb6d7c07c4b7ff447d30ae7eb462d298773603ca220cc6f79c688d815e37e145efbec3bfe2639e20cbb70f162040aeb7cd0585220abcc3ef408d71e227675ba45f8a031af02742281fdcfb1d8b130d2120673778c161a112842aad6d8b1136f9a686a16537a816d3c1eea17eaab3d022bd683dac2333d843e0bcd997e3b25065160e4728b991570fce0a2831e5ac0aaa4f0624cbd8aa013c6c48f785d9a7158d01f3a305b4b12eeb9c84897af0d58cad8923a34f66bda574b327cf6fc32d3f16fa03a1b5136f0e387f692cc7b6f274bdc1833b5507d7e053873c439d47c5723a581edc893a02449658c5ac94eeb0a078f6f45d9fc6df2b5ed8f062d07b947c54cffb5802c8b858f8b51d4d7098bd8f1dbf0631f232f1c3dd3457527f830e66c0195729682ef00b34356d553ec0640df9f851500587037ce618d0dc8969bfb0bc598371e3a74f9047c1a6d4a5946df2afdc353cbedffed1cf549a5aedc32c4a70f85af6bb89737b1b333a1f765d2335b3a332644223425ae8336adeb782b353851d0fc5af48d886ea6f518861efd90c1a3bb91d1934f3929905a2de765f64d4d3cab7e13c0b2f5f962418ceb8e1f6ee8ceeebabf82cc67c64067fbd84ac8ae4f737ff09e1fb04dfd4618dd7b11ba1be36ef7d1bf8c31dab7dbf117edc63c806641c96eb848df7c57e5f325d31435a4708943cd3c5eb12b9ff780b8cd3c3e8751609ab9a8580670b517c3b248aaa26b5484f2658c2debd0edaba7b8af0d55de1d930add1c54bd19712b30f5bf293b4d5fdcccae1bd0797af029c7ea3b488cf2fe5ee60ab06a7e730420cec7620e4a7aebf372d508ee99f59a9e42a4661b4cedefb3936eb0ba0440a048a5432f0fafc0f5892bab4df52fcda1208d5c2150815ffe861f45378590d03358b50cae99a980b6398cbb15d032b125cc188de370c8ed931372412ce477c60ce72ec49f9ecdd1cdcf888a060185b105a416528b0153897d6b2711a3682ba5f42040637b95939e5fbe231d4a34b058e516a84ab20c9eb36d9d5f27f94154b11f6c4981a187cc74b36a958a17eaa3338d4cc6b4a39b1c05db3e9a7a0ebe3b40b4e2d276bb0d027b4ae99a9341a3ff9ae7700b0628d681e38caab89c3fe2001e07f05bc7379849b256ee7f382d5e7c2f08cccd26b4f1d49317e0797682e11a6fbc744fa7edbd6316e80e651f34fce01dd3fc514f662cc49284d3c2db84898214e10f1487b90f7e1603d3297a61751b616a1151072378f4061711cd58a532bff57dbb32f277b381261920eb26194f31a4646f23fed39b3ffeb189709ec64ac67a559e07d6c06c7efc0a83d633d46a3b652e103e828b90052a271c11b81aa48e2a7d9fc36e8336783fd5b012fcf2b2815eeda3c1f97247f7b793a509012b905a4825bbf7f7df2ef1997430d9b14ca2405c4f4ef9900bd6bccbff4e909ec42ec64fdc8650dcf07f31b31556b57c052376c14125a8bbf376a17b23a8e58141aebbc8d8e3e5e34fbb6d7036ba30a65ebb1dcf609b6bcaa4f6fe2bf22e06cb9187a4580060a299b6117c7380b560ff34f6d44b8058dc0653ea9827da8adf7d7fdd042f59511b3b1c3889c7b990851b6d4451b55c7baa2f61e76d3041cb783f6aa88af578714df4fe766acfa1b04b598ce52f7f85ce485635491af6ebf99c3d59d6b2d84be8796723c8dd8514be8e80934455cae7b4d7c80c5591f7a48e28247bf2d75f0a560f9ec4523f69273b09756557610e525cea2cae6fd99376e2b5780b8f86edde419a1b2df6bc276dacd1a48f0d4ab32b5d933c477bfc737733ae8f510b0425b07d075232ba59954d256668c160fc43b5af5eb160d447ca719717858d9074075337e3d17d703da49d4418089f34245c6b61055123011cc24344cb37c71c1d1bd26f2fc4040b366419644d451ac7b154e72b69803398c67e4a56c6da55e2c4276c6ab1fbf09f5a41a08cd007aa79e8cc805c89bc6dfcbbe8c5f4417d78b52e7207cbd5326229d7d796a334dfb5e749d9d3081c3608a6cf87b7c3fac3cbf13a8746b27bc2afb718b5189eb5ced4127f273ad614d5b83ed756d6f2a1c019573d9f3fe5e12259a351d1c7c019c9525a60ee5d926673242e6f0ea1c29fc960af4563b784aaea8a00f85251a420b49cf7fa7932983afafa273b7683764175589576809c9a0acc57d6d1e3df6638516fea4419f9a20a9cce7d09880671de1ceb4d6a3788d507be21650106a9dc81ff17bbe33dd1ba90dc44742af5b150b1409e458a8c11fa844b3c0e6fcddb575e3b297118b684108c1ea5dc8d1a9c28fc29e1fda4caccf7f05895b86f1d3424424c7f877bf4298a0de1e60da02e033612126f7b82f5f6d9f735ffbd9ae07b294ede5de995d561deaee4f90b42aa090ad115bb42bc56410d9402cbaf4a604798fbd810185618ce65edf39d74335133ec74847f6175b616aad0a4d5f149f61d8999cc19c9b92df50a34f862aa53a88df3e468659d020df10cb2e0ada6f1d31cb80c706ad4cc81a718a11c2747d03fbbda907875193adafe593530f0bfef02180c0a27eeb8c7fea89ed48985f7b31bbdbcb9655f70f42c651b366c86e54196a8d5357df00400e4654a8927bf12a20d707124080c86aae46dd97917a638dbd6124bde87bf52dd33635d9145f946d5637498d58627b5f97af90265ffe83c3cc37f0bcef41c49c6cc8b92c58ab7139424f0bdeb4940287a918a65263cfec4ec7f3c185a6b136b8cbbe7890630553b12c488fba577b32697f139db2496332ab764bd10dbdae864ff08331d42e3c79641e713bc205b3db10dcb8c2577b5e38c28e37142e6a85a64afe98d638dd5a677b7d1e2c20e1282ccfc4aa222a812998cf40aa44143acd4414270337717799ade411b044c2df8dab5b59a938ff25bdbb5c0e11e2b8ebe85586b69c979182996e1e01c751da2d1dfcb3e9420a9f53afba2b46f5f38aad2555027289ebbb57f8cd29fb26ca8fe248b8f707e0ace7c6731bb3a18bf395abb34cb38726abc44da4b113e8d9cd2aa01a87fab159ce48150f9ed889f82802e76affaae68d5557afd5e849e95c4698fb3e48b19fca6196bf223235d7af437c663cd8ccb3b077fa9afcd759d6701adde7638760001fd8a661c488c9cfa65adf8a313f04b7fb82d4b18721d91e2454f83065440f9144c81bbe7fb512bcc5a6f9c7b50d8ed5cbc20bb6d70e392bff579c20bc11b19edc63ebb75b04f9742f01f2164f2ad1f13372346c91f3d7730ff1da4c287a1f96e7212ceb090a6675ef362c409d68c18fa7945cd1a0ccf7f90780f9f2d08cb17f44f75c055c60309d075c892e29a5cd36a77bf9ee8060bb7a514cf151dec98549f5886a2cab5091fdc5d815c573b66d1b27c08c5865ccaf5764e1525b376838aaf4ea92f24ca1259fbe681ba287e6f9756eef0beab42494e47d0f70f45f49f0e86df8a8159b3de52ff5d966672fd42e6f3bc2f07e967364339210dd8f5f4bd7312e14dacfe4db85a6b58ce1619f05e955f7e8ecca0faec64c41140f6ef241f1c3840fd64107f8524ac686cf6160d2c1f0e5f9f7da967080826a1296c1cfb812c47c8710e7869592eca31bbc51d3c393c82978ce19badc334f9bf0419f683fc606f5bb5e5f9fd31bc8e379cdc92067dfc44b416b5a82a8a3aea87c0dc43411ccb56ffc377637f231240c346e657334da76401162b77fc618fed9a911104cd0a852acaa05f5129f2c7d5d1f49d2ba3bbee12acc662cc0d68f36ebe1a579971d203b23afec5cc897fcaa1b343b13216d1ffb70a20352d94be63af8ae45e657a0b36542841d9ae7f8e6cb1fd9ce554c9d181fdcd096db026a2588920bd127fedd55581387ba6fabbe1530981b1d1219f5e178e57214f92e8bd69bea09ba8fcd2c99028cd3e9395e8e068af33ecbe47f34f2c05b11c7b56cfd5f6bb30815dd5ee0c24d5460276f155d056556e123c577fb5dad12c2cf15cd0791a00e9d9986b7653af47e006bf10dad28b201c98a8602d022bab2269a63e7fef76f8c5dea3f395ddff72d329334fd2cff65ae1bd81d98ad4973f6a2d979d60f9826df0c66a469e0a82bb92236cde6bb5996bf856c3678890faeadd076de705639011e1b37381f5f4e8361503d4e863e0dabe3087ef0aa4665092c32733e40978ab0b04d45789e172507b182c1fd9e1e3c399de92ade8cc6abfec486d3d2938e71adb32ec06d81c0e8525d16011c1b7da88af8307d36acec31f7b0718d4f2dab0337ea726c52a5491d086e24276bcf346f7bfda9c446f7935147398c364517c3dcc374c93562fdcce85d074d1012b9655f19a69ec46b6860871c2a1ca10d4e750a5ff5b332df82a3dc6c32f75b8a218c763f4abbc495c83aac39c90227caa238c2164b7a4b6ae813a0f73f084e53c741ffc2c539aba8ca6fa608c9e776661b57ec26cfd8ee0cf9e0e0d92498d54baec09804efb8c2786dac4e299c22983f5cd4150eaae4be85e3ca7039ea336054a4970ae98141eadbf92b9061b3f0773064dc3fb23414c314f5121d8a93c8ca96affa705cf00d57bfa44f1ea6478e4ea245430d2e8b3cd90e5a501d197dcd11fe81129f3327018f6081613099ee81642d26d4cad67da59d75d41ebc5392066755bc447d0997948e05bd7f589d4cff811d8700349cfc544f2f530c61bcd68352aa73af87b2594080060f5519f870ac14f3c83fc14081f25d8452267d9af56a5c1570179210fe65c688805622d501264367ca80e3d585f48ec6af865dd67a938fb3905f7180cf8e6768b689edc2b94972afde20bb30d78353f3682db53aa2056a7cf57af8d6e0bb523666e1c25ba194c73cb428adf7461a4b8a236f25605e5b4bbf457648845a12cd8db11266c91e8e41c38338be85c19638b687f218c9a4c45e804dde3670b8e10cef7097bfc2e0a64377f1b0de8b5ce0f6841039355d7b14488105aea6c31645504c8799c17f7d2dd04a56aa7a07627ae742256e8655ad3a73d650b1db9fc00e70c742e0356b368ca5f5c2b04b80be7b3142f1de16fb54c19ea4d34f876a98f4c6b50abe61c23c9a2aad5cf5169a637cf24d1aee7bcff38b95f2e7a1e70f46ad713bf8c358c4ecd2ae6292a2a5d3d151f9eea8168801567530fa50e37966bd4c77d3545e2560f3394237f4d7645770696cbd3c204392ec046aaeec0433f24438dbecab9f482f3b6bfbb4d3e921ed3d402d3caf5ddd50b11d89d2501e9389f25ae64cbe8df6d1fabfaad1942440051fc7b896de08bebf94f0c4740cb63a2eb3330813b4047d3ecc956491d6de740418a6fc0fb9dd3a235e47e0941b125efcd184781d26acf671c4fceffb20a1db9fc49dc2983a14101577c5ada5cd3f6f6ae08dd1aa8d52f96140c971e4ce526afc77965fef8148e35b01d23902ef9f3651b39993ad8b1abc88de48cd2280e1c5b52a1bcbed1a957f765019f9d242ef46638c8a0970c1ca2e5e14843b61d9c62c4fba146fa3ac141c69d0fcafe96a097c81ebca1fb2da2f3aa8b44f66d5d131f6619280453f06246fec8f3c3b431a7d9e14f4a5b8e1410ef4be5daf820d3831fcacbed45c64db59a707f5a3470ffa8507d51f75df678029aab1e4538f2eb8c398bcacaaff63f3cdca230de3ddb7fcae217afc25c3dc6a6dd1ebc9d4a182e0713fa8bd6b890450e2a13918c0d354ab2abd7b7536d555c8d1ccc7c2392374009c6195717b430d614fd23141178c651b54b0bdd606c2f3cd341d2f58cdbfdcf10beac1f7bc703d87aeae4187bf7c2dab05d7ca02ec60e000f08c840097182365904efc1142caafa0245661fea36de0b2b9645210bbe56e3e55b60d8278ddafa2fdc20ec020456bd25a1cfaa5a7ffda06788031952c81b8f7b55547659ac6e784a542492e062114adfb9d9d3e597ea92b063dc1cdef10e84f4f072c2cdce73613a53a260db1ff62cb72b32e26140496573c0e6ca89e34a3d84cd3909a595a50f2c729c60bbed932fee710547740b79f8e5f4ef1f613c3e05d841de25c0bf9b8084c3a9c978aa5acbd2cb6b8a5979cccedb708082bb6d67c67c8cf8db252c132b2329b7472743ef824bd6877c264ee7b3943bc525e50a31fd312ed3655292d6e3d0de6e4c880a4ff3be3f6af286ae5d16f97c2825e163f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
