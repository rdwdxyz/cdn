<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f24ce8bb85dbd67158738b6c6fd8763088cc60d19859989122dc3933064522de4e31e82bd33f7a39a1c1ba36d57b8d672e1f0ad875b3126d83c3910e40d3159c7a09fd8c441bef700bd103954c497975566e6ede4d9b98228728ed3fc09f1a4eeb0c4c557d7392a2334e8c09831111e47b468a5294f174d2d47347080a0e91b36af1ace7f93b619bc561f557d34a9a2f474c9ce4da8595ba530c70333ab3b3c0f5a06183e13b444204a336d26e95cf4dd43f92e6b847eae6f10bfa4a5d285760fa0792553838ec86c4b2f15ca08fa9339269dbb74ee46c1381b1948113c1b08570dc89ab9541ad5eeb7d81b4d53ba4d6b3ef8f508a369e17bc29311114563cb6963a1729eb84a75a9cc941e16037bdb0319cadf6f25430e7131a728f7a15b037b43a48edac97808006bdc6e567c8bf2e410e604760e81a94631996cdf259732e632bd86d3ab0a0820308c513112d1485edd3522a3a300280284fabfbc0af64d65ed20118aaf97056b46214182454e32a5e477d5c90698128945a7cab773f3e18a2097c1862ae843ab268520f4ded045f9057350367e9818606eea08e66f92e2b26b88c5aa44206cb9faeefd0769d20ec6ee69501fc16ad20b2986e303660b4e1b4652add6520abebd415300760ce98bec9a102b8db0dcb5c5811a89e6c1860007800d2c7859920f3ab6f7cd03347b95f702eec38034e74ab2af9bc6efb3c6fff8875a82d21db68946e45989c2b88facf42a3a15197f725d72ff42e6e83dd89a6d4f160fa1500af702b287967699dd184418b3faece86fbc21aaf10e894c7029a09a5ea1b0c395edf3302ac53e2b178035b7610f680e4acb6c48f3dca76ff119b92fd3f0645e457e36f462086663c289feda2e41f92125ea6a555ebc638a02f65124681a04dffbc6add35b4d17de9168f669965232a9ca75e0b259dcc68195269df08caba4d12fd1d218429d2940315a1f633d42275b60a7236c81c4e195bccdb39c6cbd0b76e0ebba3ed99c17954eeaedfb018fdd1ce5a8b00c55620c7705bc1e7c39915095b8e62cca6f4612eed890eab592a0659cfcde6b0712adcce5a966ce02203290374aa67839fb4f256e94fc235318422a5e5f5407540ffeedb41a1219d0f3615067f0da9e34dbfabc98833603fdaf06becd148567a8fc692df1d06a4dfdb68cd4253e26f97dba6cd3ff33163eb0fb9d526c63628e09f0d47b377d2c79e7774a5aa6d67dc344d7cce9b1de88eb5a28d605e687feaea5ebf3af09f907acfa97b45624e0194aef1037e529ee3a9079a034fd62f605c3b32448082b98c603d4efa166a628cd8a58c610576a903abe785a18df8ee807d60e82f3a6748507c96ec37ecd729aec4ab5ed31f329c5a91500db1cea5fc4b2789717011ceedd4c59b1a447dc72422aa6ed4ad351c1355252650a82a857e29121e63cd3c5dc7bb98e15d2a43df382dc2b65227e877c270e66a8d6a5dabcabeea4af08b464f5d1253e696857e8add34364735eeb08b795c2396b027de498665ee0dbaeb15b4bd5acdd4f93686a91e435760831b0f9285b4a62d9b4bcd78678227cd0851497abb2c836875125f2cca8efe4de7e3371f33b3e397a6092cc985b38708be51bc67dc846d84d49d26e6a69bdbe70a68e9318b053d4ac764eab9688bc2eab7cf568a7c8fd590ae29b84489e67538a2a3f59a103b58e2d8092a6d55496a8e9c98a64b7499f6c02193176ce9bc58e0d0fbea738aadcc98f293608d905d8525f98ab39e4c6185cbb729677e92964ceb58d4397e5409d6885da466f3949d2edb88916a11f7b9c12d0e9c5fbfae6799e7ebde336092ea441696d32dd5e97b40e01ec34d1a83d2cf083e61d41ecf9bcd157aabb71f7b3059162c4e70c3f19fd9ac19b74c0088690dad4f4dcc2601ab011517f8824d5772f42d96db707e9dc07281edfc114d269ac8fd3cd131e8ccbb45fd3e2799b199db11fd0aa1e0c44c374f10930fb61d7af38cb7e05e7d62401a226a06fad060dc6ee45ab1cf1af705c88ece32f89f1a3b7a42eb69b4385881886ed141d82dd80cf2a71699231c97eb8db77abca7d7f2be222180f6b07586b88133c0836d723fdbc4e8f41c643cc746c90023515ea5d5fe5a13c4651db6a70693c08c5475670b11e0ad7dfde3e9a1b789ebe520fd06148d399f3f77e643df41ec105640eb49e91cbf99370cbe3acbcdcb8a1607cb0a9c0407c2dcaa99a8201fab906c506aa06e11126f1eb19c5825368ef23c114e700d1005d3fea476043cd3ff566d911a4e86c3a9a3f4c825b38cd260f32e9fbf74c59f0f45bce2bba4b7d01d1b5071f9985fe36455a2b5f5146619dd2f34e215bdf0d92f90104434018f9d93884292556811cb434204fe3dcba048e95c42e473712f7b940a61080a0e82bf28c6bcd779504213d181d632d44c405e2c188d7cbd6eb46aea1c7c16c793556112939fcb0320adf23a132ef1765751a17178684096b192ab230e9f981c9bd165328fc08d941a3790038cae0084ab6b864161a524feb6bf0c5a939cfe2c0a8aecff638b519270da50d5b03d94b19903ed20ed96082b6038f5b7c3d7e2a3cf49b338679313aa59423202bf4c38eb1c216c39e4c19b816f9e4b7ffcdc2b8335e61f67f38357e2092a94b53550230ac0f2abb6e4875888600513c74c1f89e15290f82d5a157bf241d034e6c053abc3df167ebeb04cf990d8c22b9e8ea9c0e36224dd91f1fe774cb38de64b6b44beef7822f2f6f58d140988e33f2703e369d2a30e2604a89a4d5382b28a0c24bb4a1ed5e86f2616b38500cb30e342aea4b253d3179bf49e6876f81120dfa8f6e18c3acddc7e3c252b22a4b8c72a1f27b73b57f3c256be2aa732f4831e7e3a8924c46d2c2031e8415b4b8c9f6ef6204d331c49850869b828810b3e7e64cd02d5a650001b4258afff69e1e7a6c62384a6e76da371307dd0a7496149ca647ef8bb5e3d85c3da52db1f2ffaa1aed77061dc631bac1587818633451f2d0ee147c83b50273728abbc187ee5f7b5d08f880a96b852fd0ba091a652b528bfc7d0836b45246b6b18ea96af204cb68d0b0bf37cc85d29d8e12b10757ab99943722782ab7b4ceb48330e16d8dd75d3eeb2f8cdf8f4c9dfbf4c26f98b8bc89d4aaec536ffec10b2caeb39712fbb5ef66b54eb190843737343e0bc5545dc5b27a2c4954c561901e249faf00e5d01324a4737fd95968d43e34ce97614202eb43d5ff3ebfff01d0cf23ef2f73627233fd5c71abc0251f9a411fea885d3e5863125126aac462dc394866a31f466371a36afe6367e216c75a65e7de6aa9e06ac4cdc8282b5148ee963f10226c793516a761ae679816f112f1d65a2154cb8ad544660eae1fa8b4a48f20caab6de1ea29bba5a43dca1f465b9a25a5856d4fd88b0cff4c8ff293fd75743bbe003bdd9f3c009b92a84475642bbea5f72ba97649c6d7f466ca770f9899f12babdc0968242edee8081656ef3a18eb7044b2bf75bea25fa13ecd9d09773138eca9e2b4d41ea7143f635d0d0bf0670055e76790d2a8bbe1ea7077c49ef1b99b2a2a78b11f064aa6e0158132740382b29e503359d07dc03d3c1c97aff034cd2a41a55121b9eee18559a09f56e858bc2c2ef2e9af607e21141803813ae2ba95dbf5ad7c86cb350e62b92cdc06d7486747b150974bf28e182d9ab07d192f384cc34f1c256f9e4450b5269e6aef42e91411f389c1081c81c005e9c20b4107918e2a5f259dd6fa2532ffcfa7f70ab35d629325239ea9ddd2af5641b98fa698d16509f396f07b7835b94578986bfdeb2a6d58f35ef86ea3a523f19bf2dde9860e56e09eb7fb892018c1c7c8d4b4bb2953652e9612958e94b3bf215c03c0cdeddb09f7f27a18985ff8541c7b14746f625bdef91e1c3e8bb078e1b408ae942635b1e74193ba3b312a611585f5fca35590c0f6e94b21eba36f4121b5c26b690b1d40d8e6504b21796e7acb9d0f671829001b96bf2e596764b4b3c6a41c444dbe9199df7ec7054785be8744ccb322fc0f0ed26215ede3d80f599431ea9837c0bab5040013c3d00e0017a4fa0b028ccc2fcad3906f18226eb5a68122f77ef666e6d1343ccb8d4021bee2a896fb8141861424da3a36cd1cce9269c3b5d03313e29ea7e09d9848c08414e23d732bf03626099dc4ced7fd6953210c8dfdd75cd1c6fa4a8afe867057907e233e051bb52f0b72620df2bdf49cc8decfa86f9222b291899e3adeab98311be8e8549c303757402d01606bfc58a4422c3fa531f2d89d779cc5045463a61796ecebefb197e60eebe8fdce092cd83fe41432b56188161ff4231bcb1dff2c121b480db113336b04e040c0955aca292bbe1d8f795c2549974404687a87921814655707833991a96b1aa57ef13efa636df487437cb1bf90fda4f2bd1db49e620eee30ea1bfdd20593aee19d25a9beb6dc558e30007ae8a1d8fa24a98c655b80a51e318f7574a008db8f8a4d8a71962a8a40cb77ed7fac871c742e6c1ce7a55eac260174b849e5442c334ae21b9a1bcc802fa9c4bca71f8f58a958a63c6142789a5754add4ffeb08ed5a36467ac36d4b90ce85c5defe3b2c8138a5520eba84c903af176df7626361a466a8bd9051f9cb454a039029ac307df476eb53e3e3ebf92f58ac1bc890167caae3538fc40c15da4612446d510bc435a0b7d0e1813b84211f4a16c7bb75bf81e1b21a4a7c1d2066b7cbecf79710109639b39ee86f5d25b1ba2a760e589f94d1b37fc95cc7a1234380cf528b1a36246056769d44219acbb393f743bb49c400a8bb951c88223f78f8d7f080c3b54f5e45e90da2cef51b0a46c8d5d066b7e8a0462c1f406a2901cc0258c81c59ff0c7722d0a60c235b958824695ccb8bd81c9cf234d58916030da0286162ad827c9cc1cd83eb8c2cf1f9406b0397912d81ba24a58d156e3df11543e41536357c0f87feb5c1f8d9ec2b6ea4fbab5aaa25560bbe180be4b7a97edcf32b2de0bb130c1c3282e668adfcc756ae134d6884f98e326774740aec6eb7820845eee5acbdbbe01d2e12be2f6f84daceca2903f081367bacdb3ae471d1586302c312cb133a8e6e4f5d1111ac16931c7340ac503f7160233b6b83262ded430fcb6e28787d4189de455ef586f107d789084e2d521bdc6af527752010e2b15c9ddcf000ac0bf3e7909e1eb301895ecbfc942479098a79477e8a3e0e33dffac4d0ddf6f94a4b7cd190f0768f0d20345b75d391ceb4bde89bb3203a072e87ab6cbeb84f74181cdaaa2f7477da48ffe11aeffd239a6ec8675fdcc53986f2389fa1d3f2902ad2a0580e604a6e62d76bf690ad6abc10e2fbe722516801dbb1b943c67ad9d30744c59fb0a97138f3438ed67ce799b5f45a7da436171ac0dd068371bdca4a4bae31cf004d9f4115ecef29a3dae71e44ee1064a1c6c6f7163a98bea2b8a86f4e9ca235f7914d9d18131f5b4b11ce963a3e5a3695e41ca03ad70ff0c8011b8bf6f18a0f409d5bea22f7583d43a12a9ca99e8d9ea7fad9b4a4fee4726cbdebe3a6dabdd58a252344aa45209960e476fd55404835f1ebfa95249c19ae325215bbc857988af155861486338af809e35cbcced2992b5ac78edaf91a9a5f53725bea8894d5ad42545ac841bf82e893449bcc39ef2e529e83d1b33bbb330171d6edb1d7740fda2b1ae70b4073fee14a3d4e6fc0dd475fb16ad08627ec79ae89580992bf83869db39b86ef00c072366248207cb93afbdcf379fea7e1918c904ac8314a5602546ebca948512dbc942e621df36fcf1091b11da5c211cb9ea74ed007ce68bb806a53f6571e747d5876cd4ff9fe5252ce8f4348bdc82f65b4956e7819d93f79cbfd6477a8b41a50a936a1b08fe8fc8d1917a3f40e174f426af7730166ccb3320d507b03f2a63d9af22dd07eae33470986dcb281b008f19762be785d1c266544f12b926fb3c25c4581f9d8aec5158e236bf8d6866abd5197eb4e4ebb701424d259fd3e14ca8896c5e2cf2e3597af5393a6a9fc9a1d874f79136cb5695651f69c7f77f68f6c2ae75d17bc30d7f3fdea1a4685e56135d51deca05f4affc35655a9d434cd757cfa1a545f1a5a74ec17f5102b1f10c05a774c60ae8bdcf9ac5caf986cfa92130d57bdd69ac019674071c315f1eb6caedd395188a923270afbe545cec8819f65f624e339ace4934132d4f708f07084f331fa95e7288b419dc420c17e39837ba108c26b04c9dd7e4c6e668791e7db3ce2223020a82d8e70e1fb0ddff114022705a44b58bb00f2d07d61ade4d9a95a2be4e79e0248c74d7c8355eec61f3460f7691bd26fd73611b2bcb1474d6a55d08c6c2eacefc3cd93a7cef50ff3ba381e9ea469139e04476b4119433d89adbd74c42e5940207db99e93dcd382029b997e49b7b2d2488dff01f5a0d279873437328326273dd304ec652ed6608b30aab73ce48531465fbe217ebfdf9dc2ef82928b1ad0a2c0d6809bb25f6b9e525c34d9daad9b036942a50bb0f658f9fa32a276d4724517b4b7ff5b9fc3ac09cfb96c6a93d2f1d98158f4bbf2803063797146a99f926f28aa6dd525e5b0f42be786a2cfbaedbbdaf9354a99e1ae6b467103fffea3272d1531f40cf794962117546601341a38450ae28bc8c28b2a6461519aec4f0f20676bc88402693fde556c5a002fadeddd621d1a14a1f0793bce318e04e9d24fe459fb1990890c7d39d1fe9c393cdcde1b9fa034378e0fe04bd9d45d91753186c954bbf1a9245978f5334ac82719c53d9fa6352be613886d51e69e1617a97c2aa8faf1aa86f908e1d0bcf3518cd4778641934a15949c3aa4a24723b1e4795bbd0cc3b99a43d1a3bb0af1e1753e8a158cccbadbc94633502165d3b79516d9f36a1a6d44d4cf97d70103a58c6a931486339e73caa23cb757e57da6092c082245f43eb8f5118c5b4388f49bccc0647c8c92094f1915eda1a24f5754d217bf727de75d6da44e548ad7ba7d7d7b5376293915650724dd0d341c9c0651912c089ec28fc7006eef2663a38a359af9b764c52cbf1ea1a0976bcffeb56a053e06ec52ce2e37ecffbf6d332b877dd10d0490a4917a7f7b2b2a74ba0cabe5506bc55d628c4d0a7050859e7a02db30d4d586503e87d48d34657318a7b4daf5e8e8e18dd984cd7f44304b100a4aa33820185d2a8970c577c4c62d9e31f410687a5aa8cc6f5ebc608a019adfecad20f4544597fbd286c0654c1c804dbc822272b4c3eec20f095684006429ad7fd9c377a97760325789d5f5298281650d1029fa12c1ec7fba382f6856dcbab1ec2af19584c77cfde4c4ab9546901b8548ab40f0df04fa527f5fe856b39db9ca21da3f0884b054dc7bed307edb3189800f5f9cf118c0f8cae8026aaa25e8c6b03277b990389f7031c57e5b2c73b2940cd43f038d331c67fb0c6ee56797f073157f474727641e6e4fce18105629924a1d551498a88badc809ab21d468566aeaff292d44cc61b44ef29ce70d0f9048d815fee600fa41fbec03d3e5607023a7910e397f04c134f286a61a91353de00c0c6406a92130f2c5470ea4b625b095a2514d0f10ecd2b3aeaa9f5201353e9a50218d7a47b6da0d9ea4d47830e5a674cb19aecdf029d20fe1603fae72a797f9e6d1838f7f987493af86df1931ff23d9cc56824fcce1468a8920d0d887d631c00c9c49cf8ae307a3a615569a9f3d0df562c0cfb08f2981a87d778528b6a3c289206a8355f2f1256dfccfcc0a58b95025437266aed148b5ca8215af5279a92ce0dccae3e381bc62c7fb93bc8b36cc18166b3379648c10289a3c6c7f4b1e549016167d83e2fdb668a381e348793c28675372cbe939caebf125321baf16b22f63120b2c1b89b40cf64874f56c39d17aee860a1096ac0d119bb70e81166fc3f47090d4ebc893ee42881024ba74ed74984ce188d6c75005ed64c6689b2a45b04ddcf2b3bd6109c03f33bdb6aadb710d3461eda5460d9b3cecd703b8e737592407c466d61b6c6ea7e5f6e4000f011075731dfff82da2a3c6325811791c13ce43dd821a2a500665b1821d006a687ef3a299706c05cef48cfdb8a9528c12bbd830e27e9da40987907a651b951efbadad654b89496f0fe7165a711c1bfd9b6c8be137229091fa646a198a93e13920442855412d2028e4463e1b8fb8887faa946fa3d94b00dba1d1e1b5c0cf53e39f2b3425969fb07171bf400448f8751816b4a1b12d799c3c29b7e7031d139ca80cb70bd3b3033dcb3c5b41aceb1a2e61d698247cbef425f5b4c19cbd98163731ac4bae248d4d9e38ab3783faa1d97baed2b50cc39349e3d3f60c29e631b03bf2f4d2394b804c6d30f10758255575d00d2461fcf12079483fcf845d8f3738686882f596ea659ab1f61402774c10d6d99d9560bf592adfca029d59a218e61a75f5bf98538006e777e132c6eda7d14b594d79143def3aab89688021faf00efd036c16152c4921673c588c9590d7beb20ffa2d7575436e25089bb2b64552550e2881cbf324db31a24d07488949b5dea653daab34da63d379a786f6e30bd82366b3cb290db7fb506a77ab46c3299be429757d0bb4b85597de4623790236a5c6ab2443956b87ce8910e87d4623e12db455f6bbe6b1aa64d18787138e00038df0996c6a2ca3b6c16984e928af4d33a9c38042fe76152485055a454c5cac55dcd1a5da80d19476d9caa79cb465932bc6ec3f1096616e13cd582d99d80a0825b1ce48b1db84d5786ca04b5f1731d279124e93dada79cf999e9a26dc777c49d5d92f2a8ef8d79a7dc4ba0bc048233a11ca805932040b9f85026b101cdd9fa9feb5907786a0b2b1dd709f2fd9ac4948d45e1bf26d7a6e1df1981f72ca187f949e70e93152e67ddaeca06423ffea3bde91a6c3f0ac8a1d3c73130073e4dc667c1269757f3b015a04f4ad9024e9e1186079f34340b4d3a10df0829004d8fd188b3c1d0a540508b318c6c1d50190754179dbdf540dc4dbb088b51f873c4d7ed8bffd4ed8d456c6c4961c91089b1d5589919682def3c6a93bc19cda2321e27a634cc1ef72c5b3a37ee3adaa077d4e9edaf2f97f2816eb2b2a8181fb90827597bc694c5384863918cd842e2a1ef01c544cf9fc1bd40216220208c846480aa8f655bca8af4f3e373952d9309663342f1dfed6c45f10faa28dffb79450fdf4d05ff24b13b72ff18f46e9d720e97f9c4b57367ecdad1b7a40a107b1d1bce6d7322410bd6f922e59fe49b214e35202f172bb8df6a42db7c6115a245bf9dace1626af90436f4fce4c1ca4ba6a87c0e676c80e85de9aa81a20913183ba97222079940ebd4ae072a6607ed007621ffec19e1f0d0fe43cdbffaab5fa00d8e47e1509e1e3cbdea61d2aa9dd6862e59311cf6a693c4fa09df48201ad32f201306289a34339c2630858452b27b213056db05271e9f95c71b503182d70671c557422055505da6163f45c95a5befb36abb2044f114ad10103246c835b8fcbe8019239d3c0e2496c0f5ebf4ca4caa087102e3de423309f05307e07385ce481c9983fcb1354d7533770a065522d6413e7d948a42f07b9ff0b17615747616999b72920c2fffe0ab7449574cfd219b7921da35bd37d1dfa107b6fddf56819a0fcee8b7c1a330371aea1c7ca1257d731ea6177c4960c4e700753442a3e82a40d3b8f1683d7131adeadde3c3ff8a8017064d8beed92ec028d1cc5d330b636556e86f629651f36f50ef745cf57bbb46117c0355f854abb0e1628836be3df96e7ab67b897bd4cbf020fd7c2de1dc497b995fca4203f8072f2200665ad4baa7201d7951ab1c92f34cb158e731385cf3c19b2d239af50c267b84c236e7abc099be1d1ff027ed04e1bb49f3c5a35200f420275189edbbec43ecdf5389afe766e615cdc38929ab39b4bb20925401449bae26de6d69e6541d07764434828a42e5fbaf8e210a8a283a02abfbe81e86cd97ff95e8bd0b4672a24e1b0f09748bb70793e7d6b4ecf98d86543332e952a6d723061c395e63e61712e014c121c043178db5895cedbfef6cb8f398c7c008b56031896b8f23eac9982c954497bbe4bca7c86d7f77d71918c60ae4c17b9b1a89b4c0b8182694f463425d78edbe07043307f6c30301f2140fe66ede3fbb298b70a91ebc0bf4de3d4e177e102d4e5393968323134beb2af50bcc60a8fa8b71113a2dfdb5d951f61a7cf5546181827e7e41387c87db680a6c9d4e076bf2aa6ceefface5598fa801d24ad971bcc9d40250cd585d0dafd4ad6b0123f0f26d27b9f0c765d2af4ac3e910b2ebebbd7e34aa17552f381189ce5db8126ba7ed5ca2925f73ec48a3e7edf295ca4f1e61ea222d7ee30ac2401861a7ad078695cd08bd8f4b9beefb231bde2e61ffb3408ce23114961bc0aecbcd49ac927d9fe67e006df42bce5ac9fdaeeddbe4ec6ce5db757dfa058380aee371f6c8490c9afc8dcab730e13da285b8707d248073259f8ad35070434e37f5f9cf04675f93d92fbddd6b03b493633e2049235ed413d1e88fb2ddc33f2d95660d86dca34a68ea7da5ebb42e6d396313d2e5d9031736766b49ccbca5396f7cfe856d2ef417ba95d21ee601d771d8ae0ac9d3d429440c959890fa521d31b0ac7359ee12decae815e95035b680b6b8037136afc9ec7e1e24221e18fb9064b229633dc39dba7bd44e9b878e0f06a08ca6bbed7baf1099c92aebfcf5f3ae18539110f6d6e12e89e7b0c30460dac666a97e1f1c6711e6c2d5a0e22608a1e8b6c7c02b45d636ea6ddffbecc95be36d0355359c1e12ee258012ce5c407f2d00daea069c95daed8042f54958ab7a81c53a2e4e26f27829dff5962c69c503179bb708445cb40433c07199e8f33bd21009b36acbc7f0d4d5c84d5a03154ffe40821b37196753378682b360ae0e42fe966cdf3cc16cb6f502b3606119dd5024b2f271ed7e99bb4ec3f19f1c329a5509785d2d3e639ae81ecbfe911546b73762bbc286909bd1592196ca24fc22fb5f3c9ba59faa0b0f4a13ec4a9d3e01f179cbd27baff9552c6eeb7a361e0dda438d47cbf36446c7d35bd00cb269fb58334f61f14e2e6332b30977d92f938ebc21772c603be711f77eba57f2f70a85b7eacf0f5ba0bbea7bec516b0f88c491c010cdfceff9a0bf94085b61f998de50dec9a2709660696c145de3af5c5a262f69f00198853bb77a9077ecd65bc22b748ff3a04397ec0f993b8a81c8a10338467c9bdb1939332c7b128eef4c3df57887c687ff67868402f278aa299580453c56c6bb30f4ce21490e5ff34ecf5ea80ae35f5e2007da0c68119fda5c38ff3ec0c9aad13aeaa0b94e7ab41a47cc12ce04333ab894e49e92979ca3cdc426e55bcbcbc8ac9f7c27bcdfce3c80c261940577ce9ed7fd0ae4e73c6f4f84d51e0464fb2763dc5025df09ad95118c9594654b661ca667aa7bde285bab2c8ec320571fcdde2fa4e4ccbc29b4bb56531e331c7d6732adace27c863762653407780e444b35bfcf5fe94c394a3779128d7185fbcb4e4bc676528d8c3e2dd8aa75f0a04e5876d5f7349edeb8ad609255a01fce472279bf34461ac64871d04225ed5d524ff56796093a354ac7f70ab135a9c2f6204885af32a2dc6c65c8d0396ff3f997e3b9d11e682f75866fee902c15390a226a95d8e6d2a67fe1af90a7ff3aa50a87e31296d6a9155cb98f01452aa941735665ebccc3be6301106bf67d8f2137727f0df90ed61a94acc228f62334965ece23e626c072e352d12429673909360d3f5b9fcfd53248aa9b02c0a9a973acc53cc8a1b2863fb0cb7cea3b30544fced951aa74b672c13185e549e4dbb17c029dd3a1bf71ee5ad655c111874285d8a77799e31dfbaa9d286d8b77076bc032b473248f2890fa48251a44f3f2c560e1be903d6af2017459d9fd439b2a0855952c81ff9a27af5ac9ea41fde6f11c72ad255f622a95bdb77a42ca93fc8dcc01faba7ac44ae6a5a36ffe9ac0d3547d7aca6b7618e79f6ee868572b3a329cad0840b7d79e6debaa8b38e69c9ece8cd119db53050baa406fd09619320f546eb11600bd176ef497dc52e96d517e870033b3168df165c176ad3c6e20e538ac2a0669706a684213d658a1daa1feeffdd32a317a2a1d17b18c323717228e0bd3083ad717e234e66cf6ba1a89c9c0884fa44ee0d1f35b159553b5de899af54497cef6b8541f88b3993d1c5042f5db81e5667192a39ebf1a464c60d9c81c99ee5366aa318f3e37c045b71606c6af29f4edf4bcc9424b3cd512db050dfcb14e5eb0f0db6c61ab48d5901a674f9527d1ef4e06b081b3fc9a90245482fa0099e9a075bfa30a835faf6d3144737ebb3adfbacff365ecefd616d45521893417e9394bb3125f83254bb7b324c307c6bb30c118c268ab67b2d47c4e45c542e46f43f10763898bea6c1834c8929a370bb1ff97b389cf42b00aa1b20c96b4c822d2edb3f8d9a68913db1c052a0214a540ac58f06b1ad6904233f28da360d8b6c8bc981c9d62c97c14e726da523214599ac80948fd03a1a87744cb70316cda701ffb69cad57bfdbb22c80b25f88c872bed99afb9012dbbe1754b70c251185269ccaea943d2d4b36381f671354477536a4aa1562fa0118c5a79b278c1f7d78bbd089beb5ba03c220b88fba998491fe2ed26709b9647af7e91d0ecb42440528b1195a1bda4547ddda3e9a332b0dfcbd6682ce715c916c3a98105694747c0079152af3f80059aebd870742e7b5cc7225b471382434d40f6fe9aabfd8dd0d845b24d12dae599e09049a9e20a3d9a5043fef1bcb7b2416433584147cce3814d4851867aafa7d9521ef316f9f5a38fb5ab2f6e89494850d722069821e58e70667979de56292a14729229c5a667e07d3b985dc358da63fdb45b57d597c97063591f12b5f08098404cf0d7b85f5c28e4a05c8de328de7db305e611380dd1e3596bbe02a88bba8a21923c0aa3194fcb65d15083311e8ad5b2a7009b63e01d96f408975c3c9ebd2f30179076eeb535120f102336858f0a14eab52a730481a5c059404cf732cca89a0b88e793b58234d01bf433edf60cfdcb7e153929c6d6d9f24c71f7610faa721d068fa4066b29bb2dc887d523835deb488bd58df5a7a0371c0ff3ba754c8aef1f6ce2480d7a659158f50d6b849081ee3df7d61619e1112e85b42860240172575a76c14d50edd7b6c8f2be8ef149519406ac08fa5095b52d59bce828d998bf0b38665087b86b3e6d9ecefaee7b8b835b4cc5b7a1e8c4076287d6e881421508e90be7530369003e6a951b416cab92ed04669c842c365fc654a5155b35d055c613f9d4e20b20a43fb74f5cdfa56936a2bc7b1acb197b4785d2cdc6a632f342a30081e0dcbd093b6079b50e602f1dc0f7cdbe8901b1de99d8fdd592a545f499c6f5f2aa7caa77be5746a44443110860790813684f7342cc5ae736160e23f22a9f998c297fb5d149e7c54b967c62200f1f8f5b23fc87860d7852cd4a77e4b7c541003fd6d69d9c6274746f9d7538399e4fe45a6534075686e911017ce54b08e68c75666be4710094c76b29d1c2efd896ca2a42de4246e8bde0176ebace0f962f225022aadb244362df24c3c3aea2160b5949cf6add1a6967955be48d7b6a0a9952335b93f223ec39f138603d946c6f84bdb2e36832537328d887f41e1dd493397c557695b0392c082040c6c0c2feaa7999bd13d853e5968702a83364e5f26eea3546ec376b58c5f8c2eecbf3073a1f3fa8dc4198ca826c4c6d741a537f049eefd9966f8c648ab2b3e5bb107f45b5fe87c9dfdb19209c81537be213c149c3d500c1708db7e58d17ceb4963557931916202f67c98d089b5a5b731987bf9900acbd1547431f5e52cf0713edf1d5bd0c8b7db841959149f6364766bd1e747f95df35087ab9c5e0cc62020a56aaaafdc471eb717d35e375f4a814eff90713e91c3e5aea61373fa06b244a53da647a510e5f47039cb47f5415d049a47dacef55426fbea34af6891e6144c7deb1eb228fd6d46fb3aad8dfb9784a029ea20d27177fbf69d17467c107fc0b2d79613953c60b64557136563674a4e96fc7f99f3a49e3a420aae12b66c6f322d4437ce3b0d739da1558f6b222fce8520f60223e42187e7df389f0f90ef9e0578eebbefc0a552a173ccb0f10179851c4375b50151b64f401645572d5699e26a8e3c181fce86d5f185e56c0295c278ec88634d2e4c1fb8c4a362dc8c6b1a352adb958d5ad8294969a5a044aa7aa20dc9980fd21159b433c907dbb386fd95e9e1f913ac7c343cfbea1a7cf96ce219b4be074ea5e4fda9ac0d6445305de0331be6d69653f26b38175c0fbb0049843ce6ad1cb8510cd7c078613487caf3e488ce9778f356fe518530b529155f18dd3d36a7712967954f1b9b93adb4a51da44826f46a042ef95d07f83407534d7bd75424c97b05abf97f5eb17d7ea871b7b64f82196b85b39c8db0e70f30f06a6b1fd2999362cef66df9f37b1a36d43c0c2fbbeba7bb15405138b2a715b1f9a97ba9e3fccd6d3750aacb5c49eaa73b12fca2aef9988c527834f5e582c32e5eff8b12ea4b287217a6e485ad2c6a6b66fe140f91d2dcbe9872ff02b20bec1bfa7d82ca1ae7a232e74908275301f024a6da33eac8189301774533df2dea943e4ec05d7c3876449e149f392fccdc0101683fa4197e674659f10c079435b3bf6913f9294db2be7b9ebfb49164a93a54896cfe4f4a5d6c55d5732eebc1fb7a6a03deda8ecfa220504b8ead606cf39ffe79d20745bf0bcb2f9ce3eb8107865d9e5605ba7feaad4b78413933af584c7e6fc7c101ec93ac68757c012e4bdbcc7d0f926597d0835ef3f48150add05dd215eb0ebc3370764cd92cea18c92cd717dc7a87e7d3f26918914002a9375c9983023232288c0c2a2192fa996203d92139b022fccb4a3bd41b5a00b45da1692e79094f6320c47d26bcc35500c5bf29495c9c15c072929cb284b3417fe62a66cf049feeb4248d072227097b3fee87d49033718dce49930e8f6300e617077acc43af5f20ccab4606c2b12789eadeddb4497be5ffb2f3a71febdfd024e8e22ab6366f5e7ec613081c1a2d834647cfcae24cafb43802ddc841c83b0969fabc323136c2005187596a44e2429a88221f112e5920e787b270d7fca8ebfd002a7fa27a863e1e4275788a886f2f6cf4f4ddfd9452f0a5e1432ffe9a404cac4e4b487cba8c4cfffbf2e1308e7561b9f200e88aebb2fe373cebf176ac55b4029c80a8d06d57d2b4530e9b1a1ef93c7bb4d89479fb628d8ae031fdfdb302025508b9c00d8c90cd69fa86f37c8f7160ceec6a438008fc824f0599ef2d404c71112847fe44492da4a4be85f0199c366073a9cd145b65bbb83a7622a697bf1e52014ab124b3962b3c7f2890edea4aa459ce80be7cd89b8c533a9601387c6c46bc52af34651a15a769e4580a8a67df7cd1136ae746506277e72d81d6e7b26674dc3716daafee341e4de1918d5dea4ca5036cb43b2b8a6b5568bb072984513ce397006681fbe3a0ceaf3d0fb920dc64d7f79466599b313a3c01ee20b11c7a1b09057901e51371c35b8f00d834b799be6c6ef32d06b29b585698f5fa08fcce7fc8ce33ed48f40752a6e0407b5a49d9cfed938da46e801691db807f80e6c23a0684a17dc43c850706fb0cf7377bf246f03c02d553f74d86d69cce76d85bce5d916e7cc778cdc230276e9063a42ef6607fab562762abe435c1e64811e5a774ebc5059d5024ba0f67a664f7691c251cb7d1fe7a245291a666e202e865ec6137f6b01f5432b9b973712638d8ffd1ceb5739f5aa59aef527ac1d88852241463a8675c0bdec6263ea64486331007b89601167f8c93cfcb8eff422ced157fdaaebf20ca67cacc15ed9a5a8e7be788b0c753c9c1d41102701a023a1bd078a357e2e2f1b20816f694e60fe644ba656156d399f31425050ef3324384d6561967f1e604fba7910f3b04036b5e47045b93a09a356eee7f12b3f2ab4dc29a84a8ba494f39fcbfc3b5aac24e974d6316d41f23c24d5a88fcf8f37193d6d58ed0cbf313142dfa103af4c744f7ae44bb13593b6ca087d28a447555e7438157eae07b93ac904985679e669b87c98b8bdc5a36b7f13e156b5f7cd3717ad11254a9e4162946b1618f64188c379d259fa21904ea0a87c4fed9afffe7ec8f55098db164759aa3a9cbf4c9ddc497e85476b7d53d5b9f73d7bf82b4f239a9d17df39d79caf5aa71c48f38645b017acf13828f13d69c0516ceae1ff2de113d104a73071a58cb2d0aa951d2856aafadde091bfb54856ae73a7484e1f193cced361094f703da0f49bf3402ecfcff662164ea2fa1bba1a9f0d56cd6394b00c1679db4be9bef255dbedee637be6512c2fdb1b4445596e8a6e7eb99b58c2409428e6828db71ab0ba7c2cc0d6d22882ea6910500c4887e28dace4dac4271a3311b077d85c4ceaa6d63c6998aeb887e63b0823507c2053bd25633f2c7e891b3cf48b024ae90bb4cb0d3120acee23f208a760a392134798dd986ad877e58bc1ef6dcd49ed62f785933eadc1b9262d290190ebe7f424ed8ad08f319de67123eab6e18383cde3c15a208a7ac6a6f9742eab47ff014bd3982ee2ee5277a060b2f4c74001b0ada367b511e4522b01fc00e0fb4fa35964c79bdc152de6baaf080df2472399b61aabca3d1d48bea16bf6ea11146180d4bc18cdc809a2c018baa8918ea81955ed64bc9b966f791e53d86f33fff457ae00be9b7cb8e24e894ea94946bb54f572755603e71bc36123fc730997cb471146a75276d9283b312c53edcf6e815ec687967db4d2c8b61ba4b2256d3cfa105e5421d306fc6205172f1e4fc6e51ecf65fa1ae838e13fe514bb8ada1681719af0f56fe84a299f323f51e03762622ff145a74855ff7fe286eba91a1ba7ba1acd26f52eee185dccf6b59eea370650ad3672b5f0580c2b9120345532f5e05fd7a5af0ec3cb518c97d0f3899a35c6c6cd3008564f12b3c2ef99df6f170e60aa7598352b5a480aa2b208f4bdf5b40656c76b527dc909d0e16e22273a1e111611e735b69d24d13593721e54409d0fc502de41a0454f4c2cfea2a7861e25c48b18816ba9cefa7f66b742b37237bb37ae21b071652434827e49d51eb8aa80d6b285538cec8d5e2b63efe83c81d03ac28bb86afa67696a2c13a08930b7a4092ac4a78109a6807d085462690391a26ab66aec9d53e764673fdf5233aaba6d21aadd4f3fd4ec7e966c2c996385251c51ab4291ea9ab061593306dc693617d624d8cff11e6542943c816264db31141117e3a1c7ffc4805c394f101cbc979c1b36e622d37b947df8de509c1a04db6c734a68f42b37a4b9843047b1e658241796e4788457a3af32e66261ef9ac3c92054812b3ee6fc107b849e0580f5074452877a18aa07fe85a25dee67f34c385c59abac2ae29c792878fb9ae518241acdcae69b2d64ba2147f2a8aa3d5b3c2ebf9d5e4e6149687ce434f56a0ee966590377cf487f79a7bd035c6f0deec3e562ca04f2a1ee3ff21a82dfa998cc3af235d99b7a9c4c83795de05ab4f5a20522d0e606f4e52c5ff8841dfc2220de0c7ac0a2f09ed30df89ad948c38a24de0dfec55051763f55c1b51b8d484d78ca84f4661f1bcb2b622030b26d1bf781091b890f4e99df577caf682dac0821daa5f6124e2092b8dd75f9eb0e3427fcf1a2f2e84f068dad581d40543c527a8d68852ee15ac974ac778d14d0a34c464a75773eefd1cd38b1761abb6d7f74236189e3aee90a282f41003e12941dc7727cdc1de399b5569db45cf08356902dfaf45af114b7023bd75aec31f1959c4b74c745f634e292c05b062c6b9bf130c76b42def2b6ae69c6ab8548911710c2c40c78b9cfe0d6d9aea9729d0a53c3ba920afd68726d2ab6d4fca505296d20db2f1b67994c9a315273a06714ab8d68aa82a7d3adc60c13574cc5fc018ce66b89709e14bd5550b204fe9a41fc3185581a7e32b1d4403fe2cb372664315186b8c2c13f4109932b303a10fafb3ab02a8e1e8d95b4183989963d080a504e9fe02cf0a0c2035c4c98bf84e4d9326bfba03062","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
