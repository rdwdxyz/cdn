<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a0e1fd1f00bc204aab94a8d5919ee2652ddb08af357cd995ed0fae48fcc1e56dcf65c722251cb7595604ab423bfa0fbce5310655e6b870a50cd9f0515d3eff8c4f308768dc1d4e4271ed4b925dc9427c7fd87b28122bb2d92a197288ceb8f0fba45b61229c08f1b160c62d6eeb0341cd57271a9bb6ce91ddb70df9b0fd9e145709ab54de4d5355eb30ff77deddf0aeb53a97623d8fd8173564ba832a48a3f9cbab9c8ceaff59f9065ad836b3688e4a0590f147271d8a3aad3d7f3deb5729d3c27f3823b4f1c759a9cce2be956a7c541a10c95ce05711bfcaaf59f1067b5c594926f00573633e8229a3bbbf4005c0ad1b77af1c8ad91ec32a6ba990292308aac1824c1d465ae6e028300708f8265a95feb73ec30a793a4bb8b441004deb28fc50ef3fa7a039fb6007417a20699bc62d370428646eaf31e3c7c161fa3f3d5bfba577c1ae1c7da3658b33286367b6079bda89ce3cafdbe68b11f8be0d58e46e5a2aa4cd185ba3edd29e340ebaaa80ad7e96fc736f59b8d5ed8fca076950c75231896eda86885f93d29476735e7d0d3460b3f712f4c41dd82f49acec177df7f28989f2e06f020a6ffa4e7012c2d852197844d7da1881ab3b09b674a09b637aeeb2b23453ac1d82407553033eb67848178de1a906df888b356ce158e721cac88a2340db39a1dd165684b9588145d9b849233115964bdbd4b6971e40638be60bd896c27bc53f43a833ab873fd7fc9f06aea809fbe053fb2fe4f3640b30a354b25c628698aea3d1888a25df3b56ee81db6571820abdbb888621e1f1f47d9a0aa0aad400df1bba143a6ea5bb455f3c251e2d0de8c782721fc5428deca5ab22c0320d5b1a0670f0346de69c625c150cca535fa21f5396cfaa08ea0806239f4fa74d5118df1914dcb929e856d74b14db9d72be034dfea85e0329ebda6080004dce4d55f13e64c5079682a83bc233446ef73cb9363590c1d2bf59786b72884806319be8a5c2127a7b57219a788491b2407f68526f507241f3a7f098ab705fa79e818b2e993b211aaca72b268f5a805d0b950031ecba0bd9a26403586114ca5be8f0969fcbf46fa8fe7100288e7ef9d345691d439d3affc3de99618f7b3a1ee323a2cff5ef33a4805f17143de901169a7963fa619d331eddb385a0d8021d36a14755f8b39d1658863667544447e238a03b2f2ee4a835bfe33509c3d60287e1288afa692f008e640ff85a27feea8dd46ed3c65667ad35110b585dfb6d214556e940b64642a90051a3585e5244d50decbad8fc52fac422eedf7ed79b9d81ef445eb0f32ac540ac8cbc6867defa4f2aeddf4acff4b516ea334313be7dcb703c4d41646322e6b53224804d1aba266ec258428b2760d3c9160d0d8ff1f9d6609dd146c91646fe2a1088b4b489325a21e75d76b71508fd6b29180f7da891ca1b1926f0a030b14dbb18cab08ce12c8449ef50c2842ff35eb6d2fa86431c6203f02f17fd5272de40061ade9a2161c30f559de2e0f3ecd876f85892433c63dbb3fe4b12a558154b5596d97d8d15f89f277a3b95e93806474ac088a51742dba0800fff32d7614c4b052fbf4746c80d6c18a712fd30c0ce0cb7598f97fd707681796977381abe1a09f75d182a11ef8377cf4e0de3d6c54937235747d39a2570a49093d78e1d4710c4fbc90e2ad3fe69041476d078dbc0cb10fe888af23fcf5d4d4672ae622f9c71481696b68f77bc08954e04f996e2aaa82a6afc673890f46317117786dee4678a2f97c5854fca929d2f4fdf3c3fca7736078d9f30412ddc8accd52b4f1593814b99efb0e34318f16e28ad457bfa76c0c394a9b6b12ed7d62c05d80be7c012162f4032dd6d9e3af730498b7852d6bf35ec9cc91432d0f773510215056f0805384f2cf83d51085b1ec1f0fadddedcfb8178bfc3a68eaedeec994d4ccd856c206faabfa317b28cad05dbeb461f20fae65587958b90ce184042da766fa97f7d86e3d8952b09ea365c3b6c7f50d8150444a8d2a25608a60c3fde80b76ae6c73ad10828a2c7d672376e0ce31803878a9ff5df462e856fdab590d9f09f9f6e55e220d12aecb6216d4a0d1953ca66986e333f9e27538193e04e45f50935cc7924bf2694738f83f0de0a14b6fc104c0ce9a70657e3301b8ae1de55c146ab3a17dc42a5d75e8d50b5e6d8e819b85ba5f0a94f770bc23cbd4820bc318bbef4ec95f83524bd02c46ada7e3ceeff08cc7c828a2e7bc396c04d580a05f1161995f7290a609e2c3275533dd57aac34089ac6dda5ea92113755043dfe416f1f825421b757cefbd066dd0ca6bd9d133dfbe02e1e24801c2170d1ee4f3a849471c5af19e83a29f9e8e2d34b1bef842736a4ea0482ed3ec26c14962e0bb1c6ce07f8996d6fb6d196ffd6b262032714152cbbe4890bccfc94985e6a3546e919739b43d8578f5ecce1fb615d7be61d308d6b88237c84d1a3e4707ed476fd75010059fdddf50dc38511ff768c492e38592e645cf5ebdb71752519bd18d2be98b10f686242c9fbe3c9e99a6a7827a883c3f8a8bf5347ee1f08324d73284478f3fb67bf80ec1160554c3c78b5387f5d6e86af9568af5ca4a7502433282cfef1d4fbf9b9e7e0e6b5f342e03d74e8a4526549a50fd4200079dd762b309f982314f5be81fda87c9e3d7d5d39682b9f0c569727dad092ef45a08ae03a3a577ca39f14de673dda2eb2e93fca94b138c0e9e7ee8f922efbca851cd761f65cefe0eb3cc442e878a41dd1e7b764634c4e8f6bc07514b8953528cb7677332935f73b22391c690f0aa2e6c822d26539ecb4789e9b685bf08c9a1a15d71152911a3f58a37cdb31e0088c4b7bda3d901a42009e2192699e51af627a7a70b07dbe99539b30e684675ec914b3d70d2881c3d79ba04bc6c3d12af8eff7f03436a5f77e126d3b47dc08f93a3df60cc3152736ec64ec656200d8cf8187addedb9188942674470e34539ba5d9fd1fb28b8efe091b2ecec5550d8398e4dce366e5d9a61689f3d457a69d5a9c5065f8f736b29cba9ff6777293b38d02c7d5efd5712bbeb470954d781aa9342b48a5221177efa717eaf8398c200ef73a949ccf5243d40f23ae17ece89642f655ba02af22f49c42ac9ad5837aaf30734f81afafeee55e9a36554d40f8b80c7920b095623bfec4847717ddbcdf0b3eb0c404a45e8da808fd6996d82c7d03488d39c3f7f81422693e3345ee89b3599255457333bb4d5fb113e8d0d3ad3a60285e4969da7667efc6f6faf92874525ebd99eb4ff638035b43167b401b3aa5706ae0883739fa4a243c85bf2f1b20613bcbd2e2ba26511087057ce6c8f04fc11e1ab1008b2722421a73645a0effed98efc5f96f64cbf686766743dbcbdf43d32b675208fce009be74ecff6c7f8cbddc9cc3bab21a89fb018baa67fad31a0591418641f7e9770c3d157b6a260ce04ba918a8a39d5faa1096fae59924664a494c09032c477a8f1d8100c15a474e51236b75345cab1fe7ab6697580b5e084d9649c7fa271b10af6890b37aa3de6967677a785a94fc5791643306eb4744652243d829572efa38f370b4e576b52ed84cd4849b1ce45648aebf372f733269235d30a1ac818a3b0c67ea9a469372537753c02d12f12ba156b1d482d37502bb93d0e93c245d41431c960581dab848af98bd0b08bf44705b7cd66f5240db4eaf235ec225d19440adfb8a13d0750a789a82797cb30a00d9696fe4ec6f7f891962e3ec6661849861714b6b1db0328c395f2139622856a0bba988b32982d4b35c7f0df06ec194d1d496b3e98c82f358e0dbdae30b996d07e8fb2b64da3158a8b5f6604c2d2f25667cbdf3a11eff070392e66767e2fde09d5013d6782ec6dab8587618fb9c4cf1bdb0074df219229dc88409f6ff7f56afba8b645c675b8849ed8e750ece9d69658535b2e2b11d7c78f6921c79fc06849007678e358e9cc1f0df93ae77845fd346a48c1ab31cc55434453c75884b5dcace58b74a636475050456845730ec9731c21f51bb4b33b436b81973de6181e253b0635a17cd9a953e9804e282907edc0a22968bb4483a8ad820f4bd1e35733951b0f7296815bc2576cf18f468cbfc5ba6220f2620541ef51a0eef1c3f014bcdd5b2e6fe7f6f475f5eb588e4528c99c6ad74cc0ef2212eecb3f120962dc3b120374af3cadf5c92097505c19965e6564739766b4d3dd2861733a339c069acf8ddcc88c0e40907b34ee1ba0a6a0eb26f834650ada9ba19e30061ae019ac7d56fdbdb60ae21c2d823db96639f390af449031ef3bb11f88be9b3aaddae8932703bed4f3a1963c04aa511039ccb5c3ff660b8e34d10ed7bec3d356857073fb93b5134a1be26b8fa1c240cb6522b81d6b1ded92e3d2fbfd25200af602e42c71997d4b3880d0b874564435e61756ed77874d1453f5841a980663f0341251baf802fd5adc27ee4a42125005c1cd04ec89c82a9fbd5f9df184fabaaf833b4d7a5d5c22b8f09ab992e571628f0eb34c36dbc208a9d772ff4b41b7c5e4cf8e0d20224f0b4b7074aafba97207281c48531e85b1fbd6c9d316ebd0cfbebfb6863511cc268f6a3f9cf48839c4338d8d98f9d736d1d3126f4e22bc5fb752ca83fdc30c8a397dbb62ca408938f981c29ef298840e49e8581c2aac052c73bb6c83cca4221e546c49e6773fa14a449fe828cdd52c8591ebf5eb1653c9faad7ead1f8187315796392a9a29728f424a8c58e98a14a2b9d6ef1554c8d29ef60a6d46fca640c99421f5d857c1a048d81830d59f51a4efa0a9be87f567ef4952b5d61c205f79c6fd9a55d5e537e659be914f07083097bafa43a21acd43d89c025fc759c2e27867d847d88ee003abc3e726f4886c18747502feb50bd11c6c876a6b3991716d42215e99502abf7da1bb8000c1478c27a73c69cd84aec37ad0dcad26804eb4f2da176df6ff4bac3b812566ea976fc48c3ed01c703a8cd440046a2a8b126ec9c5ba79a19b45523577201b3751929f4c1536f5ee7885d218ed5bad687053395f374af873cfa56522233499feb3f475ba85b506811c3087bafbfdc26b085ef8df6c7ad95622928d6e0cac14e4a765fd89a9923b86079dcf27677e8220f2388c4553eb3705f75a299c59466b45424321826c65122729e64e98351d8cab6f94444ba2f57c6bece7c84da90d1f3f244061f9f555b25866e8dabcd6ce12c9767db766f2b61eeac260e4ead7a27415c77085bcfdca9f693636f80f4a859a03044ca5c8f5935c4ed9ccd368714476750ccd04f6604d04e07e32795b93533f540b4913d8bb3366715524bee2e71a5096aadb25e551b4a9bff12e77446336488b4fb293210a4d4640030f3be1ddd8df77bd75eab56a7762576a61eb3352aa6458d08cf6807908490cf54f6edab5e3426b15f94b4c73d3a443e01e5cba1627ab273ad0dfb6dee71db22dbc82e3a9d3515bfbb6425ad3d8862af0ee61df8e2df020248628423cb73e498bd4f8addd8de1b8e4bb3618b3991045ca6be615e53e0f5452c909850d7e74c564d839d9d6756f9ddd927c829092b9c7c71eb07964ff8be511c710cc989da02e97e832de3a6e5503df404ccf6a39e145d187b2a418afb2d3de67ab5a709f8398c24b717a44ac5be166731ab275c5eef8d9d90e3e2b8510f79201a224385688e7a038fbd9dcd0ea9328250d722ca58cfe0a53354c924dddf5890ec435c4e352e7ab698ece508517fd34191dbc97188d5d41dd052b26696a4a35a0b340068125e8eee67d82f66251362dc2aa589372cc9a418aa072c078fd3910c4608090cfa19d98ebc4044130d3e3f9f289f82d9d359af83d7ee2adc03520640b52ada86d3b4c3ba5a5bf6187cb461e9ece8b512094eaf9a0e993c6feed3706d2c03acac9a01fdd968d65b2eb35f6116efd94308f9e07b2f92c8b04ddefb60cb4971b998604fd25bf68cf0dac36fdf413fad30932e1a3b3685f04c76d022c32169e952baeb7fba8f55923c04ee23e14cc3ca3161bb68030b79c6cbad24939763a2c6d9eff879aa1552b50e96b67318a62bf317e11fbdd3a6bac4af8a1d308f3b28d9178eb6649e38da35aa9cd6ad9a7112c23d89b40de348664c04da095c1094158d632a83a603c6d4910367a50931d9b039fdbacc721c0ee2cc66bac076b065d53f160ff9b40ace0e009f033732a31a142bf7c56ea3a3015830fa397c37fcea6f70ed5ef84ab0e0f74b6fed89a4cc638ff1570cff9ac46784ee07920d921309f094a96c3f20c5014b983b43ca4446ccf688d9f95f05935c4bba8fc966e65e7515a5880cb81a6bb2c3d3d04bd5d441198b1260b4fc0c0b5b87f22bd1acb078406fc8b3a1673adc36281b0f612b3f7a9fed125851b4801c44c0e673d44be197d87a611f477b820979e398964436c7130ffd668a8056d32030adbce2b24ecab626e93ed72bbf6ea2ef96d7dcfec53216d1b4caa3e91576f66d785cb083045dba7f9354bd316fa8764f6bffd74421e5ecb7f07db334011b202cf1f16ad7291c2b0205a5aedc1eaec4c71f644933a1ada7b337cf58bf1dfb9b4c4704c37d594487d37bb2881aa51bb4f852f1b08175a6ec3c9db5b4e92a99714aa38f9436c74652e56aa302cacc5a85028da804e969a0669f5b2b37ccd568a87a4e2836de2edf7a24b2795a7583a997f24f56bebb678f00d905968514a68c4d51a49af4427ae75bb7f3930fb3d10cbd6e55dddadee40c9d312483f2368619cd34162991da67e4d2dab102e959b41760c4d9da9eea49ed75a09ab8b61760f138cc9b6e1a6d09ab6185493fa8a08cf3ec4a60282e8af93c05d0707c7477b94f4decc5663b31508302638d5bc5dab3b43b3e194401a0345e4d1074dd6b4681f3f42db19132377b5a743b83776da0dff07a62546315ec6303e3825b5beab7966c0d903933363247a6b035a8b5a32b384631126d44903ac4e7b81bb4d7207318ba4b2d20a99e7f27559a79f91f30ac97e70e728ebecef8b7330926f55b9e3dae5212aab9e20579655b44f42cd0d931bf7e3960993f5d37ef66b29439047f0ed7cda7502a065a7ab3e64b8037bcbfc22fe378b0d415f60fb249a7a7e7e272bde6005f6a593fa088ad64d58c25aed1a7c8e3ced4c01889885371fdea301562c2eca8d535a7d5a1a27068c617079751774844d828e1876176501862e3f93a6ba254b05c88bfd82e76c676e53a832311120cc60aebf64a9be648d726caac1dabd70e310f86d3afdae1f1b4d60cbd2cad6773c557f67c8197df68530e1766499fb5fc8846cf364127c9ced26017dbe556bf2e76fceeed1b4e22d82b832c3d8d1448e35c09c1afba1bdbe3fcdbb45c86d2aa9aed7d55da9a42e786372d8b2a45effd39e26e6fcd3a38f144976cf11987cc3053acae6ae6e875ffec758c5cb29d86dec0855fe9bf39cff136e61f54d9bc2090ce36a5ea4dc96c6791b8d01a98b41e0775a84699d70a001796d2ad2741ac0d49fbc124b973243ff55869357928f5b2ea5b87cd6e186c4634d87ec96cc537db449d842ddec626b0bd5c1df22465aead16488219ba90d8df2bb7001002293ae486e3c4d2d0449a69d8ac496161cc363df900713b3f3d5e3cf6fe51495dde3bbeefc2d2274bcf4a6267e4cb54c9f4355f8b8db44d78a5882c5ccd6edb0246db198e8621332d1439a1b38530a759f2ab5296d8aa17dcc0f5307797e77ed47a2e12958c4a3d5676d012a299ef2a5f3168b3b024de82c538ccead5eae404eba9f8b36990be9c2a222f6c541136cb1f1c18c3cfc9111872fd30f8800d1e6e34ed92fb9b502c8219f7c2c382064de6bbd45e872911b42060546a52a8896a98181d42d37a13b3aff12070309c4404011853f1ea29567867a46bb399fb819c781358c4c9071c48f3ed9d76e4cdeebc78150d5bbfe958ef5fe5d65cf9728382bb2cd6f49005e8d4180efc2c9de4b5500fe516de5f414f51f3987eddb72c3238b105a0f1fc0159347ed6e10f475b7deb56ae6f8e8450cef3dc330e08073021c75920a27d06e489ce1d54c410b80c0af63e0b4bc01c18d03fb2b6298b65f01f36b2233f4360ee173a80fe689e4d6a34954d41f594158548396393c9462835cb16207c188542afec48a8e469ce5ff91b1844bc74a7934a31b1a63a0716d8e8afb5aaabf03e24a2dae86f4e0cdb1a2b32ae4bec4238b80db8c717b131c32240330c7c3f46a9b90e9f2ba555a36902fdd04032621a2efc72420288f66ab192dbdb863bcfe3988e217ad1f219c664cf6bf1c54c9721a1b9bb4e29e0887397786a5bdfa880df8e9da90a06dca7782c0f1ecd2f21bcaff19537f89d9c8143647736c86e66928d01a0fa194ba6225eef86eb86858a3a472a9a5f0f360b37633856c84473f3e066cdfbd8f67bd83d86d6baa73ef2a5089695161fc4bd6170c8eb340ef1fd2a8ad0429f2d29a89c0d81289b40df862af4bcbed64ef03b7f410d5c44d5055f6a7caed42d04ad870eb1f63041a7e4912542c98ee1532f2f6c7167a25e2f19398828cee50340315f77f9fab2067355fbc848b7901e829dff0b910fe53428c5e26f9b6671d5adf307106d97c15efec4a2f27b51279180f0431b8eeabc732cf7fcc40a0600f6d467c33ff67564d04629ec719572ef8b95af319200b3e2a8b8526a42fb20107377476c98208b1e8d2ecf16bbe256e7e6d3e4c00c3790da789326a3dee83d8e5304913e6dc4b1d0856e5e21f139f86175c8efd3699e4fa7e32afd8e95647fb275bc10c2402e353abb9934783fe68dfa7bb971eeadca0969dbbead5f7023a320388f2a29e378dbf18b470d969bc9f00b3ec227a1a8350ebb7adea0f7f9b0dd5213bf43c2f69cc73d2767639ba6cf1beb6a0664f4892c55e8bf2f30951ecb1f4bbda0b741a0fc6aec0f97f04994925fa7d61f163ed331bd3733f7c362d4e12fb8ff4efa5e74ecb1c02b01db522c9f3a0e70d7905ea158b26a57ede47713178e3a079e076d206ea34a3ff1a8c9b7de8843d93e7d63fe23e73a2ef377f6143dfd8ddc1a413c3b6ec199356f3a571ca183af9f8d2c70a7eb29cb3ce7c8e66556d1c228cbacbabc26b2f9885d84143732f60cc84b661393ea386b097cc53f5b39b69a64d3c6abf9fba325348c883c42764eac9e7092bcb13f4b95f9bb5e426dbc75f5e616d955e52d3125acc4f79c4cd5de982d16f1a6abae75d39e7f50c50f3c88b07568ddf24fcab0fcc0aafb57e4a5bd52594b5d6301399962fb7e8eb5d30ae2aca8ead9719486a11936c14d24f3e02dc403df698dd753bd20b6127510b3471f250059072f101934219cd11bc2f8bbba1a7a719d6eaabcead7780231bed9f34673ad3f85df258353181a6dd9815f5836ee9578fa63002bc46f76722a1903cf30471cf435d0cb7120c35ece2f03b06c14551bf63ec1840f6969b848f1a6ecd6f7a410e1a80124749b582f5acab4b6341a412ee402e0aab2cc49e1500215056699c2f6dfa068dd49836f80f359d8029aeb183bf14a63d0961b0acbfb4330aa441598f07491b65840398f5ed0540b8960225861bd96ef9cea3d20313304f2245772d5c9ae01c3016b516b576f79453afd3452e6c5be7695503c55af5d2995b89ba4f14980a2247f299ecd34935d0d9c51ab69c889125f620107919d5409a2cce5109c54bcf68bc7184cf3eecdb8cde67fac67006fc63d21fc827dbc4777813556aca61ca3d6ec2585a10db4851de5bc9a0951f308d703e6b33261d66ae79219c072c5a38c12b3b9bcc5094f850ee524947f6ec177b42bdaa08b917332c3dfff1bc30eba7f814125bca0f740969b0a397e1bdd9ae3547fc160322e5984c6f7be9b35d3bcbdd8cbad4bdc99328534bfdd081fdb4f967f706068739bdfd4359119cb2266536b0603a5d682c032ea66f6bcd12b65ffc89e52e26fcc4541541298e783cf43013a7b4942ad9b5d3e6d5b2127eebab9c6e56c7eb9c7267323abdc2b2a1b9658e6813e6c4421c110e9367235ca1867b9df9b90ebbb46f36ed65819f723ce47931effc8f294a10812c4030dd004ff7d78f509c0d795fdbe6c8a040bd3492192ef1baaaebecb551580f0e0199bfa12a025d6d47f770864114274e4ebd81f8328d8a496a9d5a03b35cd71ff0138f0ec37af7f6b44df16bd360871eaca2d56b4f71a7c5028d7547b352aee5266177585ce09165aa132950b74e239cf066cd76b9340beeb79807fae1389eed8ccbd2289674d6ecbb435fa27dc263dde969ed1f41c34771f92a29b24b5ba34100a8b60fafb3b6be8ae24580b8478940154e15453320387ad3f322d9f2dd3cd5696fa858abb6e570f7ee26ce77d34d21a9ecf221f62aa5cc85678f75980b9b94a331447f3d17b88439a6e612d62564ed90fbdc854c719dcaa4968202bccfa78babb6ab3aefb1c43ac39f731b561d6b24a1902cfc826e67fa5738ee0e613475ac29c746f47bb12f0b6ec40f5cdf60ec67ac309e3d196068f4477a15dcec6ec40224d155fb4a51bd59bd233894a580f88cd3c40053de016b40729e9c4ce2a0b5e1216b3f62ac272133137944d34480fb2d75cf4fd3286ee6a84e3da151120149d74d5dbf8a539c55dfc600255a98d1dd8b104c5b7d090a103bb1af4296ce92518a05a6180cc45a20a15a1b66a63d8a03697d7b10cabf89dcfef58c31be1805e0e72755e1830402b4cecae2a5b24e2db7cd551049a77d93a4e029aa5db9023de5e67dd4f5e6f8ad25c412a2111583044a3db8a907e6cb43c8ffd6222e48463269fe7f1e6889abb3c6858da608b48372fe999ebefda288ef0c06f98f269a2f3b5e2f553ed3048e11791e777dde09d61aa5b888256554f3b4942fd93458369bdeee9af3ea18d4a1aac0bde34206b5d1d5d72bf8268edf60f7c9f2e372f5fde328c4bd22c55d32f8c7fc3bde32dd12e2fa82306d5333b3a68a5bd048cc298e28858d7f944d4e86d907f8b3ff5d7687c631332543638cf07f071f9742bfc382b7c26861933d17a6e82bdbee9a130310035a28cc52ee249b7fdcaf8ff048a1b9575258da94508d642db7cc1c18af78411da090b540282ec90e1042007b297597e0df1ae42ce9727682f07c90226ccac55f860eaebfd0378bf2b3e1f408b4fabab458072056574c276bcdbcedb79b20aa3144aa76fb9cd893ed316a4e1f4acc54dc822265956cfdbb2c29d47c7f60e1495675011ee3ee77f1fa126aece813b0ff77d7c84674d4439d7f3daab83be11b367474d489cae30422c21ae402274b815ac110342d1c1fbedee339c689ba8ae296c7f1f856aa3e5df747278968cfc88d010ae1fd8989c0523f2fdae05a394c92a9ade985777c4ddd11a0290a75a2a313f2e7813285c21a0947d433e1f554ddf6e146dc1d8e57b15bc1e35945ead749e03632e9df8e7b5b50fcb89c9380139b6ec191b373ad30c0a1f2bc187eddb78a9ca543801a125c07c853efd3979385a645b0a23fa95af8a9400825c26ec7d9c51ada39debe5479cfcd6d2d6a0891b743b6bd1968959e25edb9b4f858c9763c1df44758bd1a3c8a76a0f054e47303714fec840c1bf5720451f35c8e7403c871195afbe508bdb9c7da741540354f6c18478d41be9dd9590e8d8ef0a9571160ef270c8ec4e3c750549a65b3ab2e00539f0ec865c498ea34cd37b636474885772fcb71f1dec92df14dfe08644acfd869edee7ebb788d5a7695ddc7f63bf004e2be4b29d3177604ab3767fce7650d7485892f8eccb7ed5268cab93da9d9539c9c071b1e57b6875586cfe8f09292b89e3197227b2f61d454f4547d6d3b2feab46979c3ee1088b991da9f75447959c137bd644bdccba89fc5afe11cb6933e23a1aed6bbd0e5334db8e00b0ad19a28584ef0b860b296cf626f179c3540ae84572eb43546bd12a8f9a42bef72894c3e8aea3b4d62565535a9ace62a05ed1c130080ad7761bf2c96359382e145dcb2942f9cffac348a66aff7d0f168ad89679f0c25799f1a053d6e88a45ea396d0eb324bca4cd413c5eb7939027461a1a41c7e69876f9365b77751b3fb2629d800f4debb09f62b3c8d707ec482d5f6b30fe631ac8d8efd320fc7b7664bd54c3002557b53bbab2cd9ca82f4a2336533fe60736dfd2251dc9fb04a1917c9ea74ea16b4dcf8aedd165b10bc25f69459cf2978f981bbf5842a1dda484e0dd051a8d3a95e2efd1689b7de32b225ff3fc3fc555971b3000bd11d69332c6daf5aae76e4b6b2c8d3135039e38b1a15467ebf974bc38a70eabc00d3057352a3ca703d3313c660354c3d59f09c6ed3cffc4648149f00b815cbf26c8419a1a89565baf076aff1decc9226f5d37b37ac8731915ca2f0ed7923dad9070d5fadbbea13472c56332c9627fca962ab79489a8afc280905811ceae7b96c32a8d49ffc50ba676b031d577037a8eb6879f4dd3ba094bc22a26ed6f1e139a1b782dec5efdead7afb4778950e2e93fbfca97dde3e6b20c989cd4b694ebaf94dcc093fa6f347b264cc3d74c15d9aecf7fed324ccb1ceb817f2ab63236db44638fb942a1abc664d10c78c0fd32188ab364f54db7fec20f046117c7e86a3f37e45d6ad610b9cdf96163694c6d9fcbda9676c131ad8e5d820eea713b08b1742b48422e4898724e3ab0227540f428838adaabd79df5faa67de312fd8e24cf598d86c1910d18a80d7c3bb27a9b38bd8df09a5c4a5c43e87ba9d3120806ec2a3c3c10ab47acdd2a820a1a465ccce246a3621ba82335d7026a84f8e9b0d99e75e33f94d9ace0451d44c4da623afdc9dd7707f938afc815d2aed87e10401ab7ed54e466df0fe9855a9caa842f23c006466e31f700c9d0b4da62391ba96be59e6566939350bc4eb0d95fc31aba5e47e448c97e0a167cb7066ecdf4c44fe62c34ebc68882624cc0a6bb685751461244dc46e4f6e6539ae825d8d2616b6492552d4a26e4402c45f4fdd44a66549f5d45f91ed26ea484a47d8b178e9b1fcc5a93aae51959b08b82187afbb5e97677ed650c9abd5f53e0ab93de0dc3bf2b70a2b36f4c21c99c664857a5e3424afa35510a183b38b78c7293d9266ca50081a65bc2204f454e809ac91f88317f5cf8442b51473e2a945467c265c96ed22ef67d23b7d79ff94b456869949ff75ae8f32780cff9c219ced8930e965dc85843a469a98a87aa3c10aff3b01ce490632f9d971b7f52bb23ce92993d96e244df3d3d014e379f7be52bd96ca58ced4d7e23fb979b11bb801d26712528887a6d115b17bade53f48cb957a39399d3924c9b06f4fbde888a960647cf7c89ba77ec520a937e432309120f0398984f1dee9b68e57a584ba03eec5480fef5768fed50191a45316984c74b15dd288cc8515335f1b970c877213bb4ef7bd8894844c19091b6d854581e91d066c952421a15839858a318a0b2cb06d97d3d4ac0106e0ed25b4cb88b0715faf437f4c0da6d4e28bb825f24371b499ae4a910f45f296ec3952b236a35a69e9ab56a7f7941a0041297991a9e129b9df13620c9893159c21b74f868dfb0f1fe55878e8c8c2780f48c895c09f9db7019476e65fb9caf775c3b9c4b8c50c869f7b23c3b34f1a923b13ef6ad60d2140de24e4bdaa96b4f696deaab44b7b43e1f3be8ed9e0193956cbeb9c771246315eb47d308248f76290a7249c7fc7592b97a3b7c9327aadb1255fc4c817e0d491eb17adacde13751cc3d7aa09feb43892bc27b5353567afbec0a5e3de152e99e5276d620b6480e401130e2eec47e240949eade27ca587d6ac46cde6800e84d1bb9f26d3efd3073eb61018ec5dbbae51f17be3cf7166cf7fa4bc3bb7398c32e1d16bcb7c1491cf90eb9b9311987a27fbdc904446440406e91226f3d451df86a2b122fe604bf3c11bfda48bc4e91e497967496025419877aa553f6bd0090b8a3bf00dd489e3698c34c3615b0ae299860b58fe65d3b9b89300b8185c0ec4536d7475911feb8ae1448dfb47d4fa0f30419e95d50b521b26730dd66ee060faa2b7db5d42419f76dd35bd3899b14d4db2459fc527a17039d1c32c18ab9b4c99ea5174c03c0bc53a9617b7051ea24f6487bbc1b428f980d925be67dc3da31066f987da0089cf51d9599c871f6a9b504833717814ae06c3801cd605e11d0c6a95aad900f94a64659c3b88d7c5a06fcdbc5b246e81e9bd5b4f7d8c090e4bea7d2d752ba568c79b18650056a4ac3d68d632fe6e154074665637eb6ae0f8bafdfb96c355299d752b010a630f6f2ea80185f19d133938969ee76df7c340db8a99cd6f46141b0f463215f0a0d472f8c6a96acd9460708813c0276b52e01e5b79f1b25bc3ba0e23cfaf1bc413dc39944346767a979918b9d6d9e0e3c4e61fa2d79a017dbe2cbc0859cef786b486a8ad6f6e8a0dca688337cac64d673140c6fec2e655627bf587d4799aed7c85ce36aa573a1f9d3aaf6cd77dd478f133e077e22a6c7a05e0a05a1225414d12d0c1e8d7896271878ccbbe311c489d40387a86da1ecbb21c10cdadd7ed058fa297bcd68ced9d325c5133078209db6af7e5d30146f6d5de548a12c5d0f3b54d96151e5a80603ce2c9f508bf1558b0d9aab02738bd273afe73e984e4ccfa427f437dc1398e20f84d9ead61b311db176fa7d93e2d6d9fc045f4d45d279921123d18b983dd2a4a65f0083f76b681288a8d7ff48da7c16538f08a5941515e131143a7b528146bf725957f106b7a9390af4cae3aa0aa672a177c7d2429f43407f7ecd2b06b2b85b3b60fd6101359591a9fd2a9e03b2f58d45fb651ddf9aaaa0b08509180e70c4ac45286d34f2836e07497653506a4f142a75882d2df876d25fa2de7f3a7be1fc4765b715ec09b4dcbcd8bfc838420185cc2db38c2a12ede4a0c7910b353e14262278d1fd770f4568b935ef5f2cbdfdf38ee8c27b770cc006a9b87288f606afe3a95e70e1afa399b5e100f64d5ac0a41698445a6a9012cd24a1b24fac0e06a75990082f43f55610716d188c1901ef7713991a112a0b39a507f482ac893b223c0a76f51d4f3633708a235cbf7e7ace3867c0053d5afc2ba5b7869d7db3b4697088ae6286ba54055388e14fd590b99d1cdadc7c9d392ab222ba57d4ede13b574c38d2c6acb507db146a56add35c6e0e22bc5d027c486ef41f071d5f100d17bf34667c7e843f3c8fc4c78ca3fd56f8f03d1ef5fbbe31e90fd5af85e903a1d282a8212db7595ed9bc401f82a88dbadb5fc1b9cc136f6e91b56f57d7d163bd79303d31001d10dd1648f63c13cc32230e32b65652e1ca302a4b738a4f597f1e0c6a837d13940f33ab248607b299867f3ebf1c9c5b66df504fc2179340fc38420468d0c13124d3e8d91eec582392beb168baf8c55e69f3ce750c602581027efab8d4a3c5a00a23e56dbe802ba03da35c3822d7fffb7939256c636d94824cc1c2363a0c0747a15bc8cc2dc022de6ab1f7b3402a7b7b696f47e5c8127ad7c4119b584e45c57e5ff90baebb24d464aef73b90d915bdf752cf3f916cf0f28bd4eab4c5858b79d7098e460d809bf97773a9e7722efe33d5f9b2b0ce8067cec98b34db75fc4f4594d8610db0a7cbb190c076f3382d10c268fa479f96ac0078b468adb2776d4ddf53a4083659ccb9b068aabd6de9b08cb1d5dd09bc981d89f5d769ad334eed067f7a8606992f52650868bb0487a9413e171ebb5fc8ca8ee86a08cddf0e0c80f3fbd5e2759846f9342315096e57bfd557dd84ecb19b057e2472580ea7f9626c2ce5750323024d31e8f76448ed4c1479d1731f086e34742faf1d73938d2a3737cd0fa790db858b057cc3b472b1251af1e043d6e284dca355b8bb4e7cb38f0b2344fbbe92328b29a4a0a1624e35d29a172724573e441ecc898f9ac90a1c56294ea45e20bc974cf3e4b82efed8b600b58843efcfecdf72f4bb51eec604a6e301106f91bdbfd26db69748557f843c848db1ca90e6b4d0a2bea7dbfb0e916257dfd771438823844e76de3e882c396d93a387e83c306a627e64ea859179ebc1a2b1f11ffe3f0df2f86463bd7d22173201246fa1124abeb1318609f3f648643ef7ee69339489164798e61ac023fa31c23516d9e2f37e410139e0a214f6ea65fd865bbe9887bc5678f576ee523aacb051fd51ca4939a7a41b4f01a07357fb2c8129bb29f990c5e7aab2573d7ae017bb8dc465a62a9eb131ad28126be75e35305279bf49c93fc0697e0761caccad68db825772ab9c625a717cfb684eeb4cdeb4dfcfb24eeef29e1fce022644059b5ce0ac4e6eb75bd1e75fe861ece06e882b4c4128fc82db6c3a7a5797c8ea536becb31adf177e0cf18f6a69cdcd944b1ddaa26f283f454660faf63f69a640aaac8d654faaf6d834050c03f61ec036b9086879acaa8761c0b69e357a9de679eaa597436f5a1261887e22f35b6a0130b9d2af44465633ffda143574533b7051a639594595a6af72a9f30efbf9e33f0955cb5c8ee071c3d987ddeec26e53b906c2f27be38413d1366c8373d42ae54628ba68a943d26f9cd1619ff4e6eebb0ebba7d75e9afb9e2fa3baa6ce98c9879165470c16dbb22bd3bc81d14d899191993cade6520f15352458a1ef2fe0a9a1e3e23d4186b0f96ae51d87e82287d8c0473f691d918cdfba2c9eeed65ab9a5ea5468caccdf0bb7061c45df5deeb541ee23c1efd9778b0d7dde45c9446ad3e558b69c62e4f93446c5a89a0a6f2bfc436cb50c53b0648db034c6778e73f0687f9da9538149db3e0aabdde32004a26deaab1cc927ba5ec3b351be113d1a8f32e4c1129a33da39e2dd99212619da1f9c2b2a2368d22f655d11843aef5b6553b7eb34a6feabe235f066ab86cbefb06079cd8bd6d7a91ac1a72e1b2d1f2359b8777221f87da5cac2493ca82c48b9fac20a1b9dd4cc78b838d9439d560750900b447a6c45e552072a9d23835607d341381a58ea976af2cdcafdd2e4e249059242ec2f6c9c9fc4d11b98878ceb2b2f7de25e73617ef0c06d90dbe8fc8562ed8b4e145064dd2bedb7a3760d65e51ab774a2e5aba7ffd2a6c44dc5617e3b6542a535127024f0f039266ad8d5c525396998e5136e07710d516010bf3ebd20b3a6c5e884a2850e95537648986ea1d78673962413430967c34924fee59d1eced0c7a85902dac0db55941f001a6338c1550b0ef97f3768d6cfe7e2e334f3914b1d8e3ac18ba13a5df1eae57fb62b6dd308d3c6d28f1862f253b1b5ab58415d2e81db6a127f22b4b89aa88ed263e7a6fc7b00b286aa3f7ab73e2fe882399c44138e734b7aed5e7e05d4a58277068d4abb2a512fd3f5105d17ed85e4c74dc18c5bb4cb2b4ad1ebe2f24c3c5242388e3109aef9321630f670126117081bb86e90129772d4e0bcded0d7135281a8abbc01d3e1fea2128c3d4c1a4dbd7de5abf7f25505bdb37d91bdcd66cd47bc1e9123cf13702b3920a61f20e7073c9bbbfd68114f70da2168adf7a2acc0239f70b1f10ae056b61a798391d75d1311e99bf658c20c5dadd6d12383142efbbf98a1c1b9084bcb92eac20a39e14ce8ef7bf29f7f1c153f066c8fe386e712d1b402de4db03bd7f31475a8a3d5ba93a3408decbeaa9063f99f4c00dbd3a8084f395b3db713b92c5c774d9b560d17b63fa789fa18f5a400444526eef06cc22dc7a281ba1ed4bd18fe1e37a865c44afcfda9877233bd91e338afd8ecf39f42773f45e3671f3051c1e1d9e5f6871b6f635d2cf96ff9a363b714d30610151bf6e266daf57a8f1b8827ef2abdfdb5885d52205e5e998e13afd0d2c3900289a7ec6276cac7f11a1b471e24493a01f199d03352d7d71c859edc5777b1fbcb716837b9a9c0a263ca87509fd8a42915dfde2ca93a104ffde389c92908611be800c2669be2dc2ee171b776a3fc3faa15c1214b7d6afe9bef5954c6c1a41d813b3d18b9e316bf4ac10f602fbc2dfc0ecafa3c0206fb2edaca7ed2f872f1d88b5f00b71a226298d1b0fb8ac0cd586650040de58a021fc542b809cf9c81b8b1d0af79d8f5d6dba31d7033d76f0b6f3731e5023bb26f8937e8c7d1e855ab336a57b9dc3eacd3aa9d4d433ec336f44c3f099b01630a09d4e04a01a121e4eb9f1d7e54441e58d032587fccf2a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
