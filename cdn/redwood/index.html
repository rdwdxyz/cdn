<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4cfaa6942254f322ef1ddf5cee5198aae3eabfc421155f2e65b172b58162046ad28c0edfaedc2073a1ad3284010d36420d348336ac8f2217322ffc5654e05cc29b02e278c466775dc93dbae02281b628d996c3d545930e7de400926c0fd9c1b1c4228a11b32d03bc068426112e0f3d7a1a442f62f9d21a5c56f40483f7b56c7b1f968772b3f44b2fba8c2b15ae6d49286727b013ea003144b1e6cb869b7d701d8338b2e05da2884d265a5b995efc0f6412cb25af3398cfe1f4e9687f65a96e0bc556cf1a40fc0ce857b12116660ddeaf8d3c46ac802eb950992314add4d0873bf2db3a953c38d43f9d35cb9a6d9dd7b10cc53cea85a82fdd35d3a3e44c0277d7ef3a78988bd9d08496023f6b05f8ba72a4d8b5efe17d06005366b688a4fb82aeef1160988deed2678a1390af09242c9ed782505aad14b96e644c9e6de03a0d192c3618a2e80de8a8dc90af23ea74601a71723b202d5b4c2934985b19a9e41c5d2c224145e7768252fe566e875d9e00a889448ef5375d80445f508d5fe1745d447fce42965a340c4cf23e462dd026fc5df93f66e15ebb12a37d35aa89a427672e51da41b1b46d5cec134fd238aa4e558895bbcc526750d1ad8e5a39c8f2602a3adf6ea17ad53e4b7d9186caa4658f06c04b3f75f602340cfb120179266749603357c8ea3e78e9f60f97bf64e17afd2c013dbf336b0fd9676e85f5547d8a9e9a03410db474b3f07e569feabc326dc8b825e3d68ff04ddc18889d04625ad18307ded2e92ff43923353f624c84c94972156df962748cba0c9750a790e06de6eaa98bfe49f9e00fd514e09910d4234028f583bcd3ead167fcd207930e478dff03f870e023dfd070cc63a96a3458ea1a68717957afa108b2a8b4882228220f2826602497c05d318ab64e1b663c0a22b619c454c590d77c1c0698d7d54705057f0aa03bc531833495164df0938077e7ca47e54506317f9633cd19ebaf3d824b6a55689fbf2d3a2905dbe43a10181763be232ebf55ed46bc66bc39f5a3a77d23b3d4eb5a1f88833f9cdb4cae7c083a6b8ee490f03874ad2ffbd4762ae2ed883b700fabd07c081aacd7e3e92dce537448d210c9e6bd095b47cfaad415ea99943bf8480f21ce97f49da3c721faa84d5fd15285bcd2f184df83a12fc541897a164422f237f943df77b34e7c099b7a4e0fbf2c70ea98e08a0a93b83a13f44511d3ea8a25cb60e0b3ed480562f7712a5ffdd059d0f9fa1b8b1fcffcc75f63541b5d0388a1dd958d3544e24b205989a474cd5c5d2c8c6b16ec94a97d7fbaa1ee93d63d82ed9f069417a65b345ddce7ca47827bc193b371e4733af6d7632646359e858d7df5aea6a7692442201d7a03b8c02da49e4cc750792ac0f2036287bf23d5b4f63b805c95cf3d4ce210c75c065b6fe5625743be418b4fe2b81de2b629df9dd6a0df7b8605c249f9cd6e30166082a0d203a98a4130dd354e7270bca9814b44988ae9479d354083532c15081d67ecd158c121bb0ae1a401f929775c87f8f9abed528f8e479620c61e294124c78a59427e3a778141dc2fce200f3c5507c107f306cb6263656b653d372b6f62fd6411c4096531c590d1cb7998c23ab5cbe1e6961d2ecdae3d4311ec622a50d5ca4c4c557c0bde989eb61ed8a677ea2abaf3653b1987f7aa5e17348c3892b68d6b97f82ad01fc809f53d1e3136c3ea59f8d372240e0feb9cc7b5ccf53330ecff43c6ce1b395a3c5e150cbd55ffa4267597aa3d290a05d3ef0849441b39381113674c361fa3ef8db9fbc4a213cf9fa290e0f74695f1a3b751d6dfb5d146e57a35ac906784a7d12e6d61585b66424d322180fd6066f7fba67b3956f41f6cdd0d59f1c7ffcf53509bf6f8925934831d1c6b7406665bba50f2351b44a0043c4dd9ac57b95a7fc7e36c94bcb724c22365e22e3726ee7340e94cba7ee4fb6ed372663aa2394b2255b53397ec38e65785f9094be784027e0745dc1b74fc18d63b6cce0b51e2d40ad6ef3b45b691b7aa9983fe06dc9adfc8ed3fb5c9efd8d100112017dfc02b5a514e70f67244c0c83de1dbcba645aa413cb6098c2e3c39d41ccc5e801df927aae20482bac07eb5dc5e9e299d9e8711e52245ab4fcc09eb3b30d29eeec79d039917b0c9305056907299e1154924f8837fdb344561cb9fb5428b4507450daa3fcbe0c911f76e847bbb64e9f7fa7d40fd4151af6e956c41a0c9bc9e99990ed8ca1c84bca1b65308f509d770a79ae56f4dccf95ae7967a4822015a8b7ceea98dde6a97c98322704b4f56cb906b660188c185c1fd040ed5851be95985db34553ca606265bdff4e063bfe5a9b4af01f7bf745806ee6c3d25b5792cb81bea19a09355877cba68ef3703babd110b6f10afd648b8152c42724173c1684a31b72edf3c2566c1d5e7301b538acb6a87b1a35d103e3d62eaaecce4c79f35f0ff32ec6ba3708536b57573cdc2c1563ad1d86abcaed20aad33be1ecf4895e586e20175971771ef6a5de2cb59fd0f350d712243beba4838f1ce4e55115ae387ceaab177e61ed118c1ff5ad99c4abe4724d86b6fe5a14b07756d30e6c39fae62e1e480c7471ab673a2c105924ad52d9b5a2182d07f8f8b4873cd81db7b4ded43e155d027b1c8191a0f3417866e19bcb97b8f53e91e165430986a58c7992b924998f6b3c36a2f50e86eafa60b33adab62eff45e57a40790898a989855c3194811d8bfb6432d687d300eae1cb9fdb5b4ec33e733539a3e6764f2278012ec4e9be7b67bfdda81109db363125213bb54400a65ad1a6d0369a15d18c8d8c55c6c22c9ad27ac10ed99f8a57f33cf7d8aee879da842db5187d41652b35755a674746d2f5c1ce7c36806fd744314a265f67761effd277d1f7aa27a89d98111938a2275f6314a4b54c9c8a188099ebf90ba05561231626691d8c2ecbf353e339d63f2d53fa9cf8f8c70d041d8c72209a78f3d99cebae9a11822404a53c2bb878a179e410a3aadfde05e4b6c1523b0ad12fb182374a489b73372add83dba6ba0c4664e6637ae8ee8a25cfcb34e1a98b1bb0c415d403f3fc9b2486f0f67491cdf947446deb636d911eaec9424a6f0a7437bf047e5168b5f0305619e79df6e06ff61e32a86502b8fdf586e908db733e83b0f76e00cf68ee9e950d3bda34ccfc46dcb477792dccf68abdd14973f3dfc29b2aa5b3dd97a35752d04836c47ba86237116eaabb954561acfde6f8025dc9955b1c7f40a168cea4a48ddf42aab20227a7c75f95c052e7ab0af4cf7446d85507906bc0550aca28639192de25e2ef5ceb61990a37c9d3b127b567f76e96704013752cc7a686f3bbd1709527d8e6c3a9641bd50d12694294682139b03e07e234f98fa0f9f3f86caa0e224d9223b2ea08a358ab8981ec710742d538216fd6ae1862dbe233afdd46c71e73b0feea9138d6e57d9271c537f869fc5e34912e99000edb6a59b4298455407a59c9305fe35ac3718456873cc9526d3cc5f212319254b9a3d21f99d2362b48426ab0d9b30b8e57d7ec07afb0a8fb997f306a00e8c92d028ea291efe35f13f1cad39a5fc14a94adf8d163cb1c94d20cf1c279892f172c8b5615f0d58902034897b5c366856b06de924e3b470591227c8675bd8b1f8b322cbdd9f156c614c4edda117724d0fd7875457b27a66023fd2cb0fc1dcde997cdc93dccc846f342d4f1b7369fc212fe9d78d307ba532b5087a24775b7c3f6182312cd57aacca6e85b42e66a750a0d446e938a0e9142fcdde344cfd925ec294f84e331ad97e109ec772234ec74a03198055d2f499864698332665f7c0864d3004c30a0683eed8217fdc509aad6d75785dda887060f4cad42e3749ef0d36cc843c9d1bf69450216c2decde14a76132a0f45178207929d3104f1401a5f020d62ba750287fbba2dc011c0dde67342c1ce25270092d06ad304ee2a6397c9a56eff4c62eb58ffe58aa14dc0fc8f9786246a5041d2ebb615ff70695e183d94ea4ad8a76262bfbc5d068e821d5b382fa9c2a7c91fdd8c18c04280b2d34053f34f019d68527b2b4c6766d062df059e7ff7808a6397103551e433b126e887bd6feaf558feb0b8f09785b9145b162885b0b3bb49729c1a3b5f9bd218165783cf43fa9e0975f6e86b656b7a3504fbcd8a01f67872f9f2fb8f2011f6b9c29bdd136a77f1801b56f841025d192a7dfa46f61d51979dc3b7158953d7f1aa2d49aa78f6235fb66f31a188d2b1abd1822c076fbc015f588d8d11786f074379023f9ce4cb202fc79a7ecf4425d322dd996854b359e4b2c504fe7e2c2b9fac6f7b221ac6525b771704f28ebe0e04ac7b98a11c34820b38dbc5245a63a94c401bbc6bc8dd43343d49e8b1c6378e0625590d91466120216abacb6befc4907d3439ff8350f3684d158e604352d2cceee0d34dbb810b1a778c53c68c82fba4bda641ed50b1189961094c2a70b183663db5f951e512a6d59e233ebc4bbf1f8e5d26ee4b54f199adc7a4c99b5621c33100c4421e71b5bb20dc8c54add0a8c806f0f4342394e90da09cfc64b85157ec7f3d9fd76a846dbb3ccf656ad760b7d83d1b05e913f51a95fc6c16dd9d6bffb57083deaea5c028a6ac95dcc52fd436bae31180128d144dcf83f31209e61b03ced9e04e7b1c2dea1d8a166ecdd904c025192c59b8d68dac5a8e5dff15d7b02fa69fcf608a1d0e98d331fd07008de78d5c5ab1c1db41faa87330afac769467dff07698be1e8336f879719186a0257bfe1da2bca9a84e6f7a4feabf60ccd66b6f1ed72142c4368497cb26ab31c26b2e2ba8ca310bd531525f725a703fd2a0048e2a4547be167a54cddd7ca854bd66a0ddac054efe8ec59315fb8f3dd202d5c89eba4c3ac7a9e8a8064d4b5a0142280ed7de4d6bbd24bc8ec86593aea90711f502ba13677ca61d7f1dad9bde0573214a697c22280c336f68cdad3ae4c3d2e30e5c5e09c3431999c77b55278b28139acd4d2b1692e942a6b00061d27487e8a58204edd767fb8f9d8afc0042d1dda2e4615dd16826b35cfdcbddfd9a07bc0d7cfbce816586e596744e96cf2f449d696d744c4fcdddfc775e81847346b1b465a809a199b17e56f78e0c03a8caedbdf7ca9ebe67bd9941ce5beca23132faa25871002121d95ac45ed29edcbdcb385e4ab297a91b0335bafc6899435d0c1c744488078657df0e61374cba94791cac67b817744609b189d5d8e8503505aa8a8e8c408cfde859839444b8d2d4c89ae6d8293cd2256dd91939e3eeed1879df79b826d8ec8515f3df45c8a0b7d56f2588dc2082e295656117963688b4cdd07485df6721e6fee882fd73efb13db0118bc938009642b5efccfe99f7a2edb70b8094f8d4280f3fb2fde1bdac8bd096fe2af745efaf5d7ce8ccff6a81ac82c96c499c8d545093c9c292a71c309f957b10b3d739728e4848fc9e00d35ec86d3fb9884adc7e7e6b63c68d47c8137b72d782f8469dc25efb3ff416cab542955d2086c332008a1e352a7a90d5810c2c0d637a5d9586e5ac1444eff1007d933583abbaf60fcab87e0286efe804ab1146071acabb88abe148eff8613eb20da5ffd7e1b616eea43fdebf1f6d6811dcd85ceb9348a3d8cda1922052459a62a4ad0f6fefbad91af074f59a20dd302d63029f72aeb94c7c086eb154ccd30f8193d7279b9bedd3bd891a7e361130ba60139e1395d23a4f5ec765effe2998b5d5c358be3b3c9cc7cf8423df0ea572ec77348f653f6e7c49dd1226f3f980cd723b88b96d621e8f6b3e1c36c5ad1dafcb54edbe8b323a96be30be3127190c09caee31fdad85dd59ae00909c2019c565a9c0deb0fd970fca8be47177b126699086dc6aa29a0325dae5b710c077ff8301f667ed81f94ecb9599647a447934ef1146472a123df84c10d11873085a2883db2409bedfa5e7de4343e31f62eec4721d43b3d5592b820ac18d2b041fe1e93451e3c442517b9052671e57abb60ef778b45157f99fb124d7d8de7538aace99f95d32fc308a9d226b5925e360fadfa655f9e573616844a4084eafb6e9d4801cf9ccd08e65669a79183e2aa4c9b715b62862813d09e0144229a69b6e6e0658332b3740812451068d7af7db19ed49625f901d0a3169463b4adf691fe75bc95588bbc0422641565904d5934ddec165c67b268f0e7d5779832ae1dabaa5751535c7e0bb3816233c6b1933db7ebe3d872470b61b7def6fcc5b0e36b08a255bf22dbd49b1acf59ffcd5fc8ce930943259b633d5be5723654c08df8f45b329257f4cb37d76f1da7f7d7a6fee3599caf4c337276874a66072c9be353a55990e4f653a849d07baa706a83ab14f88fdc054fbd419db8680bd32f6aef45a1296ec6187210fd89fbdd9141610e074a0813e4133f8b35efc09ba45c6cc62282cbf8aae4d12056e8827bf49a05ea019a3f4be0875415b374d8a6cc120652586f63461e52c9a2f44bd6d87d5993c2b55a97d994cef46bcbfed3d305d46a01991a66bc168c66a838426c1f91f6b7f9cc5a7daed3f5d86b45ed75ff97469fb99b949deeb0a11418fc26dc89a8fe31db15799b8913989c9e6a3f4731f0f815c7d99ea356f8733a303537fc15ad5274a18ee29206d54bd511222c92c983e1c6a7a145c3f5c63244a277a88d4750cda0dd5e3c3f28eda5d55952b5b2bb0bc8df8f4fc27d822d04e803a30debe6a5d4b083f05d6ab2bb1e6900c5d7c1286517111b4b61f8dca14c67a9c5ccc88cd78bbc581921c647bb572010052ce6e68b3d11b71f572dff0fde6645768d1f3116205ddb20cf12e93d13a0bdbad7eebb9194c2043daa82c81bf0555b037c62ff84e4a12066326a1d8991889719aac69d0dc2d68aa44cd738ac70ec8d3f126b31c00c271aed60d7396264f6877864ec4f294264afb232ea91dba920d4e653c5ccb46d2b08352d5516d6ecbb4dab6d6a5decc2e9b21adae99d6984218ef288bdaa9d8310d3b6c4a37175cc7a817936d9f66b952499408012a8e7c16272103f24101b999fa461b9f69dadd84b8d63c6d79f38d09f878d00675c53c5689686916be7b4ba2d6b20abc97e42c958c41f53bab476c39b212aec2b8404f0fef59300912cc966ea938acf33a09643a6f59dbe67246cb1d2569c1f31c2a3a35a0e0e5a3415b2ba01dce8e57890569f172ca6d0da3207ec11ba60566f6196a71cbe6edbccce4200f1cad13f842ec985eacf25bf9cae5293c053bfc7d66907e8ba7a131cf0f6168bc9a2c32c64b625102bfc2e2e2565b8c8bd7594b50a198cd1d318c819a597bd3654c45ec9c10103b6774322ddfdb6297e0b6f44caff3d1f3a1ff92ac76f6a9fd95d3a69071463550025384eafbe23e9e5e8a0993f6491f6f41737e5908f79e53807b8ac4c84e1d6d24582ab95631b979d48ba7ee97f581f6a80681ad52e1173c7d4c65aebba40b4e01623184c6bc751f968468ac18d6d641297a6436be6471d3f6bd57dde1723b49e22788696c1ee9bc807af6a9c44f3831905e8556f9a803d97d7cb81b3f67c8640c82090e49aa1de4f7109bcb8b626b691f3d5b74a0ad883ac4787c18213d64466d50264f730874dec90d3ed08c46906470380826b188a6b200ba19479d93f9f830891c0104a4a39391ea2cfadd1ee18a93a9747f4a59764d89e392893d7bf89cec6f4c4b2ba76270e6e8665164a73d88a4d03fc9bee3a6ae90d3a9fb1a82fa17fa25b73efa311b2329fd22a8aeeb4453829dad60b6af8bae6f3f228aed4f9e4a43999131e5c9a480d54e5ff83dabee2f4fdd053cd6cfa96ba4f400fb1a4ac02b8f9ca0e15a11ad143d6bd93af2a5182049a9385fa626f738dd78b90b51ea09f1bf70d089b250ded5b0185edb11ca2a840c9adb85ade8c997fd6cfe837668499e90fbc8e7b3e3b8c90b0e49025cd28ae577ebf9cb619f54c246c64d86f94028563f91bfff7cf176822e5fb8c23112579cd4bd644828e2374727c4a0bb1aebd57651d5b59847fb4cf91767927c1a70065e5804f04c8511c9f0312dc72c5a41660924ea6c87ac5dd61fbe9f0ee5f90d469950593634f987efd02e948eeff05053b80f740dc51879a40c34e30e6eb85243f0081cbbbed1bf888e1360029ae533270163947aac0c3dcf870f8eacde6bf061ccf42518335d70b471ce81aa99daf62514c0704cdc38f20fb207219df89ab1b4b03ba4ffb6456591675529975cc0597683a73ae34d74dcb0bd29d1497f4996df300332cbfc6300c8247e0b7faa129b542d589f406c7128f1192d7131edc3951818fb0595cc94578e7cfd8006fbfbb23e15c88659475d75b8b9ebd9e4947b2403bc762a142fdc2d4fca84a02f5301c719d501b444a01805dae2e7de3a8ee13eb5cda6ecb0f42735aceb4d8bfd48fde5ba932c0b907e06962a96c4b1025c9a5fd28ff6697ad41a3170a92d556554879b73d3e5f3618e5f28c6282413e405635fd50983904d2c530be306ac8f49b2ae9d7cd96fc78deb84ade0988f5476e7b41053e7c4758ed7d4140d98172a6768ff727445edce614009635697c399d71cda005bd975145a951de7446ee5659c9a38c8c0c1d9e82b2f616cbc2f66f40a0d1a43df8d815b173e6934b345ad0aaea27898af7d230033e69b0dbdef2a7237a37ca07d71a65a96daa936e92fde1810c89a15fed3c14b8b83f2516338851e0456d55c143230844f56642f8159e5000f5656337a14c9058008a65f5f921f04a15683c45336d336cf8b6b5e7b2e1a6d4d20f47341a58322be3642986fc9e713cf39e8162cffbcb532ab2512285f809c14e1dd5be615eabb7a95d4a58844b1ed10f50e09d87b0875171efb7d67261bb1c75290d41c0102313db6b9005283de68f290cbe447dc407650355704f10fc9784d47521b1195e7b03588beb0bc928f46f5f867eba7e218b0b9a2aad93fc9097b704b37aacbdd422ac645b6f8ea35874efb80f6b593abce0925e9a0891ca84930bf6cf52eda4fd4cd049c9e5645a69f7bb20b753871c9e37b76c1629238805d5a32cb461f276b25b911d630fb52e5a674aea91d5959cc45e82b3bc7daa3a1e2a49f3bcff9d6467acf8105b2cc6fbeef93e255a54f6e65b71de999cdf9e96c1edce6009cbacdae3d4435554cabc6137d7a76d18c79326d0cde59b15413cd66b090e7f7ae2e3312809e673da7d3444481ce41949607804bb8ee59a11c866884820f659cccf44882c56a15b60ce2559a80527048485ab202a892d0ca74413c43621e906b82e88f42fa1eb76a814c72efcd06b79041bd7e64358efdbd91a7cce22640815602d45283b0749bc5f1c6be047d924a38028049cb6f573766301959cbde351dc2f878f45b44eb5fd2f84f1fad0e48cc9440e15c581ddb60232353d1c7240f2940be1cb205d5d926950bcdaa7ebb5caa532eae836b9d9d28071b9019a560d15265fad8ffd3768c901026d8227867c0b0512dfaaf46075ab827d39f74a55741b3f1591471e75415aee79a27c9a082e0507353f59bda131de9b3bb1636db0630774bbd7bfa1dcf286d79eb21fe3c997a8ad961bfe43530e8e6aae96cd26c52db627ada7773c740daf3c605e1aa22f6910d6c1318edef67643e7944ed4042cc1bdf78cb54f192f14a3d2aa9a3c6e68f138ed4112d4600761b320d3b0d8dee0db8cdaff8f3a9876040e1acde226dc8190e74b7d9306f2fbd0ff6420cbb4394f8f7bee7de9faa8ebb725981307ae2b6beef83b49df29b7fa505cdb7be5528027dee02e426b40f0d26716df9615587b343383b0b2bfafd4506e313f6597c131304ebe0e72b8f21c067c439eac5d69f4e0e3ea980b38c90fd06bce345a8aeb12df7c31e9d4fa285326c3d14598629134a9076e49e0b24ec8fa087fc893b2f2024be1e3e15f3cdb52ac1d11e0cdf0d358f5934ab82c19aeb5f36db8e9eb07c1baeecad2e17775973fed19048fdd0a2e1d56adb0777762aafbfb24226037d52c8407d5399c0e3dde0409c791aabc45500ca48e8e317d7de9b246d342e1e048af46a47f90f8af8bb811c4fc5fffb1806f927f8c80b1e7b6ba721c2a8ce43a74c10260b0161acc1ddc0f5697e7e16c6307f6313690fd6886f2cf1378557a8f5958047c75dd87c2940173a3dd1107e57217e8f70523297d3d6137d6ae8ecfd597fd2041abc6e2230f9f638da19d6ac2ec0666a526be0ace92624bbe02aa642bbd817e11551ff84d1087de6f75f95a32847df8ac91bd0230df9f6260f1b399e589f1b604999d9a13dcd91ded538ef770aa4c8fc3d4d6cc8a140a9186882ae6b33d0b0849c74bb49f26d2e6b7caff92d9c36599a364bb790d070f5ce024bccfc9b1a699e5655a8823ae45d1a134e99f7f672a8979c0149a6a6fc820df05e9ec66a3f82506edfae34436f052abe8067c8688424c58f501961d2d39ef9362f03b5f57c39dec55a8d12ac5e4925b021b1e9360fd3c793c9004315ed886ebb33379d9e199e1e9afb2e1019cae58d6137977e065112bca76966221fd2b4fcba327105703aa68a1e644f16baaf9ff242cdf3f12f79dce07633fd9f9b9743c71b7677c5867d399bd4b648674a760820b4be861b3778da17be0a723823e470ddfab06298271e06b1b5033d7887edb07671ec53435f56c61d4569fc2febd71c5e61e50947187ca557ba312f5eebba1bb9067e6745b4bf7b6c10e4fedadfe676dc242d044d8e77881d9ab22fdf76802c9f11d69792ddc8daa2b4bd5a1f91f1fbe0674379365934a2f533183bbaebf4e8e58e606c39e53e9a1dd9dd81b1fb565711f47b1cbeab5ad5341ced1898a419e8fa923b295bdbe75812ec6628aa9ac642baca905f77b6df23e966daaf30e240ec1eed52cc0d283f4e9fe5c912b2bd2908e5ea4805835a8815655d3934eba58b50b40397e6d5ca2b20f7c81cb403a3302d472799cd011d160919d006efa5e96333239db6e13794395e1c67eef0b2e38fc558889805077d1aa914ec61f20ea23512044638624b6d7154d98aef2101dd563f5feb1c9f93783fa20d63ab02119820bf867bdfedc4ada6477ee2a6c0ba896069ab09cde77405ae794cf6f266ce1637010061dfbef1a5c732a9300bbd9e7cdfbdaff4f5a5ed0418b45397c417bd2ce78eec18749a3fd92238c4fe96012f6537caeb67fe5c305d1b2f5dda997d9c3b26821609ded3481191aeb539a98b3e63a87c8701330f5e707f8180713c4a263ce8de3daa3d35329fac410037fe542661042bffc79d519e03826c5490e8570fbdfd2b42c29164669a9fb792ef46b5e3271928b7f623de0fdd500a3250e7f914f6d43685367e82cf7db0ed8d88ccf99aa57867439e37db33908444aa0379b165d52d756f8446010bbcbdcaaae91a599162cb249c8ec104765ddcb3f0ba043a8be8de1710c002e6d8579395c33460185090fda8c902e019bac02b61cc7238753de009f399e3e01ddf70b005552df180a32083074bd25dd7670016238532aafa302a03bf9155e320ad246b5ea87b72db5d985b7cdccb6a110fa33c0eb64e36e0b4193d837f1b5bcd9456dea7383e84a00f90a21dbf57523fda9b1caff3aceb9ba0c36e2b0c93151ecc35069e987978c615f357f2b874a821eaa4841864e98dc725d408f05de1353d3129ffde02332cceb00029ba8d7b73a9442e2bf259e5c9f5b69f1ca36141fc5a60b1abf536e7cea151ca672cccce064a256a64929739afb545999b094e3915c0347ac7ac4b68d21786600c0242861d90b4e8ba9f3334f0db9348b0b050058da320c869104216f1df5f1a881b9472af69e790810fce3bf92121579cae37bb847340453d3d39b5e072009d507ec783ee7c28565e9910eb614afff933bcbb1430d82d396b3851c427d3df35b69b026ddd6d6834cf261ce232cb949d0b22a055c08244a4b37d56bbbf71b866a70eb63941db9b331d3581d9da16076d351b4adc5d1136168adbb530c57e186fee38770d0a68e540a946cdb9392c004d1e575a35d2c3c840526fcdbe724d5ed85f8c028893aeb9135ab85f786aa79cfe8dbae11464aeceaca9a5f2b886bcdcc812005eda06d71a090283489e89b6c5a9a8690b5a15da2cf7b0fdb346916c533049e949594161e745b51cac3b77a9da5480b1dd7b92a5f608653cd2ec94540d5b73b91708cafe137d098d48368f3237fc2479fbe5480338743f9fa03afaaa4216ba8e2e2af138d652929b49a03283dcafe7425e786e2c1aa8617d319bdd580fd8a20822a14e2a38aedf00e542d7dbdb64370c8c841f29f2c34145c0127e23a25150149a87cc5a54e3faf3d2f92679ce2b83e14ab8007fc7178cc293bd8cea347b01086a084f9c4c1a1ccb3374ae950bf288eef1c59e288aa4526da0062531cddd166a7b53e376a80ea012ce5420fc321d4ecc024ad498108d6902e0aa5363fd8c7eceea73024c71bcd6a9133e86afdd277bc515edfddbb70222999b5021805cbbd2e60aeaa2be938a59e90c248a4c6b7b5517f97712c774ba8aa232f2c85ad5cb41cd02a7009fc1e6f2a0d90384ba38284755341b0cead21662a0948380f2c881ea2ec64f1ff3548279cb3c8981100a7b32af02e2743fddacd5a9d876f2b86f2ac11f6852a967243f967b3a8591cee394ca3396d545bdf96f8fbf7ac70ba208f02a73728a965836c5958ec278843956452e55c6fbe7f51248a6dbaef56edf42521046924439f92307f0d77273fc9a7dc7d1aa99c15467c886ede87a6dc7f1485284071f2d1151e2abeb18441b83a6a5175cac1a98b6d7770a275517b62a108cf96bb02ff55d14cf8c1ff7754b733dd95ebab75cd7e0c4712e5a450e6a45ecc29f0251d4b927a925d8a0ef1ac3a241d48ee8aaee1a86c8ffbd7441f9f8164f78a34b17172c063117367dd8f278f61670a9ddf1d468bdde7724a8f6b4a38d377ccb83f2a3477e3a9f83f90f38c9fff8ba360003e33f731e41dbd15ac09678863459b79c146bdcec639acc3a910c760cd0ca9e2c5e3fbaa89a466b3c0d628327159b1c5907ae151028144c3fdac1366f567ba6cd7140bd1a85ac5392dc21a4768c9cbf3fe0fac82cc27f5d9838d3b2bb9582369e094635175f7d571020d103b542d4b0ebd2499bc56688af90a4e99489f5a07eb2a68f6ee1cea752311eb90abdc11398d5ab9676dc3c69c9fda583aa65fe76dedf02b4f79614eb21aca6365ce97089d7e0ea6a9d9c613c960990de531b9cf5f1964f32ce051cf58a680060313f96a5b4cddbd490a9fe5c2a339048076dfe6f1acb31f1a92a3f6cfb3f5fb0b902e1aa1a5cc5e3e01ec303b44cc5ffd2c11432fbae115c62f774a3f71a5576538bc9eb935078880b243d7782ad84c30c4abab98b38e7bb64d85067d683588d633430400d676c1aa46e566b81c09fa8f975d8f4d4e7daf7cc47aa87c0d2b79af10e0fd7a689c76fa09e351693aac937f932fedd5d9ebaa9e8453b506478c94e7c089be1dbc50e4e08c5b8073b63cf32b3591c6439c771075129a294d2c90afba6059fba20dc8738a25751bd5655a5392cb51202843b8c37932673c9cd5d7078ba7648ccde33712c7325557d1b70d68f0e53694444fb584ef42f7c153cec3942989d714467c275426fa9ac021c022db2597fe13464ad6f9a18b4c6c990e5bfa7f5adfc541604ca35c0a19d1974e36f158247de641c62b395596a60b3a2ecab8b3d1d65d0dc86a24c895de945b49f77563b0a46d5e69bbdba4f7e1098fb6a43c5a2b64831b2eed0afc81cf6629b774a5a255bdf8c7905aea4d54c51e9354bf2387f431bcf507bc75fe53a21b54cdc9f8f510e09c91154edf5fb287a367381d995c0c3b1c5cff5a3d15351611eef614d0a6c12c34298bd4011bd4cb76577181891d05286b81349afac5670d1956262f98dcea08483ffbe2dd2bd29153f9872f22ed70803cb88c3869f9c788a3682cb9ac4a406136b8431ff125a885e72909f251f52fec98ec3ed57749c3858773430cbf70e3e06721b6e4f117f1c78477a38cfeea9f9588ac3cac213958b0721c65022793495a5cbc36125a68657de121719df505e7c28ca59da39775148305aaaee56e8120287c73f7c81c20cc8e9ff45b48f4065da211af037a2e58390b8528ab605273be83dd17b8da5452fcfd31aa39f9b615cdb548b2ca62f2e5f3885c7b35b5290bc2c5ee6c834f19c4d21eaeace573f12cd564519c5b8d3c12e8d1df8bdf9cd0b4ac14cbd75fcf3649380ce3fde4fb53bb627cef1ace24bb32c771e3a4ac0b7cde83ba8b53d3ab49901e3eaa10205cba5a6114d096c5476d4062c8b0901235d8e4a1fcfb4c1cc109158c887f2ba6b21b33c19e4315cf574f973e825bd0f12bf97d1bd0f5396a08d0fd3f2962e62aaa5cfadee2b8544976e658bcc75e0df3d570df601243f6f1332795628e7ce7710a85552e2da4d3a600fd9e9bb01e3cfadaf5061326c330c09252c93ef6b2c0b32f4a8a0a9dfad859a19872be297cfa414d1d5075953abd566e3ee46cfcff98e456b08438b047f94599ceea49d94e01449ddca6a3a942709f29751a7174e0943497c8fbecd3389059f233ffd3354a1d75cd8f4428821078c0f1e3b1f0d941e1b9c63349e4368f3dc4d60117e7b4c5c9060ca6ac84d728d52bb1d11ec23ae193a143b42162f159192af4e24a5ccad9eeb0a0103f6a58f361e4c06b50be3001d4bddb67d2b5c103a72a9ca968238a3dade2babb888dc3b84550df0c5e82775f483064bc21b6e65a0370813c4f9c10b22ecf241d44c5509736273e4a587ac3e8695f95fb4d88a03e1e70fa8d3807732242e3f0d54baa28fed16f46c23a1cc55873aa2bde93aa5dead4c25a2a68a8f3e051bf0180d79d0688e9b957e0d85b2fe68fa1e007543c858951cc3aea3efad013e9f834c876653c750c1f251715e902bc067a14af6c9a49bf49c2d222fce5c9cc38398375e5528db485a18371087ecc137aceb345077fe1a3a49c4e06ff5a1f16ba00d4797e182a191c5781a3cd5254135c3f75ef77f305879755bcba2c12249ec4aaae458055d4f8e12133ac55780d96464b568b002d049cbfc3ab4a90cbc32d3c56ca278f03827a6864d76553a1572378b0223555321dec84fa74063b88c1bb5d1e596a53f81522c785f208ec65410a8ee357f418da45093d6989a39aee02fd23938553918cd48b3437638177448b0de1f05533e4982365a2be9f57dffe35bdfae50b41aa0fad01101c32c6d3dcba81863f1999202952f47eadf91f409413e385a633224f67f1967671966de412893779f07dedb527b72a7c56c421fa6743a0280d260b9875cef80be95427da592a9eb1dbca54f044875cf1981dfaa2a4c921a503f4f41b7df8f9d99176c188023c49b494154366617c968cda12c377dd3e20d7533241d36cc12ac35f1c899113cd680d69ee7c66155c010cda677ea1629e9cf09f7b17939b1892525240a8ac0370a6ecedddb399c49748585451cecde274a835161f9b5bf470d139b9a80eedd3867a544bf18bd5e4359de098cf218502b4030f7ef00c91ae405af8f1fc615da1c3c779fdbc10e4967f05489a828f053f5a9971bfe300f027893bcfdfca1578bf1514b13553be8d4207d0832c298fde69cb148aa8861ad7d945e793a430be113dd34d4295449c5618312c911aa4373f7d7be95d25d5185d16dd0f65646ba735e1ae47d78d9762fc689f554fdd56f75691718842eae1053f9c57c648d76809256297812333b023e0c366f3f9b49158138745083a9bcef47b61e8476c68b92bd51f027c6c8a7cea44d1d0a92199f707bd503b8c20c8daaf244440bbc3f4d7dc806d25474dfc96683f247ffc4c508d19c2236082eb4d758496c6560f19a8dbd9a31bec883f42ccded579bc7257989411406d17bd70f583ccc861c5340e23708f7b5c8b6bedd7302c0223ffcb0087052cdfbb6c52aa9164281b2cb698934d6343d86a19a333a91a5b73ec7bdee9fad09b0461d300625b1572c9559c6942235e07a7e4b4aa28a4b4fa9a42506dd3ea8227d61452f132289241f8c95d237db15c57d2e6f18f9eb9dee9fbba5485994f3c8c583bed473dc69432c16f8ffc6c95ee1a2d1b24c41a8fe3d038ba9d897d20adea33504ed31d33f63bb35450c377574858d2ff6b3c30e5ef709c7819b9c6b1d24d851829461445b1016e9a349edb1ccad3c44d8d387264ae25c53a88836398dd4a8161de168778e0b405a75ab202d1cf3120ec99b17d5efc84e7ebfbedc460ad3c573226cbe08ee8debba6ba2692e3e9ba177945e5739ce15841605299d1b74d37c2cd20058629088d4e416507099de14960adc6084c62cd00475c449f84e2db1b33d8799ac260686a0a3af41f53c0ff5d470687bede43de574f198f5745953fd6f6fcff65b2decabe899147eee33ee35c719a28cc81c4d4baf7d2fe38d47ab981a38359ffa3d45adc64003dab617880509371f94e75b4453eb61252de4c043a994590de5f247de52d358639d36e5b69578dfed2fe378ab9720ead30a929a7ebd26434a1621ad341901bc502b76ab120d695d8d7880ad0dcb451713832f0217b95131afbb2b6c9b7b73686ba870a40681dde44bf04674dcbca4b8909916ee22397a919d3f6be5b14477a70346f6fe4848563ea5e4dd381a8574facaf1b2dd2cac2e9f9c90901294604d1a45b0c364914cf8ff9c7ea939bc96ecb31647c08487b78f712695caf5e99d6ed9d148f16d84adb340945f2440e922a07a42aca025c7f60b48b8b5df851695ff761c4cc4025c59c1df86f72cc650e12ab666441cde2ef4181fb6af86c0bd0a9f2827ee714f9de6920ca41ba081be6a0e0cd45a5ddad861cbd93c552b6ef5a070877533119ba46604652a2cc0e0186acb758d1d22e82737d7b212ec0db3fb9ab911f55030b1b5cc0e193d68cedb07db54c725a990995db8c8c1054ebd14abc361929f5cf78f603cfafab156fb573a0e60892bf5decdf6a9612540c95126652f119059d186d41b7d14034f2f1aae024e691cfbb08ff3263eb12f570757290475625aacab74d04995d8c3de9a396ad7a180a2c28bdea9c61c45242bfa259df2b96b97fd980be557e0e45bf61f46927f959b8d3a12dd590ce6d2dda7bd8979198bc5f561bbff8efda335252ba41c4c89ab38d2a5d428b5f4b8434019598749b7936b5aeb4a6174a8f55ec26a302c1d585d940132b97de54c838cc8dd134b32fca2f5f537caa72b7be9506a50ff60c5224d7f40be7dd5cac09470d44415bcfe94582a64ef0570fa4299160454a639c22f2bc78250698eb145c90292811ad3e80af8396676e60c79c5de4426e34aa83f917f5d847362872f36f83f9c7150e93d494691f71100cb3573e2aeaed69edf42a32aa248122b8f0b8dcd44c0ea0f0afc10b51b4b35608dd2b43185b2c817c6ff1dccb91390937ffcebc1e26b4f28905f88d3e367a8a63f8716bf748c0d626eaa641a58244ef88102b4744a7cc2a01f2f44473beb338513947a160b3b9f00813deb792478ab2a8c9dd9153c892baa47e16b08d2a78ba449d546ca020da5a1c11a1e962f8c9017bc497d009baceb2a07e87aa798073e22a0da3f7acc15b5b3e07cbef006e8464a59cb85ba0256c922819863a34b75252abb9ca718b9440bca56d251fbe68f682fb39da0e9689084dddbdb220fab98d123e51c77da5a4f73ea143ec987c04f14aab8bd0f0644da202f0e25064fca638b5cb58b50af42e9c1cb24ce50cb679f58a939374882c6df57a1f2181a765100c197e5c7ef1f7b2dbd370e5f8b3c7d70216f2b8f054601cd894044e1bf5670cf64a171a375145fcd474253505504862ee0cd73774e0b2c1faa08e331db68795bd939736392e93313f4834b290c251a8c759de123fdbb9ec20b7251e4275e8d8be5cdec552c66d37b5ea6df187a0b2557fba9cc50beabeacf88c4d33c985fb280604c1922743e758bcfcf99071cc5d3f194d14740bf38bfc494c0a921a9b167458244529fe51a81790cf54c17b6b637add8e80398d85798c602ed75d51e5f6c0e5ad53b872933f8a98b762a849b0ec178d412d20b99b7dd0b57a41ef40c2a8c13bf2724f8e873838e08e4e31339e70ce6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
