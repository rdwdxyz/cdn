<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3183173b0d2d549a59063a496d5aee05d07fb39462d6bc0d4ccadd80750254b8dcf221464dc964a6239178a5fd0b23579e26832adb167d784ef330730e7bcfde4b123669835ffec4cbeccf1f6d7e2d43f5307d8ac2ceb73cfdf9979530f89ec50ad6cda8551969701bb00165dca3db174f5b8f8c091346800c6f06eeacd594c63f512c95259ad707bd4f36cf4be99a64f3fe721bce8ce43da3c888f04bbf8e7cb72cdbbeed38b4106d3fdc3f8b4684d21dc77b36658ac63b92dc48b43a90f5ac146b0218336816b28ae9c6aacff27eff761c71989803cd783b1ca3b09fa1a303d1bee40e1986a2f158268ee45e99956ef07a224cbf339b1ec90ee5642bb7f379581b11a544cb498bdfe9a48ae239f7d465b647c4a35cc929c85a7ba9fc0b3f7255063469f2e816e5da4e285814fe2eab31cf1ba1af914a5f614740a9e767bc676dc41c4806c769c4035decc727421a87fd277971594b6878d118429f670926d8981f5dedaa6a7ac4afd764069f2fe993faf20442f07e0673391bc8c2451ae4bf337ed02a54e022f7736d93465271675b3f61d3480b014451d72c06e8b3ef0b3531349a64b88cbc78a58fecb4f068085a938fa1f873998e15f03af626532f3279892aaea46065328478c45029fdd81f32d49b20d232d6d819ee8d6ebe90c8a23f4f4d75ba9da7362ea1a72e77f686d6081c260efdbf7b6b48871dbd2855e4c56477f917498e065415f8e0e78e2a5a29c8d72387d166184b52b2eabe75788518eccb1985fa1104a03abf5786e8957313d206e6ba301bc80f4425235af016c9f2dd7c27dba9f20eaff3c52de425e857b38e6814c726cd222a26aaa06deed9b50c54f397209f3362372c8823aee8205d90c68a5081ce6ec0feedfd7b42d07bfe3e92cecd7e799465faa40dd2925c9c54d996401a5138d009be43c9cd939d53881e42b184d03be41ebd055aef7a51d131d27992178e8e69ed0149a46c01cf58a3abb961c94b40cb3b9268c6186524de53762186e467a7db66ddd0dff0c30158dab8e5a146ae571eed27da91a4e54c0f71fa2817a0d17fd391a4947bde56e97d39e85f68fa41a48081338c8c19431af41e6876732bb40100aaab245b467bc295699993ab3a42dd7fb6d4ed0a478de1c69291d63b74503841d9fa6e8b268ee611134d78fa8c558660b762dd6c2e2983df6875f80043e004d501a7cae6f43e1b96bf778b52892f91a9ab025f9af261637e42591cf7ecec2ae104882cb66b32e2c38d4f4b32e8c7c6d8ad0ca8c762abc9cb35fe54f0f4760e7f6705d7e576528cc826e9915468af891f3e0a82b459b1ea448a4e8b80b531775986c92a1c25c4851afa0c0c2a08e2279340be18fcdad5e1dcbb349c782a1b1a183cca84fb1adb43ccf4c65a0d89a91e07ecc99ceddafce56e213eb46fba1c06e7b42a8c89db5c88517925fe82656987eaf2fc6956ceeaa69e7cc0676020e1777d29329e4a36ee513da5566b5a67281e8d067de0b17279a09e356aade686b1f81e39c3da28170782f23d624a72038fc94f812a915e678e1c184f5b3166715dea95b2a73dda5daeeb5c918fa4efec1747f61ce8b39448446628109d9494b09465d6c55cab8e6ab339f0f377497888f50e873c265177d8f00716158106048913e4118d5619b553c8a736b70af359c81829645583a80c029d4729502f8b2c4aeb86b89e1110efd1a17adce822a174a3a7d1f46a37132181665c120eef89e81e2a2dde30fdef6c12905d71536eba805c2943ab81412ea9eeba6a1b80506e640ba2b6f8f343e89fcdb63e89979c0748cd4ac7441b8788e92f7295daf0b7441f606bbc3f8645319f13cacfe9aa067f494278cd962cbb42f36b13fe3f150a7daaf8068a6122b84a18a4e0e6d11b7940b0c81b565394a7d84df70ec814daa3f51813ce4c9af68790508a2b8cdfa3df3db088c6481ca7a8237882f81e08b048740444fdfc50879fa8fa5471fb3a748fd811859074cacb34e5acddd9cd7a453c3cfeebf477e5c0bcf10d03c471373d66f473b9bd83e6a0bf87854f5dd219fe5ee17b94fe073de4d1a6917b775509ebd5073df13045358c0efa419f8e5035bbef8bdd22af7366598b4e902ed60d20fa332bd1e1701b44641175b4c98981cad3b2bb071cc9de3017225b358f4ff6b088c87201bc7c0586c71f82bbcd663cd1f8f418747b29b5d962902468463f57a36d65110bc281fc30a97c7d1e03faba2f42241d662b61aaa188d552ff281d54c07ce86369b5d99f63cdffe0ad78e2c75714c08d50e1f2ebf00e391f11d8aec1d875e839f3cdd28d4f847ee189dcec04325ff6a2c43afe6f7007a37026fe62411db7b083086282e9f032b8f531e940d9307fd28d0e751590292d122f95657faea5a2df98c8027d6e2c10b6d3125d685b1221e671229eededccad23cdb115d15a39d5097fe508932618c1e6c57236b68d99ac3c80a2244cf6c065f73ec77c8120f679ddffe9d7eb758c94dc44c90e2ff52240ac3f0cfb26d2c35c5aa73c18ccdffc8565c1f75e620dcb4e3d7cecd600cb9c2e62ab75347587640ec316ae1e43ef39059867f65d157ebfb5383d43cbf5ccb187668e66e773c070682b5c01572836d1939b821e3ba3c65e36776e18be2ea97b28fb0ecf695645d83fcd738be8744b1925c0f79a4d62cdde0279367131c329e9024a3f983f3f6aed6f953522901902927edbc5c53b9f763dc6ea7785b6cd40871672df0a3e2b3daec2e6fd919d3c1c9f8de6af8442734525171ec1f6b05bbef57aa41e5ea8c1b847cfc863a67ca29f78adf372130a8c30c5e74ffef873771c8ed6b03399453617861c31e663396342676df726dc1e49febb4da056695e099f308d89adfb25b8ddb1831cce2012cff7385f7aed02860faad507cfe520e4ef5a7a38d1947f6bbf324c9af45a2cc621e07dab94edb9369c8204a39a894aaef307f8f3750ee295d9c357d3d6b39c8a1cbc585798f9e5d37ffbaae841cbc9247278056468e7857559bbaa28a04eb932bc0c7927c8722ceddba4950127e0ae36729191d82a5aad7705dd029ce9479e201496271718a9ab1785a07e35aad9dc79bb45c11e52a31b9eabffcca3af54fb7dbd41ca533d9fc9c21b9044f351038a7ce075dabcf7b495f00749abbd9726fffb7dc8e5ec221b41db79d70f491ec6eabd9365af1c983e5c1ae1f815861d1ea4aa473c3b257e63cd48224519e9fadc5f2721c3291788d0a8a04420899fadf6004414f6c5ea425b16a9e2a7f067826d367cf6cdc75cdd989a50fa6479b12cbc555dabe8984ba80defe3c147a369d253f7b7558e3df6f0fb47b362894a2e5fa6b8d159d08d4623b554526776cd37a8d19779d72b6edd7feb018cd869d714d1acb0390deb2839162e8ebace2310d4e7de1450f732fa2e7a750885a16aab54d8e308d8d97f606c72bb2863e98fb668b226c50a71c4d9ae3eb8755d8cc2873aae7f3a844a7c7400c14717fc2c8112e9cd6220a8f8fa86946a772777029cbcb3b9a80e1ba78a85dbbdcc162d689a110033e21361f6367abed365e40917fbf3809ae4e86df3c86b38643896e9de38dfdf95a7bd25d5bc70b4177bc99d33c090e4d016c486ebb9856b456cf54338a67b02dbbc7da0a3735f7af510242b44b5d036bed31ce89d8ec3244e1a6201251e3244803cde19f442e15f16c50c3a38f437093cd923d3d10b38a0d766a7fd53f79ce94a02041c76f6e9445fd387328e4dc7b84219d5b83349cc58431ac7aa6a1893e902133d28735cca22aa47a9d13e83ec867bd8aab90a153a58b9516e8f9c8078a80bfd67a0d037572d6867d039d35e3310113623a9bf7a89f0dbdeed6930085fde17c22ebaf6c3bbefaf9a4e9504f64d57dfbf23ad4a721b205de0d84019ec612e15c1892d8fa31138262bceddb78ed06fa0c5feb8021f6a65f89f2067441ac6776102fd6cb84dff824fdd64116dad4061e850c22b31d3e4da58f60af1bbad0984d0b65358ca1e7292c955edc88a10b381d656b78f58b5e7997c64d958d0fed2dca189816a16dd7c76dfab32d756f8d53afda8e5d4069e975c60dae4dd3fae00d2e5d6fc82d27cf235b9e547745f84dd74902dbbf8d7b02ec7c6c42ec048ff8f13be414a28e93020e55551a632830d252fcd98ab6f40a36aac6cb71d9f2cf5e5deb093a3dbb7b5c26561bf7f7893a866322edcbc8c0dd7fd7bd341d4b76a0867663f7a8a8d279f5791c42d882011520fdbc22eedec055b6a763dcf0de62a857d84755eee8d6befd22c287ad1f694f4782010001d9ab9a2e46a08e3ecab0d5ef687a1fe019b1fa357b4267c3db1afd7020226331b7173211d03f350e75068c12391db074c19eff37a0d349813c78031df9e0a0b1d2f2e78aaf7a83e882b687f2e62221db7bee23cbd816ca7bee0bdf9bd92198d78155836b398baa7ac32b707a0a2801c7960c37ef11cf82884e7ac87456b4d7ecdc16c1b9ed2818935fea886c1ebd9255c3c06b2090b58fe4f49faa5f3becb007cc6a45321c6f6c54ca6fa892bf0e137019ad9917407be3c136ad02b8eadb06a63e6d9b6ea4875a1dfdb5a703d904642908a2debbbc9e0e58a677216a34f37f7f5b2762cec503ac4acdfa46c485bd745730f180c3133e50c4cfeb54bc8190fae7e3466cd82947ddaab160070c3223956df7b581c32583f05a5fa7ea82e30c28d26327a43152e4606ff81ea495640eaabc26068fd366f808d3e603ebce7a67e1283873f3c1c28c64cf01b94f9288ec4404a21b9c9e2378ad6ace79c3db48174f88d0dbc84bfcdbc32c40e9112ae6fb0cb1a302ce73e0282a37057af03c1721ea0c7ba1c6b3cd73c04f9b4353348f1adba5b4ebfbd216b8536e50ae221e7dd97c21b61e226fece057317b172ca43d5c6621f947f181bf06a42900c9c8780ca11841a65f73eaa80fb614b5a6442bed787acaa2e3aabbe15e3946670c6a206e1645e97f1be27b9bb99f769defd73a8385ff85fd0878f9c22a4f9d29b23f21a18f3b07cd206a30b8e4cf085ade08490f5d3d69f874ae42dead66789f93401965bf779b5b6a393b2514fcbab813d67e853c961f1174c9638513312aa121c024fef4c7791c22cfff8fca73cccc081a05ebe791adba15229628064d38dd7b201b0d6d8b3558709ef09fa4acd936f1f1668a49cf6ad3dafb4b2a69e7f6d0a4df15de84a8f12f555943af06c1db23505a68acc7b5d424071ea9c794fbcc831cabf891f7d460d0045cf1ddd53b0742a9270f9da127a4522286475fc72dbd061f333fe5647c45c85243b5e8bcd9cbe35a6afd39397d0044d90487728225d03edd63f4e7fef88930f45640bad3bdd7033cc1bc4b007865414b50ea13cb35504bd27d7f4320df1458b854afeaac7acf32c526220cfb079f967059cce34eafc0cccc4b3aaca402f609128fa8f30ef2221b4c0f3720f8826ee5978229ce3fb280814e9c2d70ac56f771949c41403c48978195f4b5a4ffbdfee1e2c205a022f380d9c99bb45b942ff0eaeef36f3e5fa7bbd36d28a78bddd78eff7b57355f1c9ce68f757078a2933cf06be0192964a47abce8c69f37a84c61b5a0edb38467dc79bc3602abba1a4f0faf1d0169175d6103836ff639044c3618f8712b1cf57ea2b512fdf27ea639030a9d11e20850d20bdfe75d8ea9c5abb38b5a91b55fdcad9d1829d1304665b1fe57351e0101175dbf25dcd580f6148e24583d29f9cf6ebd7d3580868939f675fd07e9f488a46f6c2fddceb641f1e98a0925a0a84452864dfd288a2e2a195a0362328811a85f1ad7af2f704b5089624d81a1796847bc8eb86863ee79b869a150977342c3b265b581a8922eecbe0d3de778aac415d7006c35e7ae254518ae40f319965dc8519072dbce759eac2b0946cab3e8d565d30826abc574b47099a5e5560f2ffe98f6384b307d3bc57a2f4a97f91c0402b78efba08ea0e6c2c8b00f24b3ad5193939031c2cfafed2b713e4cf4707d362e1e74bafdf580b71b258b289a4a8b778ffa45f1b9702ff9968165ab120fd4fb67b00afdffa7f1dc12af008345a6d633c71fdf188b579b1878b3da823b8909d5e76d46c6a5fa42bd1e030943dcff22021e0447f8b4f3aad7ee940aa216cb30ce785f2fdc93b4fd3946876f5a14c6c02965f7dadbd5679e1a76a99bbbbe0fcbd36bae397d037b31cd2427d89c7bba154f4739baf38019da0b6605123afda0d23b3feaa8827a96bab06fccb06b1cb2901f9f712e5658be4240d4a34a1068e2c3ab956f27251a9b8d6e9119fbced404d46c85b2616225906d5921a6516d08f251a9a264cafeb40da0a9a70e9bfcc21fa3003d9ea44349f1e69ad4a1cfd43f29ab5829399c62cfdf28dc5bc5eacca7520462d469e3b98e2cef0d4a58f957e539527872fa60962fe101d34ab455af95f4ce3f9072079a452399b44e8b11362aafc0e4f0441af190da408b1b81f2afd8b702bd743fda00d6eda99d659f5a3940af1ebfb2cc9e728e84cb07a5731c2fc558ecca75b96ddde91b5a7eb5a430d3fb2905b5d55984537ecbabcefc6b925259763c08f13104e8faf54ae8e2e52fcb7ffaa620c452b139c7fa1f8410a7ba31616b4ed58c0cf342d422d76ac7c4c224de3a74e6eb1827a92a6280986c230e3b85f3356c56ffe856bcefef60687cd5f3a497f83fb107123d414b362faf6f8fcdff794238d8ff97c74f6e2ea1f5b1ad021f7daa11ea30b410e1055251043e4dd79e6e59f2119b2018ea24cdbbdd4177b155f93e0a0f52c0e7c69c4e9f14a0b58183bade8358e76277be3a8f417dd0d8ed4b1f2a3b9318e17a603f766d92203902e52a99609d8a22cd75d169e2b1be8421fb47b79c5d4bf0074e8ed4d5afaa5257e3e186c5df66c493a1196c7135434d7ebee7f21319b7eb76c9bec90071106e8c8b9abfe0448ba12c6779720f456df700cb634da64df96090cf4f27669013c41f904de50040dfb021473144411930e0076f7056121a0b1d13949b5947c2b223784eef6798529a4aeb412e4a1ea8b1714987babe8a987e3156151d98936f8265f4f1e5bea084117fbec28cc8d397c4c4043afbc7a94c6e3a92eb797522dc2e8a4fdb99f2c79de0d291f99e4f94373c580ac205954e654fba94829df8215ec63e448ef68e955f6d7e6062f10bcf86f9e34e2ae474997f69801e15cddee1da73d53a3e9fe9096f2d7946e08fc714b56f833482d92959aa955fde5a8b5758e371bd84afef92bdcebaf1953a9c1fd55ee929a7fe8d3b00ff3025346291d82c4cadf5306ad98449fe303ca4254039c2e41fcdda813bf79a9fdf464193ae38b05496da9ac04fe3bfcfc11ae5eae3414daa15ffb7affe8d67894c123900ddf80ece7ff40e93209e34f306faf5e9d684f0c7719d03681f088e7f07b97e4152f79c18340d281a6abc15654ae48c16dc32af20185d0e881cfce664c957539278193992b63bbe3dd6caa77950687ec75136e0c099c33ee2bda33f325daf63044cf494b2cb166424b23af48ca15099edc67e6de86d40401c7fccf1785e3e41052eb3cb8c11f44a1a7805465306d29df57f9d787b24e2cf242a06a8644630b0b8efd27294a3007c95929d23c71bf44996de90061384beaceebc6ce0dd30a3638c06aa4ee2e69a8b79710761d8afa264ac2b0ec79c11ea7ca1eb0142f5b494a4820141be5f51de381def365e6dc7636feddd53158d40da72685605c28da77cdb2996d59ccb78c9752dc28fb3d7bb3cc881c4e0d9b891385deb16ee8a2dc0a4d2402a99e0ea026dd3a21a8b2ebd6e952ebae46c74a5dee40ec43a717dfdb05dd25a44ee716f128083ea9270fc85549016a7d88d87f3f089e67dc100959de6cbffa1917b79c39d3c7bc759dea78426d6ba25bb488d58d3664a7da5fca693d3e8c570e99e716a93ec135ec122e2c484872eee524880c3c618b323618ad83967cfcbdb4d8d341f001aa8b21e5e144d4c37739ed72d7eae82010763c0357be6cd8e36f71657854e96a7eaa39bd9128e4c063e538644519fef23b1e9a10076a78ba6e5c88200a38f44e27a6a4427161fadb1e25b4cdf0d3aeb8d0aa6adbf9108c20a21c8d3edce7d9c3e21d6980b2b3d82e97299b9b3cf7d03d8bc8ef00ed811fd5aadc0f3bf52a474f1fd3a70488ac3dbfc620ac41978ef911b8ed3cfdfe9e5e3853277dd518dbb8fd221a3fc9216cbf86e408f88d51d4ec0d3e374974049664f594db5f981bcc02c6c30de21789742fcd6fabcd6ec36caf0a4e0e568a16424257c94c7f8c8ee353d27894277a073b4952422fb67b8468dcb2cc2d87201f96600b3bc8ec971e70e71b87503cd81d97556aaf41f666d9c4b0fbd85e9944fc638f09d77b8c7e83ab511e7262c041755fa353de8687f3261030319b4c19f37c6cf2ac0e4468cf009f3634776c641b163078a79d389db79e5a08945962b2213fc41d6614886b8ad47de2b33ab3c97cd9c72e9afefced9a3c631b928eea2fb8b3625d3b2aebb221d3c1f8c39b06f3eb43814d849b0549e780c6a8c29fc394e82fa83e218e5c743c89f85c55e523b000515d5fa58ad4746a7e5c07a1b6062580fd2db8d704f092e286a89e58cbbc0a3d2e220b1083b1c561cb089beaf6baa1bfb6f1f469dc544c6f63abeace2b06f7d8945a1e965e56e082b3bc1d86ebc54e7703c3cf55cfb95726cfc06b2a2a3648fda7f31484ad7974892f68c4c68a020037c600ecc70658c229a3295f9b78d5de39401f2c9bb9a5630560d62371236c88cc8afe27b50cadbf5301c8788136d72a6ece35333c42717a6d3415db1be5caa9e0138306f3f93b0785558b77843d33ad75740dbf16dfc7291a1d2aaa5616cf1a8d275245badce4e2d69eca0d0d6bf9371cc0075dc5a41b2da5133df0b227bb70810509935ce40110c2247924566f0279d2e91d250802d6d5103c2a7c1cfcfcf8de9077b2e87cc9e29fd05ccc5211f283ef96cce7d08bd85847b2440602e37b9f58811f011ed2c0561dfaada0bc6cb0c621fa937035c1e7d9824022054f4935f7d87f586822a12cd39d9dbc3af6f2a3309f87dfcefeda0d076bb4113dd8295b4fa791e4f51f732cb0fe5c338e8f9bc9fade0729d03bfbafbd52e4cc2c0f6dff338fb1b1e27a2a63b163d0385770615ae8cc374d1b8a7bed37cefee4cfe3576f0a87b89b90828b44fa93a1784f498129f5f4e2cf8c05ba47d6984e8cf901e744423a23b067e3e75b0fea0a4c64496af0511b4823dc438a8d22df4e0fafbecd6ef8661e3fdd81c7f7eeaae9b2d335fdfd9cdf8d3f71b66afcfc29f9c3286a5ca7ef310a305f17aa4472b405eff92ef132ef40b0e3b190cbc29685523600b7166eca3b46588436f2053a4cf3c4cf2c2db51c8ba6a4d967113e252f61cfbd8172974e9bbfd8190d033e4d3521ceab2e996f1218a840e4a56210c2fd1b34072493b5bf565879e0e9268a3f6ecb4a8a45185aec6412fe0f342381b23752fc0660ccfe89070c112a2a2a2a5d9ce8678cf96989f1c18fd88f1af393389af3d0ec8a61186dedb23f59c5d0a4d19590a5586238deadac2e2d973308f75d87484baed4d5706e43b452a40f6d206aa2b631cf7a056723346b36c4459636d67043b0066c6c9d15513a271aec1cd169b9dc56adafee1c2233ec0f6a7f1cc08095fb2331ef22a14767f13010e861bf79d4148796a93ea9b6c5619d1286ed6a35de2fd90e5c2063ca321c1721c1c6daf5ef44c1aa0cd8ba93138069ac622d25c3fad9f911fe6085af3cea51fecaee162efd5dd6874bcddd1d008d35bed007394f542fe1f9fdaccc041531f1860087535a51f85a6a2a09bab0459966f14c8b327ad61e2348ddb3f47a0e60584d191bc8ef3572cf84d7116d69c4e29a9d368a66a444acf4b02a177b4c67951546ad2eed3e1e53797c1aa994994bc95dc79c8d9523cfd0405dda879c4b60026134061e43ede80f1007719ea79e66646d143cf2108760c6cf64edb4414872b8f744da8aee73e6b44da6353360fac666228f0f378d70b0dc04a8c3d1d14e1e2aa9a24fa58c40ee32c9822fc4ed13bcd5fc7613ba1e09edfc01a415fcc7443006072a31526d6a11d0cb7943403490e98ada5ff2c90acce2545c06c6db2f1cbd4251dccdfb2dd41adf6a4955aac2b2179a501ae65ab234306c61c03467b5778a8dfce177dbf533e0b9188fb27ec813071b750b60f9245fd0925875b2999bfb5795b02335e27a472c684ae3292fdde969b8b6953d2fed6979006634922f7c477c4732fec442fc1b61aa83d7f3160a53d154b7f1e1731a45e973df31b1858533cbd1fefe038cd914bc4bdbe7c66defa66c9c386b19ddc9974253026d8f0eac0e41ccccaa4c0cc2180aed080b29b9f7a493f74e4aec653aef50af9d8f3377d836ec691d3440b32630eb11a39bbcb7e9f19479d9da296d0bcb7417ce6bc5f29eec42090e4a6ba2522036e5e6b25984038c839a030e3da246f35948cd0f0f1fdaec28e354e06c8b0c18f378607f81ad4f5b20eccc570830be2a5960c1b777d166fb5bf5f4cf62089c2ab62b13f37c97d12abcc2df05d8ae67ccae94b31657c133f027ff6759a2ba996ea4f0260c9d95954ea6e5f0f5359ffdb703f2f266e6e631e8fa9f3a002b60ca846c02739e4f26487ecf650d19c9b543603fa03bade41d42b3d97cbe99b573d9a8b1367672d1bc029cf7afd9d7c3b3088020dcdc97e99e8f8299fff0f0ae9785b98284ed7b6f9917c57d30fe83dc66f25844d736cfc8a207bed269b9008d3896583ad95d21170d73c7322a2bf183b5514c09da4fcf68831f9b3a016ace16729fbf95d2631be1874745bf9d213a741f0c92c2bcca1b172435ad8e829b9c5c00881cd58a32222cf312677d7511f40ab1ee9e640e0e41b1bf20445284213b7fc41569c2e261aa272a8d743bbb309496d2cbe806f85ac21f56ec7dd30f6c66c66cb54892d40dd3ccd49641f08eb2d4ae54536d6a27ed3cbe2c87807115552453d01e1690148737f956c3387e3ffbdacc56d7d42b704902c01e24c6b6ddd0f6d63be77f22e56d2ab7bb25c6dab1c7e378f31eff5edb406fb1c266f2a5cc284ae2402fa49fda76d1207a3d23449e6a188d81940b9cacfb526c35b83544dfba413986157de01f3db29e8b28d67f2f0bcb39be8152ed05f92f619c37ffc18cfdddaeef5645b3fb7ef698e6d87f5fa4dd6ecba999abb661df8eb18464b19cb48392b989caaf47cd80191e6399f4fd8ad69a2963324b3bd7a59283db1dd737f988dcfe3736cfaf3188b3212640251947d06967cdc7d15a4c961f653cb04ae1d859131e694966edcf4abe203ac3d0d8d30a34a1ab6e4dddf039dc49d12e97ceb2889f1285ba1c61412b9ca36a3f0d55f2a1a6065302a1f88ed8531ccdda7b15f5bbf470268b1df44d5e5533669d0be24138cc18a8f1239f50070fe12edd7bdc10cda210d6360869ae8acc416a2055ab7405b772b4b9150a4c4749ecab97b65174092cfed50929e73d8ceca24d8812fc8925fec0f9008f55c3b990b0b6ddb0517fcda660ae1612468115037b88f2b7cd80d65bbdd2e8019f08577cc7811c62ffaa4a45a6b79a98c7f6a04717eba631608ed6b9ff16b929def01d22807afca98d45a49349e41b22678ab7bf25b5a64a2c482ccaed53cbe595dc018f06112458e2675355cd2ebdb77815746d03ce9e4d49529c30ed21993b16dfe059baa3e6084ae2d869ef686cca0376fd0e521e4046951e754efc49a99a77de3edf61131ad0ade712a4064e3141da8b2789ee19f4083f5289cd411d8f25d7cae649dc78582da2f7a30a112b6ceabfcf38c7e0c7a2b826a455e7429e1b1efc802f1ef6fed6b20a12760101b63ed7a3e9158c630c7e43359024ebc8e84c8516885bc919323f18a22e68802143892ecc571ac6d2e6b6f089bf9188833f5e2f14b0e7240d87a1a30fe9881648afbb90537bf2395a1c5592e4e71a94f0722d17c82b571f2ae9141e8de505ea098c02e651c647dff634bdda0d7d9af4e9455e57f9b4c3435cce0a799ad3a980b2ec4314d440edb3970faadf6c2b5a8a251e7464d8978297b370ddd572e5eabf14504d8d454be4ec39bca239a97e9e73e2c470499572a11602f086acedb49a573175df963fe7099e09ce3cb374ac15bd6817950e47b16ecf1d77c5caab9291078f799688661cdd3b973a8f412d0968fa08df53162ffa5c10ad91abcd6b0bd21aa71d84e28f307121a984e44f344496cf6f2fbd82cd31e2ffbac8f2c479681e873ed6916e6def299b407d1ba15390e8bcb5c262c53f71e222e85ec045467985d1cf0e82d8f25549a386daf3dc8c49a709a7ea72bf36b9916ba61f38a96f8bdebe1c55e9de26acc2ed056a43cbf0e774344d584e22ce1bfd8cae8a59166bf22aab3146b498de558f40032fd51af87be536fb2de4558e65f396f8b579721c17e367f2fc2164432157b96d40764079b5a2e3918eadb9bcbff33a6d64b2e4d7ef2833bcc7d1521d0dfe5e1cdf2b4e297e5a76e5ba1fe5b5c56f23097250714be758e074eda4ba16c92506512ee6d6a86df3a35114ab787a3cbfb21d83d447f5d3f6ec3cd0b764bb5ff62cff1c75c462ca0ff07bff3fcce11be2968930986d079fa7212618cbdd25fc9778e09c6d386808842a01e0c50d4a9593f1b218f8cef6ba9b3caf5a6e9be8b50ada94844c3d347b1277bd52923eb1bb4c7ccae8666b414710636f4a35b2eb9f56fe7151042ecffc3e1bd8dbb193e1d85c68fcefb5283ac5c61a935c6af3e7f995efe9494127549cce2ce7e64e946a4e1df7e67cb8e159911306355b92aed166bae18b98ac7f07410bef32553e5ac3015d1cf11be53098d095e4753713abd21277511d95c895d3247fb23306ea6ac0b3abf95651e65789c3efb92607668c85259d007e56b78f94ffb1b510b6e1cfc13fba25d3981dc4bbce349dd3c2d276d4be93f75bc6f76230bceacf27b043ba4679a4a8d908e02fd7ffeac87c23fcd113ba13c83f08cf5b8bbf889694257234d05ff29f5cf12fafe96608041610870f2db37289ef48b7739fdf9e3c7d499bf1b5f4544017b9eb8d7c4512e50776c6c0f2a33b54555f1b14a230f7e0721497893eceb7e2a23eaec3896106a71e0fd72749771bc7bd24dfe681eee899486340f323afc9028df18b81e90edf9d26d4109b793dbb74b0c362791065417ea4e4a628e4cb62237d18292f1977839c4e13b5cd9370123076dacdcf01e7f517d3e8ed7250f1d00f7660f022a4dcb61bc2c403b8c5063794da6068ce4a291cfdd839b45e5b7fcddc34f50fcb7c36b2769fafa2085a8585c8f0d8377ed95dc41f491ca5e41d6727e65f83541ec8391231c7f8f5cdb15eefb2f70c7a8ef938f4ed965c1a3f5bd467506fcb7466913dd3e7872c165712e51a1444e06412b1c3e0208d2284f4b084be5c94bb7dc164da6221a6a3f0b633f39d841aae4f6016f7c09e27ab372b61646dbff29bcb0763eca60d88d20889d5858ed620ba92bf2c22a3a423d28d73df275629420c0c45508d48d3ff4993f2831fd48132658b388603a5a6a8122a256dc261d9db6643652d65eafd74c66c82dbcd852f8cb3baa9af25d782df18c5edb4b33880a59852a876b02705ce8e76bb2b639bcf21933a47d2442761313f6e9a618514dcff6c67780376619683a1156e6a6e2d416ea603ba5d06baed559e0d20f68b60d97dabadf63cbb2a1302157f4bf8b03ba9b2014a70962ad22edbeecec0f13e1f0b1e0a47ab8b3fe442b80dcab4e55993c7168b6c65bb46521a9957da9c739752a85d0e5826634ccc3e1794778cb85abb802e4bcba9783725b7b5e19f3a13abb6ca6abb2bf0cdfb256ef6b7d609da9d2b7f224c1ac67d3b0af3f9afb81daeadd387044270856297df53b35fc5090b6edeca26bd127250c7975ac278a13b4afd265bf99eb7364a5dbbb7436531d5251bc1c1011f19dd25181991639ac42fe166e11c0d64a908972859d82b1357d139a601ef8b9f76f8989ecf32331276e104dee24cccf60a1dc6f72f5459cf0109cb76ec50cd189ff326fdc6244a0c5e8d425ac20136d8efcb30c6127d970530a61c892fcf63faec73e413e2370654c4f728e88bf3c0c4b0b235fa4b6d789173d784c0eee1a3e9d97c134c0c7b0edd3695040d401f3abb99fec4600fe7f9e75ec480c43802cc631d0f55a71197ecb3fa26b4bd1059cce7f16644acb5e573b2fb843708b6854ca86bdde06f7544a9ff2ef6aca03d971a4c6302d4d21012127d92ea8c3a251adc60fcdade814fd1198fad110b6f5e261887e2f8ac64f4ae8fcb62eebabed2577e413fadc621ebd7457ee28e0d56533cb8358babcd1e602ae3443e1a94b09537988fc370df9001e478882d897ff77ec4c78e29eb36bc7600303c5d77e52eb1f6603caee8d3a505414071b9c44b2ee7dc1fac75dcbf1ec16d976461ed5055cbcc7e30899dd4ab6882413f96337c33654a63b8cf2f5197820ad9de53d187da3f2c96878f76f3889c975221a80d761c00ee51761df1b866bc532b03602d17acc761ae37d7240b3a36f654d1a44d1084e0b27c14df1371200ced1b68318055e71480ebc4450fc618fb169f28eba2bc391a25a3cb61fa8838e7b949eea275c4c12e6667a89ee87416208daffc70e4a5a77c7cd883b65b66f09a52268882e9e349520b5e255c7c0754402d1caad95b0acceefa882ead5cbd83c573ada08e9c349008ef33cb064c134f90ed100b0e637935a7f206a016b13acc11bc164e5b42ed998bcf28a86b783e3c2c573ff668eea4a9998825f81f3af4d2efc54d7edaac25322e6db8927686193746d2b9e4cc40622b7e24e95c727fbf9145966a7d71e2f392763db2dc9418c6d6ec1feab1694080e8c4da5c8f5b0f771450663bbb420d5733d44f67b9e04da27e05276dd9cecf5f69561fb42bc8d881588dfdd066b48719bc62eadf7b447de3555b229ad668bbf1047e2f3508d188d54a1abc119a74cde581c7fb5bc638d9c9ae37b9492357a49cb199c3a584de7e6a661decdbf760f55f37bfd53d54ab1c6aad0cff069f99c4bfc2c81dae1ebe3fbd31f7cdee10dc713117e35a324a308061559b0a866d59981987cea478888fddc711a1d1eabc2352ff5732bb8201aa7ed2e9d38c4f711da261627bba2ad268f55a0469aef4dc01be257de8064c9728b046f47d33f1cbc0a13650597affc54058807d1281693cf76b62b23a06f45ebb9a0c6bc49b95d0c61d2fa1f5d0b439e76a499d626044a76f719810750cec8e64db77207f7557fe7399f391d271d10f6506cc60e1b4ba431a22e6d99413a9316f889328cab862a050e0c544c90799c2e900dd1898ca3c30bb4778ad10514f79a56a6fa95532aef7e69b3dac900e1a7b07efc15a734df53ffe8f68c65357270f8a8792c563635046880a0664447b7390404315874c08175d9c0a097d5cbbd0c40e1d1e83e7a99489e4c2549ef9887126dd2840735e4afe0d79ba9120723027242586d2e5e5f76dc314fd4de6d5b9a7d69f7378e884e9a7d83bc55bc5581e1a779fb3b2f1f36433ffcbb97fa2d35fd6258264a584609a9850690e1785ddcc086b6224e84cd202877919666e7ed7b2672e031145a872e59efe62948007325bc6181c5eb059b632eac9b0aea5c3aea9d208466de6d0fd598c2c807b64b4e34a4b13e3b80a8fe1acc2e7a605162dc82a0c98d02d724b7d61a1e0e1ac829293333109b18769d80b00b6555a721c480f34c0e48a3ebe0d77af3404ad14644747ca472993ed154dbd4d43dc8b0fdbfeaaa90f0b5aa2694d661c93f3c00da8a88d8f112c7181b951cb4be7ee3765fdd567937e3f1662de6df29f2d7423a692ccee190a24338efdff2a04358dcca66ac926c9c55e3fdc71a38555c4f7c845294e0d23749feeb9e182b93f7c23aba4c067ff63d04b8e460368c576a9753d3b134530fb4a50f3d3f4f64ff8fea0d0b475236f340529d2142c14895b7d9a7ebc96cc547f289482fddae9e773c633027fd9d17dd9afd1a3287895b15b7b5aa7a74f7e307eec138c3b1d76d58222ea6325a3cd53c8314d7c255e9278e51b58e69fd9975d64758addb10e9595eb097e279eb3ab57d50852b05eca0dad9ca2049160cae558d353a428322741cdd9e965e4f53212795bd221068575645fcc596815039236f4e2f919aad4ad49f83c0ec7994fc24d9704fe791637cb11bfab3c10700bd28304a938cb931f6bc5e1a547fb50d19fc1a8a1b4bba38b41886837a29de3ea32fd6c2309e332590c4db3a5a696d5a9c1ca8a2ed054cee45532c94c5021896699292809ab64eed3adbc8c8518850d762e9f2753e442a8ddeac838884cdf57a5eea8c65ff4da4a6922407f59d37f963aba9506ce3d3825d040ba591d11b4bda78066a30d83571395dab93588ba0e15839348be0d2d9c2e03621d81ea0b1409d0ba4b46d5bdf6665896c61d312d2e17bf2b3fa12ed8fcdb82fdad7a10b8ded279d6644611115e26b787941deebc3680f1c350b4c7f0a0e746b130c98e54c8b21e768f19aad7fac85b928127983131f5d5306343a878ab0f060c0479b88b89a37aaf3431c874c81cd84cf4d9b3f135f70c3edf6275cccc65c39569a1d0693a55146839fbe4c06bd7ae3acdae918cbae45f50605f52610ab594fe0130b0b6c5a8a0b94cb1dc605b1afc1b939f7c78ebd1075b14571fd577daf94de8e4d1b90e02466a762299a7f69ebaaf8b39956fb182931c26686727e8aaafb47b58feb6fd6609dd19f65265a8d4d1cfd8940ebfce9b8842fae41ac8960f82b374217b029b0a4ef25d0e19534c35a1762433866b74c6c4aff216f9b87b104bb0c7d924e700827921e4f997e293af3b35e9cd3b52975186aa5c2bae38f1b94d2d3d9b310ea31834abdb545e86d797dfa5d8fd4de2dd92dc3b4be33fd4f52b079f301cbc913da8e067ac2f377d372331344456c4f7f26e2167980acabc351e3051298e103d6a0ef7ffe3f21d130b3a96f0044c2bf453a0644005b90ce80bc47613c9382a276e31ac7fe58ccaccaabc7c725dba907402be3bcd153924c3b7b4885d2b673d054b31c15ddae218572f9c9a021e8a86701a580db8414afeb8670b832ce022ebbdda1eecc90c34b3de4be9b7820c8e3b99e2d7de9b532c7f1d26e034668da952f37fabeeb2edbd7cd9e69c421713af9f95157b0c59a850ca4ad88277c9629f0dc65f2256525c9cc39be54d18486868d364e96af451ef93cadeb247989dba634d2d143e253257afa2cea778d62e8d305888ac5b9bca86390ab116a14f6aca64bc386d5560e4725f722f13f0aa03d3a5105072d0ac2e5b79640bfbca4fd683ed84ecfbad504958865d704f823eccd1263001ef089b8f446df5e64d8e9cc4e70e5837087adeee830bda50035b4f4d33f7143dca80b4f20c18df5385765c6f309803c1af07821f10c511c6cd0ad778770200ca54cfda0c37ccfb3d5d679ca6ff5ad82ebb030e5f5d7a03ceabb245d0b7be26baa61e4656ef56e20a4f0ca82bea5f056f56a5f4e92a89fcee8a7e7e0d2dce31138b1447ac1b5209149cc4c6b21aae9f6924ed77d4e3d3846f1dffe4550351a2d787fa89aac4213a2fa00909672f080aa5ac24586b5d026d2eed963b5dd445a664171bfcfc2d5e18f39e467052a60e7289d32f5c961fb29e42979d2bfda4c12417fcbb96f7f89e17ae1020287eb8ab7a46c8dc4ebed8ce45d4c3f2cb72ee08834ceca38b9b5b1de1ae1f1c8abc5021407b432bdd002055c99e63392606e16f2f94a374f0ebcadce677e5651ad352ac5e5681122576d8e8c3d77609e377dc175e171e0a4cf9599a3a8be2746734cf55255a15af0e9b31025fc3ef3b146393d3563e4d8d667bfe15e67bda55b194d04ab8f74e06ffef7827dc86935f54439c8a18476f2a982365c7947dff23d98113c6135a5fd534c54b722843d075fa969ecee599a432bdfa8336139416ee34174dcc047851308a3821a5cb2d4ce7768c94513f6134995c4a46c1f1b881a1cffc99ddce78aac0e1b82a3ad8a982c16fd377a393ed0e1d606439bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
