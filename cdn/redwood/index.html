<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b542aa2723d02684d09eda63602e62627251a30346ab144b7ceb2f9be7d8c9d8f0469c06b4c73295558a18f8657f8be7488e1dc626878da6217d0417fd3777744cc0955a69f28a97d200405b1034c1990599bc02ab570ebb58cb67dff18be92d46ea0cba8d9917c842626cab78d920864b4dce3d3369211cced212ca211f9df5daee15689cecb01eed43d3610d91462f323a489f73e5567656329ef7b6c8a7970d89efd99eca45abcaff923cad318ee6d9140f57684cfd1a6334636cb05e89064367f68145e5b82d74bb5d7fd81b0ba10aa014944673c1d7212b20ae57148091bc2dccaa2652221607d972eebcb4533c2c3e4f720c1956e261cff6ec4b3c2a2442b78fa40191ec4e7f58b055d9c9a6e1a80870ba707cce50440ae6125e4029a87f9b31a0bbdb5b78c5a14e77d90d7560d4b912a26d4f3d46423efad19db007e3b8b67637902fc516cf9ce750c08b63f60c485f2b0a56608221b1f538afd81008762d23e8c1b347a71f5a8703408d8e28e4c736538236fe75b3bb30917792f142d3e0963af52be02803a23fd52efb87d0d7768500d5e6d392b1bfc22e124475f9275e77f45c644b2a4fb769bba690229b025673db5b44fee18b26cbb9c3dd8a993a0c6021e78da84e44d76f4f77dad5cce5d6e30599bbde55969f6170bb0c49199994993bfbf34bcc0e683591bbf06f2ff1c693f1cb1d07b9b873a982b0458bccbf14d04bdf281daa5f10510df1a8dcd54cb4ded219cedf882b2480e16c2bbedd5669cd1a751d1940ba6391a8349045d4a2a1f0ac51650a83bc46db9bea20ec3fb89c3d1b6f6b1ab6a66b3b0082055731b96baeecf77af6fe367c4ec7f5e2518de6c76b6299f2976f394622d3d559ced1289c3caffc5f4f1b3157ddc03b561ac2c38e051ca7ec8782469d4a77a0df58f2dce1ea616870652d28609a26eb6425e9f4131c68e05cce98e6be656ecbd40f9b6d6608a004839692ceaf7ceb3c700e0b3c655d9722982083c3ecae55771f4b802fda0f0910b97a715b1cff218ee3cb4050195de22c50319fd2293053bf335b56ad2dbf3c09067197cba015d88b240dbc6f9d4dc9ae9a3b24fd96f91ab106a737da1e11b864c61448382aaf4305a272b9b65295a32ec23d7a56f0d0a6abe3c2f785f34df7d6b3f02028d74ed351c912c8ccda942873d3aed15cedecdcfdd65e5ccf60f0e7cf701d50daf5ee58f145478dcfcdf908a63eccca08abbd891ad0e50d6fc08e88ba86c833629f03c2c5a0afd07a74acb87cad98ca946c1cee1213bb76c0b14e9c5e73e6cfafe0f031caa66b0f67f5e0828b9268870447f3e9d7c52bd300815751c854610b3b54a5d9361c95f9621d7269b969e8edd99990bdb62b9236ea1f37fd284b1741162d45194594c507e5961dae2d05fcc0e2a260a689f2c78eb363b69eefbfeeff15297f223a935918060768b92140289d9afefadd069b888c113fec939ab0b591f3a3796a4edea624c6f650f0fa394109f43a443e3fb42357a192088ff64608c1694cb80fbf348ea8f7d4bd0c3fd99cf9d5a00fdd37226315d496d0c80b40b5d6d312540a2471c08f0ec7f8b586cc4cd399759bb9c33e55b6765411aedf29e7f3e9e7bb5fc464b9721e1142d6d137127d71514694a05bb47ba3c7fb8a1f69617f003f5a092517daeb9df7a2aca521f4649c1a30f8c78a8c902c650cd588161ed544286fe0900ebef3143cab20351304cc0d33c784161b7cfd65bc5429db8f67e64bce63417021f02e1712de299d32c35d78ff00dcc3d1b78e47e6e913f6f5cc1df7760f48dee8a9f5b9e954e3a2d6a8c9364b12f534f40422ca0409d288a34b78f939248aaa01d4c94e45f9365df1a067522ffa09171a5e0e6255dabd16c199613fad2eb5b5864b6540997531473d9150fd5c085010ea9b2c94c539e5885fd1566d3f142490459158dc54eb11bece716df96de348f553cff1e8b245cc7993c4da1af390fab079af4a0396e45e78990b6171c14faaebd51f686cd13d86f5162b27abc9dd1111cdaa74b7a8603e62c0d5adf5fab12727c807a89a7418ba0a248cc8862746f03614a3da664b6e0d9d5ab937b6e0a4c35205dd89a8c6745dc2a52a76ea8c9a0cdbea50b55c0c3d8f5df553bc0712fbfab28855bf977f6fae433b20806dccd1715bfd3cf2091491c8d2a8375db0a0b85db63fc9b715258444d8e4c62dfef54459bc84a79ed053265cb062b42e24067465dd81c4d93ed5853abac99a7cf7d386840c71d885bf9c7a66b27cc9e48e50da3a05c276cdbb6eac26cfc4b471ba4613832e522592c2842d1c4c98a2852d8da2625041e88deaa5cf7691dcc96b76a7039cf6ceb26a0e6a0075ff35d4f975f5b875611e81cf95c2d78902c20e586619f7430ae8b5df329c9475080fcc902a26997ad5a2b44c25fbad2dfaf41c472b61c5adc2c9b5b7b56301dfd3c71fce74f5979c174760da491176098ae8849cc472949ad6952b73932512667b95daf5ef0a4aec67ea8bf77fd55a715b2d3c4201b207d7c3fb70d2c5303cb17db58ca800d53045e54bbf651caec1ae02915bbbd0500bdaf1977ca7c7486f1d4b1d5f7fcd485e384873978f3a92fe689d4ba10b1aae1ed064f9fe9b972ab27c1a3bc5b2f78fe1a48f708a672108fdd68bdb2d3dd52a8fcdd1155b8238d6bfe5c8303ef8c6ea36cf85f36537738439ef3af12a23083fab68e5bffb00c8fd501aaa9fc63fa6cf5010c5b81f822790a73cd61d4552fd25eee8b7a2ff44544a160781bab9ab6ce177c06d71995c3bd51e4e1558fcc22a689a49f1a84cdcb0378a864f09e9d6f08914ba485298a5431c543e5a45a514151e06ee788e0d70665080ac67b5af2d06a2e3365119bef29c1034b171a3c2d91b13f5dec784932ff2a6b5e4d698d4f0c8ec04a7d0a02da7d6d84ce158deb53a19c8e47bc51ee5ac37d920edc314c2d640b1fa54c33f089435faab3bbd7beee766e6cb8b8a85329ae14649516015a559f05377fc9eaba2497bf12162d1e7ee07ec8eb4e51f5a5a7d7f62d947a5ba44bc0c9a4fcd63357fba8b441e5105a3f85f056d9f600c48e3ad47cd6bb2ae5bb097baa2d7cabc938e6e25befa1db68b980fab0e3a640e911a0c02ecc2c62372f8db64dc256cdde21de61ca555b9e05de9f79fde6ebfedf93d515f729dcffc8e7e21ca049136f9bbee8a2bf6627647c4900c457a934e94e9db08aec0208dec2768e56ddccf0e1e83897c0e6f82bb4d993c806158fc39da941ab1617eba283771b24a7066eb94e5ec5316dcd6f08a54ec7143a9f64371bd2c1ae7bcd9fa2da2d0d26e9753dd287edc32aeb9b6a3c05658c44940fe527b4fd87e7ed24f93921b35f26747d9780fadf767d086ce73b6fb8780b3a174f98756ada76ae00aec13e47c34f00b4efccb3100c22895e453968d14039fedec773523d86cd59db9eac04847583573e3974b430679749833892f02f50b641086c63e1a51ce93be6438b6e3fea5209052636f3fc8c715fc285c49264b517ee14501fdbaeeb0718f8d5eb839ac22b507c2fdfe0b583dceb6cb6a44b23ac37219137709497ed17dfec12b8ffa04213b333ab43e1cd18fb45b9094182c5994103f2c54ff5ecdb938977feee270f6e3ea02541a13a3d2ad693466909559372aa6ab9b36c2842bb116ccef4e67dc8c3ec8fe83222c1feb7ebbf723781f578adbaa6088273fc062f5d225cda19366c7f7df9ea4f28be5c17955b4faf04153d5d32489dfb596fb77e0954f886d66c0e75633f264d60dcbc0b1dacfe326d7c18377f9f647e2267f77782ffd17859913114f4756e551e076523e890b143f9be8e3e59ff423b61ee308831de47786646854bdc80ade1336a52c0f0f4cff824bf002a8167114d8e7898fe7606f8dc58058f03701c7ab600c63fde315b0cfa6af65d2d948ba21bcfbd916051ac69f5b8bf6cd27a61bbd04a2a99312c022a6142cdda85334365d950d83a37f65cdd7506cf9b797e0724f3439191bd9fe8eea3510cd40fded2f0edbca0985f876bc4b493515faa9163ed13412fd62f2941671e92666139d97b6ebc3046e76842658a6a3e314594f340c97c03c7b29741dd5587f93f252ffaa4707ad3c9b918121f4ddaaa7b5d1fcebeabf2391878adee83037920f01539bc863fd25a5c5238fa715b0ed6455a5f1869d5c39b6f5c94e349fba0ddab65243c8a4c029bc8c3ad91cb69e77a8adfa24ade6b64d988b69bc84e2ddabc56f6623d0fbd2251fa3d85e31da94ba400c6adbf198a9583b6813976e0d4f3f8ee46415d6a4af2885ec9931005e57a158483030b0ae462e8681f8e43479d80edc12232e911ae84a71e078809af42a1a967dc96ef7806b20972b182d73f09437796e0cdd5496273f6712a8f79af38828a1cc3df4e791397d92b758c6472b323bb1d652e67bcd9f3c5aa6e590ceef70210689c7cb18ee5a8fd02a75c1f72959633b622e02ec4ab307f009edd0a38387da57e7413294c29df232cc6c2c2bdbde076c9a4155e9405f93998c00bd8066b98c5f048c29034fd2cae06a5cbb2bc5ff81493f611626ec3c482da1e0bf9df834ba6a1997b847c775a4b256ac20bc6971378b97666251ee923a320cc9de393ed324f5bdfd6f109b88abe51c270a0df7884470e66ba847f0820a7c6012c6325b262b21e5d6d491e31d863247fbda6fc32de028299d62884dba509505580aa09c87d1beed06dda72a8154a24b69a6c3ac4dc6e20c22026a2a29a4c59f2e700d5ae9a5db2b3f26a60307937876f4573711092336222cf3599c6e74fe65f4711454713373ae94344d35f0510a68b2eccc22b46009dd2a05291edfd8b6987058b38ffcc212456ce8ace9a30f26d1df3ee37b7f06b9cb0e47479f46216576c601cab73b81bb0197273d49bcf778f221be722a3849bbbf8140304a4cfa431d8642022f56a1eea0881c9e5fe3e4b894fcffc8b37bddeca9156060c89a1252d0a9193e2e39f6de26cb97d7e42dbfc047989c9d8eb02265c30fa56f1086a8b986fe8d2714dde827efa4e2cbed325f3d2f33e365267d1205d087819bd2d054492342d0bab790b30cd1d48d0e929eb6559530509043d8e4dd9ea10474ed69cba4cc77dff0822e3ec2fff29907cc89a9f3c8757c6bc8cdea7e97dd51bae5ba42ebb0885934977dfa988dfcf32dfb6cdfa4450d4b996cdfd65607675d1bc58f1943d1af32d169c684e4ffa65c3f0bde9089b7f7ced2b14add019c903f396d6bbd210152f7c5a2edddf2caf1555d25dee0b72327d003bbe7d10281a2e10bff18eadef885db898335b4031087ef09be0e7b062425f0d610b793855302ce10442147ffab41d656d79816ce70a0d73f0574be65f3a8d370bc697c159385417d7df06c5ab664201a44f63ab0097a990f98c90c3f4b375beac6111ef80861db3c66d31a623296a9c1dffdbc1333d88faf9c3a9d971ccb3a86d7f2b96089fbd14c029e88ede042ae8c10fab644f49b5fada479029732fd166625cd39dff0dd1f5f5cc5429f67f42763bb0ecc9323be988ea0f0abb2dd87ccaed6d33e0f1cdb42138e3764466930b6735ca4be097cf804bb9239bd25f715f0a90492ead2623c1421b20d25de58ac9c052d0052096b02bb82896656d4d94c289179e00061d5842049c90a8dd2dc517741ef1de56bc83ebc2de7de8415a374af7b23b69c9433d6a586ea834bdbdf6098d3273c1eee8b9acbf5d46c868528d804c972aca5ac83f5b78feffdb01ed18240fdc8ed7070bcff60aa3a829a676d710c449555e79b5f3497b3c42c23845d7169f25260d7358f0fd3950380a8b5adce55e19fc0662cf908c90c3aae0531bddad56b3da38cfe4c6ae059452c62ffda4e4765ef6898354ef43d1f4923f136a61d391eb4829248e6cda5efd49b9c94efaaa6027c186dac4bc0a39251a9e93518dfa7e9db0f3a678e2368f022e9e34d57c7f3f68b38fc07a76ff539f9a9d9374f896e5d58cc4e851769400d8dec3389d48f1a7eb158361f10100bf63e3f1a5dbf8b65e12bd47679bf07936fcafb8c35a8992b81af6fc1a61903bee894914c591266b4dca037668d886f599d8dcc338cec13b97e05fc2dc152a462f9885749dccef3279ebd64a9d3639e30c0bbdd87a37af5d2f42469db8c41de1e33861e9b94ac6be00b209b501edc62c26a951d29ab3522e1eed9e6e3581021c1e270f27d5435aa29a01f60b95722f2bdab7182af484b6abf258ccb0d19a7a6e4c575430ccc84d278e4903bc0f64f5a4cdf26f16ab1e996f23a23a4f2f6048cb00f85078522898e6f01133bbc6035298c5f328f6243e1c1309227ac266e664578bf3bf176206372abe71664f1021d6c6f5aa35c8236c9a7751b1e2113bec8ff19d49fd5098157fce433fba14e46e88d3cb180536d6350190d7455ffc1154e859bc884d521936c1bd5c646a738b8cb76a2edb5ef0ae6e5091f4fe696f4f65cbf3b198186a794e55f3a584b9a8af7f8cfabc438b29dd824c471de9a1c6b67cbd626dcf749a01e27dcad0afa841f880b15c09192f411b45ac6b83c74b51ce58e41e71881c324a5c6478014a74c6804b8a959f362e6fd280d62a637c92059283490b9da0cc6a4006413cd728edf0c12c7165882874bfcd0fbedb80cd134612343b86396e49e7263f040af8060ff46c9d62f90fb07f65956a8f276e2241200dfa1d0cf1db7fea99608ac0552b960fcdce5da8a16631e0b836726170f43ddd8040a006f7ebc619c48ebbcc7dadc9129c28105e73554e006f913c819630e36b353a67ea703b42621c2e64ba67235315b5cd52316aa419f6c5021de8ea376daa4b3a0281cb05fa186b260ed03ada60f9dad0e8fbb2375f67b401ca1418bd0d7e53880266cf7a7f64c3f8bbcacfe90864a038c5219014d839d5191316aeb1a011ba2ec8457fdee205c621431e4386c90e6f04e92e7613af34cec99f4c8e02bbec8ef0e2c9ad5ed336f79fea0293bb9ecf36486e6f0debc31d1961c59b3b86df4cd0ba2620eacb74be14b9c4b8fedba5fb18cf77bf92c06b1fe8eada2f169e927d882546519d9eb2bafa6ea413db70f70e5642dffc26a09eb8c0066c2b880ba2ea46df11985c7bcdfd8b31958df85bac78ba601039fce8026351d25f43d351bd86475803923985cc2e0814971149e696b30b344faa26667d06e9a8cf7b8ffa1650a6a28775b7fc3e9ee4a0425ae3f699e7991ce3a90e202670f3e31678ea907f1bdd52985fcd531c747d1b20dba9f790484ce915a566127c01d8c8ecc0778c081c9abe71c70651be97286fc09a1625d19e3f2e12446f01acf533ce575418e06045db9f95cb6df9fc48785084e17ba536b3b7c9b81e0b2c603d7dc789feaaff5a4718243f23e0fe2b7622eb71eb59039ddeb9a3b401aed467ab4796b131a61eade33a50933f06e834968ff8170639c8750e458a896ef7921e0b5e41248f104c77de9376a8df30788d8800e43acebdeff2b66a699dd47bb622b38049b33534c2cd33cbca234c2ca2ced5e31614a7edb6db8a2738bf8e091db179c59249aa142d3ccaa6b28dbea1c579ad567caf911d5c94a468700afce227b2f82dfdf609f16eabbf155cf0ae07e02424386c45b4d1720ee2da7b185ec2f2f8de3d536b379ce607b32c3a811e6cb9a109fce324e61ba3bb9ae00388d0025a91f7458237dd88f2c95860bfeea8415e5bb112ba10a9c1b2928600070e93fa0eea092490e82973ee7c1bd5871e07f2bb166eb4a59c127da744a7e2e0326d4bdcf7d5a0d92271070a54786a86af3793dbc26ec482e9d324f2e3606312b0b293a5ce29947b4434d8dd8224964b4be316d1ecd1c7c897719e7464dc86844f5c79a73e836230ab9edee6202456abc0b48f7204ab2edde8a2a568e3cf2ed95ff69b2f93977a59b1d49d10b4623affdce6277759dd943bf2227f93426c5fcd41f52cbafc93d02ec2e78efcf5de3b0c91f6b19660d50b20fba0131eb601ea324525b18e56a3a00dd770a9752bf9d334f4588942129f644c25d9ee0306bb97a3061d01f69d15b637c7f53077ac782c604c020bde0b8f77346eaf5d4aac88adfc1cb93e6fc25caa5340cd66b53c943ca8a991b39a880103792092293ba435aec38ea5f4ede9e53218a4757ce153998b6a10d3126de03e76b03eb007cbaf67e25692c881fe9144773270f328e0905c2bc999c4f954fb7d810deffb4856985dcaa95271259b0fc053028578ac20405fe8f2a6b9f922b607337aa2ef8e29e6992d368d1d493399207fac676439fa8cf7129af9966b10f35b8f36b3ae9d628bfbbe8316712208c6a588ac005745fe8d793194ce9aa126d2657d221b61336b67bf39d008c1f302c2c6a01db87bb610d85cce714a84f575f0df2f68a1c29fc822a3a308cb9cfd149079161cf4e5e1f849bbe073679a8a155799510567ebfd23e5f070ee4fb7861044594f611dfc865ae1b1a23d685c2e840b9acddc94109e0a04b96078048568f6a9815376e4b93c511db5927a8b2d4bd605986556ac69b6ddb8920bfe71e78eb2823ef6de97b664d21ff35dde48eee523d1cb25609cb528707b332cb8dabe833cecb7109a191264665b37165569115adaaf92890ea4e79103d3e5003a24938d397106ed49dc0734a55fbfe9a85f9d9af8a300f391ce52566b7360dbb0fcf6e09cf54a6c7e2323183804b3d62c984ce74d059d8ca50d38bd9e9ff6d0347b9ccfde23dbf936bcadb4468e46437926e764531cf3cbdf15c85a82382b667c3dcb300524135782ee6ce5e0c8cf9acef514956323df491d5019625de9ec5a9ddda7aaf28a8a4c3296e16d5911ce3ba27612093985978177fd28303fe07db111e0663746044983a98d9663a6e73b4df02eb5200c504eed9a2bdb7c02cea40eafa14728f0ea4a1260b059cbf24356fb95fbe25c5616a65f3a95aacd1bf166b2ac2ee570cee2618e74e7e2424dd70fd2cdf95b32bc75307b51da3e9f25089270b2ea6b323fedf40cde943c5fcc1e7ed12c8eba581ddccdcb4a3399a32ce1b60cbb056799714295e0d63f7611149a93bee6c5935b8929f99f508e40cde1cbe9b19d3fb0ca4f7668003b967be75fa82c9c0c09ace17549ecbe6657d18b305a3c02b72f91836465d10ec7849ea420079bd69be79499a78f0695b99fbb68788d27f40d95713767505657e7353888ce36681193d6844ffcaf912c117bb219a5c33a30885e1b29c68a846c97bb592580d40bcf85d9b8fdaa2185586c0fbf2ce3c6889000e7d4b9f32e7dfcfa464769d02f6b0d12bb651bb786720eb056eb5cc4230fbcd68ba6fe9d6bb1f2a3233babadb258403454c90a39c5c5e32a583820cf4fc6a32e05bf800fb9c2655fee9bf34f912d7bb2a4dc5c28933f18ee608eb43e5586e82edd10719a64a9911728aa1208051c9b32d77c21cf8f3dcef316027e32e8931b9ea6b0d6404955b8fa64b6d585e35995f3e4e65173c456ed111f21eeb09d383d9c441f646e68bcb0257aa781d87ae6ce5bf641043a6e6301d1c0c0a327b0a1ed5cf48bcba4adb6571251849fe2ebe12aa64075daa3884f111eb671cb3666f719353bff0ffc3cae35761515883f78ee2dc206cea54f46cbb04a19cbfc7317a9658fa2211eb4e765d34a94775c1e05f6d7b5e41c7b58cae679c7d796f0cc9cade4fd7618e197f6c86b35a5b986b0e2508eabd542b1c3b3313417b2dd6d90c7c03f78078f98b459acacdabe3ae3c8e997485e8e6ac0416787c7bf15ac145372c3f78d5359cf1e14ab368f873761e32a5be3e0202a5656ba748d9a0c8d4f25620de5e61e91c0a1e00c914ee21211e8f5663ffe60db2f67da77321780cdc53d47a1e5b00ddd5293f4a35ba1c60bcdc1eab81a570836c62425a79a7429ba69533ea1c51ef138c093438c3dc70b731241065991e6eebb0880150794a95a11e8dc02569136df4798cf21ff54fc0dc6cd3b2d5ae30740b630faa8af918c82272eddd6cb85389131021c89d17d37eadb61fa5e2f386ecd0798ad7a7d0852e4d3d842d5b79d89a100e2ee3fcf1fc3e7416959df8b575efe7dda3846753a5d18780c000ed976cf73353339acfbe51fe7a7c16074566eee9f078fcfc00d75ea6952b127b6332fd3f43dcdb87d8f9c7151f1d607a9bfa0f56c15220519abe55d19f5ddc286713a2c5a6487b46f5893fd6567852572bea945c02c26157789c82caead7c84ae1a3418ce60fc334c9ad15602262d60fe3cf4f2fdf47f740b00d23f9e4748965641608301ef2afc965f072e698b31535c52a4c8bc0bb6cb7eaeaa69606770b5a3a64ff7d1772e5de1eec83a5feeecaadbfaed3c40790114277264669f95b0e2af7e60647aff0f084071fbd389b9a94d3b646348dd4498107ad2fb18958722","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
