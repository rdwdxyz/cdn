<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"882bae96d4a198714095fd2dade86d5b8ef141dbb1f0ccc609d41fc72fc8f1a6df73e112e3a9cef6f21df1276329ff8fe1c262c21374c11cdc070d8d8c4ce2a89c4ca765d7744370aa5fca55b04c385479527aae0e67d184dd6a1387a5433d2857c211e96746fc23e62250b2dff7a5e82b166509d4908d55a673cc8afde02476261acf8526e264468c5326eeacfdedfae212439e85b25e49416c869ca51867a01f995b81a7540194cf11c327cefd2a5d29289bf5864ba32dbc6de86de74000a87505e401235a0005aa3c71ad037ef453e83dc4f84b54f34a8b98ba71bcec0f85b50e4a5ef7f49e225707c9a6e36ca5c91dbf5becb9a97620d6bb4957fc3b7446d6d94fa30d616ea4ef0afb7d8dc969c948a0bedd019400f575e9759a80608a4735e6cbd6c8b720451e1aba1a821ebd16d80ea220ca9f6cc2d70632fd972c43a45e5bca2f78f60238ff636af91c0163c40c5cc2803aa4348915ce4533c262afdf3f783e79f5a3e2d6e974020ceb7d2a92294e86d7f4ee003371179ac8f3e8e27dffd2f67e4d722834dafa0b8e569d36454c86024565f1d0d3148174bc39bb77e3803d2c2e664e149db5533d9486d876a7016ef5425c469b6f95ef2405f8b6552a3acc8d0b8c1899a776af01e1a92c25f9186cdd93499c23c3fc714602ffc596b41dfaf121ff579ef5f0375ee0028411547561f7e02319915e9017fbeb6572d2122e6dbf5254a3d84f0a282c28ba83f6052a5b18a3bad804be9bf7019065d95ba823e7a709db5f6e26d6844c539e6bc0706f7c14e81de680a677499b35cd80a6f7ef48a2b0acb46598d780a689356d822598b524e8fa715778bb37af6a647a783128708503bfb4c0fe373bea87fe6300babff578de2662b766fb8caf7143957d8514a3c2f08ffe2772b2a0c2c549f325323f81df467470b4e030c486691f8fbbdf85b1bb89a97ef4ae6baa5c0e2705a63824254b45648bd0752edcfbdb16bee3eeb6baf45a6251aef39cab6b1bf5ade84d5d874aaf015847ab8341ddcfa84d3087b885d5ad0a441b6074ae10b529ad9e3a800c854f724ac580518afecb28b555818c38b9b424bc0462f92d79d77ff97c5114c91ad27a33675e8375e1fa20784817d6f552900d248d254e0b52b1302be018a4de7f2fd68cb00af8fbc636e0110eda42cbbe5e240375ef97db2c4bb71804c0d4f40aad78129047dee7648c9ca71600ae6f5707e81889d4a1ce0facbf72636f0f2df24625ec698fcac830f9816fa22c1660eead4b1ef22b6af781f632407de4643855a25a51940ee77632b35913c7f75e193b8b8d5de335b9b5b6ccaea6c274dcac98b0f5ee193ea7f5c3eeebf8afc717bf2df0e8747976560d86012e42119374235bf8b1cd72e827052c91e6243f9bee680582c6a1fa357668e2db7ac3fa25c5d4ab029e94ec915d52c7f8e223d1543bbee8a47500d662ae46c4bf224245115e5c176ca50607a30b25a2557d736c579c46e75395773617caf1231b18233ed98cc6f9bece69e64d2480f0366468a2420ab00a5a9c1cca60bf9837cac80a896b3bc0569408499851438cdc5fe5b338c1866d359ea8b087dca51caa55b0f42da2fdd3f2c59794a290c160fae6c9298fb1d4e2ed93a6c6ddfd71f00912264c1773961c7805cc1ac4e85b3bd2a6ed4f34fa88f848c25914eadb5e7e0bc8e60b597bb0d780eb1f0b2a35f2036892e3c09be047747c3c2c3cb4778b9485b0ca92c637a6f79da26459efbdc53e08e66b690ba2428aaf5718e169ebdd20798730425c559e8c54232ba01cefd0d90ca3435eccebf911ca09bf69a145879d81f341eaeef7d44844b59eeedbe0920088ee815c1e2651e823402af90a4fc6ff715a5d7bbfff4ad54cce659db21933c24acab911b6ec90421a68a46edc05a5a1f33d8b25cdae682a4180e7ea47b606bb21f9c226935fecc36abe4728e1789478963552f7a48f7ed13207482255678e253e7f04ddc295a27b80bf05f9340fb517ae65c9a0849edc3fd7abf2989115fce1a5b756988db22be52d505740dadddc6274815bd50c39a35b258773532d6e6f2f4839c2ac453db5d9d472a4a187f13bb970a58d0424e30cbe8ae450195c98b38b3f723b5224d3a7b2341e55bf6f822c13670996c717ba8595829e5ecf8554ecf9f4b77b6d0dda4db0645adc8a58acb9d641318945f302c8fa7c7cd514b14ac0dd730563400d8e751e349677710d3a84aa3fb273d117025c041019b9444695373dbc2e29cb7b02e26a5e934d4fe8f5db49a8be2b17d561b6398a7f9977dc5e07fff9002238f21de2c3eedac4d6526dfeaec49663e259bb7f3ee1d4d4379a8ce88409d07ff458c0c58146754b04cac33274ac51417d5ed259a1e01a2fe48dafe3c4261e85370f31e35b30c2bb459ba582f668a5afb42b38316c214494e4235ba0a6c4b309fb4fadc52e948af3647837461a057b387cca56399ef15f5f1dda5c1a508ffa21a67197b14df94ae75dc6d2c20f0d0d1740c4716b3ce3cc8b5e4e97b8b5748901c65d72a8384dd364eb636e928879dc8796b473818fb8cc56a92497af8a66ddaa3aadbb9bb8575ef0def839a5a211a41d2ab1abc33e651b3c6ec0b7259896a6be96cbd8a18ce88c35842fc2d0b10160b4c1195cde7ed014e97f4f9627622469900a3d6075cba9770bb120e64c842ed22e3430e7e4c5cff6a05cff4d3e57aa3b98625228fa59d82e7b52a7660ec74260bc6c27b0a19f74277ec9e04fa7bb4ffb0c14d0fe8f08431c15401efa103f8faaac90b1c040deb1efff58a2201089b72afabcb3e8653398d3a187fcd17a807fa53735082f463d03a6539c96895344aff5ab339a1574669f331f5b3f46d14402faf36d1a11b02f5228a57dfec96e640c2813aea1cef0e24c3b70519e3756d571b1d648a1f0447d83db8724f12c97945e858cab1552844ccf02d471d2872aa19248de2738f7d0727c2e90c16ec48b041619767d47d356bc7f6ba08a569984ddafde7f2fdce8a49317045f2a06826b424eb3842502c22446e34aae79d9831e880bf74b3271f4d3c2a1f6653fa59e64da8a3f2d26317cac51eaf49918b97ba03c06c6134908d666c777362cb8b422c05eac1ba2044b1d27177f8bb3851c72cf4d2a59f2032ee83bd3d08e74e828f47e527bbde9bc19d02f7de69cd3c17034ef62ecea01c857b5aab1a60fa38cdf31e80bb670a5c1185b7195d1697fffdc59b0c9ac46e8804dc72c40752c5e0514d207d5c566be0fcee32a5ab69ec867001a23d5aaaf180faf1817f877d76de996ba4f28754c6eca34c56961f13ca522bdb5929594486a08283928d382c2d0662410bfb3b7362492b98b6e8146fc34727709f82a6c2ca8b6ffce08a6b70ce9892d4de9bcf78eeb8dd2222267cf2c09267526d6a746b42d36da1d20b8e92a071d449c21ba19ca87f7c7f02943407d0d0d38479afbbc03565403d600c33fd1a45eb07c667b845cb910c69b62a4478a840f8b264686f3961b6e147ef8f23b18ce2ec71b95860d713cdcb8dd4af13fff9faa2ed8c9da4c54509c761b3073bc06dd9faeecf1dceac8495b97459c40650ae5b09fe6419cdf2efdd95a1f2651cf665bc0f544eb3109a38ae56d890b8495bdbd172ebc8209e9f8437967b4c72fb54e64e7e9a221d923413bfabd3480d4474a0e02dba05bb5c4aa14d40e9c7d94347b90dfc5a2449afff8f0736e9df590db655ffffcc5914d20befc13ddfa578c232d237b26f1fbcf24d8ca1d0f95c7f8834e7616864ab056bc0c8b08f606003d2dcaf5992767ff43333ce7717fb8660bb29de576ea9be3cba39abdda6fc93194acee8f285f859e98f2f7528bcfd8778a7daecb3385ebf51cd6f33b9f0e1352068e0d0b8c2796329766e51adfbe2b9b85874f052aee1a11e069877ec7791e34ed67c50f5aa5539506cea5f66ba6227789342cd3957ba8e8199a1209f8f1ebfafcaa889b2722498c1c80ce58a54f7aba54eb93d4ffcd8e04ab5fc62494f61367a4d2017a90849a92153313eb1c709c1880c219d94eaa65163fedeb10e20da82dd939ce5195deb3fd69017198515750be3b4be9d97cdded01a1feb3d378ad3e42669c327b0f398b821b4080b76290e2d427b0dbe38d0fec122d2727f464f745588f3d6cd8a777a6164d0073b0364f7746ac5f01f8f6f5faba2b97c85b55d2aaf33923fbb9fc972f074c640735cacff6952fc9a27a9e887e8293f50cffbd9285e40c076dee94d50ddf3efad367a6f194030ab39520921ec7f4805fb62f902d7d5119b5d6d04b2c98fd7adf1e8ac6ce31b3a028c6c0c30d6d1649038e7f90c41fac462c0eb9eccd07271e137aeacf25b2cd71b8580db1ef320f115ecb7a2bbdfd531f43d1544e5b43e6c42ed4ede9f53f6a1797271060e27e889026995f55c4348ea1d5723b469b22c810430834f1d4cbc8b23e2cdaf0e85dd35f16355605504a5b853d55f10f0469832c80abc7f05a511b9f48f4db48625177446344c7acaf749211d671da1af07b2c48074c2191b81ca7ab8e8589830b76e1e935e41e8dd768711a79fda7ae9dd4079895e5f011f51f3b96e78428610f1217c0152bebe08b4357cfa4f3af7588b0331151ed81990c476e68a649ec325d6653e40022dbf43e2d4de8e43640d4cc27d0053d76898b535fe856d997dea0fa18d8771fd5596a83a16a72cbbf67528934d67afe273516effc3aca3fa1c35278202b3bd18334c37508bd6c640c7949d26445851799e4dcfe25a5b47b246254e0cfeaf444223d65d347aaa1d5eeb6e01d19a9d7bfbc743917ff4591a59c4e2d230efd6d1895ac75c6e3fb6a14e01ee524caa6d22771b0c1c5ddf6a8aa58da0c4bce9ca9d27b01223810d6bf67d49f244fdc2ee8f9c91361bf103a3958237d57691beffbb0affb15799a42e46fd8621828c6db1fef21b9042dea7a5e7087eb007692dd91c5ab6f5841857efcf1f313c06ebf5ce791bf16161fd0cbf95e99493ed8c0826bc0ac37eaac4d1315a75207d35d7cb0a272505a50d497ba806f3eaefd73e1c86c2f744046bd42d5dc8e7476705602f59b8f292bad2a460bc7273a6e190246505098c7cfe6fa77a5e62fdbe438ed3145f20e67950afcb482f191c3c06e756fb5e950fa0ce039971557323847ed32b2628121aad4ac9e2d641934badd75fcb1b82167687f046ccd4397f17e799ba7dcc9e6e772ae4c6ca1929ba1e06491f4857eecd7d4dbd286d642ba1f6836f8dc96c6cf602be364f22468366baf6b23de896148de6ef41ffd1fa4746645e113a6bcd70c6ef6470ec5a8dc4d34827b8c29bb6cb7b67524099d511eb1f468cad7234fa6db7425848577d4a4662cabb50739eb65ca7f1020da8115b42db5e4e4ef5620e00e35dad4bcf8b1722dc0ffd0dff642214c70743b965cf88028db849ee87a789cc3ce622b1cb3f3c2f4e2c17c29f58bb252570b77c1fac7b8daa046b687360a5cab0db93cd2ab0c8db5506f82a98aa534dea3791a8538426ea9ee753c0eea87ea0c957434031eefce7011d0f9ed9a6aad449d3f6a75f2a5fe68d78ae0d34c230f8fda742e384918cfadbef7782841f1a079d7023ac30bf0003bbbd9e03f320eae626560d7573c4f0e18f2d0420f18ca4b7855aa1a44885724e7c4c53058f23031189700962a08cb6bbb0cfa54fd880a5761f5c42605291cb07332f9119eaeef2490d3a7414176ccd8ab70ff9243455d16e3d5db552c90683580eef4685ee919e6220076b51c503391e23e676a1cb3b9b8b4b9e1f85048344f4de9d059ec68e992481be231d69e27e2b50672874dfe295c36e88a671d79b4b8d1017af9589ff585a4bd14c9ee1f152ed9e0b5b827c9281482fcb1c46190d741913791bff4e152838238b70510e9872384af3cef9203a0dc2babd95a3b9ec685e4681316cc77c348a71d68278597a53152b84c655a2e43f292fbdd6bef05af5f8915da1da6521f0d13f5af6d6e567c62f3594741a9b936e9a3ff7accd22288b770038eb0e2b2aac2d67ace90c76979e7f44a6d2c401e67b9e9e3db56091a8a15cf289c8c3abb58a0df8612eb7da4c3792ea9b5686c1199b9c076dbde4049bcf47e5ee9f18782b0f4829500d334d99379c1e26ef1a4b434cac9eab4a77f14bbe4280c2581865c5fa654a2702ec767f4b93a1b2452405690894a75b2959c08efecb7d36152a1301fa8a5f172e8573dbd8f2e585acc34ea488022b23ba24ca79ecf7ef34b1cfe297ae3a6ec08acf53d43b0f4f2a5c27cc28ca0e96b77bc3ff6d055ff58da1d2d10b8ddc50c564df921ebc8b20380d3f44b6e98f0cace06c0355f63b77cbb5312e376f1767fe94aedd0cb1dd12fb87d063d8ca0360e42405fc4aa59e6e6762cc1d1fcfc74682aae87915c68e59c47fdbb0df37b402a6fc02670db8bfec88e04232dba3dd44d7df9898858f00927d661c424e720cb8eebfe5ad783228d280cfa3b35297ec18e7c912e179cdfdde89d65ebbf97c83897f9eb9b666cebff97bf152ffc7448d881b3b9ac19bcd1abbe1c7ad99383c68447920c872ee4fbbeffe1c1e0cfb6f88fca32bbd4959353966a032acfdc40e5865078b92123cf1e8f972c05a16da362cfa772cf07096fcbfb2b3b6f4f3e9e2de9b725e4faeb6e7ed6e1f92837df10ff8038ae8f05f4865a343e5b0b7a57d91b4f940fed5e8a895c7f3d2198b85538f329d078be1aec61a125834d243631b41756bdd9201df1e9b9219d722b68024c5e36e1b54275b6c5829577ab92b13ee96b591f2be741b3fab6a9108b36e0282e3b42b5e6070fffaff77860f997a4a790289467854b252715b7ea377c918920ff418ccce8db93b2ad7c3a842e1a389d527aea7cae11aa995eaaa638bc22d73aaf4a2bb2f1bc95448acd64571d5494446e7672b1dc605c8adb8e2ea55a3ce9cc031ffb575cc2edaa8e2965e3e53441cc8ae6bd1a60571e7f2e68fc8ac78e53e1ec5e4282bc5b5524abf3336a8686e744057fddbf86d66a0a586d152dbee397b10a636ff92400835c2ea32bc78ffe9d8afc3fad240f50c0cc6b44a2cea1a1d14654c00db556cbb7755dc52391ec12defbd2b6ea86092c26d27a753d3f1b6ca7b613caaa71be25e87d392b7b0aa2553acbbabf6fce25048062aeed4b600a4fbe2bcf5666e418e8c0efb6360b798c6f3d1e46fe0051c353567f32262a3d315c0734962edeccc363a9643d32f577cd2274645e7cea9194e83425ae0caab289fe30451e5f48d52c6e44be35c53a0f53dc419e1c0d433ab01ab362b7553532d0d13e5fd4f21c97dc0222daaeec122e403e9ad95a569c63e970ce5196a50a69f64ad259ebd0747b45cd32264ccf6411ec15d5c9e003a6707da674735fa361c6305aad0fd652005f58563d563de333e12e27678380cc1d7e71ab6a60cca9640f365a8f51561d91d76a3bc4ef53fd6513244a3fe2e25da61b68389e86be7d0f982b628b6773d68b2545dfa45eba766c743e2e7413ecb690c001f748400f5ed3e0eac8b2955fa348107cb05efeafb7d8a640a304556a7d96398427bc807eae1ff2f90b8d530c7ed97a345f045757df602a1d1ea82b5f411e72557a220b6f66fe849860b987f36e06513fce8f27069e4a80b299f0abc37271fca2c00f71cfc88d7d149d43f95f21520de4b7276f255f6e82f60187689b003faaca32bad0c1362a561ee7c6c1ed2cacaced2255cf54c6642e3b92f7d44de2167518b6e894ee49e9327cc34046c06afd25338d5c6beb44d6015b6327b5f18048413a8c363c7f5f9a0533b6a6c8ea9a3c9b795bab091e92b7cec042a1879a52d4f501d9244297becd0070bf1a401ea6ea083b514044213f1da50eb3b1398a610039d0b3c4763b9d13f76a8f87774b4bb6cc9fa2a3a5ea60d064d31490f4e630f43a1017efdbe9e004d34e078bc65d01c0dc5717c169e202d467381341171d9e2b9d5d4eb8df2409b62aadbc3884e0f189437c0334f30e9ff1569f02049bc8fbe8a40b78f92ce26d6f07006864b1cb2382fe2af2d8fd39d7d0f82257e88d5b09783130f496880562e53d2f9129284a29d019fb918b34137e907096fb9221be5166706c4ab8e35f77fa14463365edfa97248dddcc13849807c1d48020872f66c186192bab35509748a647824248b5956d3da2a4661584173d548d9372b05bfba07bcdea32f6d7557882dd927f60342385ffebeae0bdbe40fa016a93094c1fef875f8a2cf02490b04b392168e70a570fae2237d927d0d0c0d51e3e2bc8b0e8f335423c1c61e585adbf278dec464aa165560d634ee9aaac77d39069c8126bb8a8462a51d79952cc08c9f93d5433d3681bb145f8052f9a3b3160dc87c77b54a6ad5ab3154491ecf31dad93ff6ebbeef0f01f811840a9cad39db5e5fe2c7cd64ce59c558e9b85bcb4cd2f78ac98dc92fc41b0a24bd5f5ba01ceb11f1bb17e01ce7e97004168f0adf0dbfaab5b807d6b7b0645d6c8b08fb4b523334f7c853a2bcf8f76b7d55877980cbdd4997db93b026f67b3975096f9ad9bdcd57a111c7db016a7347ecc23da2d512498803dde114a59448aec2623e523a794cc0be5d2dcbc49c1078a9fda0e5c1da650d3e063bd0aabc7c0879f18ede424e1035b4ee63a79a3ab3d3c896d12c73a67ebeed3f14f7e9e5ba9f0000f4f78a15b5ece4e9c99b50c414179c72610826173017250dfe2465123c26090d49db7ed229b180f3d448386a5626e121f8c6f2ac44881c6b98833ce29cf639c1bc1e6245a30a6dce7dcf06e8d447fd9307f44feae45dd376a17c7089f420255dafa3680f017d259a0116829272128e0924b8f1cf9c03c982b9ad7180ce6af499be7b92bedbd7e6a9b67621f1256a6093de36006c4e09c3b8cce6301e137b8956df14809f9bee6e8a0839b1a1b9bb81f3bede723ba4f7ce50334b27bba621ed226480d77fd1f520ff5aa49ea293182691cae6bfd46d7002871f51d114c1691c33dffbd4e9db64fdbe7966fabede8b29c3b2f1678d6d55d0c8726c9c1821ee62b9c03fddd1d3bb3880c59b1aa0644eb6c5c619428cbc006975e1cae3cd18f13c631bf904f1323cfa0825632b179989dc303f702408a6bf4ade07e1cb5cf106e75b39d8962c1e4b0dcbe9d8757f3bb4655d5a76f4d0a6f7e571ea94ba1200e83685312939b01fea13a392283d8ed592292749eb7e5624ed99e3158df7a88c49f7faef8e31bc2c31e98a48058d08aa27333ac00b02615ae773866e836c5fcbc41756ef24531fc40f25b856ce863e98682855b3c4d8d1e9b1034eb27c85b49065f6d1a9149e7bcd76633bad14d50f90835d0e0a4b3932cdff184dc770e3eeaa9b453bdf64fcc3b8b4e99edebaf7d8dae82199957f72c92119002fd5c14a811a11dc0eb3c44124bc0afd21169a37c11ae01239c7b2d05aabd2ca6710c78c6379b260c9a35c56cc69e1d90c9704bc312f6e908647012149c313c001e2b92a85a5d36715c384ad81c86a080bcc1faa52603591393064a72054447003ea31270eb063e54458b684c06e2c626eb295789db712d735452249b5b1ee512d28dff547554e32e570185c8e828ff9066d384d370fe67565cee95141fefaf43f9874f8e6e0de4b4b9ac129dd33b26cc65224e7b0c34fde48326e89a48197d9be1d2f1d62192169396d384442e13386ea38ba6abff0cd2416e2d7bac5c6755af3d21be5c959dd31aac1c0cd5a4e325130a6cf477c77b9c111484cffcf80f605e046db615df667f74c20ff111c7f769597017096ebf7da728c3b8c9f562424eb91c543aaa263207a1307e5377c6226fe20737a19570b855374ad3e7e0a7c776a144cc0a483680f5dd73fec023b9f7534c1aa4c4957126d5bbf3c105d3f87fadaa6a41155798c911c63a558f902819ae5dcf48a5132642a4abf92b535bf96589e77119c56973adc87e481d731844e884a1e5efcd29df94d1c1584d3546184256d9f6c9307583edb273d2c8d89830ba81d24f393a399b664a8c2a59c223c0a0b62b567047c96a00ff12735b157710f7a4ce30cf567630a092988f4e5e3c1a783fb6b22645c8d164179bb761880f968543057844530851fc0a7edc4bac6942fb403747c7c067ec5d609e9b255bc969f4920ca8833fe893b7a93d95d6374a1252b5d96fa96ba2fe0f22cf9f72bd18ac5ba66d06dbec15ad4d39b727d3c75b7d9b025e1d254a687244aaf83e371bccd50786aa152a92cc99f5f43af17b19aedc75540368d8aeb5863877f83489a6314cf4e78471d0b10c5fa744604b739921f22608df382f8cbc20e5e5057137ff373f61c686334a0fbf1eb1ea3059816ddf099c2c96bc8a903b09d57da5d2eca4bf322417824243117d1d2b816fa60ae25796581476291ece4d0ceaa1a75b5be84949aca1c1c760a144a7a578157ca2b2870e08770579c1e2737df6677776599620f89c5ac73a3cf3e01eb828533113ebc9fdbd63e8770f0400ca2a2fbaa2cf53cf47586babab5f9efbc67d15ebde13155c207cbd2d53962668e94f2fb7f367d0ccea827272ca15f812d3213646bb3fb5fb245a374cc79075957ac74d7ab0b138f6f24e1ff6dc43049a3c69d31050605319123c09a31f36ebd675b83b5a5d09978e809191f338c2200f0a73f408699cee66e08b98082a57fb24461bffe7ede68115fd4fba6a14da6cf5a37c253c595ff544ec6d58614635f6b09bc533ef08cee3a14709cd7488b015ea1a043b68570d84fbfaccc031257b9c3f39d89e39f70132f8026f4f620428e38cfb6eb910438f5c65cb4fdf3984687970208e004d637f15f873957a71c3f57f45182d894a74e034c476df685e30fffc07664c408406eab49c581c7aa1724f9edd625d3cf001f3355fb3b573dcfe213038fa1274b54353021a05f0df3cf0f18c125a22937a02668bdf7cd9d7035d96b77c012ab5445424259687211b2e95e21a7945e4f872767815142abdcf959e6f152220930a14cf9e0e8eabc43cd121eec6ca8cadba56705b42feba0ab075c8190fb67bba0827ae08663037b468abb905fa7da0dab471963e4309626086ab568528d33d1e5407109d2ac5f3f4a25d39f747f9b495bda27aae7a0db8d820e640a1282835f6cbfeedc727de82573fd4523bf40cf539ace7c79b2a970eba73d64ecce84eb6cd48cefbb0713eab4ab0a960a63cbec5d4a5359438a00404ff9abf57099e3897b62bce56cb568e074c5499c3542e33248ccde3e2fb292c76f81e10ab91b2373591b18dd6071651d2811200280044fa7490adb6fc5c9c4cddce5405fc7c945ef6f0e5e9300ddb1e938fd63b43924bbe7a6ea0e763dda809d7daf468e64083983355826beaec6c4747cf749ba69f6953ad83374ddcb04cb6ec19afa995b13f210704456ccc92d2b6d9a9e6ab3918d1a8768489ebdf87f6a2538b0bf5173c4f8aa44a461e5bea35a4fe5bd072c15be1f65d8679b7cddb2c8bfeb4573acf1020277a4170c988a8360104be6d5973e10fcc4639100f1eefb3c312aeb73e84da9273b4f42a2c1fa2a53126b8adba8f489ff5867267bb4dcec491919889bba1688e9e06c87987c6db8057085fafd43f85702f18a0dd29c244bf7a19fd9867029b6f7b5517608dd937be19ee4c049c46e9c7cea416975d182cacd1998c84a43327fe0463d8d2c7131db41c7d81d2355b2ab683ea5273fc83f8f3683b8f02dab925b31fc984a6ad29284e595b85d70e9f63d5d4e44018d2e9030eab8bf65e04ee106756530e35d7d04cd5b20231cb164632357e72b8bc997fc25bbc0ddd2622e4f4248b29f0a1b9c6cbd2650afb792f3f53bf006bccfab822432faf0232fc50f3cbf7d80d9776d04716431c42e4597b92a6b45965908f7a4388a50f5b41a6a755860cd515e631dc35793e0dff3ad86b6fb86b4fb4eec9e9ac8ce194ffc6de7f0174a7af1fc2cd562fb00a5352f48384b347b50f611eeef44cec586204ee3a899c34f0a469b94b6a1d5003912b58964d7a734b98e85ff31148965a17f48a727498f1e91b3d66c4ab6a23f652668a791cc19750b1fe27fa825a797f82e9f55f71bb5f6a8b03f74aa16bb9345a2d8b164c203276fb3936582ff26c366e0e3fe33d2758102c235f1dbe14c0bec4ea367809dfce624d1f7a99fe8d645b71a4cb39443f31edf47e1b302f0bb701e31e8fee5eb73127f6a56d8bbadcdf3159477567a93d2657ce848eae3d283c2f892a6c858cc9236874e71901581533b8445e142e43ecff8a84fc944cbb9297a2fa3194bb67eee4f204dcb6a4849f2bb526c96443d6e3eb952b565628787392af63f272afa37c11910d2dd8c20d4761c9315c5b4636e8e8eca0398d911d202c4adc25caf37254ea8e2f76f2fc76a533e437255732b6b4c4c2298b3c008093e0e9a2213049ee34521805e9d7e943d94fabe89ba8743c7c73f7a6a92151da9f507a3acc8171ebd0509ab27614a1fa21605f92a382eee0f245138512918b5e0db02ea7191a6bafcf5bd6387c521fd38ad51c2db08493909c22b98874d6e5c388e37ebbd7c0b25948e450542e3609e384034051aab3739ba5bacc37ef7446c5f8922dbce6a98ebdd52bc07ea367bf1241b369fb5caed961ad2f2a32380cc3ee1fa621765f837c2b570de9e16ab64edd45bf085a0f382260625bd022219310f7873adbd7ea51ccbbdd8fb23e7c93f29760282f6b744a69df45f5f6401eb08a1d59b5d886b194f09d1921f50f98d3ffb0dd5203434e07f29c3fdc0b2a268dbdeac4feb8008807fdd0c22e74120c9376ab9f6468c258ba66e61483030dc672facfa8bc0029812f65bc6f3d5ddf742c34e43166f944fa81b91b54a933ed1e16194c34b91c19d4f76ab7ce72dfc024e34fc3db9cf59c18728984d401efa3cf391bfc2c97f77d9bd5b009ad0b72b26ac800cdcae1e5e9741b481fbc5996a53f4e6ad9d2b799c5052ac61306fa747b9bc4c0b48c1cc59631fde2eb1b5efd5307864630dde53b35125543f36fa0162e0b967300cd574f3d17abd98540948767d5aa0ae2aef4f62378077ced78400567ab1c66125b44b07bafdbb8cecf7442c53434265f5e10ec31e739e82ec97cd047e79074eaebe7f2e550cbd0d6c9845993eb0fd3d950bf5fa872a42c077a42f4e8ef586027b23cf5c383c16a830019338e64e72c964a15e55d7e33f7ef9519afc348e43c462a77bc529a4b55ced02cf28ecec445a0b5f1ce3ec9837016695762de45ff97425b2fa294395517c651bd5057f33c67b20a701d485f04edb15daed8b540b5f2d2c81ae503032382e2c280ff0bc44f639fd29cf0615411f08acbee62481f5de4c304919611e182e1d946672f5fb5c231aa522de307335939da66ceffc69710a02a89373040d088fbaef54244a97aa61f33700054b8f4026018aae9b4ca5609c30e5c3487918256cb3cd2f7a33a5b2f7169dc7214c70d1df206c535b7f8a7017224e1044baf8fc104360807ff70eab87d6d55efc1e59102594e657dbf73d183aedf35173e1cc281c7aeb102dc609ed73a01dd1fb4c49d8ca78d03314f2c7b62289785d07fcb246ad132bc8afca9b796cae3eb415904136608829cfc76a9ea1afd8a891f86b27bf4afac0af485a16cfd4285de3ee69cb797a3cc99ca1bc68c2d5a34fc0ef9a772d20858b985cb0b728a0c86cb1f0fe2e51c2f7dabbe45b18f060fdd36004e70b0e02c8a6125a33ad293e1b5c1aab882fba28fbc7fa864bbb0c0380db4609fa32877c0828ebed4dbb031b1b91549bbe061de6b786b14ae2e8dc1b5594493db560ceceb86d7c201761b56c01b474aaefb93cd478aaf0b193d409f6c586df2f41fd9fb70131079194388b9646b0bd1b971243ffbf14d5a93d836fd0056c458e29a5c18042af827e33f5bc47552f5844d553c4a7e9a353f3ff3f65fa0a6ca4b646e9d4d2c6ffb940157ecc15ea2ae98e3509fda56b1b2e8e63274a30b44e79544763f6a7aae50cb3013bb92cd5cfc7ca595c29c3a1844596a023d8de3df67c5d5fc3e0bd93f697499d5f384f5d2ba32417bf6e8672b086605c0ceb4dde6aadd0821cbaaece452d9e4249157c7430a24019836a760b3191af02b1f674c447ad09f309c98543e7be2d67f796c56c91668ec6750b727d466ad14997b2485ade5eab9c45c5bd23c053502642a7f7e178a57cfb310752c105954ca4138f4a48d3263489873d3d6eec4714a5d5067b1e9d5849c46aa2c695f3a77e6b4883bba143017b7b763a1ee05ee51a6155462cc119539ab89bc8b3ed8dc7b86d4512a0742dbd951c8634e13f113606b0f363a2182c74f720948149c4d6d93a360cf800f1b95bdb561fb5864b8bbc706735d4c717bb44571d252255e94aa48637802092b0e555a1bb48ba880b0a63ae7473e4685bafc831632e54e9c2ebc7f3704719bf57750cd9d92447a06ece6625722bcc859e4500f615174d26a9fb4c1426f2655199a2b04effc95d1301a506dd93a11d47cbbe810eb39cc1413c56ebfe7fc7475405ee5d05f43c83dd0b76e8888c3f04b827495854e96074495971b58de8d60c3104b831487f5d6ca5e11163605d7b072b846502e3cc5157e4986dca35a1b84c9d59882b74695679fc492177573650fe2efcc9ff89e5b1c887556adfd97712419095ecbc34f0e2042073dd4163305594878d50d7e62247265fabfa13015a5f6f1a49b75eda2af81a5e7b7d8b7981122be8f05279888d2ce1e8de393f69e84c68f9e423650e41410b1ac9a83e99d9aee4887dd5b75382c254b9b6cfd3b5d1e34ce8b84237ac306f512c77464b8a13b1ab104c19b5dd02d0749586299825a37c55c2a6816f7f9f0822deb5c8c0101aacedaff7d1cf097fcba7f0d97eb6c69a3b2edc2c7585ff139e8b6235a2a096dbc18b858609457cee3dd04ce2854a95cdd69d52e9bfe741fe8e4ce6df21fa37353b9edf1651f1622ab8667c628d0b5889bb490b66f3fa0c462cf8c0ad7335e0057ca77fc8025fb0b02c07fdd95e8c7e4f083ce55dab75fa3a0cb6469bd40fc77d00f463493fe91a5139fc226ab10e77f0b8e1280f6b3b36d96e41711a7367ffd16487bcc4c39256cf14efd691f82d876e3b5b0d0005b4ee4cd14187a92ad8d72bd5e3b4bc877ee825d23c350d910cd5f205381e976495f1c9c7b505621d44b9f0a0ba05d2d5ffee2090b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
