<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcf75e47a5f6488dafc2bab36627b18e4e67a8160527f13bbb01a1f3a1db2a2268c8c2774be159d2edc84ec536fec52b0d47948ea720ceb4997bbfb003aec082d7c2799968dbf2800fff3e468398b572aefe8579fa0a147c998d33394968b523f11e2913f1e6581b34c61513c715b734c3f4ce912c299eb8f79cc0e5127b45cb597cd0d66658724a91fb384b2d8572254a306439801087e64c8d5d8c44f85dc30d151305481c69f53259f70b891ed5d617d6701a04e834adfce25578322e6a90366d70e6e51de673aeb4582486f390ccd11121a44f2aa622c0137a50a672768214eae6be6fa7a34ea8710b6186d48dc26eb973e1220a7d898e0e632e526c8bc3fabb0aef6d53981eefdb05f2710a4dc3c85977a93f42cd8f6454f2434da07c599a13a1315186cdad49c4771883a5b914491eecd0d7af5696d75eed986596be1da5c7969fc58cc562dba0d8daa6d487e2a0d46561c89c75ff38eb8b14293e0164e702285f9a8b1b7324798f09e399f1504b29a4c96206d054e859de2100d3a0ef0b99be52f4d0efb3761a5ed1b8b7011cf02f80ff0c61ff0fff3f132c283f1fb217575aa44c371f58c6ff20ad4c1d44465c7c8a0569ae0a3dd95245fb22132cb84d263bc60de2b6ffdb4c1f806dc1967136a92abd6d75de8e6cde92bb5c3055a9081a49be71817402c3cb202768e7a81907432fdfec8dfa88c6799919919a8bd92bdd3802eb6eb36701e81f4df5411096e57e2c32ccf7c41667100a45ed3b80a380792502d159ef50eb2d4d55df8b2bc1724864ad2ddf1a8b9389093073f7eb29d3192e31b34524f84d2adfc1d0c2dcecbb3dccae371998008d54f625f6e24073437dd42de575c001cd76f5e6db967e364098cd0e1aed44b063480b242a2f949e66a80451d7d0c7db3860928d2b40eee704021cb02faf1229f4e4ddbac17e9d4ae9e41dd3888b71e17647c12b57c21c800b0177bf6235f5f2091f2c367fb40a4a87efb59b52456406217216aa13d3232589dd27cecf72a7479c65fcadcbdd45a4e6051970f0bd195f4f4bbf1c417408e2110a7aeb2b9e4be261f449e26b335406e040cbbe6f41415be22807cb4d665d67107e5f3454398a731cecfa5e6fbe38ee14fd64683cc2dc95003f5f642a6bfc5f862a89c3d4f2729e691276b5711b9ad91d27b42d70d6155d0359420d6bd12bbe4ebcc505502816962a14e1f5729193e8f445cd8446d6a4faaa994569f109b1e130bf0ae346738c4e0b1afa4db8961280e782e34d96652674c5474659bc2089ba263b140eb24389363a1b99c3dd2026a67d2073815588eb406250f3feba32dd5696d05bac994f0ebe7fe76785c97ce97caacc748e418a09798efa7a242e24f1ab135cc6023a4c5b685cecd7755050f27c43b67055907dbb3d28838f3d9dd72059459b46cf46330eb290a3a24c5b5af4b30911238c1bfea0216c484389121b3a71cd5da6c8c7096ef74cdcb73f2d155ad0ac17887cad15c0153b5a3efc934816e68b44f715b8edfc90e122156dcafce860ace1163ecedbad820a4a31c7ae9a778f48cbf4ee2a1d7fcd33eda0e1e9b79ac0c677fda6104059d0f5a49a9945c135746f65e3932f1fb1d2709c7811b63bce3d1d3b2eaf42498f4704ba88b232f372bbb8f18ffa8bc9f884e1ce5789a539e16fddacc3f26ddf026477bbea563575f718fc5c97d972d5f99a0603f87986322cede705d3ae9099f1f8b71db2ec9fb539f0a98009fe15e1070ee43d6bea10a1c9be7d59f4327920eeddcaee31c0c1f663d1c0f9223c59a02504b93fa7e6044be9ff4703ed71d0b4b61605e89fd32de91433bb417b9be2bec050ae48d5a78e9d9deaa43cf1abbca3665dfe99d465ffc80f828cc7a12a0294e361899e2b69491aec559ff527c1b0310a866e413806f4677b495a7ad513693cc91fd42b2a2e02c5d7cdbdf47747d01a481d87eb9568a7bde2214c2c4b6fd2580ae6483fe126d4d4cbe4dcd2e7cd0aa70c9818c9a58841b494f0468a3c84a67032f2cbfcb39b43115d37c7b33cfd0d360b648e40f22fee9fd203ba2397f069c14e9100a41b9c65a07a7d3e3492d9b2a14eaa8eabf58b2ebf09b42ca40a752e820204f7e3a48a76038ed0af88f0122ec6b780f4933211e612ca7443b8f869a2c8ad569c5eb249b8e35fc5589ec662c89b1d7d0d8a904be14441e09141fc5bde16ee2909bc690cb05caa7679421eeea6c6f15de6148567ad08cf7407162728ca50ab4c3d2cbce025701427d7c7c0d357e24aeaa28036687b12612ca2c826a47e1c229ea54a860ed6cd223d51c1c11e96cf1868f0f4170d1728e1260b19b53c86a755f483a9eba8fa1447453c822059cbe66753ff614975dae10fcdb9f7e48d7d5795c54bca376b0d77524eb5cc2081e8d3e9ac9ac05f3630fc74babc6f499262f6dd2629deef59a88e0b4e630975d279e73cd3e5c03bb66b89f0727182f0eb4c56ea472ffe471e98f0772f181935e16b3955edf66f6c0eac2b9906ec1ff72175f6145ae2dcc76b0b4a952529b476ad784268f2b1d98c4b5ab4e97a49af91a6fd8578d6998637e427de71e93808573a173ea3423875dd12259ff69135c2635e16b32f04dc8f2a93a0943b8092c8d8a2a9bdabfa0c9c9e81f2f55f62f0c1b2eb0880d609dd66c8d4f693259e3be8a234714039384c55faedd47ca4889068053cd7e77aa8ee5d2268356e3b816eaabda46f079a3fd10101fdaf0ba1216c38314341046ce3688f224f92479e01b1317f9c36cc098c2982db31f96461e900e51bbaa60b7fedfc26e5f61086e034fc41ae9770a5b5fc3d2f62c39c5afab82c23c713fe96bd729bd5f3cbdcc544b3b7b99f6ae6fa862d31f1272846fcd9c73880f0f05e284f20fc8dedf7d0cd4dd315e2a1b55d301a97a7b6b3646668b1f7a15e9fd0302aa90aec7916a2179a4023f1d5e31c6166bf8a0a754de44c61dcfeb00fc34e80dbd1c15a7e164c4a6bb05cec956e96a6487aa86897a0241013a59caea768acbd78d485d0e9c6290490dc080ba30894dad73b3c426272d97f8c73a334390521a94447f065e28a56a897e432cb00583e6637da4b8acc1e907c03af7cb7d9c08ba5c22d621a84496584951d9117de945596bd80d1015cab79be7b030e213ec944d6a86a87ba84c14a8bffbf3b7f6905f76a012ee6030689381c64a458d6d3f18729bd30e8d6e484396a1c7d6f3eaea9a60a7ef148a791cb8bd55e3ccb86d6cb4565762abc137233c520b98bbffd0ae7ba9fb7a4c8c87e805aef885e9c2752fd0deb75b7aa9c681da85693a2cf6e1d328be95ec5b40bf3816ab155954af9fe3e88a35a638b1de6021223cd02b4d34999d7893a81649b9d6d20c671b9bf187eb9b73dcba4fd9df32dd3de97a7c3bc24032830f7732dabd87dcc9efe1aa587fe5bc213fcc714ce167ddec324d3d405f09898ea28caee8ab21260475ea4035f2d8acdb81f787167672170da0b39fddbb20612e8b1a70d28c1e97ac8d91a85406afb04d71ba4543eaf28694fe108bd292b013424b0e33651c072eda3856a7fa02e6e1fe62561c97a2163c298663093b7f3fb651013ab989421ead95e4b2f23d3e64a00a6bd58b2b6875bbb195a1327bc0c1eb93d122d7d4bb045028354dcfa1d686103dee91bbdc4d8bcfae22b46000088105ea2cca14990f9729c09b681ba4f723be65129ba06c723e516e39245f9f0e357bc0be51465455d278a6ca5a42c3b2d7f89d505db6d9c476ea56fe30111df132ae64cc05735e747e4dae96d63d0feb9b682d4937ae85866799887f02bbd035631c37eb0894538786d2cce92f242ed524eafa8991c126fd6224cbaeb6fa7fda87961b05d02a1f290a9d6ab397a29254ad66d0ca6c99c564ca5373b55db11a7bccce1fe2a426b2149079d889d2fe556e65ba01ef9fb3f4dbe26d55198ab4cd8cd8be5ab0a49504763106910ca9a139e5c560191709a435d54f6f2ed34623d7335f8cf68d6253e7f555bbbc46025ef25350fc841124eab1122070f99205cb267cea10cba34044d86642767fb8e37ab4069f553d676df4fa97cd7856ce3469b99da5410f14bd25f4a5f0dcca9c34353ec2274d843ff37bf227ba7dd46196f865f750150e82c910846e6b67a5fa6afeb2b6c03d6a98afbe6da2c760a3eb7fb8db663732a6ed7568461a65d31ef68e921030f6edbcc344122f96401ca2cb3da4efaca60be53e5d14a4b23ba5b1005a17f1b6db3ab61c453a5eaedf2c9dbd224091c97daa26ec8a6414f18a08f2e4cdf942656c7b473337183fa82ca2a801ec9b4b0a7865697b04b0c58f8047f2b41e70d9df927425eacce862dd2450a46dbc31d3c65f9f2935c986372c8782e6c17e1a745d1c91d9600fe8911f5bc84752cb0d7c6789d2378265c2687133eb2b7180c3c92f0eded84b02f6af724369d2152f6e4a5339155b2c4995d12c74ba3036f42f2fbb8a5083a9936e17a1e0b28a70e0246e66ee615c29bd10a76148363eb1681a8c81731bee4ddc3a4e4986d970b650131795f41f2cf0805b75e632e08d2415342d6bc8090bf2201047c24138aed8520bc557e0f2698637a46696217d704cd568d9d01f6fb7a288a52e97b677517e60c8952f2c35f5e94a161be29f579432a6d0e43ce087afc21edec1765af3ee7825eb306d109fd4ca3fe440b5f5b0b321d3ebe65cbd7cccbcb4eeca674a53639bfbb4e96b10961c8cb940f8ddf121a0436ede32e95ab3873288a1c2c20d4999e5581414f9b8e6cdd613705ede906d7205d2916a75784f62febebd044f54d9b7c0d90cd780a41168b846d8075319e0e1cbc780225eac6d02d51c3b258faa9a4c0ddad39531f3a55999d6bfc18d6d98ef7eb072068a488015931f7e2819871c6c738d2136372cac4974f6b4512eea69fc369d3dbd03b7782d21a1ac5788dbe64854f0d195589c70663e3297c4b1b41465dff8b86a2a4e72a154b08a228e8e143fd3da2c7cd3c1577d358c8f19d1b94a9a54462972108ce5189963ec6dcd9a250be2b1b569c02770100e77da1fa387f57f0932efc7f1c2a69d08af129c22f203b8f1656fd4ebd6a0e9df6656970118b071420bf7187994c310871804da745374dcd0383d9cc9504c8f8122fd98be12f2f219cb1a47a56bec82c58b1bfe153919940c197b1e219bfc683d2c313e79d0768edb91f3b2981ac418134f4478e23a1041c15a592d2575dc9b30194492b060f40f7bcd5afae0dcf22947dd1a06df78553c370f58cb672e4e8946ba011bd5e60bdb286039bd8578f782fc4a32134bd12f77a2f25f7de56be6bd5a79cfadf1885692d24003c930cb5322d804cbf39066a339d2d8d87132ce4fb77628656477f138fa3d1c97d6bbbb8ff971166ef4b78bdc8ce92a103b81283dc0d15617de971350195b21cdad2ab5ba1b622b2aabddf1d3a9687e13b05884d937fc00c351b9c86d240d9e9c92a701c18acfe9f0dd2b4c923dc31acec0f4c04c8ff6a17649fb46b7b3b2397299aaf9193921cce9705397c6386877c72962f8cf49301c1c5c092a63a5afdd268f982f96bb40dfb07d7c619e240c3449bec2162fe9ea1f9c94d5f3521e05001e07924b9f5f122cbba2fa5b282792df3bbb52edce388fe6d1351d26193a9f5302cc0d06dd34abb123efc6a82f95154188f65a4974400dcae164843902f08e8405f3f080099021ca60b262ae5a998f8159710bd57664d2166a37678ca7b25d1aa924c7eddfa337172341e48b1f1fa09738d47ed8b9d333794080f7282def3c86f18430c3871fd223a8835eb00b72309bf8aa1d55ba6eb3a15e1d7564bb90c5268ed58b326b38ba36e7f5b0301c3a6eaf5c1f680a1b71827e19ed926970d9bbf466a86cad2026121f2a61d7d68ff6e01c5ed19deacd83c4d009278043c5c6e7d535b7a00b27388ff63b64eadcf3a2c50a0c69b10e503ffa40fc82ebbdfd44d640855cb76c8f99ae54b859d273725e184921f3e88b2c807f1cb5e3889e833f1a9e96a0c9fc427637b3379fa4cb9d7beb372188854a17cf3b16afc6d3b1b8cbc63c3b6906e4a9b01e1066c961212bfb416a4b74f77b47d5c58dacc1192470d1ffc7204088a58f4bb8bd44e3b3b8e26eb0d4a9b4771fd6328947a3914a02b22adcdb38e49869e12356c676789e56d6b1d865da7da5fb12e8749f25ae406d29d625d1833eb5a445765e73ea3628c4f98263147005e2cb6918b2bfd6520660c13ce4c2c0ae8cda983028b8452de9a9200e0ff46b430513926ac201472386cb21dcbc879e4671df018dddc941d7d065a0c9310ea47606b133147a2e52f8f2537a82f4e4bf8c4edc1946477dc92b7b786e805b96dedbce08f65ebae5dc4cedd9ef55240158726cb22a69ca9f6248c7ce3b2604774c3e6cdca52ff91ed5e747df89086d37915b94bd3b5f02ec625aebd7718a38af41939b4a9df510f917b364c3a24e82d999972fa95f9d43f87b75450f600928e5d9b56fbd2fe532edaa03032bc71997a07f2101b39c451308a7d932d4ea1ace8778c5e0bc4d06b43e3490e3453d20e401c0ab9fc9a7f83c57e83a5438eb0109c8059e6d8c05c8cafb725ca42e7fb2e7a685e78dd47b5aa8ee82a6ee6cd56b097934bf1ec91eb7b7ea2f2817b09a8516294bf2d77f96583928327d7845b82dbdba30d307456a62b607bb9653cabf74ba0c13ca3ef86e38baef2dea3b4f689a595c63be663e761f08595e2d37e2db87861ec8b9cf190ad9e041a9e875ca4e1bc654f22e93b726cce59e02f18b0f539b572a2081517e600a7cf60becd20a894ffd5ba71d84de2ef5e6964843f987691a512b6a927367b04340a4942b9741906bbd47c03cdcc7575626f54ae8ad91574af0588004da7b3855f3fa77a13aa9380b48ab91f825a0ac5ac80364475db35e5cb2ac4a68fdb9789089079a75e9f8e7e9e037e84768d3cabb181c6d7d7eb8b4cd6c20607ffe552ad24197f84cef810d17763e8dd71c97dd7d0193616c3f67e48169db4bda6d8e67a9099f188c766feb9e94864939e526ede091af395dfff59cdaaecf248aacddc9b9fe7bf3e0490a2220a77f0d922c1325d010f8badf09fbd4b3df24c9854c5b3bab9ee8424e13deefdde04f8d38ecbc0773e8451ca0c14bd8511f79fe57ed8a02c758192fa0dde3feaf0b044850c68141c6ec0edc4a3f7f39453750b748562aa5594d4558f99f6af6089947e74aa05183701e69e6040f5aa107222ad3851f6555ade894f503c8f059bb95c64bb4deb5f5fc32fa2d9cb3f57e4780b238a6ae04f24537531a648373a781e04a7ffff2f9b01fdbde596cb40907221f05d6a01b5c5cf3f677af3675043455d8afae3b6f6548426af3428110aa8eb053c48621170a97e2c6eb5667c1c6b0e0986682f5b80e5e70dea3dcde72d45ebc4bfa29174ff61bf24d4797533b169781c696280baf2527b14ffbb711aa40a1b177fad8503686d7cbf96759ea7ef04b07e3c1ec4c7ee292fb3ef9815f750311b4064b5f0170c6b29184a718280f5582441238e2f7dcbc97c8a128dfce661a868a780afa3a64cc57079e1c3fc8253de9f7d75f99e3a8d342fc851d58134eb6b3589da1bf453700ec2f306c706dc12a9ff7cb7305e9ad917a53edf5c17df7f48f076af94124f92de12aecfda8d87a15f5679b184f0a64148cda1af4d8a48801fbf0f43e9a986e22395fa23f31c880ee55533a2ee70e4c70c0a77f86211d635002e742340fc8c3a46eb5fd1f76d2c2e4e1ec4d79ff5aad8fefd7ba8aae39585841709e92ca73a7f429556259d6130ddac1e8a442d8440fb2588bb9fc343bc665a69a967a6e68291cdce8369a60f8be6e364c783c02c16c7835bf620ae133afafa87d1cb8351f88c0687636174bf5b25481dfe30c6de60e2574d173fc01f5727a605528b25ecdb4b894cd3de1832b98b13c4b9c6bdba877f651dbffb56eee2768fd26e968392ae3f8742d32688c74b8fc974af82f46db493c0891a3648ab4c3d645875ffd2f9b319f74b744544accab7e852bcf2505569d5865be84c974d224aa12cfe0235dcfc4fd04cdd6461d83edccb0c61435a726d0b1bcf9a5b1af7288945780257ff4b7e2a7dda2d8b2c79867e4b534faf80c1a0c1c0fe421d72f3d0513d09a2ea58d4f6f43a404639615baf2a8beda6b8d4f9b6513dd299526ae8e1856a04c54a700d02e2b8a45bda3a2773400d888dd55244f27282d8798b0d2603325d0f114d2b77a3586021bac799cd80f6a070f256449867e6b32ccc297bfd2dfbf6dc272a6e94949057873432d1ee62980203eb6d69b2b4a6b888782b75aebbdcb098dfd1afc782157101e91aebbf68ac5b83e13a24f3f6b2f261962add8c8e03db68ffa7e8bdefdd16bb24a081de11c08887fbd19de4c3cd31e68be8ccafd6ba4a0f083a5deca014f6823c9b9272b5f0ba0d4a33a5e3ce6cf91017133287849668e2375add6580284ace9042407d176a85aaad235a56a3c091f5afb356e70eec4eb437e23aa7310a1f8d3817495fea54b91eb37a6233c13ee00866e5fdae06b5877d6359e8c6020d5ee2386a9d54d08823a18fd189fddab30f61ba2927d086d74e482734fb0d029122a3a31a03714d4b12115edf5852896bd18cd11671de46e37bf1264f78ac8eb346f4ca94e654b166c71c9c8d63ee479e7311d3e8f222af31e149c94eca605435ad9762265a7ecbadcc38c19a990465ae209f2357438a103e93294b5673beaf7afa8830ef57e9c3e481852290f420b69b6562315d5f4ba23c27b2c0d0f7664fbbc70ab4a49a74e1f9dfa356f39b3cb816fd4643c10057df42ce72904b10a6be897d9cb46b469c7517e41d1626da87e40a6501897ecd6c5f4ef5cb8bd83eacc9cac20ad135fc0de3a5c8b42f3c89157aa83eb6a7493b0beef1651f21370ef80881df212d417fe9c1590443405d51886e4a9f5c48c77f21c0d64880409c8d8c00a21d29073f9b00e9290aaab6914d51235873d3dd22849914eb4a8ea9f89f496b6eb18bb2cdf6e75378aed7319ddf8cc95e6faa438662908a7204e2926ca36dc6c8745ed695ec532213576abb5eb8cc9970894c92429c14b77b684eb7d5e14d156d9b097ec5221802e0fc075781a9350b9ddb605dbc916a9c2a0f4482a838756ed278ebf178742b14eb4b5ede48d701567b8fae442238685f10b645b0712454bb14a908031f51c5080ce68e3d85b7fd88db7d4f0f14fe3e77ce5fb9ff5502fa497aeec8ccd090e79331847c7cb124bc086c2f504121d0be0885fbaab86f7c6a86252aab3125127a3f4328b34226e7203db5c5c799a62464e8784e25865889100b7e2eed9d51b9fb5d9f5f5183b0a846ab18f1fd534f8ee0d2abdcadbd33fa85fc469a6259156be8957f962b7768904f41749555e120686353fe128730a0ce5cba9f84f34016896794035bc32f7376385e684cc95a3d715bcd52d50c2808fbf7c9eb1cc8e2a4d9e9fb4f1ef64f62b14b993a407eebecac209ee7e2c98d99e11c0baf08e53fad709fea17442b638779f2b4dd7e015f7c8d81672489270670969b513f49bf963e3672da8991d46cfc226e023e2eca3343a3af3ea658502c6c6a9aa4fa41e597e50146530cdb58b4e5446716ce29be182937c6d01d484b1d74d2efc9e538e5da46a9b4cfde8169b70666870923a842452fa55137321604ca830ed53276e3d24ff6cc28adcde0936dc6990fd3d76735a9ade4fb16995adf2af856c6d4520d0f44756ce87a5da036a55d39322c7b99c80cb3279dbf60eb3e1b0c898d68c4e4d8491512b78608ae794c56a2efb1eee2706bf8468db6c2ad78e717c6b9d09cb89f0b3f48bdfbb3537815a5f7ffc45970f94eb034ee0667e8fc847b891ab489c11df67acdff8050d4433fd9e583316506e4280e9125db4eef1447fc3f4ceddbca002706dfbc74a8ca5dafb121145cc5b47a65ac12edda016e4fd4c98e638f7706be494910df1006bdd1150362013bfb535007831ccf16ea8c6cf883b0ebf7ac08ec93a523e51dbcdfb570eba97671fb0a014611e096c9a3c80af0bc8a1dd4e8a61575d8becafca58c7e13f650e9a6d2d6ca5d2760a6b60c7317d91950e3323bd505d4b39f28ced9482cf72b494efa03588c1749933227c764fa12a10a3e14d6573019c28ca02b6a214dede76dfcc8a98e20319d4b4e03aea751a1773e442eb34e7104fd278aad988118afb7b62aaae917d0ece8113029c06494d44c9f4281648e8150b90f9f78fdac95f726b9253b9dc2caf6f9e36b797112b843c275e689b185dc46432f94f32b42d69b408a3c38a1cb4378ffbf892709f15d1336e99afa774038a447ccda0777110f4ff82d82762bf8d4c8ae4d9282c39b0120775fc928287c9ff7b86e711a97f615b27969b156353de67ef097c3a7509cfc05bab88ddb2783d5106a3e264e5bc66e3e399bc0ba306fd7f7397ccda2fb2570a7ce22a4aabe798b2db1b59d96aee193db1997f04340d6cc815543c1a10ca886471975e5a17150b4d4d31b6a5fd70a811be0727251a69b45550f678b6b0603437dfcffae504495f349fd3c1fc2d0817b22f7dc91a517201eeb2f0c08f340a8acba75ddfa739d56e892770fb65c88402df93782e9cfdb0530a675b0c7242985a85ddf6d8fa3253bb25d664bb47111eb04c6b4d5e407063e0a0722eea65980a52c9d0d61c8f9d8216ad2a0a507c0fd5cf370832513a349c662770c339b99c3d0a6f51100715df47034a72d7acac838e54a77124497dd81b63aa2fe7357298940acbbda0383e2b612cd5300476cd0e104047119df10c05bd331c848ebeb4ade1469cd95b9d6ca37d654026869905553336909098a15fbe5ea8480d518cc87d1693af89778ce43994536f73f759fdd3d6b15644f3daa8d4c2ffc86d5358121b459a0afe90243bc94df9eb0108b3145f2bf5510d3b85138b2660d2bb27ee3b74606f05b34bec4438811b70f315127748a89c59692051666e01b3b4520b0a31830c971297e276509b3a54b8febd3267fb4a8a0d7a720aafd52c9e338bcba14945e467b97322ce0ebd8c06bf8f43a10b80d7bc8d7d320cbc4be2c588930fa4ae61277a832b0158b3c8b386ad54375de9e9586183d52dc71f5c8218cfb4b69898a67c26ca4329ff297ea58f81ccdba11ece3f4bc22608d9a6299b8fd29f6d9e9f75cc9d5c4d29b10ddc9fd98c212981b5ae7376f2de9508fc439d87fdf9523f362a46c52ebddd8178e934f4e3465d8c3a88241570515ea07467d132f5a2c5576c685aad30244737560e656d2fae80e682e1b89cdb8fc319c2555fcd571f34f1922806b28c69b1df5589c25985f0574bc25f1da6354fbb2697f9748318a2d8bdaf9ef0b782a227c3d4455533a8dffb36a05bac3ad6a134a40dc56c36cb996b453428ea89dcbbbe1620fad32d13cdab26adc57e0629473e35ccea75c96898acdf74f6893106e75df9d16f4fc65653ddfac9827759ec0e2ee4417dcca629f8dffbcc475eeea45dc8165ea11b131e9b7a1a3b1f93d3da202c6e7c153958a6e15819992002a2e698d8c68784413562d498cf426110200c5d362c9a1869f679d3896f9fe1d07b12b8dd9efe1ff41ac459c794f980ca1e615743d2208cfef254c94b47abff441ef68f0b7714c6c426c57f7ad9fcaf027ad8d39d8704d91cd8c2e7987d82ff4c56b0beb7ac0f461b7413bb98452869e90f4a95a7d65621e960d6f30ef590500a068f59b0f8077ecbe00179f6c61797cdfaa9e9db27a3d0df74fae53bb75625aaf23715d53440acd6c043a21d1701110aa878d9450a785426a76e9f26339ff3e7cbd92ed47bc43adcd90e92279dfc562eef52e93a1d209bca39bdadcb03e9c314a8e4df6a9da065f0d37ff25f5bfcedf3d360e502de8287dc203ec97b61e5d8f4faf7ebfc9c4063a1f77006bc6dae0b31b055a9d02a76b43600d06e051d76c2e54feae9f17e628b424df0ea8a828ce7c85ab49005a2cdc6a82dbb3015e9552f15bf025acac4a2706525c54add3df245b10bc38082d06bc7a16165b7b77e33dc41785a0ed1f36caae4d168a01ce6daec69fffa66743026e549af1e91fbfed60bf56a5217cecbded30010aed66f12c2c65c96fd4e29b4b9563d5a81246c77830f2340aa9c1e06c069a54e85678c55f27b8b5adef8f01c17248247e0d1626029874a770d6bcb782655b3e0fc3b6166c92699a20374208ce4dcb99ab4f23ae777df27650bb46c52c2b48bfa22c7943edb4ac1b0a61d34b1961b3cf098896220d407440ae9963fa42ce316d6d37db0a4b25f6945623fdd23d084d970a2ab465ff426edc9927eaa63ce2f0529fe3f8435f45888e7a112eef5db9c0d7f5e073c54e54f480f9238e9115648b30be4c462536fb3037ab1ca7adec084f6f1d75d340b1aca2fe848127003ee1cc9ed5d4253d571fa91eeb03910400c3d569babec202b597430185325da2f80d5b7e928bd442b9a952ba1f0e6143c87e649d097d2bdc1b8885760f7ea137f7879722376eef4484423c07e3ba33942f75e1c43e25b886b6869ba2d6a0b153e4e7af71b2ba92bf9e574db729808cacece7888626c16f3c0c4963b4699ab4fe7b4ad916f8b9848fc86735d2c0b92016a315a6777d632549ef14f3376f70dcf0c6f942a9ec32699f3dae91d40ee8d4a2983ea251ef863346c44f714cf02a402a7da14d619c16e4ba532e64a544f7e31f3161615e8ecec0ac5b57d45b853235651819a5b1a385ae669e886a91c371767817544a201f65a49d7f269ceaa46c7e8eabdcf888c60580161452a5d7501e75c0b4481c4d40a0a44a7d0bf94e9eadc1e68ad4765346f4597341a4522714cafc45cf97591a94090da94549a27cfb2e4f4ef689a1d7c6ec336a22623e654b8b9f1bc7fc63fb8801dfe57e6287e47346674f32400b8790e2b5d00693a651dc736eb3a97edb608486f0d369bc0331ec09bd7a1f10ee1c518c77bec8e54de152b4842827c439a2730172d53f344932ea7efc8fbaddbc169214456b629b2c2c0ea82c6d55745974d4ad447ce531b46f31df16eafa834915363c6a303f25fbcb518167c0ce8513c19567952a3182a72e82e3e21df117201f2072bb38e7f640d9f07eeafc9972a8b98f7ae518436d4d4db59e13ca7d78c67345e57026c1f026ed5136ee13b31727afa5f5a4a3ced54a768764ee11eae13eb454c3c9a67bc91b0e5d1086e8b439a12d6263ced30dc62cf8a4d47067f3477b1a1bc1b878b8084188b3d3a3793f2a29ade1b990115488ba2533bbf4b1b45ae19c28f7393616e6c16d001ffbbcc4fdfc4ecc111e8afea44f33b3bf1e96ee9729afe1d3fd73b69153ed83be5e2ad00bdde4bc4f985326105a1c27410ca31b2bacf010287cb428b0c734144ec736ff3779f5e028f5f434388718973a7e78f7d81029694e72c271fe9141630ec1730549ecda5096b21e076f7f70891f008f0d8a62b190604034800101fc472f2571998773db4a81abf90c25ffb4d9d764cc5f0636fa0a19aa2616e9d81bd572751bdfa39b3567e5de02b3d57e166d963fdbf202725c310750d95656783aaba205a9c926629c8f068632f4f6d918d58da25fbaccc81537ad562e3a8057e82b13467bf63b9f42f5d1f99407c793bc5c94b72907968b3a72f34d63adca03f7e63b2ab3b193d0ebbf6d92fe35de65dacf0662c986314330fb84b2a2150c88ceeb505432ad488e76765f54c495c2dc356305f688512350479d43865c45a56ee976424fa61f3e0adb55af19fc5e8e95b0bcb07173ec1061402c9cfa4a9a0c40b379846617777f133368f0b0e7d882a151922c54745efc53863492cd4385b5e7f09025f6f8234b61d4c0e51d463b89a8ea474b4ab14190ff54172a55c111dcfa36ce1f1c4b561994441865b73bf3dfdf7df8532ea9bff4bc05a4d6ac7c5dd49ae412531a2c022a98f35e4842590487c24847edc6719ca2b84bf62150457e995ccd6a3df45590943bd7f4adeb270ee7efa0ae934f872de42ea7206bfb0f414c54b25baddc32bed8f21b908b01dde4d4d959d8e9108795983b03199c29556e3d40ac926afc85f9bd2b53d2622b4db66d1cff8aa2c796ce80f31e85883c7087971ab70160d6049c95a4eceba404768c7837129b605f6bfac695614fb6124c1a09746d3147d89624ea03f90c4ad1373241325dcf47cfc43e7644af67c6768e6b3ec7c05cd112025c0d9a9fbae116bc286f1833f831a0c8f4ac1b996f00f7318732abd788c4d71a0c8cc2a0281d505925791e87ddc78caa41113ec8c0a2509fe048b2d945a655bd0eab0dfe67cad4861f8fecc9d55bd299a1a843635713c074e7e7246228c67dafb1a1231964de9ff91d365c3ddc166733e2bb6d8d6ee4df6fa8c6cad07bc2fe666005466b4cfc6411faf8d325c4dd56edafd441fab82d6ad0590a58e96526ef0980d3b32b8430f905753da913c5d42f1f067056cb406a53c2ccd0d925957e5295234af99354c4589c911775e9cffbe0076ab90e92cc87d6eea93d96af484ef9dde002d0b8eeb6ba920b69c7e57b1affcd046dcf1d28775dd9a37f11014924b40d1d281478a71cb3089d6b174a8179f8f46732491df7bfef980cfc65da177480030ce651b4182f197c1db8de1de33f7aae3c4f70fb6c67170b5b1cf62600c7c8318ad4699690f789b7624afc6ea0e12efb24dbbc23bd078ef5b1a58f44ceeb78a5028446c2429b603726810156ba58365e1c4a9286d83fb79fc326fa43cce7478b453fbf2bbf7d36f1a952a6187ef410548f179596881dc6dcc1aeabe47f998b0f525931f6b707282ad692a920ab220ab9a0934eb0dbdd01e023647c767314daeeea013b2f31599076c5dda840dd7927d5f456dba4464ca25520592621e4ae2b7fb86f2ddfe3b9d2022a9b2e5cb0eef75b237d6de362268aa5085383184860b9c4b32e43a9e1e6259bfb6b5331a23932a2a4e6a74e9aa1cf5575f19a3829bf50912016a993c3eeb919024635be5240b1fe5f2a8741925e759b820cc9d0d705a197140338f1c7d422ebef32008e5182a571dd6a9f3e5298499cef00e981bd39b69f9f4789b7bbd5cf765da0ba6ac64e291e136bb4e5ba54e6e07f1dc97f90a4c7b68e22f70b5e9f72d8caa24cb844afc874a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
