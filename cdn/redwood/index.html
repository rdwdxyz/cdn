<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66ec31088845ad935ffda15173487287f6b4e183bd5ecbfdc372cba74305804f1402488c3b37a8e7621f42c7c2f07c1074517bd81e26b2f4b6e2deec60db9dc1f5e8240780a233b26c035aa896b2517a1e376ee67d2e66359a1e241f27b02cbe8cdaf52d71dcff0225b3cba709cdb482f9d966eb639aac399ed025cb53920f5b09ffb65d5ed613d23bd9339317ef6279a710559c0e58ff48716b7f666621c6038faea157ac0cc32be318120d1cfd60140b4c117f22d84b43b65128efcf4a1f36f80c4540b745c8a8e92b416b72225582051155eed66e8ccb5ba4d666c814a75d25df6a433c1b4c0962d1b929d9708b193c17366c2884e11b9192981af1d7a1f22864c59d607574ceb9356dd26e31031199fe75e5c4bfff22d98ac834b1c1ab804d6bbacfea1e1434bb050b540f25919373f3acf83d0fd20e26c3ff6a6254289de56b09dd1a8cdec1eb230f3d73e07e7adc2b678a1b9a4d7c1ca943eed0e0be2d2525908946fdfb9f584f78734a22f628bc100e87ef361f86364d69b4b052a3aaef48b27e12ed6fcc6197aff7064429729e906eb22325019943342dbd83c982f13d2d61449be366e2ebe95b3c3ed707ffe00b208336881dd02ae24369db31ba256af1acc665af4e8709645b23c5ca765e21fc552822d0ca1e5cfd151b068ddd4b4925c0b2feb05992b681e6732f4bef24256b7cf78b39e0d245b2d78205cda72317dc3f012fe3ffbb42ccc311c9c11d928ec1092e0a6690cd24f344d376f0af18771ccd54c26ce64b9f0a92103d699f57156e9f1f7b612f5d25feceb56f892fb1142770d1c6da2b393ebf1025c3fee78a20fdab789493c955d7b9f64febaf13257c94a1fa6888f61301b0e3e9433d37b1239085582258cc52a5c0c8e9b6f7df81890d85052fec4f7885c7ed935a5d338f9ff9428420df8a41532e63b8f143ebff86ef345c90e22f9f2835f1b5334af67e7ad7866ac9b1d80d8dcd059c8de8303f96ee0ce0fcaf03bf3db8d19da468e50c86a940fdfefdf3f23536f50073d5b20498a10c3d3ad128aa630b63bed4e1ef6c710ae42e56f70639063e6a11023b185dde802d7c07e3c877a26f12e47945e2708ef9677a5243003bfa0359c3facc9dcf2a69ab7f9bfbe382034eb00481e788fa2cb19819e293e7f5128b9e9e1eab0b36b05a76316f5f82c4ec1c5822047005cd26202ad8bc01a74ee001f9ec98b8fa3df4ea61b3371eafaae9f853aa07a0428e2ba7098422bde593cffc5720d8909290eb491cf6e3ed64c0b8c18d3ed9793a7d2a2ee178d54876801eafbeb5c4f255d70c09eb785dcb4c196672356fcee05fff219bda60c1c83deeb9e5191a4c45c7cf0bd4d63824718fa2e57be4a09b8c25b2076e9d2911f19d942e94ba01ac1452cfdf4d96365d513d84fb752ca0ec10c76379b806a93b70fde9f9bd1001e94762bcefd33aab136c1deee18374a0fdae1c1b846101caa07d561eef77b1121f6c810f4a4540ac24d7dec31b09b63d32261120b607cd63e7c186a5f21dc22bbc266ed467a1062997690619c246a94555975fd503d59c0bfb66916ea100cc959d6bd8263bfd193f45affdab2561d1252b0da8c262850ecc9b034a2cfd46b826b5f2f92ea0ae43befc912ab913ebf1e8029fca42cbab43030ad61922e402230f4b740abba89a900937f6753bd7d002743b60899dfd462d25b3bea7c78b02cffc3e601289effd7c8e5e4dc2c4dc4232b90695313b91cc7d85f582a79dc80121ebb12e515b1a3e421f8ba013438404467d0951dd33a8616555022e747a7b3e14d24a32e65ccc71c815f17baf1720db22e29b897236ab7d07726f4b03442797fd4a23eb20c65db0592a446cb47f1863b3006f17432edc0b1bca9d47fb38d0a80b58b126cdccf48d054b7d7f34f12ed6fe18676d933f3df95fc7dd76ba4077c94c539d9dbdaaf97cc89e7d4d32599e8310731bcf62123e46f44d88709cca2822dff3c6bd400d96eb27f5d31c59a412cbfaa52e83fd2de858b2760551107776f278b4912faee8feb11f9cd23364173bd5a407254d76748e135902be717eb8963c7bd42129e5754fcada5d57399dd1e8c686110418bec38fe822226632bd8e72b5e11463a36edb15d7752f45741f45aa5a14d6377079bef88c3cc7256baaab524d8e24610a8b98a374f5e655b8dcc53091ae7f6c0362e0a6c31a986c4a15e8f63d1583c99f7a848a73ff1600207f6820f8a2f003607a8b9c317ec2512cf24f3f63b94109a62823e805bd9f2eae044a94e45c7fa87a6c85511729920f9d5b1dcee39349642940b95b9d80327166919773868b4df551d8c86557e9bb55a519b9db88fcdfadef0fbc6e5261f5b5eb195fadd06182e1e7464a4a06cc5b483b3be137b32d753757d2254a9c169c856f2e0e57f3f831b00b3ffe623fec6d63ba4b2c5a6908f7033a94d19774d27028fc74e892e048de55316acfec654725d3a403ea754ef1986dfe2aa8c3e4f82ea61cd087718dbb8987bee3f45b8d62a0913cfe6dd39d117ceb59b784b9f369d4f5af23c76803564314e5bee166414448b59568d6f8c5959e8ed3a88b911dc2c9620ff6f2c7b28350bacf453cc1b80f8fb7b7aaa3ea20638cce6994bd08f3ab591d2a33671bdcf3981791a6f3ad13191bafb8f23b4f0b6248b05b6d6d660b04358af7445aa55c3b588f8c4d99595fde6a1c35127a4d6abdc4d704cf7529b45644301ad197082fe0891c74b5239f063d74fc86f48b11ea6d963e9444a1e8e1a157d82beb27d29c56f47f75589bf63945e4183b3f54d5958bb74cf58e960381a5b9b14b9a5fdbff461364617fab7450359db4c06046dd3ac6c010b1f4ab338356e96f176f1776b4be423803f833d3871d8d7cb2df9d1ee22c31a29ad1a03c869053f4f42247da2d05888600819b85d7660d8467f6b16b4404681a1428720d8a03fae3f8b400e504a1403e572be64aa30864b1398cac861c08421388ae9359abd51aaac50f9fe2fe4004331f92c928e05f2738db48c8fda3759a466a7960b7f0420f5cd832c79ba33b12af25ae94e099746a7186465ced965e38c0dac1741f77c1653f2bebd285e1e412872cfbbc23b9b2349f03a9cdd551cd80db2ab23601d42a2668f2e7f03629a0c4b75ad400b6bc47719045915efe42dc68b811ae398adbe7bb186a509db77eea38fda9b4c8139ee9fe613023fb09dbacc56d5daf6ce684559ca11dc6bc23c87d9d14ad9e1d273e8de8a80368760c8d481b885e692a721b91525f9b1a4971d99d26784da8b30cf31b258e763919888301d7d8a3d49cc6f238452b12fa48da81b3899b9f657834bdea5b20c0f2796f0cb05e899297082df2b3c2095001a7bb04cb5f9f9159a98396a00eb68e77382bac9b78ae28de980df4e8a4a6fd9a4deb9f8e791df4f3f3cd1778cc6e9a55ce484a9815b1b2f22cbcf92d9393910e90e49088b013a7277ca8ee490be4837f97d88df580274b576f3682724253c5a8b769cc9d48c805349137d2f4975937cf20e12eb4115f44222e9b510891a83b34fc1fa375088dfec7627528c4782fcccb9fa02a438a9c86eb251bd0a75384f0fd794a26ad91a8e47b4c8e7e62da0511cf76dad7b36a7bd27f2a4d3b11c0c11cf98a307a9c115a3e999c3d96780c22527ceac562c95182840929bd8ccb3e0790c8338b60bcdd209537569110e7c86209576f4db950e44081c35fc714bcfe6cd2027e4ca88206b187990dcd88be73a282e27bd18b734dcd3351ceadb7dd57379521eb8293819e1c6f9a4894cad199cec932156061811fad31227646c0ce12ba4aac87a9d2a0dec115eb51735d980f2e92ca905c55017173021c4df2f935f688170f9bd6bd6d435044ce8f923b5fda4b3e44c6768b6a415653cb8c9c35e050e155b9b3f93d710bff1e8db08767027447902a8b42651846a2c6a0d225a619ac22a17248eae8b1e19be5142923aa14ae43fa15d1c865475c7129f6e8731bfddaddac74c8ce696e4ca007b465dce98631b329828961f33b86bbd351802205caf246436443a6b2cba7a136cc75a99cf2f1f3b9bf5bd77db76458749ec150f6f02a7bff82b2cc1fd3ce7644af663ec3de455c698b5b0d0fdab90ee5e02b9a8c3ec7682045ba4f3163a7221f2519733e1e063b341e076f41b665389da80335724ce4bf004803eb32b0f9d22a1acbbd259de4a5ca513efa8d9a7aece3891f8e747d18baf3eba960f9b0e3879aead11652cdf0946e41d6774811c21940ac8600b063c2fe46ce3337a00b72853e321e8a8103daf3d2c0946aa4a632579ea710cd93ff51cb02269c44b4e22df490a1dccfc569211320e09aa7926ab12fc4e9f1cfaa31ed913d3326581aed6f5f453def9e6e418185518930c0c744b5448b5b8af50875a37dc4137474cc99742d9f6ceda189cdb6cd67a58e3f71d904d1f96a1fabaa579c96cf544143beee51dfdda49026175e828f67da075cf7c5ce02012eb6490ea0cb625b9f37e6c4335b94c20949d9e4beca3c6d750e65e9150955f18063b0387bfc2f15fac1223e46697e52ee4d7e93770a9d8804c79a2bab4ced0522a96ab204b896bcc90e51a577021734c221255bc910e5914ece077b6db99e18e4fa901ef0df027a97613c4bc65c5715dcc7e934882ef52b8fd28db7655ceda1976a69009885ddf79f494d5fd2ffb9dea2bb4af2c16808874d497685731d49ca30b5112f42c610990a8a05ad1b1121027049fd1e2d364c3692e8f8b3ef7964bf24467e484763bae45119c4b2e1ba8cf7b0d68c300b3705fa3d9aed54a4012692c9c54436902032a5de27e3ee91b1971070a0ae76ae977cd8eaa824bc5b9ef06876ea9762b1bedbda500add0df522379702b0c8041ca15507ceba894ea8b3180cf95dd47e0fdb7b7ef91a8327ac72235d359628887fd5e2dce773fc2c6ac73895b561784db08b96a2860a809212dd4bfc1e3a460df223f556e83deac39b3a331a824e8b0ad33634e88b22321c0a354fdd5e512041fab7bdfc23404c3f752c2d9d3f45e96c3fecf8c5eda151ecfd29d2f546626ee34da16d51ffbdba13150d00cb207065f0903bf3e594975b59c2c39e0e864d7f598955702eeeef53a1c921dff98b7761707caff1a2da8eb7e786c8ac6b0a2decc8aaec377e5e3ddc39ae5efae1cbbf742694cbb5d45e8b90478ac76bf00245d83fadad736de64e46b873ff5e40b819686cec9b43ea31b7dddf39c2c6d8eab4cf3fed58129d92ba541cb19e37cfc96be06e30cbaea08e5489c83a3702e05c2f4572e662f589cbabfda1e8312c0257bdfc90985f743d357027cebb597eedc371d576373e71fba237be9bbff5078c7e2aec17f5584ffb6d156883fd64c2e55b3aaedc96bdbb824f45c8290f05d895579e686c3adae6029dd0d02a1f62866eb85d992043348db14a532cc943168649b3acc1eff03eb9cd4f6f53fef699ef78e6019ca8d41425a0a84a1c0d1c25eeefb2ceebbe3dcaf68b9f9a25bb2e3d00dee4866e8913f378edf083ad3334742cafe5150cbd2d2d0af05367391280c5920437181142e263e92872b68132d6c301cbc0f8ddeee591d24484504fc9f927963f63f2bbf537ea5e32e23b64811681ae5a3f8795ba19122996ca81e42854264857d8cdf0eeac67fd2dabb4f29197137518cfe086f7c89ec479ee2780103d50adbba1b83d0d6bdbb7daf5c6dc4852e4d672997df038ce52cc6b2e1b855b617180d8903dfee79d31ba8bd0e328c7809a52e6c9d20e2cbe3c00799c636d2f547da289e69381a52307c5544a39160d9e5f0952f0f0b46d30b5f05f3711328af62b035213b5354bc2252b2e079c5d9d68b00470cdd2a78905ffbac6b501dd074a04ad1edd623992255f9015d2542a985d30b54b2001765e265cc4165cbdd3fc72d67984b4fdd10373e796291114bba4c42d3e1473d832ba373ae47776abe5c16e3c868f12464f47328fb840bf22c9d7afd72a0a67efc5326ca760460f6c29282252911dce6c67188f49f2fd9b8ada85119d06f992d665014d397242f64cba4a2bc00dab251f7c6d6628c42196e82d170478460aa2d746707149a1c572763ae69d3c4afcb6b14d1845d70ad9cd167e86e92e2769505e07c560b3ebc6a04f135773a4b26102af1be013c49728d005048c9ce87d485f956f1ea623664e941478af6f37a6e6d8efcffc0888dcec3ef9e37c2b25b09c48e9e85d60a47af71d9b8759304b73c52414a2eafabd919ef801a3c4fe0926ffdc911d73f2691976c969c057f41ab5dbd8aedabbb0a60fd7fc988937fe9648125a979be16bd30f447cc7e5897b2b9020fb47fffeff1dafade49dd44557dcd6be464415ab74da3e37df9982d11c5d53787cd052786b018874fb289b8b96d5edde4876ad5bcd1d9b6fd663ce3075b3d6a1778cd3e8880334e213d189eff19225ad83cc8087876f3bc9038aa4eb2df5769c6068f57331268e0e8b9d5916e9bc15cb9822cc101d6f9ba8970f9323266cafbe116b3398c2b9de6beb77907d5390fc15ebd93ffc995cfd09e20dd9330ba8a58bbaec55cbac5da2e8c49c99a6e11de63f0dccf2e1fd6d121c7caf1fd64a8ffd25a3ad4a67548e28f6c353a5e066198a4b9bbbf3dae1a9ebce72a68f352cfdbc201dd6ff3aad9f1e1762c7de851ad7ddf7bbb2418d5def132e0634851ba67860aafc57f9e65f9929ac1d5a96c6a1013b8ea124e325f0ab0f26a3dc171f99fb4f2854a4b27297449400c47e760d885ae67aa709f0b5e82e52786061a8df9457e81974b459a08ba09da1672edac03dc6ef19d9d4f1a610cb9672792dbc9bc6db37614ea69b9ca1b2987e625812f46fd21b2b11cb82400e64ac59deb6c0328293d1add68c90588c8763efc86a87b34623c68598eb7ba0a3bf1ef480bc28ff2da69d169f6ba5c7643c89a54cc950ffa96286950cea9441f665d6f279d9b66725a8558004ab0fcfa1a4cc6658a2ea6c19f3bd291305994d71d6c082eca32154e425a96e4df5830a523cfadde000d294bee9d6b3332fef5ded859ced4a307bba8ee649d71579b52a4450a97615fdc77d603b2c3b013638d8c7c66dd374ec34820f3d0e08e01b4976e4c94dbcb2659b2baf3c5d769ee53b79bcfe6d4d0ffea7d53f2b4f7d5a8d6dad32ee2ad35fb30bea9774c324ff32f996a566fe69db1321f2c202dde46b946197d43ac658055a1e3566e0dcd356eef00aec927ee83d1efc4b0c92bd43551b9fe9a78130c2b37c10ec704588fe754d18e21bba57b698c9ff79cc40e0342397c0479206aadf84d974a806ccd4d72cd9dc8a71fb35c8d5f0c15dc3855e0072817dc8b1b90ac2fd2294e3cd13eec2ae7d5746160be42f9ec17842edd040d60583f46d7b0c3af4398894d43a2ce8db351cf00aae204df59baaf0de7be4049023e1daa3e7c1583235995457d7772516445a00c34b78ed890ae640d2c71eada02a69f16629bdd9b30a824526342fc1ef6beb377cd7bcef77141835ec7660cf5a524686acc36c70fc031456e8852d5071f4d7c02a61791a33becbd322a78f7bc1f1a7558872e31d01a3d6ce9c2e00de1eb8b4becc89b87bccbe5c994b77150f7f97749aacb817f76d2af0d37259a76365ebb711fe8f117567f63a5ccf76f8137a0379aa4141d3192f79962789d7bef4d8385cfcc92dbc2115b87651630f4f12cd8fb9335fe6ae95962f9e8b7b87f618a922297348d5f592063c3269cac887b21c43210a53a63bc92b2c85d63d4fa39bfcb8c8c43040e9d3fee25b94d9824e7aeb9cb0bafb68e9cfc28bdf86391f5acb284aa4d8c9971a9a6254959adedcf867c7b821eed3f309d9b1df809b79b93bf29424aacd419cf8e46fd985673d29b241661ce43dacee8fb40a745ef2aaf01b3c4c6a8be5c611f3bc4d8a3de2f40905deb050499e0dd4f9655346dbf4ea1db5187bf8ec94b22b90c18f28dd56ab2b410444b7f289cc061d111aa4d2e353f53e26aad7b1dc1857e456337e31c22e24e05ad14d541c88ddb28dc512b1b2b1a24e590c58e0f56b6d408516b4c9ed09b5ab3f85c7c472e83990e0aaba544596d4c4bac5ee5eb2a131c6f8f57a4a4cb275f1421f4cf7c4b7389e8757c6e797feb8fdd461ac95da155f7eebb3e54342c8da348d2276711514e949ccbfe572c9a7a1385dc487e31d3964d747f31500080a43c194c467a22c3c14ba3ff371f63b1f449715e0b509891bc1e509ef1b2a6f229183750be5401646fe2590c2165a4985c203b1580d56c8dd9e4ab3cbb5f6268baf44e9b657b88d97e35b61e9ab4af14d3f4c6595eaf9bc9ef7b948c4cd85713e9be2ffbe62836c472f30337bc792bfd22b6a35b2ca4b2891222827c59f52630fc32598765b907babc82f96e5edc9ec0107b211a3eb1b81ab8d26e9fbc824718c29584cb9daf8807573ef1459f387505f8b743c767ddf4437a499af745f7ee2039cb71a69f811216c794869b1e181bde2d8d09516ad8b19a1485368ce2567c64c4adb1d5b9f829d88a3677486eb1728d33414bb2b08e1f868a1cc3bb2ad00e94b386313f341bfef5027639f6402725751a35f34da96cbc95ada79566d1107b8d55fd1f656d2ac351c92245740cb056936e0bb0e1dcf5a2ab1ddaf31f8c0d33bba7b9029cd844ffcb543009535c858bdbe71ab307b409920f4cf83de8c080367186a34dd587cb883912b4921447af814141c2f13e178f73f3825c0aef5933708f9d1dccb2e031765b00d22a78a7b38dbf01a691b6f570110ae52b602e46471f04ca518ca73eb3b5a86a807a84ae472fe1736f01518855ff00e8b1f0229da0284f41cbc3cd69ebb40146e46f8543eb94151c4f36650978c8b471320e6e3702f0e65f7031dfa512ccce17acca98a6851da90682f7df60a1048500bb22ce744f1c0fade9824b0e9d4028f0b156246be4a38fab7eb15909bac663fcabc256fb2183a75e14411a70ce654cfd8547f8e97ab6f5df128003405614b5e8528bed79d69d6806d44aa135915447d8c02e305c6228672dc092a36b4595e8c96ee88f67a5152d0d8f468f3c04699d6ff52ef488299bb60646be11248debda599c6571e7c277e23299755074e88c9614ba1d56f2c90632b5e61ecf32c39355c83e2772c6f5899afcac2c979448d9a8fa9566930926e26c2b54c1253f2afe216f4ba092192d7dd8e68f790088df48fffed9de82b70a96eb92da3899d13f656b87496d79305e58af08e21ce4481b3ccc88803466b3a283416722ef89a85a35d8ba6861055c8df7ee5a6a408e48a3d05757edba006debc1fb2ed3a43d618a061c257d6b8507ac92545f0fa69a938f7d89e117e3710dc159c7d1b6181ae837b2c61d8dcc7458cf3480f8fb82106b27e130213a944a5e71ebe749c263d3efcd90493012eee928b7c7cd9f671084bbc9f67a4923f45b8b00c765eb0b03d3192e42567fad94885ccd81b76897f5261a136c239af39d1cc49e6fed937e26321d632abaf96e20769dbf9cba948cd20c5970509000e8b9efc3a64f087b89ee4b2b491feefc1c32ef20d6109f47eebd4ab006655a76f7c214a7b9be5cd9a4a3ad5c4b256e85565019935afb8d66df4ce5511bbe4aa8951b33141bf96827d9f946d8d709af129873610d30d274ab8eb57da10422a9baf55c39cd99b0b320d4c46e5c89a1445098b758a8a22347f1743b50fe1a56e252812011e723fb8a7d0b762bb53b1fb12659140002986a08687e5da3d001299043756f41b16143aa7b03ad045dc52c902409d47e9cd643ee9eb3f113a27e44739fd2a834f1d161be442620ba440c0b5041cf90aa71c0efc77cd8ef5c66ee21b499ac33ae24e1f4eed25da385ad028958dd28c6876e3a5da2dfaf72df6d2a332a76bb492b57fd90645d07febb0cd74a9706e8548342daf1d30fcbfc3a9a8bc4f6c76bdf6bad6de993bc94730b3faee4e77dd2d48855805b1634dc87c95318fdbe4632a1556848df4c72458da50c4a1e04614b57ad64a70a5df10c1a6f425c3ae86ec58ca4ba755b677c919c8e4aa0ee7add8fb644788393e6046f81243bb4b94c02ea69a4e83f807a1f6b07705c3a62bbf31fda5b8d28a3de1d8dc57323b7e2431d858015db42d0151f019c6540772f6196339a71e89acf0520f692008974031534fea2b90304b6a5e90a2606052ef1f582e608d08d9281524981afc829756d32ec90333caf3bbd3cc2eb5b6fbc383bf336c447dff3e6b323d0edb9b5c6bbfa0d6a0f60814c91a850559331eae0dee35c365afb56aad4efe869a81288d1f30eb484a375888a2933679d72cb58bfca357d8d853fb19f0255855bf6cc42d2ad5c02625cce67e3315b371694cb3d994d0587e58a4ea1f9dd2e6bc97d505b1f1eadf87d9180dcfc64b988043a997fb8759b315a953cb4ae04da03293b6e3005788e2c663c37d32453ffdb3c3991b1a01a2a5a62a9d6864de95db6fb3d769e2605807749c253c81b5db77041fcd909d14a3c72b1d6db54c95e66a1853202d5808ec198a0c2e8ac25a7925866e8901ef80292c16190f91054ab7c8e1f96846709898f46fc044de352ee5f5d5dc2b15c37ddc0fac07b713dab8d8245bafa4fe2b00c6445e67498d5e09a1dd539eae3e60bbb8dcc21e00cfdc4a14a5fe7e08edf0a365056b690c8fb5bafd9a1de2e0b32476903d27e4b2578755d55b271e6e3c2797dafa73d4a68439c2702ca3483d5cd544141620493aa6d4018e4d97262b9e2891a96cc1aff5c6ed649a92b3ef80f8704134c33c25c0595aee0e7712f16bd6ea0d82a929cd2b1f7c3eb6689db748f7c79530b49996171a0a4741eb6cb727b28a8ee5d89c27a235cb36e99433059d5323faced81ae2acf8edc3c4f56ab1f94800290448bc86b6b63eec5ef6e1eb59233e02f085e37a7ac86eeb861c2685f9c6dd3a1ebd12fa4dfd85bf529c17f7e9f39d17591940c09da823b3716ffc0199b125117e297c0b789e13b2b669e8d6ea00e1f451b63b8a9f2eeb9fb4c5e82e50c4f0692116e351965d67a2ddd4e3a0fa8363be21a39a7dd55556b8ff9734087d7bd84378ff6bebd5870f9bd69bc8f2266981e832601ebb85826a7d66dc117dcd33cca525b0970193f718559a13eff90cc8d3179ca313764d3fac9a9227faf98bd247c1a950e4df87009e4940fe58d8233bf7130f052fe97d6aca7a4f3b758465e5233e02024fed70f1b3281e511d520162e4f1c904f53dc4322eb9778943dc7d2d0bcd3b44889aadfa43c251767e30be406d16ffec1d21dacb6b43939a5980cbbc5e44a3def5635bc1232761bdb76218651cbd6e68a1003d3cb2edae9f591f1043ad2cadfb39fc78244190d8bb12892f4efc61cc486359e95a0743b54acfbc0e16fc2e0e159a8a22902bfa161aff5a7414be2ce5b93fb45d2b39a901465868c28a9d01c1b315b5c334abed59a14841250d76966eba43c891b6f56dc95605208fa996a843fd94907f794bf2412667e4d65f7eb8cf972df7a3ebceaf867a1a326e91f75aac07efba09cf1d511659a6ce7f3fa41dc568a636bb02b02be5a4ac9ad4bc9404821edc9142678acb9be5437df04903cd0f4672e0dc52e822bc52bc70026f5863c8239a2d5371d0e86637e02783c5ce164568a9d17427b95f28d9d88b1ad5b10894fb6e268bfe4ed9f34e4ba93fb11903813895b5e7318b5317a1276812835a2d753296a0c5f944fe689ec0d0835df06b7c3bff6b25bcb1bc4a61947678a602d1251810c43a408de9f9f6f2469ad8f5c7871878119f4e460f1ebb4faea1f29836f9438bc3d765324ba812e464582646d0f119049746f635b42787146a862050fc625d3176e121f6fbbed89abb7d44d090ca757ec436ef6a2e074061a12ed39ab0d14f30fa42ea1dd8786d0bac1bac02774196e4285fb4bb205eee3a75446252941e240cfd2d8ef7d0ed1eb64868e726f1aa60734226d2cf3aa4ba440433a7923639c292486534716c89cf08bbfeb6a4f885841c5984766ffad43b5a1bc03146ae45bf32594ed6c0236fd3f153f0c792af93caee394ccbfaaa6c2121122f8df9f3fa224fdab30aa9b98d0e613cb4300d5cdb4fa244e59151bf0859cbbbc88601158b9f4d7deea1951fcbcd1f9cc73d9f0e9866d75754762f094cb0da05d08ad43023665462d4e44f1a3dde4a1e06ef2b8816b9eca4c1f4dd523386ba4f8be62a8d2ea93d82a958944328e44370d573079082d63409468f88a3777f1e9cf8bd94dd188a91dfe4fc54792a52bc23080d65da1d963681463322d03fdd663f3a3048379a904e12a37c053a67f826de20f10d470b6f87dad6964fb246971846e904b99516d5efd02c3d3748d391e05dfc563fd2429ec2b3922dad8c7fb266d43ea620d7491581e827ab03cd7454ce2663b12c52469afbf40c8ca908b532986ee6bee44ebe22ef20bee2460f5e3c3432f4503cb7b7df5afc76944ebeea3b0e03a8dded6d5b6caf7caad4efbee9b46b71bf64a79e66a6bf8c8817090ec285ae13f1c23ea2a068b305e3cf3b1f29136a50871cf1dbbf7ad838d24969c5e8b7edcdf15e7687cbb515043b1952373554e00d8fdd3cde16f2c49f27a2200becf0dc3b01d3483059daaaa0f3f3a1bf83e1df79090fb7c3bdbd3e71926696cf2f7868d4b0612cf7dd64685a2f4b76f1326b82fc0ecabf4423ec965e5c85457b979f3071b2bf02674cf5d04bd0c57c04ded9e6fee9d0146d4ddd792a81c5c6ae9a700b2525ce399aa22fce71a79033c520de18e41503403d52d5922d4e02d8f59987f2f90befe7d058e2280265054143ed1ec40cf15f52f1c526aa7b170158a16f7c725208b54da0f4d4f8c3c9d28bdd863cfb2447c369a0e3161a887d5db33e4e29c212950d304a477861811856cfee9f092db14a61e7ae956c1bedc0ef7bfb5c8c16cf5c766ea1560c0ffe3be77e4e54455df30889b05e1da89c4ec8676cf1816cfb3a79c666690e63e25c3695b16f5038a88cdb177965ad497f638bd679d886f6d6351a95e546c5aa2569efccd130b3b97d9f56ed32ce62e8fa35b1c48046012299a5fbaa9840f0a5de8314514135e02c4c0bf0de3a9cef7e59eabd336a21b6cb6246b1ebdcf238cd6242bd4c6d70339dd544aaabaafb54533e481d3761fc79f75b3eef0821209038d2a7e5093d7ee24bf5ec1b490fbc5c5794107e0b9f7d4ef6163d672e4c6dfe1d5d17f555caad1aa705dc8204f93854c9029aa54774617de7a967cbd6a40d4b918d6aa689a166e4e284383b4c0191cf7026d1bf04672339391bfcdb12fc0c36706e5a1b5a285d98ba80331649dd505d4d8dc5dc289fcac12592708e18a5f45c4842328210c5474ee3c0aa55bb79cd9f362c01ebf59a1ed7762eef66748d514ebd5220aedec789c2905eaf8e13fad4fccdd4483b12074ea4a5cfa5b3cbf4a32c9e8fc820626d94336de63a25a055575c0691416712890af26a1d4103f242f03ec8b243fd2a5dc52231b313f9fe36ec517a6ce9af6ba87d2f8f01839d5b321757a8905abdfd130775f3855937c7222aaf63961770cc17ea4ee8fd9a2e28d062c4539f731783c1452fd15ecdf797bfbe2bd247d8c9e10d6d49b9338754c1b55bb72056213c01941c60129a6dd0b8c3087af75eba4eac4bbff1978222435a079549523ed0dc98b594d53c4781fa714ee65795bd4079ce775e9580b5ec89bdadc0b681dac53ae77c5681b2732c273e02f2ede161dad2325f5487ff98711d7d60d959db0368e799bd0c46cfe1806e157f1b91565d1307658cff79453f5cd0eb23744e4763ee94e4dd93d5f95b415fe17694e62a745391c248f66028ba77ccbbd203bd92487ba0cf69f6b9d6ebff772dc1958f83d37e8df5cb505343c1ada8d11a54ef74b55e7011cbfefc4b8275f4607a43c8ff1f640f5bfa65ce453fab9f6768c6726814f1c849e87bb7826653fac2fdff266e311153af24e50add62f6ffd31d3a23a98f4554ae9f17bd778eeac22252c054a26929bc38c10f1e9bba95fe69565135d24867de43f6b782bc11f7599be1f6aa43533f862d9bb548ba784474be7ae173cbe48ffabbf2ce348750f297e3f2ab30b7da914c04004b70798f4903c53cb9a652cabdacbf6a5f1c148349d74f6c0a2ad593a423f99abb290d7f53069bd80f945c1fc565b57db9b0cd936e5d2580aff1e6d426bc8bfd8cc17c51acf82d668c077efd84712601f9de2c7080d69266c0989c0e647a19822e621a6aa285eb44e1e24d7b6f2cdd574882056da9531a8f1b1a5ce463decfc407253d6d2ce37acc75b0c8109bd1e14df70906b8a08ae7ec3de1db900d0f59a13d6a3e4ee09c23d81bdb467edf1538e0eed46c1a3428bda052ef1b4ffbdcc33e3c8df31a94547b9d456deb7e5428d28ca2cdd939bc33781a9ef6108fbda1bc615bf17f83e1097fa2a1a44230a06608cd6a331d08075df3ed5ef3a38d64cdbdb826edc9ddce9b1c2b7f615a51fe89e7c0b8f12d3cb6144890c7cbb01fddebdab22bc0d28bb549a3cdc430531786ccd1632d5423abc1631257f2653293dd216c95eb4038d578356998cfc0a86bc4abd11dc4e39fe32e75cbf7f0c6ab72cedd9d3c2337b4359c8b25c4125d76c170f27dbec7dfd524af3abfa79cb1e0e75ab5c437c44fced0055d96126551b8e4d1c48adf2dd90ca22c1e0ccd1e2aadfa3e050cd4d5dc615109765a77c5ff97d77ec8e91c86fee561b073b520b8335f356413131fbbd8aa1630a46fbac63a789af614d7ecaa0442d55322188903d6f062298d205a76f36b301934ce22808cf5c87ed130a869564f49464c22349cec3b350252c99d461566f5cd23e600e7cc2bd6d7a6c0887bcba1de4f4c81dfa296c9c098f738d0e7bc7188a720d09d5b0d1e4d3576b5c6a890ac29ec10b8003eaa82f8a34a899d3722d1b62b41f742e6e42e8c594dda525488baf4504a4be25b119f330cac02c58f3a2cafaeb321cefe6eb0dff6e22394a9ad898e59783c526fc21b06e18217ec4052fa5440436d0f6f2519b0d196cc3a0a3fbd853015923139945e857a271d50986a63a2ef0c47017af216147bedf2edee891d3860ee5868f57764b20d92d9a4288d871c905e3a7404a86e586b4f5e2231f3e853155c9b2697dcb56518b9ad6923965e28574452fe7fd6c2cf9d8d38d91472ee310dc7e2568202","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
