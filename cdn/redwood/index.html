<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"183c8c9173cc1ac9afac39cf355edc261571bc687373fa97e1363affa620ee42de6e3e9af6f2a019ad89faf9bfd42c59694ff38c8097061616aae841c4da8dc36488ed9d1cd649e8b9f8e7f49a9fcd19c17749d25f872f799d112c56f66f6c2f40cb1e559e6bd5ed8d69a02493e56961d3cc6c6f7d81fc2365f7fe9ee17545c32e6342eaa0dc7fadecb64aed74813cfd1df60efb97a2827c7757e330edc139cf2fae8102ed6a08fc1202839ef7db197489ad6c12fa8bbfd1ddc2d9c0d79f7e775992de9c789a9c620e54f50b69906339a331023dc1c7f9a4fc22e0a7540d7e0fd665f438484f4311e9e8f0d8dfe1da2807f3951857482d310eb82b2218a178a67153118b3474fa7c3773ece82ffc26d772d326bccfc7c7aa7ecc6aa8df6129155fc60ac91ce48dccc2a2f73c3c7112d9394baf573dbc5cbc1a40fd0f4573718f81b603b6f4abba7af2a71dd8d6c4872547f705064b520dd08b11abd7a47b8072dbae78be2977f1439324ab5a9368e653b0203afaaf50dec85d751648e4fe0e587316d33d842c6c1358f67c0a1cdaba274d2498171a5ded7bff07312c6249920bf373567b10a9f8e84a7ea045376cba1771cf41929b17a435b3407c001858877d8c46a51aa60664ab5edb5367e9001284c17b5fec9b0f4068928c3a5c8f54eb06c13231177bcc609e9eb2ee7addee014c779bb9b050dd9487d7fa00df1e75962790351e5001f7437b4759f2b00f5d3bac6a959f8c7ba36221ba1498414eb24b94268d258f46c7d33d7b7ea8b02af2d25c5346686e503450e30d4fff203d9f7ce9f62806612b0a4d88295afbfb1c03b5e78680b88cc000d414d550ee40796b1a2ce70e39db474591d945c6ed7ec758d70343f52a6382722ed7d67a432fbdab5afe43efc4e60c908eeebf00542ae499c1de368516010717e66119dbbc6d73c421e27aeca526b407578050dd3e937000424d34f1b7faa4e9d3c5df81df14e5f7d9f655a8acffe6c4d206d4de94fd1f5573187ff944106ab894e8e96285bc1a8e54bbc8a31a8846a6e5dd1a0040e0dee94eb73717b7e5cc528b52b9c321a58c7805f918a6829a50b532363d7c164d3dc3c3f887f0e8ce9f82cb8124ed9aac721caf1f9686e14fb5217ba560461479bad1a97046b45f2cc4dbb73089da0686ec3c03421c46f366349a2e164ef18a0e044bc50728638b53b1b8f84b3ae0e80b2e0d838ebe3e4773110cf180f6eb70d686fa9ed9d3d278b4a38674e7279590e5e4422b6030e599ca55f745eb8e4cdc81031b904e9fc37ffe30daf33cb310b0e650a694ddc86a254956f38f6986daabffdf61b6c30b126c235561e10c2122537ae4f994411eaf3f3cd3cea821f6002679a1fb309dc8bce5df9da67e6ac02aaf4539b2d379e0cf722a1c1d353ba57a14c527e52441b6f2b3cdc1ffac918a172b0f943c320cd029d111483556907eb1e28ad199b680e7491707768f4c26311920512a7d396dd7ecc25984ceea75e45955a8cf23099d67378b011a5fd542d0cde09102be62b9e1e7fd9a535bcf779909e4b44907baa5af496aee096339210909a5096492fa2ba9d4dfba9e3644aae02f04e40399f542574bcef533699b0c87d73eae5cba3c73c01caaca7fcd744411ab16c959ccbc705c82f967c9539ce4687f51ea011b9daa96e0b9d1471d7440dd42412bdb1a6c83b9b71e999dc118593893827ce9e233f4ed0b50ebc7cda49c341deea3c0444e55b115deb1942be9e5959ca689b876587c6e47d8fe27b6f36610a11d1950fcde3740cd43ef6af66598659e60de129caa436fe40df8d38f2d7c0e31401ee4768d87f8a21031e7dae9ea9fe168e75b6d5d257ae250fcd5c060d3372baf55524fd2ef30940b8e27602fd35ae77e07764b2c95862aa815717138f9b2c382b714a9d354f39dff8548466176b80d65470fbf2f3221fe195954c0e6630775a48186a305ac8aeece8cd6fd007c113b5ca2eb347b31b304e0e3fb718b287655c22e4d2cd37fe5d0f5b21cf9a623951b31f9d2675015e5d00cc80b60d2f080bd0eabb43e8aef1985c2518f418e8b40e9e8db70cf8b029c735382265c482a2a822fe31e6c6b63ecccd3cc97dc71b72c6181ff3465014df48c309932700a4e96ed1392236581ef53031db0ec3e86620d8e9804b6189cf875db61e7be63f9ca5960aed452324354303614f412704548e4ee9336427f70a53cd4a99ef2962c37a3c56a120870bbe8861c28dfcf7dc92aa269b6116b30c34bb9dc9494baa6475597077a98deced43e307c6cbb4a72b53e7118e8ec670bbd7dcb6c8047a2b288d572371c5b6e209fea5dfc694e5ec85bbd9cff4ce1098767ccdff4a00dfa525b924dbadcf6028b91de9a72e421443b453c28c92dc5bacd241960a7fb5984247983958d3cbfcce13f628ca5db331bc023ec0c025a6ae97959e10ed04d15676b4d6b982e719701c7b84430bfad310a8a38af86f65803b6317ef59dd65c682f3f45e8a50f9f63a481c33503e09131dcc0fd10de610a14ff1989c2077f6f827ad22862755f7127988a78022634898643285401be5941413e1cfa339cb64866e58f76f3baaab73ecb447fbd4dd3a44314ee584477052e5b74c7150876e34880fafeff69ba476e6ad819337f8d40dfc2f8763a286421a777fb9a3f7b43a6d6405b45300fb1452620481120051e222fc4da93ae1f0cde03fb99efd23932d0908e8d88e11eaff6d24f0dd4cd01b619c33cb42a08185a9eee3604d1f59ad35b6d33e3404265efdb5636e5886b2117122fe74dc9e2363171e2aaeb9dc83724aa283e0a99bd7ff560523860d14ca2411f0738fc2c7d3a70af114e25164f3d8a9e4721e1c5a2ec96409fc7751145f5be3ea2be4f59d0ac1b76dbb725ec59a56641c9f1a6ff7d4c2ab9ade18af8cd1c1380ec3898f5bf3e0335c2ff75bc7b5e37f1eced7080afe1df4d85663a8476ca2a5972db4abc4c8c91aa9042aa16e914c58ef123b8b7c282084722e3f9179ced5adac75eaf7f8da4bfeb15b826cdef437293223d146fe3a082231e8b0cdcc8a5d0d9ced9aa0c22ea80b27649444b4d66906a51cb0e0129a313b99877e684e27d115dd615b04614dfd59a870878ed0d2a934246c4175d631f68ab2585bacaf2a9c0ff1ef908c12b228dbda632a7e0868533b23c8e6799d574b32546e61259361878ae3af82e29a23f420e0ce44018441a53b9504adf41b604ce41c1f691866dca039b1527081f0a99aca6fb674a359688fada277420f538668f1a1b8e7f156d91f9c01a26f8785841dd2f5b723147608ffad1f6038a51279bcfe516785ce41c43115828cfceee69b4082da3946a3cd5e92d94c24beeebd8f79daff9aef1845b2b2d11b86869683db50622117605bd3db6ca8ebed60dc5accda3e24cca52d1009ff82233eb94df786748231b2f4ef92095e1782922d5d45a1060cc6f8bda0780f7e4c3c4110a7cf8acdffdd20f078c60b98d0ad1211eeaa3e500c7b53a3d73f8e14f74961bb943b63ae83010db59349ecb391d3a75a31d4dc1424f10f4690fefb5f0ccb6778b8cb6e0bb52d55967a628afe8cf5954d411f85fd18584a01117aa1301d359fd79710468a2669a9e687026248890b381cb320e62c856b09b42dd8c5359f24854e17d79a6d30b57d84d3136266c59e4c9463bad25672364752c631e849003af888e63f6644f372ecf6cacac2bcf79ff8e5177396bdce7658ba078f8b6d039a73fd85611b63fee765e95463157be1c7063e4a0c6e582f92816c5ec8e3202538852c8340060bbf5c78a02865a41309a4f1fe3db24ed5baa58265a71e9ef805d691a15544e5d6559d2a818fc11d9a78d2abed0f7858047f1d3ab62172ca3b742bcc2b35e27402c003fdf9d46ada722aeadba1dbc2ea5e3190da9861b25f53b00c95166fa0f6fb8a60a9c189259ff736cd10fddea6dba6fa3cc12c68ffa32cca522ffa4e83a29abde22ede4ac772fada3f6d0572efa38e191ee7e6950789edc80c7f3b71f23fcaaffef515e96f58221619e48ec9116fdae3c556b866bac1bf27bc47a9b153bb64a0ea6f4c3836caccf11abed0f0436a647d5375db93bfb400fcad79e59b197d0c3e9e058d89a82e7a6f235c897685ac416a72a5a6683fca009a9ddf5c8caa8ec692552a810dcdd8555747f7f72b73d27fd917ed2b3373e68501b288221b0a1548e80f2dcc47c6c5ea4835441e03ceea09eb66aefe081cc595bdb9ae3b4e2459431d02a540bc16af54155a09cc6fd6faabc8bcb36abc9fbd3dea5cbf06d9ea852dbde93b9d82863b437fb7a92b043d3d295e19d6cb1187b0a88d23852143162a6b36a40ca9e65e94c6e908c977eda77567c84254b7203081830475116e3cc0b9d4db31c44049fbd61c6a787bbb055a122ebe65b272e7512dc0222936f29b4cb6cc8e8e436a539720dc1ffe6c4b022582cfced1a2c65844262fdc2923124cee46c2070b20658adabd7d6d301db19574eca3111e122e864288513d7156928a97e3c9011419ccc7e6c7331f3e19d172a0d4f45010d79a7654f18a13631e04b249592e13093f71e6ee58b76f257adbba7105133c83b939a66ca6f6b586999204762916f8aaaf7742cfe6863fd8fec2087668aa1e175fef0ab35d2f34ba67047946cb7b9f0d407c419849182c6d000ed55cb456ef16cfa12fa55dcec40eb6309f55963b398721800016ee48599c9ad9582f15dd071e902e010aced272483b9e1460290c307f00e4b84cc4aa47953a26529d1f6281cee0550c10e461b5f43cb904f2aa5a0344c705674104135993eed634a6f753422c79b9e0a8dbb03b95f5f60eb48d8b18f65dfa20c4ad9db6323cd9fc6e7cc96dcc265bcf8af1427236cc93ae1d4a99149eca92533cc99e4c345323dd36ca33f41514961620666759a8d52cabd13e5af1c9d3b9e9ce5495898bd3f1f27dcc433bad80fd85ea7e6acdf504c6204f9231737ecfc9164287cf484ec547253796b22e10682beb88998f38a6e8abe8fc444ec6fbd3a679cbde8b716e79b84e8028a88f16e60fcd8df279e3533031a756b93ca11c63e5fa94bc307904c3cc2357a307ef046da5d631f4144f93ab609d3561e9334e20da7b7b8d23fa4376d1d127c653a9665b0d56424c62054508a7c6f272dda00390b4e69add2b9011560bac2ba510db37fa8b05b224d8ff906b0ec7a568226bc829c2ea661dcce31f39619a110689491292a194c569449872499acd9206c1ac58599b927bdcd16dc714e1cba7908e6ac8c74b2dd3b7df6d49a00492741b7270c3acee5baaaa94b4f29af09a4b22e943e0b162c86a289241714947c1810c9e8b05f08a1a37c25595d0cdd07c30c2f2c0db0f4569caf5823b7914ae1513b4bc59154413e184e4af998208012c73d1756adbc57bf61bd9976e38d385986cd4f9f2bc94f2e41d01a6c353407a66fa28db3b91e4b61530ded6e5e2a975add888711fb74ada51e2dfb396711bfda6588ac9ff6dd88bf644f4e6617008864bfcdbd3c344b555e7d7eff15015754a71b768aad2cd0ad7602a86f4d08985e6db80f71a2a477bb31baff4654df4927be80f2c7306d395fbe76ce8ac594385d552358ae2a0ef666b1f2556aa8d90704f8d86349b7b54b6fd7651d8b7aac9cbd42bb376951e5dcf2d238660f201564efd5c38e3f89e027099b25295b8d324212f329e8b535daf3e4e2d320c20714f31073a40a5c0a432dce788adf4aa9f1605b7f44ea79af68f46b5314b36e94748767c419b8bbacbb1d6fafde6bc12d3aff6e5ae48208d8194e060c8b2e18bb6d2161b5eef4df1de27c8d2d7cab6f3fcb85f5ee88994a952158c56db0816b2b006f062c63a147cd8a213e58745e27912fe04fa20c5111445a2091df3844eca71e7fefa00ecd74d1ed7099de83370a7d5b9887ffeb9715f74938d041e09fb4406ef05943fe1b638b291814a393716ba5d219796635dd6cc16d368f48fc55da70ad1caa1da426b8c1ee97c1381381a48e760f73ef6235ae48b2429e2e04ad193b89d0b5666e4fa1ef79a9e10a074953a6d7706a76352341408535a557a2f01d01e7ada7adf1f7808d1649512ec0060d2f11bd65951d20709b0bae8bd850de00d2f9d802b0d201742c483a1727dd03785216e1311f0326e1bae3f894282c6d2037a0fafa36bcbb3b5877759d18a8c5fd9985b4dd36225f1ff784a73cef7fd0ca8fb12b84d97c905f6b294e764188453ae5fcaea7d98e8425587ccf0a3249904c18484ac651cdff14d5c09615eaa0fafa9ca713019268cb6d8aef8f59dfc4ed1a0e52fbfbeebb9cab69ea3e927163e608b797436db41d3d7ec7ae4a28a19857e9043d0fd0d3e0788c40b05e54388ce9af96028123f45352890f109ebdebaf1c60fff51600a0eb667b5cf9c2942734a80f419a3ec66e449ad72c8e0bc922d1fcbd7595cb9f9abe3b57f01e227b86ada4d86bda10c65bcd8f84cabd15132657411fddbeb86b4951cc6a671f7ba9f0a2d333aff1fbcc2ad1f557d99c35a164d386a553c29b401afb65c8a25695e73f5a455116869035fcdfb5199f95407babd9b434dafcab14eebe4c1a297ea5e53fd074ac9b201042a3313bbfa5168c9e9b46a1679de840e0d484218f4e1c9c8fad5e5a331760522751922c7b39afce291e38b213fe94a946458919ca2571bb7ef4b6ec634487704a737d3fd413662a8dec99c12a9043db29ad6130013973a67a72d966edb5838445bc75d6fbc9a56f10bb1f7fe2756cc6f66c75e6b89d95822a9f9768f87e7517079f2512ade83744bbc2126514accec1f1149de234f404f6a232bd1ad95fcdd461c4d1a93fb37e41de3eb26394803cefe3a435ee26389c719e022ac6d4dbdadc6bc5f1a3311c4a67cdead2d0f59f241a67ee95ba6630c037ef08cbf8802b9ee60dec1910cbd961925c81ef6c47512b38c5a6d6c5ae13af6078a16153749ec3fa77eb73d2f4a48241248d63056dd58a02c438490ac0b8552240afebf6970da554515dfedb956d87e9b6f8de57e52733ee8e3b336ce8d1e80a4421079064b44cbef194dfe11b567dd23dc5945b218400eeb72a96adc7d03f1845b01b702bccc0b02baedf8708841ea58113dc5ed59572dda9b249780ccd5c9ea46b92bcabe02eb18d0833bc055ffaa52b3a4e69cbce5999818ebc6d9677af1fa48f461ea693071c567b647a400e212a65591ed237f444d5a95f4751fe812685128f48a126ee4b150a1c5922b3eda754c39bcbfd4128b847bf0852e7d2063e63c6cf833e6f97b542cb517567ab755aca496e05931d02e97391c1ab190c1b68113c9fa3f1b77f5c7577da497ff9b90451249576755709ad5a3782f6328dc48c63d0ac3319fa3c2042658f49e9a2c92dd6abb64f7b8d8642cb6e6323b8a815759508746f7e5ba9bb8fe7617e4c545e177784aca8feec476d06064fd4baddac3b138d6741165d93b269c428dfae558069d5e8c9823a8de89946e0d18dd2f1fa4379c65e06b28263d82c04bff574a5ffde92f7f1968cad0e21c7143d7d477df2eec8bc05cc6c72446c05fb6c899c77e5eb7725941eda5a4720b5028fe8a1fca060477630076c86cc1ba60ce6ed5966fa85e58bf9b0048550434dcf143ddf02f462e3b4ac566fde650584ce1f7f5c0ad881f9bdcd7a7c499f33a776c25f71301e96d3f6d80d8a7c5dd97eb4db793598144bb6ce998d6ec2d8acf41422455e8a02ba0549fe01a719218f1b2c1b0df8779d5c149c8afc50435799a1d347cc8b247db0498e7a2d208fb8a327f5e54a7baaa70a80742750d31434a29ac4d281188c3dec3b8b92779df390abcf3cd8f46806111da09e94fbb730bdfdb3b4e9f62a21353d099d53614607779c541a1d997ba25f035d4d146f370a489ec059fb3b27d6fed416bbe3a9ccfef39b7ba2219a0145e2b653355ac70a048d09e2f59322acab6dcafa1da334419fdec69d3b4ffa77914163c5e8a719f8a1d17063dc44b81ad59ecae51f3e40e490be5863c169073c8e550218cc3d148be4797174cd609c9f37121b3fe6f3d1ab7314301c726f7f404130f1e204cf90476005b7df0e7892a678f98a14cfbff08d231b0a8129bbc0cccfe81ae67e371115aeb46e43e1e6d76a2dbe710638f23b9d5488fa2c0d018aaef989f631a7b70db6183884c8201ad42b8133990d31348f2b56c5ac795bd7ed808a35a7e72126f3629bea764ed5590898ac63b22f2fd831e133246cf47d8d483fd0e7bf2d11f1d222b9c87dcd8bc11fb5d30943ba9e2189b7aa1f1f6486be592eed77ebf2c91d464a641f6dcba644b30e84c70354d15dceb4edb7270173287b5f9b8047224cfb74458f098dd646f831c8edcbd0d24628b250aee6dff7b58cffce65282c0efecd9f03fc1ec728ade6d21768abe9057a6703c78c4a44f0c4d400b351d90e83d6adfe52b53ae403c8b26d50b0a9d62d53eb6a3922ff2082c17902ee5596e0a78cce8d95d7f909ce018fc6ece08184050d5f47bc58ee55b42ec9eaffa32f6b0c201525810e7c11b567985e6627d254a887b1c4f48248270761c086dfd5523cef8a64252cede9aea673f39f80997f4515cd50356f9e1485e164dff0b9f61fb4e200f5d0d148b11f20c632c12b8fae87af88bdb8af5add40fd8c83d7269cf643db3e066ea1246274429ce84e6e105af5e9f667223925202f96fcbd6169e937d04ece78f3d1992e915a088ad40ee9f66bcee2bbf2dafdd3e718d6d088cbabfc2e686ee26dc6eb67ecb388e6da69104f3b7dfedbcc2284d7b970a80d1cd46aa743970997e5bd1a4a660943cc9747514d6be4401aa4080c780db18890e66e0dd6a46b39fa86780cac71ac3cf1f4cfff01258bc91d6c8a8267e93ebd03aa25e8d47eee021baf5716202222a908d42eb27b7422e39f36498456098dafe97c9dd0c018efb9a1bebbce846a4e4c91d24b138ce0bd0572f8681ec2cef9396f88e5e9389e83d80fcd37b8d76cd93172956b98a9fe58a753c422ae7546693392c282aada3753dc95a3786730959c1c4909ca74de6ebe31ed2d228e45ff8d30cf94f49aab393d8cb0d5dee7e7980decb1e29f34beb5bb4fedd406cd75e4c0507a298ae15c7a92d58603db874f9dbe1a9a16cd700eb8c828bce46a8bfe009b02099eefeb6509a100cb55461362d87a1a529f92dc880755ed0b7d6b14e718b3e15b608aba9e59875c8592917bc6fce8b058994e8a94db0f59627f06fe8d6d0a4494a953babb4b92b29b4633a59a9b0da6ec2e0e6217c3eb937be85aab5c74ed46d2d383856f75468d915627f8e3f698fdb1bb795baa96135bf00be6477dec7a2a4f990162b08d45e998c04d28afffdd4e065ba08645cbe95b617b7987016b3b0533898d7e1f14560d9cc8daa35ea19ab02e1ec675e11c2563ec227ced6f5b5b71809a1f7d7d87307eb9f46cf1c0d089dcfdd90e2682157c095a452cffec94f0641fd1970b1989dbb3b493423471a3a0f2dc879fa76016b027199c5ed3e830e57f9ee650a52ec26886f280ced6dd4f36b8a6070e6cdb4dd9302dbd689a9f6de46467e12ed58c772e57e1ebb0e43d4a38ede07f7297050920cc32708a2238c5bfc92647e5e181f3425c6618dedf9c9840a17225056c594617abf5217ef8a2b2f290656e577a25f6d38bbbe17da1fd0078c53dab661802edfcff03fbf3b56f9da70a891410293272d0c712fe86540747b599d05620abb67056b6982f2b7aeff18ada06c5fb8dc91b0bf2e4061619f23b4501752587d198f49c8e27ddb71306a5ca083d11331a2683f094bb06be9d204b3196edc5dd2016a1c657a1aab4888ba8375d9369eee569faf211a9e3ae096bf5747b317cccdfa20602090c964db1f899cd03a7a90d994343e781025c4a97d275b94643083da2458cf035816622a10e6f1c04acbfe67de12bd12f786e9ee07f2dd0604886f14029805f27291a438e943b0e6e92160b85e1b10d606d1f27194cb3f26878936e6ac3d2dd7bfe78402c8a12cd6026273e01ac9096723c311aabc5106ec97a4580c610477fe42bf8c2f44647656df2acfeb707d715294eb98204166dd6ae94ad3b1d92dec813d775f0bbadf90bff26c7587a9ccf98b391a362bffa70c74097beda7ef5cd2ec1f0ad1676271586ab353a6ca82b9c9ff7d84b05be8b77212b236d8dfc3b541af2de2e3be5821f95d453b344bf247c3d1cec891fe406664d2717a65408b45efd7d3d7f20b35cfbbdefabaf16ccf7032fe93158a215abf069d1fc2abeed239b6a6ea653fecb4afa7e6dc210dec1ec8aa0afb3a30ed826787fd4cbeb2f7119de7f1d641937b0b6b7385bbf3a809d948c05f619194207aeea1f092a878f3036294e7889962aea7d9ba3305b2dca6568e76face32772c1fef482f281995c45cc8a8312d7a9eca466198cd16102136cd15533d14f0c90aa67554ff7f97b9785d185cd30cef1aea64890296fca92af0ae07770b6bdbb13b6ae58ec3e38c86db8b6c903c5977170b8dc727d1426c9a92ec525f3cfe10931273ed9c160d95c67b8775fa591bc6565a036fa2b1ea4c699dc7d723ad1476b87f07acfe75c039754eed07020222063d355eda9d25254a560b6ce1480871b354eb56b0c6d3fc133c2e27b79038a6f5818a69866a6ac1c7c1f504a493db7687c844586a4ce21f10fe15f1ecde8fb634370c1ed89a31b5de2652d79a454abf6b438f049d09246d2038783f2fba84cc7131c211e61ea319004d22b6490cccf4e7a954ca0b47be595945a7b80de6aec52cbc9ade4bd7b79839803fa289fa564dc5363a0e89e572d2d2964aea8eec5b7c3e2d8d7bf4585469c2393cd675fd878c3ccf47ff9da47a28a3440246fb2fe66dd345e2fc37310751b4b03b63e4f483f51a58ffc2161d1b95c85ee0350830e129f0034b76446fda1aae69b62b94b75929894f317f9d168e319cba6adff852266e3229f256c2dab176bdef5e6bd7da4edc3a6c71be57ce177313777669e9bae05c68e793fad3bfef0a73da3a6e0cf045a5b613698562f8732ded2360673a74e3a758973df260dd2e0d67806a2651e1f4e8899f7674e3b72dd1d2bd380d563a77083cb04b8ed3ca8e973c6bc9a8c6d89ba4c33c213b14d5a6bd4675728abbb648149e5829355dfa283681670842fc21bbf61338dfb48f7d7ac396b42da2132331437c43ca402ca49d071ff3eea4b8d53d2dfb97f17c86e5f8a5cd52a766f56f86a249cc06555743e68383ef2e4392e47ee951d8ca878b7ce86abd1ee2091fa48699e44ae490b06cbce54f1ea8e8ca91f7d1e413cd400412c8841e8063b1c812821be52ad9d6f74a98687b7b6a240b83555ca2b6e6cd727c994167897ff2bf30661645a81ed204def4ee4db150ad23959e682ea02c8bc486c06af2d97eae04e9f6ad85738cab473b3943c1a96bd10c2d5ebae12e5f840b4eb22ce804bcb18d5628a075d98f67d1ee9ef94e07285f0ac1d266e02a634c37ff40fe3bd313f733b9c154c2b97f218c1a6799b750dfa007c47ebbc3fa396d72f8548ceb7105c01ec5605d555300913aa7ec99f7979452dc11b64cf77882015f4d71868c32734f3bb09692e4b0b71f8b47c229f46966f408ec765614a2977d9b78fd21c4486a053f9cd402690378417f5f3f7ada67378aeed3cf45ba4d687aa05ba4d8b33ad676c2d2dc51f4a98a366515a053203242a65b30a1dd91406fab7b8368b4119254e4ec15f3a6676c9b4045e2b17ac9df2815b6528bbaba1af0078c83ec28d4ce62c0c1a544a998146c1832f7f00b9076b1ffe126d3112b878f51a4a061d1ff2396c8d2cc97429f4ac2f0ebd22e85a79b5b93f4bb92a569ee808b878038f05c4d7ba4b735e22e2c472778aab42c0b6061fcbd191ddf0ff204f8a2834916e14d847020e11b1603aa601a257db1bc2886bf28282d4ac8c0fbcf13e86353ec2887a6617e5215d79e60fad4a2c25ca9753ed434c64643944a4b5710d05492401d43bd0f6b4f0052af09b0109f01ef199e8b7579ef214ee0aa5f97424f09635e8ee9e43707c23ce5b4f88b379e5d2835b4b92e005fe1233c76321bce21f2e0a0994a45312a6483c5a7f70f1d47610dad4edd40c4d5fa5744eda09b9368fd0c38c0a70f80505e1bcf2be775d769280e85fb9d0ff36ebe9b329ea741b3341ff5c48da729e150cc3face0a3a46cf2db17894d9356b1ed6b34a092394bd8267070fdca3a3f44a971e7d52f7cc798697ad717c5b253fae020174777904440ca1c6e6c7f69c646e0291b7ff334781598efd99bf8c2a5b530242c386616ea5d127e442ab3234b3cd26a24499e66363a2f2b65e9a4960949fb97501f20ebd65fdcf07d310f1eeba591ee6dad539840a7fc43f18adf837b724699d9f617f43cddbc921f6e8861caa5e68eb2080812f98da1431d3acbdd1ae3e84c2e124ba9aac014c892432818b9e893ff2fb68dbcc51d9311eec1fddcc4e71665b5e2cf7834785b7b4022a1a15698661a49a796ada79ae57f8eef95220ea7c92cc11d8d819178db2f8fc8c6d243c2e9ce492dc2ac0fc6f22ecf198a181f27f7200b082a9b17ba5605311f25e80122667510bd04d0e4fbca4d180e8789f217aeab351f64caa7fef8541962229e4f05d7be3af8c1813a66dbc6d47651aed90acf6f9e11c610c5ae05f20d3843bcb932c97d87d9abfbd1ddc2d319a15dfae47934343b881beb45a93e3e9dc5b91f31af27ffc20dba3b7ec7376e4e5390cfa1e5a3604513a796aae29bd372c33a77426f632d2980f7c9cc48c1cabe9b120059cd33906755ad6d7dce0f353ea5ef390e97f05e173e65fd4298680dd1019e09831559634808649193021182649c8b3ee0bd40f8012d5a1ad1f3eb5620c53cbf349f211471ac81f25a2e4e7e701227ab9b640400aed5c7fcaf221b0b09e836a9d673cb16686f1d7c857a2f32d03ce204b9b31f1d23946bae6b55a02980e148662b49ce1e7569fba9c92593983395505693ea4936ab1be92b12a2dae92f25124aeccc2402611849952762b9c0291a0aef060c8efb55fc98e5131f8e47278305ee8265f2722cbe7a2227463701590bb7836b2fc0c01b2149c286d08ef8eb9175125fe289ed50a74e1f6e81bacb99725bb6645c3b1032b034abd8183647bfce7aac3433f80f11ba938f1fffd10b9e47ff3d6c2a1f9c8e3656ac0ac56ea9db46474299222854fd84321bf16e6af6d6d15bda0d1b221396ef63ee34fef8810fa96853217f7219732b654c6b11842d5aa50592cbca35ee3130bc77ba53feea043bab43cdf6cde7125c6a681b98660235f03f1101d2c28d5ba6970ff06947f7e1da030d230991046d93841dfee35a9fc54ad7233f18d6e4a22716c257659916014e6c486a0b567e5cf00b83fa8b258536ccb6a2217778d3bbe2a57841ac180ac49412da6bd751e8952a64f52eeedea0de03df298d71643d419fb5dbed75452ce5325224f0dc8462f3b84e9f333abde681d6df6aecfd578c3a2160093c4fc0a674f1c7b232b1ca443649aa93fcbcb0e4ae71e21e3a8b074a0b80459593e48361308fde1c26aea4b4de1f3e8926b36e9a7d71291b34623f9e4ddc9f87fbaf0817de1b3772ab54c425cdf6a96c294764ec0ae35ff5cad4ca54e1e53f416628d71b18829deb52e33a53e4e61e4aec9509c554e9f780c90b7c2b6832f5780ef612df526a3c76243d6edbb2a29af86780882ae6fe8e4505acacfd11a118f10828f9476e4c99407fcae4592bc657eb2f19cd816c01e55c3746705fc2bc039122e57f223ecd02b0d8efd9ccc53956035784c912de090b4f0881599a188119d3e173bb8da580ce6a15efa11e7ab815d52c617b05abeaff752e524a1cc488a5e5d114fa54544503a6e588a7bdbdc951d4d8ee2123c46db07763f02404f18e544d0c5155ee80b836f52118c0365d635ecd029693613f1bd34c8a65cc19aeba321bd32b7fb819b3990a60fbf3886fb7d06e155aaaf42214d2604579f9b5773230fe9449fa9a8768e797bf9c01af0e6211bbec1a8933ebf355cfab55f232bc2c9b5c174c7258822c7fbbbe1b4edf0c0838323e097b78b9fa7989f8965061d470d6a32d1c8206bebde55e79a5a0e357c709b9f3f6ba8031b54a15cfe39f963186b2a0d5ff73fe213694d271670c3bfc0ac74f789a75d4bb041b8d7282fc4b97879e7a7deb6215317b40cab3d9f2d5f264d706d357ac55690b592f58802c6a24ed422a87daebce07ddffc7685ce837a9a43ebe07a9384047bc454d168a1196233c9593c4fc93891ea7bec796e465f30e370463cb31470dbc2a58fd2377c078e3800c16b45d2e2d135b4b428d6467951aa88a1e138145fc3b30f7473d516412b31f21c49837955be05a7470dc6102e4c2eabf2568f7d4083326f4d198d5ab989095f9bfe9205d1aedc4750b47ffd144ffaa43ee63825a9627346e3d0ae6ce447cc0faf08cc800414548ce1f37330d8da3505996451158e0a4a339dc7c192536b50a337f19e012b303f969abb053b1534c5f37ee53043fe0dd2f8b95f99f77fc09d07b6bf44fa79be4767c1c508ee748b806375329939bdbe358fa8648f72e9d136cd6dce003b2ea7e94b5c15144fb447e38e016261a9bd886772360a1eadfed6fba2a3db885f39687f5f0adba26eb12f89959f512738d03346d5daaa45713f4217a2f939234b38399abc259e6983c08d9fe10b4dc03c43192655f723ba205573e791389a5f6dde5d5bf4aa6985b6fce3036482d2d8ba4b584fb48e2021291e545ba46195f2920fe4c4812b08e032c627eeeb3321c18787d70f9045d0875026c1dd05ab6ba19e971cf4dcb7acd2686cb071d961c7cf8423c1a546a78b3bb3af1a0d1faed70a881fb127937840db969515db449bcf927d8e32e5e90576442dda233634c8fd7682dcd34a73b0ec6979c381a54282f8e9d322a1f6c009173053000ee211efa415ff51c1275b5aaba4c91581b75c75d93aae0ec4f7ade9e55370fb084ad2d9ae06fe8f38dd18a1e041be5e37548e98006e7a41df8d389b9817292826cdb002652c6114c5e84bb4d7c8cbe6f44632d1c77c40d0c0f2f1debbed1a143f68c300a8e9aca15b97e598d9300162c04a57c991c33a6352342172e63993fd074bbdf39966d97d3b0f151380913f4a6506187d75ace981ab7d0301cd2bb22aef654e75cda24690a9bcf3ec385427c03956a95e46e8b8eb4c8f9906c6049b87468b035d080f8e9747390a5da55f7a1af679ada16a01574845f914fd86bbccdaddfc4fce71c0f4ccaffe63ebdec4c8dbca20077fe9a91dd4984117d2352d8063c0086cf2d35f998ae2c2796212cc5a1681a75319f4cf420037a71d03d2e97b4114838dab6065e2d409511e6564098022f742ab31b58b862b3ca0f0415939afbbdaf2ee414c2e959afb1f42bda0e4842e3b8d4085fee49e6e5f3bf2ee174fe15d528deaccfcd7657437807d8e9e9305b63103300b632b683496921783ab200d4eb31649252cbe47b96193dcd9ea455365917716dfdba47c17f63a8e4cb38f671abce87978602129b236e44f2c2e1805cd921c82ddfbfe8bf037728823dc845788bfebd2514258b22f45ea66dcfbbc8566582a8034c8461cd26627af25988a6144faa3f66b55d9e7ee25ba83803df491a1f7e8040a88152140e07acaa804e7fd860ffee9e23d0124346e416b3b147f2f99da7fb02a18825031a4ef685724acf636133010c5ca7dfd82953f9ee539fe36e6992097f665a69c90d81854079f772360bf4855b2b66c185cb4eb2f788b0fd3766e5be3b240d0b186d359cfd4927eee5890ab6621687f61b5286c7e32db0b609b10875d7cfe11b8d870ca038a9d4f7e1f4d4399b14842fe0e0374c923583e086d02f26dc018f5c22047dc9f581e867a564b9638962cd0bb9afa8cc05a597333bba097b940af184ff978b750fe505d91a6eaf48ff091dfcff23b9de208cdbaf606a5f9bc0bfdab1d0b21baaa4dff9aa38a50276fa3b96dc5d4f1bb2914c698c20c28b9bda80af2861ccc397c678ab0b16e590dd91791115b65cbbef86116240f520ace95f3c1d9b28f7d0efaf2ad00767ea7e07d7a3870ebcc3556f1e313c2931f79edca58f477e1ed6163a7c759c5254706f3754de226b59a6da18812bdef8a5284701e7646cf3431a29ddfebddc6055eef63b9c8a7bfdd1afe69b7077e55f47a82266c5d8302488334620e2856b02a2c3c087b3a61af63e869abf78174a56608a8d95532fadfda28dadcbb740c8e9f32d9c2c5b317c608ad1fd917b3dbfa82ae5894afbc0cbd1b6b51866e42f80d18d5ecbc3f84066c1fd16dee6c735b08bcea3224f257ee574ae24a4047bf0659e515113287c85c868d5d5ac206b9b60c69e2916f26e5191b41aeb9613455a3994b471bc599620fa8aea3ebf5e90fd176edab106a337fad06de3845bf191efc4cf00f37befe2a9c421701c9c8968f15025104deecdce98aeb16e1777d12ab509fbcfbed9c989f3d475c3d7f55cd22222e906554742d31ed53398f8b8388dcfe2569ce15f37bd9be143bfb07fac363ac6a60e73169f707514fbf3e1408d0db2a7a5d8e9e7852aa978f1466acab78281cfbfa83a97fd528f806f5ee791dba8a49cd5a67ead2d1a601f9da796d5cf8690e2a2bdd5c793754ceac2c151d66e1e31e3c48ff5e6b9ac05b1365469eb618619e6f0223c5690b236e128c6650910103b3487c9f0994719ef5b0389bfb9cb9f474884133925430656b03e724ca2fd8226bec952d042439d71584cb4190bb07b7f53f7559e966d89cef9f34bd8fe2caabfc8b8c3e70921d8aea6aa0c00facb06d35c350e67c16f51e54d4110d19155cbb0799a2605bdd738b66010ffcc71b1546725193b6019f3935fad75090b48d067254bf5268c805c03e908f12722748071891022ef29134fd53fe0f4392fd97084824d117acf5e3599739022101602f0f86f82bbd28ba6ca6d444d1111517a5857e7e6bb7ddbe54a8c3edf9bda1afaedc0bfa0a0124f8cd2f2fb4451b5fb10308b08706413977d1fe365628f4e5a0a66623d08b2456d2624d33f792d4e866129a3176dc353b18f08c192c36382b362be1f559a69bb30c15bf806b16d81afad12b82c0c621fa1b4820cb0bd2d2e9c1420b30e46e67732517c94660b3a971b6782b6ac0a289ddc1b0317cb925b645913ffb866d777d4bb021bd4264d9fa07fc158aa0837ca43782254f4c9ca9d46ce2bb86da0a876ec0e4bdc0edb9f7205c61fec6302cc2d32a14e9ed205007a515f7ab859912fd797b1049c8e2e26fd44601f6badc9ca4b4bfab5e8500d0fa6252a03c1f4ccbe6a6475aabef979107e74537bdef26e9f14601b2895625cecdfc61a348e64227507cb3b203d47dd97799df541da9163e035193089ece5b4a6ba88c2715ec3354aedde8953cb90f4500d8cac7d1006e406ec1b7d466cc95fcbb07fa820fdac05b36ccf78100e16ef9aa3c6d90bbb05ca80bf0e1921c7fd8b2e5b6172cfa4ae145727dca670b5e1959630d37c8a8dd1aec5eedd7d0bfc77edb0a6c9160e4a032093770eb70b1ff5cd9c1c4e5df096acd624c5817914056fe1dbfa15bf6a95f2bd37736ac391f01788015f97619882224ebf14f892883933f1169a4cc86be7b23e90e297e97e4723e3f2e8e6d862ad0f7e83e670d1321d38730a76fea9ece4e1ed5eec35dd493e599d1431bca5f3f0376e181374e5018008bf2b3d880bd77dcddbb6a42e954cbbb4b8d5a904108f53992934dd9670405704358ab96561defc597777bc85b6e7919ab2d85c5ef1bc312bcb1b4c7fe9fe0f604a7862614d2020000851fb1474e1e5254df37bf906b8c96955ad65073f8c8f250952988dd27edb46207c04fc63efe395854ae8473da53d495494142f177f387833246324070dd09f6a0086a18789fd5dc3cb84db5a4f528e720e1d83b4df7ea8d5e9d204b4b72f4ff5562b56aba63c914fc4f1e826f9510d58e72b27c8488b76db24c2e470ee00a1d426cca7874545be53040fa0c2c48de1ead108d06b5bf064d9d0e4bf831ab09ab7066a3ebfab98ae947315b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
