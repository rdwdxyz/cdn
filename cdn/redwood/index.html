<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34a5a555b227c52f2960239ff23a7bff8a83b5a76cf7d425482b4e15c474f5fab24db03b1b24eda612340582892ff1dc5eae6261e584d7bf32793d92df937fe65213029cbfadef1f8280ef389599d0ae728c3dffc7e33333e4700841697317b2a5b651e7d8e5bc932cd74b739bb5828c79eb59fd1dd0e486618c0dd4d178759b689dbc441f45e783d6d9d52fb4cc034b455f265be956191f461b804366dc9127aca7a997877b8d014e0e2c4edf3e2f0ec84820fe865a9f25ed5196ed5cb65359ac09794ed06260f7f99bf2728992612680d632827fbba55b2fbd34aeed128c2d6e0244b07250f5379d835334c502dda7ce30e552a197df31302f67df997ca00e2426b087e13a7d03afd0b026e876e3bf6af38dd36fd44112020dfdad5152b723e4e4a6a642a1def94e6d78f57e5ed171f4890896bbba06d2b5339043cc969312b4b912db57bc0b37808c9a2c0f8664238e1c4b1215b861f54049fc808bbae8908b75553e42f4d271571672e2b4eff3c6469e33eb6e63636d20dde8a81907f012314d5e27948bc6f6174539b964ad65eed90d9d9e111d8422fec1f63fd374ab678c40535fef8055baddc6a7ce5e0842d6aa96723bd76069cc252a903d578d03fd155ee2347487d88163c1f7c682ba342dacb3a4d67612c3c5a3234bb9ebdf4eff46722b60b02cc79456efe6b7c63db133afc3952bf21f909f949b8d4bfad5f88ba4e2ac9fe5c9851cd546081a3b2c87d343b07ea79f0cd0437329b9f294815329b9f1c4b1614aad5ac7277739db0f06fad29ad0f4ecbce9df672542606871e970afc52c27fcba4f922ae4dcf0f172d5bf01f51ccc9c21ff64dce73883975b2a8e6d3fb72b700bde747d3ae76449ae0123343533a90dcbfcab25a3d44a71a6f3ef515b9046a7c153c4b701a8ecd0a89a4ff1b31164de0643eec32d2e8b370978a1951b8b64b43071bd5cb0d6021603583f113fa89b4fcccb71d80e974589a43bc7791f8e67e8b371709f1f74997a0bc44334d9bb481ab25a955079b4376ad185f0707677dbefd632aab07f144b564a30cdcf26fca82b0e3815a4d6eae6c75f3e726473f55cd3963198333ee6b2b0118303a644e9e4fd078f7819f8b2f3848e7e70ae51077c19b2cc2e56821eb1664e8a32f0b40ca969f4de2b8ee88748723626a2f3962c265aee1574dec2a09ace8f87e86eaeab594660cef691bf9625ea5e7dfc2f4ad8b198440b90a328890ecf077dccbe0ab3847f00c4ba01208a96c923401b16012c2bfb1ba5cda4e98f280f3ac253254492f034839216c0f3391e20dbc12fe029672b881f77d3e0e6b4f2c59daffa7f83a68dec0b9a4dcc70c497fed3e659d67260922e68843ff563713f8681b858e2bc2ea4aceb8f1f6e6a7f9efabea6d7f28bd84b62bed183052d4e7da5bc8560d5a883e839babdcab2374adf449175cf26abf08a2de64316567c4794b05c1ce6e75cdcf1dcbac0bb29fe21263718271e22a76f29dd3664d78863dbe54f0df8f117c1e2806d71e48160597b05f25317e6bcfccfd3dc6d8f7215141f2fea972d8e69f819e4d3e56a495273c6cb796cea260fba042cb235cbff049398d64139f8cee444d43f38469c008887bf1dd25fa1cf720f25b2a544fc90628910332138d10c346beba999b7161114cd64759fe785ce683cf7efaa0250d05ebb2d72a337e59ba93f7a9b8fcf39c3829d2bd6b0f6bc1ea186ba2d1c06b799fbe84340fa17252da49274b958b6dd33f244225831721630e4973bab1c9bc25a23d7d58fcc7d16acb29a98e3013f2accd9ae7dca158f891c616ca123e2010a9836a20ac6cd35d6cf0cd6e5b60e86e3422023b3eba034690135377044ef8276dae1619c3469359bdfc20163c8d92e7c3ede8dc18032c3cfc894f78d7275f41b77eb825df3a1286df25c504f3c6ffd88858bc58cc7ca360bd410d9997f597228401324337bf04363e9228a50ad91e7a804e2642a51a54564f6e00200dd3dbd4cb157a215bf272a7e42a12d406a46a5edf10fb029190dcaee74a40e9acc749fb8e87b1291cb6b25b67cb832901c5b95654afd64e2b0fa1c59adb352948a3fff9c315a456d32ac46c24c4411d96f5bbd8954c95f2bde5ed3891939529dff674fc19781ab88ac208ae8cc79786a56d6440f25383b22d29c036d499efd43b9c2d8782c8d5c8cb0f6d0bb82e1e0898e85d15be516ea42df1c62045d46774761157bb6602a2f7355a1d176a2b505266dd2ec3992c18d3b849a1732223d82af539a24a166f057aeb1d390b475cf09e860a040c25ddaa30f55922abc51a50d69d7fcdec0ee2c06b8b4fdf86d6e1a78223fb5b56fb4f297e23e3c113672c9bb8e36f745d7e9e06be77ba3c8afe02f4dc3cf6369c833f5c4413c2772b94303c8d775b4d05954e9fbe08039d99d759562845968df35697fa299d38f9f24f8b539ccf3fc33154f2782c028f428a8600403e5e12b7c8466e1c0de77b6706525759a4012682df34aab2170edcbd555e16376b699944937590d08b6c22e6464a29f8aaf861c6766f33029f7ce0bfd3cc772a6b1cafb74750ddfbbacb514724a292bcef0f08e4abaa1caa3579eb8c3588e37f9620690dab26641776000200ad2efdd12435b16dc9fafe807d05f5a8a51686a06027a91ef432601a5d8eb6510b392a51f927024e640278b69d1f7139d24f96b21b3b768dbd449698e0a25db4e9fbf1d9eeaea2207579e5d67120f5c8bcb57e74208d5f979a4335d275a9c21673b9328e3ff12ccdbeaed8e4b908cd593ce809a2cd6407b7b864a4e101c7fc394e0268c20db148b61a82f75638044183c3ab1e6beecaf23f3e04dab024e04893027374a23a78283c9f7f3a223b3bd4c434005ce3817632be859297f1fb937abfebc2178e62e098ac6e8972010cedd889a8883c503b33c0f224a4e58f5e9ab58c2cf15cc2db9131d45ef992d15ef8eccfd7fba302c14814bb18be242d6b2937a823c05bef8467a55d8909c46b39368bd9d2d23d1764b66dee2582deeb66c701227187201db903a7c5f034cec1b9aab3a38540cdc0e7233664b8b343222bf3cdbb6794e5e64200697d062bfacaa1cdea0f2c03674278f7b407b432b0aa337330c9d91753a3724d05041a21913eada9ac54327a0bc97c561dd33dbe603bfa26fa78c9f125d7b2025df196e054c7e95ca31d6408240286106cb439f0b9ecfeb7a99199d8386fcce5f03d957dfda8e3dd568f3fda120e57435805dbab875ca6018f67a9438bcfa83f1126882901bd0e2459c34dc06ff09fb0f635c27e1d9fef8a5ee8bf35d467e02349c3dab921128a230bb1a64f53f42c479a2b0f0acdfcfdb74bc7e0255a76e3211383d1133632572b13928c07fdbc6e1baa885c0b9317aafdb3082dadf64a57d0654e8e02e3066c02c0717dadb185619f65aab4b8d0793596e7f5ec398a5466e0e176ea5115d3c78f9b66b7fdf9137d5028087a4f24f9b5cc18a7f1b070789c9a920f78bd37dc20803c58b7c9fbc06d5c29f2eb55c02b008bd365ef2d227160943ca16872676ee410d1189a2240b8005a9152eb33ab77900b4f28676ab0bfa75f324b036e27eeaaf995d134a4fbe876eb78f661080359bfeb80a67d79a1dd3fb329cfd1031b2a1c068c8f74491bb56dc98256415ed16d2abf453d88cfa16039b6d01d49fe89dfc28544d3e407e7b169059a822ddee5ed21d51ab2da5691a9b94fa1777ff0c3a62950ca84890679dcf9a0db562a46749d3f97224493f7f70f17a72a8106bbdde20ac0f0748bf506ab192e14f9d0ca3308f9b703d12e9a6df2f56063f44b5581c09b43ecb7cf555a8cc14c1d3c44ee74be416e941be432cd35fc41b0f768b1f8c6afe6340ad01764a6dc3703524e74c62a2719bd4c824f4bbdae84c4b7d1602216ce4a17853cf9519f5d5a626fcd124fa9a86d55801d9edb8c50567d0315f7aca88cd7a701d4dc516670a8215afa3e47594e3283056050429cfd2c5079bd7c882f5bda2479db57c805bc3d09b02cb7bd08cd70404b074d44c126bbd052258ddfd01eebf0c49dccd448b634109a0d25f49a5fec5834a470caf87f126357e876b4f75a9d7511c25001f9fd2bee93b0ec2bfd8a71110335fead9fab1d6ab83e1c29d936c10498b357259ee63e2310441b689a4f024e36b7919c579a7bf5287e21fdadf06dfcdd95eb275c336a1bac5b19846bd16300cea5caeb07e21620483ff900d33dd6782bf5cf5fc48c9724a094b7620837ba2929806f4e0d58d651d99a698f7e4434772d4de51c579c9d85b667f2f78dce94c7d889704ce437fa5fdcc172c2c770dd4c1667dd87590af33e9e4061edae838e54d930cf6eee1d1a94593b1b94bd81d58ea041f5f2c4d29736af7fde1f905dc5c0206ba96a809f21affca5141d6cd24fbcabbf5b6733ac84b00a152d92403f4a50242674b4b0be6fcbf6697c2f0e52d20604743bd7688705536e59f70eaa40180a559bea8de209612f4982a3b31272455bccce41b77a5bbc89a4ee91c25f097126018e98a10062dff7c96f04d0f2d4108089234273d3d82f1870b81105caec9678b5d54f1e86ca4c5042be24c8127eaf3b6d60a3a6e29fe4bc00f574d40572f2441275f455095364ceb3690915aad765bb49e2c1621c5f24c26473a0a9569fe28d5f43993ce4fbc8f6eeadc650188a81bd080ef918c18f9cb14806575e2fb926b8f987668b908b507a0f4b9c53885206b793e4138f677837bbb3a0879f48f82c73a4119ab825d96257b202991b0707b139ddcd3ae98ab49ba46d2bb502f234532302d93ef5edd97216e338ca68fbc7cc9a8ecfc17a364d002b981a9dca442331d77f9214ab0d32bb8998febe745874d4b00d10cf936e98d168c9f64f2d26c220e158bf5aade03b813673b5f8c56bc79eb6103c5e2b5bf470b720b2cd76d2060dfb46da88a110d5e59b24ddc4dd55e468f893b3bc0e6d207eeb66bfca6cf08a181565eb48f7109e47bc3ebbf762098814c428cfb1e90af2515471a3dfd380d8ba7de650f17a177c6e48ad82dfb24ece79803497e731471340cdb4f980d6def63aefa51d1be012e3bae184aee79d76941ccacee90291a3e8c66070935a4727e6a200c3dbf7528665a0ee86dae10b3c3cd670f70c1694851f5a1fb3f1cc8cf622f1813ae7ac34062395c654f11618a86887711917f69577c03830712196c1aca68816ec6d34fcd34ac1947f68d46a4905aa38b80e279376d98cf5582a914357aef1c83f154d1644b3a6ed5d14a51cfcb68ea266100cf9edb632fed1ab105fdd712c0244be649a8c63b14fb8edd47ed5192ee3a967fbc1614fb2c713cf31cbf6efc2552007ba41a01cde46f7804a8a86d78afa0a067da5adc0bf8814316d6e7ac97d3a5529168bcd76dc401c2a9c7617ec78d0d170243ad5f42b8a680f54cbd085f1916359221bdcbcdb7065fbb4c6f94b1585caf50e4e12cd5f1409261ebfb7a1cd388a04c2a2bf01e7ce55b39d872c97d11f02459bc06a0ae3a86438f713781a0b5fb769733334d9a4a95669635b1d2754f0614763de5922ce9f9e6e762d130061603a986a46dd12aa03e98c53b69ba0bb9580f7c872a38a6daf8e61a0a9f272f38bd850a38111c6a63907d1363b9d13143318e35ef30afd3ed88e0401b750f8009b65b9ba4102a811ce745f48610b524f3a2c51aff9f82ebac872fe60c145038c2a9b14f5a4beea9ec67fa1743634f723df0ab2e1d3a515a5d2549aafa4e6fedd220ce41a5b9a2c60e57760a6ffb1c8a4be5becf25d6056dbd8b29f4712e5e174b53a0f2f0b758336d0d92f496fa43f643b6c3d973e13c880572a1dd1c142229f9cb3d29fea2c8b361381f18ffcaa42941606fee27d49a2711916d0a5b44b72e06e6a2f8b4ee5abe0c87f82a7cc5eb65e45f2056f0c3f05892700995e635aeffb3ddaea8d4bbfa7e243fd45c54a6b842386e58be3edd3d3b582a05bcc193b03f37087eebbb47986764652494250df0878dac66e2d4b01b4b53815ce6d121dbcfba8fc57c9d64256c612944fe3869ece7b7e803784af070cbce2485740560fe5b60eda38644e1fbbe64c78651873f997deb7d50db7ee7e7a32e306fe330322e0bb96abcaf771f940fcdf21f6d6167c80e845c5fe010b0cafd7e1eccd0cd27ed015233f686a0c79e28a59d9c3709585263dec839df233638cc3645935b40813de6c98ca510a8b808c180187b01067a14a0b871ae9e4470748a064202356c886244e0d37591f45a1e291890a338ee46948b047091d0e19f4525bea03cc819c7ae884ae3183e9bebd242523698d7a2f6ed809fadd7533f43b995c25be7a9b41b4e0216e8be9cd1b16de0ad635cb17840deb86dfdcf5f9fdb7416fdae89784bf13defa8aaa521da634fa0a97fa12ab51b4f952262eb0595fac99981e52eb63ae06e99061f44c3c9e27c44249daad9c22376467a0025e8db77f3c9219cf48974b6ed25ee15d28bb012f710213d1d191095ff20be06dbabeb4e336f7a6d2adb4e1ab5d4517f3991db5b27ee1c39bc732ad639a141db3f865d296b45fee612a5e8e3c75680b69bcfa467efcca8a22d8a6912594010fc781549609479d7edbf064addf864a676a67e2ac69d1224c8cfdae31f826798e4057e1ae9ec8058c2ad46f533fced13eaac5449fdf9beb6e4f2f41146c4794dd14fd37fd0eddb40eb4615aacf85aa5cc687cf12f1bd1b0af23e142eee64e512389cf3a222e47b151b8f498b5b6218d53a9e88d1b7c2760cd155aea38d88fb28d20b541aed74ab4f6d4f9722bdcbc447677f879550e0378a19ee48e22a346c82f2c5368a5c63228fe9f7e4aa55472077736ff445b21a8ea32646be659281b397c9b90fcade793898370e0b7f2bdb9b8163dd5135c5928f5ad8885b3e61f39413ad1ca3e42411d6bd6114e4e6e3c2aa8b8bf3ec9c4716c049e697c2a018a0d82252dba0f4428697cddb208cc8732577fc48d375e1ffb78af2710ff15560040dffe7c0c1de44f1f2a2b00f9c883bfad600adfe58b2defa9457611c815b4280ea6accd49f40b35684124f277ea352d2c3602da5b03ffa269e5dd90f5865b4eb6c07e1de8c47224b9444ff4df5d44107fa46417950ceeb53c7a6e7a01243b6ca66781bc53c83a9d758e58f3cbbd3437543aaf42172e8c8e7a0e16bdb0f36812d18a6ac9e1e5511d7c781c8132af760c19292c824bde55e1b32685009891b83bd7ec99a07405dd299f226f2e261a6339a5172076505626a676fd88566698ba127ef36340ef1b4144c69f78a6b987b6174ea4418e07412fc22068adda85d4f271225fadda5397cd1e796425b3bc3a6c0a421ace62e915e07cdff41da0dfaf9e60d5dbec48c2cdcc5ff22c07c53ce20409567149e545cd4737485772fb6637fd3d40318cc498b17f5f3bfa48925fbe7a14171cc56c803db23cb6e14309eba738a28e62e647c18e3f72a7dbc5653394f52ae1ffb3713e1385bba28a411b4b8b780c97847328ce31be16d73a51330ed146443f73f7d8ed3acc279420039523052bae752e4a6e8531aa2d074e719f83cb8651188327553b77582abfd71a07ec5b8a9cad6a1e7781308c88928c68339796c3c299260e1cc780de03e994898f2c9daed6cdddab152587ad97135c156ba09769dfa6faf21e82179d4f0e87c63158b9393626616e7e212b28634b76d3021868f7f9dd99b432f7d1cc4937526286bb2c7d4bee250a03310dbe37d1d41b83d804497c0732adefc4439f5dd51033d504995d576f4a0cb8dbb3917af499929ca84ab801aa1e92dc4593a467902598c694f28f8695f27402e737cb8fc6ed9f0eefb19b0a6a66e29556c3a88fce1c9b5e22d8cf331250de4dbe5a57546bee383b2f31c3ba1517a88da0f9ca22172f578112fdb9103338db85064af9610a5c83f5a861ed2d990944b4d0b6b5f1f8262e0941a6d49b4d6bc57f93ad3660285817bbace28a40c3680bf4b0d8d6c8a4bec1d9d532a3da982fc52d9ed5146c8a90a78ca63d93fd0bfd458df2f849aa6614bb773c40643deaeefc64005cf17b3aaf6fab363ac42a96a1893255e674cdfd83fcdcc0345206780658473473b2695aaef85bf090edc7e1bbcb3d6883ac5eedaa28458a6165dc910aca56f55869ebc853c365c15bc6470ac1e2bf6e17b1d31bce508d566ef174e7e03c2f7db3f4ecdc30d306e748b503411ec0a52d64eefc84f25547c371cb0a96f8e29a17eccb242c9c2acec99bfed3ac22a2205202104f92be574ed671e90b633e6c97fbf441530d5e818f8e78df670febe2ec2f74c885d1ccf4f9ef9b9c0d412e3bacc4339f84d67fcc5b3768c40977f6b153574f687e48e84ea7c9d742327220fcc688364a988c29ef8a0367bb9b4ea770d392bc8805c23864fc428b69c65f16ed9265ab75462b4eeb84b1950297dad5e4131538ab38d1eb6a94c73ae09ded53b60bbd8abb5cade551de8dff7f37bdd9bf7493cfad156766ed7d7af801b722fd136139727971c4d8cc251713d7ea604916c15af9f324a605b6003039ec6eaa78c2761587283b066d033ed69aa0f82d873b7fce8a98dc8175421b1192c50eb740d18d50d0d883ea039f452fd733b15c61be5a2a730002862807e820ac38dc7475d07e0b59f3540b0e2b93df849d40f1f53e27ce141b3b268b44e2a989723f3850b7526e9f161409f781d77f0adc96cb0531f84d3e9409351f1cdc3ad20f0a23dd7c44317d84f6afc3492e87d1805050493cb678e1d9e6ba3ce87d7a916a9d0c0537b9aabeb7849f967ad80b6ae414233ca588c6d4b726278b8ba29669af899a46be222c9231378433bf628d076c3ad06eb03e28e8650a57ee963337ee442877269b861a980e7938101f0a7698ccf7f221b01c2a903923fe9c74cdb08f31d7a31f8d82e73d0916256472fad0638473b317c7f0caa45dd1791c7e82049578398e5a92809cee527145a67b11bb42aaa5a0bdd0cb8b10deb813141a34c59e27c29cb0202893513b3cca0608ffd3d3ed5845bb1ddb0c4377dfa54bcf8e6537dfe0e1fa42c375e54310dac7c0a1a348aaa8b0c91017c44850e0a0a9cb3ad9cffea04ab5f022cf807c267bba718894295508038617ae98cb2fc5a7e26566ca459acd72561a6c39b89478a489e0841962f60a91cfe99a4198dc844f7d5343bd43df20ba6d2d66e454928141dc30bbbb659c11452b588c6f73d26721c0be5ef8dc4b15a33e965a59352db9f8c033ee597075f3598d2bd6aa5e30a641cc3355787f1f1eb9a6bc6c653287a09f4d3efc983fe25776768b79d20afcb7f56a6632ae7b5397e8869d318d17b1be65bdbf0bcf2427d0b1e37773d69cc3aeddba370ff8d2302f28830040fe7920d26ed5384d639c7f7da657622c4d9c60ed85dbc866adbdff21b4d8e6ffa3919046056d0e7132916e700c8140367231b8e2c4e342b2cb23f2d62a89c9a068b7d0b40811791eacd2bb0b9f4b45bad8bc76cb7b34a356f13e5bfb1814744365c0c75cd40b8db599aeadf511497a0874d41250803f503c0b81fd7cf6158250737ddae67356cff147396f2c00c1369ab57201ee0ba90ef7f8e2743769d984e2d99b621aa0c1674aa5fb74584e227c88fe312daef584d924ab1e669799811c65f0f5cdd666b392526578e9056e158884447ae45c71eb2895fae4fa67bd76e83463ead854a082fe9fcb129e7e526a86c8ca2e5183cc7454b93fbd6573f100750b8f500ea183d1fd8ca49259b0aa446ba6ebd4126c42532cff63c9cda4d1a5973b8f4972086ee03372c89986a2519ffadf6570a31582ef8eae89fa503dfc0976b2336b3f7b307f5802eddb549567e004ed61294435e5c709a5892723c2498f4ab81013718a2fd25ad9ff03f6552c91f49458ffefa549197862f887aa1ce45dbc965c9536c2c10cc379077806006061e8ad07049e88aba25699318a89a1d146dff4811dffc6686311fefcaafbf7bc049448fb4da72ffecab5b41307a635190e34db8e5bd72dbb17f78930128247bd8af59003169a8638e2093f2a7e54207191bdabe68994ee2046c0ded493125eabd67999713e07549c2af3ccbf9c2876550064ffc05d93dcaf1ea1fbeea79a18bd06eeeed77746c164bc03253403c17e74f09e1da0e68cc021390ee57a4221b10179c7cf999793160193803dcc01c8e78e6a58c865a9a76b53cc4235ccb53ea4760c3f71ad04bd529d37257aa608fe83ed7052643190a5ee63cac7361558d8d2ea324208d55c095ee8779eb55fdd0cf5ef19de9aece8024a1383effaef3a42e3ef7cd7884b27e644260eb51dff2c89b680377d3b7272fca79f4f186334f23d80d190c50c7a5c4cb614812583ca689e61084a84dabab7a487c8b9cee0fec854ae40ca966408068b20b06ec72a9c9a945b30759604ab63b1a72ffdbe0b576b5f0083e71391d6d61e7546cad82d1e252bb4c9e0c78a5e914e3212b4aaf69dac8b7bedf1141de81da444dbe26967ccfd50865a37056814c9cec53b3085176b80f018788ae929a43fc00cd1d75f6c1a5a787e238ff8d3064f5fd252bc121961c0751c08a59e151934ba988911c3790eada2c354d42470b7a4edd0fdf70d462acba409b593a75f9df271a8ae2b8a3fffe1eed9f6a0d3b8996d460fd9f56b4687f4b007fa660680682e608a8eaaaba94923b627782ed733b9f67099fdfb5ede88b6080ecf2f1767f2062f159059d9302164cdc56b8514666cc3b30134775bdf8de18c2e58f9dbd0e4145c1140fec051ebd1e828fd1148f783d82ee3b884c7969282009d0ab632d6b24fcbf07bbbaf72a2e10e779e3bfd820084494d7105b12e601ba886ab5c1210d39fba731c0df9630cbe37d8f25ab3b1f94353759597e50ddbdd3d0927e78a0f7ac81193a6e8261c6330af0d57e67a7b7ad257d946571d48783171288c0047bd5dcb8c4f3bf894fc129827b57b648d45572c83ce3d5b5f214e9395be71f8844c02dcc8ba0b983e7dce246c9dd47fcd33c493bd586b2ede36627781535b3860289bc0eb7dd0e879bb9bf1f7c222cd829b3e97206cd9df6e04a24bbe0a595098a760eae7ef0680426b1edc1283247e3970d582fccf2513595dc6a7599f739826c37ed501b7712e6b70e94afa1af7c991bf1bb430484b40d41cf89cf8ea20e3801ffc4426b330dec2df1ab3af7a7123b2ff930eff7de87b4d15e0c3472b1d8ce4b76198b5ecffd7322d2263f0007bdae1c02519e82b275cf79d94f193c1537ccc88ff7cd9cdf7031b5d3d6185ec692820256111b5063a1565ecfa4274c97c0dc6c8735c098d52d8bc41b2089ddbd6eca8a1ab9f66815bd2ff4bdc15c090b1c2ab40e26345e46a814a8321ee7bdd1a5703add443d86760072d5fae6b78cb83f33eff5cc4f2271f27bd11c8ee2755a7e41ba27fbebdbf6f230c077d6d3a9092a23bed1473af510d1444f341e469e397c464cda6aff4a682e7925c892b894182155c03a8cb45475b8ca37b3d707f83b1b550cca08876f6524eaaa22a006920c1ecbfc1665ecf8ea169033790acdbfc94bd97576b5ce9371963e9825b0c2e497dc98e3134725e7377ca4387f729604481a9f1135f4d39fd3b352783af9e3e6f465ad002926d33a46def3775202677bfbf02b6da7ada81ccb3a20518ff7d797e0dd71fb8c70b96ea7b6e61825d9a6f9796d7ef84cf3298aa4aca005d8edf392a48fdeb8b0dafe68dabfe377bfe006ec65387eaa33a2b945958b31e48294949862b1c7fd663f6627249dd954ce97199e1d91557d86f6e7063fc2eddb54314bb2abccc1e63004ab3b7fd1df8cf83bd08bfc4def940bfa4983d39d644bd27c213989b9c77af98360366afeb155d14efda02fb284779b9478092a0880edd5bd84a29379a0d9b91050b5156afe92bd8cd336b23eaf73dc1e4cdbbbbf3bc7035453d61db46b2b4d7d4395e51624530954d0fbffb9fc2c88dcc22a78c0488cc28be0e3544269d8fb397582ca03c3072b2e7099b51a31183b10dc70e29a9206073fc50610de18082b4d294dbb46f701375f20c942c82722202fffcf7bcc7e20a83d6df7afba6271916c4a908a44420e4b6bbf324babe8052c6d8176bec25994b3edaf9caf7f15f206e1a1666d8ff5aca26fef784dc460016e8023c7103a73817269c6ab6eaebb47ae96e6dea771908c4fca351efcbc69af562f1d211bfd0ecd5ea2240b08003bb596b61f5fb6a781d681fc1f824a5caa0cd54b8f5062f2784c2c4a8d0c5e07f616a372c1e2befd171f7fd91efe155aee4e6b8dc6e1fb4db97f7040cf4a8b4a9e20a6780b9be811c7adbf56caf3c5d344b7f90ea41674fe0e203dbcfd891571cdb48c579a777964771e1fbd83c64110232ae466d45e267f3e6017b2d79c926d300d8f4e5874773500085d85aca4c19a2490a5263d1c1be8820cec0b050b059e9f36b976131e9fa24b84940adfd0d76a3391d33d582e6ab4d80e359c8692201da3632879c702cb1c882becc1ec163771f0d04bba68ceeac3e35dde6a625ea755336373a6d5fa8581e9412bb1338ede4ca65d78b3de9aed6850006a97363984ed0850fb3bbae1fe413c68dc19df0f08a8198067b04a329b2b987bfacfbffd4b0b9b8714154f0e2dee69e0cd03ae92b238b1c3c42ada8b55eb3a835c3c47bbddf753c6e03fe3bc3bf61c558aacea2e77eeb40abaf19ab2eb2ee9e6e5a71d849e0c2220810acdc7f9ef16e25f392ad7df4b7ef6ecc05037fe95dc93641c28249eba2b5d741c8eb2b57b2e8a3d45ebccbcd4e6be9d3d7fd980247cbac1672a80d63f0a4d2c9864c9d71192bb49743a8d80047a63d8517b9e4db508162ac1bf7459ae2e4ae0a3ac5157b36d59cc34a971de5f315c8957926611f8ff67f8f5f8b9a04d8e0d5e46860a19637402ef036c1996cc908c3feb791dcd74450cc8faf7dfa8bdaae14151103674f9ea725f6dd6c780c416a321b65634ffe3e80890e030bab9e42ba8884c251241ac5243e8574bb8718dc56a4e36e22481bbd3b7d4782c17a9fc155a55604a630224ed1788d5ab9b129db81cf5c0d61adc1de92a54d34fb96f9d23b2733a652c0a796d9b24d46233a72d69b8d304dc85ab2ea1d7cd1e352b23b9bb35b58ec85ff6d0a5f63d05820361f97a25f35ed6ef090b3027bf02cdef0115f97a3b429dcb1f0a37fac3f3dbf150a9f664af1ce38d4bcb3dbf5f0481cefb68454c23cd86009046d652260eb7c001a6f19e69b74d22fcfbddeae937c3dbbbcc345e6920ff2bbdefe04dac73f1ecb2b9dfcffe3c2980d4bfe7c089fc8fa3dd71bfa26e09849af940ca1fb721f9c710a6a1564fae1935581695ea2cfb3f52300d8bbfbab983e8471081ece682a17b42a211e2f15e89b2baa55159760183b4553d4ac34c7bb55e7a352048d5e4144b9bc7646b99bf16586800f9cc2f9b394ec30461a7cc66eca1158bf5da9b09cb11a988323d34c2daae593664e214131f2c6ae07e96d18000e1f0ef01c5a32010bbeb3f0994b7482a7c9460af4e3be49b879105c4c5e06ca0528d23bc0d650f79b14bc7d58d79e53ffc1190f377d6f8ec40a9992a2cc4ed1ffe3b21c21f22194c12c3a25ee7b31cbc1b922213e93c3371a36cdef0503bbb6758695415d7de431be104e465e4fc6d0ffd381adac35e5f1b025e5a46d2b354e9458c6d933d2eaaf87dd47638f1a3ff26077f302e3b3b78b2400df26be407e9586ea8d682ed18cff7808b283f59537d67cd4b088c8641c151e56cbe7a44caffb4f7c161874a202a240550c076a2242c695b228ca98e674e648aa6acb87b4781506c59b99c650e21290cd39e709ce91b493d4aa4a8e8d29089c19830a6ba0c1e355651a32bc363f389da11801b6c71f3ef00715956ad320c720f757e90952f92627a0366b43ddc33089b2a7b64a756d96bc04b76c05ac182ee8e41dd5f11d130897b63a7108c26eed383c8cd4ad29c6623c8e34da6354dc545564ad5a935907138fd592eca5e18159eacdc68ee7ecc849ae1b8472482e785f7d948bb580cc2882bdef8c05f82866cc25f7c6ca87f60a76f9f79050e5580da61b1fabd3ce82ac99f2a68005a374eb2c6fb842f7382810e5b7f19d1e313e193537b2a4638484b91cfedce92c571c2586341f20fcb417d7af8a03f62d64df8f80edf64602dc3ab49f8984d4c437c826c711160a4b7dab9d9fc538c1815bcd4e304a066468b197491dcbd37bcf4bf0687267341b0ab56532825fcb7223c13f95244587f2444266fd7dfc7d02d860fff6fa0831651a2b661f5312bbf9340b256586f21b22956d8dbd0c2cee2b804c64beec8ea05fd66fd0afc981d5a816a496628501bf5184ee9835e548fc2c20cb3c5ca9c3889f307de89794f49b26f0f509c6fefba66ed65fe96cd5886e5e561ff6735b93f86192927ad24cd8c76137a12cd13d2f347c88f65fff993529ee438a84a470f57ed63bf6b17c39c93adf918870bd7cf61902a25b60f9db8cebd5854dbe64065e6972a4eeec557fd7ec4f9393e4dec5b0eaff176695d12c50d953b392e8476a394ee11117f18eb2957da97655d9483652e57ea35885146e4f52d2e74a71f16bf3ed0de8d8ee38a459d78b3c45ce29969da3e6fd8e5697c2b037bc4477ed12fdf0e970cc9b54ff442b006a259d6f2af50750e00dca55508381f14b498935fd44587778d2edbba3ef506111fcf1ef2a37fda4bf19f512876d28cd8b3bbd59bae205399a73a93e3098d95efc239a71e77294d9050a871f7e52f72239340413b50038641396b05e35b37b708d379a0469b60809c99584375aeba74a382972765f47b71e986189c8831ccf9351ab493bc492336e0f0a7fb227c92b39124112bb23950c92a8e25982ab29f3f9a8d9ed47ed1c549b8e24f510db34e0d18d1f533f63acd3fd1d476d4d75cbfba31fc16f501803a15221b0d4b66acb0f1a8ef24a5092f4fa3ece220f665185b9a1043c6d8841e2241dc28961487be89aa874aa069e5dd309004798a6a2db4ae9f9d3bcac3180e032c10aafd9e1604959043d598c0fc3087706a9f91f118a594aeb1749f35e27070f10d52e31e47294536c8a33f1f2bd550e647160403842790e7326182aa0fbe7f62b8433baa8ddc61923f9682a4e2abb2714f0d751e8e9e2efffefee04eb570cb18a63e1ddef82f111ebadc49adfad0d72d818aa4307b761d3d15eb7b12dcd1293404b3c8c9ee31c604a3e492687b02af7c61faa86a3483f9f98e4fa330f7da117a5e0c025c34401bf290ec6f3c444a2eaba6f58a3c308f6f1bd53276c203b606c689354e4b31661319426046d9efa93a0897c3db739ac73e0df987a85c7ec0f97180ec594120538a395ce8e250f523a651ae7df0decffff7482bc44ebfb343fadac01c1fa154832bea8604811ca826d3b0be921ed956fe96a05e28f80ceade8ba17cda0dfde30dcae28c3b2b030822489680609db58cad79794b356092ea2ed8f6bb72803b707cdde7cdf31d69d024f58db6923e7f423770d495c21933c1adc8fa3a3d4bfd46b8774af2579eea584251681e2228ca877619c7c9014f3b8ebf02680ee83d4bc6e8a86c4f2c8a224c98b2d3c48cc742e22c9989672aca144056c709ec22ff38bffb8cf6d5bfffc0b0c75733bfb8455c6f83bb6505267b90f2499fc871d573af8e1709ec9499100d7ccaedfb33bc406d1eefa4e03df58252e12a342c4b020577177a53d07cf4bbe866b8805c44d30bd27e8571d248dd3067a60fbbaa00a19a8dbfc0306cd16f48894af99e9d40cbd102cb0c53337dc6c4e9ce21238c306b48a2c404ef683de65eb5466743667ecef599d9fe09e721053c28418ae5fa3b020914e2418604fbbfda9d269658914db9fa6c0f71a060e07423290894e16d19642bd6a65483127357a65dda547e81be10dec56fbffb3a65b312a526d1e0571366e705985f35cea543fefa0150c22d3843081bbc4c8f7ef9e0b34cc9e95b27590fdee44511e3f6bfc74a228cd02d0c078dcf9650003f2349bef571c2f1fe55c9e0d89e9bb1710f54921fae102a102a7d196912911081a77b4d08cda2ae6db87566d337b3a6842d94c760cc35eea6a150737568c7dd35c57f832661950720c59df2cb33bb362df76a068af4e49f882839b7b0a79317000efd527687d3965075d931aaa784451cd643e521a1368ca216a6a071e8442703d0f7d3175a67ae64240640fd10b8c916f99d9212cecf6ebd44c2afcbf8a57e4088a705e0317c48cf40f3f59e22c0821077ae329d20d5f8bd563b3b1a944753bfc5aed2d7d80754b193791614db22369b0e72a0bca685e3d9d805a7ce8e9a59ba5894a96ab78d79a42f06c11376c98c8bd36517fa24b6b6d4546ceccb4c6430c5eefe752ae80e2ad0b7f8088c4f8ff320db5d00f41b7e786b73de3d2cb98376324593c3f61be043c4b54463e8b81fba2b53b0848d9e72ca1f6b3e5681e603487bc0aad2385200cfae1a455a0072dc7c9f91a5c2eb33432056a7046a2a13eabef37b664319ec3c233c6ca71be9e7433644314f73d8ec41949e9e8fad34abcc90941be29079f25fc78bc8627d2ea1e08304ee5e1336402f4e7b77f30a53e25c9309d8250eaa06f742551ed2c88f9ef5a4cfd164a27af5a47846da2156b0cda3b617424755e6e767b464fd4c8c1a3f7e11ff55593ff61d3cecc45ee6c5df7ca73ae23c09a611210cf4227a833b32e3271126295fdda12fba17f40452bf64395b9c3d3befd07d89a87607c9b9f1ca1710c1b2cabbe2da3200211c50708026f8ce501f90bfecebbd8b43376316642103872ae6a794430ed1ad1aa46027ec0679eaf89b5509463c8043a74c157797950c789d84931742bbba74705bfcba1166f3a8bbc18e0c56d012c9575a3d18994112045520b4f0a30b0adc6701ba34d1bcd203b1720a7705a31b3dbd686c5711989a544bcf768ef8b707810bc6b735b1241591bb425379592bf5b773e14a3f7f9a340d5f0d2d6cd24278fcb86b1096d56666e9e53608f744e6adc15e33ca4a8f65216db61e71876281afd4211b45686b742b031ea503ac5cc2fda1a10faa902cafb1c5d21eccf8ed96797a636c324bf2aaa63dd0f6655b83734fda6cb1e2c34d83e3a5f0ae9fe8fee6c5186a45947710bcf203bafa1470e9b3968232ea949b3b1bbe367d654b03fc92f87b59c9ab9feb9bcb1a99e132e15c467f2f2ce8a8285e1bf3a27db859bc710b5b8c9eda42ac6edb7669293f58bd7e7a264e42242c50b5f9814f06accd2ea1ea90240a36b43b6820c25b451e310ba610e87b5204e47492102a74f73344db5922b853278057b3ef5e70174c5befd593bdda4ce1585c64c2fc5708a3405851830d67e236d37b9ca7ea3df501a2333904f290f8e6aa6617fcd5ec8c6ed91b25769d01ac898a13a96440c823ac5de90ca89276c086977594ea95d1ef640a9f1bdc789385345d75d83851838269a77ddb66e3d4da894a12ef89045664f42ac3004917327c073d2adb746d8e67cab56783f6a4549dc51dc97a71d5c5d62fab2dbacfcfe7aefc3af693c28ba7eb79a1664cc49e0d577ff53074da4445da50d02bf7e417e580091ca46ca1852e52a73770165ddf4f4bb57f8572d0a4f5cd46d65a0c2c2c763ed7dc1125fa5ea1688452f5413fc369e519570b9bf4ab766e90d7e8ecef79afbc275c082b1a69e3db0378875ae2287d7f4ccfb3859433586247e48fc34ddad422fa4b45a3ef9951f3a899148e321abb616765f05ea5ccdd943a2d3cdfeac3834c30f54f479bda107f73ae6dc020200115e11bb236f2b27fe8d763a11038bdfc26473fe4605c0069bceedb7ce96d560823604504349659266b3711d17b225716d82c1f34a289a37594d64446ffea6d0e19cd8510f99cc23b39b91f533fff3ddcaf91347b4afc81370b47e013e9bc61a4509328de626e9dbedb50c20e988563afd93a748f9afa46a4fee4a974b0d9ea71d356a5735d27241a5587597059048b539065c426c6b5a702bc10f428a9ccc2665c5edb16d52e1b0637e92192802f1a66286f2c6d7b0bbedaf6110eb4115c961a30447e5c078982b47ffbdd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
