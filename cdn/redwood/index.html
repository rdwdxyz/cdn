<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b4675994d1ede2b1192520e96a2afab2d9906b217cef3b66f89cd0bfb655feff138b34c43e1c59f82feb10d3ea248812b3b5e4ca356c2b350f249bc5e9c4023ddc53177444bd85ef6d145bb498518cd457cdee7a09e66fa7a1ffaeca447fbca22ff6bf51e77a3c1e487b0eb79c6cf7874ae019425e1d468c77187e1c8c5e11f70aa7199cc5987c44b5b1a908529d40a20f0f35626a92be9762db42a6782502054350ecd592a39460144e85ccd0ad17a18a60566aaf121f882596cee01ba81941ee6fd014917885559845af1afb9e470205f0f4f89d4363b3819006893f6c2636ad495cb10afc80a89a565b7591d25c1e990bdc3192ad683b0a8872c8e24447f9c18ae59f0f43f202e62b86acdb456f1c6d2297656482c6dcdb7dab4570d4331e26854d929e0a6d9879fa857cdccb66f00c20d76db3ce6031e5aa4afd670fc0598ea0f0dd7cf5da6d67af17b58fe0a400c46a8dacd2450e75d8003091f7922fd032442f75773c785b4a9216e73a3c948a4c07c9f37cedf255e1111aef4b3641b5ffc356930707a8eeebcbd0b47b3a110dee574abd05ca885c605fc41d2c05f9901677f34cc635a632abcc67fc1156b85fb2750a3167041a9fbe9a84f15e462f9ce2e48eb42c0cf0d51d29caba64b5ff77bb3fb007a81cf6be166b189f5ff7aa74549f68e4e5b2de110baf761f08fa03f48f1a6560724b2d0d711e82283c669f07462be46124bafeacbdcb57a1f87899907c15b15163ff29e56f256d82dfe4c557fccfd3b81fc0b026722d1c296fcbc2a20cf90809cab794ed790f653702ad8ee4d5ef948e2a51ce8b63d1e7adda679b50b28a71bf49bd05520fa7b9dace23d56d9b4194745ad1f19f2f86e8d881cde2844e81863bd990ad74b4b4c20910f6cecd71a0744e7d8e15d2ea54de858769b1ad5742752e21e85ffc3b0455c4015a138f3a9725754c3e2768e31485f23eec758a2d17af576d6479d85f934126c80253b4fb9dc2fea399e87132bec147edbde699740265e2df5656905bdb946e888433929731662c96d449c81c77a4bfcfd98b9ac5bdf1ca397df8c6f154dc235cac953751da8f7e44a38987cf2b798948695e70b494ddef31afa7ad5ad9ad2f8b8e9c7eded96c2d7ae55a80815e2ce6fe2b6b89da32cd0740a9b7fd26698343852b5b5a129c5be48c9b9f8842d34375c4ef1a4d9e18a8109b980a1a50ae65b2efa61c503e1ece8e1d34e5ac131b1f8b6d34fee1d822d0f29895bb6382ddb6e21fc6d8a3702fcf990683f6236b366ceef8fb8afd7eb35ba6a8c002b59f84ae7e44a6cee9bb4e32f70a6318daa771a1c40cda74e2a81222628c827e5911ae2df72b68df090e0d877987bbbf1cfda1cc169d1e7e586a72889b8b8a3db95447d9731bfeb22909a85d3d50a27e26e2f211f2b6006cff2fc1565a07be7f54e1cec7dbf6b76aefdf1f5b4564434fd385df0edbf9dac0334c94fc0c7fddc4d97d629083a632f67065d24a10e5f2d415cb82122c7c21f344a421d186284ea32281e3c32a48f68729a93539bde7312136de4ab999a970ce8e7c45e71f0cbaad55b36275c0c4e0c55c26e553ecbf1b0e51523cc526b5d73c0bffdf3cba63f7d7dd41f5c5c95ec1f40271f71f933e15731d43bf07eabd6af81b11f264a7654e80c0272023612469e873dc76ae7762929afac7568f4395a3f44f38090af6ff0a766277f99cae686b00ebb8b906fb9ae4dae70aff9f6a724b51df7c718191a9ad084d1b7ef9ddca6622b74382d98ba1a37fbe049539e12448115e39fa3d9abc8e533e6c9536b1114d9bc49822ec8e4bde1f118036466ff24f3b8e72eef29ab19ae4665d21bbb8c43b018ee8940c08a05a7bd898120026e2f89e8a096354b9c2ef4f715adeac56d572c4bb4bcb4803b697d35fb7a6d12fd474611f86d72761cd1a64b3f7eff9400072aa6b031ea89660c2d787d8323c3605becb849deb6439d6794426fbb98a9d648638ed16406f68f5fc592fdcf8d4653716edb6b567fe96537aa83e931378b4b6bb7f614e43a5ba4103c8e9bf40e4c1640767a41c6dfd0a89add218f0a5e1a905ed0b040c16ad4938d4a0d6fdaabe031040ba109da935f63630d03ab025d9bbaa76f38d60ac5eac959aac86959b17e5b750afe3a29e5ca0031922a6e26c88831fa8bc7c2a3cabe62504a8a67e62c0f7191e91f1b355b073e0e0e9ef280b5188f03c214f7bb6f615506d2b1ee0267fcb14825e6655c9ae69d04c7415f1a5b47ff404582e29c65cc70088ca1f0b08fa17ca20924deebb73eca22cf6bd771aa93c8decb6749787b2d6031df2cc56b1a4cf484dcb8cfb337ebf7e28330a9ff41c1be6d9f1154a30d9e3d71ac9ee931d54d579b2f69b342ade00d10512dfffbc766715ea16657cba6fb8bbaecee8e436401aac5df4d776f16fa5225c2a5584d14811edd487f09d8b31670ec347c71e7d9a8974f8fd84fde9980c3d08d04b135c33743ef511621a2b21490fd552de4442f4019a1c2741e176a3c122311abf761fe6aa55f35a35ed3eba36182e591298d1958060adc3918ae7e0c2ed55173cd6ebedb43aa3cc1462734646fd74c1a00d582793fdedfbf395146d72f66eb6b7cacf14541e51ffe059799b2e668e46a81869e826faa1a5191be5830fbbe0d86a7345d5ae935a285da04dbd40f39fd17b7df0b875ec20ba4020af82d0ca23aa50aabd70a4482376ade2c40d6587103fd389bdd6e8eb78511e2505a43796df5c9dbb6c4588f3494ecf990b75752d42434316af9b03a50e62c61227cfe45f32292fbff5e9b400a1168547170befb528cd967ddea4fb31714567ad59872848f981e5fc023dc177a9311ed75e845acffcaffe4264caf8ccac5e644da56e64f9eb1d2d133aab9b9896a99541e532e505c23d708d379a31fbc96eaf51ecf163b069b4b7336a29ec6f0ecaed798931098febf83cf9bbf93da984a9014a0a9b063af6628ea99b0b9ca78b0e65731c1cb8202ffe16264162655552f96287dfa586dd02f1742d6fdcffb22624a66d5bdd2e8fbef5c12563d02a8648bbe3aafac36d2de115154a102b4ed163ce29ca446f304d48b8c6a648a89eb42e2029dc9b0edcd3278e65d284b3b042d4a95845f946cb470fe0d8a00dc31ee0437955a05400db89295fafc44ac95ca67afcea6ac7fedf8154afc857960a4eca8ee8be995b26e8d8e0e6a0d163c130754a3a83dc1ffb4d1d8644ad3d41a8e177155de7920764220c9636dadfb0341135e20bc938d8446427ec125552c8f7a2b4309ce9070710984f07548c5793d95f6bea3061fef456e8a9edde7a0a304bbc8ca4be9cf3a97463a7936ee2335afdca2f3a94456ba0f258242142b1346475b17ab58363cf76cf28d23425eb3b2726bcd22aebd9d53fc95b54a9dfc07bae2f48c252d2bd87ac93b7c1db2013c474fd25c9508acd808925ffde71c8853ffd30b216bbe899ccf8dadf166989e2c95073e81d54da0933c8aa437a5793db9075ff6df84345a1a39f8d239f47e9bf6f12e1d498be06ee30d76c8b8ab5428daeb72a108ce94d9b201ea91dcf2ce762077012787c0a036685f8005eef99a1d3f28b56023b58433bbaffd8ff64b13bfeea42a3d47be491b9832aea0e185f532a240a6499cc208dab21bf587eec5ad536d8aa4b607506cbf0dfe66c74a787840d0d8b26f256ca3473184e304eb9d8ed784d6922080fc8d792b3e866b0f233ac05eacdaf66b3595ac6f9debdd34d157112363be987ce10903f60038f286f63feaa9d2399506a5d1791e88f39337f107175a7c2d7f8b9df6de16652ada70b14d03be65df1a77c7053560a291dc014266a232783f257bf3a993acaae451a1ff6d7988fa8df0152247f1d8a0f938bf4ab43d16abe65a6844f19ef9715059bd92ce8d693c20161c664d6ba2ec9cc58de1a6505ec2b104154a2c5bc21d1f7a018f209865b616fbedce8e60362256e622e669a00ab76976e54dc8530eb4425f647f10928f05ab2ae0fe2dcd9f6183a413b295fcb000ee3d3fcee35dd3a590e46bffd0e4bca5b643a4f6117a1e8a8837ee5236a77f7aac9e6aaad080da0b780445ba01e8afe6b790349f8526035a14e1491922b2d44fb8cce9d2186f0dd67ce772cb722deafcebecfb72ce52f0343efe2e84d6e08e0d08518fd6ba7c78ba208916a002f8a672e19c6de94b36a4a1345007036cdb1692427cf9d5017b80cc626f9159623ff227b802281adaa7fde6feeeadb5a0f95a27c6ea9c5cf48e4a6d74f4b098c61b51786b1b1b49ad0a546562bf6579c7c6ba99d50b0548857e3fd53688befdd869b22f29b814b5ee099b10aa957b763fe785ea30d3525868dcc9828ddf840132ab8225c2eeb2d3522c7dca73c3b5fb77f5e069b9fb2227552d3252269b5f3bd74579ed28d39a468d030ee73e051248cedb7fd371f84813b5804a01ad9134be969b5f80713cb8659af5742172f4bdca9bf337bcedeb913fb6ce359741364b1e55d0e34b3e23cc082b1d145ab81e3b973d37d79da0e86784518b56fbe26240853a2520c3c30e8f1cdebb894b0113677b53f1e913712f520f9ec5c7898eba4be9c8a25e22646d20663e7af26f6487f2dc1a3cbbc769a803d14b0fbc2ea88d90a82251f5e84d007e5f48fb0028ffb5849e4acbf2af068dbe79d6a7acfdf99267c245e19cf4cb1bf36dedea73cef1279d857c79fc7440f5a685a07944956498d5ed67c8073e380719aa2742b0df1660fe55b3dae9f5b28fb00feaa593f033f912b6c436bf9ac5b69d20f360ae278cae91a697fbe9c30a77555dac135e26f6f3643993576ddd7eff92c6a6d0601100d78520dfb3159bd55c7eecc366af6b4f3ff6e018927a874a251cbe7db8534bce1de7140369d277231da676776d082bef833b099e1c9f9acacdbe7ffbeb74437760682bda0f99b0261380e9d8c773afe5ab6973343a5c9d672ffcc52efe91734556b87a2df1374853bd9e5d86cacce314bd75df408ce2b9da58db6a83cfee3d02a8c28052b0f45bcf099d6b1a7277bef1034fbd3b1adc6ce944f0a2db09edaac81b0361f2c50c5468c84105818292a0544487904ec7255747fda9ea6b4bbcb9dabdb2f8da02e04c871da34033bccb2d389e8a7b4ec12878065dca6c74e19b96d30c2013b1fb94d1d89f4cece16fde6205ccb1d2fc38716728a0907caf98ba0ed7ab374779c3f14b11c1d80cb77fb3eea76510c99cca82bfa3203bf00f44fb52cb25038dc934eddc594e8e481828906245f9ff185f2f5c6ae8869e87e8c7ef880c151336b3e5ffeb5a0604609464dcfa1f59abe263adb665dce7cb8927222c6cb54e060a0231b870b6fc7294513f42f8f4bcb6247c095a2bd84fd3c96076e908fe5f120a9fd85889755ee25dcf7401d200e1c6596a226d598caae8e890c41f6365d02387b4b9bff2443fe2873ffa654b2a7096f4cccb00f075df1aaeb2404dd7399ef23418e452705de4198f00cad48bebaba0f6a3270d29c7aff9e4c3275877248789f8f622b17e9f059d21a0aa55fefd96dfcd6a10d4cebbd48bd33c3527ed9379d2f6c7109d5296ea1abc028e7ee8014a60ba052e49e5eb24466d0636482b562318b2c5ddda313fcfc1005531daf9ef67cd4626a9091e4cb8df52d7e13ae0babd91fb234e16ef716f758946c06b06d970f917ce9c944a34e40b09e765b7407eed7ef5fd08f2d415aa74a8c7794a96cd0c6bfd5c06e18583dba569a79d02c607c3a7b5e96b900a1b30b1dc6d1029e50124d05c42a5089ea00348261c1bcece87a202bde9e3bdd1fc1716da697857f670360fc552c9fc8885265bff54a09df156562f114a848f794ee720aa8ae46d0e4a6142ff14911d261de28c3a9c899b299f657fbcde982d0f01cf9b74cac1679b6acd1011bd7026b63fd183c4b96a83c913a5e62a9f60de91a80ca4a5ff9acf64b634cb3b55293c1a36837a1f67bf7aa90722ab4f9b5542e6f604cc8429849af977ded14cb63fadd53c95adf0bf4bc81b0e3be82ace9ec52a9e076fe1f52a8a463ed7e5f7ae00501048b190294f61f681d07f74f6a49e8a3168bf5d5290745c9a0f9d5269d4e5a20e7f71857edbca1480467de507eb5df9cdfd1dac817611088c8ac534b991b7fe99b8f59976175edf9253366170270323a22b640e4b3903c3c30c7a4bc07033a7ac7a075155a9e0b542fdd28ff859a491300e51e3398b0b4f915266eafcc835fcb402b49d47b34d6b533d4b7fd91b11b684588927d148bc59aea2fa98d6d881292d0b2484fb7603723e7d2dc5bc9787487ffe89378f18f4954c3aee22c56af798b7c2e5817951437c9e04299e226ff7a5332b95ef69975bc8cc0cedd1b6849b4aea763706637c297e3c51b8c8ca4ed9137338cdc775890dd62b94fdc7652b23c6849819a437ca927206d3946c51a7a04bceeece9a909c6207ca017d3a54e1b4d6bb8e72202b1883a7d0066167f19695fb711c797c286cb32841f2abd06126339df0facda4b615f63dc08d409e629ca2b6b1d45e021b71fc36db54e5a358f1fa902b85802fd28c68a05a576207a0fd6f066e4f3277a57a3fd50fd5b32a1daf7eeb0d3e63a81c97c1987b576aced21f848f686662fd37bd66e7b0b777ef8f7446d58e90b4f63b6f02f258a3a51280a86fd753d13bd4f41cf8fe61158071ee68b48c0f19c1d912ff32191ad446954660d5cb9998dd44f1406678020ebf9f25afe1e5d1397d60dbee7e7b4b6f91bbae835aaab9dc5a37252de11655dcc209caca105517f3f7351789caa84d0ffcccff0ba0b6f89a8c457e02550eaeb1d168ecd263f15ae5e3bceede27ab52f9f05103870bf440de71ac4f24af994bba3d82a7c9c93c0e1d7fec30162cb725ad7768b0a15338f28c6fefebedfb88726cfb7f124da36d08a8a1d886f08bce76d5221dd05036b3ccd9c8406984bd27b13123250d8fdfefa8501122773865ef0f46c56037256e31971f850c023ec369a4d2479a54825fe7e59a6b3b2b185bfe0b9db72a2267123b989d1b97951fc1d8895f363070090156e2a726cbda3cb12456bd9e1556789294164ac7188dd9ce55d658eb4f60b7e1eeca717dde3a6b4ac3d583174d076c5a141e2e5bddc29c2c96da8bd129d9628e872a0abc70df58016042564ebdf2ddbcbf0368a4a54f718598b8f90b4f9d386b1169f0c7f608b2c3edf82a46680ff5c6caa1005d5d9ed814fc6c667d708d6b118782e2b3eae12c5b266304c6731ef91c4a97509ae0c49f4a4459b9e547e61f2ded56001c3b6b7d35a74356ce676410045d45ecb1313d08ff44b3338838260369db29eed4a47cb83e70d75a82f2610bafd9c0b1bf05afc50caeb49454e3c65fd0a9d982497e4e238c66305d70d310869cec2abe2932d1d112e77eee8a5f7d4417574f6e5e417b0add6324f94aa0d6f3aed06cb9be6d603dea8a22507ba1e6a83daea54e74f52b1a067b22a512333ddd1cbad757ec5c1364565e002f2024be8dbaabb272c61814e45f3c4ef87c2d2781f8df48c764ea17a37c53b9e2455b047ba19a28561cf3fa5e15cd130c0913a05949f81bbb220fd0bab2ba742e0dbcc2994503fc8439a3be5d1996f387e41ffce95d6ea7703ed105565bbf34a7eea26a0a573505703f798986e4fb0c80ffe98b343a6275a189a106f3e760690d9681159d241750e83a0ca756ff327235c5d329cc8f1b64c3ea9b3003792a2ac07dbfd040b58f1bd23ba250948d32d662c8fba71be9fc5a2e1d2dbdeb53d13ccb58f5b24a15610ae1cdd4974298becb4f58dbef4d7cc3c09ed5035e436a3fd34400e2f3d14de57eef02f7312d5548c6be4b180306cb2023fa54aa2283349c23ebe3db0f099bd82c8657e17cd15718d4ffe74da647a83081674067f834bcf954e152c34ffebd8c113c08023249d3177377059fcd87dbc1d8318ad53cb0e5ad15f00cd7d47c44a3d183132b58dca449f2932a087a748acf605d4ac1587f7b1ee6a35aba0db07b8fea2ec8d872e51d93dede487de65901319288d7d72380298df097e85999f60a2f21818dbda43b9c655b5675ed08e4ae0c4b833af1fe5f73a39c834fd29c7a21fccc3785591c0f2fd49ba9504a3225e98a9bf7b798fdff1496a2354a1c3d4244d8b8c5a8ba8b25a15c9307ac644a83ec8e0005855f576bcc08d62cae65b0f3ce0a14a8c46ee19c3a6087d10ff6ae5716fb456e82fd937d5833605fce546e4ae2dc148938b0a30fe8dee530c323522d8750210f113fc68e66b3a71c95cf09c6b7bfb6624d2c38117cf63f299958cb25096129400377642ac5a0f6201b3232a8c50bbd9ae8031444ec3cb728986719078ac3dcbfb1b1661429c4e8aec586b277257058feaa89bb38bb01b20de78fd2946ba1e5fc33c537f2ef36e10cabc83bef5b7cca86a49eb89855fdcdc55713d69534ad83cf92d9613e4e4364ca854b71833f5fcff69696870ed8f19c9e0da9d8d251359e02c485b408c00a758f54e752231fd4861a447566bd49f4f537a5682ac7682c669d43379c78a4e291e0265cf1a36d8ff58f9890d2a001f00d40ef9aeb780545c97d451b11445ff936bcd15d0f088234ba980aee64d049de88f586ecfc6f8bfd1187393888886d635a42e598624e9e6e532989afaa5776ac4611baf729c28e4293398f3534cec7ee8c9e031826fb34576a7a406a8a6c812175d7b3ba43b7cd378bb6949772bc1ab3c91ca011038f16268de9a31e485406eeaf3593abd38a1712c62fd562351698f7e0a24e69f0d94d8ba1bf9e3299987106182081a7fc162960e3ee597104e4a7c2da7b0cb26f3182b103d6b251432f1af0129bd3ad6428fa9d9e6a49b202ae8a9b5da77315fcd732ffc1483f1cf81418433dfa7f254902ef307030be96e515f9d79deee7426d2aa2ffd53ef89da8e724e9c5ac67797424be608054d56acdd77220f561b836e8748408837c28eae2fc21d7c45cbf28333d4fa47401a3db2a005e03c3d53cd751310a04fede22ff5b5a72ef6a63a1bf73491ebc8890ddeabdb17f6b9b31d44c951264241d5c1289a7b7b6503b6028d7bcfad52acf1f35560ee3dcfe68ab0e5e588fbfe260fdc2bcdc2f14621a22d2860e4fa67b9c4308e804ff0f71b0956a90892d6d8bd5a1d00817436fa429f27bcb8e82677da4f4215e5d6a823fca7896106b2c6bd42cf2a33283812852ac726d5b16e9698dbfd40bc1510c9083a993b9a9a7770992391f0b54e902119ea106089f4d16305037363962d0dd5528d6478ad956a17f1eff0ee62e314e8e283e99a332d3066e236338e15197cb54d9408a37f79ef753c5548bb3e894468780760587b2b236c10aa2f2f90de8a018c9eccd413a03af7d63096181244959dfd509ec3ee8db1095a245cc493fe702b3bc8eaa620bae9700cf556dab7fcc60254a522144fcc0af592290508a8a7a91062e2506cf9d12fd06ebf27bc193b06722535943b76494a6bb5a59b662146fddd492f52af9862987ded086e31d41d24e56142b462201fefe0846017f397572c922ab9cd4f1b94a3d6eddd20305209a90d5f183efe24fc1afd51a75d5d4e7064eb17a7c69a3220549de610241bc0bc41827d78f3a5775180fad253893e60f601acaeeaa51714332befed5d9fa114d681c5cd239ce5a435177367477d18a1cc9548fbe159c5e69303548e6ae7cfdda4103b1d681059d3201c21c07621b99992d43ffa2100c9c59ebff00f948e3699f63c67b3deca0e6f50138d6d57318c83f75804b5d3e31f9c1c4cb3e186a8dc494135f5b8a580e85e822b8a16c33a3d5d87d86b45b8bded568b94f36094ae01683aae90d0a03678be52a64be778c307827ee9932e79499df531b9dc346c3069a6228edc43b5a131b47e811e1382b287db8b7a0dfed859218f5c6d14eb3e853034dd2725200f9e9eca7056811cad9ff74d4ae4ea29d21c83db84af7bb4802d2d66f2a71af44c1cafebdb2448737ea329d5a5d14b03f2bbd409212c88004a0d0f51229dcaaee0b9c7520bd792e1bfa68d911481f3dc298308be566ac0c5cd069e75b035ec34d4b6c94194c4f67e74ff3ea872411c0692ca2f1bb52aa1e0b844b2f35cff9ad4e3faf6d4f5cb0a503da634dcd8e39d88d40206f9b8da8c2b8b4e323988ce0d8bff67676a8d354ac0fc717c3873215a96376c0aee6147ffa45ac310a4dd8d9c90d12291181a94d2e1ef01af549b7c5abb8a64f7218d6ec9b28bbc508ece4ee1f73b8c7a14b4816319ab0dab125a4c49cedadb094896280a4a0b622517a5ada88c782ceced699c9c883373b228e0d60d2102ed76945ec6eda447cad18885466b551ef66947d694ae6504a13b4e524606a04814dc6a62ee9df442fd5008a9c0f44ad618ac68883cf97934bbcbffbba303e9d5d39155122f7ed4fe8e94768af8db911ba7392b3ea19fd48f15f568471699f42005e73101ab5452480f40065f2dba3045b9f31cc93725f8504bd7b18941d03f7eb71ad16a139429f00d727479632214194b31f19862a2e89e22cbe1d6c694e1fdcf9358575a5db2ee910fb8d0f9098a9a28b7cbe2db95a9fb9a54449c910ee837ba7bb6214813e6cd48446475c3a2404098efa707b98cd7e9f32811534a0e367edfa2152d4dd2b1b48af349b2687ca176226a16e20637dd346a10a56fd93bb985881b45659e7ff624722d6c328e143690e16d3eca832f611d20bb6c50bfdd71847e99083838410cdbcdc3b1c7564ed8c022f99e8d7d28ab4da154aae01237a440c554dd3dc94a3a3d0919944da0c013959668fdc324df9161743027bae91c0b7e8bb5e175b1c5e558e86f416f5d666377c6534e59b924ac75a5c748c19e5f6f3ec337ad1791bd125327b50512fd28b0eaa9316fb1990bd7a710497c3c891ac84d5020b4ae444cc4fd16c9f83ab63f57a8a589e15de82feabbaa93196c42855019e9d61f26acc9f4ae4f53923c60e4b4d78dc8fd842ef8803e2dd0d6da9e3964de20885b74aff9b7d80f94b0a64d5c9cbb72ee58093ef40b525337b037d94a337f8aaaa1ee6f189f4a53873e965e28a2b3523f3f208d0b69fbfc8611ad000aef3888423024e45060c0eb9f5137056c3bd9ca3fc466e492bb6b973854d0ebfd4fdef820781de043dc4d0c834290b8fbcd8c107913dc43d00f72b8c1ec2e5da8413700edde3de73a07d086822f465e9223533f765a5a7cf0243b70e2410108160643dfa01c3df505e26081fea59a0373b37e0d8cc96b81f54405b53cc07c88e8b1b437112653ac91f6a436b26b006d721e89d57f48bbd0878f307e573e6ba2e5efc071d2cedec93327f337976486024ee848986d0d92c3562e8ca3f4a3f69bb557b4e9bc3e7a36b8acf4d1218a1ecab53c441f5506a466aada29eecfbe65baa68ed0d7a2ef7e2d32cb0aec2e95a8cfc61950dbf731ca8193f3fe4cb5c0132d31a92f329bd173b0004c4fe2a193fd499287424b2babe1aecaae734775810d9d308483fa14bdd2b29a6d18f96ba3ce433ec0081a7f1f3959fc3cb8ad6bca122f4c476346291f64ace8e9f6e3c692a2c884971ff16d4767c7cd555d624514b94fe9240db253dc25bccd18071a3d24b0c0d38dffa0eccd9f53ed9fa8c6947677aeeecd31d93373171171039bd410b3aed0f389c9d2ff01c8398296c3cae66641b219f44e5af62fb21907c30fff340af14e5e0db8ee3a322a8c05acd5b0eb2d2aff72ed6ba585d96741de38df0a5d74108df59c727f2ac2ee5bfa01c1c9132e22d4c07f2138b23e054c95025a1f17f634c63b691fb8d8943dfab9a3d9fbc4776112021b9d64058ed7232f3ad809295036f40ec9fb13c03b670405890ffeb418b69d1f6bb26a8a8eb5111b49dea01d68c309225817b346fe564d95da2d861412f5ce3b27bf7b30ed48091fb982444ada0cab72e6bf9ce3461bae7e5227294515b0f2a9f5a9ae7d4bce071fb59e867d71b3603eb9972efb45a0ff4bc71788dcfc86ab614d15a164da8c894babebb4f85c425142aad2eb95de7661afbcae8302bc7503dd36bd435901560d426d3ea16fe135a4dab3e9ad61c2a4204c3970187ca922a26ace82fc0d995f13cf000e5fe26d863f66a801e1193d73d5add7a268641712bd873c1bd043cefca630b57a949fa29a0d48c1c6e28c7f78ead5f561d0b4ae156ac54220fb284445510033c3f62000b16c2a80869c98d10dd6c4522582ed0636ef7073a9c01af162cd7902a950a6e88894e3953e23232a0886267365b00d90ee1f7fed2e93f7541845b431e224841241420e6cafa77a5b0cb38b0d4c90d591299beca956853e22f6a7ad965dacb9a735a4e982738eb76fe8cd9171a7f6311043c1a0038be3186c35e1f3550ae0b64e7c71572adfedf44f2dfdfbc566acfaffbbd9a730ad2b8323df1e449729782ab9a175912d84beb3990701b6914876d535c1dc7a04ced351630644e14c77986c654ae11a8511ec286b0665ebd5ee73f1a386f0604964ccd763b116b4660fb32b904734e499d426bc76135f0a2281867fcfe587cc5e975904e3db93468fb946d7f330d4ab65d3a1493e8a82259743cd70fa92c7df0596ffdd8a811d7cc0884a89e08a073714437efa53c32d84bf5d26eaf61bd17da8ba6d9f1ba5edea5ca9634fe28740fc43142599ddcbd41b4837004be56c6944bc0a5042f1a61d7970157cd92f8755d854870a0f91266f0d4c51964ede3e3d19fdd7fe92d1ff1761f29c4cc24e05c3ea3e2312088ee226d75944276cc6abe4894061fea5d0d761e7ba57f7a79878cfa91a03b08b4667251a09c2a2318b683ee2ef1366e653c72b8ce1e337cd83308497615e3b90a35136b93770215e35058b76b5589de8f98e09a6da001aa45bc9fcea047fe8ed891dd91d5e17610e0b0005851360f78d4b2f6b2007555edab84c7abc9684bd1773c35ea8595fa374b632f44fb0edb90b01dd09d92cff710e08d8d28c681e12ba73685e376fedf9ce91a95c9be24a475dea0698d16a977b33351b48596738116476e10388ff4317f6478f9e904da79d8831ef2df1f6762bae89b10b374e20a8de41d9be11bde0c299667d77f5ed972c33062918ddc0b9947b20a288fcf0ac57218d6ba3b47b18ea85dfdf69385273f032f9ed78bdaf093abebc31cb33851c86d2dc64f57ca4a495ea3c3892f87adfa0bfbf69a41532d2fe83fdfcfcad9281149c5016799140fa8b244b1ff19a5f490dc5377d41fb6e8bc529f13be3c586b9c0beba3bdeb1ca09cb6f333f6d15f730a8f4e408c5b625f54ecc70d7e517112927c4e5dff8449ca58cf354e355678f65c137f03ccebb37d66209fb23860e51221dde3ea51e750b11cc32a24e0a2a19ad6d6973f75febedbbfd330800a2f7d4a0892c681321f2f12eb81f64da6afd792d5d1c3fc737e9b95f5833834a115e8933ad086df2ce2d0b3b8428e62c01a1fa5417455c9371095b013ed10a8a405e33128a955046d816b4bae7d577e1b50916b9fe03ae99e19c4a1be005a1e43ded0491e3d0d0b862cc89314c73afa35473616ffc28332b4d14c64a2341f998cffa11eee7e8ebfc1b11151e7f71bf3772fd7a9e1e83cbba46bc0ffa54e606a90b26b6384e31ecbdfae0ce28b6411abe3100198658e5b1b80f835289b0480abcf9b29203b7dc0686f59c4fd411e451492a31a3036b32c363baac64e7f20dd5270bea7f73c4aaa24829dc2249ca70a47ccf16c469e79dab5973be75800e28dffbd0387fe6f81439aae1f546441057aae7fff339d6e4611e31c50b81cf1f606d8710e2ad7adff6f4ae747e770415aa04c2d3e2076dad4fbb4c1688773f2ad0246d6a1a67649722fdb0944ffe3b32ccb1e108f5b8b7d34e576d1d7d6c208579bfa79523e99f2631b6fc250cac940404bbced1068de183fdc303a9bd5ea43e02cd275ecf46ecd0e5f1817ea3514ae80ee1d6ad8fc458a4662b80ff75722fd1d9342669e98ea9e88e8cae036f2fab36e2f032c54c5ec107d0e99b02229f0dd59b85a5ae20577df09d4f55aaebb3003031086b5a4da7ab9224f6d663b69a998c624c12a67b80331034f571eb8c6b3898c07e9e177c2de460dc7dbba36759c280e101b22c323828b873713102b0cb011e54d77f63c3807f26f3f26e36c628e2103c1662d34907e7c83d2c61e17d946361fbaae106d25a4b1c414de6db49bb709afcd333934cf0416fb3f5176b34dea2a0f09dc6e447f8376fa893d9f3d5178d6630f66eaf7533af45a55e8c2d40c65608e08d9e16c8621e8c336b8192625a3c456f2584ffad7dd72e7c8868a0ed1a4b49049817b586e46cc1e67b17a903c8d6cfd72e56c51bcda5c085e3f06a0d31c2248acc5816b09bf1c1354879fcaebe06d2514ca371b27b8fff1a9850d6812597bccc6cb4865606cc9dcc20f708fc9bb5193966df4f32f26645e03d6534a44991cbff2058bd3d84e5812cd636d9591621be27400da19b0deaf203cc1aa491ab9e3c0b669c079190d7169ba4c9bd50c23374a8463bf1fb379fee5f2d904553e14d411a6ac32653b57e32f7c92931bf83355cee2c2a366c25195727b19c1ed536eb4a07d0b9449e6db7eb6f3c19a583eb18c9262f5c6c6677caf141928556291a0bcd746633f005c407b8368a471ba3d2afc955aeadc4db17cfc67df94ba674e0b7bc47193cb31678b10713357b627a60f03863f18935837e6c00786e06cb79b48960d203c337b2f250747ecdbb3ba9f1747ca642dac9ff0a6c8649a5435cc85f52b6169416014da76e534f476cff57c59c736929d6b06be272087d8f3cff84c008d1971d0303661591da135b01811b7f636f3eb268e801e18c722b5899e74f69794581dc8a6e4c2f310b0b985a69de8c875b8a381a405bc9b893a6acff3ac67c9a2d185857556096ba5d352022150331e87868834c7efa318bfddca6d5611f32dabcb9d185380998ec0fa8b9a88ca687041f18a80113d579da55c485f8a0a531ae5cbe80ff5c65d239f6dfea7c7446e5f1099dbb344ef79465448c80854259cd8ff62c7511cdaf36c19e34f49e538f72f87bd0d66fc87a0a3809576f92dc2eddd1f856f38930a25b7b8175b7dcd19aa2f4a83020bc404517a00419f2d584ab8c030deed7dbdacdf14801e803b0a6fe65d839749f4221b6ef27f0c6f022b00ef8fc72364063f56a345b6a3d409b5cf1926e16cb73bccdd86a207a2f06709105174a28a6f4589715ff48604315dd00f51a37e54b7f245d4004553106820aefd4b3e8cb814f8edab238829cc0238991d9203fa9c7677ff17e05f155ec37fd49c82435f32376e746c2b112e921093cd68fd02934600bc79ebacf1b6a76ddf794ac30e3e280a573d9dcefd9cba4196731bd90a8c9855792d320088c2bae2a2e10a76b27d29dfd244b1203f6b2c4f30d03247c706410591d64311efb52c71fd30218e0d8799bfecdba16d8b6fd4a29494ada12bb28e0d2a0d06ec9af690ac93424f366484d8624cff872c242150cfad7b24151db3df1a07cbcd00fcb5e25e1917a58ed135c810ee6e3a27c26e89c934e3e0babb89750f4666448ffb41e091d2e475cf8e4a728997fd7a194bac5909b7aba99024baf18c8b38d162be0826c113050bff144811a7e41f00cf6552f0eb9de6dac2135a3bd4f8712226b2f66b60a7dd960e23945a2910275557210adc529cea063f01f88162a162b82fc6f05fd237c7009085a7876e69484f7c3e3a35fd4a305cff51dea2984e00b4f9333390333bccc931f43115b5ca73c91bf35ef5b62f2083b72c683b70691583d74efe4917dcc185a18593c1f0e44a290cb99a7cbe4121627171fad10638fc582553457b4c03198a81a3bbbec6393eafb8045e63f6dbcaed6c4a47039b0e6101c9062992cc9e713f0ad39ba67c93f124eeb65251581755f1d41b1b4181c706187d4a51c555cde03316609ab8e2758a7ef097e4243fe0dc92e8fdf1a82fbb446ba5ea10d66d942caa3a2a708c2c268cfbde2432dcb37a023578a2808c360acdef121ac33f74ac408af5d4193c7c1088e9a05823bbfffac8e1a62bd4f7bc6c327d53514ff5015756afff47add6da2fc319067acbaf0cc3e1cfa0e6a948c011cbcda0fca3b0477e536ec96431843a96b61bdcaa55c21156e86d5684e909c73166f0c0c1030f28423e17470423558a5eb1fea6c315215c4930e0983ecf378126e5f1b3389d278c0632adfbfe87d8cc541df4a88c1f11ada18835b530801fc38b79b308597abfa3da1dafd86e8521fd058a2c100bb1ad84f92bd1077324f2db99f8098626e39a2177a55ba8f86e7561806d23364c2fe0d212c21219e758f96cbaaf259ebf653124e8021d1586728557e1a0fcc368c5fa58a2016ce5964e2094514012b2f244fa54e6d2a2f47f97ee787ff0a4c8d5f150dd21c764b5500f9a36073d41ad64f2b789bb61fe830c6a8ac7bd380f8eedb01755a92867a2776023aa1063aa3417830898e8fe6414e99a5ce081f9f6ba00e786e6e086f0eca8c3d03637560e6b518847d4005cd288b005eebbdcce2f8b21263f8abac9ab0d482d553f892f5fc995ff5df75238650a9e8f9512ef885d89a0c8104eb418a5f7917e4283587b67c38f866a2b6e8e0de75126fae1c468cd424ff5e84148d78705cafd41b8525a577ccbcf79c87acc3b05ed96e914477d5f93d14124a60a8c5173f30e73b6bc379531ca1762649be3ee781c44540b94a910d1ee72661bde5fa28722e92a1d0f20e6029ca33c449bf20596c650239a8553b65773a151346cba69fa68e53b4d046e11ead636900ec205c9fb5f50a1097931dd4eeac5602b0ab275c5d0f22289cfc80c91043bda74c9f9a9c597245a207fd890fe74caee20e2f34a8dd2c13dd57d4cd1a0f5dd58e8cf417a40bede6f19209895fd28cdd51e75292b9c7981148b10bbecf7bc554aabc753c99bb655d19592b8124f914abd7fdcca9e68eb22b6ccf548073afa8ad77c75d17a255c4187b0d6559a70b985a12ce97f39f4af3e77da84961c0e558cedf5235be54d529a91a5d1969dcf743d2be073b937f28ed0c0e37c21d826fd7d296b9df0e341ecf45efb34056bdb9b024493154eecdf6be8a74fa753425e65ff8e0c61af46bed26069a7b51230fb3c56c04046cca4525a9adbf13367f5826cdd4d6dfba425327130e45bedb9c4efefaa5935a267201af719af565e816678bf933db9afaa99c2b3bdec966fbe6566f7a44401cb886150570f89a9c97d5901eafddf8d9999f640a1a0923290da212d26be87e961930b3419215b183a4d37d71e422736773ff484c47a38b1341c0a47108bf6ee7189baa4f02153a136fa99a86d0ec96d40a06e3778d5b78030859be4387aebb26cabb831b1f4495efe63933702808cba832b8aa0c297ac6820d0c1c4ae7cbf1fc4710456a2e7624da75ef33151a933dc15f6429eb033c0d81868f4438a3d107f333c226abda8fed50f733ef153b28367c0878bc92d44a06c3723fd2bd1e568afc14b205740b0953f9f647a65b86c910c9a41c694d84323b48130edd0528404b03e28e0077d151fe54c563b5973f264b2c692fe6286170fc35ca110163ddc39b681b43aac3421f6c412ef7120c0cde52865d557d19be063ffffb7e58636db1149819e8cf94fe250015ebd8b8f4ce9d6446f3a2432750dc7e5f01859c357413cb97fbf73ec17c33ed34b5dfc01e25425fdd47a6c077dd091fd1c5d5a44c9873c69b96d8ea39223a13c1c36bda4c37f2f68b85f26d1e63a24537a9ec35faa78878af05367900975789f0208e7846e9409c4fced1b401c7094d45cd8afa0e6d7ea371f7247ba9b1b89f805bffe0d3214b5b62287668213e502d74de6b5b969931256fd774d234257d180962c318386bf4d6d49aa3e59f8c32fc6bc11d85d9e3d8b21e1254f630be59446df12c24373338de42104f19f9a0b00e07ca1d7813af249abaa966e3b2a337871b6d4536d8c5ebbdb70018b669ae84c55d679a2a34cdd8fff435d2482b9669c083534e4db6aedba244effebafef5fb94949c6a8dd7c68f28bb387dc468e705b76bc0f49b080ce86b3d6f8988b0a34f86c0ff171b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
