<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0b45e01e43dfd3c5c825480cf149b055ea52a0b3d45f814f3fdeede18803f862489fedece7188f5e5346fcaca8beed29df8621f873ba2f6fd8093736dc07d272b52283d8683ddb636b15b7ec984b928ed5734af8b5b366cb4d54cbcf8babc97d7589b3bc5a2bd888577c05e731916c5830bdc1ad1cee663d13ad2427dc21d5a5d4864aeeea15a30111ca447f37ac32c7548d4d3dc9c9315383855ceebfb4ea1c1ce91edb4c01a881a9beb1b84f6224eaf118d41647c2336a1904d84a4a1686e2eb5f8f2c8dc0bdb2f09ce563cb20d0c4bf641f2ff6ad67133951b25678662d8bc5d7c2cd37e4e0070c854696aee828e39939bc5d6bf5dc8cf7a6276789b1642ece8e51c15907312cf2f43b90a672affa3b70b19c033e9527555b682b8e79df84d5a02b72604711e92760bf9549396f277ab2d34f2e840e15275011009c7112470350f1a2254d1fdabbc2120493f66e3bf711e75aee11ef2f595c820e4ab95b2e0c9676518a1d9dec432c4063a19cbac9f8c5c98b2bb92139965bfd64bf0d072a395f68ddf0a021c288344c4e6f6c07a058eb3c851af771da953aa5a7c19067e4dff62266fb1c9eb49258da32610bdac1d58f20b51e2b3b6b5666519eb137eafb762d587abb5397f33e83088ad5f7bd19ade3dc3859217c22c5f0a26681901621b1217646ee4d55b814db185d3a3e0526d93365bea3b03e9e0f37e14f4656d9a30a975b07cf16592db4dee8ecbd7d2c641c8cc8f46a796a94fe5a184cf0c5751ff9aa22a2b22bc50595ada3ef4955c567698575c60a8ebf9909f6d1083ea26de3499c88ea0a61c06836d6a462d572dd29bc331a810a0013d32d36d77b1b835421686b9781fe9580fb06d99eeaa6d2a16ab5370c8444590bf4c083fadef8ba0cfaf556596369c51a34b1b5faef9c9920467499f35fd90d2e0b7e4e81d99c2b15e983b7a036522660af360122d040581511ba4994451fec2a1ffd51bf481d612d590eb569b8b5b653cd500cb2fa515890fd7cdcc484e4f097fffb8aafbd0d895e34e4a4e4ac63ac830f3e7002566a282a75b9b9f43d7aef71c4c50af8a286a828f8fb7e72a00e8248dd7ba0b2f76b2a7b99dc75d026ae1f83ee4a2c19bebe6c611db71a2543747f3392a6858f13d6842a1802ad1980fc3a899074d91461611e03242afd2175a40938ab29660e9550e4db1d28f7d5012a2e6d40f2bb96db05ce750780f7ad6ca43151d8a4d8e3f66b6bfc65304fff40dae154dcf30583c945069df58ea4f0d0705e973c107efe1cc51cc2926c6b28869dd54054efb140e5aea11a358a445ed71bb763f5e79dd18c6120bd03022af8d0ecb79aeef05f3db27d30b256871ccb989da503d0787b7accce37727992a6a8efdaeb0bbb075c0b441f1fb66d2fba4937eb26f5bbce436e56439c32172d79913e734e16701569911d7b200bb5eb5f73671b9ad21a61a3493124f078e4308833ff72077174c1f543ab12767d5614059442620595c04971397ae954cbefcd3617b5165671db0031cd6952cb5af0bf39b8faac58cf6d08aa7660062dc67900c2ad02cb92cc6b07b71e6b641f3fd69cae47e82440601b7cd99dd65fea895f8fc21f2acf1e1743cf9c0b9da9ccbc73cd79b32bc6184ba17f95cdfaa430affc327092cc70acfc0e20beaf13ece5a843c26288d1a68598d7cea7e9bf2c2370e9177236e55056f4ecea3695c86454700c5bfe3fe0e7d8a07c8c0f16345eb1dca99a56714452d99a5264726821ff78313eb275fcd49a4f7eb98b9fb4e83c7559762a1970eb95aec074931c2a26769a06719668724b7299004f803ce50b65711203612a113c824cb4b5b615ed756d595bceaf7588b256059c6940bab17df053ff183b3b5799f6cbd80f48ae9949acf0a14a4c416f3c5123cd80113c3defb977ee1ef7272bd10f699d4f8759339f11760eefc2860afeb42d29dbc079cc2d780ee6dabea938eb91d6de5328f9a1c5e69bc1beb990c8e0960315b58adefa9bf3747cc4994cdb25cf38529084056a640dc6526099bb40c5c3f2e22b37366b57249908f13d4949e89dd72c613b6fbea4933ec2f8ebfa743790b15462811814b0bd22177b9414fa5375c9f7d3477c693c94f22a5175978ab2880d610dc32f69c81fce507c438b6e6a000851e5a2209f822d5b38aca85a74939105d77ef6476c5f2122f261bf9b103920882412b3997794dfbb2c982bf091fb5e6097d59b6bdb5d804f834914b97745191e4d25e56faf93abd19a4931ebe1f9eb443397747f7175c7d8bda72661d7223e96766d0caaa1438b68f02dc4a0785af6918d4fe4915d402fe11dee5e85d69d4365468880d8aa7badee0cde29ef462b630a148b76a2217b2e5a48791912316c3802b296d78c23e02620644e19e9f1932e554c768de1852a4cc5c3112ea6c39eaf63fc9c8fdb0d0606deecbec7cd552804c9c0b8b9c46000e5a991860f491c9f24fbe3ea960745aa2edef592ee7a9ffbd1082b59c9cb237ac235e1bef07832edcfd08a9be15b0760f916e7e682b46d10b1f75b996ad5bd0d601f805c28f0c8ed18dd820f73f314a823a50a4c779940e2fb3f4cc6af5f708e5964994a4f9627053eb70c0abae15464ca98e161fe91279ae6b5923fc682776fcc089989e59dc6dadc4b510f3e3aa02bea0c6a1e476b3a2e21ddde0fea325c95f95cea2bd40f01a5b4770d86e36cc2af5a921cccd0914918be71ce2c65b144438c81847f140fed2ea3a2c6a40a20e5ef10c3f0e5333a25aec2042290f84efaaa5dfb9bff1534d6773dddfe8692397f7d23e0a95be8a501de49620051cb1371505c345ce30d76a2251aa41b8f1859a9701bd8420cf5b08fc6e13ff68171d99ce3a6501eaa64e35a0f173434781b6a0fdbce54a8cb6b5140875c0cf5ce23576de5d17ebe77273df79451833068b54d19af6cf131762222b96a2af0dcb7472e92560d4901cc0987e2005146358a0d8af3c4ad76bab93266e7f66a37ac8899046fe0337937bfacad6b8b1dbb2f956a3da469af7af11f33445424da1eb29a6f8207865e835158821d55c5ad16bcbce82bba520d23ec1eae1a6af6bcfe604160bf56db0da2936599556b1a078bf8d7498e12666888672624dec637a5433a92026e9c6863193243a38c3eeb94cc834d96fe6b46c379c658d18c569a022b91029285d392326a77b1b19a1ed151d62830a636fc709a263ad4ed5a4a6cc37bc5ce395533d1c0987eb1b28eb56e5ec7451a7e31aa3d182aa4267b986f3edb66c2d18439f306080b359085523cfa69bc13c1f749c1f64b358f66e4e173c380f5927e389dcfb1fe491bc382f9258db9ffaad78ea92791c3b0aadcc3b8b775acbb4f4a7c3b96e60d081d9f00716a606aabd602571b8e79187c7a5db0a0fd2ece5a37f64999b6779b064c3780c66e1a5b685d74babb9b16688de97e0da5023d8f5ee94eccac2178a9d814f83c21a13ab0a4272e604a9488ee0f8eab855710620a8091b5d5787ec54c9f54ecb2f0dec2a9c3ef2189a8dbcec9f2048a9ee75a2171dd31ec57c0f450477175f2d06a87b89e4232afea51c1df225c247c013b099b8a36a3bb213748036943c809f7ac94f5a800bc25a97d38c40c3f1a33c23ba50238f83f41f51eb8950e4de3f112e3b52e8ea2f608e6ca19b1d9a2f3a9ed9282b18337d3ad841942a4ec19180266f1b43e002075dd32f23c13f11a5440fbc08b87189268648ca44b33431e2bd0d7fe63c486329998fefc43dbf34a6a6dd401f7ddb17d699ad721a4e745e959d4615053a0a229675e018026eb08025444688be50e81cb10bf71ddf446d7f3de943e798e3d3cee7103cf0c2878afa164c99ceddad3edeaae00feaf5006ab770daadc7efe323437973250faae0ace9c54f7517ff2782969d3fa2e7b61fa599058683501d3f4861e07cd467f807702ecb2a4a654bfc56f5bdabb58a6a41fe5d7ae302abee8bcc0321876a55ca00d61f36e683fe049b4dbea793c65d112a28a232fd4958e6844a0ed8b4174618e841fe61c7a8d2d3b10e006e23a66e7b3ac1f69e2dc7d110f5e5e0d5a6b4f0ec612e4013a8e384b85d4aaea9b3623942ce64ad40e7a990922310a0506a6a5a20c33e0120166a7d1d86f6eb1c42e0b96b16299d08c34c7ea0364fce68db2a8cf0c09a5910cd91e3ce9f41ecc3554995ab9622e2d16938e1e3b4141f041c4d041bf0932e42ac662740364be93bf363e2053d6b0f385ef7fba64f7bc7ab554b5c626748b523cb4b87a27ec8457f84ad36b2a9581ba6490d6db3416de175cd67515fff2815520f380574fc25a77a2a73528835548ebc5339098a7f0934fd5e5e09be0bda0b9b63e08bd979c57b514591aecb36d07f03f8950d1f44a5d27dfbaf5e71c25bcc4fd47e62d1cbd9ddf208abe9d670b8a2c27ffc79d142eb4de9dafba899cec2969a861d4e0b8fafca5ab4007d84d508c53d9975853fbee097181b72fac017e918729225cedefce71975cf682401301b36f54385de9b31aa29113a0ec6dd5f4173f9d473b93ed920b69f88214fa7bc5c8d8c19beaa73adf3c50ceb745b805026e7623975127c3ffa8249b0aba58dcc0c3d3a8ed6540baf00204d17620a4aacbd66c6f3c8eea2878372f00548e2f6a37c7af0577938d43583ff419f6700c43c10442c7ac9371a5d9f839a931a382dd6ebc55804a225d9676db641c3f7b8e5a5673479090c2d8150ca290f01bda3382e8ec24061eb8d9429f8aad8771033a61a6981d8946d2469d50e821aceb082fbba5969140850f1a2a86da91f5e77e63f70ae864cebf484762dc5504262dbfebef326583087dcba38d9dfca8a19a0a3c2c2cd8310addf51a058490607a792b5f8891c353ef43a1de2e6a10dd625cdb5a005730fa64ad46a0a3a538d37984413a73553bdc5d7d833c5774749b08f28cf7e79b48e4703ee2f77f3757128300b7479a1e23a6d8bcbb0296f2a8c72f2189d29c374ada39b03de53d8dae0aa4f5e1e6eeb4b264aa176153d4a5a4d6b2e8b5f5cdfea5862eb03de16e7e930d4127eef1a2fb4a90c65b0b857dcb5af39e9fd296f599f6d6e96ca3253390230ed0e29f4d8b4a9cb62a5605f68e8d76440f5b9dd9bb43b0ee4b3806c086f208cf000894231bdbd48464a65e84a35a03958e9b4c3e759cde514350c6abb01a7acb580b43b17ce971681a4897c9269ef3ed087cd16b2476ab3c5bd27cd8d80389ca8c761d6924e8348fc874d100dfa641546b37d69098ee90bd4241b855ec4e4b117f2b02a04ba8ac5be8c977d9096d9b2f21ffdbdf940aeb53aa0fa84600db1422da2f79ba6e7c9f5dbd9429d5b551ffa84eabdf089ac93a145fcd0b036570129720c2befe23e01477ffe000f8bfefad33c8bd32d1d09a9507739ce4945ae210308e06a1802a5fc6ccb3a996a9570171bf54f1d40085c90412dc79be5cafc914142d76dac9270a80af8be82076733b186ab0b7579d02189a77696828a79e3e40ad6c3ce4d86e916daff78e5bc9fdd653e04b62c58ea46c7203ae8400b05e6e2d46aaa7bb590b3a4581c648d897694b40c6c1a483fba45ecc104ed55c04a803b55f8d6e41122ff70d84e58a51c7f1cdb9064355da18faa546a3098195f9158a98505c5d793bdb96d2af9c484f45d20032dcbf90215fdd6d56b05f7a1aa15cc659beb3a10270b1aed67d40f4339819cb01fcdd81e1a5742aa054d0dd6cf0ab9b64fc7a5e6ea58e7c5d347fb362fc9ee30c5983235031839ae141a4d6c12fcadfc469a5b9aa31ab4de90ab7192b73cf5cadf55b05d892678938dab40fe3182dec69915646872461bf4c8c6bfbb6d07c12a2790eaa790738d038514a0af9465c4e5c61c2312eaa08a9a9304f8a286a0e77c42c4301c42d74091e4712f5188c98bcce730874209d47dc0b402b4578cde837763bfb79c833e733c235eb698b572a637c68c401119bbd7a5d38196f271a7a4787ac6c50ef6718eaee7d9655477bd5dfd30f75bc5b42dddd865516f1d3638d98ff69649fc28e1358ba42ebdea8708eeaf2121408cd3095ab2710edc20ac7808f0d7b3ff27bdf514ed856acc582c23506a4f1747ac1963bf906328d63e657fcaf4003cba2844d32382e656837d6fb1bcbecf7adb9d3cefbc58cb7adc55d53d5e48d76080113a7d678568ad83cffd4d19e3298f125771ef98b0e01eb4e6436addc3b8161f8d5186b04e358de4004c25b6770385cf4c5b3241abf0c03be702c4cc8f62195c083c0cce14aad3e1b614d1c4052ab81b2530e21fa8afb78a3b477b04009d2a258797cb1a5de5bf6b573e8709b07e1b1cfc61a5e1f2758c4becc130709d08984a6ae15892ab2fe5ad1687f1463b43d6ed682f58f479a7dfe34d986a9673cb294fa613c6bb54317dd5f5fe2aee5c0ce80d0c94bc44a66413a1c29035702214584960bd3246a51d4c71a7af01cab8a9c50cb5e39cb9fca180e39594bb3df1a73c3c07ecaa002652dd9a59d3c6df94da8db499bf24db9feef2d11c6d210b927b7deeb65da94cee8e3c1789ba5feaf54f2ed0a0975d83e23f9a2f13485bf062d51bb3d69dc6ff469c62c04baa9496c60ac87aae65a6bf5285bac085ae18ebde56d7382c0bfe3ab0a7f3a55c9e82f932725aad6e73da2b83b999110cd731637c1184bc91bd519fcc98ee5663dd48d01e8011b7fad5876b8e768bac358704f84ddf21c8ba2f0cedad6709df63e1c0afcd66c2330927724a1ecfa7a6b3b799e9063a22223fd133f92761a8a67217149d33c765160894f78ed4d945fe91335e172e39c73c6d1c8d73a968e5a32d59519e954b54d19e980d86064369b2b4799c205ae0b400125a99dab3d79f5b419cb2c8969b547ec0b1050851d129a90fc626451d04306b5642d2184e12bc7cb9a71b199ba872016720a20442ae3ee6ae700173b38f710bd69cde8f8db0cc62ef63aaaaa927a375778a159c7fc4c2853d16001b6fcd9356d907c065b78db964c9baee4d2ae96b30dedd1b3d9b2be64a695dc3f983152b24329481a3df745d0f07d2bca0297174f404e9da3cc02d628da18bd55cfd5d9e381d51e91481f6d12007ea25233acb4c241dc0985cb9fcbdb14529d4ee58fdedce983e203e52fa8db4974ec7c89ffb8a6dfa695585d711179aa1a5af49ebf5038f423e833a072bf8ef0af5b058a447afcb1ebaf9ec59e73a2ff271593e1e9955a0a6ada4d2291176b4e639ebf78d115529d1f6fd9880e311fd8dfdf5ba7a0c4ebe0f98011deae6f200e3bac0d05c28e509e0d91798aa52114311a979ca5d88a897cbca3b971a0852f589fac50f8a65d38f93b7cfd0782f4ba2b3b38f167cfc425af5909277997a79660d935d36182bbaddbcaad5b196976ec45da8d2bd73f0494df267c2082551b01a4d84da6f5a65175469625dc7f1300917620bce802d6aa28389cfe47ed768108de1c682c2adddbd1ab6f27763246adb5be82f004f752cc60387ad55ace9f24d036f907f1938c0fcfad15493174a8f71875a29b802f00f23eddd8bcf1a1440a10e3153af41df8baf4c7e47ba92aa65843d77f92d27337255d0be4d40375b3422a0baf3b38268afb4c81c8b5f6c13ae04ad1da67e49f791745ab17bdd55f49fe574ca99fb78dcc5995f9ff7c6090e3dd6c3e096ba69dbedd846c178a64028483dd0c12a4241d84591dcfbd0b2397355fff1f75d2040ae20205eb2e66a1e486ef7b058a76f92dfe2c29f2d499f7f1a65540c63b923cad3055f3ba99f1515ab8130cdd3c00c68f80f83660b2e13c20d7be6891fffbe1b07447820eb8d1714221450a1dfcd59a136840562bce07df16100631213e52d20f433aea2fb45af086feeaa53129293212a2f7413e3d0a73e09be8c7c0532f33402ac71a0983b3c6251438df7e816f154822d058b5b3a83ce9446df761893f51208c1e716338b881bc8ab25de6a6fd0958b5d8c79f066d45be475821f8b821683159e938d0946b1b7d1d0dc3323c96365cddba6ab5d6a5f81bcc656ff38b76dcf75d237993f5338e453c45a00a78ff700e98c95e667913dcbbf78e161e93f3815dbcfe7f5081a857faa741cd852ab4bf71cc2c6e86c52330c770436153b77577432baa6e99d812458fdbfca534df7c6734ace67172b0bee3543c3d50ac413109ef2f6b0af8334f987fc60e35490602602ccc3f3718a24f3e9f00db6adcde86336bd7db5cda0dd911edc2e3cbe622c0d5bc72c00c0f80f5bfc59d628ceb63eadafbe0688b967e8ad7181518743a6f9c95b4720517b67fa5f7c401aa722f51634d7bb54186dbeaf0fd0a14c2cc8fc51abefb8c74b340df8ddba15c84ef82e326f30295dc035cef085fa2b954bd3c2bbfae26ff4e0535bfcf9ef8aa23dc992829687a9abd489491b90f009956817e2612292ab2010449b26d263e58c6f52bd85ac3b527476c5eb316eff4980a9ccdff18bb3cc87c36829530783f35a64cd3d35c5585e9e4577d54f8c01e553d0e29353907eacf915f1c15de51a11e3a8450c95c037f8cb073fc67d61bdac648e37a5e144d3cc6326c530018e200b0233762454eaa7d8d2700db624df7044b1d8ab13102897cdab758f0c185a297b850d93ea13556c979f5dd9f1cd339acd9bfeb0ab92b8dbb12ed65f3e13ee0632f7c4473b62d1ce5e7d938c785692f71742f5086575e56e03ea196fc98186919290020a29306bf51cd597a53bdcbef638769f212fa358fa49bbeec9988af6740ef68bb37c03f39376f1fd34c84eb35185d1a659609da8368550f3a2b2d6e52c387e784ab48ffb03226bf7aa9b2560fb39cf3402bee93b30182a23b9ee8c8c9790741f7a96786674b6c9cbb9b26e41857596daa19fed0f94f9bc2bc80ea881426bb894b7e6b7fdb492804d9bc10f338cd5ae0231516807b55b0639f9b78863456ba22d5c3765757ebc4b1d38cc09e7d3ab0aa8da1459bd4befa25ed13874b3477d504a9df0af80c18721cd0f8d927726b0187a8a335f9ff2533c577de65d58ef924b584f416a420155498e9aa91c4d3d6479a9cd370eda8e488f9f615979b16238465f738233e1f35db859a24fdf6c8b6ec98357cb0f1d3078d11cdb352cb64eb5f4174088a8cb3c567ebff68e92e48a8236625ce4d6175bb54646413c068e8c8bbe5206fd332198bb998fdfeaca8d599caf6b1bb4502ee1c48f88b28052f1522767615f292bba416cc6dd659333fb1b16d207967b7be0bf680ae9a72585d6851f45180fcdc750d39c4e69fbdc2cf3ad038f1fdceb31546f94e27d22c9e45ebc6cd94f0d169d46a7c41aa5c9a49838d66d685c51f66a510e716521b701fb1ed128a65ab29e9453d6604dc39ffce15da8afb8fd6629f1d2612f6962349fec55b13f13455cc5a608d0919c5fc5405169951aa12aefddaccd78b19b2988c96c206dc58b57ed225b22e4baf03f2421b6239c0f1698e10c67eb9b5784170bb9316000320f3d2de0082e3fb64e04260c999df8d4e45b833565b08f9c68a1f8d7f5ad07e3cd7aa560bb64ce721e9eee94e116bf71cdea3425e64d8c7ea556907944a20b4436a4551020c9aa0be8b34c1b652afbed18e5c897da4b001f088ff2e91050bcad59a2e91a5feb24d094ec6e09574fe72497b617dfd862175bc8571dfe8928af10d4dabd3dadcd9ba921ee10f093717f1a572eccb735817422d9dd27301d49e04208f2a6e6215f7d75c6e14a163567e9623aae4115ef68b7dae0c73d3b78db8ae7ebabe1da1815233b974ac3a4f549a27bfdc40c1b8eea876dd2036ee8d3dcfcd3c3d8477f3d88ef2a59cdb3bdc9de365e14423934a91f4bedf9e45b840a148b38d9ca40c66d051d79c02da715e64ed5c660070dc8287eea0c271b6e47618db557ea28b8226da1f67a5ae977f8e1aa2bcb261f49fd6f3d9ceebf5d31cd1bb92586f7bd62a94f423087787304ce9f26b634b3f403ed48f68ee43cc73fa41110b38c64a53836db24a925d3eea6c6b22af37bcc26255d0801856a0eba1831b76ebdb2cdf76ef9dcd3b94b7d5433257e8a852b2eb1a8d538377ec493b47ce2e0f8e039e792d628adf7995b0b5461b5d8b65d6a6eec56a751a03989ee885d76f1b1535b67da06d7c1e3552927f221308b763bd3f4d8eaaf839d403cb0afc19247f8090b2a5d6ec87a54835d021ebd76db2b92113d7dcda22ae83186ff0cd2c731424f2ef2b7da4276b21b5681c288791d59eab1299a6e4833f4a8dcecb3cda50cec4cfa0716fccbb2533f540dd9820df10693bc77d99a181fe2565ca5f3132db57e48506b878fac38f78fe1d1f0fa72ddcf30dd032bf7c4ac4f14e8f47b2f29129b6f13a1fff624eb90ad90a6bb957aff0d6036d7f0d181ddaf7063b4a1c6818529dd1063635f372e106bc51226361e6395a7ff60d969699eca678a05c645cb17d9d867e694903e9b3f3cdf400fc486e73a515c5681c0fec199c3355b4e0e0d731e97d181ad3b8da64e054e9e2c413da8a3afcd68dec1573f43c8f79987f34a3e4ad481e8e01fc40edfcdf5f66ffa08f85e658c29ef9e2cce3e04879b1aad800356b2572861479cbb9bc2bde863af6584eb84722f2a0d66ce8105d5498b9d6f4fddbac3951084436fb1f7c6f7af1223bba672f47133ba8454b34a34300e0ce59820d725912a4f421ccf103e4007f0f800a837456cd98f0549cb02da12beb4f78c81b12edad65ac2e2c79a4778169ec5d6840c27634c0fbf89c324df39949fcfe2675d98a9919fbcc44aaffe6ad36b6dcd0ad14012379f4a9e00a1519bf5b8405cd72b05a19ae5d4cd37bbc0a23dbd72eaf4b7eb53d2facbae67a07d77db897ebc28cab9cdc752f2aac5b117707423079c0a7b3afba842749adaaf10cb5114e39b02e1f8c9961dc311524f98328b105981818f5c63209c3804b21824a75e4417c2c2a68d5ebacbacc6d814a8b360ef999adb3670a5ae29f4bca23c5a5d635f3a554434ead7caca50ffb07dbd6c512313d395ca721154043f8889ac22d3f4e2984618be06debbac3d4f45d392bc7c772b7a5f900ff5a05c50c01540ea15917a6bf6087228a43517c25db9f88dd6690f94837aac3c51ecfd92ad9dcbd29046f59d22642f5de65f003fc94c36acee6d4730a60e57454d0e36766fbad24bdf44d05d45763f7350e446491c6af6b7eedc695f63b5fc3cf0d7eb65fe4382897d9c130e28851e0cf2894436bc12f4586951e069886909eb25c3d2307067ea49496c24ee97d6153d7cee5b4f883092be97717ecd51998fb8d940f5e9775700a719c2af27a1c4e4da6f9fabaf2ee106c053917119bd25d231ff24e12f10e3029817cf7856400b44bb2992d8ae072684d5dba68e504e0b61e77073a3d6c786609c46c7bdf8b932b89d6bfb4c61e52a29079f0a608b7f3ad6ff9db8bf12609da3615a70ae09a38a0428223b51bf655dd344d49e73b2740e90b792cede8639e2fb365b23e38776fee17d69bff3f0d555f503c0409bc6468e9129dd8c0dc30305fdbfd97b96f1dd4a04c4c2703ce145c0b6eef647033f3fc0b64a394cdb9405955fdf09b6ca9fa26dcc85618af6c104dc90ac6c30c6eac00b41a1b70a6536ef9d73556f635d8e1b8072580c45fdc799b5f2bb66f36be4d4bd1fe10d59d8e6732813f7074a6aed001ab12de28ca35cfdf0c058bc04258c1a154e07c54768c219bf32ec5dc11b99db1299c863545c65b07185ecdc64d8c2bc2cf05dee3f1d05dd443779251f237cd3359d15f57a75d46788031d29578c70260913ab242cd9108ef6a9dff225a473261e47e0c836f28e2d446be70f246e608e2ae0d4eebafb6ef1ffc48617ae407f30b0f0f35e6dec4cf65a3274e8c00705508f68767d1217e4f6cffcb14ea3375fc6d71ec5e2e98ea6aa94d5e292c2e2906e44cd5b85f364e7a55d1b30064f022e905d4550cb12a4461e65feac7eaba076a9c023254922f75a7d1d89556d894e49e2309b19bdfc1f08d3e2b124985b0f570b1445b72771e8d242c5122b6a4efcbd9e594c82a900daeb2557e1e2693304f13ce9231372eaee3dbbda89473bef2ba51462d5c42782c32e18b74c1a07c1a9f044ab36fb835ad60a892d9e17e669f28af9879b55535e467fcd61000926176316542dbb6275327ea26ed7c376e1cd8bf3d3eff492ca2ae8bc4a83d4ba62317871108c77d164ea89c3d6119c85378eb8b7d7cf534a33a026a7b41aff53a198b4944143f58dca9c0d77c4abe5e1ce9b9a05766acb9234c256e649044f9c6364aa7bc79df4583e7e8191a342ea892639f5c52ac0699441db9942e20142e3069b5c85cfd0c63c694d42736ba18122738b2f62c111f02d985da126c91ff50cd51c1f689e1782eb8454a4ac7c1cd4af288f3a3c3ab0e442003f5243ba05af61498bc6b3519e4f93cf7e289dc950f27b0dcbd2494915baefebe6de9834e6cd6d9a61bc41197ffde0eaedc1cbf411a0816b824171f1ff55e9ade130df3b460720011098ac7199242b6a7041729d0df5e3aece3eef146acca41001d39cfa94a3cd09f1ba4f86d0d96d4001dcef51b4dffd623b48bbf52886decb45380b93e37874a3d3cdab011de3f8fce031d7f249c868f1e4a797331b145e3a6167234d030b82e840904585646610715053ccc51e2644981c2d2a728499c06924c4a611344005ce188351687b33dc77b88b1b02fa4674de2b5d9a5c0da7e43617cd4e41825db7ce7cd1ceb9bec15c91d92fc6b16b7a102d90ec66eba90f057e80ac73504294c1b730ab473940a3c1dc281ca5c8696cf299834f2690c0e0dc7e357d0fd092bcc67ed0cb24dc5f077c63ad176ff6e425306d375b4c052d1fa641b92a4ac17053153993fae42a6e52be4ffd6062bd4f8ee9a34fa7e7f9143f621adf7639e75a3d86413f262effc7e78b70f5f3ff68922f31e9df3d5c885c0994853b60fe667248c1e23be13fa3ff8797a18a3b7d480fa40ac2ae799f27997f91dc5b2e3e3033c77332afa190765e617015ddd14f56bf57e11e6c377ffb3d65eb4a67cc54aee075c27e46c17451246e948469b600e401359cf109bdce619bb5ccaf8b7ae1108bc47be689c32ef833976672d691757de246d255e1cd72117beb3e02722324f75533d7bad35de41a924375b46301a437e4fabf77587d43552aace5fe483b17cd4284d2f5e85bd41ada3258fc8d56ceaf26b0597bf6e4d8cb41e424d798b2088f5038ef7d65a227e276ea0caa59ad767f9edac0e495ca2fa162f7b801c121e26f424318031cd7e9dbadc0e9f4149e88a6b0a644b84077d3ce7c37e543d1ba1f09f6320d51413e295aaf9d0668fff1fa2eecc06230a9114f091481135bf6b03a13fd3e793f38f987e14e011d15faf51812e7788c65120567590327e0983cd215583997a75e1d088c950ba8cfe4161d3fa6df7a3a17c9931c1064d6fbd969229d347abec38f63260597cf42b7cd19d7a63d7afd755ad098dbae65c6b196dd66daec9c2936e24cc47acbe521aeb3b392e8080c8be5f9b99105468ca45c60726a10d7f1b943e7776c20055514c5c63c788cac76def9a9316cd353550f23db8a4d308f1ee5c1d5ece4b2b7f19fc55001025e6ceebcdc645152986be5d312b9fb51c5914476961e23485adfe2c194114dff877c74efd3c0435c3f0877a4ae60ed3501836eff735f88c69d630262522ed37f3431343eacb5758ea3df87555af7e273ac243569ca8ff0c58b6cabe306f1b5db6a3c2d6b8d9a42b780168921a366db7f507080f95129703a812c3155ad164784309a88a83cd7630af392c742c917a0ca0f446caebc5b80fa329f5b80377a0e1a3a9c00183fdab5f5957342cd54815b15bf5ccdb18c5bb65627b186aaf7f213951b423845d3f0b60c9536553986c6608d66c6c21acc8c14e21af1c7c15751b309e4dd2eb3eb5560ab9444ed0c86a0452a18bfd3195f5906cc4cc2be4dae430bac959a0df8b9f0a29f842d54df016825181aad36f372815e834672667f91a035facdb18517c5dc6e92548274be00ee7ecda7d0c3c11c786a8d04788bcd6c453b81719a53260c17825cd521d1dad997156832d39c3af86e7369856bb3603361bb03ff6502fb0591251fd8d868a306f3eadc4ddf3466be942f7ff242c6536b128ab337c1aeee78612e4affe591fe6ac0afd5ecd2bc56a06485a0448fe9633fb2d5280eeebc5e3d2ac212bdda2201fdf2b5cd3463eebbc8fb09f0bf661c78337ee9bc4cb1da0f18c93674891734f5cd13fd9f33570d2bca62f02532edfef2497f21f639f535729cabcf0a963a826baa13453737555fdacbdab89e72bc95c9d4e8bf19ea7ecd9623a8ab99ead320e82398ca59808b29c62a769a7967c17f6947c192790de7bab2e6d10e4babbffdee6041578d7ee2832c803539c4be97419cfbe8c3f03fd42439702690456a34375bda4f26e0c3d0c9357b492c3cb1004bd8c9d0a6e66558a9ae6b12c208404c8eba55b547155ff1d1bb70e39b2c093a8235803198f9afe49b45a79b4b5fff151db3a856a1053b987805c58f54ef24ff67ddc01ce8d44ce1c2cdc36c769a43379032bf30a6a75875db9e3f3ad89533d0f381b315a64391dfa42d302a3509831cbf067db24250eb75c43b73cfdc36bcb638b564195b820a8efe3b0db2a8774f3ad4af812147267ed5eeefe59cf64d4c0ceb95f968bced3aa49fec1ee8a586b0dd40665f19fbbf1bfb38a117ae9a1adea6201a4e673d89267b24da17923d92b720c6408bca7f4a53eee40e212e06a21958b179c75fcf919b30dd9b2995299160c1ea480ad90ac962e04029c9d0f961be5ca942924320dbc4c8f2e5c4c14c0e3e67e0901b75e0149de32fc953d6950a38feecf66324e1d25f8e7197637a66d40e31c582589b86bbabe23ff898b1f480ac00dd828f9454e7f0ad258c2233cdca94f9fc5b9b94d706048bc5ed0a29fdb5d85ffdbb7e4a4ee1802d187bd53d92fdf0896bdc2c07c49f928de9265b80463e84738bc034e44bfca7fcde293a98a9ca24f859d08ebeacb07284f349cca9f9ac5e87f8a448a4450b1a8ad8c1a22186f2e91f69dac3e95d544beab11b3851499653157e3aa58ac3634b948237f282f0400cefe921e809aefa89ea59e91ee502ce7579aebf1044ac173af978159114d40ffd69631bb4e430c9b65bd89810a10dc84cfb95f67ac8e01c2f620a613e58f388fcab2a3de8c75723fe4a8dea95e5edc4b398fd7e2274a8fd383ac7917d371eec796ca2be2f20a69b84b3db741da907624b0188b54ead68e7b5326df53b84c36c48bc86907302bbcc5bcde52dc43602797f4e92b750968f40ac056fbabdf77854d5296013d225a8272a7f66604cf1bd03e63d033155de8079d496b7dd1cba9f92d8f7bcf81e703ca9d5e4d5ed2728171ba19d730e7d45a88716f4fcf191ea9395f9a2edd76401aa5ed57122dffc3a7103189e224a180c468d1fbe7b988fce22c2ea79bcb459a4eca9a6c5ae5fa32a8d8d985cdbdb740664ed6ab9b322fca127df5059190dbd572940024acc4ec02ab14be97833f57072695d1475d988264301b688c68c3dd88051fcf969c864b5dfc2aff2f1705bc6339c7f544ab259b394eae2d2b2f75e3f0f96ba127d747f967709a4554db6ec94d470827a477ca910fc93ed42f31dc891d595e989ba284a6685f56dc51875126f82ce1034dbf4d784a3e33e1d2b36ec3b14d6a4cfae7307956c6eb0879fd990114de8f506d40dfa4074a2dc60d7505fdc03ed23626508cf861d933b39b277185dfd7775fef2796540552ac16e524e622e323b3fd69601a1341ed9b0dbf78dd8a364d44f98717a3a7c4d828e31dd1f0a34a0e37a65fa41e0f09934cf88940ebaae2336a8e2ba1e29745b6423928aa9db5abb84a749043327976f057a91e8ff558747663ce03b31fa6cd203015b58019e3229d7da6721c5bfcef265fbee7d3ee465debac9ffa46d723e819880826e03645a0649e61bf9c7e209cb3227022278b8d3cc9708d75faa25103feb1d0ccb631c1d67d36d0567f5bb0727ce8d0b365efb960aa68a80f0e3ba6e2bc295217f6e5efd079c097e55b80f26bb69f832dc6af549f0777d67c938f3a0b5e221295127e8f3ac08c0125fc47d15717bba2d6126e708c5e8e62ff96433bb4ad9b8d69b11f5b0ba7f19edf2dd541cdda6533e66a6f1f5a5b12f9d82d0969f44d9733f2e4042a2c663483e8787310f6f8438ce7567e6f5672c683d3bc123481b36359331d1b26e8484da4afefce55aad3b7296cc2a781a84e68e7816c4cc4b94bbae7ae037b43e7784642d0d9f6cd0b617e78db6e85f3db48730695080628aa5b3611b23f114796cb4cd364487bf2a2b719d9b2406c9ae8620b03e934497c45a13d56de86d1e9ebc78d1088edf6c4da1c140b6dea0e378a1cca24a70025fa91d2382bb00d9ae371f1ef8ef4e2b6ca81df848f0860b7674a9b427fd94cd825ed91ebf54ceb8af0ae9f334d5fc109507482c384b3f755fa22ba8e58885b0b0545e234df92a36a59cf16c1938c482db6f254e8540a7bad9c4243e303b82d581d16cfaabbe9e86e2647198ca8c49b96219fe73a97fcd5549f589981ba89b148e0cc0c5c2d2d5b2aea38b218cd90bc84125bc56e7867871629f9f1be8f19d2827209d5ae4a3605dff8faf77c271a8e95171ab1ceac794c65ae7f3a804804fca91f7e10f1ae8055d11eb9660c451283af9cc51ae4f79d377f152297636afce3a7f7880caacdeab90ba9292ea4848e0ae1ae0a75279c121e8f0d91819aff4899e38cf74e50c21a2513b2df6ce7fc413f2d27e1d8343769be1f1c892854b727d3a4c52472b1d1acd259a4579ad576404ada59669794b00aa95a5afdae629a4ca9763d3c57a11cbd2f4905fa448802254dc5b366505013b81dc13f3ac95e385a0eb76ca53e8161900d96aed3edc2f4141c7d8f861a2b6ddf9d46953c4b40fc06e2eb83e10473d7e9be538f2965443c7091064bf884e6bf42947dee6cadef5359e0bdc866a979ef309c49f6614179b4c410aae07d7d6305d02f33224b30831cb486f592a5277118bce9ab8cc8a7e38f2a93f874f9d61df7d29f70e5fe0c28984f7cc9ed8b082f209c95c33c82a4622bb4b2e0bde322c5d3fc7302e66aec8cb7d559f134c514cf310b63089cc31b2b2a8cfdd79e9f5a21779d791a1f0bc649417bb0364e24073493e530ff7cc6126d68c8106d63b5bf5cac0cb5ab59268d6139c3af22b00e89043a546ffc881b2866e0e58bc03944ff3f1c9d7ed44151e14f9349f6d52adba02b7886d6439c58cc571fed49eb4fa21b44e7c2015849e3cc3e81b7a9a698c1a70f6e619f3187a8c77c4bc88ff263624d4201ce519d10196181e49af154045dd003c1ec23672eac8b06fa05ed82a54eec2798d4a6838f2d8a45d52ab0c32f131656dd35ed66651235fa712c30b03b3bd962128328024527fe54c10454f2c1931d3dea436b1f63388583d1d36cfbc1e3ca8f974f6d32bfe1c3ce0a7cb88eb4423d094462ec074850ababaf4268975ceb445bd1dbee19ea872b9fc83b6c320ca45ed2498a25bb3b2c83040e937fa5aa3da4b6a5811cb5a69ed979eead635492a6ee86aa5d38d1e93ae72fd8816e79fca70209b70e7736f88815ffe876b584c105ec71c88892b734433347c56941d4ec9dc88da6d9678ff55536fb31e2ffd69c9cfe26c1ab963867989b5711fdeeb1d511514d3a7df980d105bd87e94244a560b1875c8aec90fccea408942ec0537dc4a6a2e329bbdfc997c68ece9e45d11d6f63e6765fa3880a8f8b9fe76a2978b96fdc4e2f3a0989c15f121ba27e3ee64b8a90781044666a9bc8f5ee67cac8b2ed92d2c026775d43e50d8cce9cbca68f83176684d45f9071879f73fb79c237653cbbc0521a9d288f8cee10bc4aa18232201249f9db0a7d9ac0c707c610c1ca8ebbe155a474e082c35e810932b86eea7e86e513ca38420fd67b6248d9eae5e7a40449c3213433d334922c89ab695eb25a2c9c98c4867a1d1eb64aa6f4ec4a2f7e31a7bfbc49822aa4ec231512501683ea3825eea6a3137f72ac1e11f3b798cb71affdd10944c7ea41495eb7d2f26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
