<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d43a0ebce5aac8a79611e23b335ef724e09d384e3563d1de1ae481ec21568dc3a9e71c73217b392a0d428a7f203b1254678ee632fa85c9bfbc4ec72f7321ed97901be2b3b5032fb613dde233b1d789da10faba04e5fdb0b3f956d7213d75e402dac1a35af8e765e7bdd41a53bc20e3d2aec562ca63945136738f74f4a8495159f2780a7a3d51fe1c0abc1f9437fc5b0035dd00f232e663986661639ac6c152be8b6624a013c1b6c32e3e745b973beab76ff25b143544cd531a3cfead11425ad55d6a1d657822e357bfb8894f31a9458c400b414bbc03e5e1cdf067f0332b1593a6b251528086a7acc996d1ea91f5bcea5c8a721899c8e7ce81709386af9dbaaba13e4ac4768c6c3f406dd2a77fee2fb7a9fb7dbbb6981e105382ace4f5e63fbc52ad0d5ee3c47b188580a4fefd406d54f2c71a9eec4b7b95101dc026fde43915d253ec8caa7a25422ce44203211bc95aef9d6509422a1545f84e2df058ffa60e5afdc267ae19aba9378d32f3d2fef1fd635855266434625cea6435ca0315798094b12f1f7d057172c91be1cf450d54f4c2ce907334077c888f1b5eb7ce8c4bafd4bcb6a32d24c3c1b8bd1a2be478552141cab1e10931edf3a42f0ada86614743430b6e07e45ce99a3238a262947e81b6984bec4c836e5732b4fe1807934934d45173791b57887e8e56c6025b759beb761136b66f99f522264b30f417933c1564ba1b31580020b7bbd3b8f9df236b41845a3b4459584792f63ab6c5f18ce10a8b1adb32fc8c1a97a0816c8a4023dadd706b295c8f1eefbc217eb0be1a900f1b977e3c11a66bc41054c87efa3e5390ff61bdb7e13601945a6f2f7006f85659bd296cd4eb1dd803bbe58ac4525ff608b169feae3ddce94cd7140d3b0d8b7ceb5344d44a409eefa4e9767ca7879a1129ae355178fa86de070a6f36469c5f7b9fccb6c6656eda7a1ac378bb56a4251f235b448602fa6af105e90c7daa2f33cfefb6a9bdd955234a9bdcc6cee498d9dceaee580250cecc50993bde777dae60d84de313514b5f77a7880ab0f5b357893703a7dcd28ecf32911046c8a22881bced6d3288b9b0f15a55980ab4d874e2052e352deb74448b3b6243a8fd294a569d5a07bd06ab5dc83454426d3df9fafb4fecbead364d686b31523788c1e8a9c6111e3daaa175bc9f889f2f2df39adb5dba8514e12d1e8849c036f84a8181c2fad8468c51e7421f09b8fef517db941ef41609383b66888e2a9f3e8cfc202c6521a2cf1c4650568bf6e104078111b0cf44d4f880dd2e3d4a4e852fa156a06149f57b42b3cb453670784b00d7941d473bbcbbf20a38ae825aaac9166faa8077d250916bd141176ddf2229168f6c578c65068a0c0ddd4fc33197ab6225e90e4a97c2b4a0fad893978a9b10b7c9f0531277150fe2d8c5dbb4053093aa58961d118c09917b201e475ac5d1b950145fd84a7a8ecccc25544c7781227e0e3b0a351648069a53df6eac7d91c6fdcd109363536a4296687475fdcabc332e053b3dcc619abfeb20e2abb50933d20c892be37dd6223a36a694fd2c0063ff2a3b194df6b7594f2195ef421fa7c8fa5bcade1ff0908c938e7781d38f4e430921a2c1f8bce64ddc1622b56024d19e513852b1c1300b58f5292d1ccdf7a597fd70729a8d71d3977ab34d0f56bbdd78b3ade9bedb7831bc98c1265e10be32cf71774571a46efc3818a1ed1499ad286d558360105cd80022250e025f01140172310ffd37315ef54ae05a9c80c509d16ee841c072e3e4fdcf151a95d784c482b75a85ed02a55ab90f4630d1b0e767df19ded66b3360af8158a6291a3616e0f84c251a946d085d4aadfa400708729730a4d5da1f628fb3e100a7d0b66123b64d7b9d660b8311e0f173d2462b1c7f170f613d1aebabe87409ea8dd92bd1216e691c078f0cfa3fe3218e657de850335247b18f7b82fb8b2be575b5af6826a1edd9409a70d89660ffc568a693a3c49c04d907922a872ffe8018f888b7db62251bc0dc5cde9e83bdef7b8eccf76b44c910f6b040d4f7e3c12ee52874e2640d78af278ffb15be046f044174006abf330a8fb3aceb05a4bbec14981a156c15e3578caf402b4d7a92585c496caaf2d0fad7c01ef504cf8d5b56a9992b22b33320d07efb1073e0cedc524acd58643b2019e32d541d2d9d7bc1d69975a201ba04665706a8b3c3faf6428638bd33c6306cf4bba3ee0832b9c90362369befdbecf016e4167de08c492d348b241006de324483c21369a4e8cb223d7e3f05919aca2db5f25482b421d73505afdedd859ebe48a7d611763853c6e35b1f64a47346c58024774d7781f07d5b3ab32111e9603d6597d278a3f8a092653f3135ad81ebde55325906ad38a289f9fc3fba1d93c0d25e440935e0277178b7241be801dd6af4e9acfd06fe8bafbebfcd96dbf1f5ff2b00ea917129df62915ac66f183fbccc8d527e4c8f53206fac9dec310e0eee1270dd3d9025306b38b5ed3b7046698627aac4d0277effdb00ea03fb0eaf867f309a5f09d9a8f786c0d22c210c379bac3b535fa12eb8a257f535913ccb4b8dc2b505717e86af7c84f776845239a0c03b086e910ca12c40e8aa6b6f1bfbfea4cb04bb26ee8aa708b28b4ebe04ebd6d3ad41fe389fc97916cec0e6a5d5505ec4c5c3b55e10f8c9585ba3dd8af062ca3f141c86e2cccce8c1fb2ce2797b9c62692b28b7c2f0c19dd78f5982c295618d95904a6613e0040340502d21b1e176d2973bca9d76a506f61a29f079cdf0b22993f48219b63ecfc1f4e55d4d0f3be087c5206eef373049c6e9114d15245855731d26f3db2f477fe69e1c7ff40a9b007efd7c987e4f50528c99b88a77be779477c7ae0a4d4b2f2fd7c436af4a8b1a204e50b32530c1ef708a7d82727ef9dd49912bdf43cef6c6c632cf3a1433f6378d452f58340d77bad355b330c1551928bce1057fa491831a98f6dcb48dbdb800179c50470071a2260a9358242193a92e805fe6b036cfb4b7b0c10a08193c7084cfcb01572b45b5a746fefe05431c47ce0e400ac3792d911aa258f93dcb01e16119a270ddea622fd26f08d43d70c752a84589f097d3fb824eb68382285355467d95811e14716b079b73a3c212501cb86c6f7a2d57b7c51082aa48bf8b4a2837bcde5be6d2e6840786e92362c535789349e292a00313355772823d33c8944d436b9c02431b823eff9d24668a1baac9c45289dd2a4d76b5f3cd54258769ad33339b72697415d72c82358abebea93319ba59d104bc4aa016904b7a2fd85f19d63332e598869c1af58f2977c3454e2dcd6b2e42c76b33c2cc3d6096ce880700156cca3adb9c0f0ac4d8a74dbe9d7c066f935409d1d9c53e151d4e44608ebe862578c8afa5ff6993c0a3cad7a72232483987e77664da9600e5c8432791687711c5793da6e1a75fc55d974121c5daff5446f7fa42250e5f2d18b6a16ec7aeb4f4c0d115b3c27d7648aa54c8e2cd6ef7ffae8ffe2622e5974e54bfb88acc3add96bb2919b9f432c8738c45112839be90f972bab42218a83e660a6080c2a3b49b0f6ecbc4c6aa9e24c7e60c6668bd3ff0d8df379ed1d78493572a09577a4fb2a163290e506a85eb788ba962a7bfc57b6d2ba57680526e2cd9ed558ff5d9916d5c76d765c30ee33f36f8733eddecba1c95083399261f7a6f7752d5b60e96bb2446f1d58fc9a7e55106c693c4b2eb99c5740fc531a378f60398de211c37b22845288d00f12fbf30fd97ce8644164db9a712cbee6a35061b3bd958be6477cf5b5d1919a2e970acaa5d7b76aa9b1b416be1893633688baa26b56823e30dae839853b8eb154b001b556f99125c8efa890a2279e710646464661a66a71e72be256d16d9ec223b292ef4421765f2ed143f0266a3afe73bf05f973d3a0f99c4fe056756f16f2274edb0fde00394ee24a32b94fecc42316ef420b94d53f0502cdcfcce67bbd0c88e638d40b8cb3ae31fd372fc52c10074da12c742bea11bbc1316ffa35e91f4854221372eee6cd7dd2f87048597f77cf90e071482369d519758c1a04c99c045fa16d0e3e80d80c1d859eab5ddeeb1a6d74fd112f2c076920dff659999098889bc77bb3a74710bbc1fa45d750107b7ba564274adf29825eb6039b90a6c3144b8805e92ccc4cccfb0f3a30e930b7255ad96f1172512946d2d31277b01dde631d0ec1088e27fa17d768d01769d3285e8d3a694ed02a37e6828ceb74cb31c34ab16d7c27dc578d7d245f5190576303ce4dd500c564276bd1ee2f6385b84cb3fbac33103c535196e739610bb951af6a6d82404233fd4cf821cdd9091581f36a5db843320c51ed1dff4f63e72d8e3533db10212d37614d490932c8ed931c074f88cedac771bf074ced54b754a033e17518b4f8b1e247409ec176546b45fcb32e26021f36b2d6e5e7bf77b7e0e5e7ce330f129795e5973be252ebcdc5e997c45e91c368a7fad96e3fdcdc377cf30c74fb4729ac305e545cee0ca4593864090b4920514803c88e22e62cfc0e983fdfb5dbed170d1a5d58c6b42a7d50033bdf59761746df95584311195f20ade60000d88c221db38e21e441c642a04549217307a150d2fdd7a123b99c39d67957424eef26a36d59b67b4608bf080518b0ae1efdd0fc208090a506901153491d687584b283990712dc19b1cda8e89ffba6a8604c6bc0c43d84fcb25a9ad81aa5a67d6df8e18c6d88ab87e2574da3af82b33730db0944e5fb92a9490888016a3d7136b4a1d229dcfa3832ad5a00fbe3795927e818029328b7e59cdfa763d4fda0ba90a27e3b5c1cbb257fd585d8d581c1c62b16917345d21ad5258182276b8f44d3f43fc7a1fb6036cb533ebbe6ec50811d9b735c0ac31aa350310a2a00888639484f6d8f221e4fb0182c3d5b787e5182275ff8da8f80d44d5ab619c96f35b8c2ba071d48b309b55b2a25d09315d00337b24fa5f5cd2621095217244cb3602069259c452128c4292396b9f8c8942e1ed5b54b1286fe61d451f6d97c13ae26eeb3adb017429227c1ae786cbc20effd3510ea53da5d5598d520ad9ea5964e33b8eb8ce23df75b975b69c5fadeb7f5a623795de66fc76785426895d0db7ab7cec728c1263204ebf8f35ba98dec613bc8eabf803df9623302a0ceeaaad517c71e395249de8d90ce9763a7b08f1b1ec64e2e78ea7e20f75211944f2d772a179a79c10a6f4b31c660105dd64c814a3ca7c2cf7b33b3106ffd8d19d26911be4b1f533b25afcd3b1bbb6f362a2c5f74652edd7c36b4ff312736137ecaab7f4b98408d05ca46f2706b85d99cd2e678ade2d856b969e0016d5bc198d9514d4c5df2f15593d4016d3f04a67400a85310832a35db34e9f8660372ad6796bd2a65da5a170d11042623d9130eb51887084549509cac1be825b28636322bd33c3c00036df663374afd0071e87edcfc3288230c74f233a55689b06abb46c93c811bf60bd002206c88c345cc3165afc84313a574f8804a6fc7ba3411313055e09215146b7f72338a1b4cbbdcb2d73c327926016d2831e9bb2f9a4ebaf5001b5f93e1bc0ae4e7d2f8ca4c2641fda64cd576b43edb4d4944e2750584b486e3357cb3614b3b8106547d8916a4956e0629385e6d1427c85797cfca54d4acc27bf7ce7f162e256f624b26fd6a5af7d5dfe02c2fcf075898c85cd103d1f2d1d650e33a376fa2f21309237e9b9182a72c15cd1f8341b3a36f9fbca7dfaabe250761e6d14140c652cf0c95908b6f2b4bc5b2aa8c99708792e1c504b73dd2598b7f5d3b38f47e5762a3929e344d75a3c87da7038a269e1cbabe96ca65855a26b3bc0e3ae5bc6c5758790e3f67d94f47445cbebd50aa94fa448ab8b49d60bc232b32a1501e572d4b3112ddadb9d46b8fe4ae2f80ac91c57461dbc95615c12d1899b4a61d310077c4e7abac4723711f76efd3fd6dbf9adc3dc7495cd33e808bfdfda7843ad49a704bb17b425ebeaa6a6979f61da7611029ef4e3ead0667f787a577521ab7b055d6224fd8bacf37ea2b4ab3249f40e115ae9001f7086bbc4bdff571bc1ec390463bc639a0faa967d2be53f2b79c18685777f2ec4dee8ff1ef89ef916c0519f0cfe9f87c2bc03f63175d2c55abd2f091e45d1f316697e7083a976be156f4760bf3f8e60d5c1cf5c18f2556cb2119e2af1f72bb8303465695e660e7c3ab7e08a2c8214809aa3baae738494fecc3859492b0aa8abe7a609771f27d3a0326ee67e268f44bc2354fff3d638cafe998043732ffaceca03dc57e7ea425ee07187002b9b6029c8cb430763a1cadb3fd1d5d6b214901edc093972ea3493bcb6761b563b2381a1ef2182fd8376f9e7b929a323be4b54edc785e50bd5316ad04708e07cc90fbe0ba63b726bcddbdc9c476640202f7fcc1e322fd27b521e0a65e343f1b7b3c4ebcd1382af977f16101fd5163aaa7137b7f7524496ff263a84b6b7aab9bb72cfc19fcb60b4074d90b59ca3049d84d4065297b9683ebc40d0e834ceca252cba547e21e0de3ce737865f8830d1c561e2e08647835521ef831349fac75b68e9b9902234455dbe94855e2a7c11776fe7aedcfc6e740f91ef8e2bd0380d71e3998e4a0d26ffa5169fbd207dc11aa74cbe21bbf94c800400bf8ebaf525d4c969244a027074a13cff767dd495c79b307e6b90506cf30102ac41e4cc329c629d9341f82a0f4fd4e068b0f804f898a424cb225144800df65fc6bbadb0344a07cc6f2f069ded85f4b84ac62596384786f617eeea61535b6d9ef2728c998771e5b0924301afe29b83a29fe3013d565e644251f06d067ab5bb041ee5526e5ed91c10071682a4583ec8e703c58860f3e1a5349ca45ea508203973812d6124ffac66fc3404c6f6307047e209ba18ffe31fe67a89b710cba79b8ba7530c0c75af812cad920f3b81a9e6f97bfc20272a3e395d2596b501a83029142d2c1a798578932eb20a289a8aec9c3952ea41cde0d8e21e770196b358e11678c14b96d806d5155cfde1d772b196e5b1f8e07e626e6dbadab9f3e23f998e2151d2dcc7e0f08eb06e986b15dd101caacafc8620cfec9c43fd0991e265450ffc085908aa1cd39e9ebec184547445e5951e87fa6cfa82bb2573d569ac0ac38eb5c438f5861233246836cb27d77e8490fe8ba5236fc2355e3ee084bd5fe4529b6746eefb7353ba0264f76204cc1888f9b72801c520e1145ed5e860b20ced1fdd67ac898cdce44e7be291654e8f05d648c7989163b9a0f2c46f70b2867831cfd41ca1ef02a3005aa9eee94253fd6dd504cfd253b5fe3feb2080a0fc588f6b68335fb93d9221386af923e70f881254c377ef3bfcb1aa47be268ebb2e6ac211251450884e2ac00e99acdb176afa24e08155a93720ce81a90eb496260e2561ceb186ae3817b269879ef29ab74d0e14fc321d76905927a205dacfe014d207dbbdfc753d3606bef3fc661a0d728dc83b94ee5d5ea6a66c6eff34f4bcb71fa11e1afda50d3cec1967ba3d5ca3da801300213d3274d0297fd054119cf3c90e48f1041f2d3111e6f48e6179b0e1a5109a3b8eea1ea8c603c6b9e6711a8a053f44587f7f613c3115169f9fc9d1e1574d96bfed5e5711bc26a1c0762ca0ced7a5602f13b056aa60ecfb3e7a90b6beaac32f411b5ead611d837981792b52ad45b7c5dfc9b03fede4b7a1fe9c0138ed4665af8991634bc30b116d85c17d6669771430f8f954e6851f79a1e5900bd60369a6c7617d21e7b496d0836384fcc359f38ff8e3ee1c08e95a694dcac85f3bdacd06038ae493a478e35b63e2e05e61d0628be7cccba8718a5cad82877b5435b0911fc3907d27db002d0f27ae6de4a346edcfa174465b3303f47a8d71d790a5985c148f478dda1134be443df7256237efcc56702994cbbab4b0d3aea8832b8bae0c76cc2177eb6e2688abbd062a9cfd46b05e465805300547c20b41d8a3d8a937544b808ed587e206d3ceb6d33fea6f372738c68266f7157fda129308d51f723842804b752a428df9f9d2ecccce8f857e841f8f3d84389cfa5ea47407000e010dbaa5f5b4bcacb69c165af66d6dba3aaf7374d71c873376c730bfc74e8524299ff4a53195f595ebfb25da2c34e833c52e3a913d956a47db16dd402441ea71496497911e5aa7a98ddc03caa9c3f77cb5a482280f212931b79da6555b8a5fb2d6197752f17e688c60f6dd4f64d293bc3a718f14db077801320ec3ee8efded5e696e867f238f7b42c4cc4336d81f4a105afe288e53caaf01968c1faa81fce0a9bad22e0f606d678ab2166bf62c42c61188225b913681529fb0459ff6d282ff65f59358db33fe9c617ee2f289303d6e436027542a2194d62700bb5d6ed1618c7b9141495e4a42d1d140d333ecd14af5b0e0d9c1ba1c1398db445683664b9dedcf8a210a879f061da0b306e3034595d62a343e7754c9f02c6e06a8804694c4d4eb716ef22c40c0e031de403af57828c1e1fe827287865aff666e7351c453a04f5d7b64a4220e3d2f719f152dcab0b8040eb99befce2df475372e9b31e1bfeea676178c09c09f071c4aeadc017203f7cee3973c5a41216def4f97ed9bce9c4cfb856cf3325cf643786bb3b390edac0a37bddd4f4133a5896396f6f8d2a626ed9e07b5c9c46b62c7a2f2df379872d14d18170664fdcd355d48bb4c9939ed530b22d4e4eeb7a2722c692341575905adc2b354d0a7a1a544090663272cc7ad1c87a965fba28d1b3e1cbdb931b2b647fb97406d04dff9db686ea72fe40e2f5cb5d1dbb770967dcba3c4a9b814db26888fbe22775b63bf138dd29ab3d01bd04db62c1b49cd558541989080bc8e9783bf7aa3127d992032bec42605c01f97a314c295587ee1bf3d17325a69da47f76b6af9d4eae09aa2774fd7cab4a9efc78be706554a96469a0d8e5f02d46e45a69e0807e05aa1195795a2b9a7ffab8582a4b8c04b7b9ea4a4c0fbd0b291e4bfb7572dd61a17a9f5c678ee033610e0fa49dd2fbb9a533e0fc625785481909b3106e8901a8f7eef4c22d01d4d600dab44eaa7e6abff88ad9da8a89cbd346fa11a40fc17f15416806b30b8dad114d8c0f66ac57d7620dfa79cbc7de05c7900b232301160c662fcdbc9fe2550308f985629f23e3da32ce8c2562d9a598c390e15325a94f6889d3500c5c25ffd909cf73c6b581442de2ce86811513f42d9b6ba90e5dd28c7172c845e3e63bdf970e470140a19b35230be4d69036dbb08eeda45f81ec847a001d374ade9194a5f524cbbe2cb0c3ec327b52467648b345346529924ca347822ecf7fd249fb90fbce96b0522d880f230098632dbdb80b969fdd56acbcd790b1289e33b3a636e91b333ec1b72de3ea9497fa5b98abbaff6ded2d93cfbf7cf6037765b2485b76c6d035f636ce8edabdcf1469b795ff4dcff6ef660d764ac48e036699081a5855b9cf1e52242b7a1e90c1edd20a414e870ed882304a3e4c5594daa7b520296f553f55822a0e45ba900588dc265d0900f6b0b02f82bd8de1750c603e6d87152c12fa282e1cdf9725b1408b18068da88f4c0933d55634c7149abc5d2654413eb6e686506c7d889552ab7cf30f121e5a3c81604d311dacde495fb02dabafa62fae39abb614af6983855dde6a3b4c9da85317c6809eb62750b575dbd838d6c54d7a8c19f77fa8cc2c77b360d1b98c98f8b2eacd8d70bd8585847223f6d5e28c2a6b83b838e26c55a1f02f082d226cfde6fd026aeff58a74757cc8290f24b2c170bf296a04616d96f58cb323e069c3c462eb6f2b640a15364fcd5067fbdf259da1f4a0d33f2cccdb6f2c52a5af30f76f08e5f6d04575f87d21e688148eba66ab4eefa33ee2d0043e6e29143e6be264cd4aa99f07dcc1099d47c74ba8f359a10399cc5e4edc16867d1a8f5fbff9243be57ee55ec6d6d92e35242f2ff4115f24f836a58840e3820a433fde0dd2eb58f8a5ca1a41d850399f1d3a34eb9efc588e8fb4da64c4510676f547231a1429a764cd997e72a1974e1ce258da64c2a6506cb8bba2c341769c5af4c76643ff14ad2fedb200f6323ec7cb789a41db4def9282a359f1d1b47683e92422051258fe103c99caa96b1cf6935bc11aa3b1a379799f1e187f9f297873551457147949f304a7821fc51600c04324bda5be8645f9059f44b3ed49cbdc3706b74096dc2c3bf1bb7a0e33b9fbc9355154c1f40a5bf3e6371a2d0230c7050335389122a242c0bbaf4ae24de357037fc5ff626d94c518777cad5b2da73edb63ba073925db416d197e7d8af54c66975db27dab0b0c64d160fb2e0e35ec09cebff64513fa018f42204d7a6a0780b75d25fb2632f9f42cfee9c856422637122d6d73ab85b8e2321b452d04cccf3f96474caadad343ffb75c397d46f826dd62cb620b08e053a256be95ff20769fb907f6f0dd7529cb3283f22056bf4f28e0278a23463475eb96da707d2dd93570b19030a26a7382aeb825e012b6c5bb1639949e80cd0a6f4ff0a7e10e5e2c9cb1b2d4e4ecb7e96cc7623d42f3ee53808e342b979041cce112cc0cbb26ef4c8544f7b606553483cade80b01346d1ca0d0d48fa71e5180d1f079bfde436260d33326f998cb38674ba0cb16df5df0a51f118cc21b9f254ec80445752b20a377ee24bb137656baae4911cf87374cae9eb45f32769f53a319befdfc8f0c831cd3af4dba89069e93e5bbbb24dd870fd9a7f1af897d516cac6662177a8de1c30867fe3ca75c5424e1d91b7959965a099b7daf55c00fcb57702b89416d3ddd2ebacd1f4c366928383cf612f050c4756eb077fa940beebc0947e1c594342ed307066b314ce3e21adb20e87cf803d77c9ea07e743a64519f84dc6c01ac14679f12af7dec140b8379ac765f990bee9a9ba75399dbeae9083820b37cfd2a92a315ab02909b445cec86788c9348da5079c017c92bcad4be7357be25e648796bee869da080782993169576e8bc20df3e9a8bf82934be5f0038f73add2bc90615f1c27de8bf1c2ddc86791c358362994caff1c3cce24f85987390561198ad6336156f6498513a9b9f870fa3422bfbfe7c1aa546eaa2536e297d3cc7ddb97ec9d187083ade61a44dfc770e47b04086912113f3c7d0a358a16f412c8e798272c7454f1389b97a6f0519ebe19249a06ee77b89f3d2b8d6980135f10cf9e0deadde4262914a8bdd3933d6012d1dbb06ffcb486b731f07516a907eb1bb6b4b9f226fd7a2c584b84624446c07568003743a12b269ad85abca118e830f834f5fdef9e437d56b611e3b357877a0ce1ba64d11a1c4115f191fb51f871d12c4960397dfbb2a20cd5aadf0695d0bc5bb4d0323030093bb01af7e02c82d33801f43e0c172dd12cf04e902292c02372182b36862d573802cb50dff5f712b2ad35bf50d0d5e4c271e7ae01d46f7693e7f8126ad67a7922589b0e47aedc08e4e0704374b53728b2ee9e362a22d2496e5fbfcf2468ab041eab92000df3620c7cd8c2ebd44207cf3cfc5840f4b01bc739d9a79a086af665837ad80fdaf9092da81e02417fbbe033f412d3774f2124508c1bb4265556a2a5cca782179bd0bd20aec3edaa780a5829ba53a7ba66879b8e4c9c4b60b868f699061c422cad258dd08b4e223aaaad9f2aa432090589e4e6dc8b4c5e91fc16709d27cfdea0014acd76d4b7b3ef0e01e24b47316307b29329df92fb5e37881c1f85bd5ada7cf144b93b484eb2af8d16d801c7c550066d46638790a25a98494692cc3400e63e2042e81ebd3179fcf700edb210df56481b23b9b640b381f7c143c94311d0b8e74e8e966755e7f78f10f0d77d7b45c9b3d1f63b72b189150f9f62d2fcd0a65b069727c007ac13a15a7603755730ea1c6af3feee7bb117d0b1ed65ff07427206fef7e3e2f53c040512d3b37200fa1c89d012d62859a2ec38f485f51d5a0b04717820293621a2c30b85f9094d96ab6c6267e6153a8f40b4bcf649afef35228840b88e83b1f2e19c5836b45dd5cc2282a38d97d5c19021b953983b710b1d464e3c3ed4e87dca0ee2b6d5bbddfcf473c2092f1333fce699ca75a2f15c589dd43af15b4021c79ac489feeb1bc735d24dbba407f2db99081dad96838e31f60d01ba1486b5e0f71458e6ef09df4f7f2c9a45e9f39938ab06f81e14f1698a850de1cd68c27452cb42f1c2fea1668d3f84dac40e192372b773868db659bcb245d7321d65ff1c1d5d7663aca025d2188073c6b99f41283b0dad3ced2365ca06b9fbdfe794359dbc5b481d3ca2446dd0d6110a6ea67d36165d97589b4e5c8906f4b8d29a3d7a2cf262ba9bfba457b0517ec0579c8d8b45d01eb03c8f4985cd0ba35d5c3c553589a993a58f4cc7d47aeb668da9d76f00cd82ca8007217a90a974b4e3ffd67588a3ed528d53393d1681035cb204053e74e4e747e0ee0d57069c2a8ffadb19ab9455e5ce71555b331561a22364d7c5fb4bf9fee3b620f9538eb0b44da8b0bc60d436acbeb16dadb9d5dc69352b443f57be38b9cdec0bd7ba433904b01ef3d3b7e8b1de410587da948c6ba15fc3d089166ed30890dc39284ef395e40dcbf0e83ca67e2d5d8c9eb76eeac244188e2c0666749aa26e09e633b5682e41995b4adec35bce2499c3d0d775982515302bfa172aa2d43f37db751e825cff27453e997516021f401bc809bd06b7c6b843e61cd383499e3f031d4942fbbce025f957385fa9ddc4260e4f6a836e28dc77b95292b83c9badf0f048e7d5a6a45f9e2319ee47291f3d9ee65c5a4e57d4e76f1601a3acb44d08332106b29dc1e0895acebecbc5be1b60aba848492831bd4a79ad250c5752efb32cd7665f78de2a1176ff03ca49dcf854dd556a91c79ef0441ca7fa3942008174ca54479596b281fd8d7992e450180de6994242995c6943ecdba922aa5127a68a8bfcb8a96113c33b565bea89c1929a65f09f68a89ce6e84932ebed1d028bf517fba5a4f2128783aa89c9fc083d58b1e6bad8e4ea3e0c6ab5a15d9dafd665a48c456b7252f9187e75bc3f3ff3406a7be66a9b9231ccf5f966c4ad972d9ac45223b61ce5e6342b81d5a3af36c83a4743f177d95d5be01fbfc9fab8179e055590d5853f1cbf5fc7342c3722a5c7aa17b1cd9dbc072800dfdc50b86d52347446e1f20561954701de28ae968b62625a03fb9116d21c1debce75f3f6b67dc3c461675a0184732df528bd19cc75d3170b92a1f2631a4cf23e13c9bc9fc4e0485c2fa05d3f3225eac5d1446b362a2b693827a7f76eaae24b25c9bef8f9c9e90f79499be35641fc5598d2646cb40fb2115432d5214424b909637ac5163c976d1e44084484520d6cb960a3ed380d9fa223d759916b557c5cc9a6afd257253198d47e150781ac13eeb2907ae49ea9b3ea5c89f4a5ef0054bacdbcfacf8377721d2724dbb5b79cafd44dc9e2a3397aacdd67aae0a4df2815c1b8edab80976a813e9d535cae74c9d875a6e087657074940fe5e590fdc620cfd2d0011aa1781ff3658107ccbd40cc8c4d09512dee4f85aec4f1ddab5021cc784b8b0218a5357cba4decd5543a33a26230e5cc2514a2559809256708b2e4665c2e402335e6abfeddbc4c8a8dfaddac5c50c82c0835cfbd66cae3ea73826ef7e17b9f079faa848649c6763744fbf6dc413c2aa6b441a8596572c1d2c0135ee3a78e220bad7a407f6d0efb5191290f5d385d135f3c5bcdf0336d8b43512a728201b95fb05984dc9e4c1da31440d085dcf679f949c6b1f6ff14aa867217354eeda2daeae26f0664da203f20c42a0fa1515ecb597158abe2a1ffbbd8000e4274d9e2726fa9cf644bc194c9ddd72fe2f228b55b740df3e0ad82bb443d9dc42b4a446102696fdd69714f601e9b02481b193c00888f3ab73814d77490efb959100c0ed126e29a61be958795873243e61a47b60f37918b263099505dbb97be693f7bef6aae48cc86a875a9545625c70223e4648c87dedc478bf7149c4fc2330ac591d47b32405cff38918da9f41d10e3b89257f0d7c64ca37897adf3661975ae3f98aca16bd3fb4d19555ff3a206766723a1c69afc7044e73f5d63782eaafd2e3ec444c1ffc797dc6f47513753a26444102fab5d6c435d9b43d112c23009a90f4f56a2acb90728f88cc509ec6475019d231551aa3ff81b544647ce75d965060f9241d1765268041ea142409ee4ba3977d9ca5d6c350d027bcca69260ccea9c39fbd54d82de44976d14d5d8c17747c1511ee2d683a805a96aedfe6542c7bc519e9641fe6b433b1757c5969830064a2ee0ed95639758e27cf640bebfd91ddecbe003e7cb90efc8a6e1e2b851fe553f24251b4e3321bf8ed580f924a1f25a0de8e1673332bbddba519e2b8096992eacc20d30f7bdd2f0a5846fae4f1b81d75d81a8fee363f54142260923b26cb37a1916a96989e4d96d97bb68bf7bf4f2629d27d2fa091f9d4670337f962677f332b286b3db9441835f51788cb0fb7184142634a67c638f061abf9007d3184389424414fc27d6b92c4afb4221a9619c46bced34c13081fa6cfbb7296b470021878587ba31c75d5b34e5e787f3666c6c875d30619c47cf07eb44dd081ff05da35e0aeb2888eb7be27868334f5535617301750bbaeacaa943bbf9dfdadf7965ec9cfcb0c1739054c409bf694ffd7544f4d75f57dc1e89ea379877341e3383ccf2453eb450e706a55dc5225d6d7850ebf7dc7e239c8cfcd0de3a33cdb7f683dc0d268c6f59036e6d5e84df49d9d6677c10afa3cb808f98884552f02ce7190aff07a00ac106bc4c1ce4b48a5262f1829b242969b0592cda8034ad90f81efa1237f831e60a3baaadd7421c2d290953f18c4e81413312b010a7bcea09870c041cfb0df84c0afc518b1765af7d89baad552451c0c78e05a31a0e77f37dfbb54563fe2d3902c98b8981f8494503cbcb548c9ecb48d203f7dd8c20c9da6a48608cb6c151e92078546dbe33c4f7c52913f73eeb91aeb48e3875f140da5079621517bada13a08fbf5914dbbee7a0d85edc82cef636380c51cfc4acf2f2756c3f97e6eb1c852a199c33718c546463214b5dc4b3afb79c6cb399a9f90ca6f20f3a253273736d0a4a99da3b1b2254a3468e26c95527b198661b1160311552c0e4f9be04bae3c7b67007e61e31cc0f8941a39ce6feefdbc2a18a10b393c9c0ade2819adde748a151840e193d048b7cce5966fb47bd9b46f7b194c8c5f6ae724f6a69b6e280b39f57284f07b9acdb9027f16b1f6ddbf4cc3e861d7e6dd5d8006c2181596c418e500a6648ea6bd371bacbea5afbc76869e55be07988c83d38b09adf885e1209845745af08d4239480ae19a73e107cef29084da8895ce6c29342e3b3bb5640ba6ee491c5dcb71f9eb469018399cfe5c35dbe82f5d35440bd6c4e190f94c78c06cbb103b107b50924fca6368b42d47220809be110619b2ed3a2a8c48e6d23e1b3e6df04038da831fdba77964f9ec825fbbfabeb9109847f48a8313b1dbd477ef48b4ca34e9893ce3e6f447eeac03b9eb0ee0637d8cac77dcfae1d29d7eeed20b44a5327fbc2bb2fa8b988e5d314d8433e3cfd46429a239eb180319d04413d89dd49878b5c13bde94f52083f1a98bba6e3c2115cd4c9e1a8816ba2d87b527cc1cce6d21474590cb4a77e936231facc1b73ef3aea0d69bbc40bb1db7f13fdb863aa3e13be8f3facf3c58968c16ec984cbfe1ec7657f3238b4c1622f393cc2ffa4af20d9e658b7b98d274966d595b2539f079b21a98ae6694343e34d8914a68f539659870150b155745c283f61daf4777c34164f67a91ca9955d0e86dcae8bf87e074efd1dabf7f5ed07799e35f0e921ad7ba900ef9404a157f4ee5661fd6ad8c0e492dc7c347614fb5a1eb7246350513d8aa2decedf3b18a78918dfe19f66162bc07315b8e6dcfe973b2e5fe12259b301247379b68519e8097136a1ed0362cd91fd0319fe22f32232502b749ed887b07d3d87ecbda6404cf98c489c1f3b615b269998d47ad29c8018629aeeb57c8e1cbb324011aa4b29fadd205ce98234dff81aa007293d2f4afe459165edd43bd558d6fa7b20a149a8547e12cb3993683c4c22db87d0468a3ca86bc6e64ca3b36e3e2c1cbdeca2f89226b9b48cbb13ca78b7554c649945cb61c589fddcd509c8ad4c09eb49c87b803a067e85c6faa424035f5f7a134c55aeebcfab844754617a74d4927b56e46eab6c059d90b0fed70302754401211a71f08bb0288d6591834e43cbe6e799c2b8e65505695e91986a1c91fd940636283d80ae4252ecf1992ee2443eac77235586017af77a67034d490c37e36c9930e996d12b05c00df8805e08663bcb5a76fbd0a7b46b16c41b202779034bb778c81f518eee4893a8fea5310a3745c98ac37e184aa86de0d635b38b80cd4cdfe45826c9f795988d2b676ed61405cad6bf55209e6de793e2dc0de0333bcbb7c0c0c00ca8abbb6211fb638912f322b7a61d7956bc50633c595a682e61bde5622655d8245e404058a78b5c93d92cdae8a894993a7729bea5708d0d98656bcf2c1dfe42c169a853a427ffe224a3816447bfbfe4efa53c44ecace3fc62c844c36e4b73c11c8453cff107502d0c0eb13914c0ad5bb3624e8e59818e657243033ce565e23499853055f45e94cb000562380b9ae64cf64228670f134ef840a867ed80af81cd109685ced20cd0efb018bc8debc469f794fd4cd7165e04c8ff6a0d5620afb5cddc6a5a0f9d1f9c5f0586c24ce79d6345e1996ffc1cad808917a254158dc2cf19411f2d62440133f6cdcea8c0af8b43d805740031ff028a9131717b419c72ac2dc823faac1e84dd33fa3bd9b06691419daa90836ccc43d38e5b56bf28f3f07fcddd2c319a8c0f9e97294ede8f472e1d7961b62cf3217a9bca80c84312fc1c9857daf11936c1c46a993b07698ddbc0ccb583ee263033122be7af8b693d4174ca727744d244c958e97df1ce17ec16cf6c1c7c84e655e5de7a2a4e03831f505ecc45e62314b196972019ed7b97b46d937cb35412935b635c7c6004e7496d54d2854c4d17606c97b93f948bc8593a695696fa836b16c8d90c0cfb27401dda46f8dff8e96dc3d2b49133818481e24065808e52cbd14615c1a0f05476a78641397d42ac5caf6adbfdbd5cb093294001bab12c9ba9a98c824c14dbbe83edc450dbc94a72f3622f6782127de0c9218564de053c63406fde3e93b07770ed0bc87c97b766833e63f779654e2db22f4ff48a7c1ce54272c935205f3fadb5455a31a44ca478bb796ab2f8938e1c2a99ae7dfd2680f2e2686e83685144eb9a59a9e9e984e77443bfa11d4c6574338a3b5fc235bffaf25b12661e6ecb17dded9dece24b59614b9d0bd28c8b4e03cb1cd01a7aaf2b5cdc20084842ca0b0694f9e8dfe1e6f984c8c36a85a0af4c9eae3723c830c9f0a8a4d3c7f105d912b4b703a4beaf609c1093630d7c006b2a801ff2149166d25421438e45f853503f2023c95dbfbfa85747a977a2a3b43e8b650474c18e606012acc1d93f79fb183459ec6561ae2b60607b49dac9a2ad4d2f6bb4c61e7118312e3302f0888c6fbb7bf43ca5be4746d623baa060e47bee12dce31683399433af81d035999e1d417deac95654f24b226761ed598b5d8d3780e311afea25a301cf15b3169c964dea12a5bb6f712e8755c5c72325925b9d89db0759d5d801134d65005c1cd35ce27e23c1a3443f97ec5242d105809ef9c86181fe4cc695ff6b48d107ac47306182c7d329d41507433d22c8408635a8cd8b47546c779c54058b762fbc0e5f6ce00961c8dda0f998a11a44a271bb489d973d1a9dade8bfc0a2c1c71b8901a5e4c6b909ac16e14a32d637d734f5f5bdd8c30c354106d76398c1227575105a6a110020f8d97f751f2ac0b1e08fced8a0430fad3f10849b85ee84db93974ea9511732fb85a82dbe25aaa751bafa55f8a6282beff2d39c7f037aed8b1b8c5db76dd721fceceafb9ec9a0af4cf3172a52776a80021f074b9e3564203d303eb417bd2afb8dd9aa1e9b85ac21ef923e9cb66ebe2ce7e69c555a3f2fb84922799049d3d22d9a748363eacf938556823acfedd7189","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
