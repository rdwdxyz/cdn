<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da798919087901c96f0f7862829a889006220b1c2cd1020748e97edcaa42ea2dc7797e107baf6c7dc92ae59f2f3885bf6ca12e8825f9332fa588ff90328ea76f8c3888dcb76cad2df6eea51fadc91701e05ddda39cd365bcab71c1e5a575b1107eb5f25861015fd88f3b788769f2170d04a0784fe7adb3d0f8c4a72cd973e6a4218309ec2d58900d7082c516864e3978e0680b4763fdeb980a14a21e0d9ce2a969ff9e8980c5d7ba3626fd1f82bb3e99883760b0c3294c3c3148dc5d85af7d7c85b4c7d3855b2deaf02398d11cfc8928a63aa0f19fa5c5f61e7008eae387b6dc9dd93b3065506b1147af83f9772bc9a388b66727b596bbd960d6a974758b25d2e16c6ab2187f09430be7be777e6d023fd7a6678584b5457794fe8b08fe8fdd96cf5c7cf6a2de73265149f638b71bdb7ce6e3033c72f7fc2694602bd47a207241e287637486362a14d4d51522079d1b047bb5a5343951064836e3417b5a90764c2f10b28b61e9f56ffc1ed182b7c625ad8c58fcebc793cb97c1482fb773f3acad8b2e14a653ba7b827ca9e5cfb63a338033c6a92b51fdbc0a11465e07c3afcbbb0ee753500dc558132c37ba4689bebf2631c46580db6a2d629de5e3cbff96c1b0f09c86d25cf01a55b4daf80b65465a6d6ca09710cada51136709e3fec02e3f286b8f950177b57faf960fe8be571fc1ce809087b7b4e65b82fac3c9a65ddfe8ff92174f4270523fdb1f15837e4f37cea72e9664135b8aa0733854f887b7a6334108996661486c7fa5cac6bc74a1bdc5fe70839b5434c7d9c4a9699c066a1b62d99839ebbb48dd77652480a168dc7dd605b7b1791906389aba43b22a2f04a3d1c6c9d256426d585c56d06009219f5d37ea4131ac8634a86a4fda0a85880543b1a558f19fc657fe4ec463b9ad5d8bd055f923ce13618dea8c56298ef3d4bc7591d2c368986ad7ff2cc6bf6e93c03d7ad34a71f311812f4849b70c7054588ad41890506e5de7cd4642592ba6097f49cc55767a6bfb390645bd985f53b94724a7dc0c5b9267edabfcf581cddeaaba1c417cb855827c1a3120ea6284ec834c82a06033bd365b7fcd56d2677f2b1922c7f77d42382450f3c50a2ec10499130dc0372d5ad40694c6d06519d1208cb0204a132db958a78bf12fc21946f61fd7aa124ed56f778604294ad28f6fd9d831cf0dddf74c5082566d5d57105dd953ac38a8405082397bf62d01fa224445fca7900d5f8bae6fa77faad68b3e23ff812afc0beba14ec116dd228fcaa5a484919bf27dd6afb32dde530b867b922dd537097cb9af6ea07c1da666523b9923f04c7426d706c820280c5b7b8cbdeb1d073b3f3d134638b211b23a7f5673cbfed5ef7f19ca2f3cbfadfd8a7af76a21f97339e6e71c4d6c10efd173a64f5a5ae8845cf9ab98c1474f1bced46974e1ad606707eb677cd6b87ebd948faf7d20eeaa71206f2a2041719d5630306546416d54b6070f67b82b59cffe608fe03377424f3eeba7e35501c21c14962bf0764718daf62799e162ccffe2b2c13444280d5a2ea55a496b214862df217ec57ef280c40084f4f572b6ec38c55192663b8aed404ecda2e9aaf9d049dbc8886298000934018deaf40e0091742e4f3b97126c1b822b6dd40517cb2498d9adcf8c6190992465763ac74e2dd1f9ae3474e522c6f5bcfc48eefce15a4edf63e98f19dfbd51e3360c0442a477d92f814650f092eaadb1f4ae842c50d17ed13158a3a02d2fce6c3edf3ffa8d2edb3e10c444bff7d3555ceec463a7cab6647555b06cc40578e84c13810d360a3b5cf458d68d7ab7b24dc68b3ac50972a177b5be84e6db9393df578d5d8a91a8d345599d1d723a270e5c2045a42606c21586f56a85b22c5425ffc0e18cd333b7e6357c4296956d0f920c90d75eea7a5fd6b46691499cb182a192a854226e29508d65e3ef00cbd50e594cc7c0fe3114186535d81638e9f6904a6b17cdd4a35fe0e25d6b0e292deb47ad13c7f2220346d4a2b920c5f14e6e35b2604e61d5375ad397a12fefbb0b6082bfd1e6cced220e3550ab02f3b26aa3c18f02a2320c0554b6c28ddce2e39f73be000168ae866f346b21524c452999da1541590f534cb840975c9585f2bb5b5198b1039e8efd4842846e53ea732c15c20ebf9e1a8c41400f9d74f5e5a64d5dd5b0244ea77ecaa088aab503ba56efe020a379e4e43a24d8ef739258e7cbdbb4baac156d4cea89682694266a6e43573abeb67d75cb1915e07d75fa415478fa8b02eabc7fd54589a2304cfdc10468c0f77840ac6567d823bf801c0620776e3bf351a99f94f8115beebb2b1b70f49d769d88fab69aa63ed05e4bcda8b29075e29c860465d80f81550a5848fddeeb12d510ffdfd568016546f6d23cf3e9476d332525ef1652a4673529afa2744782628f713524837d5007155e8e36f6065b6dbfc0e32ed958c5d498613cc0f6791b9a95a3a41a21da312272cd14392780e722752606d8919fdcb5222796f7fd9d94f4bec953a35c73162caae363ff711f2102df601e9cc52e7d51487c6e95ccf323a2404eb5d773816a4296ec4fa499d01a2a289c5bb7fce622861178b7ca386b73301d17ec2cb0fa9402c3ee8eb1adfbe2b44c33cd2c2b57c027d1dd9b1497d7046094f58a8397c44dbe834599512448278c09f49fb77b857750fdd801d2895d70ba85b0b8a290e09dbce50dccb7df75a857c8a97482592f507e42354066f1fb1aa10c53f48e113e6f00b2032a5babb4864d4aa316bea7f54ba43bdb7c7c13094b475af380eae829273a20ae203852db2b6ebc768ce39d6b70e8b606abdaa641a36acd58cfc2784bfc58b645556b158c70e3391f514bead4d97d885e37c5839bc1d75c595823cc2080035dbab19aa5f1d587386924704721c7891c96a1d88317056b9f7a1270755221bac18cb31c2870f1b94aed1d385b53e225608fb3da008e395231c8b1b0da9ee50d84f38347055a4ef47832251ccbf0406217ed36722bd18b553d625b5a52167f0c8fac7427859ad2bf0ea720414eb9a311f80d5e410705f8ab9cfe1272c1769a6a211898e76521581829c48e4c33d2576d57ce3f1f7da4c627db7ea6a1211045d5e0c3216a866a26f5696642eacbf00b6b857631c34125848f1cc8f259a72b3d65f87617219978b0cb4f5064c261badf9d99779214ab84dabf301b487684aca0415e51a4513b0de9c38ad1bef2593099302b2cb22988e82d09febf5dc74de356b14ca4793f0970c732dfcafe45c7bfee26bf671072cb1db219f4361cd7a32ca650a3f5e41d6ad95bf7ba3948268dac69810005592008d0db5d557d2f9946682f2b5feb09d348253f3229e17c34554b8d0163a0ab25a8c55b36f8b774485a99bbced8bbaefbc827f5a05d9253967ae38142a96a9a3c4dd221695e855df6021d81459453bcb8ef9551cae0edfc98f73eceee33197a8152faed337b78bd37ac24b4be254a386ed91cfac95665b12f0c2ae8671e346683b7d9ef7636343120c0f62ecbeecd5114e81ad3768bd65e3f2899276a7ba9d111f013fc53d8262d8f97c41f03ea94076fa5a68cb8618cfa7080d3e82a955508258754b558e099f2dd56c31a556dc279102d936081ee6f80561ccd24e6d7fa31a37c4ac58098cebd94bf556ffe69bdc9cefb85f72990738b286d1053c9a09de0d0542f6e50bfeeb114d21e62b6ff680f26bad7e538d3daac90a1e21b22a0bb4fd8096d48917479f052949dd5916a46c0c7924ed866826004cfca2cf1e5032d7f4c1476c8d41009bde812d63157ec07c1703bb54782e2e6744ea4c9d6232b3384c6cefd50d70da2f14aa1e094855f649f7533d195f710d0c6a4989b6efee0ea2b0ceecd28f25a66b2804e44c4495df73909d72accf813bd8c981fb838d8974ba5d0a382715d924dded7f59a0b17c5a176dc8a4a0fa61098c6c296b9284b202540b133936a5acf607723d75695c32546dfd515b3c766878ce978a8aee10acf1332fbc0655d28b0e27e09b388d00cd082cc0d400cf76c7049d2b2f1705479576666626a8b62d385139a6a3acd8dc7b149a12a42d6dbefc3e24d939025412a006cd3024dec1f651f35176e93e8a80078fde8d229f65357c8a0bc69e2b9e546debf81224dcd18b4b2c9696133c5df4902ed14e44e77333218c50957e9c6f31f659afd77837bfe39fc38ee20f7e14657951aefea0c9189f3a16393fde47e56a8256d0dd6e43e5402d3d843f49fecd15d1d24cc19925684017260fe91a2bbb86d5016638a26a69d6865557a6e1c19d9f4a477dde775681d9aa57eff0e183f73d1f8bd1a1e5b6d2dfef42825a381bb95136b9ab8cbfbadd8354696f7970eaf00747e7131e6792be3a112003087c53e7912da8408a06168b91a3589a4d8a04d6c579dc5056b5180b9fb49359bf396ba7fe2e4536bedd88e093ada4676ca50e7135e1c45c708ad9b84d3daceca77f77e76ceb506ce3667bb22b203d69050153c63caea433ae065ac495901361cc0629a3f51a239bc0035ff6a2094b9cd5f2740a7b0ef586e1676cec726d465b84a678030ea147936d466b03266a93651b2d85dc50b1898ca7b93a57bc09fa74969ae9c2fea92a700fcf81939f7f51b4091dce43c31aaaff5ce150754e3b10a962af5cce3e62794d9a948159ab3ff0fe4477728ec63baf16c0618813ac7307eb6e3f0b5d5e9293e348315697c1f48c4afb40b1610cad80de3c80a86e6f950dec12de4618ce1c8fb71c55f4a6ece98e0038f0a63400b4ea583c37208f0ce6c9975a1ea8371da63415e7b5be01b6cd7f12bf2d6b7aa7b09cf3c44ce5c2989347be158163e285fc23d9c263e761c73e1f6aedca9a4a7ffcfba99f710241c80e28819d80ae5eea26c301a3042d1d8754fe8a8ce2f89f4ce9dda79a58e145f96e7b674d21dba2807dbcdabd944af1bb83bcf04eaa42ffab37b63646302613fa767c0c6d5dc827ac1e6d8e9f74e6af09ff07b79c919a21ce90d634c0e176e7e42adb818f486a4bb7245a97196787bc6dfc373f77f33ef1f072b80f70d3bd86214aa1cb48712cf11d39abe99aa80a227fee50e0a769f53240a327fa66cf3077320f2930d475f8431ddab5eb56ff11424afc4b26bd7789f9418bc65eda77b9a409895f41f1d087f202c6e065287dc59272f8116e4d43192da430193969552e02b8e73dde522d5fa8c5b6219e9420c883e42af0e510af5268df62589f5b5155d6614c1ac8f63c63da332d57ecc0062495c8f7ac60151b795eb99264de462769b03f744bab15018cfaa5a2e5fbb6e4588093d235c6c2beb92a5339742915edd721253e9fa7da317e4579a102a905ec6a66532a498515ae8cff23249e04c48f163e6197577016306d0d9a91393e1ea6aad0c830d5f4dda69454162cfca78a903a67e0e65518f87a7dd1400eb8b4972160d9db01bd5ce58a4a541a115d8ce5f20eacf77ef508a477ecedc9ec7fa94558e802d571fe90e417119b90b05def944aa4c568251fb9d30fac3c0c4d9c6eb2026e35f92ba6fc8eac4105349054ed92913556d44579f070244866597f564414de4c41a64e76cf5cec2aa804030fc21c5aafb1662efa43d64bbbf46a6b1457451a7a4d8c553e67d6db93c49340e4c48950c72900aa78a394e98c94f6f496f3cc4176e853c681b1c378fed54d31d8ca6c8d05b8219a658e46af2c9e093ad46c51384501c04ad3ef6058d99921ee877dc22d08011549c6aa7d6769b659fc057f7b5d08dcc0f19476e7d1fa335ebfd4f5652c5c43a6f6d9bb12778f53abecf299f13c192b9f8d0d5fb1f0ae40c804a94f85d61293fff6ffa2a5b1347ce0ba1f19f8b411412df19d3e9fdc357089dedc1e528e136c666a37cac42b6e490ed5231bd2f7e780c0cdded036f7c1f0f89bd235189e9d56fc74e165e625c964e4d57bff443f8775c991cfc34e25d2a16cd812f6b4ef68246766b5a9e27accdfb1411ee45c2b60d3aa7be354d4a04d4d9ae458df51451185f4e0f2894369ded72d3c490388d4584b42ea451a050594fc1d179349293933bdd266e6dd9f9e718f977827458139fa3ac1eee3279de7a694bed4e372fc1dc49947988426bc1dd711053c1f320f59f3d24bfbca753ddb09fdd9ff3bce4252870a97c91906aeb6c8d14b61a8c2b8c0a56861ddd06d242ae3ef01023e9cc15d4134ad2cb828d22794a737b29f2c1ac76e69ec5afb7f9fd10663a1a3ddbe9042a6beb1490707cf89856c20d8963c56165828c063f68fd2819367abd9a85ea066d598722926f49533656815af6c171ef35ed26e39642bf70e0db3f112afe3c81b04a91430f43a3c63470af23fae164a9f966428850dfbcd939bb8c2877171bd8b054454d35e7d05a654811076e3311e1bc86a9d11c2bc65087d3d1efca2232f0e3c1e462f52e26c00994b442484dfa91832a9b879474894b3b4590cd2719fa3e82f8aadba7d2e839fa445c4d42b9ac8c070cc011f40410b03b52f54c1620e63ab190f9fe1024f7f8787074d41c0fa9f231c4990f7b95333dfad6f4ec05c2589b2d018f9e0a551ebaca9cf8fdd378e1ab72e66c5d824228075b5e1e0388db01f46acf1cf4667d292284b98957e97264523437bb7864a62eec9b74f841fbdc243ce35b2af7a8e0a861d0f01e25d0b782308f3163927d84c7c41f87ebf208cd5ff619adddccb8b4c1f68fbf012cc31cecfb06feaaaa91add6a7165c45002b8be9da01973df8f62c4153ece625e15e94f4dae2e4d6cd6f6956ac52ee9c8abcc2ffb57456c2d476584b7b8babd85a65077ada81fb85850b6b6e38967c44257fd190030e1d8f30f0ba18fad700463757d64e1617295ac99abd2057f56f5e720a24e089f3e72c1ba0586f59842ca48aa7edbe7c87496b2a3bc7d8f40185674f0b863b2f87e1ca9fc56ea5ccb660d909535a3ee2b6ab4bf9041087c6b75b89d21db024eca983d45f6bd8fed70c06c531208dccccc89c0b126741a46504c90a9dcae8667f877a3621eea1e8ae9c85b8b40afa87ea1b61f690635d23c3989904fa7f804c8ce294e2bf29a1b0f0a1ddb281e1390e45d190ca55f48dfb5137e759381323c9a43f239c0d259d7d39c8f86f6f98dbbd181822c566591897b6ada86a7fb3a8358c4762ca234798a26b67b7359de2657ee571649a7ba6023b72584463cc67dd1701b9f6b97978b56eff70903114ea46ecba49c21b55a4cff55800f4be0d71350c94b5827408a379facbb315277b4b07ec4cfaa13962453dbc082cb6c807c787d469ab4988cd2524bd8ee0fd78f31bc7bc723733b7442cef42cacaf49fba8eeac0b962b79c49fccad3889f11bc972d5994ab654f2bb4371db28cd958d72268d8e9b5b37212df9e3f59a9393cef70d871f38359b70f6e186bd689e9a18e1a1c51b0733cd76b3a1dc8d4f7d2a99e20e47adec199117be930ed5d87af0ac1eedb88c406c63a4816d8aa8952b48c954b72ee20f720861d742666bb4244e4c0987ee16ecdbc9f65f3019e1e78785178c51c37288a3fdf93a0d6ece4ea2764c1855f79861dd3540d24dca8484ace8e10a77adf2867c9174c0608ac0fc26b14d60fa5aafe0f2b093f0df6d273d350e336119ea2b1668fd1d69e7731049152c78b5dacaba1e418dd677be41fe705be290afb346ecfd194767453db71f057a0079edd0b4a90901c873a4c331ce52999ede6b3b67008ab774bc13f6c53953cff5fcafc97ec2e6d92b778afcd3260ff1dde7c14e0cc807ff70491537ed188a25b2c775a79c10b43f75c187eab2914b9c9dd79f070218edf2db6d17ea3613f52f6dcf33e517980913f150b418697135179f96b552d41a14b6f5d9d5b1eaf4b9efd9719bf6f746c8cd493bec0fd8f4f92a00e66a7ec5001ebd888aec56587f0657943b3843c381486be721c1c1d48d780c3da794f680fb62e8bf37645d3abdc91eb729af7a00ba356cef8e70882842c0ee4acf06d8ceea021c84a4590c05804d1f5169983363ceeebd5f1ba94772bb3018dd643a7e83fa0957cf85c6ef48f232b50e2a74571e113d324184f270949226536030df9da43c844c07d09dff8993b7fd6c72b5c29152d3d32430231dc9844e89824b95a4e4b0eccb79d28f74a0ec0858a03576e12e2a9beb41ba905f9d68df1f6c111415b70997af55546ec24706db98e3eefe47be18dddcbb0d6c9044b6326fb30b728f8d68502769e17433b6b8f69b647e151ca12f6b9be813f2ecc4a9f3ce4f676db1ff60cc060e1884d1cc4817597e8783b846d3a6e4567f2e93aef1f2641a9b01d0def939fd5d5e03aca95fa1a25a2b215e89d3aad7dedaca22760654b41cb0d872878a141083de952475d8ebd4e029f126ae144d04405d3189f56b36c8ad90adc0d3ce617d61eb265a8ee52672080092d8fb0b40b4cbd665b4d519b924766ebbfd21e7c99ea4b9ad1c3080c09f259bb87654709362441e538d292caad2f1d3a460feeae0d5179ccc330b49221a14fdd01c0da86d4fd21dc8b0e4338ce7b16397b89c29cadac5a5906cb6ff3b351656f91f60870a344a447b230fea5ba0c2fb66a6d19f04c2e62d7967c5bcf916bc4faa7805692347dcb23680a9022b1b638d2a598530bb2dc0929a9424ed0b902bcc72f9d4df299f86dbd1f851c093192081db3b80180821c250fcd4b2618b07c49764075e7d573752959a2e7fb4a72971fe1e7a909348a69c7f437d39b41e09f04b3520ffc3de48d63f65477b54d3e237fdb801d8f2f028c339e8db40b7770193b95f5008de2fdc5d724b8fca508b8d4ab1342be77d9be6fdec7a1ac5888d73bb9fc5d0e6216e7bd308b668c5f204c25240447c46b39ca9f522f5488ab3b412bf31595a44a7c4e84d719e51b3c8aba29d744c3a476bfd9fc14d1b7100c47794c402c1e6ebb8bd95a04464537795bc1b3f4c5ad77a780cc4d07f1303a930d504f747deccf1a0d01350e47c82758f01aaefb418494b85d3a2fe3850322824d6d78717ec673ead9a74c723a7975f7d41ef4d1e10474650a430df15c3d57e81c2bcc5f4e9a3f29fc5e00e2ed534cde6e2f465d3dc39c3328182a471e749682ed6edb5b41790bc9632a06d785a059fb326d2cc897df8857a7458f577c2542a6e4e2611763e85b3c0cf2da17325a075bfe0725fddfc6939ba56b61d4ce903ef86545930b5ac7f6ae57658389babd19fe48d2714e4c06020233010a2494ad9caec1e5df19a5e086c74b873e4497c207194a7c601e441dbd374d1ff92c0641eb91139dbb4c144b035042d4fd5111ebc8e673161bfb43b6458e4fe133d2750aab0f32f53e2786bd636fb1794827f5259459bece58a49bc964cedd8df9d086ee211b054577b4af132a6d4cdd6c063e682845b355c5b17812934cadc40ba4dfa8b3665fc599ecb4a16f845fb63a4b90da7703da8f94d9c40b416904b50292a34d875cd7af97735df07b49f64e9df6d0c9d76650e72c11a1957f822091a231a110601d47d6ff6933cdae55180a415e659e95159c5601c1c821f82d0b61cb96cb12a4c592c14f7c79df67b89b780575557894cfeb6e7aa095dd6826d0da6b2e78a00c4015cda3e1de6bf65785c32447a9a52c42b11e142d4d6235b0e5d8f2fd5c6e96ae896aeef552e37a39fb30248c51349126505d6c7f3c68b8417e0f96e58a128017eb21d3ffdd075fb93fcaacb4ac4968f429404210f214a53e834515ba1c270e488519cc59949f522b60f987a2843ea36ed7f95268e045afcc5044a7fb92346f9b2a7d2079ee6e1f7d97d8a4f4336bff58abc6c30177612397bf3803870b082bb667011dd08df6a5afde4b712f828015a9bc0ec5a285466d32671b90bd3e9de1923916e59c2c7ce251f8459e1eda1872dd981f09a380adffdd76b66526a823b46d55e47361d0567fe1bc139e6e213dad016dd7dbd131209edce698ddbaad3e1eaacc19df46bc99a34da61e9e71238e38d0335931af034fe83b7988c4deceb7ee7554e7e526821a34cf7823053764bb52587b45a7d1b6cc7a811c2e562a0201201190370cb9f596f3c537e77f2f3239b686778855f6a49ad6e478304c3a230602fa46fbd69800cb0150ad1bdb7a431da34df2ceffe3c416e85ef87b32e4f70818b6a248a1fecde7b6328c8841edc40b425f33f9ffe90b68b0cb475437906673893f6b38a724db4ad61bb5cfa4594f1e2f1028f9f341db24daa6bd09555522133828d78e914315df4fd9b347d93700d9e9b630f73bb8380a74ed21b5590a03ef10265b8298f33d8f7e5a32d4f0e36ce900ecbd3becc5e290b82ebf71dc18e841fb4b32e5032b80c5f459f5c0320a1f1da2de094e3d8c72ea26801abba793ff931500473adb1b3e4a792f1129a85c22793923a445c7ad564a0f10394b5ff01ec47e0610c4c0c06a69d018842dbdd9e9516b1ac14074cfb2be0ce64e3f4e92671f80d6603646f6e34eb6744148284a9c2434573956762464e018f7c030f9a0a6a2a5f2a3fce2e99a0839f91f99f7c827d9307817d9a51b8cae16a49687e9e3646484a2e72456b703b408da83013d305e39781448c0a677b9b0da36a0491ece5003607730fa7b9cb453d28395554ff7ef0903b9fe5fa8da5a36d97c2494ce66717d2bc4f5250de14db33f748b4ef73178b48a5af4fbefca88afd6244df9494f012afa5f69bf95585673a674c6539a7a38c5bf76c36f6ecf50bcfd8b2d2e92c1a15d3c588b4cb080c49dc70befd27c77e9579fbf5ab746932c51af330e0f402f43ba5132a34c62800f3fc1385863a71854e00eb2e20fe1898756b82079b60873e71850f70d6c5754c4e383e171aa48814f4f7dc0ee76359739e78968385dac50fc10c4a88bc0b09b8bb074e8fb08bbb71176708ab8dee8bd31776d83f4e336a63b70dbb8b17d4ae0b69393a9864a81e737ab058f03f4688845e83fb9f4c7118f469f4b3d93af91966c0a412b583b0e8b51a9c386a4fabdacccef4b1e7f31bcde0f4f5b6175c7dd993fed1d96f3f3a257253830be3adf773b97302b8b094a5b51134b01422b31ba87e73576bd4c7faabc27118780164c36419711b0e17f2529a038d83980a66061008b67a1b13b1883b1d8bab966e070774629d60bb6fa09e560364aaed937202d1bbadc09bf71631e8e2d8c048031f91dcad8026ed3ef0696582e594b380ef5269d08d36279af6082aafe8392cdd7be740678f6bfe334f35afa80123828185eb642ab7207102e6d781bfa9df92e720bdb1aba897e7abf56de01802410803d55ba97ded08af2f3157cc19e96de57f356231f4653c09c63c6af1c3413c9e04d2695195b1519b04fd8f2e116dd723231096c46418fc6309c7c40a012a7619877998f2589662e852d6a9312c58027e8c80f246d7cf4232c2c5f2b16c29e3c342e52397dac846723662aa3deb3665c3ebf10e657abc981c08552e44e08fe4598a8a7aacf0941f1f9e217b8d2a84c3e1c666b8fa2e3007668f8a3d3de8898296bd35f84dd422fde372ac0b672dacea552ebb711aa3ac688ac001ddaf23b03868846944f9c4edf48f512f7ad5c32bef3708df1f2f0470cb14dd4c7c9551b9e71f442aa696e9aabd9bc4e7a3fd1c58c42ad3f1ccfa60cc3fce73b7a684aef0fa6fddb9e981483b970ea3611bfad49672f0b39ae764eef2534bebd437cade654d4b3c2e2a5d325e1f03b9eb33f74e80425261befc67a854a265f9d3051abe78d82a7e65780267eac1dfaaea8beb7f091f7a23a73c74ed5e393294f20542153ffd8a2e38f2140d8842e9daa782be29719598ee92ac2d05810c82da8f4f0b6f490a38c798a4e17b32bf889a151adf2c0f756bb8fa71a469f483a2cde0658ebee6d8d86c4869e4f183468a89155bad8966df5fa9941180dc552342cc7a26dc2787cc560ad6d6ef2f790d1d9c263058907f21936c72b0d9b060df3ff513908a6fcc5e2d6e44be195dbdf6ce91a7bca88eb6736410700998b1fa3f401e2c61ea76ce2c9bd62dea491eb29236976ad4b409b81f6e838ee0d17422aeb58cc45485fbc36ba5c8b31b216bc0745d2b2df57129383ab1d11d0bcb14eb57f39ca2b99fa7ab60f70bd08e85d518e2ed62688addbd45dc7979f2824cd4f7c535e455bbb1d28f13ef8a8538892888d89959cd56d5adde7887b3a9564179cc69c21af1b28fb0288545a9056bdda355d8fe3fd6619a5fab235ba19bfa75181be7f00b44af4bc348b1329cebe90b99cabfb7f1b10e4442ce70e1ee08e924a44b92f38f628e4734eb04841312375f462fa41d529d06efd05f72739cdc9c85fc07b8246adf758515c96dae1ae27b30febb22f6a797b2bd7ca0f66b8a29aba6f33a5554b6de753d464437cd3bbd408d602fb70fc26e92233bb584c176667be10b738b93d122b8021020bbf361159f433aea9b6ae026d86b46de07903e02c356ce7a35a9976b4915a94150d763e4b63966cca18430297708ec959c3ac55d1e50f3caa14591573fb3213350b824d345e9453a33d5a1a1bae9766e3d46f9175068e11e2cead5aad74b2c58cb93525534a0046590530cb46261605c0cc3fcb9bf6f9b821b50aa72df060ffbb1a79476f672cf7e95929ab6e8acca51fb71fa594e2898a391a59b6324d983588b0eeb82e1d23d157492512d1272f27f9b91853fb0cfff9772039a9c44b0cb94b56575a16a99fe2a74cc135fff67a5f3f5e2a702f0ea548d4a749bf8ae074b912fb522a64550bd68cb9a8e240e872b4a7176573aa7504f33c7c24988933f07c7041e61f0eb27b086df8b66417b2e1867e797d3083df5fbdc9ce12e99d1859f9903651893bdd32e962001c7a674d67fb654a9b24d05eb21c2b3c631e9b8143d4faa572027cdda23b6b0fc4c2cf001ed5f16361bede628cd3002a77809477a8096fd777c5b578d450dc842a49853620d180bf3d934cc465b1cd92f50e522959bd463ff79f9358281c891273bfbd02b2e58862bf43bad3c878c0bcce85cf2c7ff79898a96d0652937788f5ec2b84b4b80aec41840663ad7c12a697ae3af1f973747b3c53481f712274a2521514ad10143dc692f1d240b6abff2aab4624fcb32e52e79ada5cb20c8b614068f9164f0e15eacd589842b9e6d12c91755a4c27d854ec2ffe6f246468c3a467aced66bac39af13b232f682f0d25771f5f84ad714778def75d4fd0ca134f08d40a5464cadedb5344d8da03c1ebf6ecd8b7f790d5dfaa6e02de2e62a90f41ff61ca247ce427fb4f3107140ad2d3c553b6542797d9302d18947d165f780f5f30330d586f3b76dc24e085776730101c8d42fe387681b0a52b21e45109aff583c597cb7ee0991a34fbdd6c984b12c0ef09af809adbb37297e61640ec42a1a515ff6ff88524d07a9b39dc4c7160f4ce97b285c9f4c5484d3ed065339fdacfbc421e4c10c089b4cd58e2ccf8aa5174576c37e7dbc25ac1064e9a330616957b58179eda770e6350952b8402b8b0b17ba166ca64acd2984c56763d414f616592cbaa3dac3374b8075a7b4837a02e14122b57f1126b5f77c2f816ed15b977a08e5c1f45997db324d89e3499b4db7ed520d88558658eb48c241c2235e0d9c0dda372b5a19f63cd9226bbd3fc4d2968a4db456781c0832d805eaee6a083a577841361cd1aae5967ac2e016b2d7247ff071bb1369a5c89b147e3bd46bcf48618d3aad26d275be7339d0f095f3c25bcc4612695372284ea6aca73662d3568551674e8256fc27764a53fc1dd3ee7f41c3cae80b5949dd95f66837d7a35a611f30b7c6b42b8f559e31bcc3f1105216132d202f2554a7fd4d6ff030b157b3a1049fce94a2ca1f30c4e958152e2bed12a7938900786d92fea3c0dc6fe8b21f064f741b7a5b61f01da80ebbc2c15e4ad7567a56724dfe992737d697282a418a3f3a29987aedff6657676059c338d8afeee4f69e5b6a748be96650ca9b01cf82952a164a75c598b4f7f4c9d4e314d48e37a7a30e661510667ffcb6ac9ab3d230df683e7a39eb5199155016d54166fd08f32effde88a7cacadffb0b4e04b5d09efb5d4c9eb7afc0095b1020792bb68e6af69f79377f231b89d19a475eecf23759be9c8fbe0e10e080e5ced7e7c06690d2648b89fa12c78adc08c22188b395a9536e218e22ff084c459bf5846d900b58fdc788da89ea6648073556f799730457ceea1fc80cda1449a0c94f7392bf0cfcccd2348727fb779fe8fe1bc0fb862d0b125f1cbd9d802cec1400f196e16c80394a8fae3c46c963254c69be91bc84af0fa9ffb0540c9048bad042b4e3ee1cdf91c228206fd340f43ca25ea02d9baf8101fb1f69c7927c31c3daa001749f2f612c532c1ba4cd69ca50049425b0609f2f357593ca7cd9acc38f9e76aacfea8e4f13b806c0c5597e2dc57d35950e1886803a9f50b536098e11d6239c15f9f2dd8628df565df766e090ae8f484cdca058090f610f5d5d41240228bbb912d809aa75dec2025890f6ac4e6026ca2f7c61ae4363a02901ab00234910b76ef908ab42f8bd12ae2df4e9b12ff5795f3c4d335eb7acdab44342a21f611ed346e503881e9af87566d10653b3864b04f51ebbdbc3a1b41b152cdd844317661710fb05b1d328e9a192a873ea5e1e2c2fa759890d05fd209affee2ebb655b9391e57b9b4dbc42259b558d4a967ba6cc8d01c7e61f06bf9a2582524f866bec69b528bff095a6051dca42b3156ecbbcdc79a348c6c0bea44a2f71e3777246c0d34c52d46dc9a8f4e2ece38d0c77da23003e67fec622aab774175dee0e63272569510aae6a8d7cb3e4601865b759cc1f836e49f25fadfa8e9c117b4f0e24f1047c8a0a661bd9b6e6218f0a4ce5170eb978f22ed21b0fd31058c69fc93941712d2def0b547cdcd4c879482f4a8ed14267d59eec208d5dd1c2e784626dd8f69714564ca80d89db3f5cf5439272d29b7b48597e4a41ae4504cd521ea7d7698bb3095f7dadf8547932203637a3dab2d574812b86023825f5a618c096e72f1768b2ebefc731e5b3174b606671b585ff8dd238fb6615b081bc71ecdc0329b768945efab1bf9860833454683537bf80bb512665cd55062504560c7147bafd4134365854ae122dc43974f08f07a018ce4fef8d96a1bf053ba58eb99884f20fa4c9c04af1aa7d51003d54b4fef264075a5cc0d75eac9c067e339317cc27109a35a44f08089800af00a8276af82298e7aa891aa1450948ef9ef51351177466034e4524775b74461ef561df085d2fad6075171dce71c0105c30722ab76d04ef2d5c731fcd30bab8eb34db09f17373c978620d7f1f5c583ff1991c971336dee6fc1ebee8b20e61176a240ecdee91601c97eb234713efb5ed545eebc4c26673f4c9cd770b9019fbecb5722277d26d8a78a0cae2b93ed07397539014b608dc3606c922fdb0eef71e42736b6bd93e20244a890444a65b394c020aae43443ae6d7b3a41b2fc209e5c9008247a350b5da075f88cb043da3094d047396642c10e40270d0eb697f79db8d0adbf66e2203504d1d0b61c85b45c373642661808416957b286306711b3ec36fa33f52fe0c3a806ae07b484e71784e9df96357675be091aeda3a10f61b97c59856034a6663746ac9f61868c2a08cfca57b3d7b6144bfb07de743428879455b7428304eba8af4a53243863481cd44309820bc299a51d5fbb91233d9bf2559aece0e0f1d51472c1d8d1bde4f6dba496774a1c3bc705ceed12321e7625993a054161f783c7ccf3c0feecd5223d4569a5ffcefbb5eef1901aa7b3d42290c061db69562802f4e3013a668c3acde85eaae2c0fdd6dcda5c5b55cba6d6edec74ab66bdbdad634aa1a378eee7d0a33035adfc867b5edefa537229e3aef31cd489e31738f11295703bb5f96f65be7f1b2c0e387d909e2c3d0760a6b2efb4d92b14dd1b2275092b2fe089c869d1e458b7141d6df23d3f9d78fd296c13658fb54953da688dc1c346510d352f23fd1dfa0a5011e669542aa11278a6f0559088a575e5b4b902c7117ec46c3ec8962be3cf5d0eacff744e577647859ca994ddd73255154e18f2adcede19664e09d2ac6b2fdb19c2688fa2702993b417e258ade8b90edab81440aedf916d89e6f01623713ed31bfe732432692cc41f974d207f4c655e06a0f7129f7adcbcc4945f227c4eaafd97d8c7c972fc8e203fdc259e60139965aa2528272bd5ab7dd6e724260678873dcfcf4685a33867323b21f964dc6877fc79eec11483a11a746b48251915438d0a93056ba80f1ddba17569d08da82873bc1888a8050fce758926d2277981165bd06f82ef814c92be8fb33b46f1badd0eba43f351938369d0a157eca4493f0efa52bec416951ba185e1b5ba6e2aab2b875b430452d742544594491d661b6685fdbcfc281b230a7766e2c9eb21be72bc7c6dfa3a557e98e2142297e7d4ddb7ee4f8508b24aa96fba2d855e50f4eefdbf24c7ccbaef01b061cdff8ef191b11d6ca2a2b7c21a8f9f6681ac7e244d8c790dd368722f5cb57f946653774c050a4b71d57f8c7401fa10261554843d2ac515298c3524b399cd0d044bb76165227bf248aa513b7874d131cd661b38a1e60ca8ae3aad37724bd03f67d252d19b3675edb406a32aa8c4e0c2823b10bfe3a4f9c8e836922598a0bf8c69fac808663322a43a270b15b9afbc3dcde064e6573a95a030af964a84a06ad62a4da1c916b4f2c2e35779dbefd7fa2ad314975a895e769e1fca347b928af5297ec48d8562f5ebd0d90d0c11d62c10eef9d062a89100c2e2519dc9cc7923bba963969cac11d09892289f5440365710fefff9da6535df6a0c8221e89c9801979083605506a0c53d3479821b28d503dadb182570a2f059c7c15351ea1c955c8545a6a417dbb570933a470faf51afd3fdcd604c493dde17cc754e6b40feb3c5d08063e9041abdf42156b1812813c4802daf6df0e780149e45a64a42066602ab7e707b6ad257937a3485f3911725ac4acc8680fb47dcf60365b486547e01e79153f290a7b723922f91f822012476cfec18f9cf19a4586b8f8e790904e2273e2ed2a8c4a85e9bfc0766b28cb4a173ca657e1f30d8a21f8649ea9dc5136a4020f904bfb593f037c364ab4511334e327224651ed47820daf4d6430852b597714852740928f857e55f9360601c456e251d30d66a508096f6a7ebca2af542b57a3f6021c51a9e57c963375fb222942d673729601e7a2abea4acd6593e2e81f444e1688daae44acec91f20fb88a3b4805150e87031903601c0434ee7df6e6775f669a00c03e715a438670d64b7188364211615aadf118da8d25456b74b84f65ad6fccfbfdba1375f099c080b90fb1a9e486815c9db903c3abd38b049952dc6f260f52a701cf4820cce80d8920a9c999f77ab8af0d59b81db1690fbf4fc3cac1b71a2adf997e45358a0776cf82aa7348e2ca70a9f06eb4a883b1bf555e54b48898bbc22fc7c4dec00497f3b109260d2919df6cdf511cdd2849a0c8c860c3c05f2ddda82a93df2c7bba816e4c6bcff5dac9131beffa49bc7a0dba909da7d6ac6990fa6a04ab02f7a1cd53522b3365c84bb1645142e8c32d6f5f5aff74987fe2f655490acd6f2e476c5d788822a995cf89010fdbee79df12e3c7bff32561f854aabaccb3d14ced384e608334b106c2a449125e39aba61bd52880382874deb4293e74c7fec84c84d20cde9cf81aebf06ef3ee10d1097635f972647b5d5dbc68d9acf98d156895820c606b0678d1f432d7a4094f13cab8d29eb4ff7271e83ec4d8bc5641aba85df95c077479d98eb38e6bc547ecc9a62c8b62f152fac16a804fe4ba26eb9b0e7c106755570a4f223db326b540c8273809f84310696c35f45f4b6d01e881045bb2320afe31a6a8247f8fd4df00a68decaa06dbf441e82d305e25a92fc998b0fe0299c8f0b365fecc9a2084c145be5c63051e26121f6b3c729e325a7f5b624f8197b081181d53ecc47da2410cdb807ad95d1ad515456475b06931a0b18b0f57edfad2bb701ed9036949150367a078afcfb830f46716e0199cda8bf589d1776f473ce9f3c66ad01e9bfb1e4ed0b67b7b2b4cbf682037a91db9bfab203","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
