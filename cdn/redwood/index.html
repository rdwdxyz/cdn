<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74aceca3a9a7d9f375c433b811ee2ca568e71e018e8e3f06ad19550af32bc62efb1f81cf1c80f90f6cfc7adf626c9c39bf1ddf0ae3a292d40891bb018ecc15a32ac9c40ffbe73038613327ac2c10fc280f54248cfba65e196de5a5616ce15d791c31ccacb77f5edf1bb53882ba5143fef647110fffd8b2f492781758a35b65f9ebbf44a1f9bfde1b9c65230d4276feecfa6ed58baf8d162e12ffc9da9e2f17bcdd1c317dc3358467a383d16388c97c44e15969f1e44440e3a230e871bcbe373f14a8829f0ff575b3a1745779808cd1a0c4cbafa9d511ae6a3bcd5781c6c4002e4eea51fcd1e1060d8b1ce314d121d90648b921c26d618db9b8db5acddee9d85df53293aa2a8ee2ffd594191199e6ef6c79236a15717d428f3b38663d64be4cd1523fb279beb0b78f6e98deed0628fc87680ab5410ef1681cd3b32012d7c6f09f68d1ad58f893a8f1cd4021d96d186d308c8af8a3b4a52215106e190d6dbd780478ce82c11acb8414cbdfd44f622c8fd46cab3304c9a4a600270fa1ca47227fef7715388d619da921f7e86cf2874269323e2ae978223cfe915e74ff1719293c69a94add2d7784ce6704cc6537a29290d64a680e4ba21dab0bb2ee45f4cbd976b937f87a757bac8602b2aaa6d05f5d03a42152263ab3d5e1b708cf5bd3ba639a79291cdd28ecd3dcdabd70b81e788e93da292aedb76f23ea6e944cc01f500f5091dbce765769a72417dd27ae9d83136cb4fb1cda108640ccac44ec856ee38861e4525feeb8d04a6c3df0118705a67d0e04e0f760481611c0d28033b5a0f4953225c6f4d5d5a3cfc95852d3afa08328138ceef405f9d2e9572d39e137c4cfbdd7f53543fd2c194836b23c9724014ce3aa1a21cc3ad0e8715c62493fd2cbada33fa2b2e6b4fcabf66c0727cc54ca432fc4f492d56389c2bfe397529b776c3a8398e8cbf50e5ae186801d0c2f41d12160c31d664858a98c9e2244f1636d946249dafaa9b7901b05f30db1800afbb2feb4bbb651c677158642ab73983207f7273d3a4b26ee14a5b3e421af81918c72325d4e3b4788e4973091cea3885af4b652a75dc4cd3e28222abf0aa21e45dfab69bf28f2171c624d1f949a468eb8712c633e7d107fdf5c71183ab7fe4c0f30ec6993f9e59598f191eea6d3ed8602c79d6a7c57985148f1d7845276d8dfff75efa69fbf42c67405d6bd1274c76205b8681b00670b2b7c4c3b6b25707716c606770fdffb31f0db8dafcdc40d9ec4eeabd7ab12d0e1ec63a520991fc8c930cd6d1b4219b2bc4a2b001c3ad75abc64b83318ff12b5afccaefd9bf7ae7b40e13fc705b31db1c4bef863062789d3f8f88d60f62dd68ce34b3e2cec1d1377b740495ea83fe07cefafb00d8624dbb3cdb3b69298173f8e73e88caf313b66dafb030d9b18657eb7f8d2c437ce1a9b9762c65b4fe49b69db893c3466c94cae13c88e784c27b1f771fc54dfc67448600e27699c98a9f70274fb047f5bbb5d42937f6d45fd4be26543d0a674439220db080eca70dfd488fed755b4ab9132cd172ac0ec45ad4c75eaf5f364bbfc0ee57f6f41df6d792b3bfafcd0007d38a4b5494b870402c0ac2239b17780edbe235d1909747ab7087badf37608aeef6a85f90f85ca757be7c2f3bdd50af121d1b500f4bf0c6184e019731962b2c4fa4ed0471010b49f27a1fdd057f37a1a0deb0142d86e6e9fb230afabf1f813d77f55088c88a45c80538ea7c713f386a28d021d7a50063a3266ed65bac64f29f5aebff8dc72d1d20cbfe8e8d259b882334c90ea0f5ce180305f4876bd7f8a704d967a82df714422fee95ea51d097b85ba39c0d5107ad49e6f6c38c4626115580994bc92a3ba12ab8c0c5053e57ca71771bd4b6b1876afd89c1cb1f079b838dbdc979392c3c7dfc86d3c00882f02b7677b8207b86dee6ab52893948d756c7594b004be64093e9a4b29616d40a51fc00f12b4ede1096364d7f47585227996e12bf65b956ae383287d68b4c0a19c6a81be1f47fa09a38b2a67181b7a5b432ddd81525fe6ee43db4b9f61c5000923682100f41c34a4dd5d40a38f2bb652606f1f1296281e29bda8cefecfbd3e52568ca764f0059c6b0df872e55afd94dd018520b1ac505411721e9dc1e35d53e3fc16e16c6667dddf781cabcb9a4b3ebdfcd1c4789387cd8cd7047d42fadc5f3b8f8e59a8bb2576f87c07872a2c15c81bfbfa35d0e3ec5f6c589f1fa74872331706d80ff64c3854250d844f062a6d9f307361242845cfbdade643329fe9c1cabad86ce9587d694f996710df1ff2cc2195f751858625acbdec7b08198c6f38ebd9c1150958808bce51bb4eede2a7097ecfda3c1e3137f850c4fe038d647987bb3b940907b76c15aceaf6cfa731b1357de257d0140daa4503b8574d6936aa1f641ba631ce5fc47cf0fa7ec76066166200f09b0f5e1e12bb7386507a962b09fc200fbef8f6cf32e44de96db57e3d3cef83c5848505217eb42cf1f0798786249f46d2f8ec25bb4be73154ab2fd8c0121b07417a79cb9ff21616a883c5077d0c46b20c23c2195950035f534544767f4f29fff621e22f96213c71d588d0fa783852bddeed880aca96ed16b9c9248811b46c2a12fdc7942df5cb15101f5a29a32f64c48fcc31df4f5a2b000caecea30ce9c2aa01da975e6a9ce78daa7c0536cf64124a495fee7ddf98a78101d614b1cb6a6677cd839b9a36f849df1a8cdfc14cef85df8feab320f6a586b0e80bab09782ace6c644577c7b7517de74228888031ee7353101a4e75117196b673a42f12d9eb344701964a578eac218487a4c616dbedcae2abb1b080f2e6e3c55265960384c0c4be5a0cc4f0eb1e4fc384b2c5e4a33fc317e432265f8bc7d2350c5cf6f20fa337c48ea30963e3932840393603562395369a2512df1dc0cbd856f90438cfa276db5664f11cda0d074812df4eb29f205627e0feb443b27e6907dbcfd27d7e93b387c67f574d95c920fc512912aaf53c8243c7430a0b61fa4450cb0bfcfca09197343aa2efd23df075e57f613bb4402c300336b255c038f53c940b4dda8498b7cf0a886fe8065aa6be3af767347a8f382c6c2ad14a74e6cbd1d645db376f4017b64837d7007fc1bf4a4277ea651272881ff83cdef50d67daf3ef82d7298fbf1fafac6fc064c78f011d0bd57ea6fffcc21dbcca3fce57b7cb731a781ad66a386290f213110f6359f6390ab44ae98d02672962452ba9a3bcc6e3bb76428ccf9235f3d57cab0718578d5b077fb4e9037e69de2e6654ea7d0dd3b2fac420288ce0ef434d24b1fa31eb7a9b960e8e13f7a56f4fae49ac785a4530b6dc1caf10472c07696317880af0fb78a34fd87fdc28c1a112b1f8ee8b8171f15d9573fe04fb2387ec069ab3b553d6b9cd3c8ad23c8f019ff4ca50b9e63795b3eef79a7c869c5962f24858c6fadaf6eed5e61a1cbfcb37eb95d66bd50c7674275202c68d624d832a7c581009492e98c954b2c1e0db10827858a85f06018f64fd03fd287731435ad4870b976ab4cf81e3b286ed320c3f664d7a0d097db32c13b83ce954c981618751f084e8488125eb4c0b2c65c827467d78e34faa168a08ffd564e1b4ca6427595ee4713c6b38fcdce5e4b6b016fd6dc465e76d50cfcfb1c764369fda08ea98ec10f1b10f0dd0c4d5e8c856f42523abe292377cde1f7f93e338f324a3650fcdd4de4a7df2f6fa4b08fc0852dc077440543dbbcaf143747930496b61e454fba808458e5a964b414e73b1641da629ad97da74f17022f82d10b60c7d5bf09b432e4f2052882c7023126c94b355a69f45049952524b250f49beb3d573f1545de5cdad53c3ceb68817cb0eaa03711c9c918024a3d922994f7bd0117210ad11ade2e4830a8a165c4beb7e2e22d8975fe175d49f44f8379da60645970e967bf94f935199192ba300a9f01c6d8a9fec93010e1c7a02591fd376f976c72e26c3f9ef1cc2ee104daff08fb0571a2219ca0480c0528742b33b3d2e9780630ebcee013a868b568b59b85ea168746a8996fc0e8d8bc14f8eb62c2ca784010911d4737d7cb19845bd733f7ebfd7b690b3fb0df388bf44edd085dc5b7f0a1443387ad1f7f9bc7bc23a48504f33393b9ebf73dddc8d1891f802e5889940ae41eba7caaa53ad4d53af50cf28c7c23d779acbdf6ac662f517c61d094dc502582ee4f92fc0e68ed3fdb29ab015200740afff94ebfe8eaa178be31d041f465076d5e70348ead4067375ddcf66c7863ad536c7b577f4dfa0b61faf49a36b663fa3d5e7cbe5258f7199c3f014309b0658a98803ab0823626208b39592e86feeaa2a9b06db7204c11f02075d33fbc1865125bff467076ce32b7e9baf5127c9b84e74ffcfdf160cf487bb10ec38498d9ce16bee5d28dd885260bf56882e9086286617b8a4b85d2140172d76e3c4baa3650290ec1cddda26b02fdbb6e9810c657af856ac080c45601037bd6b7e85aeab519d845c2e9a4d1deb91e6ffd3eae76b31cbc8b2e861d2c5c3db8a7e64b6974a2776b60d406f4a1bf3c75e28366b8a56ba8589a3d97fae0a5f4190a73ac33054c18c3efc2504d2b8b1ba7c879c25a4b475abaf5b3bebccb0d15f54b759930627f1503338873726edc02e84b3749e316683c1bbdab337684e1f78ce714a0e3768c215bdc88e9e96be38021114b0f453d415ce783ce8cfcbbac7e8657b0864745f80ff2470afa0c3fcec37ffd60ab4c2c66151b156df8def1b5440104f2c482269a4c6abe4515969146d04002e137272697ddc44abce9fffb3924f13ce6b37962f2dffc88f01c4ff646eb1822f7ce8647ec6cf562c3393ee3da212ae4cbbd9c4d3eecf4900b03b95d717720872262067b5f888fc8f42b9e443c029c1caaf486c1cd2156dcea0f6c24164d8fc03981f41d46accf0e3bd3201e65478d5c9c1b3bd67202473b57711c7f205e7db9e10665347f067c5e408e161305cc4a877bc59217330e54fadc2af673b4929c9d04cffe21bbae79b88a87d6689ffab6c5440bbf399d0445d27f0c824f08f2ae3989d19c1b71b04c0024991158246753eaf03aad25f298feb9b8409010f61bd54c458906468a5bcf68097f4da05b0e18985a323836f9edfed64e451b0cc70477041e9119059e67e9f5d2da99a93278ae8b71eccc7094e60d26272e6c4a3da66e2bf932d38914b9285e72fbc4ef6c6b7e950b0c28bbb64017934fe2898439056284faaaab5b425a254b26211c44181feae8ddb10288f894f1065c5da93794615a2958e8317003c36ac6df7ff6a6e5e970701e63e81d541a3806c1ba25dc65409b0d8badd100798ef63e1695ae34e39968ce0a04df896472023df262412eec05fb9cc0986e65a7512c0a881fed102e1224b70b7aab87ce9b2be0742b35ac4cb5e17fb252f9700b2ae67c2866fa1f7b17804ff781374ed88c3bce699219359ff57b4ed13dc0250e5d3c232099b6d9b9d750a9ce91dca3de0be49d86afec9499e44890e51c44c74bd03619cd83816802cdcaa08799f2481f9e2b5a19892694b168f3b954cf64361335dd22585b6e0e650420a338d89f0ca59aa9ca7bfc391fb1711e473451603ba4fc8d7782c5ff84ea88afe4e16c1c69936caec5ef79434c15997eef0fcd7498699e26871efae3676d292a659c15aba7dca8877ba3ef7db76b01aa459cc1fac52c764bc9a598a7e7510a4064d374553bf758d22534d6bf8633ce6435d2014a533100367cd8f8a5aee36bd8411c6a25e2e045d9104393f6bf592624c8e80d92fec6f5e02e782898459f7becbc521a293673cb5c8ecca8b458d09d27f0dc8888f67969154b392e884b02a5f9331c02d20ae83ac98d506d6e4443bbe3106d76b2ba3c64c22a3f8d50e1955c142719baeb81cf541e90c930310a6cef6690a27fe39818faa6c0e52dea2c077837bde91e4e04f9ff9f763b4e552328ed3bb50b09139809215cc884d8b7a7722a48297c6fbe1ef32c59912108e1c753d32b6c5dd91ad66ae599e233300cc1c65c01adf530618bdd8d0a77697173f1a3f902495f90e55065afb7dbb00164f4c7b7d1d45f24ab61515a11e5942afcbeef10f1d4245a12d2271a65fa1b1699f0fd44bd1619bd45c514426b82c5bbd8a6499902304732c3f8fbe5b64bad5477919f9f51f2b405470d915ac5820f266c312eb574cfa03412e3de385d471a0907419367b6496825b98cf605a83698d12079da9d823cafec2df9c248f163e63c68a7a054a33bf50ae7b356cb030a2a45ef5d63aa348167f2e6936653775f6fdb505a2fa0fa232547d3f9b15cf47da3641f4bd1a2c79eb2e026551777dcf2db209c0afd10f10ea402456bd4567e7f453ffa2c12dac0f7d60dfeee85e41f008d46bc69b19c310bfba4dd7065734e1f1a502e9df5995de898246678028bb3e9364be89d516aab9f409e29452ddfb4620926990d326f1f5cdbecbc0230968504e0bdfedf48a461b0757eeeb060e4349ff4d3cc9989e5d1851b6491ba93acc560acd0be565c9fa5f9820c85253c562ee160b8d884d220162834abb96d9aa01510c472c58c2f9bdd932f60e14f74bfa6442eb91f120ee838c8c6041b584110bd1c042837b8ae29fb2bf415eca1e8286135f5ee393f0ad112b5527381086c4b7aa083fb5f7d002cfe532d75968019a6b6adf97465107b2ef4347884967bd4a1896ab87cfd58f00692e528050fe58e7e7b3ac294b5f1d629f7ab9336f7a21e35c5800a56e9e71d1824541b9ad373ed751ad7eea7962433d056ba81dc0f76c0f4b84d6a91584aa782aba04b263006cc4c22f0d8c9d1a8acb3fc4d6cfe6890012452bb5f2e213cbf0d2b31970ee550b8ddb5b99b43343cf2202e03b094fa75f1e92077a5e42e0ea1f157d50d0bde0eab2764c283bed3a963c3d2607b6a52e28e064934368cee209595d70bd253d94e39214672a3d46e78c6f8b9c8485ef6ec627f6f834b9dff06ab4cfa49a4113c2432b1fed1fa86d4e1f1640fb8aca80e04d2d0913261a24ae353830794a3473870f03cea39a19460392eeed83d2a5a4b8061f8b6f312121fe5718b96931aec880da46e7ff465f9ed04364b5e5eb60de2554d1f21b55f795ad8df695d947851fa51223b8e74d370d85823ddabe67a4a59d2622a605bb998e5114a053f91ee14b9eeb393d199d199fc8240b4a56c1e85eb40045162e44f0aa4e745ed8a6c3b65b8d083cea45c5321c3086d544ef39eaf1ae8a03552035c40d9a1e2e85b0d1f471fde7ea0911e7849b5d87a4cb7d9d6f5fa90715814c55b32fa11ae3a8cd0e32311e7201bfd9ff01fa39fb82f8c8f071a881fcaa5b963205577e8aed88673d8c5c59bdb5555903293820f4b9744c7fd215a4de49fa3122ffb49d4e6b7dd4a89a486edd87852930f8e7a6aebc1d73e96fe0d0c8b4af7cd84e7e4b42eb45ca61b4f7f9fb385931f7244138adf9dc29f5ea0894e643d287a667007777294c3af2ec8afd2130d532e1cca233c675642f19d830e4ea9d7fddaf6622b29f715eee3464fa227a8c0961029e57bdd8ad3d52411374beb243a30ce5d467cc6cfbcb159295f12c3e4c294aac827a6616b64a502111ec57b57c558d3adf6caa41f891abba4077077a1b7798c084dd50b42b3bfb3c4041ba6a23394f47f17296eada46762de30a2f0fad8a16ed10f42b3ad7341dd21c030ce4610b9455573b69c7addbfeb876cf4a394985ee00a963bbc01aec38ed85107e1e50a4ce0d29b5f9c940660d255dd44a01241bdcc91ea1854e28b582db1536a4eff66cff146e092092549db362b08b053eefef76024a2907672a9b6518104cf9e2ef861757843f2365fb743898df8fafb977267a30d912620f9b709e728803cdc4d14256e1618fcb29a74e5eee31c33d2b54d1ed70d00c1bcc4ddeb69f3f93822ac8775f82a84ff60bb18bd1c0894eeb069d871a93e1ca55b0e19d34808e63d7156d95bac0aa5544af8d7e08c808dd64eb04d0e6188e9fe548aa8e8f0a73594f1fc31ba5dbfd88c04f4030eca71d53dc9caceacb00667dbb60b1011de03fed3b5f7ab3dbc9d8b7cea802f5671e227ae55c065df414acd00b1f45e33b625fc6beefee817ffff376df515e07edcac9f2fc73694fbf3bd89b40381d18ce6ac3a5062a6342b4aea118c9b03fd70603ffdf5edddfeb90011e42bd3890b9704f277039f89025723523156c23b62eb0ae14ec0bdfe9be580025bc2471e7fe0e96ce6a935cd2bc9c6faaccb1986dc8f9764b8059e23c40acffc815d8bf0bc7620e7e2a177c24d39b6ef9eadb8d1f837fe2589a26233dc7aa96375c144806cfa390442e0400f1d8162177801a362d32dff490b5df60733a09a149c4da3b5622bfed822d33c4b840703fbbaf0375f9f5548feaac921ee4bd86b37e69d2fb01b1543e21f6fcd698059eb212c2f5e2bc763866dc15c3443c14067fde18e38f3fc85c5b761123fad53f279e54c71d1fc2c8b6054bfe8efbbd27aa13b43b7f0ecb4fa5b9e394cc98e22b7f77ae2188da6c53436d11e6eb6219004de07f5ff22974f30b4d2ddc851a0d33f9a6892da0da52ada37c2a260beada9060383ea8a9e8511ed91eea8785dd26c0d345584d2e744f8b9b8b6a649a6353b81aa07e324fa6eb2900282529588681b2b43d07cfbf4a98bfa400451ed214bcb4579ba7a333551d37ea05072a891fdc2bc7308849b3a6a1a8047e1acf7e100f6df771de6108793c1d11075aad5eb94c1411c2bea2d090aa1051dd7f0d522d14bf12807f37ca7650f4fc6c70a1ced818a222965f0a7e0b5ffd82c1edde552031676bbbe9409aa935f11cc3ea8e51922fbe6d1aa6ccd9245464045f803ab6f184ff9bce7973cae88c8e5a530d6ee8ce6f89f18021005240fdcb3f95869c9c3e9ae34ab66f3f1d4297f5e08d5b48388cfbb437990c206ecb3854fe95c3ac4fc59dbfb86ade2c2c980127fa7f4ea4beaca2a46012b4758986e127ed69d44a6e8653eb23f1193bc6c2cdb454ab3bd7cfa8172311cf0d0b611f812c0962f8d4cef43a86666d612e5741c96c4b1d0309a0d4253de2e8d1031394727b3d7108371f381b20c56514043783326be80db01da4f31b49e59188245f70f142066c8ebb43d1fb03f0dcd14897b91cfd421f370e75af249eed6a6973a8fda376fc194a7bff7c84f062dada9c68bcadf8fe7f308f1394594a9c3b472f1b93ec99742422c55bf04612f709fd8a2fc874c98ff00230d704b7f090d6dce5653d716c88cef9dd4446f31ae4f17f5d76fa5c497e3d68efa84215688789821f43af4432117d5b1f083f46009cc0b197a6c62a3c8e9d7388cf9f11f17507391be093aa0b3b18337277ae2de2ebe245088397402b028273a2f9e4ae95f5535791d71a4618f0d12cdd05ee18ae4d306c7c83086ad1394cc76292a4fca20281d1f70d483d78f89136c09c693c9b9dc1ef8948c79e613ed49c2e46aa2a31d598c83e58961ddaffd2c7cd2fc9f22f55da759b153c949d5d1d1280d5e804df2a43941e97b110ec8db0e318bd05f5d8281bf0b9e1d302f1885a99637e2c2fd9b59f90713a203486173e14fc1be06f176303c503688071e16b1341c8ee9b7e2d975ebf7232770de58adc680bae9249f704dba10273fc1c0524ff689c91354c7be05c7375e15566155a4783af2a312d71b86c271c17e0a3b48f2b56decf54f2b4f0d9f5349163796e53cd0a4264e99ad418225de641b2d5f4cf35152b97602a6b2a1899883d43915eee9dbc06747861f07e920f8c326da2b68235b87283c99a3a6d0178de4fbd8e934ed72c88792e1b44c8a1b5d9b4f26df6a116a01d8084e10ba2c92633db5fb73f323b065d700b7c2e87908e3777a178b02d5675c0774b8c962468c7c10025a33ee28edacb28ccf69940795518cde9afe3e9c7c82817fc8c63befff929d187b560e1bc2e2d109f52c72ae8f34b077bb21262ed411e4a50b680abb2a09e2d31963bfe00bb903134043cfbed59e3ec37af0a942900dce414d610fc6b706bf36c9ecdcc10f978e7e9c75871d4c078562b12492d7a8cf2644bd8c35d5b8d8bfdd53044a35ec997b4a2e9a821049430e7904dda9baf3afee91f5a0bd24cff9b6ecb5fedaa42941f0a42509864ebb9bfe63bc2b021b4b5370c5156917b568057f6259009f7d1c5ddc5b2ae26740fd6052f36626630c10fa1e00102dc97df516a80a3dace6f0c738c74aeadd78cd52ca670fc528fcf6e6fa0e0e45df4c4618132cb8f17dca2a667ae5730f97db306cc19887e9b702d9f582d3c7052bd05ed4839618bb80c91a4c9512df3133ec1b40d065ecff66e91386ca3b76213c157ebcbfb883735444386b1ce42c7c15d8022023dfa7cc36252752be9429936af5a27877948fe97b243bc8c51646430a3152dd91aaae7b3891ae757aefafd842a98864b15ca9a9922dd50016ca81bced3b1405ee0c341389c35f06e564bc95ae4755b901315309c7c431e843ab6893a91f5e9f8fec512dff23fd5b9c4c30eb9c7abc1263b1ad2effedfbfd87d571bbdedf181ec4e527a6dedd29245f17875d1baf7f1940048ad0e6f4532c0a6710b9052b2f5f4329c67bf68fbb69ecffd72b05cd6f24346b4a3258773205dca6ab72b0f7d7b3b0626e107f0dc761e0ef16cd68996aa39f49f699675c34948f8012fdaa91cd029d716b8e14b2c47f8f361e9b00e7ebb04184d6587163b5826d2f090b98abdbbd646a0975d7dbdceeee83809a504b58bda83045c3ba5d30184e5ea95ea4637bba55e53191de0567277372f781443bb39f945315fe0f442696c02d09c0b2570ddfc24005f13c23bf9a554087b43f549d1c3f964b455aad238517ce63e215d4e741336c2af8a8691c81fb8ece1e9e47e023db2506295f3d0096ae587215bebc0a18ccdab1d637adc1473ad3c39987768dfa8ede340f74cac8850131682cc71f45220f545d845f9518dd7a8b123f67bd33b75f8da773967a117181f1efb04722025fb62b6eab54f69344d65bfc5db7666d878a662c8f9bd5751b405350fccfcede0d42714d3784487dc5fdc2c3db767c265fb7fd2682e3adddf0203e0bd21e23c15d23d145b1ed72e27c189fe0d94ae705fd0ab70cebe54237aca318e992d04bff9c6558d871a6d946ef1e74888fa768f22a70c4a71e1583c5452693b201a8a35303ff3203349b4fde3acb735edc96b8833665c3bdd79703accd3a3f9a284358f8ec66e52ca489c598b6ca3aac47eec7d479c6b15f15ebe99c9aa1983fc822c6d5fe91ffac344882d2deea021a3759922f5d49c9ddaac916dcafed26c2ab9b4ea2bc8c85b683a9b05cfba25f1a6da2fca0007e3f18ce64dc60333d50249ab1afee168db71d52611d7be6a0db46fee090211f2e796a21e68c1776a83203ce7dc86af7ed4a382080c65cb619b41c3b7ad92022be82debf3a573fab402ae5e76437946d81f173c282d7072453cc9035fc6110c6435fd7a39e4a41e408817ec649b902568d47befdb8bdd847716b8eb1d8dff36b8de12a3f61c13d808f2ef4658a442083c38fd069a2aae30bd5ef45798252e7ee151d2658f273c0b943db6d9ba555c69627ecacbf4722d68bd0bb6624e93a33834c72ef0b0af94c9907290d3a598dc3acf25772f9abb7b720cbdef3c6d514d8384b31863768f7343d76c128334e2dd0c9b5b3ea98fec3c2f697c56de399b4873044976fed9acecbab9ba465a895e41c6df12c5c3a3a89e6987d5124f38b8d8def0423fbc20188485e96230999f814f8807b603be058953f9fe27ce6858e70288061e42563052ff1075d2c01be1428c7ae4a84b2e9f9bb3b78e7a0a98736c2f0eb404d37f1c67dcd4c545b9e6afa0040d02ac4ea87051ea6a35756f10f972e337684f37cb0aa2222bbee7d31f77f830e7e9ba4671fcc98d665827aac70bc3f7aa63688dccd102802c159f0f70fb7937360d28c87beacc882e5553eea4a7e46998d45c707e1aa15fa9cd84ec19f1119f50b76f543cc8a57ce3bef345258f542df9542064ab868cefd3ff8879232a60eb8bbdf676d4b922f277c816a8161fa2f72686c26ab57921dde363db6aed24e66a5144a2327c28f39200c462c23301a139ba1e21751f05ac0e9673e236cd619b5d5f01b21b642b0d7466da86cc8555d1459ac23e70305245e52034f3492eda333357c263dd7d01238f448181eb14b6be05b8822b58c67171afb4cbec62e9e22a44fad81e1ca27c0b279261f1ff84d6215e8276eab985c4f47b767f4e56c3c4cfbb1e69f2d8e94b0030442e63ad518669822cee6ce787ae3474788cf35e5b245b72c75c1b996561fadffa73311ed8e56944039f6d8dd62d70d65c07009d368493649c73a482c7b333583d3a6389270dd781a2a97e17cff9189ac647f5add323c3b0fe79e514b5986d173831960d251d8ad20ad064744c31637019c44773ae83f80a9fdb57d6de62a3fdba1a39b32a6f31512b5e397150bdaeb216d2cb3791e0d8ce1810c5aa1a044d38c46ec55a5e5a28d41fc8b7d2ca283a216e74af8f6abb6596d33ec1ddea63bb01087131cdfa49bfb90bbc71c0e43a303403a7134453cbf8aaadbf489b072d63c639101b85f688390cfebf904e880a1e4aa2d457a30366c4c872fa1662d3ea14e429060b00e7cbd47ce1b1eb81a8c7f7870a839c350431612e1b6eb80405d06a2a3f83230026df4df852188d85859276287082d4aa049448e695d1a37402fa992f6550cbe5f8450aef6b451553d698cf8b0b126cbcb2a0008c5b774d8f2f062e043cf1d8f514fe42b9e0d1bfe8ea8b56f673f0da2e129b0de3819e890e38ad7dcbc2948d737d3fdbf24b3a8d3643e05cddba56cd7e14693668163cf1d67e43d3d3dc7942fa42bb38ea6edd5173b705bbe647cf79a25a3e0f1c1a8390f474a780baf7a9bcd4bfc5f2b2a86411cdbf0b3d14b8660b698c3b50071dc8bd02f30467dd7c979920d0c08bfb73bad71186fb6686642d560380759761a401b8b15a1da493370d99d1dacdc0569369e2b585b47b356941be9399349394b5c24773232dde45cb232b40a6bb9f379399b6d417db566986539e9c342fd4904d93f002563e63a81708eb44c3bfbabc62770b6fff50a315caf7014906fa8e417c132b6a828584ca4f53530b2f011e3976eff3d762a6967d5e759a3ceebf8f8ca0ef55ca524018a7a332dbc5b05adaa17fc37ba59b718cd631c24a247912f14d62d517f10db9d80f9a79ffa6436d3bfc592c97662e2838cc016d1fc1583516a9c786bc25aa181f76c68622280b80a8826b96a70026328463154bebcab493db1dd30145fd4895123cdc0b2fed09c42e6e9f7a3283381e30f6159a74c6ebe83a72ee74bb0ccbc1cd69e2e864899a89ffd01fcec4f2a1ce65eb7f9dd219aa4323213af9930483eb4e2f243d47ecfccc8164c8193c7c066d5c4ac457fc0e45d371920edfd0b7b24257ba0be8c1dee628a36eeb0150b0d77420e9008bcd9bd53be1f976edc2cc77d881f92bdd3864024ab88cdf437bb68b8fb7193c9c2497d73158108a9f64a9f3aee781c45f2e93683d063012821da77c4a543024904e0594d402f58359ec97255bf338aec7c5a880a0fd303f8e2cadd01f690d9c3b419e60dc199482ffb40f3746b4bb448a2a05c96c7b986464440c67d9343185db49bfa64138837c399f3a743590d475f822ed928ebd5e3ffef902b9fd38040bbd4e0db09ce0ae7f912ccc06107c103790e9d7018f4b82702b261a354de660aee9a68e50f0df503a95b1dc6e90c06a8a5290448881cb9a6b47f8a8691e6fe0541f9810fabeb191d6dd712333ef1964969c19284ed5c326e354cc61cfc09f644ee59d18f90ddfd1f26df21eb8938035b38fe6fe94e5d60f26747b365763e9a954a836ccdac234b6775cf0616e99194637f7a2d8777ae581a0e1cfe27db24d210c75527485f569ba996ecb1742793613163b1f712108ca6297a7d796bc5be67ce75212d5c4daa09c5ac2dd480fff4783cf8c2cd9ce0261e118341656a412a06c4941090f8aa821d69a059afaa624e62f1148580b51eebd063fafe66b937022370690dc8850d034dfe3aa36500eb98737705f216d935fc4ff705c5197e0181348fa33be49f8c78986d3c11fcae5e36568582edf8825440fc800dbf7b98be5e4089592daa70efcf2365332be4d3dc636e5f2787b856ec0479e5005597d0133ae83e582ff0554d396ed39844779bbd615410b708c9547077ca20237b1cf73feb5d04338bba6a84a1f27efe416c891a0a4b9e9e856e047be9e842103fa27adca85fa4408c4baecf33a597461cc089e6acc26bc21d5ec760be7acdc8704cc9740efa3d42b5860bef04c9033a4ba8b1af7896e927080a0de027f7d4a270379f99f39138d92084a30ecb6263532f53bd219a19b0515085eee95dda54e14d6bd1f7372126e136ab32a4d771346725d62931fc0ec6297388b985162b5bf2d46157b7ec36f18ef625fbc7371b9f4702ed4ae366c581b0e9ae74f9f16e838041bb7b514e083d3f5f876e6f325ad6744c6d2f06d8e49de10584a403e067576e660cd71d7dc23550751219098d426ffdfc9ca838823c9b77a846d8fbb5e832454b78d32dab9eeba2fbc084281002968ff0dc2c9602a557dba5fde1b47af9c564da6975989cf7fac1cfe8a647fc712848cb3ae10b31c2c6911115a00a71890392a46ed9b48b92f67789f25240dc8512f154994cad460e18c5139695cfb4964d2572656ac3a15f6026b5b287b4eb4c181f0abad6d4872035c95779c2ab2e35f1b9225271af7b224b9b75b80bbe959d4b9502afd427fca0d8095a80f10ad801f4e437352b6e2c6a993adbd672b3f42307e6846cce71a18baa72bb5fd4bfa9115c4e57fb529f4a18b939a9df2d7c5c425302a56702ae8afd73ad7f9d0b48e1c88a02514c1c5091f0b5811d61af38b8d0ae3a3a046b90b42cc49b5ddbb1803b79ac359b1ea3d67da650e3579a732364fa2099784cbf1138de5751f40d9a407656d04a6e5348c5b44e13ed8dbbabe5ab7b24f333663eb41be5f525b0e7175ca0521b32c9b2d80e82e57d6a83cf7d16fc1851f040011dd48e4eecc3b50145f7d3edbdec02a675051d7e135facf7fe6dd45c647dc68b3cc0289fa7341c2e91dcb8fcac7b27b851a51d01b0a90d7988e623e3eb24807d846e0491aef4e5d87a6377fa00a3fa0a11558c64fa411ebf67ef48a6d3b931e47f094ae63e1b29adcb9b95565d922543bf86bb12202ab492dff54d7d3a5b452b03df77693614a9a345c4f4d892162c336d2743c6a28c76093084cdb509272c96fefdf6894538bbee8ed47e1d7338ba94add288970050a6d840c8400cdb6bc4580f1ba6121ece553e27775359e3e351c2c608cfb0cb7464055c32c2dbe68fce9c0b49ebe99442e2c095853b5293dc0a6d8c5fbfcd7df93669148ee9e88ecf7de1a1e5e33c5729dbf8fe40e1d7985d0c351e37f96556c3b7ef6ff4862b8a510c67d446260af88374ee018f1474ac12758d6f7ce1f4924739408a11f0fdc4873d5e04937a481ae7e82a702eb07a46c00b129ac7edc2af5a5c72aac5626c182d404da6eccf4f3cebd3bb037d2e8e5749614b4ef8c70342195038fb8c81d9afd7d36249c708fbdc1bec92c8c995a62064d02223934855dc4d79455b74cefe33ad8069e21f95eb55922ee77986fe75950a320b44d81d759dc7c165945c2d2de800432fc80b71e0d3e2b7d3fef57cce9d78347b66ae829bcf3eb33f09d6053429be80e04dbe5dd9376baa17144794374e7c7d969b5b6beb121e9b441687b5db4fa4dfc4b2912a5954e2f0dfe18d68b4eeb16e4036586a739d6a149323d789aa4b8a16289eed9cc2e97e0e1ed63a876260906a412bb573726d3ded93ad78ee2da128c83532be8fc01043714610de301e9e2e8af6d3a55eda6010f5179dd727fa01676af6910cf52a661ca450868575de80ff385e4d51fb2e99af71da60b5a358e220cc9c3154a532560651e2b56d0df37b89931b42e781b43791dcef6c92fbe0951d19be1b00cfd3be6e35b22ae64bc256cb12512d28a5a4fe2900cfd4b56a236175777e3354c3ab120696965529bd6d3c309f9d65eec3d32792d7b4603284dc76de2b172f48b60b66d0c91e8dea46c10dd4055846ea2b6d25862a4a52bdb0d71b6d3af367e2ca97819f176833a8756cfa0a023b86642d62e2dc12535e10c051d1b0471b4bdf67015f89fe601439a89ef9f53207cd03cdcc2e852e9e6264a06dcb6fecbabcad72a5b2e1df788df9c7807b9575061c1194b3829419c038bd78fe50337256aef29d96e1c0f80afbb8a818aa17a17d4a311380ffd265d63b9e7ec8b4faa4923cf5ee75c3442effb56f29fa05d12a1e841398b38c9a63740db060afe5d5bcb02d2e47b6cf6e25ec77e700ef89fee23f2ab95316a9b9c05c5263b7ae1789698775358dd0628d2e112f17dff15456a3b29190dc7994cf59420c5d0f71a51d4e613764d91e0347de492bd98e481238c92f3eff83c7bf67ed451fe155f517fe712c8e1376758d66950efe703d1114fc47d601452c9483d7a330cb4edc86c8736924ac2c8b5e239a595cc4bdf5373e401f31907ad810b7d65059a3909b3c1ac904e534375dccc05d49d4348a99b3bd5a1d25d697efa9ea8ce38f489caf57db9ad7303a5f9b876e6f12f8e3b67c816b7ec9c4a21b5534afd7fd4f258065e5045057ed4038ee6278d702a78e01efc64e40fc6ad800b665db195d8977d8a111658823b606afd819cfae286b48949e75deb0c134b1be4db65fa483c9a0abe3bc5cc474c63d666daedb33d76e7a28b086e58a7d82d306083069713b4b5cd46075502bd5fc2eebb8c50b087805771acafa4fad30ac4cf5a0ef6b6823e5daae0dd5efa75e116b2c812bbe8b9d35ad73665efba1cf49e840d02b45b3592004112d1094468a1b5035472f6eea76f2f2193bf8e0137395e34559fbc320e6364b55ed552be1934eb58eafca75469285d73d76a0bff8fefb5470ce00ba019cf208f43b433e8308fef0b7a5209deb505f0db161233d22ed742dfea2cd1efdc8c17cf6f57af565144a6e26b80fbd7f33cce682466229dcd857b764cac2f49501ab3cf4c08b28feb8d1e2c25bc1583589eeda7a86ebc5f5f38b76a69a2c0452814fb5f44b93bfb9225449d99f73de5d73cca6bd178a87e7ddaade2e7d6c9e3e1cebf383a025ee9ce193ba89473e64f070b4de4539253ad7612dce261277e0a86398090f553fdad2c2121786af4f4a934b8c9b18a79e31a3fdf0d10b01e7ef5246a9d6a590bd6c10246e0a6196c71113bd4fac99718c07977f73489982cba7d115f84e85f154cdc11f61de6eb64bca2de2ab62542ae131bda37fcad288a11c453edf4784260693787bde1052fdd71bd15143333465c87358045eec3de303195628a68dc615d0ce6d986f5624cdd94efcd2450149c32c688d9831ad8e4838c946a9c9a5520272453a203b4ec3f2f1b7850de19b15ecf37046b4a48949de6ea60ae91816c6efcf8af38f1ef2e48a2bbfbcdca939ffc324763c9812bff130d3dcaaf1fbd4a5183c993c3cec3aeeb26888c73b56cd1ec84ee7e8653f017f3bcc5a88c874e2707bce996625252624dfe83c84c7b675549987fcf2b09d1bf9ce1543d82ebe036bba17f108e16caf4e86c40183d269c1d2915ad611f99045af914171e54450cd7ac97e39581272cd81370cd5d3ddd122be7dc191d7081c936d69b152ddd8194f9f4b283794057c494dfc76ada5de368bb97d9cabfd46b25130163950f1cd1e3f16bdc899efec04598e048ffeb623ebda16e717c8fe381d86d470577319bbefc46597e214759137474c1031eb0a64871112cbe6b37a9579a46372980a49ce10b68023ae3a327ff6b1b5980bc9f0fae605b61c1c4a75557121cb242796d098fd1dc27e0b4655fe8f7badea414d3197415870082f1dc96ebbce45b66d726469419a126262502f77f2edfd08b14f5d94f3cc1b5bd4ee9c3a68d9b2afa81f4bb4f499c392af6de2d6d54db1370b39fee94091ad8b582e8899d90dd203f929d0e9e5a53088a078fc165","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
