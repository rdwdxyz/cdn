<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70a2a6df8122f02099d50c2d0dcd2463aa36fd6a8446d9d6856c17346afde936ff174796ec97b6177c2e658e4a59b4f3d7f79ddd57ec74544369b9a6318076803af91947b422bb14c7363d7ac63325e71466b164e837c97a0bd1115f0e2b1a8b6fc6bc2215d8f573c18562195b75f628c925e785e57bcd10c94d4b638875e1f5578aacecd94617db4d3f83b1c9e74534dc982076d9e84362f7f5a942f3afd0dc922b23d8380f60576231f13f279d02fadc2b3b5f1a8aef33d1cdd041d959558282e0a0ceef115cdd49a7e57e139e7e1d3ae06c93488931fcee75785f9a3a5db5e7548ed81a81b1285121793ba94d328c9ad21dfe88c4af4c98fc1ef1093a7261623060884a404d120a6e2cc1fe60782ee676509e49c90062b8b173a3b0e51459d09d9920866ee92e2bbe7d23c239059baf0b44d8b02483dfe53f345c517f65a4c0acd2debb427db06f028a7a644ea4e94e61b8e14894324317cb6edbafd6af5361eeddc8957a2b2e8c800f635da3399e453d8597f2e715bdbf34a284e9200c8d8df748fca53a6d9f4a68afd07404bb684133623b29413466af1f6d0233dbeefecf14bb2ed270280b1df9808df0cd48bb4295f456abd980cef3afe15ae91818d571a927e09bde66ec127205b7f16c8c343fe37ac1e2a5300446ca364a4a402caaf8092b58272728cf537bc77408dca47dadca065ff5d15e369cc08383a275fdf7a0f72a2cf37b538cd8c5cbd092f52fc6c28c171a45c527732f72c9157a169770515ceabaeb4f21212be7935d76cfee6db985981488f7e55e1897f68e75ef63358d97eefecaf3491db008910a81a1cb863c389ae25fd2bd6e75148eec88adc5005400d9dd2216004bbe66d4b81497cdef9be6446839580492d906351231a9c07eeea40fa775e7f13a6e88ab241ed7f64b1d03578464e2827ccdbc99966f43f8de0d039e6459fd2b8fc26748c821ab11a8efec437cf5bcb2c40da98648ff39239718fc87a11e5fbf055129d748d7bbbacf82324072efa66a8ca87f9c344466d414aba6690bba5ed0ea26ed0611764614068af3857ce22daa4c17914eef3f33e43ae2c1c543ebfffacf0700ed1277add59789a7fe74c24a11e5d3cf5ebb5170cf415efe85c76f150c02b3b82ffd21389220a129486d410f645ac1adc3da7969e70ee629bf0b50637ae4ca9a08a83bad4febc65925c2ed2d2ff095159ccf76c143010f3ac34f985c3e753175c2a08a701001eb3ee65dd1b71b83603e47b2f8a31ebcc02b32f1dc2b75640f0914c4b4c99c8fd7859b53e0b5ad88140364bac991f9e9edcb3d107003ea0bfb9cb2f9afd73f96327af8770efc796cb6538e9877aa66810fd5c424fd4178f73e83360417e972d4d45d9d2b26b9d14323ee0b775efd20ae959aa850598906ffd85b8588b798a7ac6b7d33b036dad20c01855adebb301764899e7f72709fe121f0b522b29aa39f5f7e0b0175144c365d1e5d2ef6c0027ba8a97f98a1497d292ca1f23b1418ac795912b2b9fa684807ba356e7c0ebd36c16c5a23fc61f69d28e8feb1f5fdbb2511b59b938a72b50286e05bb714e4f717cd8642b997624a8594e7c7e1b353ad684a4e2a2865b09f4d2febb3bc4ffef1bbf2c6d4e56472a9233a57ed77ed132d0a42e84f2b59ec827230b9da6eb96ccb4029faa62b282e579969a3a452341017123aa1fe1f983da01b6cde75dcfd941cda9f6c4416faf26d9877e6aeba9dd95ee43206308010ae0ca7c4987a29ad1ef215acd5cdd9e00efeafbd11f537934961b7c53e1c7e6b14a8845d992da5afb8edf5f2dc22dfcbd5fcdab6a1706219ff50abdce4a47e27c38c93afd71724e41f76fa5b2528bf3825fe0a1c52cece35b78f9148eb4f94690236df2a2dea4b2811c813ac5a7c1686540cc40566c5c2f5cd15c97aa34690bdaa03518c649fc991a65be04b1335f1377beff41bbb30ad4fa35404c9e3ff57876d84e0f50bd677ca67829d1da9f524364ba019dd8bccea7516cb7c4cc007fd16a931bf4ebe44197553ce9dbe776b73ef553708bf2937112848c12680772a3688c95f812cf4114ee71df273b638da6ede831f894fe2c64d1f4531359d4e7e226c0ab44502253a3232bf158a33156fd7487829d6f2584b2455296022257e58fb07247943ee0ab0e4c6812f442f537fe21a01af79a33c9af7105f848796ed4cd33232124c74a217da3ecb76263aac2ee86214c03b8d669042f2fd44f25ac8535050482be7e7091da4964bafcb0822d29ea08af1e14b63ed6243e9e9d75754b5b146c61a98cade1a0214edd77ffd8945478ffb03caf9ff9acf2207bb12310a6d03d0e47da5f2a5286ac5322904c611344c5820478f041e6e6e46c0540e95b14ea77d75b671bb1a980930d1622c49e8a2a086f421263cebe284835be5aa2b68bb726b2be4dd14f3e2e0cddd2e30f40f1a8b2267a73410885d2bd782a4be7d2fdbacc20d0fb2e1044058f7403025ec6f5378891608a53a09f6b9159727d6de515a60615fbe64809de4afd17034e9438442288445a298134a5706dd36d9c64f3c0f5f70cea0b2ae9f7541c4880144c4505805155f94906f9d56008068a3edff881ee8a6f7ef1a5784fde32124d0a91f2a6ff36955870e2f48124d555d5a45933a49a7a493222c4c4e4f1a6dcb5b9107f4349b13403a56551adce99271d3e623cead472e4198a848f24db0a599cb2307f2cb67b51152ce8e89ffca1109230d218b7aef17f706cc7da0fce96e3f579f50ea89f709bf2a1c818a6e3a1182628dad21a9aae3bf0dd6523ba7b903f38b0ee205241ed7c5c7b85938618b8570486892b5ea64fb28817fe45331e6632da63214416c9ee1aa280f861d0f561d68c00056f7833ac6bc8529c96d698406aa8ae32e6266bc908464044c48a481e2aeed34869a5108fa01bddcd1d9ce89ed230a5958d62d1a4bda5a23795e9785173663ecc624c67a2d505865beb3680966caaa846eb01260ecd1b2275beebc261689c6140213f3db0e5ddbf6755d098e5c4b1874f7ea17ecaa4626aea7b7a52a936e0f309d68968599c8ee1469c08e2c468c81cc484ed5a9658f1a860dff6a507afc52132a5f99166d7e81f60d8f6638d7522adc9aba13ebf4e63b4db60aaf0998c16331433db7b3ef210c6a3d97cdd89d09b1d42762dfb594cc96b5913ac557a12420c398ab926c688c33c093beb784434b487a1af36c8ccf3904eab81b5a95a7ed7b1269cd24dce6c66ba56ce424b0ca2e53ff5b077704000367fd0b35420835fefc029bed9c4d8736d2c27e492640730e23804afe3fe48829e1b7f5f2a3d3df64747198c82d1e58652c95ce6d316b0a530a3ed327cb11151f934d37f8be3929dd654b58750a0a77718ae1d9d33e4054ce4bddd5e36bfbb70e1707fd2c96c28617d84e4bd225a01c74216e8998c6cd865a7d25fdc95c1304b6e211ddc8181e6d2eed2872f90762c9a1a59236e6badf158544fd827532ea5e45c149c7bd0674f4e78d33877d3f14cfc4807061ca15f9dc2b281a1c43182ee9aff5fbad9e068795eedaf7cf04aa4eb425a086482c15fc33a2f70713270af25bea9f35fd715e4f873df38fc8c6b4b32f8f59394d324b7d3a2c2068f40e9e0e682740df97190a3b1b693e26ddf65348cf5add8a177721ae4026cd83c767d18055ae1cba8285e37a4123c3fd63ae7823639c3e220f5b93782ce745340c980e4933234b7d05b239deb2921b9db931feb4076e8c6853f56eb331bb62256db258e6f2f2e6586d2becb30619fd3298827c074d15aef3e84daa95477f58bafec7bf1847e7df233fd5b7505810ad661262aeab4fc0a8af8f170ab8ed4a208cc2d6439cbc616aa5f8d4aa5324e334f7b308e47736066abc60b58d30a5db583326de5ceaa5fe16dbce34e80d89f92b06acea8e1d3630399b407f66f730d2c8d1088b656f76e7502ed947918614d5fb918d7e9e6ac25fd2a96c7dd5533b000b5c9cde05e4a84c8f603931aa810e7fd4a8d17d2a03e467104ed8deecc8dd1668e4d0e3b5fb27f5dcd827400624334d1e8cfaf7af668af87b8ccbe571760e95e0248bedd4212a796f07e5b23ad79a0497fa90bd56e3043a0bae19172a104af9a37d41b8a56cb37508812f1949893553bbd94d9cf9c84f7bcbd0766a5f5b52da408125cb113c28d0f0adb82832b46257a3e9398f7358862209984c9a14e28b63626faffcb5f3f21b4366714c994ac3209ec57172a5d4d0865d40b6c48a3eb6897d7c8653d8fa3c0dde84fbb7f008a4ae33f04531b36a23d0d8eef8e2fcdabd3460fb3ddda2f939275b3771a5a9756ec5abb2eec0471788b818a6bde47f28f829bd1afcf33cd2b1f5e3785cc935fd7fb60a27e5acaf86c268a20c771cd6ec4dcb749b8f62b4fb3ff15bcc4b96dd71ace4f71af481cb66185a9367459bbef41982bac8a722fc87be060102b174360a7a15bf808da4a5e319967c235064aa28fbedf9f2c71855411e8aee8786fe9f4c4c2a4059b5e83518f457c722440e77484ee2d0f28d2a54bc91da8b19fe3e04915a94e7af83dd529bb84715a9e293ab3cef34c6536943ec4276a330bc160b6800401a2cb1da0a29a76c06a5271c52c08a50717cd6059b12bedbed98c58a754d6137acac13078b69e01b57ca74b87837589dffb40194f4cc426dc611021ec9824863d345a22d26e59e4ced9da46dfca84fc308956c195095c453bd01a6c079824df53f1741d543044c7822eba101e925b66224f807f4984b15d8f9d7207b24a48f888d788a707a0ba1cd2118c64494e406c807a21c7d04aedf20fa0961a21c994838cfcf94d79e569a473dd044d4f6e9d068196025e405a861fc9f3cb880100f24acd83f95c59e325f4f18b55f177bad07c4c36b6a9a6765aff288ae2cb48f348d4767292bb8aa19d7b8c939d03a154c90e700c736f00384907aa497c124d13e3c962692abdbdcce5f0adf4e8898ed6e7a8f72341ca7666dad2e78edddb78433b79b434c3c59d4fdd56695d0efd98892d2a1087963d6e418348a6bb0a7663489ea7942dabe7b9a75574f9674cd62ff8dfd8d8661d9613cee2c33f43db649992270651960980ae808ee242a9b2196626a95bed4cfaed30acd72526a9bb148dccb602b98f9eeffb9666407a07e29cf45a6d70f437e0058cce287708735a6d8f09bea485ade50121325b0b851d64fc62d598c82bab0d66f9edd0f7f10a7fbe38eb1b98319915d4cb17b09b8252f917237309d062ef0c44fcc36a8595a003a9942c133880878618380a56cd2589de797800fa91631ae3639b94d62b2867dc4a7af7c6c464824a9857b29daa90ae1df7b34840f1f6115cfe2b132c0b9a60e96d434e27614020c3b712559dabc77579d108f0db9426b90a0fddf8905706af3d757a998aa4108ce8403040a32ddf0762d6a78436e2f83721448b95c3e696941beaf51c55cf768b6fc8c1c539a6cfecc74b68370267563cbafff9651e085c28ab347a6d01a8a09bd091f32faf67f8dbd478d0a96db305ce2afdb96c056e4d8b21e5b158374183787bd7e93d6299f069ea4055848159f1f05a2252a0847842f6921a96d818cc4ec70d09fd89e6a9ef6d3a3a599555334a1f9c3b824dfa07f30789be483a60fb92a8f724bf73202c6939b1098a54b30d5012ef42a86890f1b341da3e71169ff7562e3ccfbca9561f24686c5734510cfa40fa79c77b6c7d4177e16a0d848ec269011102155e3f07bf5b2371c91eb720b2c9bbf1e76ec06706b7943fcc4f7ab272503b72adf22042c426594af6de8bdce45fe6a1bf1a00b341979f6b6011915d88df823ce38d2f74e111b7fcd75efee8ceae176c103e882cfa18b00dbdcc1520acfd3357d7d3e6cf9909419c0d7668e7a527cb77eeb21cff2e123a7150d4931de9f1e059e477d5b4283aa6c18587e07c3e7f2eed2cc2aab90dd717a6ed6039432d97a594e30990d8f1859f68bc217ae34a100d3905328a802f244998766e13a7516539d1aa6b8a2db40b988b049b99516ef0222085579c94e00611e074a78c3854de92847a524b58a4749ae190926196a80f3beffb47a8d51287a28f3760b59c3e7a25c8a2d302070957299892c3f4bfcb44ba675a4d1f62b7dbefcd186fef3dd8ed257e22138711022a57453d75bb09c723925aaafe1e69f0b4647d037dd7d654426f7fd8f3f5cbc01572e67d6a05c55afe0329ad6212cf219f361bb94d462e8a25a28655549f6a34ba4e92f256ba4d9351f2d4b248ee7cc279bf39361f663334ece3e8ca556540bfb2e36d583881d6dc9be22021bb000df58f2d6146af3d782bba6a54a0a916de5329b62ecc49ec6a819b4107a8f9fb0d5968a3814822ff55e65150b3d9e4b78c67a3cab2fd25f090afcf5d5770cd697643557133ab715e16fd7029fea5695f6009b01489b3e230c01116c3a2de6987356b4ee9d4719492e8832fa88ca69785fad5e081bb4fb1738cbe4b5b7a9c1076cb6f9a26f7cb155c7dc70b0337b42a85c6bf426c03669cdc9d59cf23ef959b3a1cdfe7e3cb62b35b76f6bdffe38221fc44e08413a7bc3e292fcb04596b0310766cc7b862094b533234bc26e58c03aa2716e126b2ebb1a6ddf74d72e8cf9ba652d345e050abfb67d266b6fe60ff18e18f5f57ac2211379ed4cdf31c47f55b81af7da2cb31ca3d2b132b0bf72399eb6a1e413ff26984bc118afe80c9e8ad05b42c471fefa5753cd1291140115ed2b6bdbf1ec165fcb9074a56797110f253b74dfc6686a4bac0cdaec9e375523fe714f51153b7335a94ff8c98f879ecbd94a96eb2b2e64393fae2a6c52b5e4e7f838069ec52ab769cc7537b0200e59b51543ec1cf03e6bc06d02e1ff07b5d4e3ff85a88c05cd39127985b39c04f7c659f3c17c45523b1e138caa22149a9dbefd481dd47ce9b1b0a56735db2f3fb7b5fcffd2c22d51f6ac6313cd304dcc5a80c6643e5151fceaa3453e8ccc9eec450555694e12afd92eab869d6d08813828b10d7f8ab4ee21aabeb3a136a9f6a571952fbd12de782d7a9a5bd391dce5628aa90ce5704d72a380b9a5fb144b9d2431608f43e01877dfe0a7ef736a700bba85baee28bbeab8b00095274bb3816ad24fe7c8f32c27dfa71346053933e85ea22ddd450a30ad2794600ffd145c6dc9de2d4bee8603eccc4baeb5d238ca3d617ced83c4ae876091abf18901b5a53c99e21d518cef92acc4544de83293cb847a5a85eeb1609b06b7392e142f0d4a7e450199f3c90a5cfc07542ba73e2c28bcabac11775e6743cced18269aa3b7c01587726f22a7e0aa5f9294b075ef33646e4f877b8675532b518174eded49ae84bd33caecfcc627bf2afb8ad73354c43262e9702c756c17d9c23c3049d873b7820d3329c49b70c2cf0fab6438a31c8f2b78c596981133289682b323e065724be0ccdb200c7b98a271f536acdd791c595c43121a9db62a0960cb694f7dce16f8c7c6c1bb486074bd384d07fca06f474681930ea80693a015b62c8d8731b457cf712362d82831f1b672b6ac2d9ed401ff07da8de30680bcd881a5d6a51dd77d0a13258716d421500a7b7236d8104c5b9065e34aa5e46e96a560a80092818b0bf04c6061026f0eebb88ea43610635b6d01c6f7da7f3b1bb42bf6e7b130dcc8d9362efbc03bc5d6865c9dabf5aa14f4ff58328d20993acec7484e91f79c3096eac8695e149e9d9debe450a9c8fe22dc24785ad4681475faf17e2485750fde3676f397bcdcf4a511b422bcd4cad6d10f0ecb9ef22d32583656896528d1bad0de2cf649fbd51c7e8d7681b9e68ad0df4bf4cfd086393e319191734790b557be1f45e04c31fd1aa40b5bb06df5b8e4c9fcecdf47e433aa4e10d0b38b702e7e39413c5a3f7c38ca955773885b49d115e21787131470b25bf1accd3b8aa2f36de16cc4a17e0378909aeeaea3a4fc7e52c0114fef7308dd320c8e6f97a70d43254476d133c25bb62285fb5bb05ed59000767be887955c5630113fe4a64399a23966c7694c54dab6dbfae84f4090e5ce2090ac731ffa5ecd9aaf0e86ecace421ce9e2d4f5067cd30c1448b6e01de6285c09ed9871bcc812c28333c2e38c544abfd36527d66e265e4e77aa2a40576102b56e27b158685b7af2323244b7c152f64707aca723da6e6e114466fb1cad445d8c6970ec0a64713db15321022e5bfebbb16344946d926100b83cc8bc534744dd4177094e2ffa864f4a94a6d20aaf03db6f14e3bc9b2cb82a6a1d3738fce263322d16737129513c7e44e6eeb81e077b060e31b89ad0f586b6604458332769e9ff13681c480f15c6f2269c7e9a2271a97d8ca4f5dce4a5d4701d48571e2a432d5bd0752ac4893d65e3dd39355e642ff2c3ae7b72a347bc5f2ee280762e38a29c63e7641ecb6667c329965dc11091fca0c8e5cf7d7f704c8068762e7ab9c1a977214602da4645f5da0aa0e454135b00a29fa36f5846a6c5e90150e26e5ead5af1d91fe90f8465686f6a674afddaac439c38a6e8d0fefbd82c427e96da5c15bfb860488b51439303ebd5da9c130ded436ee4e4ca6f6365d12ce09d7872dbf1b5dbf2bf217b3f454d31c1683ada014ca6f01a7a04d00a2ae9761839ab980f84bce81b2959ccfa8e7740af77fdb759245f476eeac95305940d7892e641a87054b82de86d970b4f76c1fa4f98638a64b68851195cd809d952b499efa8d666fab7d5559cd5d4a4098900856c261095b850cada28b0e33eda4a0c82c29707ac344247895354ed9216f1c4f252280b3b3bc0f1ac9f45beddf5b05492e4c8bb1b026cb47dbf2404e97ad9b2e399b73aee17db1206058dc37071b0e2a34521125b24bbe75f19f4c91706b820a83410c54f62732078acd90314a8868594a19d3177ae4c22b4987376d8524c4b2931a4c0bf786dd0508755061e4e1a380227eb2df1fc2f4cbd8e6f8c4a297ae239a2d6d89a2816ffd4a47068d9db7cecc61bc5db998dda9253c3956bd57a0da337d1157886ed743c18a942a8c2a3c25ae5bf9f24da7e955586767f9582b3c534be89403a890abde9696ee28a6002190676fefba29c0b8b5a8792cd14036742057325f552366b3d5cfe2302960f51fcf1f529b4822f4861cfe8425e780399578402b828526ea38b9959090bb926ec7964e4161453b993423c84f424b272f2129567cb92f3f0fa051dffe5f80419670ace1e4cc1b43a2d1a2e6c46c066fd30359f7947243b22feaafc8a412a8d9497a130b45ee1ad6b12e5c5a678c8ab2139e961c032781a43da9c44de8e30312c65cb4e23de65fda867456dbcb585a3ffd2d10a71c7363a9f8d39f12adaf959f32638af60add6037296f8c88948bc420ff3def21088867bc53d2498aeafea1eca1cce5dfb68c9bbeaeca57171118462530f02f67e081da896cf7c062ea19c0068f6f747a1cd0f290c1d0d4a73874b71595d150535126517fa4000c16c696e6b407857c95d8ed2bd4369e27e728a6d2e8b226254a6e7231543c47482b9ee2774ae0e0ff77f902235db43bdda3943395965f88c814421888fc54fa66d5cc4c5b7a30f002289c0f4c82e2dcb4a8b0373436abd3661891b9b8f866043e30f3ce423f3f031e702f231725e33fdba4c8d7701e7908d42f3dd0753dee1f14d6f24051439bf80a45905009a7836c8d5ba11e5b19b5109d94d5b182c74f96c058aa2fc0de654f11bf416b8c4c5f9fda7d61fb54119c3633693bdb5c8f93e902cf8ff4ca7488a94ee34a1b2936a2d567266e2f3ebce2462d8e34300ec83ebad927ceaee1389a5ba28aa9aa8dc69c74e2e1d2c1570b88380aae841295ec633857b54e1c2115d8a16ce414a73960f1135813c2164409db4ffe6d2b43beba47f41ebabebafe8f78993d8f205032768e20f3e7020d0cdacd7b3fe8bda06dcac69e089c233ab4e32470e70c249a03106bb3742ab595f7c2d945fc0ca9cb60d6cb8e5bb23f7638035f003e818939ec08f56affd625b52408ba0c362fbb6d24aff25a802d1fa2e2b147c2616efdeee531f38950616dca655733be22240950a68db4b207bb182fcae5dbcb21c7514a26abbcb394f9350e67c315aa7cfac7bb87a833993b0b72c0b75d1e5b58809487e9ad8d4901efe79574985db1b42be2ecbd193d7a54cb2823b962154f1f6bea008f9bde39f8ab7f017ce19012fd003dbc6c22ef8cd26db0419b751e5b23cc559ea4b50df7570a336fa473e8232eb8e8c5214e00c92a4ec182fc55c7d023840449d358c001437f7bceb4ea62643e2932eada897f62724263e9a401217d87d44beb3b8906b47deaf599cca2e642f1a85779520418e95099e25cef8a3904ab395909bf51d111c9537c5bd91132e4a3c962197248f9f8336c1c8db88d7499126c35ea899c0312150ee739603a2ff8868693fb37ac47230f85ee35b32ca8520266fc8c8f40f1f769319cc929322849f746a0e6c10809b0b9650aa1bd6ecc52f3f986b17101aaf66479b4fa648612458b572ead8eb9cdaf0dea74963eaa5b391a3ed41aa8a4e97d39d15f9f8d3d6c2b16d0c9d3b921c2cc82f13d3ac69c0689f7e292e5e0ce449365643da3fe585e683c927b35b21e8e1729128fa97d652aaf1c806ec3db9a3b333b159861c8abb49190483d3a515380713a6d6ca5363b859733d3fb2c0c711b93c399752967e0ab9c6fc4df80bdecb75017073b84056bfd90174d887f593017e23579df5a2d3560ebe9848b6f45cf4f86fcc358d8b877c0252be4780e5709e383de7ef85ba8d8bd93d260a305b557d0ec87173b6ec55cd8ece784c0c3f88ad2079520689413487bad5043e766879ff3bd0ef8560b4651cad90a3c65e86dda5385711dfb31071419fe6f86aaf6c8fcaacccf80bf3c13944965ec5ee3f1b37776cd595437a79cc16490bdb89170d8346433b26a1ef3d5b212e0723dd7c573e2354f7b49eafa1aa265358844ab72b9e608097629a7117dc8c5e632d7ee0a055a00674590e768ef54a4e7950119d0748951850bb0dceca5960be742745a873fb7a168434742e544cd473b55d0b5de10106bf0b3cd196ac1a724ac556e2b4e2d6bed5c47a1aec703d635959ec5582ef2da8129618395509b66467d41d48522f305d19fef1c59109bf9362f35fa8f784aa27f65f1cc31c3d9bc0d5e411ddb46529cb95cec73f90efb395cd8e34115042b098c0b51d659fa53b7954669f318a21676ceaa1069544f38edfc49b011e79632a26bf2d92c4e56a341fb88ccafddc26eda3f85ede6ad301a5318aa7941d21982c67f2e3ff546311f08931c1a1a046ae1030cbf895fb02c5b1324b14fb2e4e1814dea36e1a5fac1826d6e25a25540efbfb25353029bf4a6c31fd44864f02fa0d3894a5dd0d94814c32f14f9a8fef86c2485b2f83d6f16b1d882feee2715eae059070e714c631e1c2ffbfe022c2c54b2b03a0ca4e613fd0b63f629740ee8199cbcbdd02806cbdc3f3568eadf54d9ac439d7b68b19d38c54337b8db1dc046d485588809ab9c0d43070a5fc3f760b9dcab9a930ce6751c8d9bde09970dbbb2292030e271cac2af44c3e953794407f3ca8510099bcb46c43e2bc3a60104cd648c96ea3ea4cc4353f42f9a2ce18bf376daec215a38ee280411ade2fc2920d021e06430055a15a8dbc7d7b8882374c25291347cf98a6c673b9e8280343ec4d225bb54e3495978d3f3f3b5cfa025c6f88f9a5a3bb5c5ff6bf84634e393b983ee505009736c57b4479c7777f514fb57ef2196560138b9c5c82d8de1ec0fefa457426b69396e479805e01fb059996d124d7e17f5e6a44c2a5d183344389687823f8f9c7f4e4c0d42f5f4180334a4e0d481f83866ffa8179e65281bea30f36d92d4327ee681a294d7c516a9cf8d003bd6a7b4326db64240b052c2466e91866dabd5688b3f310fe00cd8039506c0aa1bcfb82a14fff665eb74ce12b0e9749ee628f213d3f5b9cb5e0c908203bf3ef8cfdfee8effbbaec6495d3edf639d3450b83173a4edd9e40076285893a96950f1ea685376525edddc849cadf3babd26e1dc1494f63ee0078937a52f19dea53babad628b24bef761b34845635932f0050de672eb74b60fcbd123f3ee47d4a1fdfdcde2269e07125bb6de8448a3d2fce8948969c49e6bdb1dc5728779bd93f4976a630a760380032e579d9c96518d149f6e1835a2cb16cbf4203073ab20f9f58ce9ff0fe96658899f4bcfaaf430ef36e3973a596639ea17f2f34e42806d7761012ce9cf4b674448ba729591dd42aa1bc45c26722fe323c9e5c69928823381f62352d657a63132820639aa87f043bdb936c3d39fe1eb02f5b45ec23099e2cbb6f1c286e968ffabb19b1e0254efff7da474f5317d1aa6f1704e1d4535e7488d5a45eb06178c6200a6ffad7880908104761c9a5b2f811299fa6141acccef5d2f4914c927ad6078a633da371bc39f665787a82920df6f966d793bc212a86a048459edf4c7d602e831ded88597d38a8d6abba122cd4028d64aa7c1ffba2d0e648b80ab897a9970064c187e577dd1456ac6d9db404899207f8c1ae736611daf1965930913820542115bff753efcd66289f0cc34830083c37b7e7f8c647f4070f6c6f57613f1ca9e98f371c004d4f1d1d9c5426b935887482d429b1f8fa9d2817656ed9ef8a4841c7061aaf70967bed8c79f58505fb18197cdd526c29ecebabd33683dc783766bab47cc777ed196b4a725ca0448e14931436a03f591065df1224fd96b6192783bb1b6cc37568aa49d7b3f8ee7318249af8732c5e1c2081fb66253be35d5fb0fbbeba9c34ced733b4da092124b74ac988f292a518a34410e51922f720dafb73c4d434337e919f58359ea39dfd3687586c7facd9fa7b7a2dfa9c509e25210211128095dfe41814ab7bf42fa6c438f87fcf151c81f2fe4fce4c277e70c828c34fb604b1922c83be5b758f11b0cb7ddc8cfbc57f595c17cb9229be31a1ecb9243f065f6710e23f99b1505a3ffbd3fc42fdde82bad67a5275c40777375befbc612061712f54c283690430be5143478c49141a4e4871168776e5938ed0b6292d28d206b1e711105c0a45b1339eddcf8ded47e14f3d86c895aa8eec9255a2da9597b53a3f480d95b7d7364afe06ac84a88e4adae334c415a7bb4d1178f3491c9a53dbceb6649ef7d181fb9064f0151c96135bdb46c03223fb9b5aa25462d971487f1ffa1d93bcb7a34b9fad260e298b80fbe19e264209b68c530661e7cfd4e5921070dd139220ccc6df01efbc74ee72386bdd67e1232533d096053fbaa317a9cd12ceadccaf7c88efd3693f0d5ce5f557e76b8fe313d40a1360e5f1853128b97f91222cae29b5940d556f8cf625eed49776f4778905e7854f6aff682a3e2ee1ead03b66fdebdbae5dd4475046b78c8a2f52be4d1bacdff4731765e8bbe774b85c412ab6400c6522f28c44d9d8dcfc6ef0474429e76ef277255d355604d21ecfd3681f8b85378dc183bcfc855de1e90160f0c6c7aebe8814fd29d51878095f6a8862df1869ae589fd008a5d603e927c623463640c500d88b67ef4c574fd052ce43a2ede3195d8895407a1e97440a33c3964c612ab7e404a1f0b6d1323a6d7d21d09f5b9ca624003ab4ea103edf62e7498dd88ffb3af962a4128c4b4ce3979bc0d9af0282fcd2f9cff85cad256bb10553bddd8b8047116c8885653496906e4b1ac95560e9d0fb551b983d6f815578104737a9bc90a3489e3b80edb5edeb338aa9a58f3a100e3d4fe174d87b9f734e57bf0fd1f7b6d012d2444de327aed9328fc2d292851f20aabe46a8d6afea36d9fcd3396aecad8029b2b3eb7b67623835d95b983af7b314c4cce6ed373f959f5b3d2c364f17d2b0109bf2fc7e0646d2269787e0b1bf3e68585495968f51da7cb7b10a3b93f15b9b1d896148cae9f51309967da7e4c9442304b8afdf110c3f8aa92f8626b707dce37e58dc594705a0d58d04cca5b471d82f27bf09549901d93c4cb04ec2f51389e8a793929d53ef804bde8054f70198f0c3afee70bd2f9b55f96084f3b3c8c07e7c9c122379f05e1e8c79dc5eb35abb9322bde4f02682ef3b2300d1a5f74cf83a13ef9e521fe211c8eba57531630fd5ff2449b8f9402f48822e16dcca802f62d4a53a154f7e8d1143b33916521ddfc1a38ed7d6a4012bca3e0f47e2d2de508f2299c731818b891de21ecbd51423f5cc4651d155d94b031829aeba0ffb556cb157ae2a08af3aa24416edfe79cc3423fe6ebce7e7d31a6c8f5aa5785dc8ca9231899291f9f05275b66583c8c35fb55fe0fffd292b4907b31e6b656201dd0e7bcb4e29605c2f139de9d30f04ea64fcb3d2e34338dc9d3429a7cdf0da6de5fe156a8ca327f1bb1a7b854301ff3ef98f35b8fd529d4148954a4f18688e40e51f8ca43cbe88925692a7acdfcd3dcc01994c527694a130933822a15c201534f5a1b354b4f7fb42113aa2e2f02583053b8bd7e71b67dae5fbb3ad90a9ab46946c04d9cb47ac44fea25e53492234fdbdc82c68f4a51f8e6c84a88e182360a02838fd9b303770a606730a422dac7c525d3ed324b5877928349eac9b34619cb8281078880ca0ed494986ea1f4f95bdc0f08a986c158e231ff283dd4ead154ad6efe603f3bb5d5b92415a67888b82d6989cba8ae36b9f383aed44c08d5135d8e93fc8da3a53817bd53e5e099a166ddada453a1e47e8ff4179d7ef3de5d864c1c2cafa1903a452ef7f8f854187c5f6f718cfdb4927688bb0b14052534703aaac716fb817df29f135a6a9b5fef07fdf1bf83a96ceaf542ddda7e4f01dc06bcee15e5ac625cd65b7569a86633e3b8c29d7cc29d2efe07ceb8c2b20143ab08f5f3cbdceed063ec01f6b7cdd250562e93ab851707f4a099e59a3ca5de49cc45bd016b154df256b0ee51210b2998dc8d14eacb2b137d8eab430cbad182fa7d48aef24f8dcf831254702f8cd4817127994b9291520886af45bbc32698ca74e35445647b23d7a5d029a1f727cfc5aff057db396fd7db0d399aed30cdcf76fd22b84fea93ac5ff94e7ea6534fe957979a6f5a227c8ab0d8fdadaf5680340771d064cac13f6978b2ba39ef70c2facf055fc675ae5df4df45380c1cf874f3e96ba5ea7816460148600e1faddbc7a6b02c5fcacfe77761f14b6c7271b529158e27878784ed161ee45e1fbc9af79cf6726e3c2e221aa8d1072b13e46b3dd37f2b37aa3ffef277a9111fbaa7e1a39339a51b003aacad723481e2c593ca8df8665a217047a0b42fa2505b523b4594e31ab3569309a5a9fe85b123bdb92a6be35b09d512213bee99fec671533532d73de3bd95dbb8fca981b1636e4e2c5f79ef376a606abba02f519ac47a8793d61d0b431b28c3beb5ff76bdae33d6256e0bbb0a35f5212bc98db95a680530ea06c340b91e30d5d3530b64dfec0c37114ce05e4720aebd47f2e589fc5e8e084a8f725e2522d077b588b0f48ecc5c544196689151890b736e612218fc407c22af75fea4d36a2a7dacf1417a426e89eaa4a5fbc5c206cef00f0aa63d09bbfe769fdc9653b127bd1dc5f5ac9cfb32a7f6c880aa4779dcffe56e9a0cedf0594bbac575cc344b6e1c25c5f233e8f5b55f5c1c4a62f4a8145681669220388cb1af04a4c2e13acc7ab80844c2e6cb5502442d2d3c0ce9b1ccff4ea5dadc26f23285ef8f46f8d5c3bb5438a5069af78882245f6218ea03232d1e5379a217dc3b3ce909d8a74d95ca03467d3a1d5f46eb1eee25614ef9dce28e806507e42f1865ba72c12e852da345e17966b6fd3eb587074979ee84f371969dd380d4ade34fe771e70039fa477ae09abf7c0fa73364b253d4414c4488d7b59ed7898275281659e161aecf0ee24869b2a2c48a224bf39f90b5739f33df7e0418cb1b008efaccda8d5ced1362d458ff7c3beea3724e56ccb98e966c208abed5c5cb4056eec998c7e61a00dba43bdd0482aa923a8a8dd7ebb069103f93b421f31b532ca65de22ebf6cf9878754de3d44d84d331ee0b3448069bbb328df89ce734453bde8acd28a8f40554a31ab21ecfc8294f22c857f5b20228febc1840637ae27ae7ae3d6eca080962f2072755a52aa3cbaadebb8186f4140f46621a51209c8384d1f9c14d52d26e705ff744bda190cbe6fe0a7509fb3356e3b729c0c5255daaeb278913673edce05f5a868d95ae3aa4cb48f4b9da5bc540e163876ddda6b03c62266c0ccff50125b44acd77f9a59ccc9a1f2cc8a2f57c11726118c473ff97ffae1674ca6f52ba3ae7f5646221b63b48d74b502a61e7f9c30db930946df3ce912c9c21473131239f194fb7cd13e157c8f598d3e5ec54ce0cb5a28bde478a4fb7403232c527c5b0cb5b9b81c595c96fcf286a00f9bcbc09ee873ca1cc7cd155c8b1b8a59028cceb0ee33eb1ebb91e04ceab8c3329831477a2de287e5869876f539edc30fc6f9bbd3f9bd894debfab2b231421ffaa71db6973eb05434975941bf57caf4fea08de6e508169886dc14a3a7e333782d81c6da4e269cd5a1ddf5bd4d35f8241fc6ad1f272ffbdfd31fe30897bd91128d48b4e6a3fa889f18aa58065d2a4a963a5805f3f38d3b7a682360307e21081b4586b57ef085ab954968b598a4c7482009f5d9b00fc3c1ba20da300a5a7f3b0d59c221b5261aff092505d3fe9c81553dd76933a412d706daf1deaf6d3acd51af5367bc267e0c0b0029d3b4d0defc42208c981e29fc974340000bd8b94a54fc0e7159c63571c8b8325e257766e5c61f580f35dc80d41b85ba3084948ea8f51714ca178f6c406d564196587592d7a9391b36e2db02f1b62f58f8ad72dfca25f54f382ea5c33881a4c06654cc4e34e319f61495aa4779b0fa35dd219ed79374cbbfc899dc4d7f651eefd1c7cb6eb4001793867807f61964ef21d16b8a2049d61d0c52854c1ec800c8db299245c6cfae124cb47d2ac42d66c384160a55059cf6fc2be25c4307d1f6e6d22f6bd1229229e96d861c6b54053c2596d82a46729c6c6c2d4f821a63945ee63905d756ad24c048ffcec6de89e78c596e99254b0527a27db3c059a9812bc20f7d8502d1a61021d09ca063478ece47b36f1af5565a3c4e1a53a754493df9fc1f8bdb1ca5b2aeb8538ac74bbdbaea8c5c75df599a933185c10a5e5bf1f4a516abe97faf3285fc345a43036219aa354f60fd346e28b46569032144116413966a9a34cc6b173a8d96e555890cebc35a34b731f018ac264e4d81ae4f9836e29e25a125852b0d4cd03c7e100153584ffc50abf6606d58e6bbcdd8003b9155785b518003e1bd64ff85f96c54efe7b15b4f09683a1cf6fac3e717ac308e429231c78f9f65ede50dd15ce95e27041ca1ddc49c25bd63941d87cdd6aae9d6266aaf5b2107826f0e711c869d099edf616f9dddd21cd2e5badf65511c045dc0d2bb8a8a8a6a0189587936ea6f4330763d7b977e1ce6855400955f141e6db051e457b800a3ab3e865600bd16b5160a13c5ba4c0d06d7793e81204156d8b412ff79be415a734a61002c21029c39101ecf20af4871c0f43bbc284c327ab65183e85ee30f9547cbf6ac83cb7552f319f700bc0e0f1786c3f741f28c55575d9522bb7fed8b48ee17b2219714c580e121527225f0e4c34bcc40f33096a043c8fd1bdfc85d40ac79def9031ad4d7c2c1d6930efe23e8f4b2fd2dd30ac85501def96ff83f0e53636a6f541fd7f3d4ee3ce3852f06dbe6cfd61737217c4f4bb3ff7d7f9afc9c6fda4562ac2b0e90d64058c32f8ca5416d17c3573d4a19d352a9bb913c9f3001017e337f52ecf167f5f9e3b13223bdaa8482142b33e72de2079c0d266d560063feaa6134ed4e4a3917b3b79a25b77ac97bb59538c79e78482e77d8047a98340bf4068b20bcee95ed707dc5d1963de36989a51b65e0fc4d2450d768466553a1caecaae7616ad15e4ab9817a3ce8a2bdc0ad0af1aa46ac5cd644eba592cb01b3695b4ab374a8163115f9a41765b1fad7229d66b8b38e883ac3a213d2866237710356eaa0370bdd7e217d8c9449e35c6f23421202cca2f1ffcd4e2eba40770b28b678cdc17f7ebaf4955ad00b7504ce30ed1b17ed8e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
