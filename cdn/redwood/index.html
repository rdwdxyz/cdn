<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"862e6a7c3af69a6763df6805c333126ae479a1b2b964e4ac5f7294476ae932eb18ecbca5de152ac575f636b2fef52278611b80022ad1642831e9fd3ffe7d08450cdc47d118a29d39338fcd304d890797e409330a4db76157ecab30a5cefdc07c49ad32015115337fdeb0e05dbbbab48e4c8b15877b329c80d0a028e35276dfeee19e48189a4d2c617ea6c0e89850652811e29d861d04737b2af697ea8b92ad37cc0145f333be31c2a77e49109fdbd056d8864336cffca98e4e9a2f13419f24235193cc4115a106d030332bef7a014cf6a39e34b8fef23108b98d2ed0c65d339a48080046e8b607a554d41b6db5af7c836c457e79dcd342dfe1cf8bd9d50bca913694cf4f86d1c2c61fb778264e86fdca01255f550f8ddf05e77859403ede2cce7cd0d43d99a0a76a105b6c4a202897dd548041f808dcca062092736f03dd6ea63323869024526e714a81ba889fd63ba48ec6d375664bdd578deefb6370414fab0fe8d337d84ea239abe5b5c4ef5bd9cb372b14e24444472a470c3d44902f791f9fee9bebe1258df1479a93ca55d670b5825c8018f70f6a21f236b752a3408d4c280359444d371a3f69d9b4ab139eb707a025fa843eeb16bced5a907e90f632b4785bf20ca2eb1fb479f79db7d1ede36af99efb8f19a8603140547f17fb4d1df113b275ed104d1b25e793b28d8e99169054a88eac3420af9c5078732288661d9f26f449725823f9f647c56cdb38234f49172eb5cdc255462fe27076107f919f4d9bec25e70ff36c1da762a46c512061050f7a2113e63f32d4682b25ce7c8a2a84147b1577bb65ebb6811443f1a2fd92a37adceb83d4a95b63a3ba156d78fd30d066957eb1d80e211aafca3732adf23d216f73a85e3d37fefa94feb970cfbe1a3fa8f3d86a53c21ad103102e900baccf9e53394e65c19f5a0683bb995546442a3c10190e1f70814181c7e464e517746d657728877a18d8768598452bff988968786462e8754174b45370188579a5f427784c3a0df495db563b17dc180be12ffd73a36b4df464e7bf81e6322dd31db9a4d07e2948836ceeb49e91a7adc32c106b53de6dbc0dc6ec20e864d9257988866926193665514b2887dab6fc07fe9148a30038de8450ad067146c4296ba26f375ce711c3d7bba65a6aedb0255eae4b154eed6af9a6977c714d25d17b7cf7df2d1b3ccc1697120bdd3556d62da82f044c883cc36acc6f157adfa823e0379b18252c57b462db596941d2e630c38fa11ab8c7115675c480469743dcb9afdfdb2fbcd50ebcc1c15afa45e5be95f0f1c9dcbe5449bd75694485215e2898e3dd8b549d1f274a9154800187d77832c2eecddf17b272a5ffde899caf8fdc03d7532e65492dd6bc997a55bfb2cc26b3892599687cba7435561ca7ffb6b18a76fea3f00518575b7e83e486d5c71eb9ef10c06da53c3b9bfe528ff239467c5cf70b379c186068f3ed4a2ce70ff4c84e71b6daacd8a5db2653e369dbf65bef57ae5e1353259b9548b5bb6925ebd611f26ddbfb33bd64b665f6a04c50e41979d9510e59248839c06317ef9b18e678148868a9ecd9edd02fc892032430fa4e0938674a7b9fdacec992e7428e4ba80710e66f791d65cd85acafceb4e32640c46d5f5918417ead9d21d69d482a22ec049e3926376f67388adc6ff3bd569c37df9d97d7f46120143135bc469e9dfd1689d45bed6ba9d849004218124aa2cc112972f670899455475572948fcaf775c1e67bd6e8f1c5f764ffacf3b665c542a2c4970b8757223540f14ee6fe1eb80bc19e05786542a812d1e2841e5447203290df1402e6e2925d7da9577cad296da29ba0fdb4b733e647aa217e5cb83aca71548c0f39167624b04f77a227b4c58ddcca57dac74339659d544f06091a16aa08184695ad84050876a1d0e0005a8e812abaff06e27c396f12a33f9c3d34636341d9342f7b7f80efa87eef5d665ab4b51aa28d679949abe8d195d3317e4fd1218cfcf99be43e4059fb725788a6c42869d6d0c7eabcb931df31f791280304a8fe22764034c7147dae2b86c47096f1f7a995a118660e6e9a06a017ff51f241ca47e85cacfa693374927739d747b0c6b38a390dc90a92126b93d7d0168d52800c2394c81c5a8cfadd9ea524482f5782f405e99a7dc7ba61235cad9d9dcd3e880eeb55bf1a998c4ac7b330968c2201a7978f84acbab24e7168e5bbba37680db409117994cbf1a2f59605b38e078c3c9c6ecf36f078e14e92a6e21bc58603707b441f267940ccd72d0ea622987bf514b4851ba4ae16b771c10cbb78f7f346cefb358a788dc949d178077bffe2124f14a28335a90df4611c9631898ee8c7107faa5d8c6a690eb354d30f10b96432b0ec1bab8d7b7654911a998767c8c7761d25ec9b0157244482af159bb6c7e5a9cf6fa8e63b3666bebcd42ad285cf0d10332844a2b573bf3b90740a9f8a8002cadcee41b436baf3246a2cee7cba6ad2abd33424e685b29a3ede55596ee77caebe8561cfda9e234e0b659b719b822d29be2c32ffc23506263dbb23153a5efefc599e7de7f5d91789b8b67d69dff8b2f4d8a76b1f9e1a05398ad796756847b5061c3b1fbf9b1bda0bcf477c812508b59a19d2f38c8a407a614c2511de62d8ff2573149e38f3b7f564bfbf9ed5197192c302fc452af6b4ec95d6bb86f371bbaf00db991735f91f17f7e3c234f93df838c77502c0965db0fa099e87350efa99790c899173821476da206b8d5027de8468a86dc5223002600b9fdef0e37ae4cb0b770f3c5b1ac552d6b643900c6ffae19934e4ea429eba2b2d47a4a6c0cc778c8bd8e92478ef88adbceab8271928b0fb71dac34248815537c6737b7255c06f5bbba3ab95c0d9a9ec63b15c99ccd6377b68a1bdc76bab53eb3cc4f91700c847f190efbedf9f9266e4286992add2ccfa358956e0f22542746af00e91d91a20f1abd1b7eeeafafe7e16ff83d267a1d013b9751d9c4a71c1c1044265577d7d0394ffef26704fa1d54c8529bef95a693412d57c3bf1e7ed53b8640af3cc35a72ca6f2d983fb389ed49899a360ca9e388dd34f018ecdc7544a4d36d78dc04ed74cf9d0b8688fffdfa2e3a13fe8e1bed97f58c637de89889e20c2189944ac06b409714c2938dcec5683c63c3d7def6ef32179dd43bc4b0079839a371505f74467a1dd3663638ec6324354c435d8c34fd062c6557c44a7b2b32497c3c08740dbbe6d21310b7b5ad46f3b352ad47211b694c8a677946dadc2cd64f7fbe15b58011f3df85f20670bef350d6a9083530d3dc4b26e5b7b8ce5d4602a6c49fcea6c7e1f0456a033f0cd89f171cb11e1868b46003972a2606621a552db1760981666d8345b7f71f48c357cbede1450785b1a75b8a064d31b539d5a16aaf6725b7f91cca35a2cee9717b1ac948f174c28547928af30054e55f7377396648c0a57df489dfe53bb85739c58fe50785c95e524defb76292472c1f7cd3259d03666adb652827d924a8a50b6bc2b2bfd27a9a38d0e0a38059a226123064990455f215419cff3109b87b3337a1e3f306638304661b40eb5e5fb8c19b8253a06a704bb45d7bd905225d29ca5e4b09c0198445c5a573a016c9ab52a12f9ce66986c93c30bf5c5cfd442cfc9ca4e42594e573e61e4f665e72ecaacb0546bb1279820c64555bdd9ea8d1713b625f6fb7104dcfb4d49fbb38a3172c96451f4e90b075703201aeefadad56e13412d58cf79e88427c1aa96e42e1e94d75ac8f9d3782f1ea31a40623d1e888dffada8e6984c1a07893584357cdecacf7ab767d8f043dc5b85cbff34fb1551ec4181c055e7811a5029c0782aef5c4c400884b3f67491094e5435751b051f730b899ba620f9877c5bb64dc8b6b7969dafa76956ae1a53360277445ee1c893e54c293546166e9492d0e86680065431396153bf6fa096412bfd5f4a082d176567bffd6d7b6c0350a4120ec13dcefbba7f478e5e0e89f7f09d6878b13bc4778cdc51a36aadaf5966453d911669e0b2b8226a5d93de7f4d916d037328c6bc5a9fc02aa6d6bf73a3b2e49f2a1fa64fb9e8eb6264643b3a4a15f099f4245227b342f3e36bf6edca1c95931097bf1226a7760af5eadc8595511b7f51b01df7257f94644c443cf0de197130892fc54231b668982c6ebbec3ee326aaaf3cd6cc94a144f8959b4d75561d827c1620c6eee1cee3e4df8a9a9c9b890cbeac8afacce47f745a82e39a1c802d0397569878b12d4803178bd8b46806739f03d518d42df98c99d03faa69ab57cd4a97756422e6786a0eeb4f0165416355d49d67e232eba8b0c41dd2d5115c9f7e89278de8b2a49610e7e914545ea70e75b73d729e320cc6a992afa579bae0cb69db39226d7d7dc44844d1df1bd1978c102900bbe06a1a58ee847c16339dc450c2dcd3dc89ce588341314386f767f285790ba73cf1eeaab3174a73663f14e8533aa9334e6362f5b998138554c41ee52d30dcb56682a6e73bb01f5e3d0540f3cc8474e8c897b230f8b29aa6bbd297a3ccad726c3e482ab0fb1004fa08a4d45d5a7b4a8f437881e065fedf8ffc236ddf197b94c4a4c50c959ad42a386a2364f1c60556bc5d794487ca41290f5269311acf19206f5ffb8b388064bec3842c18ba4237eda8a9b1c0a4ad72163b7fc624fdb29eeb6f90645e6fbb51c4097afd9f9578f473ce768447fe1de8f5ae6385f6720c686e674c319ca56f0ed62e778aad29fb6700daf6ddccd4efd4ec89cfc59b72c120c3d108b5c2860956f876d491da4ed5972d99a6e1ebcd3e008b211d2ab433dd82d7423ad420f826170cce7e94282db1354d9eb2fc775e2525854b5218485242600d42e83fa836153a73d201a8ea046d16479d59e8df429ad3197c2228f0ba9b0f74b3afe65d369d5bdd290f01c41ec50d0fc55f0892b201b9676594133c862cd5bf2810fb993da1c1b81e89832c780f4ec1a1078b7823faa130c5b5c98869f52b9de2bca78872e66155a9ca1dc96a63995ecc6f438cba6aa07862003eb0bd341c3c19cdf45813ea421925b94b3cd90ee8775a546286cea4d492833f3f2511c23e33009c48375b55e960289c7b1285baddea70927ddb2d8f0e462f720efec6a28f4a3686ff5743645fe5a545479ce9d38f3e4139835e58c027a5426fec6c030432e68fe656db091bf0fa978a603357d89d975aa5f5b4018758223502c45bc387fe757c882cfda7aac8a7704ecff593ec8ceb33703862ecb49384d615c573f2e8f20e093baf4804e9f0e277b747ee760c801d67fb873799358069c7495ef5c3dd478e026a3c7e0413caf893c53368e8518fbde9643eb7856d69f4be66f75c43eb5006f8014ebab696d63510bb2eaedf9b9d927fd35bcad3c5158cc26ed72be6e779712b3a1d6a4b3c2e0487431c9fb4694d1c2fdd0da30a7ea72ddc8686a22ea2be8956510e801a1093e08efa5c6d1b9a6738b17ebae133c18051b539adf77a9e1ddf6dfd66b2d3f4e9ec41a223a57af217e2be6ea7cc7af2e84627a02f346de6631d27517391b726412e17d5ad5426148684c1fa6a472943cb74daa589f176f38ab54a740dd96b310d3689cbd56ad2c94d35a316bb844f2f8f664dabf86f52f545d30d0143c1071755c938166b0d71f3f3b701b6dc47e23f806c11a64610567e79464ce5cb5b51b76e0af1f5e2628ed8c403e6831ca5413bb3945c3b89e92c36ee648be731526dd37b8a79f4410f656e722dfd5ce002dc7431048e6339be28545623697bc85e6885ec2c327169f404a245f49e947fafc5d817593321571847e04fbd381fb27fad7d61056bc75692c3464b383b91796d55d10d2347af79425fcd7c58fbf6724bf3371537b6abd808f77f812cb2206f0c35134e9cfecfd1653eba1375a0a87d6936d164dd561a7d2d9930f133f3a649a5d5d715069d6f058440d39c112298f35f51150319d0d3b4682887392028de52f341c5e84c708b974012918ad9ef7629182e0bc0c642944acc84798139cb1243ac845f3ae54f490827d7a1d2066401fd6e69e8ff3ef8291857d02e924c7f42d0e81634f287b95bccc10e6acd9724fb16347e53480b7473c3998566efac392f1c160ec2c89fbe2fa1b19d7dd452b3245c38857e059644d72bd9ec2c7d7bf73297e3a152b358caa4d97bcd5cb7ecb55b6f782ed5c85e616b0a95d2330b75af7d929b0ced7c3776f2484123a2f8d05936e3cfece18049f523a33320a345ce4e2fe04d22d85e70f3a30a22c71606a2d0360c213887ed21bbee24db17f0026664523d0c245357b7ef1b618a22e915988d6e563d701de4917e1b12aa7d0b63dcaf217520b17d780bb21221968216ed92c16388dfee95a4826ab94b28ea87e546b376a9947b527fe7ba1dcb2569e51bbd0ac485104f78358a7473b0b99112fc7cbdd6880bad11764df09d48a8890f19892f372481a2c7ecc45cc23c3eb9e809cf3e2dd616e8d09021240d11a62018a5249953f10ca3671572d224e77edb7a029d80ff373815c24b7c8f8c996fd9a9af70a99adbe130aa0e56695484ca7ea2465331bb7fafac240a44311f486d819e1d6ca7152cf85de26fe3380e189303891473d2575d087997afbe2a0aa6b35dd74cea90d696090056f1a5658533b90b8fadca6001133a26545056945356bd96921db809a2dcd5da7b9abd7e9747d16b282607a276b098f8c8eda8a8e219f48193f662555107e2976702855503591b70a59f6420807485592971e9a6944366c26cabee77091ac6de185a03ac369e631b4eae8898a7be3e324d3d186fd508e90dfac0d77364ea9d91a0bbc5084154873ef9bcc92ffba2f43c9e134c5a7ce984379de9a4309de7ba14b2b4bbef1966ee0f3f80ad63ee5e4e8aaa4ac8b3e8da7918814d642292b6102da6786c1c35a6f6f5492978fac64e70baa42390237cae155a735f00e5ef89e1f523f9a60a8103dfe6ad5de753b85330b760e618bb4a9348f32d89ad50015a0b3e1e1ae89c68b6284c15953274e980ea4e18c97bbdb4679784aa565d638ccf908bde574b1ea38c4aea306769ccebfffe06bc898149b3d31de31390e65b7c00d2e2ab459651891c8b5889d1bd05eba011e8963bb642cbb6b5c56e0ac034c3a37167161b626f3736385f10e2b6cbd4f75b3250f16415e5d4cd65cb9a50664b188d94b41c17731332a3fb953ec30b40c628530a8f51ff47ad6dc5254f03f9a5d9ff471869a81b24b8a8edc6e8fcfd1fd9fd9660f16d7be238d54ab0d3dd39f0b3199d52622f86f8aa09f72ea58280dc1cdcc755b9f710e252efd8bc7fb53bc542e085e1512d4a8a701017d460fdca0cb1adb007e9a7c84570bca2b50aea129674ab164b8ac3044e1cd8deab468b0271ffdfa33b946644200c08e72b4798a6ca5f5d79a3b3e4173b4248edbb06b12084dc2df85567771c5b517a85e711a518b844b9ae1fdbc1a9d0403af3da9107ebd3bfc48e5aab8ee3e782af786a38f7e9a9aed4d6230706546313a0963a71a86cee930912c84b68acc7f1e1e12eac3dcd5f53618a2a568fe0ae43072ca5b15f64a9e7f8681350e0b09fa112e0951cace5d5902f12958f0d1aced64ef1dfb09c72a96a3b38457a6fe16a9ba150c7dfc5ce3d17842cc76a19f251e30fa7fc32b04d95a8d20e9404734edb59cf9c22882cdc6d42ec42dc4624753f594065f029dcbc6aed2cfb8578a1a9d64303d655de19633de669e270d79212049afb8702c864d062f736ef40068ebdd66a2b076910289241f2f13bb64bf759ef3859184950103e3175ddc17e4993f6b91222b96b2849c32d975c6d3452ccaa38229afcd65f302d52485f97f43bbdec85cfd9532080791672e5dc40306e554ce6a7e563a9d1dd12211cb5c267efe79bc31d65202bf2fd867a5183daa80331b29d25bd8c85de95786b7cd971f61bbee1a506226b7d08f2b86f5183a18d141dcfa6a32afdd75148bd915b395b3551472665a2244f0c66fca4a2f3e14b9f450469ce06be86e68eb822d79287a7e9beddf4bc1629061e78d84b50309020dc09073f53b250d7801816688e31d6d7d1c128cd2245aa315909ca2a073e0faf223c1298523b6fbc76d90b819bd60b660fc92b1f722c4e86581fa8cfafef80ba4da81b8f9dc818a050adbd1e10c6c08ebf3b3fb7a5db743804f4f7cd4ae416fcfd8efa76367357739cd50278cc197f7881ce4b4efc130869ba2497cab537bc9603c4fb687ef48ba4e39ef46eb7399f6ca865503d4668e93672f80c5c409f33dd86ff9a988366623fd0baea2ea5b33f92018d5ce3d5c72235d9b375a1b551f0b15c3203951bac0949d73109194da3c87aa03466b46d69859177f273921a59863b1f3a7c43a5d2d6db56032c127351a89f58dca6cf743241dfc26cf04dbcb9ecda2a845b027e741a24364a113ad238994f343819ff5d1e8ee821c5c687ba12d1cc61f56ede0b983b5b422d04f2c394adab74816a0b5fb6f4076a170946657d41b412717452601cde3f66d263b6f0e707e4871dcdb6d01c6b5f9640517a9560946c6e1539362def9188405ede4e25e382faef2360db1da437a3a6106baa60d76e6c8087164a9ce5428748a32fe044f3752e0695511e02ba83e30b7f71915000c4a767e35debf6d3576e6c681a47e479a4509a94ac8dbe810b719849badcb0804f3d11a33af53a91abe05cdc7772acbb42b88df67274bc64eabaf355df7a6a5e23ad512bba36b706055edc46905734dd715000414b4049ff2f4d08ce7cebc021c64f9bff952c98bcfea55c75ddd5a16c3e2ffeef03af507acf58615f259dd547fdae0b4e4ea992e39266984c6e95d18c5a64be73cb0a5e1f0d157162a219527ca89d5a487a72884388f7114162281c7b60a4daf776a607cbce5fce88ec160bbe161dee2bdd45aee864a854fe2a4de8cf308d466b51b4271d16a63a3da14f9ad9dbd9f4e26c0da766eff48dc99985bb67248ee93e9c54ceeca68a07d55f28bd6d3ce2488556c5b7873ceb2d36f211d730e70b75921da0987037cb729392bbfd6cd305594514c7fe4e6fb6c4318c4219e3d3f129d4108cb67faa76745e8d4d6ad7b63b378e9724d2f20f60cc67074be8e25802268634e043a9a8bb3c122abf6ce314179987c6b853c1965560e97c3ec29a9a17f7cc367fd3ec802e50126d3a5c0903b7b1f37065c8864a9d6ba39b5c96747a491184c227e531b95ed18f74fd7f4411db5500925aaaa8b79dc26128e42beb81556677ed42992e83b326c42c2c959cd1d8d0c33634b9f4a78f8c09e8cdb59079a97a9fff48c784f80dfd2b57be22d6d29c3dc869c1be078c9ba56e2d841b90caad1473c7aef31259356375d91d6e2a3b7bd1dc5d49f5b3d25e65e0b06d2a67ece5ad981e84b483c85d0a44596fc5b186cedde7b0757bec2ead40c80d1ee0cd0dcad58a573083d4c2193eb5a8830feb5619f4f35f85fa55eb482a7293b01386997a7f2c154353c0798ff6369529dbdbcb4544415324458131ee3dea3808b4370368b55dbc3296391c0a3b06d7865dc65ff83bd85dcd468c3b27e675b2dcc8336584edac8ea2fa6fc7faa156062a65133d17a3c55e6a247529df49e9e5aac7f414a35083cacae63f3d16335c704c3f061b33d756f4305acb03d12d3032d725c0f047ba8baedb968dd1c994a9921f9da9da828df577083bb8ca214d43bdb4548181cf7277333ec84600495809ac9adade95e284528887e95111ce82f0357592280b91803c8b9c65d3b25faef9b61460132635caaa3f05e666c442c5ac593b38740bf930e7c5848a36c66cffa36726d1039f3761e6c51c2ffaf2c0fca4bb58f1cc22162c4fc294f49f053674c39c55da179a24bcd2205c81708ee5fbbd18438b6e6fba6876ce2b4778b803d7e16023f4c25bf7e770660d6d62122b6d76617bef2fa3f2fb971ddbd72495e9106f1490f93672aff0709c5c664172f949643b1df814ff20faefb73b7d3ee6ad15e3bca8ec77edd0240e1d543d5916093bf1bd0f5289bc84d98eff68f418aebe88729f77e14846b0a2320b2b40847a91517b144f36e1be5ba952f232e9855a941e8e8528f13dd04ea9a502859762449898e4788f723f3aeba3dfda7683fb3204899feb71673c7c5c1853a98b67af7e6df23fe1472bc12c5de46bea31db2177e6fa5148433a8c1fdc0ed008c1550c17f298dc452312f7ffb2af7e074a5001b2873b7847b03acf126c3a59f13cfaac4f19c325efb4425e281fbab190d5609c899a4fa730b24b2dff60aa7f6e9934bbd179e16dbbbdd02da51d17b921b2ee58db9acbe8df03e17837eb881bceb553b1765134018a7af3e678a0e575ce2c8bd886225bedd8f5223ee71bd9d91a82bfdd8776c87785434df7cda03934a895b160f651c16f484778681b2b9f11cf2a53c0d710e6bb93a9c9f1fc176510a112143cd93062c862d2d5e62d205812f42b5d2b43b9d7accaecfbae83bd2fae5df4b00bad6d486facf3b62e37b445dd5ecb9b0c616e10435378e58a4a722bb4fb7beb6c26f4a2beb86e32f6103111e9edbcccd86c4d9751dc6cb056ab7813918a11994173503c74caa7ec2c0c8865e2051e13b0097ed58c4336651abef78e28eae0e5b41f25c9bcdf27ee640e380d78b8f117ced30ddca0e8b1895fc4ff0d7fd27102658edea64bf25d46936821b5a24cbb4db4ff6e1b9200ee0f973a62eeedd4922f3c1464afe67112c6935db28725c56cdc7d53782999fcd9e9e4c4eb42ac8abd47abfbffda4121afd234afe2a92df3cf2fd85655230c6baa34fb3b93c4a7e85c7dce6edf4b9c68bf20faa7de824af57379a78ff259cb6b371fbcd6ddd89edba1252f7c592089536cf48f664ddd74748ccd02f61b53e5d6098c02377b4dac2f0188a402f4e31ed9193c3cbb69593aeaace62b023a5925f359457390b885c89b0f4198b41ab6081eace1671de67452493db28fd1c9b78491b642bfd4b54849d006fb75bf19f0372bd12fc961f9a911b4c4070c5dedea975741d42d56c2b04187b272d09039f1bc12b03ac4a5cbb6204e79a3f9cfbadfd5648049972e5df379de07439bc46a27611f8d939e3cced6ae9ecf4f3fa603599e5d2fa51917042e9ef831700600e799dea6a8d84540092b5b530fed9fcfef999480c82641ddc4a5a11cdfa710ece4c7da3651a4fe365445ae4545276f8b5c55a8247440ab4702a5d474b34e19cb564e90614fed60d5932a7c70c5af9ddf47692ccd6652efc848d75f4b548694e4ce4bbd89f43fd6559a9ddecdb41cd89c8d69e011eb0287312a4286a4367ccad4e70e94c69cd225cb74cc29475b9c121d9dc419a726dcce42da57afe1d38d59b0f08d7702507b67f0271ad94348441d719f74e12a6d493601945e39b26ca9cf85f035f04e56d5a373a06da537157d5b39702830464658fa2b20c7ec028095a4c46971371bfc399d1ffe1e8c0405bc961b92adeb5865ae9b4b25786d1e1af325642c861e178fd46d5e7ef05907c9e61ccbe14a14cdc317816a1c55e511dbee5747e03b82a590e088c779cc1ae4560a1560e4919c035daa12e3352ed74b1848d96c8fb9ceef5a14871200a5fc701eede2f8c6b2031007c7789ba4cc2ff5f073fffa5131b4e0fa791ab72b6e88cc19f11f8a3592ddb112c86bf50f472205bbd916a02f540cb74609e41583cf38c36f6223f907b4ecc1e2ac99201835d097dd4d837c21ef1ee56c31e685a5119a4de6a238de7bf3466ef4c33642fa87f4a6ec601fd5f615b313650af186a7fb35b96aa09507ff76fb4d44ccbaf9192d4b1a59a3ba1b611525d78ec8ea42dd94b25d4de8e7b7eaabef49d9f12fc274dea8711a01f3d39fed37d0048e6928643bd72563e854aa82f008cb9a220fe4505937f05aa2c730a1cb46bf0cb8c5ecb88899023b2b789744f9c4e480b47ebdce74f0fd743ca351a70906dcc7d1d1c26a2a95ba40a7753a3cbefbe7fb8c2aadb446f7b697ba8ece45b966073bdc8d98734e93a9c9b49225048c1a5666b71892370125ca1ac6c8380f32abdc6be1724a32b7bd61c0e22e4b171b7a48fb154cd83e35d5341963f568eb9eb3600bdd36bee9bef750ce568c9f860016877cd205d0627c709b89923a0c63fd469b72c5bc4b3029165cf1900517a6d87588ac85c2c25fbbfce6ec4633c819f9b950ba56ae0178789f3532d9ec429a5e99820019d3fa84fc649b319546b41c4086277509c3351f4beb41ec3eda37d25288c2ab89f3c262afd7ac2d541784e84f1985bd6df68f09157c1c7937833ec4fb6a06aca5dbfb59fad5ed1388d5474fca06cfb3e1f92da7e0c473928862bbd8669361658bef69312a659a67978114e8d9447fe9e84e59b4caa455f8e27be569fc790816e04dd04037d1fe5cf791f066d9afe1a74895989b4c59cf4818ca770cbd20af403a81d890589fd6345816dc37d12ffc02b8b5cfc29a0b687d95262210580982a7f4fa83c81d9d47f8197455e7c227837b58ab01b6fc459ac0f0a1953ede44f8dd151e4656f8343824c4eb287699fe748ad1d8282b88a9df540915e8e41244cc19fdc9763f919dac101d4bfcfe7cfef31b333b2d665a43a54a759be6704958c0d4dd7f3805f97bb34de573accb4fea16596a79b6d16dda9e5d672321e8b871e7c7888822020aeadb217655c532f81023a958af7d5d5673f992f3b3c23327ab6a042fae67919ff9193cb2ce818a992562525f140b60c04284eb9044b1a63f7f46217dacfb62b498981b5ae771cf0b4274fa5f1494050fefaa37dd936325aa874a14ea92d5a844de3c2041e95f73012115c8deae06e19612d1bff09fb57d72b60a14a17400a0f197cdef1befbd4991834a1f1d463c1867aee95fcdf5682f0740428b36bb0aca31f8b2296b56a3ed1a4e598566f503ffdd4ac8ca25734feae60927f388dd6cd4d1c4e662c9c2529796405bb038ab00b475cb37ba372e13854f21d8942a7813aefcd5c277a2ac3bc8e4fd3c7ad33011050614560f9418b63b219e8c19fe1b6a076b4579b2fba5323eca7d1e2567d5813cdb12c45c9e94732b25ea395e95d25b612316dd7734c411cf7cf5fcf26e8b388d7788055908aaade7da84958fa68a671a4b195662a96909459bda505ddef3ba6156b818b8888c7f5c8ab2ac59e7fd15f6eaa8125092c3745e9cd51bcd7771c79c6ff97c1dd06db510eb8394b3070cd9825165700c3447ad56a00d83e00c58a2ca4ff788505e2ffc36de47600db582551209dcadb58a020d1ce75b174c1c3381bb6feb7ebaf98f4b74e279276163597c1838d4a5407ef955bf24c4d7f7d64c296cc8db05b1bdde618b89336d0abafc995e656f6ba2b6f6eef414bba4ac7241add60a16c219884df8ff9331235c9ea46422b95391cbf28eb911e72fece27f6840edaf21f8c54daac7df1dc4b71a20712aa97b3b0046d6e419150f6d0254d048e06dca1da9a557f71069713ec8a94d008ce4866c7524ff4f9009ebb75d1f37d23e5be409ff23c77d91f4ea83dc97fcb1c94ed351c59959cb8b5b49e583af5c3850d1108fb36f68b394cab8e35a65a68cfa80d2d4d8537b6cc9f3b97103bae0c55e481ec223a159be7c8ea7d17f91030ac88ed4dae9d1a3d5e912570510a494f9a8c1f7c2ca9c6b924fcee6342ae7d451dd95430f3f54cb2b1fc72ebcfccaf0c7fb1550c4d3ee7904e38bef27c69ce2f165a5f9cdcc2fb8570c91bf583414782e7f8f7a62acc94d0f6ce185ee2c6ee6c1b98d86ce3a1fc878d68d8f51ea2b1f6eecde300c49987f205cdc3dcbfa0271a8bb68e52a8924725a50aef0f3b9bf7d3ac183722d1325b373a79d8083f0209c16ccb5e1c1fd690ce456360bf6859bc627ab95bfe710d6274bc2e54de6f63d4e18c3e7be1f768a7aef6b91b8ded784813a80462319d962a4beec9743d2791d194b3cf323ce9b68cfcb3de4a56990b91d438f0297a3e7ec556c6e75e107f1456fa37dcb20b65d562056b3b7a2c228617312831ce4dbddf621b4e8b2ec78ac07fe48c4467fbe8bb550a54858e76db67fe15141401973e098577f80a05e0c4226d75810f10bcb400fcb8bec0f3a49923430f9c171150acf636d146cad529b106b68b60469d3d6517962e7e46247a180e06aeb1d0877a9b8210a5367a95fbe8505f9b8a409a087a422a09e687433e3f0962ce70f67e64d86f90a867bb6df07bef7c4c178fc65201ba1f55253a0e1988c9f6a1123ed7ae16a8c58edcf89c1b709f58d576150e302ecfd2895fd23bc4b4c511081245af7ac9a7653941b3817fc569ba867589d36761e1b103b30b365472a0c59c3a7803b252c42a92f1ab60c630065219e509da598d4c8674f0b67f9a97d04c0054074623c5678fd273c2777a7dcd4cfd100e8f766aeb851127258da428223a4f5361db9bc3f7b5b0bbc17d187a61a8d459e49caa99d997d3ff1cab22901a8da5e2c01f22c176deb036ca15cd70468f455f4d4f41d7c6650a5f652dcf6f27dcba066298b9a08e1012ac89f524f5ff93a970afc4d0de1a366f5529ffd3fa2b0f569f3c4c4324d9deedcc00be69912d8a9fcb40bc549d93b57f2911184e89469108e0e45aa6010941313acced94e4b0fc295aac5e542d2eb376d66baa913177894d222e74a563e98c505ccb3dcbd781950fd7524a76a2875f351ff13139d2bfd88af3ec6712989b158a2015cabfbd0b30785a24a7133873f9b1acfc6472798a2c2bfdabd61b411bfde8b53a3835972430f8c23046ccf980280417419a2ffec712cd9dd59455faf0b6fc3732883c79b9866d6d92cddcef49797d9f35e6fe2d79c78db4edf0d9348bcdb9c5ae87f5caa6e3efe1edae6852c41d42db91c598db754c057aeb1738b281ad6eac41fdb9d032042603f92a866b9d5a1f6b3f6a3b0cba75981a04379af5a7a5921085c0db819921442fe30922cc7e83a554f5d3a915c4b732b22fb6b294fbfc3228140ea8c69260ade5b7f874ee77d374639a7cb8fd0b387092d459847081b3e52d6296ddef1facf262c6e5e6ce71b28cec9cafa994b9eec63c7652a1b5c1c053a2a6cd42ad28655fcb48fa9c1850a4eb6c4e90ce253b2524eb09a3f7d1b158f1b99666f84b8f8c9732285f091c420d1355bffee3f2ef50c0aa25a5252e21ca7fa8ef430484757d75b0c71244b32644bd2d260882674fd984a2833386b6edea6eb0de37f618a4d26dede7b4275268dea85cade28aa7dd90647093bb848a7a79b9be9867a80272ebb089e75b4a41d3bc51afc07cf641e633011fc4b7c0a8c0a9c5e4e3d26b07f4d2c36ea2558438848f81283c820ab6c8a0f91ecf0162ef793e6df14cd27c64b7f96a44166e10474105aa4cb71993f7702c19580b549b519511ee4105c0f4a9791b9e4ae058f72b447063db27a5f400ff57c47c897708a1a83e1aa32f94999c904a0549bb7d02332f51c0b6c860131a6ee5860b29bad2b281ea3608e1f2a939de95290e590ecc103bf03b8962e85e7680d3decc01a2aa523bb24983e5ee366fc055f580965e1fb6eb1b59b09e2d7f6325cbf83289ce4def89ee988f491bed325605c53dc8d1f1a1e6083223c059097f274da5f55b90c2ac1c292a22e73b1e3c2ebdf96b80b2c6843cc01f54f96f1659fb6caeba2d77f69b9300f96d7dd5925f8992e00f77371449c0f07fe95decb331ca7f13d4c4fff20b4b41fe92824f5cce4a31c294d5376d6920fbf90384107fc494f9db908b79bf74d2407eab121d7d1fea7eed64b1b1222f3acdd951210f6faf783f0593f85676f54017831615fa1b9d99a70f4e6a28af124d080de19d22bcf803249021e9e104394baa817bfa35e6543495728508719b0d3eb420cf9f41bace91dd8e05cfecbb9c7c6964d438e86f1b2c99517c2e8ca461c0ef2a523098b4d4b058ebd037035c443f03d2a2e4c5057eb6a0eec4e8439dacb7e520462cdd2a3973157514380932d510f42c8417b96e0ffbc90c4754a27d16aaff14897892b074e5fdb7788024447bc0ab153848b0fad0c1c79e9a914781e94eae6e19d546fa29628e570d560a165a7352810e794a3e17413fa5e7f35361d92416a45989e746c6227da379120d898e3f7c8124d6daa64b0f3966a97a5eed0f44b4d2808d331f47394c4011c34731d4976cefa6b8e370872b6f7e384ec6ca1ab4387b90a42173dd57ceeae1a31cc02866dea952fc2910905eda442cdc0b3fef3b9d466706a3a859bb1a8bf82e67e438c86c1704bf37da229c8a4a15995ae9076bdc783825709a2273a4c81c2a3bf13662cfea1ebcb7144d4c4867e5dbdee718e0ca9e299faff0bdc7b88c734a79b3eaa7dd3e69432b5623cadfba5f409175b21823d06948fe048a6d97c0bc489dd74e6e6459a86bd512e1ed9640abbe52f3f33f3cb38d42966ae728cbb3d011d0339b9570a264a42eb76b8e32cbd8c93a8bd60c2bb623d905841f1c920eab9e13fdef27ec5769b0f6429b5ed97b05a213637319aadc4303d4ee4ef4eaa8ac54a3321b4aa3d7aabdb818049adea8a26d6a642a366564213fe60af0de9c097df004b342c9ca262f626400b91ac0098c50ad8e0885a52bc4f4796b1893d890e56e5d1a4bd93183ef2d4bc9b4ac278e909baf3093ef00605868826ea4d187c6c5962c1c60de9914a0ffa85abf0724de14da480d93208c240ea0c25cd0591f77342df89ad5a9d73df0630e8dc2ac9378042d77c80531e04bfa95afff9179d774eadcb6296d133815f959874bfdc33b5f29ea736897f295bd3c14b2170260bbfcba00082bdb1e598692a58acd61f20aead6c4290746c3cde19eaeebc69dd1406db0309c5aea3e928a03663f025ba7baaebf82778c27343ca5cc0f61c6c5417681119b037e73cf7cf4c5caa2b0a44222d914dd16670355bc78a280fd15dc4655d262d78f201b40ff7e6429d391ce25357c6bebb6f4629d9ab6d94345365f0b4810719c0f7135c79d470054dd8f7385833f4e12794ae8f691801b28347721ef679e99f9496ec34f81fa29b01a799fa0ef3ea88ee8d076ecaba2e43baeeb2b56552da79d5c8b2a39fae84508a4a0e48230522cf07b23168240c1f01026640f24fa710e93b59383c4877e24970d68c7a1c9f7d3295b58d135026ce06e5ce5962963f1dccc4fdc8d502151374b981b347be7f140e7bed64de965ee206bf307cae9e5a6598657d9fab636c35db68c739ca2708d3371e7e294fc33485b0cb219b39c216c2cb8162eccab7549e2b0e062fe3dac10e1e56ed0d14c94e06f099a4465d55627015d1e914e77255217128d3e81afd568e4e09e85b0c2d75c6875b7fd5f3cb03af02030ac329c3f24709092b2fed707b3003f8938e73a1799ba0fe25be90960a2d839b24346b2cddea3753382a92def53cfac6c1e8d88e7ec3bb321378d7ccc23eb458972f86b8ec2c9d369898e61acae52ea7ad99f38157aa92928dbd0e83f4f167a7259d1d9d9c22cbb6333181e9f7e983a5a024a14aee657e7750f40936a2ed2a570128fdc8989484c9b5ca527b84a751207c7ccf2373fddfccb1da209426b840f755b168583bab0c04e0182a24343e94202cbc8681a7f0bf45439f2f508254afe7d49f48f78ce8fafbf1ffc8009e7fa8ee140aa6c68d770a63b10ee3c34e796b59566b25dff842abb9b804530d44fabf7cdbee19e3d49d16217d6f81aabd4fafe82afd45800a8c44feee469c2028950e0b92bb583ef5d2b253344a2ca46f9368e0db7a2d6979e13a4bdfb51d1675d91f0a9407b09af82402af834fc56246b8c72f9d1f122c83462640e32bb0e0568a37b9c80a36fee8302a48ca131f9516c5550c0578a81009a9a6e0b2077ec13024b3ae8e5968499027d748eaeb321c8482c3fe80ec10c283ed38af49125b2ce32876cf06501c607471329bf2f13c81b080e0c3f3018c0836d1ec40bd8c8b34b7ca9e03c3c2814084c37364b7b40ca9bfdd63e5e2c7891b19c0253b28dc715fd4cb538b751c0a5bca214d348ceadaa90c46256daf4ddc89fbf43a580a053b162d022e752711f06f3d9d390de5e95d278b145a255ef9ba8da13df39f7835b00c43954cf3f783e8aaaf628a0fd5f25246","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
