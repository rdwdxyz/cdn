<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de0228eae795d70ac218e33eec25820fbd10ff6d306bcf30b9dd8828f425ec97dd33c37aa50d1ccec499a78c7a38e8bfd0d85687e5b89a1253a971d8823464fb7366aecf68e3c481e612d3b1459b11975624142b4c4759ce12e4b1645f785dcaf818513f8acc111032ddc558c1233a8091d8488aa19f8a21886ab5a46fda9a829aebf5264a69c1b07d95af7733826b106571ece283a3734b067b7d427a18ea5004c8155fa9a8b62d6940195e57672209a1ec1b04658a49dcc55279ec42a6fb5e1931432167d5641d6a8a37281fa2471b97b855d1817a354f81087562b3eb477073e2599cd87f0c54e83c5b9b26a53fd37f89cd546426e994333b641943127bdc4fd822d82d0f8d65d0994a4f69ad45e7c2731791ca13457e8d96d9154886ef93c266ea90e1253bff181c5900e1eb8982cadea5fd41ced52dd3afcd00e246ebeb9797ca29e7eb0b9679c6feb6b755be1d3cd08a08bd02a31a5e8a428942dfd6a2e53bf9e3e53fafd3904f25288d39209174b4ddd4311f5f4c506a35a6e0edcba49fd57e813f36d9d27cf02bc389ed19081bdef3a5461279c5ebd70ca753f7f4681251a8a141d5d0684d22516ee3478659b31f4733df9460910284f87d2f6368d0a703da61e1e2440c244bc8c1c74a9008e309fdc58dff13e3f1cd47bb8a90ef5ff48c89a3f9324af51527737a90514bed3a98f53ebd44927e3fb1bf4ab3b97081646f75dde42d90a521450d701126b7b25f32a24f34f5d38c49f099b66a43601e1333bb584a285dac34e0fb84c5c5daefa077cd23cbfbe59ae9f494eeb3c751a205bbb0c89a8eaf8abcf36b28c9be57adddde5720da71661a940897ad0fffb38d75ba2f2f44e8d1b5f80ca8d96bc8b8e61874d526f0117a7b6e66adb154e74485a9ff5b0306335dc479fce24985eb4c2f8867233608254bf4140a10045c316e7d0fcd9bf733458cb971eccf3aa5d699b5f5cd9fecd61a05a302f0a67be564408ba286469412cff11881de075b7f227c72e21a388b23ed82468a868f5700df5b54be803b26728775f8c19b1d585ec6ddbb34d295dd3e6ee8114735cbba0d14552de33846f50ee26cef96f23933e2f2b6661f78f5674e0092f0cd56000d18794ac82dd76c67321f5a65faca49858fe42b91b5829a1ef4fe90d7212f87913059086b1f55a6a7b611684d561210a1e631931cb034bdc49b0349cf1700547a5d3af24e406488548838b81945067b53a801a39f348322591e3e3e7db510126f7599c83676a8e689c8f63ffc356f2e1829a9607afb59e16690b342f5036565b119a9a1b707a70354471e291676b907e652d175552e174ef3800e607c925ed5c6120d4e6b0c3bfb0af7915e1830f0f978b101fa4b0fe6a889021dad78b03b21912512a1e0808011be314a760e8a8f874d862d983eae3a2d82b6355a19ba35b4801ef9061a6633079d145f1a8f88b7c44d84175d92f19e108cc54929f54867fad84d5e5c5ef83eb0778e94579b41afead8b76ef2f875d1ca1ff227bd8d09413c6b101c04cbe49b922f14e45c98f8bd2b8958b4dec0a98938c98a08bd1435490b14b033d7da633035c9d1aa44516ac16ce4c231513f9fe76c5524790ae438592398a06b73072bc0d2dd27fe1865a93982f8b0a64f1506137aa2e0be9c999d71da13572f111ec277ffd6fb6a7fbd71383cde773edc9752444824367557871b779a1617cb446cc431860692a28c482a2d3da9591717e3c535b03b23a49d5f5a012ade4b8e4a1567ade14dbe5a662ef1f88433baae9bc818b16b2f24e4d246c35ab83e54c28197a598171d0964e690fe0c1f3a1987d8b06693861f4db048ab63a85e05bed6ac182aedb3d24ff8d242d115df8352464bfc095a8e87fc2dcf558eb6f40b4aa4d08e7e31530e2eee610b170e0688b8a20ae19b5450e08233a134e42bfbb7ef65f6417550b73fffbd16f7adf6353548732a366e860f4c177d6c21b6efc8b1597bd3dfb435edf42d8ac4aee74fc590f8ef7aa10cfa749b01335aa35854e76d84b7a9d4f3c894ce53bfecd5001676bc8ecabfe1c046f27daa8804c99c73270d4e3378c54825ff1eb3bcbb4838743a290088aeada60441409c81a9d171da7a5ac5abe58f164cbc7e1ee2d6c5ebb82e3a4bc45d3b5ae695ce00ec74286861c0ffc923391382c75195cf6c7069e485303d9661e64a445e1e8ef2a6444a00a113f9190c4094452309fbb1df70565e98eafb45fdc3ff8c11cd24a5ab90324d264be4a5d08342c9769a1f8a120eb62538eefbbae62456dadc3b33f3505a21c633734128d3ed4cead355e2da193342b5b1e0c0eff15277b6febf112b249fc3db6e6b11f2766d51e8d4bde8f8895768745ca3ab67c9e248b71c692a082b630de6b58a7dc209c841276f3b5cbf3c2ff3af8255943eb405bc664360b0c0e5886657a205ea4e8e0127230801ce4eebd31c80440a26b47db87fd93ead5d44f0ae8d0a1de3c56242767a37c70701e1f61703d2b65932e41ad8130fb1a407042caaa1a33b21172e505058dceb277035b90df035387054b01c53b7a1afa23cbf4b782aaa2e62911f99e6cbed6827a7c75c4835eba1cd8fdd5509827f82b893b44a14aa88aed3592c54de0a302dae5e5498792535c93dab9659e3ea732aa448a937628ea99af16b1251360bf96fdc737701d4d8273c17f5ff579fc7d6a62c8a5575b11d0ade82e69bb3bd039d9c877173a8e9e2d8fe1814cbee44577fbcabb76372b66ccfc28d99612b9c36c8fd7266ef1a7816a336ce7f8d5f030b5d61171f944fbf67876f9982c34c39c62da1b533805a0b00c0eb91456be948a8b85120653a7a38ee5efbc4167cbd2957d74662a87e537f8cdc592423e38d0a3dec9af899695e9c04f57a71f0e868e8eefc0ba0f301e9acda1a74a5d743dd95cb152188e4ad54059d1e396456dc44ab65013bf71e769db9b330f1a0635f1a53c6001280a6c61d6777c954b1f049315067b22b6c3ae6de190decd5b255404bee44cb5793625da1b811200c6337f136fdb4dbc80df6c62de8d8a63532867fb332f026ea1cd37ef526a042b0f68598faaf03753f2ce52b980c1458ba74d9a27e8c2c1057feb61defabf829b7a87893dbda3a04c575dc1faf9c7f236bd5003b63918b949ae042ab9b1550c2f1d85c526910717a02e24744bde1b63d7bbcb36566062fb6e618881979f2637d4de8940006d199e379933e334a33dbe51f0a9e7222cb1f49459e377dfd653a7ce417477614bf4503698f1b447c6241b54d100682cdeb5b39974913b06ff67568baa7273285dae740ae995cd2bb077f6b422d365f3e01ed4817abbe211b56083a850660b6bada4ada8f9fca7f76c70b949c097c03a4eca76d77d81b7cf02a47d800f25ec56893b776742036e947cae9aee3c9040bb75b7629056924cb4da3ac42431d7f65d65f5cc65b1bfe74f158e5ad5d51d56e2285721baed2e8e297585572d9e63c23a17d261fad1326e863402134f70ce9a625f361bdaf28cc30db985f8986983621f9aa5dbb2c566cdf0f134163b64986478e98fe1773c7b6f319a1036d8896870ee8566473b034acd3621e56ed4f8a9c55b76770c4799dd48b372bc64fd2d98e070f1857f78f123df2f251d0f4770eb665ba596f22a7f72d29ee6f670e9b3cd47c8acaddbf87cd71cc9a6ac354131460a24bc13ea0e9335d52f0c4cbc37ccb652d9b28460d7ba2242839e140752cd630189d9de0916f385bf8f4fe4966b65f2ca63c189cfb9805c90408529c5744a671310cced67a19b369060aa5f7376b4837a068fad9468f632ae319ab3361461f1930f6fb55cba95ddb38c0d5fd0a6f2e421c96d1f603acfe474b1bdcb6c6e4e07f2c0a76dc284f90f1dbb8143fa8cafbe054a6ba52cf4b5e3cfeea0554e9b463ddd60f0103e93e3e83dfb18297e04a6ad07336821812aafabc514585a8c7b58c1c28fe97bf793d10d40a3d7645bee22e77f36a1eaa7b8b08d414c5d49342a0cb3d5b5e7154e5db46be6822ad7d1824163ec51f7717dadcecdf863703085810b305e84df172a109ef1b721985e93e95e4ad848273f9a01a5af2581eccac0683753824a59798b98b6f60e1945af870a31283a725b071bc07532cb9c09194750c307fc4e5f18fc0c01b4a8cbc9e73b6570c4c3f42d3d97a229b4ed9e6a74408bfd7b4b53c942e59977fcd13a2263c8ce4788aa4aad8c5e610fcc61ce7b6f453ded8504d2a5511fdbc04c4dec5b50d403be327438e82b6381af13d7c729f5f1c736b848ba2f044d35b739eecfad51686035ce09ebd69522c9ef0aa58bafff197f1cef62bde3ef6aa37aefe0a7fe9a27b2f6a617e0ff7e56ad24e3d779dab885ce6dafcd1f1f0b7fa83708fc0774ef63a1a03fff881ae1572698c7aac0b0e8ffae2658d201bf70ed0126ffdd526b3d9bc3d6f5c62fa011fd9bf7a3ddba20c727b45e2abeac7233cfe4243c26ca30834947c56a0e129e72b6509f20ac8ede382b19da9aaf951ae2287c3dfe31f927543b0e7c6699d09203b58722ba1451ea8418f4f35355186262592914c081d18e0bd9e69ea4b2eddf10759c3d4e1e0d1e27e646ede27fea8db48ce1f5cb0ab6b4aa05d9ead39aa8ad638b3f95409e7a1294b3c4445d92fed40f7717875a5de80fa21d2ca7347eed9738102c6ab3c5ee50f06362c7ac065d632eb4fdcb85cab49fbe4bc540d90345a8436ca96db1a4b7c2decadec1b506398ef21f575435ad74b42fe6acd3df10bfe420989984cda0fe216937c7b09dc655f24b891dc6b7965a99b3c7a358ed082114fcdc52fbd41a51e801ccdd632084da7e64a76d8129f7793d7ceb00ba80fee2a127f8923ab1a1dcdc2f304d9d65169a344794fe3094ad7dfe63713d7740a363a6330735d2411719e9bc7033b71e7311ec078aff40996123dfe02c32a0b81c7a50978a121818580624bcdea08e8ddd20a73a101f5a24d4dba817aba696e570506e15cdc81b24a7343dd77c0fb720f2fb82f33f622d904e17116052e55c85ce879b3dbcad1b71f7888a470be00125f3db926877397b52157301eca6caafcab8295da46884cba1ac4e93652d77aa22ae5c6e29604316518a513ab22d4d737766d4db826381e8e94fbda4d8cdbacc030133ecfc3c359503960965d45f540947ef553cde42295f895fd131e8ef0610d0e5f27ff943b464553372fe9163d6593df0560bae353fb252f19a7bf4c94591bf1ec3bf17a64751f35bd41118dbecc6bd0200f52953d239fd9b9f748e86ffeedf8f357159e35a9104c1dd4e79029784495e91d3dc7068938f1a11ec5d0d4eb195629c587f1edbe061dace626b1bb266103a2d021c7e2effa7b3b6a30b9bdbc08dbbce1be420cff072653cce38257eaf56ea08b42461f6cc7c3d45d08efde2ac2d7eb9005c7757a1c878c6cb250e997749134c970eae2065fba14a63fc436a3c3f8f9b015edeb2a44212fe0797dc0863fbce53d3b56b352a1fda52fc0ae2bc6b516b8549ee83bffa614500d51a5f57aa5e61452789456663bac33b8f931b120d4eda7f18ec24dcbc93b7ed98ed40384c609d7cbfed4abf7819770410d4065321bfb70814a77389b7418064ccb09c0fbdb546e78ab4106cce1693bff9c6ce849add9f137ced352cb3a7466430de49bea5fafed3a889d3b14a03b65ae32bcd3dc3d8cbc200f8e09db8a4d853b21e05ba59efc15e8a659967a3591fdd6dec1f3a9aca33a4ae7773ccad8618c01c3f0fc900ad6c25304e053aa047d399eec88944a9d179f349796fb44944550a85a6dc91926849f433927720d8d8d80dfafefc7c6d700acdd00f5f0c75870b6dd6db8ea2f1414c55d88eb917ad5eca25be2bbfdbb546cc955b079eb2d8c5065deba1fd826b7b7c63dfc54c2606c2f89f96db75deed5e59635c7cc43cd571894d7605344e2bc1e33a29961f8fd77b29c779f0ee03b8398f07cd1259f3ed3cea14e44dbdad0dd68802f10e48ec47feb625a5791d0da81372ef32ad3d83f6f0aa99fb3b8eab23355e14f03137e96726a22ea96c2e0c70b32acac80115285db7653a85b15429ffc8ae45bbc687ccbc80fd4004bfe79e473055701fa07645a863252724ea87e3d79622ccbaab52083791d17bb253230b31d55fa030379fd0e37ecc8a9a3ff43a40fe9c982e4464734ef388c1da08f9d42bd13d72a4632163062643827ca5b3af8ed3acb86ba68bd72b3743af2f5d04d8f37c7903df770bb0b80f2e1da86f727fe9faf2b3ef648ea91f68d807bc00dba93d89c38022f1799968d7d3e11302a3dd203278248cace59d5e178f49f4c24908f0c163c4957e8ebe9cce1113a2c2b7c228714250a0f3aeb1ccd837959e15c0f4242847341fbceb109c372933981520c667d81bb93264be06e3537b2100ba153be31614885c1de487a1411f97e75bd49178799167dfd739c4819cc9b69a43ea8398036e6f4534faef449ec2b0ce8cd932f935ce06032502c6b3ff9815ba5dfa45b7464d9bc14039104345568d38f5193f3ed9ed5f3831960eadf61a1ea823ac8c7ca9e0d3c8f938a4cc65ff0a8dc2ff705b68407535129c5542984d4152e3ca4282f1a3b2ced6b158d847544258c1df1cce44db368f1dcd811272e38e194fcb6a56117de9290d2613af4f2feeaa83f66c008108ddc8448382bf4ea4c543172ba57bc9af781a09e6d0d89164c827ac2643f0eb73a72c0a570354b4e9e5966c836facef5b5671b05155d22d18f09a6b59cdfdea11c7a83126473371a3dc718b8834cd7f651419b31a328a4d328c63c5db179de0ac422df767288c4754706a8a76dda473af4b6b693fc40ac7464f324c64b8c3a252678cd90f69a8f7015a62bbb4a79e2785814848511dd39f559f763a532645005ca731fb827270f05cc636d4648d4fc0b0d4763534798fc01d4cd460e56073db5f55cab6f3d9f69445b922db2f6bb18d2507770998f951d51eb0e7d84347583fbafd7d0fe2d1b10dbf51637b58e2d7e16e3a3fb974851282689030fd30394ac70db399d8c1a24a0e3a5f1588da0ae73a773ac92ad3e97958f04e04f641a7424828da4f5ca7a95ee25a1fd6f43e4365eafbf442f8525d723b4b4a9ab6f28061ee4a59db84087e1b44d42af618e9790e9ca62f42534d72a94da2e56e6bb974b1fab683632961ae9506ab0660dfd04349cbc3b62680a6a0569411276da9bc7a9ea4124de8bacf1e0a70a7cc4813b5b401b587cce9b2385eae3b6d64fe9c7c64d2664c42c571c6602abcad8e42f118addf1fd6f3d54e99e8b3159bda85db8f85927060985e59c93a48916a1bd31f2e3c7d735342b6257cc1262362cbcaf5e9c11612a3f99caa650b8ac33f54d32fc67af6a90112c5e68fa79f22541375cce15971e6c42c5b6282ba0f52d614ee2242bc7167b84a90ad035881b73f6d9c2a58f433a965c46ce585fdec4918a8954eb6de284ea606218758fd4f8f8ed65e47480cfe188bcde3809a9837e335e4b934d8bfe08576edf5794bdb24e6493476218c4179189610664e7687becb8b32ec7ca8495e983467072b49745d7e7056c7bb84078e996f9fee1a945df670e05ced1e15c710a90b4c1c183114bc40343e344746bafb9ae348daf5ab245b9d7562a46a6ab9701a4fc60687d38a8048b414d2beefd184b635056c2d1014757359cfc3a775d26dc88058a7be83e3a3e196b987ae46248d80814dd1a668645e6052590dc7d753480ac8b524efe503b44a48b2689245e255c79cd05563f48d72fd19274fe912f1e57f6479a906b41de7c687f035fdfdf038e294ba9e00385f7e0db2868ec71a1382c79552c4d9f99ce86d8fe079f389e10dcc5a192fa4d7b4659c24c9d3a181267ff60814abde705d9eab33ee90de5dfa7634c74ef4d7d290867be0c6977478d24302559db1e58658672f74d75013bf0d4f218495fec68195b1b574fa221a0c51aca2f89a30e456fc4ce7158423001d617958e538a29b8739e932596580dc03d116d534fbfbfd6c473f37a96f4e45979229fbea3d76d9f8cb16de4c5513627790b2032524d601dc8216d73c3f4cbf25c11e5f48fc8e148e694b7c745f6ff31b8b59b1cf653b647c5bc7cd38f85d108e91bc02600281ca173e94cf16b4cd9a57a22e9094b309c11f32f8c561e8831c71cbffe50378ea01e354ed590dcced0cf29bab1de909f270af2e4f53dca1abf07938f253a4583e7c6c3214f6fd09cf57a098608703ffd3a2e518def676d72c405023e8a4b2a35c3e988a2d6c8dae7f811640076e44ba8b941268901fa56331e92766171c2666a674555961a65c7ff0f526a94ce000a45c4dca0898c55a41ff7b8509cbd7d826478c1561bd50dcacad33be97888fcbf20c05ea451aa22aa2385b3cf4bb1e2aa6ac753875562e3e5f1a209205dff656ff7588a878b5e289ff5df890c9d8091d36b3ce0f061ccaf184ea6db7b0bc5fe62e66b172945dd87a105b572423aa21733418cdf616fbf08f041c051d91214d57c5dc9342033e95ca313e00c621e796675bb3efdd26a16bb9eabfc33ee60194de812f015d46ec4340b10dac5401ff9daf3b16a3fb4bc798502d803526bedfe1f5363c0e13cc4dc06b23eb980f8c0bbd3ddec6985d6e3f1cd4e8399f4a06bf8187fd9156ead67bd90763a05ad1d72115f0ef3757f852634a6a3fd56b423e27d512268d40043bf410b13350a2b95f66d07f8e243254f33bf12f6b7878391d4398af4aa0d3bd091bbd5fa8e6430e5a8684933a89efc5860b5b20de66a6e44da37e6431201a62c383c4e0e7ccbed1fec1b9482e55cfcebc741ffbb092b21b25e0db939abc0f66b38e2c209a802d050fa4969dec44fbef922236108a764d892ca84f1611e17f70fdc55bd8cf217a0c41dc1f84e84d824fbb61e3217574f2dbd6aef6a9a5e4d5d1935c12b357f254641b6ea34950b3a45801cf18fc3ff46b05f5866f0ad3ab0d5513025361712db7a06375e44008ead088a9be153b08649d5617d3575ef93cc438c7806aedb9f514853c7a9c1d0c410c99519074c28c2da07bbcf825be0d8d78e52fc695e056ffcab147b8552b8328c0b16beafa9eb0b16dd71f1301e3540b69103362dad2bb27528eac16452c704f9456863022f4e1a4230bd6471592ee4a3c2b8a862c48080b2e6b4b3b81774f649c18584868eebcf6751d22ad2b2548b633657f88e7a468ba9f418b1cf9ad8f1304fc498a74bccca4aceb1a6128f3a85f5159145ae3b9e330fa6f6da8860ff0e37952d2270dce47dc316c796872ca4df25ea46ce57043798d86f70308a4ddf8ba29fd9859a56282c95df36cd3516d271619c6ed9609ecdf7ad742208abb06ec48fb49b43319a9ae01ba9912e87cc6e79d0acea640e41a5fb1c354453d040cbd2faec26a20f4c7a4fdd82ac909d39038510ea3e5e44efecf605bb11fc86da5bed1e3fb6a60c96843a1da6d9179844f39b186af437e5168e45e2f119a3006a5b3f5c44373b87aa5f8ec871ec9dd7b022979a188680251854bad2725419ae8166fddee81e8005e07532dcbb0bc5a3369df1bfa259b51e97cb7919569a45f3edaac302112009502ea005333a875ae623c7e617e544d86f6d5faf4a625bfe24e3969f05ba7992232cbfe484461a9ffff0cf34fbcf3a462f4ea7bf45954105082cda85e92cfed068b01dd3f3205de81a5ac84de6efb1c7fd111313b9323e9a279af662ea211529b45207502554e08434590c2327edccb487d780d41bceecfec25188def2714524babc347c9edf3dd501496d7c1a728c5ce9a80d1468cbdd7ff1a396842cfc4129bc4723dda3338b9e16feb8d14470e5893ec3babe84e91769975f674061609c04ea36861220f134915ac8c96fa05d9f302a1e1858d5a6a2bc810296688975e49eef6b330e0d4f7d1b9165135eabb49b12ca41acb938236e4b400cc649909dc695cf23622fd082483808348e3043185fa223fb8fd41665a6178bc0d2e6b382ea576e11f699f4958fa63988ee8763061908e48f1de5d1842fb11872966da5365a74d0fb0ce56d27ece4cbec554f952e51ff668d1ff03b146f72bfae15611343bcce163123d05160cc0b4020459b07a7203be2cd99d1b33a41936c4c3c922a7a07c602e7d2dc9b78320bf6bee1549bc56b5d5c6c2494b2b6019bbf0c283f15a3ae114e66134913c32b9b92f22680b72a0b8919380d5ae7f987a1b78f56fee43646cfca9f79615a37c8e33cd17092bf1b8d07997cf514d0dfc7d7e4d74ad2f3abb3f9c5f068331e645480369939e685713d439c73da909f6459e0dc60ca4a1a4ab2c29c29b7153cf0c84d88eaf9a652d4a6a2ef116ee355ca7413521d9ff517989a9127fefdbfca8f486e7d87b07aea06bd0187673cd37b371734352d600e8de4f9ccb4e796288ea9ad25c0c548947084ce7a37d4409ff24a4f7a8dbca0606bcc2ad71e8de2202fa8846674065c117c793ce65c5bcf5702be40b19ae890f423ca05237ad62beca20043391ca77be6df4b91ae2dee98971de8094e92b55b40867c408449b569807a038d46b7a60a307f079f7df682251e52149cf9a11ff590afce566235cd64b7deb1ebd1d178277f7521de9a505a7647530fe5d659bea9ff8110a06e10863e585442071b695d9208812d328800f9968ce4fb4fd22467a8bad76457c911e81cbce1052be2e4c177ce6b591f59eb9842995d9ce79fb4b70caa1553705795d8f98b3910218feb231f7f85ecdb481bae7aa02c283c57b6383b31f69e2473c4b9c2b097d31fd6ccc6d142d795be7580dab6a076ff8f10c869be69046630daabfe9941622a8223da6989b26ce4b399fa7abea6b917fdad5a46b1583a00f6ecfe6ecb648e6371c1ff861f1f68b682956b130e824891aa67f34286d1eb778d725300be1dcd25b55b9d92013c859076d9f1c3a114554d9c2e4724a8d55ea9c726f09b815ddc06995ad8abfe96e75cc8302596d5ae4168fb078ea133731f8eba6c42513799e94c2bc7fecb08702c0412383aea4a511c5e805673b54b578eb59f5aaa492dbc1e450412a4b779757cf37600a280d2616a00cea44a5b754b115ae63bbc16c9293dd893ebe9b586778d55e8dfe03ec6914f58dfa869b8708813df43869fd52ba5822562b699cbf66048c61101806bad18e176d8325a6e3db17fb9f227e260e8fc1b6956a4a211b4b37f4ad10c214854e03b95ee0f5ff4b025f894440b764a7ead85cfd231829982710e85f4a9a66455b275548b3ea576c3f66f4449432c2097c813f38df58203f5f67108252f76e1904c52519979072f130660aa0fc0f5c0f1f6566e4fd777a238099b2b179848f979ecbab9069aa33b09a620fad6912653fbf174dcaf79544d31f6028f6b3db8b379ccf1ff7e3c80727c93d2d5c791c4410321e737aede3172fd40e0452ba48c4e7a03165c5cf0eda081cf282f43891fb59f503361faa8e693adc6858f8d266b961b0a1324e829284545b7f8f5dca27a3543f3033be5a0a5f0e076ea6bd9a698a4a51ed76306a1cc085d21baeebb752c37b75a1b032a775ea31e2ffe2abf78e8b65c7d79bc7feb79d6e1e34148b31ae5a0943d2719a5a91140d7ce5f505da899a072ee5bb37eb580a4550d31065b0a9475018a131764eb3468a0ba658134e57ea253865a2e26092ab3b5a161a704d13e5f764ae833e378174d0449419932d64e856dca2c40321c2c6a1d0fb4a84d9154581ba6f0f6e06b692ba3fafce1574ff12f7df97feae846678d033fcc7b4e91394a3000d90d6c6518da8c71a75180caa4a6286a8985b4d4a48845ddc42784e5a70df59515bbf1735dcb97b82afabb40baecf20799d9be12a33d15133ad4b258903d5919545e00ee17a7d07aa2c238c4654e8892517f978a2699dd2a23c9273ecc80ebf382ee79fe2b0acee9a05a64aad4a27c0949ea1eec91414a27a9df5cd2431aaf6dfb80b1ab66bd9262d725d78f766eb2c32e0af656e2fba4ab6c02dac7f32bef84cc9217afe9fbdf272ad4e00633bba3fd49a34900693ebe9736d9b43e081721c80e9a70e285b38830a5335909b7b6e4e818ee4b586ec55a6b529dc57bfb00e4def997bc0e7dc1322139cbd1aca79f2f3f00985149c42fce8457a8b078d7aafb1b463e85daace617b0c21ea508142f54250b8439e445f99c36ee135730997d36f501a2fa0396c22d157cc2e4e4f59af59e6808d7cb8fbf0cdbc66a6f3d6ed165104e114364eb08e8bfa9d90f3a47ec8c16aee22bd9da7869a56d3c73b8e30d0ab6fad209f0dcabef96f0fcd8a8c4be5d4f3fdf06f5c2d1c40a1a359a9911aef7cd2e582dfb496300e981f0825b0c2ae9a1b6ed6b708a8d90a3785397b057da2c76c3e114f0fbe02e261e556552ddd59d6588548a27d2a4ec423798f2b1e1d3ad9dede71bd31c6691543d38b19d06df0eeff2393733d32ceda23f12c570e6d0d24717da2d37c7a42cd2e968356207c0250eb3fc52b98cea5fa21d2cfb4b5a4891ea549651e49927be9a14c02ffa9a4943f7be51ccd5c15c2f01347816acdd51cc30c0de658b76303a2cdca9735407d109b5afe6f3119dafea1a19dd3d035638ca2d4080d55014378c588ad1c8423c4ca142ace5bf01854402983a1db27fd88e6aa574e8ce2be82239d4745a526f474878980c0895b96876a81038dd184d0e74801fa5e69b433b0ca7d9083f67ccb9be2a4e9a65182ebb737292a6efbaf71acee5fc638019d11b02c9e6f0c3db902d6e3ffa85c242a5d652788db29afba7818962f8d5194c2788e9224bc11bd348fddf89ee04b69deefc8cef9c08414de7cf438bd0de977a67e8c59392485b8d2f9a424dda4da4e9f4bb47c90bcc1bbfde5a64bc3d35ea5345717c69b06266f747b8cd895b91d98dfdaf7394bd481f4ee868e253a111e72bae603efc9e976a8dac91326f017ac6d31a5db985edbf44d91e48e2678723cdad6964a16caae94b9754e12283a376beef5a09d2524c4097d4d38b69e0552cfaec01d09c6d9946e103a68153ec3f047c4289586574c2aeb726c605f73c85a51b7342f928752cd9011c9e653492190f4638eef112b37f97b9835e1c4eacefb61120725a8eb86b892c846a01a0cf707c035b5c55e03aa0532cc950f55daeecbfe7a07ddebc4371733e66aea34bd9433b5c70e0b9bfebcbe4ee74f69e469c241af230089f17c116fe492720b4c19ee75b0942d9bc8c3ff6b84b36d0cc208d9eef9a382c4ffd87744a0fbd6954cb9c61e0b796f09e4261fd0121383c10a43cce125e9110dd3cbbc193ccb80f609935d663f1bc10057ff419033348cd5427410db05dd0cdd990ee605a09574360a17512cca2996baff1d64e23b38cfffbc9f009b90c1c11e6bbb84a57de2c005d77603f3678bcbd5708a662cdde046c9bee33901cf6d9d8e6a6979916c5fabe790afc454e97995b33722c3bd0c54b6b5ca25f05e416f11cac0a8f3d2ff07174c7c36fb33c0445e8587ccd118167eaf032ae3f3e12b261b56311eb2ff670c6aa233dc2188be1581b46167ad07f771d8235fed91e6f442a4a4aa5d09277fed2b3b226c38dc1c78eaa8d3c6a3a34eddcf39cdea67fe6d09f6b2d5fad5dc37310fbb37161308006f8bf88c39066627772556966871be61889d10237855946d33e205367f244ec0990d525377acc2477f04160be791e736df6c6738c48e7e0fb314188421b17d260757c26177cdc86ed1684b5ff4ff5e148c460e2ee3d4a3d43db9baf544e6303c2c7298451c694261e5e93600a01460e9746db4a36312655ac16fb63adc6a26644f72fb7d18e4efd0b1281f9446b795a863fd75fac423e2e20eb25dca628284ae9d0caf6ac27c0556614073a398ac370526b4bc2b0bd2dfce2d15645f35286414640318a058cbad858f72f07d3661782c6738e43581c116d53741ad8120276b70cb51a9a437a606d5ba654f0f8ea438309df19636d9ddfd930f92af4fcfa8b4070bfb4a99d9b3a1c0e82dd213142205bb2c6df4d66831ff9c4f22b2ca7478e718b84b2e73ba61fb7bf7cb66510c8792737522344b3bb140f3e510719a81aa9517f2071a405ed63fa044a0f3b8971eb07dca5849b5819fa24f02075944e9ba29d9f0978059254c023e65e57277438256190f6bb5ea17c890aff2e93374d4b9e837aec9830c6044ba49496ac07a74522c6995ed177f8f8d629dff414613af15edad52202bb61fc5e90ffb937afb2012ce67f2fdffd8f43a70f73cde479ea8294aa8a181effa41a160d0bceb2765e8f623dcc5d08989c0b24ef069c68b146ec429a496a8254cf7f8c49f720ce65808a265ad8b2aac134a66441beb2ac00f741ef52f8856d36c001ecb187faa75785f5997a09ca85153dbeca3308030e79dc1a2e91a78ebdcc16845fe3d85512b8bf1c613dd2c89a978917fc2ecfba8fe2f69750a0126d55841ebec623b0295429b4000af82bb62aeba7af8ea97ef0c10d766e9d3da8edd74bf11acb1c4d31525dcbe6222927774a9fea8b4c98c60318f8805a348b21a4c731e342d4634f162ea3b33f1355776ab3f78058c1016499a02ddc88b81f37f7cf6cc40853b2ae3145d39de9772b97dc0c0cb320b718323ecd279122f9a12d7438b5c71422fd4f72da0bb1e8bf7393f2bbca6cb49572bdb84baf5cde22d493b9b88886bfe7d6489d3b2d50e6df7a64f9df3f52c058d4252394df597f59c0c990f8b77537a7236243a68ec999b921e4b1d25ea1c6d11bbb81faf19accf9a74fb15a01237d442215b562f5e35087ac2183d89101156f087d03a91518f305810e84455cfe5f2c64e1dd081a63cc334716022cbadb505ee1c3a23391e89608ec2deb2db497bd495ea14045a8629caaff11c73966681ec77004fa6eb04f4f4431bfa6fe7abe75a917ad1861fc5ef862c7f20d5432797c090a707747fd86d14fad8ae42f930aac0e08253a286762c7ce57105173358ee6782419487c80cef7df22c5e71eae4202afdedf181013eabad75c10427e4f91bc432782267edb63498ddc26bbbaf16805c1732136d77a714ad2bdc7d98a1aa7568c163b50a8daa84b6fe0f83f7cfbad8731fee5659ed6b874792d3b31c6ed2e871de88ff357e2ed3d1ff1990a553afdd893f5ab66605a425b23881b3b0935fe0974402c35772dc65e5688b26b7df538cceef38dde13dc817951ec37ef7a1ea47d72dd8e536a564d5ad9002bd884fedca45a006e757278d76b13c264553eb0c90032cecbc2a12a563a2684b312e2c5569624c3d861544616b2839a68d64e9409d0cf46176d08510e0a29eaab4610ff40bdcf01b377f629cc9b4bbae2701a84bc15833ecdf2b94745c63e533bbc8ea28ffb958461508c2c976f82b6cce67ef6dc585db3d288d85f0c197f6c8b2b6387be09efd6786e89ebef7af04c71b1731959ede541756ef1912509f2e6f1ec3bc2d2393707f9f8eedaa105e905e3e73c4a72826e5b17a50ff7062fa1bfc2fb136b6e687b1fee08bc4ebe88291fed5b04112984c6fcd653b8f2ac5a2643d9f207d113d14b93fe35f7943b19882b31c222d4369c8759720180659807a1cf42ba0ee33ae0bb7134ff521631126f573343947ab813e62d7ca7b3e2046d2cbb936058c3cc9728bf123d2a5cc1ad7000de91b9580fd5459c6ab27305a1ab803f15f1a816427488a43b51535b55062de8bef6e3e81685a4802d0e4f646e33e873f2c47526ae8e0a874209d2a79a322e46261c4716a7c854dd2135adb85d92d625b2187895606c8e7fb5b42b5a33fe0076e5cd0a1992d1d2af99ee6c0a3137ec402f65c9fa2483df9ed0ce963b5e7e1550d05d0a445e59e09f30a72cbc0f2995379b18b6d1f13963dde676480fd63aafa263563898ac78fb1aa2e44e45ff5e89dcdbc5e4b2f2df7ce4d8a23a8f42a11a2bb7b97065921e678a4f2c0f0b381f61f01c16fb27a43b9c450ff45ea383295490004cf21361e413f410ae87a1b55c0316a9d56c671a3b3eaa0e840f3a58e207987703994be840ad6caa1bf334c434f8ce97a59d14635dfc57f94333b0560b7cd182569615834f11940a1a41c7255c3d99b513e15197dedcb93e73c5f7506590529e819bc55f8abe28ed833da0163f3ce0b24fd9dc97410ee87d5147863d69d6b65eb89c41f8e52bef7970fffe5d18bb89f48e0bde023912281975c35be659f55862458acbf795da1dcffe8c0f58267ff7f422d045c6540ea5c981db1cfc4133f41adc71dd2521244fbaaa96e7e03b8360e609ee0a2a13debde17af186c7bafe28c12f7ed06ddd866b5442b16bc7b3e503490996a21d6f95225e2d50eb2ee7f33abfb20ea54bf85519122b962f3edb0c5d0921cc241b8ecd48d099fbc595c655d8dfe320a4460a4384614ca36bb2231cc70e279b6a9f652d28be6f141a9a18f300429137a8a3adfbdef777c0542c218c1ce70c02d78e4845adec7b93b581d5f2fe9c0ed1e52fc7ebbaa8b6c1220e1f6d410c5d4594d2f19b1488fff71e7a50f830cdfed05beedcb6c7ca0e0871b3acfaa7d3da66c78dbe1b2df6ecfc34752a83487bad92fedd24783f6e792f3d0cf4a350b886f1373e2786ad7aefb9f84c6ec9fa548f20e09181b83bd346d309c6d877e3830c8c555cbee886739010ba3d674e8ab76db599f35af23709b3a24bd7f22e0ba344b830f8929e038798c1848e8b6118b2a2cb7b777ea32d62ebba99351389d52fdca6f403d11508f9e17ba8f350cc4e843f4f8bbbf75a1ec441dc8fcce29809a5329703d8b86d241ca8ea0ba075cd739873b6a6b35b6feba8c7f007082dc6c59a8f737d373f07b6c81317f1460d505337b3d79e08d17c887c5142d90f1d243f97e39822d35e847b507469b16210a5af14d8d474a322b5d5a56d4f108e7ccaef119428d8c694f744795f03974fee0318d5c36812bebda4d129793472e7d91a03ebad7ef94f9f5392d6734be0808cf770e98ca137ab152839e8f46851eb22b33484c249fdc9458ec52519420a020d539d75777f39fed7f04f4684814f0667594c116fb34aeb92717524656a0f2a4d0944b766d40ba1e92f5407f82f5bb255232c24779bd3549b02b907fb35c9fccc1cd6a31881268b94828a7571a4a2e2c234ba643e8835d5fd866e77581656790c016dbb0d61e10b57dc2862d2f0a15dccdff6e908f7c79bdcce039cc90ffa6685b942937b3ab243930cc8deb7fe43b5db9a88a27f3276c43441e4a8d236b831e621c9314f423aa9c3b047af8c4da9bde3c3331b3daddfbc8b22c00d7d1ed65fc302e7841c03f7325f34df670eff0ff6f0cff24debef55c0d6149a3d6dab13caddbec973528c6f45a66cd4fb9821f7cf24b429fe2a4252024ac45232e4c85ad8f9eff007e7349ba8ba2c062ece9fac4daf40a20379eb75d794c47a6d4bcc3eb94ab838d7ad70508e0eee0796719540ba7b332560695a0c7330e196d5b20212073e7175e318de7ca42fd1f2d01f3c9bd76d399eec2eac2e1ba58503237f6120a84498b07abee46268f71b8a5d23abb0f3439f98c1ccd1ce1cff3c215fc3ee7e1aae07f88eb02be7b3cc050485a7a8c574f37bb6c9a92d563a2df39d78075bd7b381c29f1bf9fc1cbf517df1a52b6834c86e36419799ab4a4a773d71851c4dfba5adc416a9e79f02928cb12f3d73ba0572011c68cdfef5471e408e3966dc34967086e0cdaa4abe7e1d46608b5c9a2a07c4c2ca961032542925ae381737f4b11647754002fb64325bee255d694e5f94db08cc6ad74caed12f1a1277687cf272c5f4fdd69827da126829685ab43c457eca9f2ed0305099e1ba4148935d268e933f068fc0335d904cbe257eb8e493d8d0a3ff103b9541a21ba95073386559e107e7460f9afc40edee9432663f188fffd8f5a3b2fab93b74260ef13ab064ff890ba3306ebcf6835fe739d35149683701958737f3cec2b1ee7d5b461b6ea945355c89a0d5ddffbe73137cb57e179a28fb2e5e4db386b363cfebea4630f88d509d0101d9328ddb533017ac9be47049053cc67c26ff9ef9aee496380dcbdc39511c8c104ddd0dca03e2492ff85defd550fa84bc2c30ae0d54049590df92a4c084","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
