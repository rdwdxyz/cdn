<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d050ee3dfbf4d3b41e23c5a867f649beead2a008051b1240f0af4a6e10c3737cf75de53e17c1838f8a3d32c0336604de9225450350b87e875b075e2ac85b728305654bfbce12c633604b72516e97322aa3bcc81313eb478ddff497c60703bf962f1a9e812497aa80d3cb9367738b2dc1161e2e87002257199763dfdaff6ce865828b475bcc03f72935fefa0e47655000fd60ededa0459d2cde03ae1db2e66db9133162f3ebca5a0d94ce845990fa379ffdd41660bbdf9c9f5fd9c19611e7177dcd73b35e50d77623b4bc268c95c71a6e07b0606c53765cc58c57c28f3ef922dc4196c946e74607efb816d36ffb0d2be6350a0eebad6d89b00bd5934928b4d76e674c3b6996ae4409b372cf5aeaa003a8172c8a90efadc1214aadd0234abac204df229567af44258ca90623eca895214ddb45f72e3eb6c47617b7849386fb6853be4ce85239dcac3ae9db167b1a5eadc9fd7e3540c0ff8da3fd60cc4889867c1e9e2a27861d88fc2ff3a309cff3fb293209a8bad0ff4c5d663c93014ae771db0bef327561d18d077256db26ed561f3ef1d4492cf4a5cb79e5f75134362259707655d4d699bb365d4455b85f72be5e02138062a0c887f16124185fc28c3cabc6a8bd0c45e132073bed01fd901debc07448881f7f21725fd06c83c4f8f97f1dae1b177968fe1b4fd7670ce0f4f3b3ec079b139de79f798831c20840e778949b65001d9632ec925fbb087323b1870dd3701d2c45f6c4032937daff88aa41752d8af6a02131d5bd5ef4e8d9c501e57639948d1dc71f1d91fb5808544c215edab7e44db65747471146bc919690c5068199d8626ef57498750cbc123b2a440f8d2d33a64980f86e88ddb9cc40500596200fe7252eb48677bebe02c21239f0e4860475665ec9a2c7f9bc6c0ad0e89be27d521690e27230be6eefa06f114f712d7d8322daca72c4ef052880782540326b2c68ad80878c6605d09b4c48c06c83840ad4dde78416e6df1e3b0015dbcebcdec334b4a1651e58cb88b12675b8f265b418b58cf998acd9a401974dc072feb025d1b344dc463044f962ede9e8cc598c4f9c15f44acb7d45351f1b3e6b93b51b710d1b3ff1614557fe3f8675576a51bb2a4a009b3b8bf3e6099734d24a0d9fa3f578bc9f4ce50bf29406910c92d89e5130f05d902bd06eea02e306c4eb31e235a28a64af0900f356f60b3f15ca819dd6406f27b2636af79d35c6dc45681cf1a75e1a817f80383018217bd0df9bcb560b3778498c389baf58620a53a959d4d4de43268c0618a6b6f1e98e0eec590f5cedd45e742e10419e66b7aa31014259a43b4f428cf965c101e3adb7c9efb8ef736231a90feb7346b325dc2693f1686c5919ee5262432b15b0a48be1c94a73c288ec7aff00b39b5d95863ad7643904fd121c42e7483b211463779714b284cc6096452c00e3292a57493b9118aaa25b28075e42c1ad56a0033a725c343b569336fb073f5daffb932c8192acaba054c96508561d59a9c5cf6298c83e2b6f0382a3e8464e150e9393b4c16a4a662554816e1285dc0f3b391f1e2ebcb833f1a167c35c0d3638113567b3582ffe59621ccb3cf35d339e0a00efc553ac91140c222d612a953b574b129b2f3fbf689b1ffaf12cc84e0f3ffe97700548aa99203260f317cc728aff4a03c319b7048dc8ec61604d0a9b555055d5e779b6d00c337bb9f37f4218a4730ce7f0b47ce1d103822f260b215f8fb625997c8679d2bca9ace33b30802d4918e2c6cb9bb8ef5ee07d6ffca750dd6cacf90e606a38645391576a54b19465e825cd77e514ee6cf74fa3718a29a766d42c85ae5634de73b2f4598094596ea861e3cd64a719d9e8791719e9e304ef0a51cb29c2f5c245487a2a433f342f3955224fd2ae9f00fe88aad1b1ad83ef1aebfa515ec534990d2aef92a63205e79ae65fa4464e771e42e2248043a42458ea5b7a7acb29373e56c091cc6f5d9292376cfd863bfb3b98ac6e5a5380f45312becc0f3d7c0a591637dd84ad5808d997030097711b38f23d2ef30e994e9bb15d1e5a28442ea49e7fbf4d03f9aac032df65fe4ec99a9176aa8208a1ae2cb5e4b9fbd342542e38764a575cd6a27aacc45457b0db44a84d02794c0b5959eb23f02ec22316bd07f30e83480e37cf20992e3431ab38bffd1ddca2243b36e1283644f4f9293a2cf92a18b5b912800718dabd640b8e1149e401bc682aec7f0da2eff776db1ebe64009aaa51c65c69b77089a8b0ec660c045c70841a165640ea43ac4d568ff6f031fc3962e2fc52ab795b8c6a0de3b6eaaa6b9876ffbc8ba622e281ddf1a178201c62c1ccf8f67b18c0abdd43937938d61441a9d13504ef2af42cfe0caffd72c13a8c1eefc326a5afe2aa911a6e037591bce037fac6fd13cc1d46ef3b885ac7fe128fa8789e3796f0a1ffb9293dfad3a7c6aeb289eca5f79a79c7d595579aa78a9fbdaf696dc73a56f27df2cb0fa73e9d833ceb75fb743614f335363c3194b6821d1b48a5ac69c00c7028e086849dcc58d175a90f7c6828d60dbb06cd5d851e650b2afe32d96e9f25959f244f80edb71dbc2e53eb3b8b57b68b9ccd79bb448a7b9c87b3db748aeb9a201de83f6bc171135478e698e44217f20c09edc290e7dfdf2e9cb6c272e6adab9070874b9985666d995601f8c1c7086ac7386e9529d69f5be04da1a197bab4b9addd4729d5bf2843a67d254526909776bf788493deb8717d525652aaeeb25b1c29348360f96c9375a524f315f98fe89e35ef61f0515701406b59958c8f375b362c3231ac66671ae6d933926eb757682657f390c9fe2c8246253236f52997346ed6f42ffeb78a98193d4b8cbc483c0e61ceace91df22566668f188f1a3a935a5297c20edd4aecb38a7bc18f49586565e80bdcf4eba4eb9cddf8619f78911d9daf3c97aff0d84cadc211a29258b4496a093d8c9369b7b3fb54c39cad3b2a303ec5bd0c156682d14b9dcaaaccb9b425ab28991f5cb7435e36ee90b9d86ce8b6c016dae6c0a60fbd42876995e82d69230963a49ce745150aa69d86fbddc242968c2d999e6f3b0ace97fc0cb7bcb34a1cebc4a4e23c3ec0255febb15011a082610c15bbba592986a5af55a8c2d500165d4024e51ec55dc318f741916128773ca6266f10790c229a59d2721e9f9cc4b375fa0f0b14d1e2b7a34c42336fa08537532e7167013d2b02442eb165d551b90b3593dc1a604147997bf9d4edb193d86df31f2df2727a289e88532aaefb3a47be6c6b3ad0997ecf6e929cd27fe361f2861a38bba390119fed5e50aa838d2d74c5dd2737b052b80b546f118a53ec5ea69dc3472e588c3120f11fa9007371d4f604606cc2637a497723634b1b631b97aa938528cbf984696d89b7469303cd83dc274702bd0908630465b6c773c42745020421442e90e8b51b2423b8510f86d3c5d6af8062468eb86c2d906ed21ccdc7fd3955af1ef775ccac76ce145f25d3cdc95a826c3e8df645ee6519eb82ffaf0f2ecba92813a4d67fa6ff57f8dc6bf6be058ac1adea1c16d69b8d0eb6d313b0852ba55d703dc3f6c53d3ca019294699c3e4274e4c111ab8db295777007c9ba56d4ff69f8ad16dd15fb5548203f8228a04ea86543dc69652a5ef93f65feca6aa2a11e78385a64300482e6406202df0b6da05fbbb12597ede9d31f90f24635e8a3c633990fbf48868ec5c4a9c9693fd91ba39f40ea33eec9d787bf74693bc0102968ddc024a4ae08f7e54f9d009bca74005c10a640e65f23b90fa198f2b0d73af2b1955e1209f81f42cda574cb27569c368a3ddc0bea9f6544afcae51a2d0dbc1009c935a5b6812fd9d1c139499d6c2e3a2fe40443a6ac505db84700104a8c90a60dc35a1fc72a2f3b3db510a54e6f92fb728dd0df57c612774ae6062fe15e985422a426c43b0fe271293a3b31c12efa675bf4926b9e43b12c47c2a5d155cac6e972b108a1e3e74570450e58991ea16d2cba0825f466cfef6e73b7fc88b1aaa6383ea4319798c496a74f0a0c3e71daa376635c772ebfcc7e319ad202f59fff593d5973dac5c96c0c15513bbfe137b8570b7775ffb9050639b0d0e4026e46d61825b916fb3bb3c0c0e3f513cb006919b975277c8e1640c7f85635a6ac29db2348d86b7d2f4117c9297197fa81d9ba74f223508c7e1cb6829bc8952e76f17cee93877b795e6d21bae8be1a72d20dc6ea42e84e53874705a49d0343ab7597610274da194693054f1be31a1b168d15c81926bd9a049cf5d69e1fdcac3aec43dc5fe376b6beb0a11dd825f9114e888f24a1d122fc4d2c519367824ac48e05a494ef528c5dda51ffcfa65bea71619355e6506915322aa4d38919ea158f47b48f5ba6d0939e45e7c47e25e76e43ec02dce08c40c9c8f25db2aac519be2ac0b5621908f949e5157ead7a490e2196684dda16653033c0074e6802f7ecd3880a7571513219cdb502498b435370df95f422fa22c25ba2f54a7f16d5903d84547398c5a9c68eae9fcce253ded5f1cc6816eb43de036913a3b2b2b77c06203ff49ed3163cfc745df5041f2e1d6cb8e16ee848ac65ddb17dcc5924c9bfd5632bfe5dd30a6c689b8a63aa976289793c3fc927e8ecf641530a3208eee7b740ea7233d1fb40c96c9707ce31a4d405b1504883b71680ca47ae682559988d5c81f69265280be320454dfb3bd976b60b3227e232835f3b9751c3679fb18ad8929e73dc033bef4cdf2dd03521ec79c05106297245983a01e806b816fb62d51c3fba668fcd9769b6e1bff8323927234d77753f4184381d6fdc132466a487387b6b9011f3a2de5b234e33357db91cf0964cd2b4d228e8b4f89eef6e81a001b086e1540af2066123822d3ad84a769ed3740a36560adebd566ba0b54853b0ec64b9b034785857ef14f46078ddcf5edb36a0a0b04aae3396fe97f45efa11b38f3c0ae7b651f6ac4243098c27467bb302ccaa31246f86b6bfdfec12d6b856a5504703736532f2f4a0e80634ecadac43348e19ef247b2c451f868007eea22d2bfce9c5027860cc33bab9594c193fbac6fdd2a485b4289f137d7042dda9b78854178024391a8183eaaab7e277ad5f243c8b15ec9e7fd41aeb66d1641eb1f2256f3c7af9072748aa43be8d24587b6136149f3c248aa185613f3f70a7ab1a22fba90ff95608593f50b400a15d43fd50074760eff65cd6781db93e6debc4ba1423143d206fd8c8455707bd5aaf033daaeb9f5c84b54f6001b7481287f102adf67adb99ea71dedf4b2568b101ab4c5d89632b1da4fc3582eee7a02833fb3feb9da03c41bf91e87e0e541a8140133c8472fc7051dab3d1594bc9a6486130e7c0b509f3dcfed98c7d6bcc693785080d52db2932529db1c83ee657be37943af2623d780569753426aa7c85072db39bab22582adce65660e04440f600a04ca83880b63b6f732edd6c738ab36479b1a7a852ecb38c781be1497e60afe62d69d5bf1c3a525c592eb65c075e208a04d3d46b12b1813cf60f73e4328cd3c885dd5bcebfe309c44353c5dee040cb5df8053ef2658ff98f5151f012fb2d0f4febdb755187e0cdb64d5a1dee13ddcfa3ee1c9c45cab2c003435cbd36af60b1a173dd72463aca9e62ae724a1fe650f6e026b5935b957599b1e05d2de1adbe2b4a135db1a05a9f662a5d8fbac223494fba9dd6f8909da047af8cc113b65ba6b0ff940c384e0618ac6bc7628ee91eccfe87508fe22cf26cb0c0ac250ef8429a383da8e87e19d5b074f0b1bc19a5c45ec30009a346064818248ad78440d71e10b76ca6bfb9bffdd39d680e8f019eb8ca24358f14a27eac784f7c87e469bcfad8edfba5249cd46b8b2532d056b5084472cc5e78ed430faba2bb91938bc9c0402c541f336b2f078216dc5e412b36f9448c071cb52de8c8ab13bd84285739910822fc6fcfb3e074e060f9d3a357dcfee7736906053e95c4df75e6c97b43438abf8d14ed87e491205ef5ba05bac138e9836ce951e0d2273fede26efc63f3c8668104cbbbf6fdf7a61afca3b999e63dec926c39a9f523875dedbd717668e1f24e33821d278e02e14f412d1fdbf3d32f415b1856d0bae19dfdc4530a5b1ddca71e1884cc77f81fe7f9c4b4b584a4eacda434711540dda618e3c762b8accb884520567c92f1267d908611f611b30b8c8f8532eef4c4592366bb56a23b157801cdca4ff4fb270340ae3638ba969bb12c076eac64815900338614e5f496d8f8666ef2b50d33128cbb1e77987da36c7f6f15bbe4e3c21dc2dd307517d8f728d00134d8ba3f79253e18c1ee4d8210ee159babce4e4276ab17bd928e90481c346ed2b83eef9195aeb07a6c5498c788010542ee3a4e2a7405b63c0026d30851ff28768a9c3d1959efd052c066d3e393dd4251de782040b13a2faeec27f78deb8db5f6b06763242506e008edddd19bdb51fadf4eafc714f5cc72f4cdb0de38c7be911466010cdfda3f46ee78297e849c66f61e0f597121c477ad1bf1539a317a0a9fc97ea06208777e931994a8e370b850c685a7a012606d4bcf95e1ec9a39bc1a7a69272129692c5d86377f609f96cb82c212252a034095310c8f606899f794865e5c03c70af4081995d135223ccf7ce834d90bd8bc2e9b4d33e23002df8ebb118cb1ec46c0acb7060e257f8142e5d20c525b8a5eab9648ba1eb3ebb5e6cbb3da096f1c97d1b8376d5bd8bd649ea73d3be2da06e926756b95e1c3e70e6ea9c21edb3fa0fbfb8602d4a1a1b971484a2d67598a20c0cb4520eb66a02fe96cabdb1990ad98308935d94c15e77385ebb36d8df6cb1074dcf1dc3b4925aa6064a853434ad87d49ad7378359db57b243d957669e7d91554e4d20a038189d88e7af87ee5d1df687ef97fe283a27b5cbaa91a747ee1b8c841a3a08501df271b49d5ce07242ee4979c432849708670cdb1bf02e06b12fc126548bd4f5a7eaf3457012d179c0493ae4a5005d783f221f8e1050e08e6fc90d5171a496742f4f046189709494000cb3180edf6ee98de540b8e9f3915d5ce95d7e0b570ed884cfd07e142ed0f51ed04021dcd0b7629c4d398416de3a9ea9f7772dcb108ca66bba2c97d0a6d7931e6f647e606497844ffde6b7740b82416ed6011f3a306c96b5d12bf9b573013763a37981d5debd631645d2a767ccd5ff9b980fc34b9c488fdeaae87f0c13c8d5edd4541c53b293215b3b572bc56b0b660c51d5f16f8c37470422bd01fe65c11f6d13144d55944927138ca4c95304ce01b30d368efe1f7959ad6a9fdbf884eb05e57c1637c8413813e941564e2e245c9d0c6ed41bb5d29b2871929558659a423381b68bd617a41da0c1780eacd61926550d1b4c9bbfe66a71e7a109b4abfc516980360eaac71347ba1e9a7106fd9360f501359ac9efce76fc41a1c82903eab10dae5d5592aeeeb3d5e8748214d38da4198640ec37da6f32a9ddb4520b6319bc2d132c7c123a58738d8da91f91f5defa6ead6cbe294e6520c9191b8d5a462396187701bb2271f9c23f7d138dd598afbafc67e93588091505a92305671e322cdb40ae9f96fb1cf8cccaf29e64a00eaaedf06a84f4ad61dd278cdba6bec100a33d4bee98892c6e325642f228fb9e9dffe57e9555607897837ec8dd8c2f9f42a3c027bdc1b896ec86a4148052055287a5b61b0de1ace46fbcf7b26db59e765f685de2369de91b2052691f58299cb9bb930d956047399bdbf826e3ad14803c38461d39a3c59bb058cc67c4a3906b92e01900b8e258edd0dab81eda349cd9200fa7567137910fedee8aa15c3e35cec11dd4092a8fd1dd763ab68075402839b064a6d957736211131846702f29c672e916add383b0023a07bd4b04732a9e155a03f470ad68f664b9eae4aecdbfc0643dd27ed27dd279d7131ddb8f1ac64d47dba12ac01a49aaf10f95889ec97669de9547cb627903491f5595776518ac9fe11ec0734371db552e193e73397d01cb1a8f9ecf484de4a026356c02ed2f3b2105bdada894877eb80d3454a2205d726cc3fdd1d157236c843a3ef2b18db14eb15f6fa601a683d0446dcb3f5afbd95b17c0f2e0d08a46c0e29e53e96c767d8f42dbd7692c72f7efe711da158b6c59e97b40273e0ef220d7c028de1b88241611edfba0d28e20a0930e849c421c88a54164b1e3017e4ea1024c18afef52cf73bcaa1d9870569c5d58ce35cdd5954a519f1c21639b240e24a3f5df3e5b36ffb066abd3b046a48d5d87a5349973b26d46b710be2d5790c28c640478529f00b1d5e13ac5c40cc7c3b815502837ccdc8b268808c629322add1816ee3e9fa96a05299134115df1ace0c06d32c7bb7068c4833289cdad36b43fb3398ba58ed18b72d2a03bc725ce855193649fedb68760dd19b675ff580abf5110f19b835d1b790286f45dd324654b82f2bc99fcaa22b3751250d1d4df1e9b624a6df4e83d4f50c321db8dbe5ca209e236d1123502f9373f6eb47d4f48e107d79eb970de244563520fe85049ebcdc4b458772d728f086045f0c73d4cf338dcc20a1a22be1e75843cf72ce04c789ab037860f19f5e22b687f1efdcd413f9701fea866f90e57b846a8cf49c88d27bab8aea637f69483679cd6f6c388c77761623dbcfbe9281cb72a077a91c74cdd745c3dff020dd40d66627ec0496c9b231b7db7cd6d22d9463ee667474a8716afec2d5919a7877fde093834987ec9d980834aa587169a2da1f787f8d009d041880ef903d684558f3077aae7715191bfd78dc2c67204e85894dd5d4575298a1689563accadee891942259e66759e9abf6050f52486255dc124d57154adc915cee2273ce2fa9c7277233df1f43e2e01cd9364cc032b774fd523abe5d6741abe3c68ebe31ce622d046bd4cc2fe2e69ab0390680408cd124e7da036bad2f8f9a217617a008bf09ee8bb800bbab99c2c23aab51ef2b00e8d8a19e252c3fbeffedc9097d760308e392c09fd3f28f31c914ea006d6b8024ff2dd26fac22fbd0062a815f21a24b6c0496ffa9e6dc6e07194866d63cfb8cbb03db20bcb8f581b833493956d1bafaa5540f41894070d4cc3f51d55cb5922ed03157396b685c2f42b5ad363dae37966d20a4d96db704db0420cea128dc920b581b961778a6c7cdb980cca4fbaf5e63cb2dbca1e6c1705ebb961c1cdf68e5ee709d78d653c739c060666ad05ce433ef5fb650011ffc66339ab32a7a8847ca7ca8ebf12c194cd9b4d7d6ebfa7b2a5fe1b4817a2479caf821f7b3fd22306479a96c6b95ecb7a715cc7ecaab97f5ca5ad79ae6f77bc56b4a1c32ffac3bb5ce37f71e81f3b407c7296b1259694dae5e2e6ce0ebaab840709594fc9ff35f6cbbd3c7efbba5b29beea3b68b33bd800a059fbf47b304a37c21e5a09a0355061935f29f691330ce14d80c8bf9a9e5747861dc1aca9001b527c087534dfd36c68a052c0c8ffe69a771b85545c4f0360ab3a172f515e8b4a54d016dcad1fecebe1a82624a7315653400f71ceb73aa44cac131f0e70083da1ddd9b8eedb5a4fee35d986918f73a5adfe7f4f8feccbde9a289b9697b5d6a4ef28bb312dacf4bd4c39f9347cd3532dfe9bb39d24d36ec8dd97b09f1f03c4984eded34ec1256998156bb3415258b9a986813c3d5b1b40679cbc5f5e7e22b170a066a764a1b40f212a975bac41f10281b0ad3b1f0c84acc07659006806ad8d53128577e98a66d1df6753b22dcf973dd54537b3bd8833ebef73fe1d1d16b8799ef7aaf436a0547db32a12b80c2ab1ef8a86b237c6b65e863c33de792f9a6c9c4e475bed694a27b969ef2950c0283d984bc661d40b84e4e9436c982fdee38760359bac8af1ed5addeeb2aed0902ac3427ac888099fa3cb8ffa7b75bc4aff9e51eb194a39a7cb8a3e60f412d1d65078e21e1a8c3ea4b0656ebd24ddfdbbd9c0fd1c2ef0fad239d26855238f5ddf5aca0d3c4ca634d5cd31ff748e5d8f300e38cdead5c3302ba62c19b3b2a097c03d039ccb7aca196384eeac06c5f5cbb8e8f255c7c561103fc28273d35caf6e896ba7e0fafe2668fb79d00f8767b3b480303008459f46623d26b511e79b3ba3fd04eb3caa7dbb93c05e36edff0f8182206b379b7a6284e3a0a5f29f7d089b476ac031a19786c84497f18a342940d9cc901e7107068aafed996bc5d13dad250a56451edf748148a6c08c34c133b9d3b85e9465b0f70e80b5f705a19a722c0094b7e0e42cfc5b40a70be3937ea5461f07d4c1d6c4c9e5af17131415e586e3caef214bd7f5c49bb3db7dd6d44f351dad4bc17b1344bc619841ce40416db80e9add7573d8cdd7d582fc33d7dcf9ea5fe0f96b36cbbdd92555b868b0e6456d399921510daacfea7c99e96056ef24e3e36f32391411dc3c180d21443cb5e37e5d346e061ed66efc12c4ab9895a35dae45cdba63aa149cc691c3737eb43aed2182a3cfbafad87dfd0e22911a5ce7c224782db4af1c6fc7fa79dbab6d6db6a20f5132e6712623e9e85bfb46fb7795ddee0e8960ffc22e84746a1d05e096cf1e8fc1f48ffbcaaeb656ccb16c477dbbf82b0c3afc2f6a706fdf0b5667af0386ebcad54507051ba087fc128b43a1333659f1e64789f29efbb5cd44a005bebd8aeabcacf9f84eef5c211e9fca4a7d0525b653080734d61d716ccf29ac79fa934456581db2963988c79295451ab71f3db74dfdc36fe57c8d6e91c68882dce7267e070639184f881bb00160f5d2940fafb4f3d21fc8dfbc976ef1d9b45707ad02bd298cc0894ea23110b46e93179ddf207ee56dadee121fd7f4347254fd40580678bf5277b4937282ec69ccc4ed7e4b6fb449879a1d5086055a014a75b8a225669f8d3a723ef9d5ac20145b2970e4b5a5126a96ea86016bf6faada102c22caf22c2beb1f21e43af60969637e5ed7fd459df29405fe0b66e719ced9244e5c25bfb883f1e522317187d4baf8d19aedfa3b5949fe805539013d91845176e7428d54384175c1b137a6fe514e534034e5916e7286ab93b4ece5e22168891394d6827455f58f7f2c84a56a770495c44bacd3ec5818ecfc88d513dbe707ec6feb6674b8f23f9dd5d8cb6069cd4f5eb86b6a6c2859baba681e8f4b5ff2f64888525774492ce70832c95aece77d2d535971ed7e38bf9cbb0c905fff3d8c430df987407e2da829038e3c99b2e902b732e6c561895af70d703d58318681acdf1a4a6210b505d656539c32dda9bcf7ec52f0879c931d33183b2351a3ed08dc037442ad77a7712476c916d7b368deb04e81f2f61abbfa2562ce13d26db3cfa6517a847a5b5721f50875b308148ff399b9b0bde8f5ad35ef734d31ad3e29f578544d0a7d8436bcefce1a0de72b8a8b3b35b8d4b7b67711425925a5d5d17cc7468bc13084fbe55cd1ce6008b5e6878f9f080cd9f506d231c1deee691ead561b1bc519f790cf06a6d0f76928290a0c2227e67224c30f8e43d94c88d83b7cfca0501ada8daacd4cbc1c5d62219f8c296bd7bbfdbded4c43ec8bbe27e21afd2c908adfa3c1fc5666c88bdaa1c6188a2bac89126e21b7bc57b93c0a30248d76bcf35c0130f921754dad8926f339e4a6fe3998be58e6f538ddffcb1b0e7d40dace69fe79f9c6bf46f6e10f58bff78f8d04e68f491edd11bdba4abbd2436529614e22ee7019e3c19bab3c86795693ac6fd52359278204a05207444c78423bb6ff2dc18e41f5c68ea95621d92e1cbf9ece63c703751de75750114c6f5b68ee078998ac15216e931b55510c7a2d4983998c7d2e7bb5e6e9ebaf89bb6163a86614f1cd6a16f8024c2df5b483d46ec092e3da4ccb62aceb235a764fd73153b68891be31998657cab415a7623c92ebba0b1324187727f904aec70b0611a4a55a12a4ae155c442903bb0ef89977cf54b125fb97d369846e2add9052ee2952af2280410ce8358c70b63e091e7460d04c7d25f92723632882cb04de6f229fb5661d23243f8a6d8ef2999e19e9c4b6d4bde7392e6b611a7ffd68985e12577f638ce49ca179505023d3f3d8374487c22434833f8aa926a09704dd00395163347436ebfe42b7c08bfa3411ed1459b9c4defad5039a11c2f480b9aebcc8566f52f334e14b8432f5d483966fb54550d60bdf42ecbe93da29250e75d48146ad6648ff6b265a2ef18ceea24bfd8b24ce70e47b3b5742ec41494babc4d38388f325c8ba2610dd83f44661d404b4b5e505a933ac9c4ad4fa511f359a66ef536f9ca23ddb750368a56b69b6366b92780414876bc264c3392b5878382c72ddc41282b49688fbdea1b5c0d10020c68ef9857a96aa4d4ebcde659ed663c428759780e2abc1a901094cd87ade7cfc2e32e51498d3ec0db3c0e9daa25f225a28d383122b3b3ac51bc3e09aee7ade268efa83a725e74600df25690925707398178415a6650a0cf8da6e906cf3cfeca1484bd6724f9dcfc2a53f62df98e8020dfc6f14d85cbceef789d879aa6d9d380c1edae1e6477fbbce67f3b08f8641527879e6e3b412a74e71478b3f0f401be5679077afbb01d88e1242bb8259ffc81fbd6c88fddc6c52014b253f37d3f3884b0176e74c447ef887962b45a0c531a84b1557095b098d583e83e9e5dead2b41e6a2692c6dc63770f903f52dafc63982fc80a7709363495c1f15c6f92cee6bb928ccd33c06cfe0347ce607ced3f0f853d1b2ccc9773d1bf1ac86197d7a71edbd2e607dc0d9bbe3b0a505fc68c121a5fca2dcdd3b81f2c23dcb5c35d2c944709374767dfd7ecf235f30fcf74fcb5f4be144b9026471a2e4582b4f31cb28098d69413250f88e99ed3c9c4f416428ca56d9e2925bf0483418cde7f525a04c92da6c3d26c9282cde0ccf8c097f7643f34ef3365cdd085a0dd9c1fd7fa7efa1a38d5ce27f73993278d2dd6cd2fe4f5f2e586ee58acac41e7a453f20f7dd5854a76872f62894d5a720402124a0679cfc7b7633961c55bab2767cb185e1475d8810c79aebb2dcb6e0cfb4a4fe0092db6fae053d2ee147b6c0f1b71fa47a5168eadb0848e28b92ab7aa1236784a26b7dcc46ec7f383bbbf7051f619a897e04ba414c52d808b8dc7dd29617784e7a938c793b594981614bb6b2f8a36609c92933ed2b34334d15bfae39b6b0b4d34e5d9435df04b6933d57e83ced845d20e9740a65627fe749823ceaac0a6540401c46610c60d41289059e65319900c3805a0b49696a35bbee48edadd42168895a33d6a493ea46de83f8e4506f3cc27b6c774c5808b4e845369859149143ed523b1db457e179a4fbb2e47114f32b2aaa3d2575ea4cdc53fdaecc499103fd438bd0edc16cbc4f144765f92cd8e2114986c02018faad399ce8a5bdb59a97ce5114003df25e535a4aa6a4db918a50d1f58e7fcbd8a56fa353684153a5a5bb9062ba156d4cb197d4756b5b47217296833d678031ba8837fa0a0660983c9ca95b58cc293006567a0a969084e21308dc9f96b42fc441070d8ed917e537434d71811097641a1bdd27bdffaabd302b8c16bec11c3c05b7faa13d859dd89e79d98a94510853baef965bb8deb15c0bc0fb151fac98aee5842f8f6fa1f43e29a0f1f7f8b74cbf2025b50f8b8d47fcae407f4fe9c683f673eaeba0028db86c0d57f8a1499c6741850b0c4fa986ed08e7cd952e22db004adebcf450dc5d4a3f169b0aa4a4506555f6ee688c9e1057a4ec45fd3a723dc7fb31c765c1f175aa9a08e10120f764e331e0f48c3466a54dea5cc00b5d6a3e84baf99b441aac5750caba1e81a3b7124220b26613dc46e41145f3fc97ce634a723929a71fcd6cafec0cf69564e20aedd09a6937b4bed9a155a491078de140e961553fbc4cbed4889566233802a43be5b2533c69e48af2762c2774c0fe7b2ce65cbd1703770cc2243248962ea8c0a5f92b464b2a2aff73f84fcf5fc832dec2108949eb5d459eb47594a872c4c7e17f2b63d4aa6dc40b074d9d6c7fe0f32b457b5f119996d93eb505e0709c4b331702c9725668c6d806dc634f703a023753dade49ce6f4fcf1c8a0d06b04ec921c761642fbbec6c9b0f88746eb26b23797d7ff965d67be6106dd166909139c318f502b9daf39c88d5022bfc8302c81f4c50fa1c67e3140dc3b83d412daf02c51b3028c86efbe4b57fa405aaec7d724326d1aabef6a434d7a7e7a3faba00a59208fbe348a3df7970e6118af78987143615ea09efef965c54a0b8e7841a7642165cadbe0187ffdf17f68e775963e94f629b35f18edb009f533da3143706f2f268632ce09c23c8fcdae722b8bad7d381f14e486ae9e1317aadef02b0aa765e0c551274137bcf41c97adcdedbf3ef5ccf346c5bfdb9a969828bd9d4e237f8f6855474ea1734042572617b427bb90988200c69f232af29274770772347dd08791ec8c60e2185734e6ae7772b4deaeede6e57c129f1b8100aba1469fb552743901c2bf81b89635e6dd472e1ab69bc8560657412bcc251adc55d6e52603eb6c92c59fb94035ee8c612969a875d832d216ed4018ff921144b6cea370068752d291242bc607ecc2ac1a38c1216e0bb25d6991251e365f7bf7d197e2a7e0bc31c962cce3e22acfcf0d3cae2dd38288328e99fae6b6dcb5182bfb27b1503af577e78d8567ceea932c32e766b3518522561bd49cba1adeca8960b2b3eae2a77110d1568b900d089ac128528a851c99165c950a93c52c37dc8fc777cd3ff60bc8b283750057079479c7ea3831655763970fe2c945350622a4c632a2db4043db059008117eb148acb579ca1f3f38609b9934be1f18da3fb623dd38acb7088f525a3a6c4b2997911d84d415c05a49d54ecd2918e1d4f62a5a1ea02dc7764a76bd43999531c3a7e106f79676d16fb22fb55136929b73b5badf0e5c772d35152c22223725e0b70b7ac3e3d362c78deaf2b97f07963d33350cea2be81abf0ee870cec484370a9a55157acc5e5c3eaef5522fa8f1a755b7772f2d77433ae873d9e8837d7ab62083422faa0dc90f1d8e9f62dd08a7d646ba6eeb407ee0df30c13ead0f5a9f7f61c3f61856c4b994fd0d6463fcd4a22ce05afde23582cf20df52a77106e25178ad1e069622c76e153c0cbcf471a42f8d5a3d6af2ce42a7a812e5342b275f6b80440f87dca534ccbae0d835e9d2467dad6a015d40112f7f810b342cebb5cff992236832d600b91b81aead2b8d355cbe1c0922e6f0fcd6e6b53f5840ef3c0c6bee0761f8b448988ea77437d2fe7578c5b2b0ef4dbb5d067215c472b0c7ef483b33d1da925500cd3c492d49df2269e979c76e4bed6f63d22bdd31cf9069872dd6da0ac64deada140fd8dbc7b4eccc6b6e670efe8a96ab7c6e9ad18a7bb1ce3026221fe5a8ad83b5924f58949756a2991ae03e26b7e776b6db7334b8b55ed510f5963cce08485f63dd86ad9d346cfe2194e0d4ee4db6337fcc159b513ea429408a3101de102df8066365b23f8589d583e768cafbd7bddd76742b1ebc09970f82062ab4cff119f0dc2312eb62e2aa75ea44f508b64e8a8b9aecd171a887fb4cae0737bccc67cbeadea35a6b29c913792f631b4bcfdda3711d8ddaa7cc7e5fa69707986116bfc13d68454c2677e2df3762a8b65090128247086f37e9962ec1d8ed26893f07c2e831c8e57b18df37684a8ed17d448c93d3b504c1faf14850abccb527c52108ececd2f7c1091239576d0145962bb02f1f72df068c5bcbae3dbda2d501760b6686fb55298d09cda2ca011146f374a8fc2e43e00fac22f33fd829da26c158226bed2709ba6b373fbf96a04748a3943ac24e1a3b124d56cecfe2e00e65e84eb04f6e6615712039e8336dc29721b1413155d47df26265752187868d1405fb1d67772817560babdbbab3d765790d4b51aa2c6abc2d72241eb045a9ec8769018e055eac826fd97e4609501d8d324e8b8e52a8405e9a68feea2dbd44ba5733e6c4fed2296b0676ea3ea8bd0db28b3fc81d48ac794932ce11a3a07a819fc1ec3644e539d6871bc615e10727fedea237aaec85733c415c0d375b124858ad49ef4da279421231d7b8efc34ad3c163658657968931aa10b664aa203ce9e1fa67fca25c3497eb70ee3bf2439766fa17f06b9c66a9aa89d0ed21bca88b60ec1e8a1018f0da95c7b91bb81447cebd8b9429d46b7d6a468d11374f3219cce7ff7192073b9948a39386e5b2cff970786d0b04138b2d9c096d846af090617ba9545f22c3539e1a24101c7a02eb9c54a3696c22af9acdcc3b07b05dd9f9fd9d0a5ff9a0a4f789fecf8f545799d2814bc143068096146444b86cdfebab9a9e4de60c82e02f0a7b4f6aac396a825df2446ccf92b3a0bd06ba1db054dac848c711f732cf104cd0e007e8a5b2f2357a07dd7e44745d4719dfd74b0475599c7d61db1341d112c409c1deef94646f52419319cf4ba202641e1594d332fd1b1e51b43baa5040a3e10d93569ef56c19d2f08415136b01d38ab91605d2f2137c4febf813befaa96f569ec88dcdc6309668ee6a000417819c7fb2b5bf1e1fdebfb54063588503650d21415f94afde6f0f591ad6819f99bca896971dcddac5c1cb5f80ba1c5d865260e4b9365b0987b40c28ccb3138d52b653e108eb53fc0c714270c1167312568034619c69b02d8fb0babcd200e34f8f64dccc8b23372bcdec3b4a601d50df33bbe3c8114d53bae0445f6c7e40f32b7fdbc7022bf767b26922b0ef818a28af8908b27ec13723a00d98c0057e4a4fa68f96d45ec725090c3bb9a58a00724e2e55848ea4db794232cbec7227b0ad89f03e81ead1b8ab1dabfb4e5aae3375996036a051db98bf175fb41ad9c52b3600344363237fa4aa37dc8f18b8aea1793f7398ceb6baa607b018e35fa3381a3d8306966a24603979cdc482533c1e1b4d4b603355086b812e6a2693a440ce88451a56b5069b3a2082ea7e24a40ea1f18a4c08262909e558b13371dffb3ea4ebdc60bb0abdd157dd5c234d4a8f4f649c7ee4f5141892a41910cffc4c380f5ea9f84cf31cf08d187499a67dce3e1fd8c2d2909ffefa2a8763a8cd749ca37e289bd5456d11f82251a64fdce166d47cc9a804950cc17361f078815814d0688ea2860ade3ee4ae3497de75784765ec4e1dd330478a8fb037d6597fce8664739232aa44e3f16e50dfce67ef8c38f6a7e84bc37ab3bed2a6093d800f05477921d4b95a95dac133cc13499cd01788b9ca476d5c559d33986d714ca919795e64d74e8b32c682f71ec3f1e0423e5fa16349e6c262f9687b2096a8920c60438604b0d7014882520acd98332858793efcdc0a16d332395eedf91296dc0113c11757c8b8c845278499fc9b7eca5f6f1a3cefe921537c804c8a4fa103bd6c88e28e9185e805633e4e974bf350b82080125011e687addc4e11ad0fadfffea52276e6d22d27be5f33e26c5f252c7536bbb0e25ad73155175ddecc661c2958cc4cfbef95692033c03df2a6ac95402e787d52d1de785f324f6c671f105ab1c7b366fc6480514f9306fa21115343c6d9b1411e24e121cc07d4245858597eb334a0a645c68262c7a0bf28201630c468e4522d58becd0a10498e8048015d15f2eb028893659b47a55723a2d66a300dd3ff8d7eb765941c1ac7a7b85fccd80c32ffaabbe995300223c55e7cba9fcc1c67e509baf3c3f44d0640d5089b65e903d8069507da85351a0ff754a6627d5b054833c10b34ef34bc1f80a53d75b90457cea2cff524d0ec3ef0382b5c895063edcd3adf22d7ef18ffd66a5e442954142de18ce16f5a965237072b4adfa4a6aed196d39b922bd212279e37d2ebca21783d523230b5af9d59f4e54d013fcc5a32e010e2c88f7bc1f51e812a5ec0829b411d22f76616c96a6b466d1312bfda0f7f46fb68217866bc215d69e1cab8c0a2135f1e5971fdb85f3e5484c3756d955c550a82d705951e935202ff9a341c0035f58cae64f60f760d288c91e4ca500ff8af1741344aabeb91c0b63f35beadad909c765f735c70b5ebf6694f28b3b2cfc4bff80d7b582c7c78a3595c954100869f9fb3513022591643618c2d42945fbeedcf947204ce88faeee265fb0115264f20a8794777a15fba74cd300287817ed3adc3278b5c00e9a2b8e9dcd1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
