<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ecbd5b7020244ccdc05cbe3756215c1da1da3364b4a9d109eb426d7646ecc6b65a6bf1ada53eab89427a02d37074cc615e42aa21daee7c10afac44e93d4bc755d884d807c13508a87101d3afa2e709da6606be0ac7e3a004dbef3127175a98d74615f2cb8d6cd09e3cb072a8eb163421c81c023d6eb404e8dcb975963d7a2a2cc617ccdcdfe0c0150357a52d896d0b01bd78f8faedc9762e11abe2e4268e4662bae3e7e1b294817296b858273fa35b37606d90e6983e1b2ab3a75395a3359e1c6ba1233b837cabfa506a71af87676629b0e529957cc2685c2236c9857f1ca870c3de3025f0ee5273ab245832b02f66ddce3f4be2957d9137ed70e3902c23dad8aee3b66f8092ea45a5ed64673e6438da8c83595cb293146cee230fd46da22bb59df374c795a534045406461daea20380926bffccd362e9c1ca65c35bc076dbd90d3377b68dd289402c359025bcc8993e59de0ad98c07f2a180be16e026435dd60b5bf9d765af1128dd2607aa9a72ab3f72f6c3ee44addc3b259d2291c5eb35ba29282b92f6a08b71da1b1ec87768bb9d9002d0befacfbba895ee62132aad2df210f877a88b93196685aec42a7fca40cd725b9621df0d0cdc2b3456685417baa66dc078c7dc545031367dcd0892b1a84b4ab6193989eaefd15016efe37922d8958a2605f52226bdc132979802ab469bd9247affc08349e79db83494dd7c3d4c1bc5fd593e90419d0de1825c5b6996922b38b3633fef898ff035ab27de278698cdf7c13820ac0faefd42f1f38d16830a9c7b0d80b1550e8596112029950670de89f9d8253601e9908ce8e5470b340e7ae45068dd3c7294be38d845256a5ac4293e343a3e3cdd82870f9879836b6d7bf42e1ad31159892d83a71003fe3ef401f39d95e20b9b7c214c892fe653bc5a59ea95ce41c1ee7d71e239e8c4487b43af605db6e2ce403862b47a3e91705f76f5e22eebf9ea47bd946d8d746dd448fbc7c4b62fc873140fcaf3b6879a19dd6ca958fdca27c5fe05996a85eea1d9c559e09b8392bc2803ea60a2d1b4b4f24844ad6330a0474c3698678a74c67b44e6ceeed91d594b7f23301725d02047a5dca488ee05c0de1282f8ac1d831caddcc0bf49c4a2a36b46020dc5630af1d5ca509a497f64c3d594c677feca40f752830193f670a3358b6018634f40d1c18f5af8481ad227658e26fbbe66a79b26fa352759fd90cac11b19cd4dea70a83ae7aa3ab02cef9c27e165ae9c4d8b240dbdae1dc0d5664037d8e539ebc6c319a131c365c03c7636dc7cc397c46af339ed95987c3dff727ae8fadd1f5fc44a3151f732632390445bf72ef7493d31938993a957e698a0a822c7fabb007a4affed0be783f78275b52f251fde2b2fd2b423ec737f628ecd2d203405b0cc8f9efbb1ca0e04d0f85ffe75b918c9382e37a341ebb4e34f708297f1ac274cd80d320b0f62d07cc55189b6ccc05243467e2fac5f300aad89228acc96a3cfabc4c51d0540a4a02c92b4a1a09aab678ba7c7b9d771681d6fe03ff0fa60a6aed707d9529657bc40dc547cc3e23ff56f252b87e20bf7e86bcdf68ab6bbf49c3a9d40d70cbbf4ed87e287aaeec875b156610e876aed23a13bfe9736c98fb435a15fe789b7b0ca376f62658f7704815f2fd09815b0a0f5ea5846d66596e682040bf67d12918b0304ad3673972840f76b652107fa4c0c377c494282a51aae7eb5489685d27c2a730740378755c5dcff9172132569b8ed173d4813dbe90d750611fcf986f0f2628cacc9910deaf126020b8c96b0104cd162475bb3de7d8fd10170250323c78ffdee1458859d749e745c2422b32a8765f0a0d28472863533ecaa49cc75848b05fcd4492e446faa6ac5bac024fee951b9405c4844e62989fd2ddb925e481f0abd7d1429431863e42f36e4d0b692e40a24442ab69b99a6d5c1fd43add560bf606c0ddf5703c7dce1e5c153cc085fb09b6a0d42a4247f4923c7dc5d8dac55f38bc8a1fc608173ef9766ca6b1430aaf0cc0207fe13598e8f0dcb13660644ff0c1e54655991b5b14be695ffc8b10e23e2999909e1ee6e7e6eab4fbe5293d2ac686a2ae10500c592b1d6475a395d770c100c3fd437516eb585e5e340fe1650520730ee2181a7c3348aea2e8e33ed571d434af0bab7570121d96ca6ff15f0226d544994ed2f21d2485b09951de38bea0e4404c70a5461a6bf1cc1341341761b3efaedde8159b48f231e363b94233538f019f7e471ce6c54777dd803dbca6eeaf49d1ed9eab103ac02db56827b9d36a588c1fe883fafb3f30c037a31a7eacd9992fd2c188f9f475956af2835c1d425db1ab94913f6f012f21d5d6cf2f28c9a7d209d2f2ba3c602e27a8014b688a3a7b9d64559719ba37434fbef892208dbd43915cfa5a356bc6cd9932fc308e9caef99e8e1a99104687ae754c10d9ef0c327715afe2b33065d282aebfa8231d3fa7b85818602bff6b74e1db7e5891d2bc3f617b9c2fd50aa60c9809914d829bf96c6375bd4ed8ffb02308c2b30b95e9deb3e0ca6cc0d5945970ccee703d9d35156f0da1bc12d5fd3acf4324e8a6b80bb1a2bddcfc860df966ba80f6030ca5d61112dce5ab3ccdb407f686535cd0352db69efa4be469c91dd8b0b924f7348ca9939a73c10b2bb74ead3e6b28cbff42234869f32935fbb9a269145653230ec26d91317724834bef6cab15720a9f5ec9fb7462b4e18815f3d3cb0cb1a863fcd4ca16a1a2ec4e6514c31450b97291d25e101396e2c9b936042fb6915394b9ade451fe6553d346e9e8fee10de17437d23659511d774c97465bb3abda099af2ee38ba01365c505e3dfe48b299bd19820ea3d765b8d058aa06708567f4cc8e7787ae99ac1f70b1be909614dafa74ee124d01ccabff4d05c603ad8a7ed2aeeae6699a59d3f3d122f966936002cb6df63b0c7bad5bb8e11cf120d9d6dcebbf2e05bdd595d2c31aef04a8167388a07523ebb405bdf5319196b5fa24dc835e1a3d330a35fb7b689dacb7bd117067871a508df9edc392188418454a4ead7410dad328b8309d8948b5c8c21b8b71b5545be8297168de933cd5a3a67094eb73889e114c904aa9f572dbe27ce00e8d56cc726337c0c0f3f72cd705c64e7edb4a3e4bb446f2b8ed5dad0c23cd9a58b8a1cf01e4e88b2816619c138f18e8f2a07f4e0f1f56854f16644345f01e77090f419817d1e210baf8eb76a8f33e4947186a839364149f76a7521ec1403a5d2edd6c3ad482b63bace8735bc5a522dedb4b2deff116acbc90b13b616adcf36272ba4f1ed10442f0dc2e83886fff82de12b6d53bfa398e076fc605070e17b15801e6813cc9736b83fe3ff30ce7338dbe5a6d64ef66966974257c1cd53f3e1b0e157b4bc6648f2dd9704e4bbdf69337223cc9b12bddd95386305f1e34f16b1f2e952b8d8539fd6333d1f5e211a6cc9568657eb36aefc14e59ec86addfd81a866b657f49a5a7f6717af21d61d0962a505d3678714f970a6b97a7a9be307002aace5e622ca4f7232ab1f8b0f2f7dd0e5b9dccc16922c89f5aec589fcd96f6f9c1acded40285ccffabbc1ebccbaba7779995c1a162878b4b6d91ca5980ed06ad49a20b4cd198780095b5bfd467ababa3fe8c1e1a2eaea6565817b0fc8a092e68c38af0efecfd537bf8f4e9f2693bd83184e33a852cfcbbf83bd030ff9ba52b12e6902117af4c1e1d0691b79194ee0364cb8736d1ba665e63a0af269cb7a8a4ba3b2a7a8ef3df60c5df5babd8eaf3e36039f58f7ffd01f2f05537b9d3a6a0ae9738ae1a32d27e4e58be5c2b126f0a6f67032361157c9eba497fb88ceffa6ebf4b9a701a1bc1945b2f7b00b1309d28dfb2a9c07369143cdaa85594d99b1041476b04591dcd18d586d1800e6ce25e522d207e967cc1e9378dec139c88c7ec0e3f4b64c51e2841bcae65858a9f1ab76696d2280755b20fa10ef4b4d78b3a18452b823735b98d890d2fcd3f793d21c0a79ecace2a4ce54d4bb6648e137d3abfab80638015e224f5078c91ddc8d955bd18ec0befbba3ddaa734c4f9caec7087adcd5f187b46335f8d7db15b19437e6d34ff72a83d1080b124e9a1f2010c7cff3575ca5aa4217e4d7921055679b8fee4eeb87561115bf199e7e2458cf559dae539d64caf9b82d696925ebdd05347bdf283f6ce7f9e9ffb97791504901cb38d5a17cfd6fd5aedbe3bdfa943e170d642ab2659f6bd06ec3872881fff314c3d76daf9d92055d080cebc083799f5aaf5cea185fb1d73e5912307562e39fa121e57925ddb85308ded92e901d0df622ef3d9f21d4b9a9705aaa6e071c8b627c3f434e42ce2096c276fbf84c6fc30becac61bb689151402bf597bdcd8ce7aff39d17389350a0a65ceaf63aa1b85405cade0ee14b1b83aab76986577a63350be6f4555a752f5e67a0417df327a3e185888cc661313b30ea5f044ca6990ef9f4cb6e980d8036232e9584aeed22918208cdff18d641240cfd429bd666b1e2e4c7f6cc923e7bb668b8475b1ddf92aa9f7a13e41036f962649527c7b492355d90c1308099f53acaf3e1a4018512400c9c58a057524094b6820b4ad2e85cc4c80917af26cee5f514ff790ebbb7a1c475629e7f2dca8311189f5747a51da0c24a280f844845739d580d4964ea404b440deb30533eb36549d4e4a8c251b85b7be1a28899b1dd5c0bf02a3186fd4dd907481eb277d4c1bb534db93c8596d47b34b769ef7c90622f0a27d82fd9aa9e0ac7998268bde1911f9f1ca9ec68394d417c6028ac73af544d15c6782c2533cdddb9d077d93966cd991b1d7011695fd6b0a0034004985eb42d10fbbc1d5cfe0993e38617725dfe933f1cd0a4ca541c9666c9f0e842c2963a34ed5c3f1be067128a0eb7cd8b4b13dcc11cb0febcb51682714482398f609cf90f378aca9ef337e8287cec7cb5ea9a4ec61035960e6c11726b86888e4fc040ae4bb7998221d0e6ded0f60c9396d9adb5a68d444a2fa18db2af57f05a4f41587f938bf8ad5fbe7ba12356ccdf94e3f4126d6653253843206f83af73a23d20e117c5027b67997fcc0cfa4994ee31fe3cdea372f9817066b45385a4b2d1522557da87649425baeed1d8ff2fd0e9b51f042bebed524aa31345e7be9af3ca5057595670719416d3ab25fed90fff3ac80c8a2b8964581e6dbf098341288667336380a5d345ec3a3bb150749513904ae318bf7c218bf565a15f5923ea91c837d368b457c0a4688e3f0e3a93aa6ec9b74e7c9ed2231c706e187ba7fd1a0e32638866602b79a1d8bfa697c8724787c0f72e013ef17aead0e784d6cf30c16f814a54adf190f9323bad4606739aa9bfc9bf82220424e917feada3c34fc4fe56b4ffdf1932dea4f6e1ac53b791ef0bf26176c74b293b5545e9d6508d487fbbe20ce886134e20768d9b1b07c5ba4e7e789056b3fb780a6beb5fcc8c66dace6f5716bee650efc205e1ead7f4cae35fcb65593e6f5a48bbfbfeeb122799b71655c37e01fe9757478acdec58d56d8e93a4d4b26a03ce7a610c5eb68f578ea110029ae6b23570a152ac7fe5838456c3442ac92dc356711b91ab8e8fdd939b75ff1001d5d9d5e6ebfbb8d5dbd2b120b711b1427fa6f820ecf981c2f5928f0f189d7122ed428285fb02ecf20ad5579a24062503d96c725c3c2807fea31086d07926430faf50d87ba8ef9efb7dad72fdcf4203025aab1c67f1e69dfa98284757ac959ba6614934ff8b5af4a5368147b9917a5835f7d4ab8042a2d72cb076c17d60ada88fe07da7c2f67b6ff00c7098feb03662b197f85da82ceb6204f1fb34488972632c9ce85aa4c6c491bec467eac7fe1fdd0b72614b7ead5a41e8604b271924ef2f36c24f4fc24c1f2fd1fe9f3d7bcfbbf0de51d8dd3adfd6ccb6a1b9baea310d622bc11a6de4e4ffb5c9b810eddc05feef96faf4d73e076e111a36d7c1c4fc77adfd9390ac47696364ec53be01b1ce81772785831cbee86ff501f5137a7b11cd1464471882aad9e679a020d761086421dd067ac06ca22036f1b58cc1b7ce120061beb47d94a99f149a6e46d800f73c7d0daab5956e4670ddec1167ea7c4e23c706a60f7117a64d06fea2d6f1253a45099f3c5ce37c9ba69786798ee8fa166cb7b3f01dcc1b88f6f4a8d8bbe22f0cc8152f3df86fbda7387b8ce2e65d315d56d3e4a21942884929ac820f4ada3047d70b5921fe223229d622458aec20b7e2ba552edded3879f1f89b6e35da676b930d958c3a06735fafb3954ef4a62eeba5a981b9dcaafac4553401a73bbbd50a8af4fa742dc4887d590023d81e1d311fd9e756f296746f0e1a5cba6fb302f3cef4d0224c2e001104223a474bf7db9999c4c9c3bb1bff7ebf8d78e911fda41f435177e0e6a548dad1d811033dd9ea821bcee43f998550784251227b5018ed02784844cdce8ea0abcb51a00628c72aef8f50bce722e84cc701319fefdb175ffaec094374a6e67e0d271de0db010cf03624ff192b0d684459b1fc3e13e8be6f5a59cd20071a31e8fa7bbed500b9c77953f421a33879d00e7d2d7fc5e05493b4a0cb184db0f25b9c66f32811ac36a993bc4ea4d20e9715a7e42874e34a29004119aa77298f9d7f4b0721fa772609a8d28359a781accb284bacbd48909923e29664a5909c94eb69274eb3b178552767d07c1fa64655c7304ebb68db78afa03dea5689e5f668d4375662597387ccf389efffab41c86b1304bdf870a0b4cf749d9ea467ff70221a9cd9a5908421f88147e9b12b0dbccd4140ccf0e705ed97b08d3cb822e8d2ec570305cd8af6cf9abba97d03b12e6d4bb02012aacfe22b8a2529d9be6c4c1623bd640f6cb373b22a1fd6e6d7fcf2630cb267bf82c3fef43678c1ff3083d36d9e50de7233516bb244efa838131930705040a10aef1e4136f8d0e3a3403cdd0fc95589680f5dbccd9cb0b36f33f8b723474aae8398b7e0bf0c260610c4e91e3b15ae33d315d04d6068ad1bd620bdd9511551a3b16fa372207f8db56384f5ce38a59e0ff877d22f624eb7a443d8473384af32c06f59e50e34a48d2d96652f88000fdc0b212afcfb2d6f2afaaca432886af904c00ed52e5eaf3473775390d8ef25d04edbb9a91571c509b44fee41ca1050475709b6699ede2f20138716ae93058908b5857f64e138b33663d05c189208c014d5fa06b285edcaac92aa6eae561782147a166bfca24835c57ccb9cf682d82193c407269c3df78f83d63916688c012623352ddb6a88e7fbe86543be40bf504ce0231df9c010ecb7346a4bb2437766cd4fef95f5d744e95a4538299455625506257f4e922dbf8ec3672c5f63773910917a8b551a5463e427e12820a778c0f8c4f4a4d6a549d2dfdd254f97d64ed5729cdd16a506a2db4f5e2e0fce4703e182d48007e84978892d7c7ab12af603f33c0ebaeb772765abc5bb42b356001072d3eb278a1626b7ae844d53cdcb33bbe93016869e369d11b3105b57fce18dc218f3f1d442e39748374c579404c34f5618f04a372c6669bbf8c09a124a032180e1131212fbde0aa1a2764b6e9e6f588286d0a1946402d822e161886d58f96a2b8fbcca610cab4f88d585585b0499cb927e2332af006b417221a9647acd612456e230234cc611cb6746ce3985b0652749345e4f3a46f6bb81ec1f79625e93e8c6340c15014737b7c4d8e5114f0da209b2833a11aa00c33e5c359a658803464c2a5d68445aea30092b6a8109a721dde3e4b242c9e0a5735deabd4b66d5c2dd960c8e195bd814e1cf4a13fd6f8d466e23e9f3991bdb6e3d056b42f087b160f376403a776ca1ca47541613fd7e3f2a1737b769531224bb9d0c51e4a3cba582986bb1948b8e2c4bdc0cb13ed1d075d9f4fdf8949219bfd9c903bebabae605141c4ae567555677bc8d37e4ac9b4e52d74ff76d892e7828f440b939a7fa269cb4f3e10287fe47289c2ae6b46961aeb60271bce8006455de6a0bbe76d9371cd423b8fcef6be088f569f5fedaf3555291c208e49e7344dbc80a083d6004c89cf3a5c1a5f988ee3adc4e5841aedc310944a811d00993afc98d14c4d758fdf7f0ae2dc4d10826aae7384477941f08faf4621054bbcce99012dfde4fa54a085971315eb976e283ed0471c1163cf7a84adaff08304c1ccd43b2a8ddb4e17a8942eacda51e3c17687485aa30bf1588c38b6586be8cbd40c6aacd70810bf40b42d8ebcee3707007d7931aef88039d4e661bec81729e9c8c31eb245626072e8e5d92ff5dd93da7433ffa7af750b09107edf331beb2da01b0f31881df18fbda3048e8c4c4a9f89a159f51b222a9e2a25423504f36a333af8d7b20f82592abf310aae5489e8fb6e91fef887f21f02ecce0014a77456eb5d74a63342999ac172c7aa468b1f6c54d196e3cde3bfb8a940986b6e9a28854be2a2d3651d07acf963600f510bfdd9af39979a186c508fd6e1ab14f9383177737e953de6b190c099d1a100aad0683d673e771c0296cc9c1b7d3035dd10b2757c091f4438473f4a1d9050b3a1dcaf9ed3412fe8c5993021b507c0eee36997981d59675afc945e0da27ff246aa7fdb0f886ce396a23227a43ea445c25a448c5bc9e5606d20b0645770afda0850116a1ab6cdc9cca6e544d5f3331a80baab6ef4e84622550dff4c8f05e1b4c4d8c51a2daf59eef9756cbe14e7fff3507293c739a221d10243ff08286fb45adbc243417d596b48bc8ab2af45ff81e8f8ee9d9d3a80d08763f32a375ed980ac217f94f65e58d743c614a119fbca804f547fb33bcf8f48b2614ad5e527111e0e55265c6c6372a922e1681dce9845e2375311ff5fcefa54b84db128cb0f75bea6022a7d601c8f0639cfc8ee47618ab815a03998e24635b5b204960295ea518957dcb22217af472bd9bcb0a370b4c54e67518b6e0c4804b3b6a2ce579531c633c79ebf3dabdc8434bfa5abed8f6b61f26575fa4e2e0137479b3e4decab0fd6a5a99015b5ac3dbb2f1eda610325817d03ba7fe890b1a470f8e46a916de2bc5f2b585829a862b22bf470992fedaee44909ccd6f42e2d460878c0d8dd49e7fd8e51c509f476f5bc9de4b0d4cd41680b4748c02e65282523c6a49a6ba5abca77754517159e53d7065335c328384613e4fa487f00b341e36e57b34da5861e6acb6e79eb1a3f276e10befc8effba5006682fb8df600b24acc490eb6718701987d8e0fd0df290fb8fdb2139ce2eef81d265b12fa119cb157f5b463a656e5a4d7644593cd27c34f566711d899d700888d1a793a8d0435abe232a9d0c8cc2e13ad5b784e6aeadf68f0e71e5383bc6dca5a4257bb26235c4a5f9a3de99537708cf4e519787a8ff2404fbfe3e2107bddee13c2b101776b380fd669c563c4484cda1b1d2f725a8a39b24a0574ae696b47b854e5ec707858441b4c252b0aa0b5cf599162dfaba28766c55ed984605b3c3e6a1713031e73341d5cbad5266e40518712082a95d79bd4f5a13a0c96bad3f585669e0b12182a654f1a9e453b6c74708edd4803a29356e8fef87879687951e3ae2cb516b37d5b5d0f627d545359627c928dc6ccc8774c02a3a6b65177da3ddada4fb54e9f6e9c7ec1a9c2cc7a87a5b618a4a62f12e83ae0bec81943da2087bf5e75c01e64daa617e79de3239712cb16a21c35a2c4f43131df5e880c18b9b5666127f180f2cbe51c09c448c8b5c24f2d611782b47e696fdc8977365c97baaf07ea4e5e364ae8f5264cc3351abae08dc32bf822cecc52a1f22c69db52fa11a0fd292b7447b73cc3ca7511a862f8b7b1f6938560a05708be88976e4ea03695cd419626d0aa1aa726e69877d329a9546681148d0150967ccd2fb2aebef01d3ae73bda3eafaa7ea4b619d0959c335d4f1439049cc2d3a3b133d5aaab96af9e80a35250c44683b8f7bcec128e66f0b6f43424348b787ce494155e5faa47bae26c6d0828324d3ea94a22f6de62fefdab979f409290fcad4d243df90001a53ebea271c6c3efe693a96860736dc2a53cc9d4780cd79495d00629c8e7e45c365c3ae55db05372cd3ec18599ae8a42064fc3630af246874d21071329eb32e07bc0ef942a6695531732506ed83e5b6f979e478bb2f47031759a200c04c2b577fedc4b77168674db6fbc323852262b7ee9f4d5b91c658abdec7b76d1a2dc7e166c6b46649f629d48599315c169017ce1d3d14b0add3b7fa58891ebe8e5addd2cacdfcf8e22be5f7ad02ca5840c24a461272a68b51a911cfc0ae8e6a7fef93834e49e2896b13e8248d0b3c902d2d0dcb056e7195fe9f57b949951f2cea7c91575d43267cefa927d67dece03706229fed5ac9b379f5f2977de2704873291a344718a331381471eb90e16a172a0b13b5e638852d4c7e1eaf3c30a6f4e0f8fbcf8081fbab7d620636f4c16ee26b5665f34adb6028b4de8ef583cb222459956a9e8112457850114b05a6e2d56acf8f8e2080db35164424d092917247ac893a13e80af54fdb9bf97f62c75b187144457366909d2fa38ceb1ce3a84d7699fd16acf2c0e71eb657f23abc6faac17e88d7850dd17abbcda33d234863521476c60d1952eff70d2cff790d6407def37c4905fa5c41c675e31d0594e94f3f48f87bf6dc896f6baa8cc47180220788cfb22cd432104c1109727442d42bc815ea5f98103f3b15bc833a5530d35cdc541a24677a333600c2db6540a970bbb97a70e8acc8f00005988c254def90b15e3764ce526bd9c8ba24b92fdf899e6d23295e3bd34a56e16a4abc0e10d2cd39399de3f64bc9cc5c896889bebcf1f30272aad1ce9f84fbdd5d66bc62136c821302e8a59061e393fb557b4350f4759d7a8e3967a947c8a3812055a3466842abd646b6662d8d33fbc3d9255355be6a38efa62b2e1fdfdbcfce75a097131bb8108322dc540d1964fc9e94f21a644a6b88dd2233b3c126e5b832e56667de096ed2c51cd4fe767754fb7d147dfebae55ea002f831461032e900cae740aa0ac241a3c8f2561abe0e62ec3c7a13225508ad1c1d13b57a2178d7fd00509375c26fbf6e0caee0014c074b093dac45626f5324caa154064242c3373ab5692ef68e889f3460982ce3bb04c742eea294d293d1d84333b17adbe3b7d25c228f2c467f1d686b21db673bdda9a2b0809fd2a7afb88a7f21efb61af95c91eefbac596136bbaa3502b1941ee9aab7d4f676a5d18ef80e86d905a0e39f1c841259b6156f6f0184e250b692817b1ceecafcaf15986f3de27e88e75e6596ecf8ae14c45ec36057929403bb9e57e605763a87ac9da66f2f295ffdef29e8a796d5e752c38cd386d7a5937c3adbaa540a2b30c2b40fc2c4fd720a37ae2bebc30ed6a8ddfb64485f732b78390ecda92b2d17a6673e21dd07eb977e593ffa2a7f689230f93ebe6340b9c7b619381233f3aeac97df91a7071a89d823b90f79df6bb2646f39c1e83e195a089c31fbf334411a98ea722ae71158cf793a0e865a3918625b3501df0c17afc08429012720130c58b1ce3544221aeebc91535da15f6fb16cde6119ab2cde0ddf609de5abc7c013a336b60867f85a7c2380cce9a928529d85b3ce1ba45dfa3f08cd79e23a724896728b81943af49c1c8b029883e6d553a9b36c8dad150030ca9250acdb362bfba472ba62a50d43dd5eae9d4e5a5e18403d9f9428cfb5bd440eca6aa90bb23f43f84200bed060f83e3d4b0adcc1a77fecf2952e4b2dae5b4e86f4d9157ef961aec69b2bc2a7e0121e05ec0bb8dd1a54a4ae9fd8cd611cd6876b5b3fc310d05cc2c84814ac848b744ac373514f35e4801536444c0d3aa42804a9daaec9a319808136b07c69e8a5e73780dc16899966e5065bf501188de777765fdf8a1400a275013a765de9024ea7f524a0e478a0c500dd997a70f9c8f87d15de5875d71c40e8e0ac193c8d4d9013e8adfcbba22befe8231e2cb621b5bb40b8eea211501522c4c65e2b92893327645c79bd4ddd9eb561d9ce4b61d366d9fb02833178697193cf20ac24489a74f95235b79a7ac264fd2a3ca77b7aa582870c2552f034a256b350e6a27231205c213ff1056f2304237d7f90551d46961661c027cab65b9764f77e6ab5a116ba2fcc0767559a2aba8304e6c86c9b898894f016ab60ce447b3a0dc47cf6206e439a399f4cfe323cbbc14a71c127d51a209f7e6b46fafeffc7bdb343064de52f644e3bb50e7127daa2c63a1733cad1a096bf5de44265ca2fb385cc6729976c66df781191146ca41c1a7a248e17948095828e6427872be5562c874616f84dfa211661c574d12a47eb7b029097ce0d696b138edfcf1ea84452cf7aac490747e2f2d6a5dd8919ea0e035d1d2870e60a72f48b71ac2ed226a28786ab4305cdb19d7d7f2fcf62c499bee3c9583f10facd3295f925b3438f36e85e421b2e4b0e0bde2eb78305c318f0cf739dfb46c20f06efcdeb3fb54c3239f2e5d9c4c5046a351f87adbcbe032097801f7c6c6c6d82a6ba2b765c116c7d2b878a63488df910e972252a40783cfc937bb8c2be27a3dcc2510f9d67b2b9aa9a8eb59a18815acdc8ee21f4f7b46c73588312e7551b723b6d8d1996cab9283a5f30590246c8b42ee1baa35600eb3a2f8f93f07617895f33cee950013310a1aef52e4002a390b941e0068603c51a3d0e91e8e0ebef5cf6a30da8a4b644d12751c0c9af713c6bfb0c7fb615f402c8452aa213648e1253d17678d5b2acc7b2ace3caab1aa5e64c84f02c2bd9ccb9b5e08e0b903d63447c99fe67237ba7771f64205b93608d32f9316696bd04cea626f19b6862f82183083b2260ef0d4b60cc44a308a24ed1bddf25c044f8b2c6495b5768486fa8f26f38b45827301180e5b111737ec07d85339fa335f51965fc200f53ca1ca61018efe23ff4e50a493c6b5dc7f5032dce98402864c3bad50dec224fb74650e651785643da96688aaf2ba88cb3c8c587216803e04e93b9c50513a018e7fe9e4dcb0e4a711abc49fe27c1c489bb371363e611b04eb0e72706d95fa90d4c90536035803e4df417dfa849df2e6adf02f4f83a19218f52bbb2fb59b101e1fd996e8134521f2748a358aeaaf7b7426b29e1d361c812d1ee74f8f7eccf69f844fede1cc398532972f5c13cb17435c49413a39ddeaefc9ae1d43892082be5781f8b1572fbb57fba55b402adadf5da075e2abddf4ed9d7180fc1221d2e129706a7d8f943a2b496b500abb5d41df171a36757e68e1be716d5af541ff4a861aa1ee52393f9e2034de608aa16d6bca23a29c2fa9a678cfda7ed223789b8f0f5dd196241a9914ba1a52903ef71cda9ab7b2b88c622591f352d6b55f8c20d00b644e12f1292b2aaaf969307ef1857cb94b11e7012890d539c6324160dcb01322e3cc7fbe52811dcfd1d1f8dbc315334557e48936bc30f46c7f72ddf01ad25d71efc1456b5d7a83dc05a305f7212e72a27bc6080174b644000963be175b040ffa6c9934657e598baf52862c9dc60c0378525d61977d7288be0711d1516e9a5d8e323af334ef386d55d4c02b51d7896ff3c10839fcf59048c3f2ead3cfea096839c9ac90e11d1130b05235fd35e0c77302058a50c4f13c8b45c173f9dd5e3bd327cfa317ca1520c0bf136a2de31de229fd6c5c870bdc69404f23ffa0a12609f5c4f084956216df28bd109f1608c772e8d71ec9317272e8938ce1451aab7d434cc338131798ec1aae13f5b5d1057304df646205718c33674863f6a94586d473959a0ebe9c7db7fe0d7f0a491c03e7f9df7cfbdf4d58545aa590534ad21822e280384f06983e74cecc7cda4a46d321d4c735554c5698cb714340bbe54a791b7ad79c3f71b09a2a96d3c4008585736c5c13cbff1c2f448be2883e197b51b86b1c0cc732b7999922917a640b316d52de8f720d85a3181c379997e5248d6770586c63c4bd212bf547d597483957ab323dc8f85a91c8f59f248a189bde8cdfde3e6386971a9ece04b77e373dca41c37491c6c75a90bbbb14c26817c5232e88ea23a63417d87596b661a97b148457c6ee60361fdceefee7e63cf9cd32a3d080cf764c95c8ba49c98520ae87d2c44dd122ed1681cd883bb62c9b58e144ce110aaedacc4d7b83be23c2c08e2422c041f73a650f78790ca9cf528382135451b236350f37f4795fc739cd9201fc91182d7927350c0b660e2aea19439a169e393c944ecdc427f38d8bb2687b41b5d113ebf92f29fe19298d55fd77a659c8996037c64fec96317aa418e5ee69e84516e5e8d69a31efe52cced88aa80c6969e616fbd975ffb925988faf77b94a9cde1a88f3c24056c0076cca3fb218d962f69074a39a8e44928916e206a3e3a5f97327038066030ae8c0c28213ebbd10367896f9a8d6b0fc6c5523fe34e091e2713be2298b943ad5674c0388ade2e3055eed941006a74d30ce6efd36328f05ddac23c7bb672b761c432fa017de79a6b6240d7adbc394632c58dd712743f16d16fe4fd19f3343b694790cabf6efdfb53adaa624781500d2942501b21328a426b2abc3900f89037bdd7639b6ccf9ef8ed71133942524afb5f64814243def1a4784a9321845de89d9fc7f171867f008c85ff0532bfa8ff0138b522c55326ff5359a981860c4cdc9f26c8e43594cb8fa420d278c811c62cd7718ddbe4395b49d7c570ce81cec790966db0f4309850d1bb6a73ec1cd190b2ae00186f7676facdc603358443bb64be99a84a78359cac629d7051e3c60f0b0c445853f539f07d7d2f0a181e03211e91833d9e64a160b2fee933f418e16220264ed180cd4b5d3c5865ddd6f3ad936cf3151d51f07c553fa58914609edf2647152cd8d213aa719a800b74c9900733e8746cb6681240e55cb51643a4a9843291da1728c851aee6f7f4ba50f718077dcb76d6c0617db84eca7e1847e7d973cff2f5150174a1ac4b5a1d2ed14703cbf0bfcc7e8f0607ada7c21ff59303496a58e2e7d6c2b3c1ae3c85f9326d82909d922663ecdde5603a5586eeca0f8218bd5d38cb8558a1bfc9551c191355dbcfb390ca4c61af77c906ad65e6f562545c33f62e349847d20aee3d4b359d2d32f41108546e41acb781644d13ac68f30555fe07424bc94eddf42b46e22fb194d7a975ced8499f9374644ff8c7ec92f28370f6bf91694ae9c4b2f6b47fdf991e2dcfeb998ff25974d3500f5a6f20ac0e8fddf822eb3d3771c16e7aff5fd7ad03d27dd1155d2eb3fde1ed9d88da6be498c7481150d7a1730d8923e6d5ad83613d65db57a18beeb772f4abd00b4dbf3b8804c9997ac2a946787f684e7b81fb6860a84aac15b19960f84a87c204d92d6361f70f7f9b02fd8457bbbc81d9a3b8cd23d944be64df9f5df53687712234a50a46cf53bf14c1a0949a8c718df409d507482a2c09601b43796fe3d2162d525c7d80b56b0df3b7eea2dfdf5e1196061305cdc78401aae17da088001819af414c90f9d074e80a31fd3ab6523c89337067dcd3c868d613dbd072f1aa732c9617266b4268b724d926efe56776ca752fd431ff0f36d744cd12d72ac3a434d0d62fd32b21b819dab5716f18182632a436c53719b6b769f3c0b293b73cb675ca9b58d9c4e19c455640e0976c420533a3ea859bc8277500ff07f5d88fda53f6fad180dd86957bc131f71c56d5121ec0e85dc48561a17de2c8e13d204dbf772125ac19de1ad8001a8263617760e7e7b864e9d96576b4dc3eff9fc4ce79d1d156295d4fcd0fbba56aad878dd53f00d200ee484aaae2e0e71c1eece5821fcd93bd7cf09bf7173b52bac52ac87cbd0785301ae4a2353919cb092f9e0ff3676129e5ce6cd762de7df297a47d839b6bad49f60172346fb97ef1c20eea3641f5124618c905f5541f6a041bf5502a35b8f206ac5490949153851964bf01c6412215445ef14c4618a539187187e811eebb782224e72f3cd384c2bd9fc401c37268d7d953a15aa17149f6da63ff3d09bc2566da65c4147f6f949e006e8d75d9a0ae1bb7f5b82a4aec7dce5015492d77902f7c3fa13ca87c0d95daa2287d997b2230674861a0c94fe0788753782ec71b65004cd978c05e87af45347bb240f67aab0361c756a4a2d3358071875e9722c60519f04680ebacc6dc21a980bd9b45e2daae3403b670e50cf824fecb9bc4481c42e49932876867a894ca5a6c63d327bebbb31c3542e3adaf6efd35f910d3f612c46f0aba5bd400462bcee750ea344be8725d8f045754d42abc9cf24fc9d02a0ba9f7f029e94bb4f64180276fcbb737550629b971e6187befb7662705bcf76abee31be90fd2d8afc325ddd63cc8e9721b348acf78a283d5f25aa71a4169564198f991cb8d8b43f608cb74ff22ebca955ef26ede875654d6228c6b679a4e2c0ef4ac47eab03cfa3528da8364591fa35e591d75aac5909da07dbd31188b112d1aef6b804f7ad2567e13d3234326f3f65c236484b22885dd3d1ff46eff0ce759ce0957ae01e2bdc6e51b812a13ba6dcecdd43c0073057c1ba77f80a0456a497629f431ae41f2de47affb0680215fdbdfea268c4a1703cf67ac7a296f0e5f60b5bec5450588f796bf91a81237c891854160d663c2f36bee0ba5f9a00dda2830b6bc63c5d15c5e387c9371d70dbc30546e816428127d498f14e09255e9419445b4877eaffa8fb47de1f1b2c58dc32e44826de053566dd4b401a16c60b513fe2c565eeb312e09a0a7e1663b03dc6d1dc66b0fbb6b4150fe77756315778734c495d85c6f6bb4b9f19ba7ee3e70c4e5a409d32d990e39c21afb9915a6f8239593f43f520c47df529f55330955ed74007492ee8aa31f56e5360db0b35e8ac5cf6407b8006d93c241dbcd0c3a71689fb22521d8fb6300cf8ba3fc16f1b2031dd8246fb17a8795c2b00dc4e5c8de66cbd0bd6713f05346d1fbc4b149799804f6814a0afe13aa4b23ad2af71f6923b5e39721cc058d1b3280bfdfbab1778387167e2a25c0c0bea9977e835d6df4ea2a960717e555fb3b4d09051857324212c80517e7da3d4465dbcd8c9d71ce7a990ce08c972bfafec7c988d743e5f3118abddb82877bbca46be0f097d90c7dd2df7489588fe11e0deb4e59a3d3736577e317fde5aa2f6102adb6efd4c0dfb4daef6a10d6534ec9b8dbc3c369f1e62365ee3908483d8db038e6c7d53feb006e621ae9d7cb04643ccf8093208fde2331be8404323a58ed6973bda5cb9e1faab62deb32f8bdb87f6b68bfb8f9f06ad440327cc116bdd03657fc039409f92a859d9950224d23f5edc0531700f789c8e22a1dacc9d3ccbf083970c929838f21ef82f43981f90c491fb9593aebf9afc26bd6b83538abbdbfad79fcd75d079e4996cc31922de69d0c7e386b1ae6bcbf9e068f36f484dfe03ca65bce9002015dd7c0c02ce3ce0363216b7093045fead733532cf3a47a688b615283429c463de48916dc74fd96b5925aea4ef389793ab5e378d8dced0e57afa3b0c620cdd2e47e25d7a6047119d7d9ffba6883f729046778fe9bdb6cb0c24a5df9ca68d9c28a4cc29da1b98eee482bb2162ad2b1d60ffb2e05bf07c2e51803a6d963388e57a526f944bde872e11d2a8ec8039808aa7fb0921c23997f34cde95613aee140b9d8e69c6aa0ae2cdf976e5248b63d53ccd8982b240ce928e924544966ed43c473a29b5a9c4894ffa1055f6292cbd61dc24797160d31bcf1a927acf32b127bbb351c94bce588cba85e33d55b2d08fb0e3f5015b1beaae38ff88e05a26a32ef4a4f55082b8135a5773332a0ffee87b5d9e99294f8c95f82eaba15363cfb85390677770635abe33ab7676efc25c15c628dc5bd9fce62eddc3824ca3e1eeb7ccd477c20959fe266a0d2116ecb5b1b8944ede9e420e2d36b58df0a4a1d81b7db0c9c39f1bfe04a313728191b7846da72570be961ca8211ca3a387f936cdff695a080bf7599609b4cbad5a596bea300463d99df190d6bb3f00d7fb231d26eabcc53e8f697abd05695e736d799fb8f6a930eb27e2e78bc846e487c3b4fb2b1a266d5f5ec747e7e4ff9aca6059c05fbb3845c53fe3a5ee2d5f6003ea10c46fa706fe0042b11a9fa1a78a93de769c58f70e4f33b56b142844561bf47fc4b84acec2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
