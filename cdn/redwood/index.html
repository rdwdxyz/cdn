<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14c96702a8e1321b55d30c7979be60d21c54db0f9333a41f865efa01ff7830f5085bd9f4f72d75825c5457ae66649cc0f51b02896ec4566c23eeaab36a224c6f5c73975b2400a6c8e8180759caa15950241acc84958f98f95c1ac82ec5a4d56ddb3871f5cc74e0a7381630457adc4817f88120ada62b0a18fa5d52be8090da617767b5885541fc243a6022f0da13d2af01ca612c87101043861db86d236e061dd8a0bbe86c0d0539f2a765de19c7128d303d90317a69f73d11eb44823bd659443c4b75430bba05800132445b854617c06bbab6db05135a78b496f09544d4378bcffd36796e04b25851e847e9120dc018fa2222321a55d7d0146652fdd4c10b5b80027faa97033397985fa74cc6021d6246448e2f50086c79013b208e076deb633a8d83c1da359508d49a45153547a4d92f2ab07c23f363a04fe9ad55c5655ba1e25450ed62a99e8798ed10a24b4449bdb28769557689349524866b85018ef63cf70984011c0e1a635bcddf554e4cb135f5e4477279652b310d903062acff7249918a717a01d697d265c7dae23b1dba12d571f07e6e7ff4df1d23c18bfe626b6bd4267b066d26c11cc1344a59b3e0c73d3be2c508342c34fa70d13a119a838046ba9b145dbf1c5b80df4b8ec51236e3c1fcaddb0b8885aed8d4ff0c1f580578b4dc47ab362745ca234c36a75eb0670c0a41fdce50c599dd2542dc0cee93dd65145d6b882b87880daeed1ad146b153d7926aa27941e3a43112cc8ce190bf491d1cca5af467984f55cae8a902efe835e2a720ddda84893ce6d7019ff593bf8094bf16428b7fd1940b1f86160b5f4e6e0bfc14b8bcb47bcf18856835b23594acf308c1fa7433d4e2d68b85f3da5e882dd3fc0ee5c2931ef14e723a1d9cf4d88671fe7f8488b70693be4221c444c33f563dbceb50c1a26c42b3f5e7b82b76f38bf15b2b79687004de92fd5656fba5811d6ee918bb59eff7496d52968558e66665c761e970cc13cd9af3bcd5388279ab8a577460f876d90e4731e2bf4b949806b1a7640e73cfeef55739822df9ef0b487a9fb59fd7d00d8c33a7270b66dc97c7fde847384228590c40debf2e2d3ebebe9d3b75749d755f0e114267d534f5704df87b56a58fe35715dc2363bc601a4394ecf42959eddb8bdf818197b950d5a51f4f2379914fad42e3c6d5c65355a96b0c4ba6e3bdf327177e8bce1b356aa06b22fc21c4e2d3e22a58e45fac33e0a0b4f2860dd775b6e32dd916f1303501efbac2a07f69f3ab285356405f3e57407c8ee8f4d49c62e0601cf45c8c32aebf025a0304d9d3ef2c444c05d4fa6bc4ebbb74feed753e769f06d25f179fad16bfaf02c1833709441d80fb9a64295859ae95dcc77d43b7e62cc8ae2a4709560586cbb243ef169d850d65fd0783a9fc59ccd6c8db494c69981dbc8b29788766d0d6fc23b72a9570f017eb3c88b112eea9e481d775f99b1efc39e499f9a77419f969831b6a95bebcd753a6b3a6bf0fa7c07b2f63f2ec6f4b160a1ee4a15beaaf941205d37e8c90333532cace6198e93aa9c958820e2d913517cf7c7c5420ecc4203a107785da6084f7fc7d4852998ce9995c3b742711412048ff9968476cd94b8a9f7e8586424782160c854ae17340527085db1461256bc097bd95e4f8c05ea4a515f2cd6e550d5289e1678143824c1fa9d3b504b13ee8f3796d2f5fe800a462468913dfb3119c803150a7a7286534669dc4a37b7f286c103340776fd9cb1be31f1b9612248986a3be72898cc5cf80a5186e054380697c4a04e1b3690be345cff87fc03261e4cbc8a3fd73e1ca026caa973510d1ad0a229d642eeb04dcd5ade0035c35231b3f7bfd2e6cb535f6f93b71620f3c03d417df709a7f1c7abd21cc2c7c017973f296149d9daebb6f62f56c220bb7aaa40f9ae23a5894f7c6e216e13353f418383b9bece0a87078311195da16ec45b4b1d341728b759dd81388435445a4a884a318a70d6d455f326aba8df10090c959eebfcc62df5e6fe77ebb666689019b1f852835c7ff4f6fe6a108aaf702f2a536ae8bdf779e787cb11d068fcdca7eb3b2c43fee6d5c5904f32cb55a6e1cfad4275a147aa50fd93fc448422e90bf11ed0ec0a96a0d76ce6f84ab518e1d0210586c7d11f5c517544675348cb60d7d9fcd3d06a7cfaf3d918958aefa0a4360cb95685a91615bd31841834e27f58e665829ccf1e491a7030148254131aa672d2b3d2c899d329fb1433c3b57c79ad5e3e3412cbdb6790116c66057a1cd2627a36b2f592b4a3c0bdef6d4260b1e46fa6ece48dcc508de5e5a20b4ac8bd01861f7d58994cb4f8e2db2f8a0a6e030dcac3d7ce7661251abbb2561c6d267a21fe36896dd8c878c5b17837dd09b16726793aa4d923893684d8a5f07fd1878d65cae9bb44d358455eabf4c7afb34324552bee43eea6d7d82044431b6eca2ad13755e1e41047ed57e7d782071fbb86e50b454604ff284ff0e9179517ca841fe0a0be7dd52ea350df3f6d90436e4814b5f7711bcccc33cbd98e252f403ba0fa7b9cb420bbb15dfc305f13a8db00eb7bd0c7960a920208eb397430680a38c92c96f66655ffa5ff2a25d6c82dec1cc5af32ee9950c02c148f959b1592ac01de406081ae69a5d95f6c1468ebdc5542321e8de044cc5520b45e16fd13298d323c9c2de3ca33fae4437976e1f57bb4d6d1694ad535afa2d3865eda380e091359bd893b8a33ed6d441b3ae12193bd5d449515fbcaff74cb78a74eea25524c9cb8b1112765cba43accdb89511a9372d0bf3ce625c12d179b72c5c6ccf82b9d97f0b202512c0bd5faa7d3a2d090fe417bea79b29ca39678c8382e1276c6e2ed4a1a6f19f8a16fd2b4414f358e4f1733cbf28761eaec73d6072bf3dfefdbaad9f1f4f27885fb1bbee8956b6318b8560d34c4a8e0808402402e16d6ad5ce5a667113ecd9c332568a2dce750be4681c3b8eac824a852efdb9eb43831817845b23d2cefde05a42b9b4456edbb12b17461599abf10f7beef9037393838899712d0258970bc2696f18e6e39c43a4f3cd5c1931077967954e76e722a9bd42940e725b797878417b8c0b8fbdbaeb198becc770cca5bf3956aaf5b801fb00c2c76cfb3143780d21a8074fa30e37b53057dfd1a89583817f362455024df0f915f1d34856d47e5495c176e8f3f3f4856e7023325d2dbdddd2a3ce8e6d143928e5c31648a487bb31f9d911127c16eebd94af5d72689edffd0adbe837c80229ec80c9caa9d2602888fd447cbd8b15586dec335d7edb285131b46aeefd93da2b8e9f5dbf10a33518c80b8a01d96325597567fc0c76ebfbb5b387f18ae2bad3496e2cec9a9023c1df043cccc70f31ab87c70e8cd69a48e6e25a8ac93e73ed989b95287c5169ff25f852b44461b966171b79cf83462a41c2deef74aa9b5694647a515525117528560212f651b78e83d0a61a4c2aa0c8c4935c5eb78fc2e4895024b134bbb9a35b7d926be286e5f8f8e392676cd2b31561facb1260ba54f0be1f699ceb13158694c03f725644876eb27d66b0f085471677d255cf26e1b868c9ca33bb5a31d14531c9dabcd0aa94a6e50fbdd7acec78f413ca67c139c40fca5655357d8540886605847f3ec3755c4027bea3e23876f00f5c416f6212fa6d33b17406939e6b2b74f5e9816907f3bdb1c419a6b75e7cbcab30f8b82f4d09b2ec7adc117f56b49d20cbc8b8bb811a21d2a6c889f9d4754f78cc0cb9f021b7295170f43a33a428c52f6e8f8c704b1a4870df559244dd8a2f0d5d490d8c779331e00665dc14fcdef5b639e40d3fcdab6da62a414c5d83f0fa0dae978a9cf83d69a6c23c0195bfd77c68609d65c2247aa4e6bf3d9c3bdb772b40f34bc73495560380abece2e7c823d554e97199345fe4af8377a2c26d451b72d85c3603c4e9738abc029d1830e5dcfb6c7d12f01c9fa438867f25fc5f6aa42c66b28dd77340aa7b5c42613525c1c9c1b4d45f5a0ab6f6e75de69f7b620ad5870ab42349990d5571c4e4aaf1c3923808222bc5f34dca0d2ba97ef37c48a155c5f3ba378a35a928cb9f591d830e0059a3cb25d88edafa971c9ee7a1edd112611238ea00a8f4396d15732a74a671acea3e2fe6b413f12bc4b5cb5c7c21d378b2045d106b02459826e5d92bba514aaf1273454531962284b54c5a79d8ac3c3bdb63689b4602687659ae180de45f031199e301a75e17f1f44c7e575b68c6272b69aa6ca36621f3bc44422f19f469bbe5dd023f048f9c384b8e37acedb0dde909165b1d19e3e00b90966e0ae8ab4d0ec59b18d2e60545d1dbe242e24bfad70c585c693bbcc6e20e892a7eb1a362ede0db8d3c6adb81c873786a17a86869243a0fdecb18f9af1cb9e3195eff1b8b61d3dcb1bdce8c7bfe922329b76d3674b05574fb7f9e2b9edbeca7f7be19951a355d33826fc0f1021ec84981f3034601d0891e1fe79d88d527812de76b599780c29eb99894744166f5afbfc7e1777fd9da8194745b35ac5ad6d7f23804005fbb35fabbef95cd06d6d4bbd42646b8b0ed47de5b04785f0a200839563d9bb7a47665e5f4f13b59d0c89cf93226d2e6b7c88d7d2775c8b41ecd1765ab6dc9a6840d7947fb9784e7769a9bf9662dc68f263815a248dc0d7458de0d52466e03d129e61c8efab2e06f7bfba79a0d5fff684cacb1ba48b3d61f97eb5468dfb50ae9e9a459bfd27757a5191cfec72741f28a5f829df03b86182e59f4285f24812bbebf0dd6af1fd79a2769dc9e4cf9c28b261ee013e36471723d789ed175f1741f45f2a37a02fc3daece2f6d4ccd138fe37884a2cc8a3306437638272a78814f9739c731f7e12638eb1fd2f696cddd9b5e5da0dc3139bbb2e6cca220882e3690b8d9125a075f88e3905f2421aa1509a2dea56541acebf474dfe06087ae25b9e66fc4c3acbdbe23184506fa619070690967aaac91b87c2253ab9aec40d06f5f5dfd3e3c177c844b06174c2b4c703d73f54cdb680f14d11298a54b87ba6043634849f6541d481e2202e5c463c91121d815fa21ee3adfb79fca2535112147a935459b04cffa50f2bc864f6949dfe7e1dd61d1e88ea0ba295e5607ac40e3cd73cfddc0cd3f3663506c9212fbca975572618936aff9fad344567da2a823c0d3b5dfe5bb23ace898a67e4b2a4b12415291f12d970d901db813cd6deaa36eea503662e4d2df169e0e1f63396289da28d8090800dab476122f0033490b1dfab72aab16f361467aea98cb4498c997ca647f72bf4cde315c7bee0de04e67481f1fe2b4678bdad61a3387926522145c70d091e9e802c1d6b4e438be473898804d47ba972e1361007ff24c0f19df5fc360d72649b8bdab5316857a03f31cad76aabf0a944af65ae37f2905641fb8a8a04747ed48075d4c65a2333f332e0428d54da3f14691986f8d8ded9cf3791efc65477c43ef3127e685a3138f9f11dae5a2f25d3a28cc23615bd49c9e7a2255fb7a844543d3ed62741d2a5e7cc11da45ba7f24ea8d904a0d868d6e7f6ce784b7154f4bbd4249ff13126084a824053e12b1d2807f7461fe209b7b3b04300b409222e6f411149c2d319991a7363ffa009a0883b1c6addc4488c15754b8791e1136233e489a64ff4dd18877735d032c7d97ff98d79d08c46b6a7156dfc036ba547306c36cc67334200224fdb16db5a49c6b1fc21a410fcf64b04da87d13731c20659cce17669c81d6cf4e2fb0a772822c214248cf2bd3de65406f94b7da9117f04df2277dd3c1a356ccb701524fb71c2709d9251c392b1fd87ea2736ece372524df83247d12608bcca3d1e5667b5dac7e48fc534f529fa851fee987e54f4b00d2a0bc5e9e09697c48fff1b3f66225ea8b4eb611b765d4a7c48da75d961a5679bc883d3805314615dcf349fc73073235fa6753e4e0277cc49eaf0bf0c694cda89d98cf798cb2d7e6a061aa40886864aabcbf11865d1dbe0a25a4474e9d3ef444b405fb47137efa8a1dc40e58c93b4c90ba777a4dd24e611816cf15d8b1d0c6012f3fd557b30686e98d8d9854f6e5a5fbd3b69eca1ddab7390fffb453e716be5fabeb72c7fd2376e690e1d891aa13c210928c86304dc50396bf9d993e80422f3765747b86e02573ce55eb33f92338759b7faacc08937e46f11821319cc80944fd8af78c5420bb91de49a080c228948bd7bd549bdaf1a1983a5039fbb987fd39b7d6bdfb68f839e084eef240f7b7849ab74a8b7e879b1553903e5b42caa361810e21f221dfd5b5499e7b5bdc7c5f85855206e409f3c46e6e51a6e5923139e818cc15c88edf625bc09700b0ac70e35b25c7f108d3ac24877e483b560f0cafa2cf86b306fa9ea9cdac330922644de2421824ee1afa09920b02364e60f485910516b52da94e4925493d5c1ba3b21030f651b879a98c5beb48af6859978e662f68cf3b14ac65c714ff74e3408b4312445bb208cb238dab5ea168c9d618de64333bcc9dfc8f84d8b5763bbaded89f4330b102c6708f68a7ae4f3d52480cb847445e179baed2bd2c3c6f5164658b27a8f32dc83ddbbc909e9c01eba185ba13ceab67b80cefb262c8e2b6e30e171009595e0db14aea1da950dca59c595aaa4555ce4dd7f4ea739bdc50cf595ca55d861975cb1008e2422d04d3de41f5de8773bba65351ae048aa801ffffe35388cc4917ef99b1c620ace69657fddfc91badf8f8892b1ad39d3be4cdf94879fea8c1ad20e53be9eff3e80015b8c4c0bf1c9200a3f387b6951e017088557d1b0ba742d4ff77144f25e797a9502882f0701017b1110e2daeaf77f0423ec8a64e7620fdef2dd02c7a9e221d930fc0256aacad4af492bb9dba48d445318b816e24c7ff0265d25e3fe4d95f5ae3ce41399094d9ae6f88bb9f64aaeb73d89df7de65f7722e1b342f6562bba450a5df6378ddc74070f8b778c8b93eef95c5878f3233967449e8feb4129c53e73b844c5677ef83600952dda3eae2404a25619d8dbef79e2c68a20d78186203ab711495e15c55c36679834e11e6948d924eb1936a9a1efb21bb2fa98c7fc0e2b87be624801e9e22a04291910fed641a70c136044ab0cfcdb0656fdfbb7560351136a074111d42f91165072cac06c16497235fb7b5dc9a5a52b7d1a6c2a88045e9c9149cb9f4e9918159cd3ac6e8c390f9f86edca79f4f6264f1b631b833e65afc5d4fbe89ba6f8d3161e683461d47cec674427a1e9101478bbdc53622b04ab92050521b6948dda6118550bc37b956a775643de0b433fa9f767d5163cb116b4b6eedc4e34fdc8583bbbe0a345cc7673377ed90b60bf8a84677004875ac8817eec7cf7dff69c0e784289471d47d774e10a7622aa4f37f264e57adb8c14396bf0bfeb7cde47be0912092f3e7e737258c8672d4f3a4caba010d6fb38fc6152abb2c5ffd8eef1908ec2528c645da0bccfc9bb78fb6944925755e514b4fbbeacf141133710d7a90cdf797999df2ecb00ca675c607f705666428c443a26127573807bf321998296f026eaedda77e4cecaad1c27585b7d96b80439a49bc25e3d884cfff634059ef166f7fe76af82b97cd8ab169d07199364f5e3d5e128da7045ce2bbc2eae115bcfe7048465eff35a33252a3b6b37dc3d8d793148e56d8b5fc73ccc3b8fac36a067d7b5e95b22e4cddb25145e6a0e8f55d0df52dbf031a5391272f15c9a02baf729805855874f5b3311a208d9a5e837cb1e3f9525a7b42208e7faa93028467ac4d9751e987559d2a8f02ddb629261a532aba02436b97a6d67d3a274d8033e33008f90c66a095b1b92b34666882b6edd42a1e80a4f9f6421b68a222ef55770e374c2a976d5f16df1957170dba06a6bae7176229bd549f385ef29347768b453a7d7d95cfe5c8da2b077f85bb92fe61cae4a4b69e76ba78ea6ef731988dbc0b44d2f5f131a7c9b951c64ea9ff8a2877d2eace6e7c6fc1dbf2d1e73d89b667c39a885518028f331df177a07de0e5e84629cfcd68ad4be91883effdfb94601d06a8ea52e04b8925535a20f15d7f98c4a4e38eedffd52113caebabab31e72478c228e0ebb2da0238398c783f2e531ebe7b98cc2d31cb56a59b0ae0aa8bfe50c2a83f9e99edbd6b2df1e40c0d1eb855d296998ece01e415097ee2e6e36e9e619b49ccd6332ec7b9793149d75035df61f01267f695537c4e4452028bffd068f37381a11afa2836c80f957f832a89be948c1d7b7fecd7903a83add577b6cfc659ac588b1b15cbef9c895c119326fc849c09c6d8ed9200eabc3f78b8c21f3136e9f02e6e8c38ed3d1a2501ffbd0bca59d57687402b90947e7e54d7cb30f92f644c70c6aec57d5595b70fa3aecfa71014d7d3400c6fc794ee5308b8df21670855927e127bd0141fe393a0515300e6ff49f7f8c3bd92b2de7e18a7f8e346854199fff0bf772fc2dd874fc052b718abe8941e4c7b467a325d11a5e7c04865f87f635e9e0e9a387bf0324b92f7a10e482b5aff5a7bcbf2f504b0ce372451fa8d2d47ed7f7436c41276bbe06e4c450f28d2f978fed1f27497ad93aa77a2b0f59f5ca1cff7d333365f920082537953922ec10f9f26ddacb65675c1e7104625a1f591f06f9712da6a54bdcf4eff6010e4180eb5755d721bdd9f22cd179e75692cf10e0f854776ce5923a2430f65cfce12e5964c96a6d716807a037bc51538225e15d7396619caed8b5ea7f844525ba8398385571e6b9865fafa373074f99a827ce0a3780b98d825bfd7ce427ec715badebc60c04543226f0260edecd0de2fcf5e70935c1fcb9c94a9319312dee09c050180d9802d7f20aefcb5b494428daa574b280a23ecaa213f83bac2139a28b7d0f07c971902cd509e323e3c59648003ff9b52d17ccd494e88025ac5040adcdbaec1714fb56c14a0612225f7bef1595f6796803b8de9e79bad1e070855f3de376fcd4e85a9b9cfabe913192a741240307bf6dc4cbb789ca70a42a219f17b1b208f1f24940a14220279d5918c873be58a7f353059378085da73d2a1814ccae88fd47727d6dab94159dfd03ddece98a95ddd9f7cf5ee7ae1904ea5bd5a49504c7a4f599c2828b5f3aee5483ed365732cc54ba550f652a2d87cb906b7dac8e02ede3a6e93dd1885e4f6e9b75a3d24bf2581e83691b26611c0c2ffceb8bbbcba9ff4d02271655292f13f670329244d44e93b49ba56a7611b45707aa7eb6b6862fe6bc1a9c50badf07382ced44174d688c5ac5e22b43b69635f895d26808099c4df5567b859cf0ee4a38ade1413ad4cff94550e70bca980a88ddb72a07438a8a4688cb0340d944d4965bc127833887bea6ed3c649d0379988d655178d1215190e2a97fe529891e322cad0ec6f66ef223647b6e2b0b01f109b2b8e5b7cfdc2d89fa68c8cc421e2c237e4c70ac9200abcc842136ab9334c2b674fe1bb8dfd0496c0334537e231830be77c0648f06cc2fa0d03685fb5dc2b1e38d4f169f77b05ba8458b019b2c1c103eddf45900192cdcfeae6521be1704d0ea8563c2de93278554513f2c8e2b16afd7e85068ee19a4bef36a01aa5e07ce3f9d457db59709ed2ed694941d423e9e4a91bca794800c95df3620447b0cf713d86e2ba998d112ec473c92f8e493d501034eab26c2f8beb9e2e36cb3110ae5fa2d81ed1c19328ebcaab3b44e39557ccf5c17fa3fb38cd6900e8aced2eb850e8ecec6b5986ee431ab1eb9373cad3b7171f77a064613946ab295e1de440a9fba47cdc064eec9dd9540a3fe1614aee41111ad55b8e909859f552f0870148e4c6e3351926604eff08f917a4139e86926cbc67484876d4e90eda0ec6f29118a659c73af6a0fe8ff7d75dfd224c137c9693fc9853528222115ff6412b550f9b618d5c5a93643ebf7ab5cd66638a3ecab03c5f9f98ab96653f6d70a129fc8ca2150165ff0079b1be69a6910db1cc1ed062e17e832ce477484d680b8b6bf20c454c49c7f517f1cec92e6a5178ec1d5c3824e227f756cd748cbf38b20a1deabb404faa65ba32ab6b87459366eab18c129e1e9bf1395e8f5f2afb4cec2d98d6b636f8f8040f27f43dcd442c7676eaf7277079e10b6bbde8e59c6cf38a889e2fefe338830fb3d4525fd64e21451feea115b2db8d28400f9f4505e2bdebce0b84830170d08447c64248cb411ceab5e218c9fc97c642adc8cd28ed0daa10b02ff25c7c5286980f90645d9f09fa029157af73056f7cdf40048966235d1c39eea3117f286d5aae189e2e7c011faf241fa80e78d3279291cfad3b4788aa9ce140dcd240c579a36ec7df3edb72222f420e3eec4f9dccedfe5e81f45176f3122288a6194b6e155dc307a1f47542345ff2ea2fd562753694baef03aa1d3f031ebf15ef39e765202b69c27d6f311706c2fb54ef131c5e3722f3b85c3a142731cb0cf1a74ce172182961d41257c9eaf7421f4c2fdd4975165a0b56d99ba0298c49b8ec7a261e4e8f399e66d43b309f10e5a5c7b5a2c1afb38d29f260477673b221312faa05339bae458efeb121b25224ce3db5b702afb715d02fd6b019b86d2b99cee5de0ca82ed87fcad1c58dea0e874613e44272dc2bddc6736e933d6d04089d56f72b793bd0fa1a80193aa4e474d8bdf5fa93b6e055712b9e9b71bdeb7aeba0bcb0d73e0a6ae10ea743115dc2eab499851dfef712d82fcfee2666fbbce96809abc650f82e7b0d70b13234910c8f3ea09aa37e2e680eeb6a514c2fad345b9bfe8c97b35e488ec4c0e3b278117e541549be7b42930ede458849261f4ac096b5754c370e8d613522ac150be5e67af3cec982730596ea9efc5f7370c7f2ad5da5112b6a04f30de6d34bc0c28a2e4e64b03bba55251c1b991c8b796d0e13c3b071d193c419f03663e95ce4cde9a3ec21e3337bf063456237b7a185ff66c01bc9155ec32e88d25d050bc7766a01619f1e59d004390205ad5bfd90eea78241e1bb3c1e4b0bbe401b6377837fcd5127f357188bb6eefca2cb7418ff8a5e6be2a77d73f3cf385da14a768e7a9809007d0b49fe7d369e6758f20bfb8111ad3e9724565845327b3aad621bfa8c62f4f04b70b95eb36db96f0f7a8be90652fd0579e53eeced136447309cedb57c4023e7704fb5fa9250c89dfa7b166ca3cc466c6975a731c551a3dd790ede39caa21e17c7c28f1008dee62bcd9d10992de24d5f6e330832e9d657a797a410e5a4d9988dc10f1c1ae84c91fe837ed62ceac2ce6087b8427d58fb4e7462ba05b7451c4b5734eed9814dfd6b651521999b24c6e4f977afbfd2b56df382a4a50163ab7b1e9288f39280ce8ddcde90465490a69d698321cd38b89979222c2943d7ee1130d352dd057b6acac15967260ba976c1f9997a21b36f9bf12006e1fe9d3eacc81dd38e8c92be2d84a3f25e106d25fb9345686ca1366ade3f52f23ec8225a7f17a9d25359a81ebad30bd0e8d030d97bd4eb88852dd9ccdf54143b3d848fe3c351d0c483f66498ab7c9d32e7e2e011c9bd4591d0dfb7843517dd59b11a9616ff4a70088e80337ff9d234734bd10af511edf36faf331ff222a2aa4db8b7f4190cc9ff6e183dae9739fdfd7d402e438fb9bd51854d1915db73c7bdac05b2741456c38b33cb1489875128f8782d9f6b793b30728a69b936702aa65755694ffa53f13c585d74d05a5ee99f38c59eaf2dedc9b27937e91bceb31e6eef7d5dad722e8f72922205e7a420eaefba1ee8b8935eefa41b396588c731cf6b4295d75a3cc80333ddb4201bcc09cc414d428e933c04abf0479bbba05986f787be1e76d665097731aeeb30af060d1b82ef9b8a465e9da8bc668f85be90bc4bdbfe672da3bc157ac095ce9f5175292e0fa711e1caa5d87cd4111e5b7953b6706c69b667795ee16c183e2df5a3e6beac3aec395962001f096027fce33e5f70a49c8c339cd5293d597fea54596d4311abbb353095db4800682dd65c0a6a3d5ed3d6f628d39d1bfa2abf37ffdb2d24e3e0880d211055a8ee8c44979b8637cfbfe4745f80ef671490038d0aa1a6ea3b5025d59d91a7adf785907d53c1b2c6ee98fb138291bc81669a95f3efb8dc680ea6e1095cf5aa80a1be741e1c56b2babc68d30598bd54083ea90baaec1dea8a2f52e0cad808c7f1997102bbf3012608f4f52d54cff1d318f84e2494955864172e963e8a1377cc7634560394b4817ed83011ded0284d55ea9ec2f4a3647c935554727e02d3ec374a19d4ffdb34eb8b212a656dfe5075dcfc57f4ff151a569821e4160d0aa9a8400252e4656be108f2b8c662b3af439a46d4d9ff19e77da607aee876471650d9f99d5fb02c20c3c642b01aa573eca64fc1ae8fd2c112291b0a2a6029f02930dd26eb37d98ee544c308e08e26d973f72dd91055cdb7565a51836a8a8443e2658af70af1b8ea318647933d83ff1322f2f8120c88f87160e1a4de2194513565ef8c87136a548a231a374660899b1bc6e1420485690b45177e2be95d15d618c088def8065e2a36bb677d378aceaaae0f52a9fdd901f3967ec356b0bff991cc10bb8c0aa4c53cbce5b2214e2c9465a1ff2108833decaf94e260816bbc3d6b182d6758dca906ad480927dd098c5bb745b8a73e3ad2729bf2b9c4a3a41664f192889095565dff1bdd7117a73ee3d7e31b9e1ddb88a05985cdf5ab4fe1bbe0a36ebae44a34ffc23d025e0237538cd54c5dde381df461b73dfcaad44fe42e83004c05dd2e60945a3cee8c0b88fde580aa325d7723291c1a50276618b4adc04357343961654846b2dd8ff0c54492b9882fc83cc772fe7063fac3e235494d3e68b2f29bae02ffedfca309af492e288869791981c7f5508da045c1f437438f4fef9bd7bb9a409f3f6859ef24926f1897616b797310a9bb936443b37f2d10da6edf28fb0e35fbb84efa64643d7ed965e84cd9f4bf392f48e8dc3bc0a5a9b6acd1d2bb35e08f2c2a6e5c8cea805b0d921d0538508b646cc9d12728c6a2c8500490f930d7f8d1e47acf67503435564e40f77f133c48165a3b9357298912220d7ae197c5aca2f312e415aa8fd251ae3d116d1a62cc52e69f84ea1edfdc59ed5002a0f62aa68f938e75587cb0cf951b3fd609581355f757eb77edd80a0950cb42cea391858979f3844e4436fdb6e3679b5255cdc505c9a2e56d856044c593da5caa062238f19c178b68d8a486da12711699da8d46f948187850867aa618c8645b0306be54d3fa9638dc7838db12672ff5bfea31454087a2430f028d9e07509a56eb5025d2cded2b9a98227b19ed04aa8bceab27856d9bfb0e581998ecfeaf022a8827bedf88277940d5083ebd957f43116528ad51aa9d342187fbf76bc7007541a98fe9e72d2bf907189b026dab718380d3de657048883565b28f29e354edb0d8383381c2089144b72ac3c9c6bfd371c001c3a511124ba508c9fb7c980571476b4df11dc730bc051bf2df739b1ae76dafab986e9d065b5c3e412b15d882a2f974f707178d598d0866a589ef6c7d58950bdfc6d80fe6a4c6b62975ea993e74783aebd168115dd99b69381247a6b55fd2ec683e5c995c9aa5e3406b2b7795672507917f7464321a1f69dd7ac4e5c3617f733c2abc2b3f95ac682cfa1d0aa8dcc219c6a4fcf37a9e4312750ea94f34ba69cd94371727abf9ee3f4e479ba3f2f16cc1b3d0989a54ba52ba018966a2ec0131bf6e69caa9d3be7535240344086fe5370fc87403153d46b0b517f9a2cdc60a8a6892f9213e8a26de8611bd3f6dd95a70c216dcdaf42ea902e2f92e89783d2ef175e099db0a159dbadfd9e27ce190f07277d9a1817b24061f15b8e45271b15992bad1cbf4de3761bb2b4cd96225e15249c10b1036d28258ee0c89dfcc8c52cf20b3c365751b6f84b48c0353041a5200c061760fb5203f04940aef004fb958e6e7aad5c149229d367fdd5f9decb3cc0b49d8852a63824074e2be17aa38abf4743bdde0d35d04a9934e9ed39ea5f2ef0984e52288fc49d104d6df4096b6983299a2db2eccdaa594b5ee5902a59b502fd3136660cd511ac3b8f83f1df4cd582287aab206b83b0a64bf87129d5cdd40c33bc3d0ebd8118dad3de7d46e27afacfb6574aa9b88fab01d847056c350bf707a71ae1d4873f7f742fa6d49b9477f0b5ac708658154215105b74694ef03cb3c8b43c0f6d4e728456957514ede9e6ee0c546a1e89f16cfee4481b2c8a09717abea3f7db2744c0730cb36f79ae61055e7e6dd782b28a0162ebb683a25cbffcbd45cd5da0e7476da0246fb3acb6b6beff84832197b91223721ae1101ee3d3419d80b8a2b7cbe78b763f6ebd12d87238389f54dbcf0ab7a700e880bc520b257732c707986d197f40dbc77e2532513a646aaacae39caeb2023885ba30d4b74e97cf162852572054d47fd9ebddc187dc17668d55f452bf2b8a562d650499f5ae91afe4075cf022da4e1b4b64531fa846374154fe3733462419ee6aba032e08baedfbee437889a573dddddd449152917dd637780da7b83c400b05936dd6a3ea58b3d3d2542ccf2937b9d1c1a9d906439584dcb75da62820255a707ca53980399238701389e5cf8a8892ffd60c43a85842e92094680ba5e58cebeb065b239eb2d33d19e9e894ccc7dd3a20be932ec1363e73c27827d5eb957f2e72a897007ac11914cfc24e8f016f9519612d842f74cb001a65f22f3d686ec4979c549f363163b43fbd0bd4d2dca516921b3175c05bba9c1089e1f03f39ef32e100f6f980886ad3a4982c47b8cc5b832d4f3f2a0a6475224dda9a938279b006d5c14f8ebbc7098911464da4f291303ad18c7473be32133ae6e5c60581aa5d2749cf7cfa814896cb46a8560865b2345d6161f6779cdfe8da5d84ccf311304dda141529314a117ddbf853e06df7e3647ce9181597273d6ae86dde918a7f23177917fb195a936de0e8cc79477508a2dda4f832e9d0be236527af8ebcf4eba9e9f43775ab404f1294b28f59de90b6d6ad9196a6a3b06c613c2711bc1095d311e819a38cc52734e49c7f9908f4e60a4b9a77994a3c60c9a7add5a17d4b5b3120a4a1d921bbd3c37a20fea8fbe342700270409c397708841a15a8d000d5fa97ac77c8d5dc61e7f1f3a92585c68e049bfe7c5c2e08ea8fa70ab8e5d8a27add9113d905249704414899fc3c283163549f6c82af4034356235565c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
