<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84194b6a1212bd537035c3408463affbd6cf84e67e9080e5573a3098238c008d17579bb8e08809ffacc4c54c0893a52d1967dd7127417fd9e3710f826908fab0a428d0969cc4061bc046ddd6c5f4e0b051dd7982b00111e2e8fe12ee925583c36b04ed5e214e7ec8d28bcc2865ca2415e05f18d3df64e08e9adfb4403707b28d68863b143245b9d1822d450adcf1502c6004da17a215241e9494be060393deb0c8ce4d969b1fa69472a4068bb14dfa0b8110aca336ae5ef01165a973d22bf22c3b64d3155905c217e2d2b007f63399e4537fe68390e881ca261ff3801dee873b3e8095419905f110c8faff7271bee07aba55beeed992d01587f3058d7a7f1aafc9225caaa3f1a8d38d5f4f55c7d70a70d0e96b085e41c0605ab2f9f5bf3b81e0d3cb4e53bbb13cba701bdee2d564032abf2b1182b04d3fa384e79f91588f2ff5a01b27fbb5b6e2636384ff80d984c65b965321961e7415127ac29cf72d91e3688376c1dd39d39718a5242c2c3367f263dbe0a60b12272d2e257e7b3223d8407328b8a3c2c27d284c61ae642543c4990012a215b3a8ef78e41312650bf5a4386dcafd80f1f1ffe409052bb0785ca8f909761f5affa8265f0dbd8b1798deee77ec73a4964c17c5df604bd441844b47f446800e801dfdcebca863280d3cc1a8fa53d084635c704d10f2150240c638783e682276e8d0a68b29b4b9789468e3e6e02d4063c586f05b852e096862fa5ac55c548a20ef95569441ee2f91e2bac150382e6e0ab0aa56a697417b19ff3cb77ff5fb48b9fd58f1d4764b0c29b9e55b36c9338417ac93a91bd0baadd0a215901be70cb1b51061920ad6a8b2266072dd41eb5af590ca5b5a300dbde8f116bf85c64fd0f36deb4ec90695e24e981fb0c6982efccbbdda44fcac7bf5d1c9298c3c668f2a2cce826defaecd6fb4dda585326bc5dd3d9f8b2607626a5ba2ce08192ba210099739efde4d6403ef2b61f976727b06a2c24232aff23bc9abd4948db22bdd91e59e089190238e91e636db9ffdae777a3b3d6166c5f591424e3e7c8f97ee9965b38dce327c127d81f3e09aec19408cf0cf1dff7b3a8d525e5f687d5d5d964d77c7a90b57cc34b324944e7f2c37b67fdc41a54d90a093ced24eb4b631d9beecc1a444e5530b6be09ca8b9627fe47055a37ea57b6eb924b60860bb30d9b50f98f36d70025dfb2458f2c5de051a7c3c213a2c925139c5a613a1c830c74db8bdd9948f147bdcfbc11966ecea6ca88a91aa41d12a8a9e147e6813d2792d3f16bd17984921203acbbaa0e06711753af0615a6b665c275cc24dd9fe74692471b83471780d9effee06a0ac727f058631c533795f2f50d6743072b34a045bd4c533fc3e5c1716b6dc0fce3cfa153ef01bf16099e087fb95494108b74f433b32011b652dea5dbb1dd9c4075d256947af6931ef80e470a56569e18335c641f8629292e62b5b88f1f8c4502175fe21ac75336854a2e6c0db221e7fe67c34ff91b5b644a89390a79001d301b596ce398b1d76ee3ec921fd1a618e7cc44958d13748eb510f7676033de237a4f7bf288d599ac869241f89eb2c9eb5ac57c60d2db89cbb1bc27318b646b0eba0e7e2ad8d63ee3cb79d48f9940dbeb5acfcee2beb1032c9e29493e66ff0b558dc44de8b9f413e8ca1164d416a0457998cbfa81bf02859f84aa11da87c78000bd50a3a4931c45c9d4b30fd3c4e1d9f13ec1160348ef3d56e90babfa6f6f991b44bb436f1670b78dc61026c9959e19113d520a85dabcaaba31a4c60008d877ca9d9e18c3980b5df25b3df5bc34453fb0f9a805feabbfcb216991b6ec877401ed9590a86969c868cae82538d6637ee3fe2e40da0f5d8b79717625abff9ca827390e56015941c04f27c3bf237631ad5e13d942597c6088bbb35a40f215b4ae7d8fdfff8e4f790a023738dc3f95446c6787f405cba4bfb24dea0340fca8d12a732f16239398771bc419fd994e939e337c73e6cb8ff6cf6a4449e8cfee46f67619d2e3bc846afadb38528d4b99133fb5735288de63eff48f067f25416c39c161d6bf33ade3628ec25587039943ae173f4e7948795df7b6ac61a2003209c5e44480e6748968540741a23965624a103de127196fae6e5e9a46296319d8b9ba6c543ce682e130db8f82fb024c9020bcd1efdb3588bab98b7509eb93c63840f81be8034a9f5488d6d6d7f1d47b72c3265bac17cc4e0d780d3c7b05441bf357a4c06c28e087c70ea51c5149f6d63e889497cfa38ea0e0f6352deceefa40a61a73ea9449e527f62e881f7b94c5acd1aadeeedc19ff3748e24e1535bc39fb30105a4729948bcb96b4415a632145c79d932fd9df4c5b91d189c77d5a9f018ba2c9a492c0ea498bb9079c0c7f984fc098653f2ec8aebf1bcef19dc58b20fbe51a6ca2df7c24ad742a87d7025ec4fd942d719be6312fe3a7c98a7291d37db582542f468b678b59ade215d2bafd6c5d3adc59ab5fbdae1e2cfcf5259160e1aef872214242a8487dbf61b0e294617d14a0efd2af72b19fbb2024b17351f5b0f022a931db4aedce0c1250d0b04e2a970dd91b100b3be9d8fdc0fb1d9ef107af824e106f93b9c2dbace64f44924092c875f509d3ce14b7612c9e3f51c6c34589cf940bc4d3e033b192b6cbeb30c53dbe2852a9e7028b610d11dc9ec5201641c2f3a918021230908abe930cccd991f76f784434177db02f88103d45b61774b2b189b0610ce539ec065733cc09560757823842187190b92d82f71b64543701cb0cdf52cd21f9e4c5d10e5653012f633ea781a8a4e27416334a297187e5c9f55a6a1abd2728bf6bbf6b80829ef136823b53054790d9549cbd0c8a8bf4604b14d6283844d82e783a690b25f6469c6134548994c43eb73f6592b6839b1623d8bdb5ee9a0182889bb9e0baf108d84caf20c2359a6bf193b11bf2c8004af406fb44b14457cfc213cf94e544e5607aa0b94d8976de033fa3f0b487ca658ba3a5286747c55729d30767abaff224219e5d4ef23ad13cc318bab846fb07b93816e378a9f1fa5a23ba93a376570de2768fb4b3275aaef9ec0c3b5f8001f88d6f3706e4f85a872ba8f3bec3793c10f2175c9cb74e26512a03f6f2a91b9fab5f60c6669b109ef46c4649025629c914f5eacf54aacdff3f3bb3621b6cdea7f97804d1a1437a2a0ee526fa718602d03bd34fcfde30f6980399ce8be8d47e64ea073a27442cf0297a7670bdeeb83171e8c023be41c37cb899df84acda1529f472ca37374e2bb4e04eae96a2b034d4c2da3292563cd20f7131ca80df5c86a78be06622ec049ff94751ec8f08dd28140bbee175a63b2776dd83e1531cbe6539ab11c691536509ef138ea6c20831e3ce4b4485c1ac996ca22ba3ceb78e49b34c83b718402e636c392b963b38ef1c09b7897fa5b8dcec5cedcab2039773af7233471e41c5c64ccc506cc049f6f539cee9431885dd68ede0b6a28a0b51a0c80842062da8b4933c62eac9a0d53d30c0acfd8c0be9b325792ff15a824a4c258af6b17e2ad58ddd7d1ec795dbf32dac3f589dfb70cad8f4da3ac51a4b50a841256305931ecaf4afa1cc8c35f6b049a238eec2e4d17262167c5a22775cc76c2928feb860d86b97402df47c03b3a605a75fb325144f487e8d531659d649d89618eb527e5a9401ce0b0faef45217ed82eabbe4f3650a2c6f7eff9790457d2c3126f7351c30e26b3d4c5a551028d1daf22947747f12af620f559be0fac7db982564892f094927f19c12fb05d5f515ddb419fedb180995e370bbd9ae04224be899811936e01037db47f8c5e166d71fc2c816a4a27a8d0349dd1dbad56002c71346cc61ed236baa762ecc3b1ba238f44d5e7fed5e94a1aae2103dd854518599e29804c57e09166e4cc98f3ae5a5070941df329d17f0578774e3655b669cc2630ae7762bb67e9208584a75b29562196cc360532502723105970152ab962a07b8286032a09a2ba4173db6e35f557b2fdcca226ae4aefee3a1dea6f9bda468e89a280f36a480bc6cfdf7d8d711bd94cc15297c4d55626c4bfe5d5ffa0203a01a4e5b044e1c20b10fcd37045dda1daa5e3944a92bd8445b6c5400733f9c066171530520b7d44826baad606a24e085d204e550a3a365a0efe53cb65d29a6ade81d90bfc4a492a653a573cdb8825b0d188f2d40d6b95a904be2566b0ff37f923a1043d67ac2dd9f2879a6c5c6919f458f6a929266fdb469b7e44cd7aebc036d848330b5676f308af639d053feee1e4ee006c97741c61c25205825c178c902f912a38149b956c9cab8098b3695d4959969bb636308173622ab236ceeaa8fcc11f5f74974f2bad42828ea11d76b1fb7bcdf66619a90c6904bd06e3dac310f0246057e18730d808cb8b99b4c6a5713c9f545191b1050b595ac9f58e7a46bff3ae9f0b2986a89b957c02f634d17a1137e60da12415779464f331078fc19a7d185149cb4700987bafb1258b69eb885a9441fff9685f0d34e6a98f4f93fe53f946f870015de8b3513d2c2a53a3fecb71e7ab2ff179316145c85a88f411602b29e8ad5285ca1764a02cc702fe3ca518f741b3ea6cc3645339aef58c0e00142449067687472e74fb3497485442a788be996dc0971faaa091248af0ad37dd34432a61f052b301be6a153ee2f17356d8014b893926c268109486332fcd219b3cfe1462197d29570eb07e1403a5add837ed6f9d2f49bd6c8d3e238728220cbf0c1fda6f11750806877ac19aec7ff5162e1d089988f3333c10be05e0b70d691a223d8aa171a110299430152f0a2bf1f8fbd0bb2b9122b13c382aefd424fe1d1246c9fda8f99121dc1e22fbdd08809f710e2c2c073a68e45d41b9161fa35cad0d3775ab8fbb8e0f87391b0c6d430f35a0ddd677b0d088f80f8555ae5fcd7a7408e8d8745239be2d2cfcf436cef843cc2f5205970ef91154232306e0874f17e4b0beaa03e74d4ab7969839e18e15115de43063578cb971ff11c89205b2b8bde80baee5055a9aba4f350899466c8308428395554a0f73aa33d89b46a26f0b91427e341e7a7e1ecca4baec825c61350ccbe6341a9b3b73c597bd72b99928bf24d4c4180a9ad8e28d753e7b0aae85edcbd2b376ba22e7cc4abe78ccde27503e3494b41d575f98cd2c1ca26155352c32559406673854ba2aefa0062d0e112d0de888019ef3e61eb620c7b6fef6ae9a7167a156478927a3f9842aa4ffc8181c132ec18ef594226bd296d6cb6a57a82f59bbe517e2f2a35dd7eb3b1f05edfcc1c3b96f3bc066b5fd4319971aed96412565892c91280a101597207b12207b5f773e4099140ebd0b871def6f4574fd5f0e105aeb258456a2a00e8cdf47695dfc49084d33ab8942658d3710f74c99846de30b5cd7ea62c297dd28739aae7f1be69095158487b4d0219daad27207136a6d7b534ccf8fa3f06d372fc5c7e65f9a540662002c6824217add102662b0de763cc7519db610d127b106f3b979737d8e3d0db504858e44e5fbc2b96f600f22f04edd46d487c440e3c58ec611963abb2aafad727598ebc24223bd0bc3b44f3cac1432ec3324ae0e466fd2f40309245c420912302f144dbc6239e7293136181c1042d22bede078c8da681cf5e9961d023d98dcf0df4d09dca3c8b757d965e3ecd3dc09d68ce1c0e28c6fbd47934cd3a312f30915b627191e67ba294f4d880d76c4544c1ff0ac653b7152cf0b601f2f3af2b93e926d99a6885952130e94173e8b69184577636a3c9ddaff7d7195d5297c79bef1eb81bef6d4973bc59da8757997d18896cad0cc177754251a2d71895f7efb99f3dc84f8f2046aca8e62dba10f35f2851c5f54fe60f57c68038e2a44b80f3b27977eeb86eefc6b3bade66e02d7773eae7b2238a8eeb778cffafe28e8dfcca25ffcb7d3e21bbb6633849435db40d0453743862b82f6fd7dc54a8dadbfe328f6d140dc8ede39997c853b6221aad249edc9dac7d7e36283f4cb0e02ff43c9006fa93cd451cd47917ac392f2850549552e9a71a0670403f145d28bead5085fbe54a28ae002b6d2654cbadccc4412487d78b35da004927b1134c6a7aa0edd2153b1b5b70ac16636f4081511efb4785eb31fe67c750eb596d87e5ae67c8a572897ad9841cbd32eb46f561a6a0b70743f25680b74b8cf77d321231d9f6cb8dc03f45655f09d0bb180cc31bcec5eba0378566d981ea407f0bf9b8811d2e0475f27c1505c021fe31dccd8563fbabaa7e0102a377ad89bba7ae4800ad21b988556cca5ca51c1ab66693e1254d4895da44f3cc0a23b32c807fc87640f25485964b8e93099095ca1f5dcbb357cb2e976ced3e22dc7880f33894b88e6f09adbfad6535d020e3808be15ae0fd4de9786b13731025b04a550be49efb49583ce4218b4b81e30c139f941b2653a94440503829f98dc15b117486f441fc2c831f3b74e25a43731971195793d386b04a4aabe65667016db74e978fe8812ab70c3f32e91ecd4f7606c9fa1e7990ca8e095215790aa5787fe7139e5819e064ac5d7a52b2043194b779583e847e67365e69f67319b9642cbabe8f0d7f2e0029ce44160c538bc1bcad6ee3565a60f2aeec8dc8916d00bcf7a9c97a30fd4b59f2175c20ed9b47c6d0e7c8f796c08efe7745609160d8aef2fca0c96ab7c5aaa098a48575ce275274cfaea3f8c5d265f9b570d64780af9506dea283a4a3d898c4ce80872af12cb22968b2b1e70a1ce15734d38493f838b2238d3bff20b6dbf21ebbb5722d7ecba4c5c7eccc7820ab6893c55b94a0470418f852ad338398d0f2bd209107f7bad32f7813ad5392aaba1c1bd580f9cded1f0fc15f48cfe8e0318354bb9b2f0604b826ea2007c74c6b53973b64fb42cb9664b5860bb8f686450285f599f0cc60958cf7a67695bc28ecf4117e3ee738c6383d58cd4c18c6b1790b74a8acc01f7b8e5540b632810a9b1ef27650bb9c6b5f9518dc5383a477884e7f39b5282d3f283752f984cc649f3b406c07d4c981799f9680dd32d6109ae870d8cc45ba9ad4a8a4fd2c709e5728464742eee79b6c3995e532a6ceafb9c6bb58955515e319da9d8c820694baa4b84b28d41e4da9085eb7f87790b4d62a0a08befc7f7cc69f3c739983b13acadb6010e5e8cf5cd4c03138ae9fee93659ed58ff79cb56150d647844e1684897556a30facaf3add2e0dbe7308c7c4ef278c672f8ed8ca75a88f6e398087aa7cafd74fbad3c0e2c8c4d21036b42b345880da85d802b3bab0ce3001d5639f1a8a52c48b5a9050fd833798d1db962e8853309764fb46d8359b6455cf72c5d23bf4fe8ab590a5120761caa633c1a0bcc7d313fd04706bbad6e05318bfd5e4c3998b3b2acbb62d9ec5fbad44999de5969809b5f4b32fc2a9ee6a343865a8aadbe626d11e7cb249a6b4e7b2d143de43e99195d16b28582095e3a5fc34fc54645b71585624fdd5a4f59bb426bcf75af8262756c0e69fe2e00efdecebdda8907e03167f190560ad99c1003ffd10f1245dc5d91325d8ef5e134a8d481b8a1233e97a8384d647762524596812e9f4a31cae522421f4818173ffae188c173a28ca91ce46a9810df96009745d1d48612c505cdcdd1cba58d1ffd1fe630e93069558bd4fd87f0f67c566e00dc672fed94442b4b61ac3e44caa5cc2a5d2b1007ea9d91372a696a544225198cce398f464d806980c5b477ee743e86c4832cb1fa27a21d20067c94784f8096b121403b2b6a7beaf7e47669f3fceafa3a3eb957fdd0fac89b48ab97edf7047aa39885bdd5fef4c9b067458d14a646e86f0e896d1b49c8c029f775d9cfffbca532b6c9c377827d1382aac07476719e18037c9ab08011aa8130f8d422bb9caa0a92d224f5b5bca11e2020486d87eee9934d489c7f45c8bd7a08097c7e8609ef94210d24b52c7d309d03dbe5c721207c6c9a813dc804530439a27904caca53c69f30c54fe1b59ab5527035dadd381d514120c8ca50709fa3f6d29e8bb38f084495519b7e4f90b1233ea8f4917100dfe71e0ced2382621d12e5a19c4b4ca93d5880f9656c61a8d09a73596b8108283d2acb5b07f2438b4e5f2bd74447610d12481a74dc240adcfb439dd70ead6f842299618b5f54410f6e0bd0cc19081f816544f3f4daf3be8a73f6956fa44f87fc1e2fd15168fe0f37b368811f0d8b57d8567fdd22eef02036f8ca4a1b3d7f88ce116e75c8df0ca586a627de09ef565c5674d2ff660554c105613baf5e1f1191e2e196619f5311dde54211388b92573556d2ed17d45860d0e5d2147ec33c9a7428cf5b36647b4a0ce5f2de8c3419a84fce249f1bbe7dfb97718aeb12a3a38a696d5b07c177a78a52828c61c7341fcd628f0b50c6e3203a5f5522c8b049651fd0d726c57af6e1168bc2524ede1c079097a426e5bfd8ef56d393b3d18c08fc362848fd41e9125023e4b41a79fa7d225d8a3a303f04bb13b88364bce03ded54315efaabeebd5bd02034a6d87960587ad0f99692961dbd5b8d6ab7bbbea0fe5f926bc044d541343cea82ad83568159f9afacb6eae4461cf29af2ba944e7d8adb2b2494c31d1e7a570e10e3b6bdeab297890dcf476917173114f855523f915dd5b255c979525875155d1569852ca1c723d971ee425521483b92290842909e3bdf3fe7f1e1deb19ed62db9c1c706412371dd89029f02f58bc18df5f553cb6b6ee13e4e77d787f6d4ace375401ee9c396d6a2c549792ff4caf3ac2413978a342f1895fbf2f7797d4b6ac3b313302ea5a4e89ae4bca0963f0050482b2299ceb49328ab21b84c1c14655d0caeed427ba43f9f327dd0867aa52b49b2195864048f6975de69c1d4eca137d55936b2816581346981ec55a02c9695f71d7c14950a013b9a1123ec0607b0ff3663840d7b6aa61e455684a717bb51540445c232c8c53508db6629a13fb994261c89504c59ae845728024698a7827adfa05cc5add8b3c82f5dcae64d02a8afd90a0a834c36de07a6cb4ed17e1c227308bb066138b6fb49a89a84c5f39d6596a94d484e47d471f9044f5d02338edf2e18f642a305984d805fd226ef2292b620846d31ffd11bbba1ba7a15578b2c070b3f3e1421c9a3dc3fb7485f3a94c6bb1900d328791fc3afac9cc78f583de3cc1bea76f24496e9787a9c6164f4fcf608518e908d0b8043acbb41c997d2841335d421d5a92c770605423ddece99f42f4d48d6f865a3184e337c0a9388b77bcd521f1051820344fd30ab9f267cf678043b2239b399b9b66f3f2657f58d93183aac8af97e30c04b1589e01f669c639243695d34b1cfa173fa0a449af341ad88c6f73f6923502b2ed1a857c4adcd459ba7f938617ebc7f616c9eb0f8e97697612be0df4efbd2c42386ce1e2265b63b2e7a0d4cf340a3ba453ebf89eadd5c7934a8d63c20bff240d56d6c8783cf690504542d2abc6d8333bac9541e4456e1604d03c420a56e2694aaf6b18c84c4745669b4cff436f1152c732eec9af34b78743abc3366cb439f606d752a25d7064c5835c5429f9fe496fb97d9b3a88b35a870a85e1eaea97590a04ad6c17e1f653dd8bb18528b9612521a02c470bef7bf1d468fc919891129ea0754f1e918d4d65055dbc0a4655f4c5ab6ac3550e214e78dbcd3cbb473ca5b20bd347feded3856ea684735230214214366eec62965239451efdc8765bcc22f66e227ec0181941be7ee0a7762bcd23da19d20ae38c9bd1220b04707abba2153c737d908fe65e0511ecfc352b92acaac4b499b2f2e6c866a668ccf43e14dc7396b3da284693a31c4bada41c792ff0100a54435c9738ffb762f9866d8a8cd92852f26c8c50d9d09a8543b89e1af4e39d1c0d15f7c4996ada799cc6beb93c84e35edc0f5fdf6cdf1d1c09e213a21b03ba812e43c001630262ef635e3eed5dc8f5c51e0b718417cdd7ee6232f8bbe9c3f95c0b803b9d1087ad23f387e78fcf6f1c37a0fd714ff914e826332121dc0146dc579c7167ee15ba28bdaecdb2f4cea18714785ca448c71e011b18c50444f279e50de70e390d0f2d8ab7611de59850a7173263e4e7484aa61b959f222770033be017ffa1eb8ce3de52ac8247a6a67726409dfc93779537def8799b074bc921463b05111a70017f3e28d29fb260092919e162592d41c2c77130e123ede2c3690a844cf47fe3b421094cd2787d5398eabbe6a04255b1d17f467e52164d7260f3a7c9f81970f3eb6e0f1b547195984061a381cb8e47d68d97cbbe2612cced46b147d400824388814e36a6c97932d3aa55a47f64f730318d6c0005aa96a219cb51b6cbae46e3b0e64b51d26150c83ae139c6179c970f0b715481345b762ebab933a0fbe82a79ddafd520eaefc8958742c329232d3955c1351db85b339210eca5227a9f8e08ebcf1dcb0f96862c7e77470e163333fa668a2f1f3a73c1affd92dd31a7b7f483e85dd4831625d9b7a504cbaea1591c63b4eb2edb5d4914b7ad431faf54a5ae56a864cae00f3ac7837b878706e0e867761967920489e8698557948e5f7f5f08aade97248f84d6e7cd8f4a7b7d8c35ea666c4786c2a9c88551a94a49211cedef79c0754441c4bafcd6abdce8eee578bf285a2d374411ca3fb6a3854ef1ba87f083c4063f3c5771bbe49f4da4a71e948435cc18625f8def4ee45c701766f3a99fd2798bee8a5717a72d70e09a8b0d2968d51e2f82f27a7a8fab1c0cf8840ac4744fee3d464b0c7e18bcb80b7f56f90dbf5f99ddff57d73c10bb875fbd591db2ce7edfab7f897c72f33f76362dd58d7d72ff08c2e3b081f92a1654c424dfe83f7560fbfd154841ec05a1797f5706636b209df7bdbfa3b2455142ec956dee23c0b7109b8fcd84ad637f0f2ff4a1db0c985cfc1cfa7a0e7a672d1d9b493fb2226817d5e8fcc50fd1e54cbef1e875d3377c4a0565380e6ed52a846d8cb862c33fd4bea55a0fa795484824b2c24e24533e4a7fc4c673f185ad58868901002ac5706d86785bad58039307cd2d270e6580b6c8577ce8c182265d662029cd93179c633ca930e8c3e5de94c85fc80b44062b32573b7a8054bc51ee8fa73abe77095aab08ed93b628707c0f142b58efcf6065d9b1f05f1f429bef1578d6457062d70ea67a65a7581e686598affdc6ef478ddfecb1f54103f2235a346efbdc1d7e0ac65503cce83875ff4fa3d639503436e1353e7d0e1ab19da98f5c505add0aff89ae749c5dac61c5b15aa8520e44430f93f64d81b0f002c15b8ba09e326f0f9b5a61cc764b4159adae49f3b51ec2d6d02f234b27a6f6d0dda78cf9df8a0c9920f9449b614ecb9047db92f7bea6f4d974feaaedc11c862f400795123e5dccc01eae739efb88be02a9a1c9a35c64fa909ebc7086c007e9df1e3bea71f0002ab29c174598397df2393c2c751a02e5281fb38670d4fcc26678ae6dae79c62975196a297ba104b017664dbad1ce5e8ae4d9cc8c526acae5d013f81e1cd7604bf7dfb6097f705d460a77c163967a310fc8456c721332e17f13220978a81662cc9bbd4858f878815685bcd341a9d7f9e5cbdfaec9ddfc57a6d5a7043481fbcd5ae2d5b88bbbcdb2da985b828d54e12582686f9131f6bfc5640aed42132bc80fbb4f9a06449800eb33ceb7a0c6bbd220ecf47679592983d375f3772e799d60174987942b60825aed8614b4a5c41768e4d4923b2eace9b15e9d78247cb920426f491e0a62f7cf833e707b40637ee887ef5348f90d49e3fca503339a2dd93619b5ccbeeee5ddd999e9fdcd662ed275fabf713a11dd40d84a1c4de215f199a978c27ee034d17b4c137e7ee1905e23f50331b97aba8a929616f096bf80d8eea849e4088fae3329fdcd17623b883c2f1f813e54e1542d70950fb6692dcf1971f308e40f688e233e98d1868c0f2102baa87c7aa7e61122963674cddceb74d8e84a1b77df9bc9ae24cbb3610cc687e985a2e2f625dd98a6e7c513508a1628c0d21448a1a16d84535983f8d11ff4a7a7e2e4c48e7e0543daa6cf5b48026b53dd166942e16fde34e00dd1b2c0297024638135544114bbb0d39ae62650a4b7a441b4ea85f0852bd45b35013c331b370624e9594233cfbd70ee30af0963269321cb794589f78849d4a898f00c8b6bc6ce06f27171fcb58b8b4367f15bf003fc7dfc0f65b2da0d4a73b3db0cdee35d7ff0fafcd0c0121d8b440f2349a5a352a7f7b4f06f8f80cccba50a473be9e0c0150dfd708dcac475f3aa03dc72c2e08273d0ca25cd95a3acaa669596b99ef88185b045592157ccda11fed960e41b9da6dc215760b273ef66e4ee166f395b758dc74e7e54eb0505d8a4aa9045281e522fd8e14cec3a11453f661b6760892af3c9e107b0c225869835a7fd71f644dd906545d4e378927c2f316c36dbcabd68b1a68e4e49e9eae1e65121a4718bfbc5c53b632f3517e1e31942447edbd8fdcd8d55fc616209aec6e2d2bb7137e0b1d21f5a7e8b7300fea0ed28dcb9b9df24d1f8647cfa20017d91546b4926a5a5ad13459ce0d71ff51aad731b72f80ce5be49b427024c1de3c398cad4ffaddeaf63058c16bddc1f4587b522567b974014419fa79cc9cadaf2ee249ae8d78a5375b50bf3ea5f63e8d9c2fd94396b9d45e2d56f4da5986280eb3b16366068f4551c3382c883168afea906a2af04fa5df7b6c5fe386ed06c6748a115632079f9e897b63e4efdd3c20d49c1ef5845f26bc325555f445616ae673e9aa42469f731f50b8662c4b96d3ac68d9b7565f19851ef61e3da21a7cf797bc2f407f2746c74aef142d06438dd44b1378deea2992203b58bd1910c729b57ed7cf24e4d6132f593b67575b2dc47b2eb0ab05f4e2e720aa30f6ff41dfb2d1aa9a59947a6631226914696480e56c352b19753986d450f6f5da6a6483bd7c47e2e5674f41e523845d69784559b7f261b68ab9848f64761886c93562a7899efa862f2b7d77bf63ea9634fbc35d6305881ade4b50867b8e48a80c68037d1f396e6979face13bcefe95a0b184c6d28a5c0596d7d18e9333630267cbbe18544189e9111b47362272a78db7355c97a4e6379a8281a00f92c21fd4ffe8953ed486319b4776641903c5b966bfd194d219061269c7e9376830cf0ec2cfbc2a029e3747336d8389e530b58dc6112b0d8931dc01850c3e7d53a924b6fc42d75208d5cc1f2649603169f7656a296c5c924d340d7f07c0ea01d2771347f3af2b0640a35a9b1631b47e8ee2d233dae2f8da8dc6ba40c7ea09d2dabd1489a9bc65dce4fdc16bc2ead171d673569cac778b4ea313da48cc4ca1d2d03989a02834917573e558c88506a9b0d51c7a44cc62082db43f8a9c35bc5ac25c4b9f2e9d9671e1ec7614fd028cfef545630f2355baec8d4738b93bce7d4a5a0897400d6cf44afc4261200845c8e95dac1e644325b578113b8360492c85ee42a49c745c0e70f80552750d4d7703bf4d0b51c6cc19a7b0d7a7a45610c22b6d8923a30667907970cf07d0dd3dacd001e451816d7a4e2c009528741f562ff540c55a3da987e159edf315c09482e0d23afcb6a78e881683a4cd3fec60b653d628c79501da0ef7f255b1fc85303f70b9dc6151139c77d3a7c1594c74a92d97609048895d8d6136c19eacbdfeefbefcb36720c87b7ec8d448648dfce8a4d5e4939c2951981daf9e2510544dfaa6e9ef3a13d865251957a6a9a8c8c79c6458dfa72c9e79c29c17212ad9dbb0cc9e9e397515cabf6ad4da82332f563179d67b78b3e5bac294370f69d89fffe3ebd2dde95de202956950e0640a18008cd65de6b3f01c3f373da8799f51a3d08fae556997a89614de67e7ea7350a74d200bdb7517dc8edbc7310407198112d26c74cd8c6656f9f90d18ad474e3caca872f40b3bfc4002b91f3e8322d3824053a80c1d0703b9cb064897a9073b57a79a2068370817986eb774e906dcd9a143e2e75c6c0d44300391dfcccf4666c692f0306a66c83763ca31ac10eb85cdf433b16ba9242b1d65cecc26e75333ed3a2385156e0ac792661a870087de9e0ffa62e85b86c4181b6d562a677378ba6abf7096f5338c7aa3a15987cba3e861e936bdb716ef83fdba33739fa107a03f02c6db2a745d55d3cce879c3f33c2df43bc9e18fcf36fb481e4a1f0bb43f1cd079fd28d0f578c474e1547722f482937047fbce9a6120a95ed4f1da26f6b90194aadc74211ffb66062fa297fe0e04b83b6611db4a8609e43ffa5a5306d0cc7c7781b8f31de5b40e6886d7b54ccda25bc76cfb4a37db0df5526675e795e5972eeda54b4e52738d6bd720fe9c8ebd1682d0bdf767da448afaec9ae564d699b208c2e5b5158f698a456f87cec1b7a6c442ff5dfdc00032f861e3d249d388c66e96a4c5f637a79275645038e3455af9722b8a2edcd772168255859cd7030608372e02351e5c96b44e299c9744eef2d0bfd6d738c505d2210a27e70d04afc977dd7f43644c88eaf5449588deba080c6918751a3bc3325ebe119bed433dfcb1a95232330e933123ef9ce6043fdf98ac4b33882d4251ec62345c7fc30d8a35cf10a3a75db79cd64c360d2d330b26c56c6df4e709dbae5291849c8a0bc09e0794cde1db9a62db84e7dc9e2ec3e07f9824838f2a86d75a65d9549dfbc7a23345c17d9ff545e90284fb4093f78bc1499cf257c72f2d24d8d874f94b9266f31a19987f846c2e3deac6b373b938ff34b1ca65b0832abce02212d07471ac03d74dedb4f975a76ebb9cdf63f34aae89fdd2e32d6f8f0dc7cb1365c485fbaf09ab2df1490db22b8766dc7fb0ffa66acea18718087e56dc80fbb88afbb36304bf3e74b9e425f34c436e6cd7df12a3fce07af46c53900c7d9d601f50c7b9c4d8cf28640d83e43b8fd3048163a3dae66a7f9368497d6387b50949c810b7d0c60b884da477568f0cc5bbef15a62cfcd80f8b60f714cc8f1cd2e0b934c2c3919cc3862171d63121eff8af090443c8139aeea30452473f91199a0c5ef254e105a9ba66f6967d44ff5758f2f467acfc1cfd54f7b9233cb464743d8852fe689054073c2695c598d480576b95ecb30db5244689e70457b5705a2857ccaa80f71d6d14fbe04f83d2d98d094e7b4fa0eed3efb4e3b87c18e0f76a1ac523ec55052e6209a4b23f51a21c902be55e2f4cf8f9c735e6a6f07081377a8e7b3ee9e47d3e5a0a1cefb4e42223a94cd7bcfd327662d48c4bf2e0889981ff93bc52fe18c8b804545606b3596fd1430022bcb9bb24bfd1fea2eb909d29a0b34467268fc1c8dcfa24687259afc810e78ae5e94a400c571fb1952c1dc88a477f987902d6b004a160e0b6aaa9b242d0bc7eaaf48ff9ff41e6d59d2c56a999f5aadbcced8e890aa6f92795cc12395f6b7a2d94cc0a6c21b9ab4d3e94d1342893a29674b196ac0eccb2c8fa95e3de4c07cbc6cccccb260fb08adfb5a26b1f9a1423c6fd3600643a2de0e01985cd358628af65ea3652523df763776a978b887f582269eec36adfcc556c68505d80159da3fbf155d83a37e2bbbbc2c246170ddf6adb687a81e5db4a60f3cbf1bb5bf862ef2402c74cdb532442af460a259430b66e6057d118b8e4b0408fe7bc73736a5418c07d5620e1969a75ecdf3de3c2badecd2b801c3fe83db01374ca886479ce427cdaae91930f8a96630de95978f1a39f007c6df93462ac9d2ad5657f03c40837cd3135b5fbbf6139f21fee87163a34b507b4eeaac6d76fc38455738a96134dcb2a63baf4e942b9e27b4499a7b24d582c15b57235b3e8eb24786dc6198b5ea4bfe3d82fef4f78eecce948398faea797c39b840d6940fa62aebafd52789233f7d0867e5f43db0bb5fe9bbb707c9b49fa195135346ce9e83f00e65b3ab190042a982a4e11fe052abb8c0aef2462bc3fb3a0167349ca452a4e0722bfe5971ce369d30d13ce757415e02bfaf7645b3de85fdac2ba994fc8e95b826286c91600734ddfef97fd6313aa1e633252c05aeb55aac29a0caa25c4eca2cfb35e4f4ab26782312fde2119b7b54300dcc5f09d4bff5fa157f3826d3fc2a7ca4f167ab6184e79e1b4f95b3dd02126775fb57cc21d06dd5dfac3e798cb2941982f57496bd997874049bb452b664aaed73f2378f097b7ab9468e1fb49f662adc0bac84c3a10b4e0f68df0e74c4d97219a30c14aa4f40ee9d5cfa07bc4363d4423e24b25b9d9472e2b36f0d0c76c7f3dc63f03803da0e1570ccf6e71fffe24ea16e3265cc9e6da600315dd482d319040f0a984d6b80cce265f4210923a325072c8b919b9ddfc57a471573566383402620959f04e439ea508e5e245cbd7f291b4a87849e8457329842528d3639ed6b26efb629ae6ca36acbd080e6d4c68ce0c5626367b17fc0d3dc38f662668fcc5a315243780200d70277ebd3c51dd4da493293102914f32c0954102c84d57b722cf1b5cc7579034d068aaea6953405a214f906679b02cc958f7b23b7ff9cc195b702780ef2c62c5c14757a3283a67bd3669186dd70a586b86f429cf0d6edee5ae21e7ebc206fd75ec906b58f97148fe4b790f4d10a81c4decaea1697ec470263bbfb1954a40c3d75941685edb1498734769a0312a289366ccdbe6f639182d78e3cbf6469d7b3c4131ef7dd26e0ddf7b1cae896487a7fcb6e32161a7c153daf2c56cd70673433d67b8953601cecb546f20cae0e2d315d73825aefc34921b7a7947f4cb5c191e0eb724290a163f5022e9e056037e8a401d974f0dc1268da072d65317549c9872509db9a8f8f015d4857ad2d5762fc0733d88a88d50ce4d9c52790bcff83dd50e500ef2b6cd4a8cb7e9bcef73c9dabb7233b9e493b8018ddb620119a83bd782065a6b9ebdf6f1cd17da87f95fec6a6949eb9fda77b252f0d7bc8c8b1a5d4b5969345d4fbf490fe6007c89cdb1ffc3f12ad2c65147d48cb34b959cc5ef3110ba6adf8aef599a4f83973d123a9bbca66317c987f5b31c77022a0d3461dfe29d2d64464bc59055b8dbea7f3e75a0550197a88898f2d44a8a32d448d9460a18b4ab321b17f30067688e4fd6d371b5a266256b11bdcd99e1ccf140e3a6a8811859cad231cde06ed7b4af3d75594179d11dd256576bb702140e5ec9c40270505468e8265a537424b1c031ac6eb018dbd63a8a9e9fae901c8b3f11a63a69eef609fb24fa9c7be7d096cc3cc790c710bf7bdbd55558b437233b4b22c73f5be8230f4534d86f4184b99b6be5e553322d9222f6c541c21af7ed01f65c0ca25c0a06bbb10baf5837cb66ed3ee484f62424e3c2f58e0192726c7132e8f78a2e1626605d7283efe01ea990b2317574c141c230439e982d91ee406de80bc1b68a86406011759c7e46838374805e363982b0f8ebe58482a3fddb7fad85779f4bcae67f3c825a824e6edf29fe429e797ddb09dcfd35e23268e5627cd36532700741b6d00637f35d663d3d4515681fe6eaa91bbd4e86e6f970a31faf9ab97bf2b4622fb42af5476181ed2b23b186efb20a0b63f28b662834664d6f63a27b53b8bc4cfaa00194da342c9a214ab7b6a7435b8ae9c64eb06cd366d010279645f246ae084e0596384474beb452c38a27a004c698564d87ea7c760f5d5bbf5efa1895ae218365a9622ce7e0b00d5cd88ef295336526fc08f3e3d0e611bea5d85a2fbff413cfda56d73a9bfad0a34b8a945d46e063edce595c6d9bbe397eda39532520288e744ee3a0b982cf343c13d7c87d700590eabf83fd8d1077b5036719bdb351776f0c8d8062e30337bcceb34ffbce20995b7f562954e88f70349f3b031f73868ab1481baef2366bb60e65cd0f05536821d3d5a4b8ee538fd7b8cf737286861d3ee70d4b0f5c08521fbdfdf808cb79493b8c4222b5d5b4f43f8307d463a45ba26b0091a7bf8a0ae233e00913c853c974d0bc998c438d3e98cb2087c2967fd6748e8c2257e2aafcb090b50456fdebe108c98818a4ebdaefd7a39cddae8a066e84d4906f26ae5a204f5f14244afa7e5bd09512cd892c5f8030d65fbda5381091f8b41ec0e792ce896cb5ad3855b3036fc77d9531bdf4406f8d9b94da99a2b9ab9defd568dfec48103f5ab83a7b175f60e436ba1b0804d9aca4ee8e4869f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
