<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7901f9431b9e1f20a1305656d9031b42e1fb5fb6b64a82102fb18c13e4ca5ac288f410b0f33409b1286c25b4852f2eb689dbf633fba8ff8606caaf0f1f942ca0fdd02f4d33629ba5da2a84a209b0ece95a39a3ae128c3fa276603293d527c387c20a7faf179916074c1dbfc87d469292dd8401ae2cd8b97a70f356f7871fdd73168a12684c87e46514d44387fe844174c6e5ba7bafd73802f85a81c5494955ec8bba89ecf5a64dd8d0a7b8b6e569b4f6d4fd2522f02469067321857d4c36b2bf6a83b450e5594f6e2cb54e376edc57b2bcc5c0680e5108bb2157fc99fca961396f88a3b4bfb826b77fd3f04ae9d48e84a16e6800d581dfa5870294add731f79804f09ced5fd18cb9748620e896e726d1f1596034a134a98513a4aed3412dddb9e2dab19cb2becdd0408f5c3226e58a3a81f68bd2612198a9f2777d13ecf9dafc1f8df74e02f2517ff5fb1661aec1f47427d969865f824aecac5ea9dcda350bd32f999dbfe2889743c9741503547d5c20ead0a86608d16bbff04134842f88ad02b8ff9c362c16917ca6cd8a36119811c21c8613d80572575203cc86ca1d9229ad9337e6ca3227ec9efa2425a2ac04e485bfab47866c5fe8e80522ed2f60868f5ed6ce2e479c459bb96598e30771b6ecb986bd308a3fbee4bbd61d05bb32f2a51d1c755b4b3cf88fd3122819e656ed7eda3094364fddd7b881df0645dd01c43c0a256c93276cc70fa3182d47d89d861da05640ad0c06dea48e0ea3cf63305f0eccb10120b603095638495f8183e749ab2506c8bf4db03ad6ff89b3ac9702e1d7538f4680cf3dc4164d46debd858594f058734e500432a6df2e07ac16c8357643ec49af167a7c9aacb9d1b75473858b40adfa6b1cf272c7cea1ea61753cb2d52f630edf6f1913a40dd703f45282a823ac9033887dca30c101e9f4d5b530b10a094b029dce80b6c7147deba1613a0b7abffd62eeb358b37b01af85f8d2a7d3f1bcca6483cca9b9a3bd2cb4b5a3c04b846c4b22e7f16f623261d294029b6e8e88382bb1b5018447360cf05bda9c6c8726a2b9569a658cec0a05837bae48c004056a9582a3314dd428e4a9cd1b324e2ae390da35ba214f9ebd4f5dc122aa80773272e4803cc11dc17e8af5faef49891e115e0a742233484e03220396afe520334d9317fb9fb7b5d1157357be4d035eea5d61fb60183523f069d1ab23f91dfec3b5dabae2aba52e28385c15407689338c762a8becd21507d38db602713b4a366f44d8204c137c4b005175763f18340eadaecb7b62fd7db12816dfa73b787ae51c5c0fcd34e10badabc8bd2f3f502612825aa0815ac97b563867a8f2b0af2c025ec9fab3336f3eeb6cb13e30a7bad41da4fe0dc9b8a30390b0932c06ba2b08bc4a590885b61c9b5cc1521a57f3947eb59c6a3438ef7c60c8a60eb40d9d4c419ab185328670ab6ddb204ecef4e16a32ae64584bf1b442173ba48a3722bb4efa493fde31f63570414f249f7eaeb92f879b1a1eff061179f6085c13ebafdcb02c45900b265946755353a2c1e532d83619a317d8473fee396101b9eef6dfc971ce3f7cdc9ff60bb2d913e1dad6f1c5b0069898983ac0600e2f50daa57a4b25a3d9e813403b4ed750d9e40e80d38b6b69d12a24e7f5bca507c3393cd9175419444988b072a8972017e54ed5d41f66064a75e64d2addd7cdbc5ba5de8fc7653adf4efd7b141f2119a84e003688dbf226b52112a6806aeed0fb93acf167aef8e71e1d0e1bdbd9b54df5625d36c1b6ff0b5ee6f4194e2097055cffc66222e309230c1a06a63813930dbdd14f28fd4e03b5a1d12392aa22f03a7f4a0d8f3350ab0b1283a707d353848ce91b54dbdf0170eb09544adf021d6208aa8965997694eb2025901e278016188e057fa7a4b78bead9bb5fd84caeb4d5bfb8ea70a4f0acd454dbef4a75cad11ee6f7f46e5b7385a771e7f66008564c69fe5524264839725671f17a35a841ca70ace18d30789c2f540cd7b67592c47b74d375c50bb9d5a6a76f36dcd1d104770447157c2325a333a050a854c4a4ea7490852b7637d3e999444efd5af323cb24284f3ba9eba7196c9945f0bc4e0d6bd396e133010df47d28374c119acbc4ea7c181c41782d41d1a688253572e8f51a321b7d6cc88e6049d3bfd94b573a6d6829b2e88623582553976091ea78f7396326e5c28ead1267b6bdf04c20e14e31f443f0fa734ef2202835f2720873894bc5108ba070ff0d9e15835574cd58dd98f5cdc15b0a78b8e029f358368e7d39eed82bb846bba28df4ca54a19bfab1d9687455be81d63d3c137f697a41b42bcb772229e299d92d9de37cbd8b3e96f14f8088b4a2af11fd895a8bf8a5f9d90dffd5674f7c9c491a1c1459cff6ad914b1f76a57f05578e7ca749c0eed44340e44b1a6a82a76da9f21bb82380d504d64b65f7fda909dd7bbf5e3c79daceab6370490310822f4852b7aabc83120e73dbcc277cfb4e6d2698a9476776854d768a7879833e36c2e642e0f8bb43b48769edde20862b80111b2fc6916c3b0e0f73667cabc710f43500e34fbb4d9ce61c509f5f6bdf16aafdf71063237ed6a2c0d55ab7a5adae9345a14f68933d2b7f4e8fb7e47aa4c7ff13425ec1cd1a8e09e41a01a7831ec1ffc81d2b2bda1328ca973da0db19b8eeb7adb1640eba6eb15c3316c4359bfef35e1809763d8692a26ea3d60a2e0aab50554f4929d8cd56a8271c5a63fa40974ade4b7e0ad8d481dfa040f3835801e3c91470972772e4e4b15817f2af524bd1c3d629f3eb955aefb7a55d6206578f5fc49b9cb8536fa1c2d1a78d91cea5d2afd7d5201ab0811d66539080a792c831d72bf87940dae6a4d65f1f9503218b899c8c4f53ed37dc86c90c436d586147269a1666175d9ccb05052c3bbe4420b103e24664f3d6897ba4302192e82e5da3770399ada39dc31068fb5a394c924d21a3d7162ebd781364da54b2ed8758a672e239af805b471cb656ee3e0037a01c0e55da8691d52f8668da14246009ba76631331005b5eccbe4a0458ebc83a9193897a09de932e4661e3e12ab0c4a194d364ee219ae09c2c56db57b14860319642a594fdb5b1f2ee4e6b18000ce70a65cf1c65522887ac6e8681df26b1f6511a3e098ae1aa2cb24dc6614d936b28dc0ecc5cac6bd837c6237885ee0d5bed9b035304a737eecb581adf6701942f904dde7701bac1915117b46bab6ee40804a3dfc5413bc1f9bb13aefaecf0cbf748266467efe0dab36886b855ab0e3d6e3b8bc22731c2eecc951529966222cfc6215a87d6588eeb64d266dd7b32e89ece493b6c44196cd8fc2cd5850cef25436e0afeda730784e82c5c8cb6a5170b371125eb574ac98a30d81b0744aa187deffa3621cd0df808204c225495c86592b68d0c39b92fbfe5af707dbbd852068478614aad9c890a968f34a0a36e16079560f965b529268159e49f631fea19dd56c32bbd09e10ca1c06664fcc2adfa8ba7ec92e62b618fd8ac69474d9c771c5d3b7e0830c692533db924cffef6d5cbf7c08d80ca18b59b110d0a9460cf54348dee2e7a3f1caea137170f6687734582eb70f5472cfd4c67235473beb203b1eca017484739705f1feb539b351eeb6c5f929f6e457f0883a16019d7c4dbd92b99a2f09f8afe78a61deb3f40d5da5f2fc8bec8465fcd9908bf7634dce62cbcf53977a425aae034604ee82e2446d4c31c215ec757ccc94a97f55d0d0385c632db2b3ea3db35664ed1692d948bda6925931271c9a05a9a36cb567e4fc3bd485661c95f0022acdf6833efefdafd974394f9c334108b681f180e7850292e077cc181e5e0d426f9bd982067a54cb2d2b67b31715e466d037dec4da4fa8d8cff38409ee899a7df2d2628374e7234ad9eb749b061497dfcf3c27dc48f298d8a4f4a31e5eec8be340d5b653773de2e310236d4105d7ef7b02f903d58377d95c1219db01e87d5af98e02df85329b2178b7a31c637174256490f2133fe9b31d20c8c377be87ef3bc10a32fb4a426f11ea27c46a8a60f64ed348799788e91a0bfc7119b0e14576f61ac694a7d20442f0e382d05ab0af862a668034b157c735af6e836c984c0f7024dc37a327da43adb3d8a4639b6f2cf16279a1630dfd2b6385dabaf99fa745bd5c60017283c09e7aa701669d45065ec8e9ec6408aa92decdee793e45378aa47c9f3f20f5df1542bf9c38cd4d345de299b9a6f9ee90cded85a07e73434d4ffba78d90c8da9a59fdfe33fa5633c340da9de0bf2c38903d699fc78cd1167e3cbde98cbb44c2e2e7335e9da118eb76fa86c130bc1cb6dd0898398b246c62a5c874b9108e3b90273ad2cd399ab21ca00df6b56e11e7a41a25f8102ab26a38e1628b08f7440a62bf7243e68a69f2d75178224d2296c90f58d58a0ef24391a9cc052eb9a2d82f06407de68fec8b2923964674e8be84a49c6601b89f92c7578bf750fb5ff9e66d0142bf6c22b8f8091e64baf6f9021176cf945f9696f5f82715ae22ac5668230020cf99d6a47a7d2591c985f5320ef3408058edee50e27d5582c16c4431d73ca1851ad1a1f9b32582ff201f14c500ca7cb3c3107b6cc67d3c372e64c20d9c3908003e4e2f94e9fdbfc3e8696b81b064e21dd245fcd75a08337714dd3b11c64bae9a2e12e11cc29a0e9e6868b574ffb22b110858e16023f099c57f62a46fdbb38150d3c7e95b77cbf35b1ed78388efa7ee1f18d261c6131502e8a207eb63f918f77b8a4d30269c2d77ee5264b7dba605eedf17bebf08e6c3963ea3cad0bc8dd39e94003ed216bf1fe560170d7b5a5ee57c678a6853f77b918c2be4089be46d0e005c2bee3d5d68d6f991f43c1661888b0b657c0dfe3dadc552e30e6c1092ba9e9e413599ac5401048474c944e27c34e063a0f159be1b1f61398b89215564108ac1052b86297e67ab3486b56fc78193ea47129b9a9563304f69bea80df69f8adf9ff3672e39c6737c55112699f46309ba735a2057938d1e4218ebce73d20fe2780cc5eda1b6578c69effd428836570f469e11026401c260604babca87197f26a08cf9f60effb6334443302f243f5627d11314b7601196f40b6e3814ab5ae952c5d0db831d32df4a6a87effbc3f8bfd3c5cf896261ce3b7365184d0714194c30c359253af5ec35d136f3af5c98f839e707f0d45bf2e8f01dab18fe2410359c00bb367fda0e8409cd4ae29c9d055eaa7ce6c7ed2a67248f10315cc81b70d1cca851cc1e3ca52e405ef3946836c0f2045b9fff37a11767da51cfeaf525aae9d0c79c0e055a54bf79e3d2651dc2fece20da2fe9df8242b4aba8cb989557d4f8161b407f2f7ff0757a634c488ad9bf67fb33fe42c4c011051dc4e21e400fb7cbfb4e41f66bfa4f161c6a94476a2348ce306e59a02eabdd5d37989a1b743c443758e42870317342247f6494ddf66f563f88d54c204f82b32b47d90e4ec35aa8a4fc3adaabe79a477c26dfda33a6b8a14594eef2cfe835eb897b6cce3a2a7143d779fd68e79431655dcc07816084b7d0e253c896a6b09abc4b5b0eb61b8a66fd1417d0de0742408af7c2521062396bd173bad217c0a2196a4fae8f649d6ec96cf39f3201949b21e9108026eb6dfa3c27bbcce2af55a0a8941c391f13498be3998924951ad1d8706fe31a095eefba29157612f5ccfb697c114024c16fea651dd179ebf2eff7d6f87bfad2b79d1d0da94c78038dfaba8fabc83d5045c570d331b49a5f80788664fa76ac2562d3a39f282c20fd3bcf923d5cefed73d39eabadab5238f04beb21ab7e7716992cc410ff6db8a00b0dd27dd187e69db4f35764db6631983a54e7195e5114931fdbbfe5f473040344f638cbbf65da8ebf072fd25d497a2264cad5d5ffab727cfe09183334194de3ca76d7731b8b0ba24c434887b415b3a7eafcf3428f2074ccc9a2b4718324d61706506cbb23f60b979f58c2183323f3b6b8ddcb1ec37652e6ac080cf62cd68db44205522001b4aa74b1da1d5b9e164fe79f8a21965318cc4c5ccb9043eac5d0e7af44b831b33473afd1a378e31bd4e386c0aefcf4eb00917b83c163e0ec18096cbc3f31fca2113bf2f201c89f29d9a8cc809e9e41925fa025e52ec6034f62dcb1d4f7967f719a62924b835d4f6f090be6098c9dc27c45800d73733dda393df40bedfb4a611ed334312e1d487a4d86518b4e1e1f3196e74f486babd559e64d1c8cf85474b78b8eb46e0f07cd886ece55ef76ab4ceac721c05ca5b9651584477846d6ebb9905b402de5444390cf51cf7a9ebcd4ccb0919f7a973acf1eafd06bb1a5ef3440c69082cc27e096d8cef4f90dce04dbe337c54e978b95a2c91e29c5e85df304ad43434583c04e49deda6e6e6b4ff651e60f2db28dd84b484727b3403bc0f4fb7557e7da3bdd6b574fc91e3e0289b0ec6d518a73bb5639f03d4dd61dcc36086dc68a101b035b680c8618c7063e6814ffd1a92d4727322a35433070c9f1cc21794d3308722ce1d2f52b29df4fbc3d66a000b1333f4ad2dba4b3da0421f04e5e852cd2c2b13d0f871fc033dca67e62773f0c2fbdfc01016534b7560f96c586a8e77b7cc46d05509c91d63157bc820880734fc9c0ab4bbe7996b55f8fd19b4543b0f27bab0351369fbe5e2ce36b1794cf52355f1bf01ad1dfb4d2fbaf031e6fab68d950fd0e47da22e86609315acd4e42aba9bb98d44a16a8ad6c694e81ff4a6c9aba399b06669912b6e36230256e685862371a67329126b0672b311ea916d3f12f9b0d66e1128da421e758f2725c1f44d5ac20c6891aadfc37b674e4df09b6ef3ff6beb57b48c595ff5a7a3a2e447fa757006abd80d580261f5e160536e26803cb18637d14f77ea497f2faa5cdd8272499e2da686c43290cc1ed6083a7c21e3e8118ca770b010f0acd3cec45d6425e1ee62e0fbd510f011eee45f3d7741d2c88a7ab4171a8bdd67ddedb1061b132572b3416b2df14ed8a74005105a38d421024c7ad0bd9dafc3e55cff23d70fc0f292385abfaafed0eb2154356b400052453f53708cfdc4c62371f13331f8e5abf4ad1b7eff40d072adf5f26a388b606bdf3a4e079143d5cfbb33c5e2f5f0f7c76b5b531dd14b700ea97debe5ad52c72ac590c322c1803d783755a69eaf3292c06116fa1ea2403cf144ece2bf35ade0a68df31c8044fca90e017d17e0f0733da41b4c18382301795cab08412e9a8f019ef64c7cab312df33117e9579cb8e6835f96a548e09c349931000b20769e3e53b8eac604877d69bee81e1f0135cf03de2c45f7fca24cca1594406602286a24f3ec8aa40087c26a15399d3782f8f3aaa86dadf823d182cb7b00f8ee03858cfbca25070ff99cf18ae701cdc505564c14069ec07d789078f21f3027bfb6508a8a1093cce3f425cfa9b9b260b318fea4268d7ba6d4c0d8f1d46242599f1177337fa9475aabf872b035eef547a3a70e3c7803d58476efeecec7ae55a8537c6c9bc8ec80b7dd78deb683af315fb83f55fec9bcd7eda6b1ac815997b72b6d51ed44aa1fbeabc32a693ca404a5e687a28953f783e46f397d1d019f62ecfc7c10acc1e53554713e83265000a02b3c9a2e402c2e73446c7d5cc2c93181b65f4f729858647dc87ae3441926f19e2bf0be1e35fd3af4e5e0f17c9eee0c0359e3f68d37f53a8983b9979956fecff71e5e876e545d9ab9c1ab4e8ff6c9b14875041982c9048bf0058bda7579a80c84a8dedc3434de5b0f43715955e203673e581d6ef00a71caa14863f12fe13ee05e38389a3fb42d77ba98f781f60b6a5d3c41949cf6fc303051417215fa88c3774ea92f60dd2ca7f3ce26076873d708a024e3116ded05ff0c97235ef97a3c986594903adf0d7298c888970481bd6087524874c9f3bb10a1b48a6c9e4730a5e2a863593149b1e68d9a9dbbc2394bf74f4d00a9954203342cec0b88a40c047c291230c8b6f2d3f00facd6b098fc2103e2b29c1fb07e5cec600081ad8a65811e50f816749c4215a431b2faa992dff780068a37b3d572c5a990a90cb8fb6b12ded01139559a96528be26a64e261dc72f1c21d006d31385108f455ab376365926c49a9e93ad22d0c7ddb61945434fdffc4938f1c3e0277c00fa3c47c084a477a8d94c57187a9d64ceae37a6c177f24bb6b078906827c8cb09967c3eafc2f10d8ef62d3b93d2858e494f897e29a34776bf01c3b61f1da3fbf19f3e5641c06689c36e7f3749a68624e86e4a8c1c002bbd8cc1e906bcad7784852feb7ad6b9d2045c0abaa5009203bda4b0271118f8f4e024112e982a7549d683277df8b16c36742014706c62c6fd8b43ff62d88a6b29cbcc409700c2d6c4784bdced96c998a1dfb5b3eb15d3ef2b2888b0b9db21a618e534869f97dd825384bcd38827ef8e4d249a0195b6ef155dafe88ecc07d5a2b8c918af7c2ff991266831fd9f1d635b590c662324ffe6d1404b490699fedde8080c6f7b2638304693d077f99f3c73c15581bafde9ef613ea14d12a29588492c1b599cadaee892a77f12796fb2e50ec9e2e8f78d6d7263b2d395e025d941a002b4f9314af8aa3e7844c39e52348803330e007ae6982264f30940e2c025159a9f5bd5e808442de913a58e72b82569ff462a60dae5a77482e034d8eca20e30255e79fa3cba68e2e9cbaa63c0df81e621798f323ef665deb4b0d76bed0f316fc0bf8af30ec937dfea187c3d47ac5fbd641c41796b555b484ed1192710546becdacce451247d1e9998cf829e615db8b467beb39e1e9d80d309f34a754b3cca589ac6fbab888ace594547b0eee6f952f89101f11a9e3799027a881d085b15be1dfe43efb910fd7a7612f5268c2a87e07f08ccf59056e336e9083cddac8d188276dd850a43586537251f1a3697b91255507c95b3aeb23f566b3d3ff5e6cddc87d6ec890b2e0a956f4834c698c1c131e6f390b18b1a3993e2924f6276ff3bb112c544234c2530b2a3df718c4eff6ca80521ede7ccb27888ab1add1e8b21500e6124aaca169352dae334409a34af534d4bf61c6580b7c487919060418da13d178cb8bae61559773e791840f6e5afd02af62e7657f5791ef1e90256b1ca58db08d7e48417945e389697a4c84cf7cb7c3732ab740a4ecee28fdacfcd42ca69567a8100dafb323dd45364be5f2ab89728b1eeea9fa4ed1214c355f19ad726d65b21bed69c77b3fc7d9cdce6514742efa17022b7fe32033a4076667675828407460e49522f5b686d09c79918d6a653bb747e33171db371ea947d625a687b14cc27f400d2b90c5892f8437897224d66bb0f3fd13c4c7e3b7888adadd94705c07025b5719a7df20d1299dd4d5086e98a2b99a439702d27a0691123f480c91b684c0af0f7b2bdec6ed3ded5417d181a0d3d50b313ba971f1248060f7d3c440a58863cd451b049d36b50fbf0133d0e8cc26c45a735f51816f1394084b36acbf6e23fd4218250d8979082a277c1887c77534dc3aba82f89008035d30454ec6349f9885efd68ca89131f8ba0a7881223203b235c2f1e79f1dfbd1474cf6527d098f110c38032645ccf72019f5187e44d9fb337eafdac5d7b19d85227b7a5131717037f50b8e59297403219791633c398fd4d1d7c94957a9bf6039a05b7737b3ac69cf3ebc7560c830741c3a9626d2a89a0330fd16543b10da191f6903ab4646a864609dc3a63c6e0405a218400fcad709d989d63c37f564ccef5d286c3ea55138fe7dc5cbc555f7e2421033e60c274ae4db188571b141626661ddaa04570147c4aecd1bf6f04a3cc52afe0106d4de98d9df7395c0c8c33130492d01fab8ad866fb41cac46fbb51521f9d0d1f9d7479471c974cd2854952d8a8496e5182193d14444215bbbfc9e51b60c3eb957e696b52e080f2a8bcc5c569a025caa58e627c0c6b8b4049e9edf5623b1448a6ceb03cd7c070b6c9ad7c4be3a1b98ec02a1cc9da5bdeedbebf8d9861a18fceecca811e017f2dae52825ff5789fdec41de55ef8f627e06cd1b29a467cc8186a28efe5dec783a83af3fcba3cb539339cd7a8c6450451bf7da67b64fbac61e4e538e120ee2dce8c14ee448426e18d07dcb843c2ddbc77bb00b190f3fff39a66556dd7ba11e4dc0bc13a581204e11ae1697b27d2aa34c8690eee740a232cad0ae902e21fb87a3bf6cd0523ce094fa4cec60e43c22390aa813faeebaa3c6e67fce3c153d5ffcd18323f09cc27c865fba0822b1304ccd9df60ba6adcc649121370567c9ebfe51e277afe30f1d8e802571bfa15ca19b9ea8fa3b914da5ea40dbb3519e4f1883c5fd484a9dfdb3444b4babeb7ba5a0e514ca22ff384f9df3ba40377d3c6e9c257b6ff799113bc0c5c6351b976c7afcdbf202c36db3808a6ea74ec11a0b85b198d5ce7790ca3254edf40eddc3e9b7ea383ba74aa8a54f5f1f751f3ea8af24390707224a9dc75ba766868c9def4c915ceecfa570ea3b794eeedec3219d19f17dae9fbcdbfae310524d4653b194b07851c5bbe7e7451b99c4423ee24ebe5db07921f4120c80eb21062222f39f858b65ed7409fd540482c940420cd9e3ab9622ce0ca9d605adabf8b3fd8af6a803bf3187f90df997dda75acb6f3cc389a9b40b0b4b1ecdc0dea26e4bc122b7159ab907f7e3684c728eba7030320678fcc9b83a00cf5b9a97d540c429dcac58c2d20111c27f67d7a555ce48df3c8ddee58bc58d4029b7ea1e0bb993108a0e97569dea130783a99d052a96262c4df2f0019b68d5cc1505458f958b84cda75984788dafe40b20e8474f20cdc4d1b670b576869e3aa6c9b275123588b1322fe791b1b59ed705246bb1885c1e4ba9ac65c81dda25302bf35b47a996c532feb77fb919f11132d901fea91b98f2dac7455894ff80335fe88a870286c29dbfd48b40a5dc927ca9ca154d4b258d724a96afc5737fcd9068e8def618e7a7545857f306cf00baca1a34d65d2edf7232719b75ab72366fc14b06aa6f9389dfe198126c63090a0e82e12d68dfa6f2690ca636734d940a6154c20b50ae0398be388dd8c8d31c2ff4ab99d88592e8099e4c9d492cb434ad2f5996e6be0074b35f6a8c63e7ac99e5e9320d53c674c3f7f6a78074aab27c0922c331e7eb73b0bf301db924fbdeb9b1faf1a733030653c6bec707b0bc4ed2e580a6dfff6e70ddb2551223108da8fac1ee875550bfbe0925ca8fa4d81dea981f335292d910de3a103e8bd4a860b62f1783eb20ea5397bb0667a092892f13464624744a427d66235ba6770edab4f7e644cd2d1f3f2e470bb27c4ce850c5dbb61d561b955525d29a75e3d1297004863f145ded09b30d72197a1cf756ff89d18a57a0dd076304c3da628b78d85b568c1ca851bf485832b52ec45cf6dfb99fef54a05c169c3c1e934a570b921225cd8aed5da2eb77ec86fdda95b605dc3afe88364920793f5bce402c6c8a0e64b3121886740359ca6c42585121aa29289cacd7210b3fa83aab907345c4f0f28fad5cd3c26960f0602c46c4c0f9ebae1829a6950e6b90c8fe38f960b47e67e32a289d37299c2824298e23aba8e4867b2d2f6dc2c6517d276e1ced65ab094aaaae33af39e135cc7f1d712a3e6f9c29de3372c7f7bde9baf93f0e3830769740a119432bcd0bd1ca900187fc76d6bb0432a162546a7c33d12ab0d1d5f870f55d0161ee791624198042b4924c2fae6ae1d42c1543702f4fb1187c64c8ac05cd46b4fd298765263322dc4ea82b01294fea4411319b1f322ffb69f7dde7110abef98777026a4cf3155c9d14d2db7a43c04795441dff6d69690edae3c5f6366ab5f0fd947aede95f5b0b38d547529570916089273255c7027d2f3c347d1ffc8302dcd621cfb2247744cd85705ba4cdbeb6f0df0dace1e3755abb8d6eba954581ef3933108f797768d32cc8c8bd01823019961e3afb19f9afea8549356ab9bedb8d034750cecd8f49f5b578c4803bdba1d8ff2bb84cec7319e91401086bcea75b4ce5e9ca820df8e9521db1548ca497d8d904c6dc015ccf4cf8e1b3cbc5c932b480c7a22e64def9c515314b1e611064e52a38cc420fd82b99dd3bc331b2ac7c3636f226a81964f0f346cc91bf87ea268d17a1091642963337fe59b629aa21ef298593f148eb150684cb405db748045205a9f527dbe7ff8f3ce5b8dd0698fab3a5ca3e5f19c88d58752523fbd90b814b1e666c33e916cf5d92014471b1d12270d13a7d6508187993362e8361868bd168d5cf9490e07c667d4dc5a360a7a61e2a2d533034ecb14b44b53f2f9a40b5205c58bf5947743eb73f4edb8d44d711cc70e1769872074290f423874f080bdb9fa9688e3b64e54afbd516c89d3bf8e6d0becddbdd14ac5c113f50297838d336f86e9a0b52391f6c547f19727536d7b2e49e23f1976ea6a2a5cab8f137166f98e4dddf83d1d00462817ed1c50e3e5db5de2a1d89986a287430af5da675eed7565a6e60ad74762f629390435bfd17e6b23464f75fdfc95ff92e099f4866b94f08951f320bd43034ff37ca122f6fdb0c959e918b315ddf3c07117185214e4f70fcf099a3a6b602ba13f5b493ac5a1e7fec9e16954ae19865703f4f7828457a06488008a11ea925cebf6adbd961d0aa5e7e3b3c6910cab96b7f2b6deb39c02c014b78459f83e4d20616a7ee65ead11771a382591cf086bca15f65cc080324e7297a1614222ee2cbe4e39dc904a1b17b8a1eba516a9df29aee6099d3c56089949be2d4e8dcd7eef182a3403f68b22c2120621a57621ed56de327405981aaf3ea99c9187ee04627c9ea55f5f1ea8519a177b62c3c5812ede57f6ddc426e11584536e6ac87aa413d438697a359f3246ab2d3a4cf774675d542fcf7cdadeea5488d7de1ffab99d9f096f7c18faecf54d9c00adb66affbd898f7bf43fc627531c6bc428ba274cb360ea52db8561bd41a5121d4467adaf798a12ba9945798174cba907bc7ded29a3ad92ff0e8af984cf40e5b21669b256d3f86e41152043008bc8c77763dac3ede807bbd969f060514070036f99ae85378f4e615b27c6854dd0b84d7c3c53efe22bc1be8690cfcc4cb28b0c158c4a2e66182ec16ce4cc13c8fb46a0bb4115d54a80a7bfdf71ef6e674e73d9cf59c92cf0f2856fa5f57c627a13f27217c18c184d0404fad332e044febc1a21c32ae55205ba4af11e537b91c7d286d89f3d1f83fbd4e5c26024415796ee414069b1794aebdd89805fbf0e90fcf2f962c233bcc97ed9334c03a6bab94f29055c1c4518baac28be680e505fa15b3b8197eeab93b86bc13c36cb0c87cd4e7fb877d488435d4d69be4dce6b329ea7b4c0d9d5c4dcc0d228615fc04efd4b2faa5da27a931315018880213ea9395f220bb812515b0608c3041bd9a73179403bf1832faf9a77081d824876af2324b65e1b80ac7fec3012c5635f945807a352248871b4573cf11febcc1c68cf8dc094bae8422864282b7a3979a004b07d248fc2af933787d41294092a760100bff65c727fbfd2a4896867a4614e11498accd37096fbab4b01d485aa2eace25b6e8be51eed1443bf88f71485e70993c32359185a882ad5519c6e10270d9334cb4d8bcdc9ee88acec0a4095872e9aa267787b0d138ef215f1b612f076e6692ebbe40bede4b8eb95723533045ab941c0a3bcc5f2f6c0cf2d6220c54b5d05b2fba7b3c3e19abe3a384dc974d7775bd28ccc39690aba009f5568718f7e89f49c75c7623a463ba346496be5cb01fbbdf46f9138993225a665bd1d5bca0cf654cd4fc5dd362a33ed8bf548c1251e44331e2216899453b80b13dbb43da82fc3eb532b8394a54e1fc825bc5d8acab6d034b526c183635fbf2c529f097068dc29845a07ae7197e1b28a42353740b5acc62c013382533f0064381cc8ec1af363bc9b4a5b51fe27ba16f643bc1deb9344c4c6e2429c8b1b1d717dda4a95934c20aa5f2cf2fd67172a7adbd4765ca7eda4f45d8687888a9f6a501d960a67d5af5846b0ffc76943359ba61c379c9fcf63bef2bfc5539674741ff6fe7c0fc06338043612be89beffea40c725d92baf51996aef82a58e6f0cf5694f9137df0029e1dfdf28626c4d13e3d61361cef6ef78ee3668d639a29a9720f9ba92844d429a6135c9ce6872e24089b321799092e178b174206250ebff8036672c6e81738a81638918f1ca6beba8357e64b0d38c69ea81fdecd50a7bf6047966ab1c43d7b305029fa5f47e2f9a7eced74d3595e852b3dab2b00d81ddf953d7bfdef6bd566fe6aa85749f1c5fdabaf279eb8f2757f6c1aaebe3793d7f3f4813301da6b160c50da27aa6753a7d335818451bf97e93b4cd4943912e2ff03d89f011bf0bc3b99ffdae1c0f06a8f03561635a89dd8ed1bef3df9726695bec2634b307641f5e0016e38690fa95013f347c819633a5d7e36af46169664a4af865d16447e992e9e8b9d6c0b675702a0f169e8aae222be79d9dca0e7460a7794881f20c8d8c8aeacebc6d2d798e3889b8640b57d0c44dcf04e03ca3a73e7f52e97ddf224ae20a48ed6c00592dbe48ed4dc6c58c0292b4b08386564d2e379183329c641a204b8792c410bd2f2791afa393f79279933cc7e25773b669f1297ec7b3229ea9b7c218d3879468b51922198d23ca6d805a7ae6cc8cee6cef8630a16c716265959275a87d156c35c8ccd186297de33ba53804741b6811ffa996e6b2ab867f0807eb08bc1d64d4382fd8695ead8a88402bfca6c92a0bff0d99167be757d198db759d34f23ecc8baf645b01b10c2582da2e1ea53326d6173462b77169ed6521e2dcc5d68d448cd489bdc6d343be444fa15694ed4575822d3ed227a51465cb57152807878ae799103ad79274b2092973e526b1264fd5e16c940541a2adc277d4168e89cc36b73413dcc81a3492775b1fd28f2acb6b3731b0bc52f7f0154d726bf6e003b013cebb3b81cc6817c7e00fc4e2159be26c63d089a73ed595b77117bd93609d463bf88872beebf8654286c4c68f62ab81b3a47cacfb869fbbea4cdf21b2c55bedcbda9890fc4aeb4d0f1da7f8b0abdc5b91265754ee8e3e234b7357e2e35dffa3423f44bbb5899e3f3cf03e4d3e86bc86403ee707efdc9a7b24aacf0b709461894e0c750397b073fb1fd149be45ae14e0285b29a10ce88785baa2f24bb6fb7c8bee176f308824e3b2d82f9f4ec540e1333f41b24b8fbf6fbec28357e7c62e79fa11319d998ac9f9d3c532bc54b4c6b968758e351d6156533fdabe935496e79daac90fc25812c043b3122b32c11bc818ca3e5f248a240b44bd217ec2b4c22b30b6f7ca9e5d2aa8f2b310f746d543323fc45d7beb76a024de4d86403ba46bb27f4abe249556c57927691bdc0d86babf6f498849609139f6828852e9bba387b2061b8f9c600dfff486cf01e3d2bb16d6500ce728a013f7b46b7d5d1b49772c1793c2d137419a75e5054ec52b036e4c90e343058075501db0a1c8b7366cc721fb30653c52c21f49d5bd9305541dce44e32dc6844a80ba5c1040333f552b4cb54eccf297bfea5c34e42eccd2ee263ae6ab2dfad1e44d3cf016098c92e303522745629a3a128c417bb0a1e0bc76d83f3d2d10978ea6728fd5891bc2f5d6dc4ff3672cd546ccc9386a1b3b85bac4d66391f308e0bb6174c818baec10e3207e7f3cd440d00c1fbbf70e17c9ed6d0597c1155197dc9092ff33ab9c8f8c28db8e6edaa10a3bbed25cda79bbeaafe96348677ccd678e2ee693936004a015dc3a6b5c55dc3b66e2318a87139bfe0ca235ace1b72bdbf65be58764dd803116ff6fa976846222b5de98c6718d229e890ad0ae52705eb9777bd419c123a55e13680cef264aa0e8537834aa10e5b8e693287de18626c4baca2483f52e1dff9f176020f08bb83a759d713a15cb4080f66f4eb1b1d101c2d6be7a32d08233ff18d2de820938cc815596fa0a220f7234090ef4bfadf100182802c3fccf44f650d4f6376d163c9412638eedc682c7732914b6ce85ceea0e0ae458336fc30e7975fbeb02418af71c3c5fadaba236aaab6ea3e163e24d0e8489fd63c6c02c64523e40786d08ce02748807864ceee99476d057edddcf114fd0e185e993a29d38c6d4b82b73c5178fd901b671aaeddad2a5e6fce0938b9f89ea26c6704f672cf52b4dde1a39aca0077d136926e22540b03aaec97486541b8b86f92561d53071f06c6d5e395cc78f53e51995c366f62197f23d40d76cad5ba118300ef8885d9868782c4a3af60357bde5dc38fdefc3b85fae833441c1063f638175c818d8b6ee3142906cb7ad6ad2eb12ad390546a47ac3885554ba32836f84de829a3c89889ee2c31b25917e4fdf2830a2a1bfcdac463945810c658d0dfc482f2e09c1079905c8025989d8aa254af2c20ff51c77c28ce2b3c59f7cc92ca37ca9b3c2e1b9530ebaa8278032afe0b66649ca96e8211db6683cf5a4ebe733a675ea17f05650a2ee09b84a2bc11bd4ab5235c1cedbd63337216f794958dc7a6b3a845b74d4842ee148f80efa3a28e6eeb8c699cfde2fdc229285cca97936d01ab8a97dc335ee70b3afaffb59c3fb3c170d868105741b87a7999f2cc4f27d05edff221241676df5752ee2777a2078df1557bd9b477879f6eba5702d8e438b7eb33c32b35a81bb1a4b54c07209a5a0fa066467ae18df26fe4b88c05ba492f66bce6c7d1028ea47c3c8bb501d647c4e4cd6325df982331599c353d9456bb120bdcda9488eed40b5d0bb1bd33b4696c00d45345820dc37e9ba9a0ac57b579904a63ac4cd8c2f85c9f568ee3adf1f7bc39c441a176ee1315b89e227470988e503ae9c31d22dcfe06b6517f7b675266a1bfc5dead0711fe2c410a534b6cb5ed64eae43a2008051f54e9bd88f688154a131efaa79a773923985f1a353e3c0fd596d134427c5e8f5ee855510bb21c94dc8a93a95bbe1f32f8cbb650443965e6c65e40fd1c1b84a2993dec92d7f13b0b2044276d7cb9098828608b23ec8de5a6ecffc180e97d878c7cad1d6c33afa2feced88a02d874daa0f1df63a8e1ffd0ba1456bf758580363bab6e68fe6b07b20a03167286827c387230b734cd8fe82e1a4cdec852acd55b8b1827fdb63f5ff79309aa57be786e1f3290a2d0e07e69ee705966718e5bee3fe7b864cceedf9e1a9325507d709c77fd0dfd9f23d84f2cf042b5ecffc36d7cdb131a08d414b78c6d4c44f4a93dd7b35149b4b62c8784dbfc40ccc897dfc738d13baeb0ba3bf2932c48303a24d789b528b17938e0fc50c5e95f32ff163111fbe57731913adb5df3784f441bf3d9fc347cc04410aaa58c956098e67c4dddf8b863ad4ea4c0d039842925190affcc354bbe98508c99f44580b92481ed490fc5acccffdcf7a068210e699496d8d3929a595c6a149c722ecd8ceef447941815a5aacf319d95b6928615cd01f0c5ce8209a4e3a332739c4511ec994558dbe97111655a217dc22a4f34269e3657bf3f20ba4c3af50886194e9ad02bbc4fdc956c73ae92efd26bd9a606af7d07cb22560f909b705cf18136a80f02005f90908b2d040efe9105f4d63586408169c5c7a86d0a7a807cec3a3bd533b2dd04869d397efc5a553c7972c2989164f820701183587079b829d6b2ede31af6e444282dc8049d5e888f659dcf457cf67f27b997892e07c95e0822d44a99d8e56e8daaa7ca5855683989fa45942412759b6e787e94eef71d74a8d470ca96b599117017135aa14d86348c6ca8574a7668b35c9aaf280596da3c4fd690446949f907ae43b9c21e869dfaceaae295ca0ea811af76a12b4ceceab8504480b2a6e9f8e8686d0197747cdc2937c40815c218205e5663ee5454af3c3bd5c022c7c8ed3c225b8aecc436a57f2131ce687b375ca55b2575120b95ff70d9b05306c4355cf9b589cb7e16403cec630670ea8af12259d13a149e6e8d0419c94f9b00b764b706f97672592f1f2e466a04f7edabef1828263c19945c9a4c7903ea44a02eb419d96996a002219ecf2d7ae962a070c9791c9a378cda0dd62346a9a10d2f7ab46b8bed40d6b85c614e0cfdecd4d10b372a3acd1d9f50e1667b72e95bfbe276ee1f51b24d1ac9a65a91ed61d20a66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
