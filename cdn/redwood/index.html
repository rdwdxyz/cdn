<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08df25f964620aca45996ff883355741d428fcc7a85376b713ed528180555fae5d8fa21cfb3b78bb964f4426d46be2281760527a4fe7622de0b85d3fdc486c662acdf81519e62ebd49ae0a4f45dd137d2299bfebbbc268dd5c76d89f787e2a15f063aafef986db9fa10a53af20131f3bb67c5cceb31e456ba9daf732228a337c29a21d80c683a14001591cff08b5b91cd0a0875d74c33f546dfb38b0eab0bd09cbf6ada3ef1ae7481576fba096cb3f7f443d33b81f06f84ae80ae88b4ed484653d50fa4e46527498491b1ce8f6417d832b7a16e543128e5481cd5b2ed3cb0e3d7b6ffead08c28f416389762e831d8044a96b7b95d17968c1f899bffa27457d092867bc04a7e4599a9c7f5f745d46ce1cbf0aa7d3aa9a121d8e79ddb8d8ba6992130384a1a2a95909434ebd9c35548a336f6278f1cf3fb3b309e12ddd72e9b60e25f55f482eae8b8cdadd2518ad99306b397eb8b3cfe104113c376527c56b2a70a3764f064735f9d5dfb691ca3754b17930695b645a5f41336fa1167208bb77e4c7a24a04f3bcd7f814afcf0f8d8edcbd6d3a5ddc90d4c8e868956bc91738ac0a57ef05b8dd4a052bece45cb3924413c0140abd9f024546f73f7098f99a2c649134a38f271d9aca89ca5da26212e86ec3df73da5cd07bf915babfe5ed8510834b9243b7304510a3f836ee223b937788925496829b275addbdad3fd1d306f19d7e14145f75cbe2392ed2365a41d1b121fc53dd3bcc8a3ea34123dbf90c5bdee4f108599d4c385f2e0ff5fa0c6071edafd2e98d236cde4d5fc2abe2299db8965e98c559f87e715a9b3cb417fc68a98decd62b062ee7edeadb654724f9f35a266c6f03019e9fd0765082da1a0367939775d85311fd10f056fc5d0930d2edb12da1dcf0d762006e4e44ab97ab37b0803674bfde6ae80ec9912a40f70674070ca06eb997c76823fc7f0c74cffee921d3263e82e102dcfa54a3d2059fe6ffd7566378119edb0841cf4ceff82df9ae73aa809ee6874de74e581539a920efa34e4ec8f65574aaec2f92a390c9244a2b947963dfdfadc892e8c99a96e6ed4e7dd50e785ad6ac7a4099ec6662470cffb0eaf376520a0e5876634e04f66bdff0d87e189ac7113a4bac069d8b0a29d0da52b4889becf0596abdc9eeeef99c5e24e247bda5ddf702fc0196663b59eaf4843e7c1cca4b46af6426f4f5f2f31f12420305f5a52338eec38663a1b79d6476f3b7afea9d117a9f9a4675d0af7739f31936143a29d75adf7bd0ea20e9a3d527f6acc40788c48fb7aa5e5926ef03416661b1e35b00f3074ebe07916f30be7117e1f760657e0544d1feb8b48b7722d50800c08481d1faa6d3b1d72b78c5c5a9c47d9bdadb68c5b9cdcced23362db632377e69f2d4903d47a300eb31c47bfe168d8339e75b3f708ae8a00b4508e51af7549f093ad430806efab4f4d29f7880183f660ed41e59a4940c15c596d2e4703c44e9fcaf131a1a34109efb56797deaa6ebfff48ab3177ace71ef82506464f5390fae1324dec7b42cca586e040f690408df36fe230bc6ec8062b7f7e26d183ffa654c763df0ef5eebad24332d36072e2649a8fbbacdf7d88fe08636584f1f36e614467a6c81684aa13f26bcaa37b681f8b149f145adbec7e64679ea7c0ec74fefbe029e0956bf4f465bb9a94f0ae966c84962f64df646392f2218bc455a8011c8af313fec05116769c99a31407eb1fd75c945679634556fe6d397f92eddfb8ed32640ba58cf621ef94e6ae7a0b16c7e47f441c68bc3eb4c144d9720d8688d50f549901b7ee13a3f3eae69e2e7d4f3ce778368b6d0b78fa808ea1d62553015d71b06f7f449a002e707e4f580061cf6851cddc2eab826f1318b3a117abc0dcfac6df986c723a14c000558029e77ef26fa267386dcc16080d8c3ad4a8cad61eb57e013d25245e82e59dcf61d55db0178dac2b3a44a38e93590e140fba630efa6d8329d754b8a6d6a8e8842afac6049f2c28b17ca2e77d722bb97d9a9be0ba3f157ee12007e3821ef7bd42019b0d7e1d70d6bfeb80b671f4da26984d8b7803b8e4824678218acba0a2dc6a0a68c6393c29d0d147b0a7a168aae841591b83526f335ef57946205049b5fdc8d2b02238975f584c4c34be1d88cc2954687bea57310ba476b972ec64dd19cd680ea1c2af01506c9bee7ec44ed9e843e3af60569d16deacd8547975c2e26cf0c9d9b1035f5c568556fb1e7e81d72c622363bc5d771f1735f1a22ec4e43604805aa09465e23988e042ad483dee7b42ae3473235a1bcb862a7e191d8ad38db28c13de64a93b222dfa831c93b1c8e76580cb88b7dcd40bd09c518cc9c1eb8bf6fc0b8c88850931098d86209bcb4f153f4d22b374aad11628003c035b8dc8ec5cf7ccddf1aa8f2ac924f44b06d6955ffdf859df2975808f1eb4fa1f5ea861d497d7f2696dc4e6ef9fbe5e3944e6dca19075ebbab3e6b8d7c494b74eeae00e610c3514b0cf3b9b287e7391f97916ba9ca708697d827f5fd2f701f0ff6b59672d17cab71561011afcefbb469f3b707fac036c46318d096a3493efd4592712f6cab0e2f1f72258d7a838888b0f049bbceaf1eaaa4b6b293351f2a0549a11791c0e1fdbfe810ce8a98e0b2ea5cfe7bb3bf2e6c4aca547e02b18d846f89797e5ba359296a526c6176f37b5e7237497408a466f57ab8997f0c7c2a8578e295ef4e224daefba285b9bca8207aa5db3a66099629133686d43535c992b18e6467cd09ca48423cca4904cc9f0d0895001c82914a1a8a8ff692eb01b27a2dd71edf730706a4afa562bdf4013ebd3d61b8eb279b08b999af4c5142f70b0a4aae974e06856860df7fe51a57070f2c08ab911310312b7bb9dbcfe0a35dcff3eecaa48769e175e6aea6c76ee9ae4d83cab5d91f6b99384d6ea488efc3b34bb1b117d8939f0a4d8ce65f961c727b66842fcff9d94e5b480177bcdf1c9d0038695c4e303b24459faf9d18191ab1cbf0f866f543cf561dd28552a426afead289268519727206483276cb47cf76718cb5a90eef124916e93404e26002677ac5cb7925e7d2d653888b81faf89f426f43ff2edec6a8a24abb4618b2c1a4a1aee239c0ca1698a084758406d1e1f75efabb2a7e64f8669c75d7476b7d43cfe1b591e4f8ff3d9873f795af555d637cb422756bde5e1f25360e3f6fe64514851fdcdd7462f7cc8bedd84854f5d8737f64cabb6a83d82428a9e573d2f64d1dc8bbfd38728bb177b6702a7c5ab5d8aedc80636bf616f3db83f7260a3330656f4e5c4c708e6b0ffe5fb22a4dfb4af65e4b29489ce7a690e82dc6b1222d23e422c41a0a9ff8cc3be512f476dfd036981759069266c7841ae134f0d452a291010ad51cfb13dc184991f58686306b8d3d225d8d6d7bce794b683c0f6efe77805465b8a8fd2fdae87d8335a46e44a5dcd6e4542e98ad3371895f3a1f643c446915e9a32ad9db9ea01609526e418e2419304cf73bb81a2037ef00a369388a529e4550c5fdbc5541383cfc6017c4f692bf00e5e276da2d944c960c60496f9f92876e9537e679ffcf3738d9205bf3e208142b0a1b5fc4683baa986ca9af5347e1f5d666e6c455c308f9d079c9e6c318b7b0661e6284a425f6eddf2e71ae810b361adc20c840eb373dbde1ba77890d9f5ea2ae3ef93aa486d5892a4786cdd38322f5cfa7ab3a18ea722029bb62f565e069eb624e88ac363f32ca4345da76ee3d83b2e88e86f702d0d387e3e060b9a28f072a2c0739bc60967d73214605a11021cf0e42936f6f6a2c8be4ffdbd64b45bd0a82beaf61334519251d94f93e359f3513fa5fc3cdcf307d522e773ee9b63a8ba0b519d7ab0dce3e3ed412a08a74216ab5dbd1f11a1e322f5040bbe82efcfcbab0f7a94967759336a2a5c369e4bb8c3c07d44707647bd8f93afc29e28d7107df54e6d58ef15ddc28c301027dbc8f7bfe2f9aff04ee14815e49907abe17c43041fba92a06276250f71f0f130852375b09b12f7ecad8a8f62b0f25eb13a0bb64ba6667022a1b24adf5448a4cfa62fbfefd805900836fa7832a1291bb629b84253efb995c801f678ec18eac3cfbe8b5f6be194fc4a0cc0b11bae0d77cc1a4aab704b085e072d9a5c9dc53840636f590f9fb7487e2b5704013ecb5dd63da2a0d19412e6d470f714204d81f38e53856a27056840c84646d1269b9135ff02c5fc8fddbf9a0d78107fb6d563e2b44da72088df6b3d6d9077c0b2d201780f1e3dd8c8374a77e48709db45a9061d2eb58a2e6c6e6a965d9db90259b1dae93191e3494f182b50f6b2174b6239c695f22adaa22a8041f11ae33cc6809d239abc2f1ffacd14715f157367fd07b5cd4cb8076bdf56042e80472e41d3f9ba4ae3d93333bd3ba65673d89714fdcb8efb16ec13b6ca98e962e243f135ff21dfad495565df02eadafc942bf7a6e2116e3dd0320db4458b9956b2fbceff4b5d094df543947dc1cfe13a5e2be9123780aa4c80a69997db4fc90b527b2ef7cc7e26740085ec235b09ab73ca546ed1d55e9470059766d52a66eed71c10e70ca654033496e46f70b07509072493cac66f3fd18f60203cafdf63120f8ed797d53fc29d867bf3bab88a197f8dfbed7907458ddc840c4dc7aa02038cef739cade7007fdeaf2448a99d099fd0dce77cf75659e8306541ee206cd7d572a0ffe63e5e42402dd4268c74792178b13b2fa40920d46f7ac2518704fddaf34762b42a2f86b3405f26db1a11cd1bfcaf56171ec427271e81b0513a2687c1dc5254aaff6403864c93263bbb46ddc054fac3e8940d523ba46bde99da1a9bf7c1c350759ad1c4f4404589ce126eece5eb34a4ba7f93b6a627258035c4f14c7e6ed2229032fa195a342d7a9ab530b5250b4699543afe35890b2fb3a9e47c64d936da4f87f202c9046c58ef1c1a6d292ac924b2af49fd06bd30024d0c4864fe3910862432b7d73337896c1790b9670d9b89a82ce9486ddf4532abf6a71b7022f99057a5887cd8fab25bd68ee14760fee8c34367a9790b62ba0bccacc678298ee628e1d481dd524d03a7e18b60b4bf0070520a2fa84c7a13a80cd4d353958460defe943672fed1893627730361ed49b1731855a839348403abd25b0bcdf9d3b6e3ee7e6d4043d457016769adb64a2354ce382f6976995379e265646d14fedaa0b42b35918e3073d65442e353f5cb35133e2052c46262f3fbc14481d0def58397917fbce00e80f4138a00d303a6c8e09cbe273dbf161194b31d52b4d10c21ba3be6b1733dd5dddb48889e7f984427e8c015f604041aa2565144f80b9e6a58d5ed6313cfb91f1f82b12960a590b2e1b530fe32d7c570296e3b4d505847d6edee92fc4c54ad3193ccbfe9c610437f23dc17c5f46954cd167686a685864ff0a24d6eaf28591fc1f7887520c249e70bb0f4cc30cb3d90b3dec9caf359d1b659a37ab4f05ea6ea79f46fbf5e7500d73f12a0ebc274896e161b87bcf48d08d9fccaffd424c5559fd2bc3b2a85d85790362291dfc43d90b6e5e15bc414c8a435e8d42c320c54a1b39ae33554cbf6b234e19ec23290d29b71dbf4fbda6c55a448eae00992dd3ea956310a58833664856df704e135af616c6fb9fb9ee7ea8e70ec3a6cf8aa260b629d8677bc4adb5fb72acbafc9f66ba6ac9a45d43d51b2e89e9ed68c2fbbfe2708c5ffc0fd3b482cf3bfd55c44288720d27058ca2eb03a1e24a8798a9bbabeae1e6f60ecf90a25d29568df8f17370adff69cff02e68984d5b82b759d192e05cbfaae97214b0bf3e91164cc82a0dbfd6917d4841eaf2ba7b4b4b0ae8008c950974dae0fb5a61b17660d2684d86c08bbac84c89fe1ca168823f4584b417c726ba3fd0dcfeb3417e7b0419403b842616a5c8c9b6e873199e75e653e4b1b08ce7168f3055405c6582766d78735b3e46c4d3cd888685e140885219bade52ef80f59f94cc1c00fe7c834e40d4d0173fcd2e19666409d81408f461b51a8a817adcd4a9e06559a95fc1e582a04ce406ebb4c01fd2cbad4ec1e90b369aa0f395a2e978b68656851d31aa34d040deb564954e1e2c42442c0e6b7dc0d2f5c284bcbdde76df8495e5e7833425a63a865d45f51251ab0c37202a9184ef56c4623bd726d03a3808312498a549c90306137cf5edd42f8b710973d34a18eb7559408cabc63b873b07b7560e6714e2b61c7ed64145ed38371f09a05f73afcfe283ca707a826193fee56fab187ad9e690a78b96fbc8a47d9673220eee947d04ecaaa72b9108255d7ac251f63decf53970a28ffec8099c298821a9ed0a09a59857ddef4b722233607502dfd123a40116dcede338b1af569d102899940662f1ef8315da6685bc169f69db3a926b4bb7a50002962c21d5417471e02debcf95e4f1f08d0bb60e006d7e6f59bcbe1e018fdcac1c4e93a92bac0d299f0888c0a1b76ee33c4a0c4139688f7864cd5a4cbb61c2440af25437960047cd86ab20983008d643b5d2578cc76f64605934379b0f71a08ed84d00120fb9e165296367a717efc99bbe66fb2ae3c7da159b4fd376d1b8067c3b7c394e86a8db62395de3579d418556d3e6f6c2a3fd6eb33a8107614676a83ff20902b3c934ca74e411d4982086042296a009418b9debcaf53601df8486d0de1c427355fd50d714fb39437f69d1c06018391dd627d19fa119114ea661b26449deaae9136efbf643968876e5025ca7df7103fe502ed82c9e4aafa0d889f3ce4edf5c3fd247d6e6fca855115f18bcd71e6316ab2ebe33e26fe1be57dab0752ab2cc3d065f898e6a09db13f09aaf800ad1bd484bb6fbd17a20d4d0382fe2a4c13d007f392be2ccb1011dff713308500e80df063a36bce1dd3c78ed7f71b12788dcd087d594580295e1df46bc3140c7ef5095e6cf65ecb602e9ef2e925d7f153fe1c0697ba8d6b93c40ed0ef55688ab09253ed8aac7140cd9a29da7fb06b502315fdbdce82e9643e120f668e28357c9bded46af01c546a7303af9e5aec292ca963cc51a6612c490372045d22711b31b2dd1219be028de2d4639e22382a6f6ffe696292bea6953ab6a943d2dfe95eb95fdffb94486af8629eddeef6df5660332272b5825058dc390f27853fd76d2ac2f77a8b3530f9fe8fa4e40f7a4f5cc2b103515238f619967acd37f50a71a917b9644801619af834eea680328ee0b7d751bbc593579cf38ade946ddc82cd8a62569ee7e7e7b2c4ac5d94a2759f4603c6d906bfae367e6f452d70d519eff9d68abeae1a4bd34780080a57eea1561dbce62f28edb7fcb8b7c33e2539d7f2537437018d180c3933f5da2237d5a51f25275f3e05a9c386256d2033992cf7bc6a92a12e4254472bea15529ebfc536450b7d9bfee3ffad34aa097cf34c07797607dbffc82700c4a759f4e9324832c356c2361a0dd6356be7840f1723149e37922bd09862c916006ae7bf6ab73e2d379c327db7e085cd93f949cc2aeb76dfccd33b0ae25fa0ce4d8ba0c36e77cde7c71f5244261343ee97e9ecd02b5066cc90af8b47163d7788b3a9a2fc66460217dcf7c8804a2506d9ed17097db8f6cbb8d9e40988fddfbd8b41a80fe074309b01978ff4be6a271d15db68123172e38608c30f88649ce58d6b517253f658df17862d73deb9d4f7e1b98a26d2b7d2367f9992006348bf9a5648095e7c49a2ff7c148d1c9f881d303c13af601092e2f56a46f20c61fd4b10ed8ccaff83e376c680d18c0bd16c3f5a49da4105daf0ca00f2c1e5814b711aef98cc7c5add5698f8f850396a5f6dfc9b08e99d92827a2fa0d92dd35b62f3cc4dc9fdc74bd8457c2211dd0f7ca988d5ef4fdff202492ac62b26ce0c72bef680c7bd88c2851e0de6fdcabd9071c2122e9d839a0dfb903e5b1e2c0fec27a4ea40c819c2972685ce1a52c66f70661c3354affba5863bcdda0bcc5c9f320ee24e1e208b5953c354329b2a04a9c02a781f56ce1e124cf6b0e0c40a72c9ec95331322ccecc53f3d32f618c834a2f7c513d55b29e2e3ad23be7cd4527ac0e6796336bc32b7c6886b48df25b091b21f8d011ec7b5f5369e61bf19824070a623f580972592483a3133506b8aa38f78680433bfa95f9499079f908152136fc32042dbb10ad77694b304fbdf5e327c58c300870cc903d7bca4bacad7d3b5dd028e7b73b8c9ba5171957f061cd3a4ab7363cac9e0c68fd4bc03fa9948e981b5daf9c5b760e98ed307cbb30b7e855e105f51d555299a78013e60c14178ab5ffa578148e6da48275d0a7264d9993a5c79b156b4aaa8811ebcfa23564a12246a5a8403859aee7c69d3d972b48302f3d164109c06cc2e8341d94e8bbd72f17a6c245b66c83f8c611b0a59b43efa9a5065451951986239c8d95196e01a6822eeaf7ce8c0cf733274fe6bec9dae5cd306612020f0679a42ff54b060543d462137f6de2b875d94392d8def66c29f3ab4f96dc3af5fcc7d49fc0966e4a3df4419d0cd906aad463399904477cc4fccf251700f0356a7a5aba596889bfb0bd7cd430c9cf27af732bc79bcfa3126dcde77865bfa1feb274c226265557e66cab83b3037d4b24d213cf5a0e0be299649d9968913e4cebc6bc29e33f33b797e759942bc5d4a1f747de6d55e232e511b7e423084744fe530be688144c076bd649b8f7daba5c11d5ed85a8fbde7c07c91e79f7c7ea1513282465572430ea66dcc2fa6473e1f9e7eeb64e05c83b64eb9a10de4d205075ff0eba19d04adc73248b0443be6f00dd2568c228170638f7a8aaf083cdff325e41fcd1d33ca69ca5fb98c6a659925adbf899d21c4c8e73d451f490033bc65bbe205b827dd71b6154cd3b4f5732e786dafb232bb847bd8c5c78515ebb6cf5d9d5960cef6ef67b79fda2561adcd56a9f84839501748b6a63027c4caf572ae824c81df80d9c327baab3fe279337921e6d83b760704c0d10710357f0cf8ea21b06a7c9969e7a8ddfbb29dd90c3c99791b3194e5fb2d3c51e6bb793b5329e4f46a6289dc9bdf7f0729d93cba6007ef4d036538937ad5c4308e1483a77cc2298b6731812b2704b01bc1e6b93e705d0305c73030c9865e84cd2164e2cb5acdac584a2a5550076e58e141e0f0d248dddb14aaf05c2fe912d9137712d5c4499a7d6c2cd48c696a6e868dbd9a80dcb6128b64556ce1a564edb6b1dac9732b3f38918f45933d86f96152fff96daafc1b4618ae2ae95f4d26bcc610d5ef038ed5ff2c7b4d77be313a00f8460746d9079c12998e7a662108fca9314791d909e7d25c6c5059609a3b793990ae0f9a3127609a2ba83f3505785394eff96ef4f6313fcec8dedf0b7fa3fe9a3f019bb849ecc7652651707cbcaa46f36a544aafcab6041944f65b9b8d21ffb7d683dced04648bdfc150409b1d114836069b905614579a0830aee8a2a34f2d32c9aee51c30730896f29ae7cae7f14fb9a51532ef868e38b81378253528df78d4e19048b8a6c4631425e2719223e843fa09fbc3b2f590c6774e6bba2194f0556652fb370faa0c30964d108bc1b72b770d9dc82093c7718c2b9c2bf4b2c3459e18881e8cb0f638de5501285ae7ba72fd318e2cba1ddab1c3de9481df03c3baec557ab97972ddff10378dfd0411c125e83fac71e36b59860d5e29ac6bb050adfa1a8ebfe2f4ea63cf62dfff89bf2c0d2cd371c652fe8c09b8726652aeafa1879b3ddbe59fc8f9ac75677daa2d3356e76b40ec374881278a2a25dddd63bcbac395b65de17756aba9443e3faf92ba1a392bf62e4e1f3899ae15c036a86d1a3b238f607186878332ee16647123a922b36d32cded961c1989e06b0940499a78386c47ddb667edd4d2bda938e21ab57c315e724e7370eafcd8ae8f9f9a16b62f87e859489a867e61779d9dcf9a39cade1eb0af74cb37aa04a02108b303397dad9fc585d95a787156e644adaec5131cd2325c277c580858811e3e06019879a3723d1a9f2a34cbec832ee52c1e45d3300bd3ce83b8b09c412b819ab2d17299b86df013262ae3995daf4f0e485bb07feb916a27fb6ceb72b1549b2ff6d7d303c24645984988b03a84f8fac4aef21af51c6c0f648d8dbf32a7fbbfae76d2f1fcac2169e0a937c15569946558a2f3fdea49060c54fb814fc6b6a2dc482cc0eab17391c39bb190dbc565e52eb5db55d24e6cd1bbc04f673d7006beafee0800b146a17dca7504ae241c8b84f470707c6785bafc118eb4090f695a97bf31d2c402bcf4f8ec624a754ca044e6a510311c61f8d1a0ab9d0cca2c1324b7353990ae8bfbf3934d510e9797c2fc831e07811e71b16c4e11e04c455a8fa71986c71bb54b2482c0ac69c7d3f75c105e65a7e27b7ad8415365358e572470c1be5f78b04f365b1fdb4d6c0f225d9fdb327ef3d1c35b96235263d5a3aa2a5f1265585e77273c4f21b47291db672c0c6d9129094ee58538eb444de65fbef26d2a9f5b131757329b69ab7358fdeb91dbed57b26c2a8785c83ff8bb08d316005bc408470ee26f141cb83f6a02475bffcdb433cd5378e39c04c5766da3799fdd0b928594841cfb639b78b05dd33a47bd79ce8c6fcdec307259858add956d47f4529f737e18f3da87d348af078e7ee7c52b3ec6e8960c5a952ea38c3b913fd8c46c38871836ec6413d1252110b642e995377059df926a44b44c8f58a280f41a1ff18f33fbd295f30417474f7f144188a5381f69ede0040d1411ba38e89b6cad0cd24ac2114bbe2f51be7e92bad0c3e65e0a39fb4a4a914089efec009526655eb1372f2722bdd8dc7f27424c0d390c4db9bed3144b8571afc867d3711777098b3af13c67c53943c58abe888f28865a2af67921b985584da8ac8a730fef83ab61a1f055010f643f87e85d2736504be15dad006a0c845d45502ce2c132155f1594f0f6031436dd1bfaf0811154c1e2e475a3e38c9336c127391e7e98ad3f42002fb432861c7fe8e853a5a4de1d426b5050fde987a95d504a6b86545c50018d0e8b0af071ff33a471b89dcfd8bfbc327bf03c2b5b34b9c066f2f8aad6cb101dc526a31c14c7c47988c9a23daea5be60716753df8d810ea6934f7f035cb40f3e289c7a3c793202e478422aa93f3a47a9c671ffea7a699e98a06e0fa19947226c6e96a9b4a7173fdee8ec4e3d01294f5f044da35e79cf8f080b23bbfd597ec7af8b9abcfd7d3295af4db0d4aafa0777836607ee5d5c3747c5b7f99e7a442f57821f39fe363f9d7074d94c631869df8f31b88cc53f5931a819bc7f5d82629ec534225cc60608bc6e649365c7e24aba70d1bd069259ecd8bd9f6b6e0b5de323f2fd69db3a5d61f35fc9e16306bf3aa4adf2b7b0f0e2d6e43c20907ad13aa506da0bedc425f4620165e33fd1f52065da2eb15eaba420c4e248eabf760c6a8c067fbe1ad7f4a5a77b88f202fea3b35b2b4bcd0888436449207569f8a94f635f659a26fdc00f764949a8623fec1008150c04719333cb65cbe72d9d359ad118556762e01c5ce8598087ea171075443d0837a378a0d61bf84fc1df691e74503f096ccd13cf747cad2e72b632b2e9a8abf90d58ddb7511f34af114b2815d2e94dce7969708ce914c4a0cbb611a91f91c98343fa30e57c2c35ff1328424783318ae72ccba55bbe0628ca23aebb93f5d624b244a13221ff5ebc096c3c36c2d4cdd50647fff6cfff8282387445f18fe87c9f30361323019e9cc5a568aabd6b8e486a6d706d80876b976fdfbc936f565f91f24935729b7a02163153581062e6a3bbf3a45a9d319d3877b44e486e811caed168838070ea1e02eb7451492af617e0df8091bc0a8fec2fb129778de3335bd2cfa35196f89a8e468f979865e22c186390f22b67dd4a5d3426f1d291e92fdd7d162d665ecec2cf706015ef8182894073aff4cf7534e291dd185a4ad34eaaf9901b05339d8989e49c755a33365f5e5a292ac783f591bbc11e97dc5a8293a038c277539de0e8ba44428bcb084ae7b4eddd32db3280d2d7af52241fd0f0f9c7295d658c11cd1445e1333bec617e884f84f2b67be21be8af7a0dc0324fb4b03f697348042c15718534471c362af37dca232ab2cf59139ff8ae4f8bd935c1df6590c97475d14e4a13795f62143262c128834f70cacb6ad51fdf8e49a1cba11b1586caa51cc074a10d654a4c32b82b225feeeea5052da7ab371d8864c780576eb94768be8fa032e4735f46ddc642bd2684538e175a9da4b6bf6599f804533dbc1ef24642db635728df04d174ea5faac0f8caed795d84edadc7e5ffbe1bc4a25932204df05bd6662d6c2ab4de32d79ae00013574faaac10edc80951e6eea16c7af861024b0b54c3ffc0aaf275e52cf7ddd075738cea160ad4ce5481cd009aaa0a02e39689a09146a4593c8e7d7e0cb82cbadaab2ec7c8a35c836004ad579c74cf70540fb832414d5753b15c9bca6e3105ee46d223d6fc27cc142a7f58a813a7c1e4a2838f282e3adab4a2a6db8b743ddc81b2bbadf884497a032367482d75a3946899e25449f000a581346e086ed16a94ce0062af07f22623896a30dd1fe2e75f137cf282e9e6fa4fb56c0df11a43388d823fd9392caa7e8a3cf3ce3962135e092d9c3896d8e0326e9f7112f6363f9b17d3f79111938c86dcc6d7182dfd972518986b7152fc57c5cfac0fe4004faa39e4fed82371f218ab02e0d04ee176134e9f8c11c7565beba6fd890f6f1e94da32a724c1630261b3bb6aee1da85e69677266ca3308872d3ac54729341ea1017a1664cb28be9a511701f7cc26692bec0e73ccd6457afcc7c4fc8b7e2dc2497a468d99e7291acf32e82ba499b78e5d33acb77650dcf082d7b5c65faf4cadb61190fa3ea6d7508199e6ddf65593ea5eee8a38689e6816f0d4f314da520034b12bb24760271ab1164f9dcf63ff538066fb0b1a039a951422c9b9f9a202826e02386aa0e8aefa75aa45e74247feb2a52eb594bd00301ea2c7428a4ecfec6ddda6b1be8ba0d15192eea88e8b8d26d926c0a1786a6e1edf7be976bee69531625ca4f2d034eea877db639304a8e3c78ee50c62750133740329eae895ea2971714c5f20f577e47a8f63a74cb4df2dcc2e54b6d4c56eb89ecacfb09efde666f66b9cc9b0b7beda012045c25b496f9d8b91d0cab6862361b19d0fab0983fbff50c87ac09483eeda157f24291c592a75f6d9df0d9404d0a36577af64d47eda5c39c2988c71b1d7151c5869989562e3c47deacc70b73e0cccc719b859101f6c68b87f3034b54615b884bd2bb3b10a92c753e9e68040805b0600fbdad55a8869f08c90d2d69df7b2445aa2962cb06d888cc026efac68ba7afa51d493b8350c52c9fb2acd325c37606da93033000403a32341994ae0fab43cbbf3a1ee936bd3b7213dace54afa86daf6f754f8b346f7e55d8d4613477ad493c1189645e3411dec779cedb1e33a190f4207bad5e4ccdeae948bfabe46b1730aa8b5b70fa36c88ff5eea30b067b2829e80f1914194c47029cdca7a973d6e13feeae74b0010d21cedd308b7225fda9512e1bae1f954df06b4e8aee98c514c2bb982371bb53342a020b0b37351ae305c8852682b237dd8063cf4549f8e20a13c21226512a361d24375f93afd4933bf0ebd96a78236215e4d4055d16341bb0c8448d7a7df8f212a0460fa9c933f613757850c600f64f3751d0a90c1ce783f5e16d683f8c6466fa867fb1a0124fae11fe60c4bbb3743fcbe84003fbe9fd3f40179760d19fef0c1dcedf0dcc98dd450f94fa271198fcc94d6f6fe41e94cbfd583a4ea37785b623058e54a8e2476d4556e057d05651248cfdb6992678efd510427cddb97af282bddd670488e7d2314f2b7f3cb535a5575f8d30a58741b215a6f9aaf8ce9ef8fca2231ccff193028a7efd5eb3623d2be5b6e992acbdd109acc4cd39239f17de865a29038ce1e92f97e71c08f1e3853f64222494be7aca4d68694c84536961e71b5ef70a7d7a5a6e420e045a07baff2d88ac6b424535a266350a95c632fa1b856cddb82d51e36a6ebe3bb1c383f3663822aad86f06f07db34478783c55c96efeea7b231b6f40ad9aed47d53894414b886f3a91aa7131953e8990e935ddb454ae63e47badde56671bc10037a01eb1e1d143842201262b2742ce845f15fc9d2f6cc6a50e136f99022767c51ba7c8d8be03662291cf2142e15084d1da413aa8252fda49ebeb7383b39e38fc24fc8d479824b8e1344ce2de078bd154fa65f823441144956768b82176a7300c208b63ce823a575ccb8726c12b0f80078046b876df14f6e5ba3b22a5feaf30ba576fab10dc38a26113cdaa242395edf8cc39b77707ce047f47f25a59e27e86771258ce9a7eb3deb0a7fa8e2ad0702115dbeaa60be3e53bbda2f3e6401a3a8cc2b502a844fb080f6afd6451642a1cb2e8b612625a69f2ea8bce58c7dacd36c2cdf2fe573394cd1abfab1060fe151491072a20c048fb78e11d3fc5636e2c2cc8c169c127cf2bccdc53e527989efb9a8ccbe2fa0843b693da15d52ef434350e68082896d0ba8b8192d271bad3a4cac07d67f8dc744659704acce8260c1920cf80aafffa8f67b6c187e165e00e11ed7a4da8ff5e16404ca775110bcf2f0fd8b280322dc5e4a53d07537e76cc7d84ea53570dc771369f63fada1b5655a318cdeb35961d0659f47ec5135dcd30098f08ba144f37c32b47f7ac1fe3f564767cc086a2a47e79c13447aab59c2654d88dad2af8d3b597e9ec13b3326bf6564a0ba20538a341c56638163c84f5e4eee2caaf83a35037c79158db4d9ab82940a5df84b32f19938fbf047115e7e1818abbc86482acb911db7387d4a4f6038b62e08ab5a3a0840760939d4c1b7aa0393f37bb8d53e6a327af07ba24bd22f81e2d1edc3fee6e1e91c6b6ec1240bcce5e395311c43b159d0486193df200384b47a2ef50d9da738c1a51018871192a262ae33c2e3e479493b97d6bf1b357d1ff27ecf6600b97290ceca6c753813e1b5b6521cfe397aef9311340d0a36237e977e68c76e0d297ff6a1d3de015a3b99c3af02e30041695fa2c36e13bf519cff18cca3a42e84b2472aefbc93205899b670b2a83ee119ab485e6a48e0749f7ba15843841f340a520c8fadcba7fa97b012b95d6a851e078945a6f639cd5f24d6a3a37be38323ed012d0301a31450b4359406fe382ac0b5247f389beac62f972cb40b4ba341501edc542dd07ffa20f9f37e5fbad953d607622fcb20d4ed19f82c9be4c73f812ffd9831318e9164f4050983e24b026e31971db0654b481f7b68249341969a3669b1a9d1e74f913b23bdb10f7eec0ffa9740bc9afc159d64ec2accd652c897c280e74535e64cc2fb2999e52622937c76a385d4d0d067780c653df0950c429efed2eb185a550e7d47a1abc66b4539b0037538ab4aaca0921abc62da163a36ef1fcd6f4d53f5de4200e3ed420753e6dff9e36a24d0659808726ea52e0ac9eb8661e2aedf33740275eb85ae16831cfce929d5ac1180592939d6971c774112882ff98da54c2001db8543f9621377e16bd3f7438f4ebdfe7d0f8707490504a61c24816129f9b8f0a7ae93f78ed982f6c258b5012230f8bb289bc8a72270e9369fb62b69a87f0c9640d2a7a5eee350051d1c03248a1e0ae96b21b94430d7f435a38a6f2f33d24e15981cd883a3ea39e01037d8985376e23885ef2fff743238436291aa9ac492086dc0099030c0ccb7dbd292f938a72be00c98fa26db7540b4284e41421dc7ec4d7000b6dc192fe9c797c6f2795bd9c68524ec2075fe09b6f6353a07dc4d62b6706a70547b607492f8b46200a4c50c85d9f5992a9c99ab65019afcfaec8776dad10335b927368e0302b7d291d68313e82f1fe492cd53b8b5055542658c8b09e4bc6e3d36c3a0d8da4a003a1525cc7a304402d3e35d2194b8f83ec0a4ee60703c6daca11f3f340cc0ca39f21f23d1a3d4cc706f3610ac8c0d629a408f7ff45527b8ed12e1a2b310098be3433936089e385b36c0dd645f59606bd81ffd53875d8fdd99e37e8be13f97bb4d9d68fb176037f23f8004a047e94a02f3258ead9cbbcbb7ef017a9b717809cde3ffed42f7e869e7f13220c58c20d3c69013e93b3d4f1ec7778989ec0cf36061de9cb4ca01211b510862a38eefa51cdcc6f133c1efae29f29bfbe7de376be729756a584fd7b71d34bd3d054f8ac6ec499153cc313817cf946a153157d7bab568d3c918466ba05eb3faa7c50ee575359935b67e81962f83f8d7b7d4e139fd55b686de7fa855ed5c4b59555cb4deb2b5281685a0fbde4380a67855639bb8736bdaa10c314c1594f38a2dfeb9db274eb514ae0963f1fa402985025496e0b8563cab9169cc2b24f87d3efcc6ccce2e99d527815e76f9a43193cb0aa525d8879afb170b2b2cd957d8fbda9a2f799e2bebc9bdfa7bf39bad54b6a234ee003304a2775836bbcaf67dc5865a9f310f1a17261dfff690ac563eff5bcf6c3c2cefb031b50827dcb3f5bd578a358ffe26852209cf8c557bb8752f2ba26d61c501a808b9a1eef7b5d23dc4ad236e81e10a0184fbafbc54bc860f34ed9073dea39e99033bc05f247f04b04f398fbebeae8497f8d8d7fc2fa461e16f9858aaab6c5b56ca70d35c0ef8fdcafd1b32bcd2f64f685ca2bd2f82fe8ffd9e85d69af889592cccb49f694b80005a271dd8ca7a0a2e37bce7dc9f75503bfb844911944f38df133d8f18a31101926b04b834385fdb53701d1aafe61ac3ca884bc08dbd71d12d1b35ef3f884022be09413dc27c730e30b8d49bdef3ab081b1d752d52fe9df05bc094eeabd74a2b75b807eed65d611f7554e3c43e37fc41bd8bd1431847fd599f935a32dbfd232c1b1f52464a5302b1ac11472ae5679f30009108673823dde9406482743c39f3ea4805fc1ebb852f56f16f94ce30a69f976b7330c3d05573cb7b21419a440ceaa7df6c92a3765ff1ff890f8519d090c6144b2ea75a44c28dbb0a985c6986d2a4cced3a2c7c75e93f5ee0bd71c6768acaa37c1bffbe82f3cecec81dde5743dcb4072ae5dffda7e3356d8b6945ccb4cd44ed1f487bb0048dfd1408f1ce16864238db7bfc2cc04563ebff6f6b29ed771705ae5588d15613b6b47535279fae9095e63e3695b6923c14505292b7f9e233dab15743372b216a194e512fcba33659c3959d41c8ddf9cbcf6cb50e063c26a37aa2e3c4c58fb3156d15dbbfca1931572f027372f9b0ce4a7ff29b386dfdcb8fee4758c9c00e83cc5967f0afc068b0c938037b7012da9d59d0a8782a32290594db6bd76d51b43f0ee2544f9a15969d3528d622ec0d42873455db2da28f41eb9a9b9f142deddb9ec63a7ef16de09d0b9eeb95e3a7d5b763f5a40023df5510efc07cd317cca5d01a6feafd76941b4d749c27c4101933e17ebf77e157520af405458ae33c73da1ccfa00e745951c9839e7408f25757ebed3dad95f92608554de8ac1aff28728167795ae7814d765dd1592c75be5a1d1eff929c55f289868832212e3de7b345537bc14d1d0c11ed78177c1274489815ce16e3b6b5d142f29fe75a525c9a369872946e89fdaa00a7692b2ee353073501a7adac51b7c10efdfcdcfdf0c460f22aa0e3a5f3b8f2498685fbbf7dd3de0ef47183b4db5358ca4685863c81e988b2ae080add4e6798db21e8711b978c4a224fc7cd1127463bfea4d3c62c6647089e45dfad5dc2fc37d087874f3343ef612068a7dd9b783d7e53cd5a50f1391dba1bf1dec2e89b7b1d6a6f686bf2f4f4e35246a269ec22f02c60369b77ed8bb50b4c044279340d0f4a633ac554b4030831df40cbc1c4c0d2064b1379a1fb93fa843fa2ecda13420fb18a106c77ee1181e27be490aa70fc7ec4d24adfcfa9a26c2242de0c018f9d3bf0f1f8bbe42d606e8ac23c41e01fcb3c7f7a0987681c6890f48cc9dab1fe9b5c5b41d063d224dc18998b55efe63c29b437f043117f99a6351c507070ca7a11edb72eae7eb863c7241c758e74f8fdb93cdfb7446d6278bf89c174edce9eefd11612a043dc42af86013795cb504b83615379a6fbafd8de21e5989bd644d5a4f8960c5bd8f691ae604b6bb4c3da2326d509bd20ff78c1fd7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
