<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02ddec7ee45691a16184eaab24f26a8593252aa01b924b612228ecfd4abe21d7b7213f39ab2e15fae6513d633a8d84bfdb84d7c271b9688ae1826fb0ab074d8654d54778cba5804d6325efbb6c73cff3b6bfc45978700e674d338efc88c786e59052176831b9373e2c30a0f0759721b300bbb4407595d544f5c642ec837198c17e5b20f72f889c2fb9c251d23f1000d3ba8080c4e82e236787d0ad4eae557c691bdb325e4980c244686c66b893af0243c44ec879861ae614a441959a03a2af5523c294554e31a1bc92e759754ffaa5fd715219e2e4d05fa36b5a16b763eea194e175a7dffaee21028169c2c2602eefd4b9c313fd28c130ccebb1bd6e8e039e805e08013ba785747f732fb3c652f21278ab4228ef1950181e7685b899dd493a5673c2f8925c2e5ad5dfcc43968e7783a4a1dea655d70731288b92f9e7893a8412444a21b558ad44c0911c4fe4146c13e902ccebf94c27f1c36bc956ec55314d1b1bc61722ac8d851b50e269a6926d93f977392477b351ea3a0b8c4c2edaf39de2412d59f287d85c45bbff139f80aec6e1632e938d4fb0c0e81a94fe4f775c17608ab6c68a1a1f990a15053ddd79b6855c5f0148ebd1334e0a2987957418588418a4fb9d35b654606059ef35e172ff48543a606205169022e8627c809f483fa02954d14c9195e5abc55a9aad540a12c6031b67eb0625fe7a43c66800e2d4af88f95359f4a7fa4a08eb46cb757b0d2140b75777c343c216f9744d962536a29df7c47524d6f9d626905473598013ec048e5457d8d322c7c594d5c956c669cce0fc8cd7da460620150037ef87e0a5599ee279c5d732d47751de96ec3f7cccf665e5d085fa071d4323ca45db54cfc31e6a14f42f216edb6e3302980af29690a0859fd6dd5ef70f7dbc9282ab6279b7190318dcb9f9749e7cbafe36845d97904cc044cf8ef41cb25244a69146731681847e6e1e0714fd6e0de26a8442ce8828899297d76f604e26b8539bfe28432610d7c021b70fa6bad37045b7075de195d569c7c9e9f6af9f1e9594baf878def7a6c634f28ebf6423b035a4efbf7c8cbd9ba9677bbb9c682b3876ecac26a201ae5a70756bb1dd40a06b9aacfcc2050da9f1c489ef094642a5bebb24d5dc19ff96bed748bddbb5710896cf67945d2bd2914b91e6a43c938f34d2899879d480a565b6f7018492381d04f3f02ed9997a69ee585d3e861a6de3a4f165baf28b7688dabfa161a6ed285e25d4564e45e817e13e679d3b1c1153378f37ebb2a0d402086148568e5b8fba16a41e0a2318ea8ca95da8d245e228bc0b3e5dfc190bd9f7f934a21e18974b0fc4b42d726a5f6f3f9bbe644edcd1076f90501fcfb074419ccb35ccfa708df4d7678d6e737c012e4f36fb748bc64a4818b62ff58e24373564f42b8ab4c14ed767a78d97f18e4eb1160a419f59055a44a59a0340fbc585362e28ae4c1c608f9e3a19305cc3b7a86568007312bb13c82795a01ecc13a4d5fd894d732af8f942eaaaf4ce5bf0904902670676c37aed1d0446ca02ed432893b27ca70f94b8a9a8ea260ac7e502812cc2ee50b952aa69be9a4cf1cb0efb46f7bb39bf4484ea712b871c423f857c0a4e53c2b407a8847d90017b3fb66c4fea67be4bc32059cca202d076ab76ae4e5ab2945286f1a9f06b52fb9e9e5cb7a855b3568fc4ea42fc030bac8e8291f6b81cb40640801a4d6448a09cd5a14bc7e0b52da8f0e807ec25f517baaed56f67dc4cc8ee74e2747771f7d10998450dff1c5acde57a0e9d1ed01e817e0ad043eaab51c83f9effe4588895c9e9ceec7d04ec7200ecb8055aaf5ff24b1fb1aac65bbb526f038fb37c0a99172a75db043edac1b440c6b59372ace5781f621f9f793d389929c3e83a124b638a71fd164122a66ebf881bbd43d50aac00bf6c3b540d49b3d09686291435e4640e9d75ed24a6a96f24da4d0be94b85cf5e2197e337645cf5bb4a1c7b5d1610870b4ab8c9608b0d003aff5d6cc94cf17c1cf918100c8d264efb029040f4cd91e6f556ed42d746dfa1601b51000b43b2abf68749228f2e25a451cff4c30a8e4d493c43a5cbfcdfcda03563644345e3e08d5d15bb780ac7c62453ca89dfa8db8ca9c46cf7fa0a79aaa43b4f82325fb0dff79a9f90a7df5ab9d8ed49991a1d900f4f351b79def4a0bb93dad61c98cdd2a4c5843c7841abefeead021b296b4d1f360879a34574f37c10bb4985c1d54fce0b55b2f5a0bfbefc35fcc16323b9fa7e19c2cd68342bb2f465fabb10ab1d7c41d3ee14cd9a66bf0966a83da228de836eaa56097fc5d2d97d5958e6e702e723c990755703633b06c583a1025ecf170a93336718434a3ce954eec46a2a994a398fccc02d67a3b183abe4b1133fa124022333a543dd10dd7b445411d29f059251e99bd473b959374e843e9c891395f0a213f3fd54731189ff1551401b87cc7404de434929de17c6094f7d28328f8ae80e4621df896829a76218c3bac2476dd48f26f93f1ce36f79e0306ec6fde0c1a61ace6d6c5c7321ad33bd6a30acf1de2255416e2b6f788801f4f7596c968f2c9d4db698c6894900c869fdea0246f6c16232a4ee942dbc20c11ede6aed19add71883ed101626774b35f5e32881095b687331fee7b0deaee213facea040eed9ebdea7826ff0a39efd3487cc00faa5cc7bdf647e80a0fe0adff5a64768d0f513f4c5562631bcf11bb0057e58d5e8734694b226748e404fa351cf4211c28a501b4e6666515cd60fd4d2b77bedada5c61c71a5bc30d1c0bdae9a1fa5470ebae81fb5f8b7ebb7e537eb4c16717bb642568c25bee84ff59a0be2c27f6a0658ac6c7a9cfef53456b5d1afa16e6de5f5212be157b4e8dc19bb9e822ffcc17b83a7f6b5e5510518a33e1a0d426726c0f0ef865b2798d315f448cafa7007a229af67016eeefb7e5ec1db576b2194d0625b703d1184b63f8b0808074267cb73b4b5f95ca5c0b1189a41e3aea5dd28ee39b301f0eda262324a90a9c5cd36ca97d1a5de8c458dbf24c485379b95c1abf1a2402b420a40774848584041982c7c1bc8d13e1a1faed1138942ac38e731f5e32691e1bb7971b449db7347f74937c2715efba6d8ecec7b0b1db04033f9f7936cfb250ac26f8ac066fe04081ca52f8424ff4ade932c33484f4b5f42823448fcac30db174faa7f885f8bdba449781dbd70ca33c80f55ec38ea64ac956769f757b4b9b84a54a6e15e4451ec7406c1bd4b34402e60f158552dc7a21634602e6c8c653cbda70edd8298fd91ba0eb1d9497bd3eb0fdb55956ca7399e438f296d8eb3ab3cf3726e2e38b1eb1fd0d639a159e31aa986df454a3ee403a897a46a60d09136f3397a02bb022757eb4af1f99f8d1fb72ac418b3743c1858eeb2f2d4992c4fba3116fbeb0e6e44abbfa718099dae26901d124785af8c4fa260b248f3065cfa04788eab70f94ce96f3206bff49a34c245db5671abb5e06a18b8ee1b476f8807d03a8269df1ceb22314dc405d63d528ef1a4dbb260de6d5221c70e1c317b6fdab5780e7660a115e472b0dfd5fd35a17044dc77c90f77b5d27a1d493404644cfe7d1636360d4ab24ee96eb2005d40f098397555c2dbd5f0ec35186107ba0cbf3aac1311128de7661e469b8b3263050b700995c57defbbde7ee58b5a61fb5f15a668cd740298158b63f9a258d8af08483b2d983a958b03199656136e317530d623ad2664579ad66190da2388a57c742cf18c9e50d7876feaf7d239ab0fe57dc0094a4d72cdaed8433cef8c5e1f7e9b98759f4d5379db1a7ffe67c82215a0f83e891553005c0cb1cdf8e3bd3aadcf2a412c42da49a01c95dee89d9f8f7ba256449fa2f9b236a49c8f6592ddae4ad616edefec0bdb68d2aff3f297ead319b40492d3aed2f783616076d3a332e033adf7df681d02c351242b2874b76864a1da6270dc35abc8233a3cd011eb566ecddccc3976aa2359f5d4cf9606748d72e86ef9cbea6c2fa9a671cad5842de93a9ab9b59bf56a4e223bb6eae0a2b5a32180d4701f0b1e7682ea0b5ac781708045137e0e62ad205fcd02c1b7d8b3086c55010ed6a78b3cf20ccf5050ab082b0560addde8e0096b32a9863a588bb0ce53ef45b3bd04f284b9033d907e64d03dd469011d8a6befd1c7b42634e507fd783679e2b3f0e80437992a0f6cc74b7001672974ba47e44b609a13abe58ac6c6d8c81ad35a4cb898d3dbaeca66c140c5e76376af65ebd703016393d2c364b7e054642200de82bbcf3ce384a20fe5215df259f9300127ef41b8665226bce495e7361fb0916282391ef73f316cc5eabc0ca99700fa9ecb246590fa5114e05d4e83aff9f4101e4ea2e9a9b6ed43b8ada1b0526481c1f42e64e49a47eaeb66d256ea73c6475a57205032879a1b47ff51f48307a6e935b400598e3af8d1889ad99cbdf088bd31e0fc15b0ba6caf389bb9f1c8d7eef8c47d19dadfaf167c1d75c38b75433d42656092c59f5e7190ba7c60b6a7980b0a4413993bac68f2453beebedd653e3b87ee8f6f832a3f8e029d609eadb1ee0a2d7d870aa4086868a25ab2790397a86cbdbfa8b62a9125a4570dacdbc5221b8c656ad54cf7133aa47b876e95324233ed455e390f37ca0a2fdc450a434ce4f4b74db94c9a423d8904921207048247871e659d2604fa74106b2a338425256af356eb16f8f2ff08202e200982ae4e5970e2157378a71a6bcd9a82343f95d35fef924e2d4fa6e3a92703e8766cd89f8230ca377c70dff79a51a6b3340c405689dd0db9a4873647e91822d49a44687b6c9456279b3666d257b8a36aafe5c11df1f26fa23b7878160793f8a393e61b9c7ac3bcb90d53bb6299bc0645bca4318e411127040329e64226161a1c86b5a9dfb10d386c217afa5f9b55b6d0b6a272f2b829afbef4e08b0a1446e94a2f0f18db07e554301e4af8acabccf6fd30f58ebfcf6011d9a53f7ba0740949ff49f9df4183354003df3c953dca91f53ca8816106ad8af4a1d47fd3f8fb2a2ea0e8efe6e00ddc02ce8b6abb3284d655af5d7db969d34504023fd0bc336a02bcfa20c677756bc33d8e2699e025a4b08dfe1e6b4f9185394c0d4a249cce0bd9e18da7e2145221a8562ac18d34741753f4761d6997636299be31ac19303a7dbc54e3462e00d5f137aae95c5b5879019e015a6d4cd283b3e9d3f6c7539a189a3534e3a0412eb3725083b10101305c0e36bdd5daba9b5cec09e21f9a5e48c1f86e4da6e0bee13871a4893e28b5c5dd749ebf0554dcc87a728dc84af87a84b3b68c4860b8523ae408aec4047a5b8d8182a17b3e01cf21a8acbeb818215147c3d596b0b91a431b79c3a581d1b384bf30db9caa28935d43e7d2cc6235aab490f3520950d202ec4c8ee925a7856fbecd93e7275a5d647c615361cd9cfc6f8daaca9f28803398baf6760b5534a7254624de765e847806fed766e747398337024cfa6054ff47572adb31f663dc0bf01d212e554578bc47c575e0ffcbfba908f76185861a3251cd21b77d77decd0630e3328d614586ab1990f187b4b5a2217e6b5daf0f5f38835292913a0291417b9779eea335c4106206f4b992d11c590f0a1d91644ca931a652696a6eb40a97444792a2c7f9fd99b3d76f15215c8af9c9b1d7b5bb291c034afe43f69fb81fc095afea3eb0018c2d4cae407e10ff76429df9a7105e14ec2aaa1e52dc37da414e41071c2903d9b38324b0d1810f0e06a50f6ec9e7ccf56fe1c43022a94fd5447ee6ba63d3a89fbe3ed1f751e6bb834de728ddfa3a1da5e38e9fddb0ab7400a5f1c5b1f601cb95ff143e01708beb32d8d36af5b93aa71f5b2ed7127dd2d72bf03f8b5b0ee2f6d9098940d121aaac987ba260bb2411fedeb894b1d84be18fc0b51d51a068aef2893dc4229caf0c184166d4d1e54f70ba47f854b9c215fd6b2efd591995b3311518f15f37284830ab4282296d81bf7b5c212dc01455db17c050af147e48a8d118fc2f67ddd944ddac77c6419c7c6456aeee021c66b43886aff872474764fead6d17b969a21955e49acd638c75d884451265210707dc847be17700a4892d4015ad3fe16531a9017b7c08a16e583f6bd8a6d01139a5f766508fbbbc345e3bb30abf27cbb0c98045e7a1614a6ad30af1df85941340c2db33ea9ef6414e9ea7f39f1599bb63774f5daad5d9c14314a791c9ec2c67c53d589f778fbf6b11e59e70e1f1160fb27847d63787603eb471e45eb954239b03223a528604c63bf5165f04526bc2031bdd95b564b281d1ccf4e0c571c96564c0fc5c05f11b4f90f5506264a954af271d61121688ad1bf67e92a15191d43100c563742ea1d20d063b10eaba654d4d9452a569376671655028430e2004c894ef25e9bb3edb3e89e7b65e564f6042208466ed0e7589fe43e874e9e8c6f624e04e4f357cee0e6fecd51b4c22637dae9ebde25052b1cf00e9dcfc9b00a7894d0f5a5a8c8fd33a224dc3fee564e7bcb42671026f171c2af5bba9d9a4fb0c1d0278d9d0cca92dc0310a74353fc384ecdc505fc413f037af26418f47f1a8861f8a5443e61cf34b76a1824cc08898856a1b81f0f7d3ed1b1f9d502243f350a16236591ef698e7ddb44764c19319840045fa5d6db5ac53fa60f27d6e889fe016e5738854fd2a4dcfe18bcd504b19548de3d5a1c6f879273bf6c77b6cbf21d876e23a285bb765bfa525fee4173c5386416a132b6513d238a1e45a6d49136f3a0a997d33fa517d1cc9c0f54afa5e6110a2827e73f4e1796bc37906989593321e8825706758b36ab296194775da3db05b7563a752248de6b836d232b3eccb12a31ba3b64e8a879ea8d8677a963e6b660c3be675db756cab5d0e7d829beeda8caed62842bdf6724d13faed87b9db1b8676744967130fc590f5047cac9b7d5b3a1d788bf1b7d782ccef6c4044f558e183f8d55d844cef57bdc5a4a7c6fc004aef1a4cf77b1f2e4519b6596f7ec6ab62a118a4c5e7a42d951753121864b9f229e033ac0d28fc47a5cf511e133aee17f940d8e0e374a1a553fc619ead8fa6e02b6d1210b3f30e937b096321bc8ea5d16e4d42fec3e8f5dfa91f35a18752b1f3a263418a31f9570baa35d3f07b0e4a2987742a687f20d079ce39ae938b550c6727f70e10fae71409bbe5a24544436e1007f4c199c82ff2f91ac4908e26ca10b11491f2947c28ff0af9aa63b50536fccfafa8e07c87814a7b3902eef8571d7784bf517f965d2d0d91b86c5a927e99086c1ebd83daa8be3bd849246d545df3075a6e968d68cea5039aebc32d6f58c096726c0c4f6b592d2ae7446956377f7b26bd3c33377ac4655a5f0de8ef84d57b8ed3399b9b362612929e37931a87e7bb9cd7029b4a8f38327990008f0c41a71a369f9e75e11db1a30a4c48c6e22e8048c7eb219e2dbb83f14d3d9b5c4f29a7b77fa79a10be09a04ff7e48d49042d1770bddadea18347b582e09b13f179fb6d91a9bb3d7c63e74a713c74baf557c95d1b80ef227ef6761b970e70707f698803e90b516d861fe7d8ff0baf12d701ec687019615453b5c473584e993c4494e984a07b0bdebb7e9473b50a21b23488392d5f42b556b265eea0a9560c7622aa47d25d658411818f073a760677d44ea0f4310530b4162e854a6a5201feee3283ad2cfde0fbe2e25252cfa3d94f08facd2e597ffc077593e0bf29a0efed6f81e5e9ba5b6ced990ea753a706db3fe42286ba062826f1b41bab969ae3c264d64e84251e8a45842a19bddf5fc52f72129dce8f741fd59e1a8a591706b6c31011805c5395e4a425ab4a31632037be0ece54773ed32fb78b6a694f5e43ef219aed154bbe7686d25323c15b4cab6bdd08c6fa9cf21e74565dd0e5dd645b027e3a76ada667c4f44fc36ce3aabc3d49ec3a360bda7b831ad076b793c4c046021ba45da09a271e6a08a651d50ef34dbc78b82b71ebafadb477e1554806ed3382a997251d2f4a181a1a4704fda272340b1640d415f822b7d30ac669d79ce48521ba84794af2220f494c936c22d9e6d99719ff29fc036c435e8dc1b18da8c06de21663df624d5af6f0ec5cfb7e8be06a2763be0bd976ec8327dd388ef3288f8cff024d392f2954f1908f0e33d89256bcc4927b08c02d676d2fa5dc80cdf1826f6779ad61129eef3f9b727e2587278b9d450244eb1fc4120dc9f710b22722e27d546250d20de07fee87d1fd1af5b84f13bdb73c47202e53dbfae09f0dd351e9bf7bae945973926c87b3b6bc5158b3eb15f5df17e52baa11c1c351263c1c8ad1923d5a4d12a4d1d263723b91c04344b2a0b88bf3b582cb0f33a41c92b842e5983fa4062f1a0f70a143f50fbd0bfdd44ea5e372256074dc2c719ea2e040f49c7365101c6730bc6d017534de53934dfdb3a1a23be6fff74324ae47ee8dbd5146c348cdb4d5fb7bbd6f6e11ca228cfc2dd7f29a36aea7edc3408b29145d781a838c0080787c8b8f34ad5fb213986cc31d188ce1eb4fc896c09fa0f6f943880697e4b5cda1664ada56557f75d997760e1ced5e8cb65a47fb1b6a6ae29685f985dc4c7e5d6d8b5c5e41cb44ef6aae438fa016fc67babf18bc2b5fe8662eac2e8785010b9be73aaa6a15536fbd4d209a88bac8082d2d85a30a7f8687e290dc52987e58ef9300617f1811fd8ee56efe82ea531c149b6522fa99f000d5bc504d008abce1d1a66a55159896708965a55fd347dfd2a18b59431eb4ff146329c490d0aba9a83dda1e1a34d718e6f922f55010281d1b8f3cd42ad4d56c06755d5f279f0ab8ba958de8456b7875d9d47a08df86c91ff4b7e3db8c15bd395ada21d4fa63357fe58b75d76764b2c48771b94e870fda5ba141d27d4059d7ab6c124de5b19ad79221480319dd50989d548735e91f01be99b2044c2326b31c405f3893bcb01d8421e17994d32732d27dd4e13f2432da9bba18b96ee23a310803709ce6d14b95e1feafba85af3cc081488d05d019ea84613277690ba399ca415633f60dc3cd994644173099c40b119e9113eb2e455bd67de5ce83cce8dbec960ed466c6726d6852754c05c5ecca56379edea32da2c0bb179a201b4998b5ab80904fe77d05633560a01df994d91766949f0eaaeb40c8fcbc6eb37a67611da92bdd18d404c7940046d57f9a31939db690cdd5da48f8b202c340e2a5c0a59fa430728d12e234f6fc46735e97494b03ea7ff2daa308f32bda806888fae092d6ea60ec3055ba0c1ac9def48c76daf5b54ae2a5ec6ee90de712d105c9e08c22b3cc03867b57a9a37b90f6404596f1c2511cc27d2684c98f6a174094fdb19bdce2629a49f84ed81b3817397c5ac441ba364e58f7df4a5aebd81b2d3dbc22d03c7e3a4fdd055c53a70df19a2432042761a9db28d9cdd58b78977fc63d0c6e479527ab22716c08b95a47a7aa00e7f5c090bf6ce2adacddf2a941980ff8c3c25f8ed8911f95b0c304617f18826eb30c0aeb46bad177170c249bc2f1be85a504f9c541be5384592a676c84753894afed201503b53622f137a6393c2c8f1d314be08b391647a39a1578fd90365a6fab79b14e7f0ca7b77ae7e59d1c50059830138c94785eb4185b38a3f21397d97642b1e7423a660c152a11825e9fe02ab167e15cb76d17d09b2fe44b715844acd58cedadf86e2742e86a7748f5a75c383a3c29c87eef88960e891300c8ac7bb0f082df66080a8194a699f580a6b11ffadaf6ea069583e466abedb850e3e9d34f0ecbccd3c756c9da13d7ded62f4a5faaea96dbc15d4dc06a9e7280466250f00d31c8bbb31fe216202b1dffab4f0ef30097e75a26e6d8101c63c4caf98c17d3a9214e3add54891bfe8fb069627f7880ff5b318d9b5a763913501f4b85c59670fdf3e0dcbea3c4f2326c84eb580023a2c63d646bc3d755414028dc75624b07bf4a38c7e21adcec4c3de44a30297310da1f2d369039661085752bbc5bba92a500c485fa50a5a01dd28b563fa82d6eaa4ce548a9b5e77a2a2cdd630426c2314417713c8aa07676d98e47ae5643acdba35f49253380e65b2b77c3d37cd5109bf53d92b9fc8c35cafea1dd6679c3807a37ab1136c8480064060002ca1aeae6fc03096419f3ec8a59d890f8bdf0399b995b6c93be28537566cdc375525de45dbf6a92b7943adb2fd484c38e7a33e584d3d864319d74316c2df122d4904876737bbbca9a1dd8077f038bba779f8d34985da7f709fc0067078896ac084cd733cbae4a6a0284de68c4a848f106b604d83c15a4ed9391aa49715bb5b552a5f4c9027766793e331328c113a188cd8dc5a1fb94977e821acbdfb9abfebd0dda7e0b5f68be79b7d464e25e019b45614166454d231e0be3b6fd345ec08d95aabd92c5f498cb29b4abf22bc350b83845e873ff180345ee42bf3b5af029c62475656a3c2d141e411504e45f91c8ff1740c100b0d8fcab4a0abbaaadaa8b49aa6cbbe37a3e81ff65fce7b1ce295b19b31a47bf21eae9c2e40498ed7801312d39ca5dfb757d934984bf9ad3dc34e3413d737b7c1435305dc98dec69a856006e1bedb77bd96611680fe266636b8f77ca4e9762f9624da99b56d334259ae577eb703619015b2afa96d8de876119d9301fd7a571d42d65f68e51b1a5004887cbbbe38686af5ae864c38b500ba9989b3520cdf3bf08c37d5fd6828913f4b5d9f2734e1074a71701346645dfae769ab09010cf7dbe7a643604526eb91231e1e7fcd93cf47321552728ed9a78e6af41fc3b84366e0a34fadbeba3a3ecbce378d135e1595110f02cf246f57aba644fbb4b65eaf0aac9d688ca50e3649f9cf49c8e80eb26360442ce44b77195ed58d1d5889488490b53b62884b4bcfc9cf321128972e99a7ae10a201b13d185384c0c7f07d9d42dcc004e0e3e61936b55a0068aad3eee37c0dc43c4b153e3df4e44826d39ad16d7a0db68c8fcc6182ec29436fc05b710b9de10a4da46fe43c2258039794725c5e27acd9d292dc02c86207bfd20fdd918351f6c4d48dc6607e68dfd3c34a434e521a5a4209e0bc4e1d068dbc89f7aadfca1c620f266dbc2887c5cdb85b63acdcacb08ddf80c7d7f1d76069500414647c9f846578904f90131142abdfb5f5ba8c54c911845859f22bb9b50aaad8f8a9ad1c1f2b2b78364cdc21d91c07214e615d5325b19796cb47e13985bf3f41b3528fdf057ce18969f55e8c0ec0411f9e1ce63f87a96b8918bbf37f90574d0ec570d332c4adfe83e6d551d75be97d62382533601634b0304749a5b2352b6a63a67fd3c1758ee5c9f451928e6ce779a55ac2940efeb40e5e45ef6def9538931255de627a35f2f1b9ad13c700fcff0869c0453a549383938030baed2222c0c7cdb9407993ff35f80542e04bb24aa1c5d3ab98dc32c3f4eccebe1d7dc1c430d1f924e833523e41fba83d8fe8647b4371a0843742c0036996e94a8596447f5c7e466069ebd83ce13ada6bfd9bca68e4f4f8f21f461b45c512f7e29357d9bfec653b43d4dd385a6828d787e85694310ddab40570249a5ad0301f71dd498e637901d65cfffad72dd050498bbf4ca161779430dda05821b432a9b723c857ced7ac20ad44b58230f65bb45b373eb001cb5580d9a87aafa39de61938537d2a5001ae42fbc6e977449074ab59b31cfd53a72d2eaf156574dc3fe354d572166b20140fdf8922e17591a861c85d84131e1d211ff0c361b01c9a0231e8189178b326280f5868282d4a92fb1eb15c4efffd1fa9b9fd894fd8547afced4df2d371c3583dde7e35ed2bcb2faa14742aec656191634a41fe39cdc02de8fe438c1acb02a039b0a673c9eb5a123301a514fe5460c8cc69145da6a31c8b4647ae59f1d8445e523cfef6a103f425250656c8648fd53b0afcd67166b19a1652091babb3158e1c97b72fe51b19d8b0dcb3df2e11687015e4d6e13646083fa690ccdf23abf3e9d7bd7666ec4d10ecf7ccf21ae3da29ce3285e5830f5c9fd54172ed82b5f52eed8045550c98e989bd8f9fa417d5e5b431f997fba9233c4e96010ff0d5797727fa5567487daca379540adb777f4e5062ee1f6efccf658de66b7de98c9f91d763c6e1af42a095a9fe81d5f9d22956d9d1270b58dd1f7f7b90b0073daf0f87097b967d83a9915032e7f8f338ac86bf6dc8a99dd6bbb0b7a5656cd2f89af08fe98801443a747976ad62c2d09794688dd80c8cecf3f8128836647963f9caf514e3513665763b0f1e09b063b866ccd10a31277fd546d63378583c713eb7f92a008f856943eb4c0d6a84fe47f93664afc3d5f157df1d41ecd38e06ef60bc7d7f63b53353620c8cae5ec9e6d65f257d942720ff05416d7ca6f9b837b9c3f01e8003e3314efaad330880129a5ffcee81a7c5efd3ee9ee49dd0501bbe679814bc6643b926fb2129ad43b862ab7e596362489953abb5f0d6b1edb9b8491b354722cc5150f788c2b24b0b8f5b6516fc78dd4cdf00a78282c0f0c532795f84725ee20e5d879ef689e6c2f5fb79102f773bd2ee628ffcdef4b6abcb9168f4e3ce13ab66dc9b3ccb6d62118b9947b50d2990970798fed40c0c446f97917c6ce45976e97e52f4ee58c26bd32ef59028b29a15cd2efbff728b98958f2edeb08a28653c69bd8fb3a617825223bf32efa7b7ecf5c060d7e8d23f1bf230190c0a804eab849ec72dd92389ddcb7671a58e33e408480da460483ca1113342bf69a938ff84352576fd35d8fbaa7f8eb1747ad537d9f867b9df45f98dd935383d687cbd5df1a4bd99db6aafe534a9e7b0374c26e9baeb9f813dfa9f2cdd91c772d95c05e12c80ff022ee3c47bd23a8d196d6cf6b6c4cb0e7040d0d0d38e9cc6e9e29e05599907a16deeb0ed468529d4c9abe7e3a4624bb4f47aab7fd2bd44b730cd5dfc02e767b80ebf81b43fe427ff0b4c003ca2ef8df086f8fcf904db290528945eeee17ce599d6e26c5093de333ecb50d4bd38a589f0ebf8ebd154c77842b1df38e3bcf33fd2cd100f5c41fa4f6d3ca0aae098aad4d6765eb1d9384475b8ee1a77037ba50a88de8692f7659d8870fecfc45a00d021006f47d338b24161aa6c793eab18b1993f936a6cc77e4f358b8f022f8ddcaf852ad678a3865a042320321443dbd5b1590f5518af9a2318a58c8b6cf048ffb068b79f3d5aaaff7038812c60e1047985e1175bf8af6410e6eaaf2d8ef1f7f9a6531665deae833164bf8b0b7b494fbcb27574883b758205e40d91f1e949488c02090bd7961a896c40bd60279848464a56bfab913c043f2cc0a6427e450c2d64ada002710b6e58afd23fa79e8e395420799354137debdc0d195a88bd61d1f56412b6a90471a6560a426760f4265da5dd1244a8751d081854f51789876fd92da6d2fce29c25786956632796db2bfacd625d6d6d1b48d2d24d3172210152861f7030b7aea122487ae142e2ab926eb706ef881e677f4f56b3cf9c00d0e6617ca98d945bb8dcf9c4501b4d42a473fe710ac440b1796fc9d0123bf638a2cdfbf7bfbedeefcfb80313304a5d38fe630c85b06df31a2a9a740ffec4d117c8d549aada9557a51951f6ac5f8397ee80863506aa3a455bc62876c0efdbd0d2213e583dc4c4ed9870033eb9540279c3082492e5ee3e62465dadd2b00c385a7e15be29d0aa4df31c238187029b05019d60f772d744f2321e2eef98aa79255801f601fe09f7d476f0295e94f08abf3cb9a326489c817ee8122eb703a4d8e1d1c6069a50e49e28904fc8bc69b2e7af9f37d5244623fdad76d2b6e25af157256f5886a0ed4d0536783639fb62af2f966ccdac389f09bb96e3fd23490322cfcf6d65361babbdb2f6896e1b743cda2075edd87f3f654a7b38151bbc31ef6dc13348f6adb8677ec70222c47c7d2dac55f2284060f7e8a105cad9429f10e8e1704f8ecc410cc1685842918e912a2f5d167861ab0ffc17e25ecae82e195d123d5df4b1235b72ad0b497c6725102877911c41387434bce67b9318bff9a196d1b77beb4fe27bc5aa5052abb38839715f164010b557e18fda33b25210fb80c0495f92f627e5da48abb56ab63677aff0eb3b0b296b241a7771fa0723d6a856ca8529dcd99af72d8fcc107caa057f96a733084e665d0384e5588e6086499b1b9ee9d63cd3134ba9439a35202834c89d939a9b0d5d02033864a7dac50816108a30a02dc723689552dbbac4676a1cb4a2d0b3138521cfb69bf6ff5be9f9d5e21424568c715ea214820a4371b8c935d0b5cb5785c7163adb5904a5254e485c4277d5ad6a4a416433e386e2e6fed4a9133614b7e9aef506ca36a672ae02520a82f4c44501d29f3f614f75a621d705fe562c9f3d0973c3dbe699c860d4c0fd4bdf689a149d09d2e8169707e2dc21cdf0b560b21dfcb42e2e206fe52c1a0a5603c2e5d5682d66c8b50885127389f3f5742ea5bd11b71b23c0d87678c0ea273600ed5b00e4078586af06a9d49b8e4815d974eda663137ea7c1b1d3571f48d443987feae57b6b558fd5e44a326757ecd8b8d1889e9cfb198d71827a39ac7a4b0ef675cf0050d2ff1a962a3bd81b5dd19f84d68e2bf232c05159cbf807086a9b795dec281a7a2ae37fdb2351b373be9fa84a942fce059988874bc61087c0a8b85c3b436939e7bb479277b0185f56386b2928fa6a9686f3322622efb4077e8f40b27eb35b98367178e8b499d60e4f1fe70b739205335afc7fb0658da943973df1012bb2a0d229d33064f68d207b865329b79806c9004b46a04733ce16d82e5ecb6891ae32ece3d56084c8d181f4288898c82f66211884c30eedf18de8995f51119735fa19d0b2c768b37f20d5947cff4b4e1cd5548570854b19cf508d17f62988b19174106f7f596dcd6012fe6993e396a4ba965f0e5a843cba1d32e23126d892185564cfb3a95cbed2da664fc7b681e40f61714ec2b115750f988d8a489a84450dc512d5df9134bb0dd3e25af4c86434b7a1a23ff342469e51ede6c0a8cca883f101314fc39ec4b87cb23c7bbbd461fa17deb90e6a86a00958d98c57fe13ad1d8e79fffa9bc5760a74693f5fb13d82ba6cff4291cb8ca544a6dfd983a842221b2dcb9096a933bb7a77c85cf65c74ca5ac770fe1b85c3bf392ffbfc47cbe0fcccecece4bdc12b29981df26370175b2339cd618c8f235052d166a126d94437b7a2dc590254e6ca1decc8e0188762dad7c69d34509a37297d684fcfadb42206400d1d334458f0f578acc87b432ab6cef5152956bafed69f93012e8ff8acb8edd113e884394b41c0e9bc7864f15adb61f1b40cc49a6faed8a9de7cacea4f420779ef41d10f21453d53b663ecffc6b4e3eecaa0d3c7a7dafaddc6ef547861e89fb38401f4012450ade1def62d1efb660d9c2dd2c999d4b7edf10edba063de202648b02d24a32096b80b0a3c6ececa9ce660860e13a58331bf2349c9a15d5e562fa095d3b549ba7fb8d13d1a78d208553706cc811f4752436f10f061f2dfa1bcecc7f66fd92e0c851fad1e14fc5b2efc05416b70a32007b1818fb6a6b3e5cc016d3b3241d82b014d7ea25df2ef9d0ed0d74bd058dd2c19f5b66e500a09aac9c53cdabf257a5d790dd1fea04fa2376bfbeadb34ec8955ae10f6e74d717c516e6fd5c7ee97d5f624e08b6e70bf3eeecd046f2d1e4f12f9c4254445144064b72afb491adce1477d73efba5168991c28fcbf1df8bd25e67a57c6d1b98b5a1d16edf8e804c21e8caccd28cd8c74ab9576972ba58dbbe6538d82e7c97eec19c09304c76989478c66cb012391444430439276ce86fe03e84c992e13820e46987470306917608b538929e854431e55828be2efa8b43fad4d06353b5d23168f1010f743dda87bd5331ba832b4318d364dc2eb1d67db086667662aa598948c088841ee73c7600875c9c5079af4b617cd902e078b821f5d796bcc84e46bcee62bff005c6c44a8667ccc87414b607d9751ef6c06c43892e141357838257736f4aa15cd24928dbb793f003c74b6aee7bd997d0544bea3992640f6af272218f13750b64911af431950afcbdf51972644ff82ccf7c92db3fa56ddf5c1d49ef1d2dbbef23c7c7b629106a94b726780bafe45abddbe7f1d9fe1bfc3c6af8efc535794ef2941bb3a3ee10977303ed5192af005c12f7da0a24b9ef0e2d0d93e554fe1293d761deb849b8146c7a7937e4ad51267fb76e9478a67a5416dacdb7d4b42f4de2146c92af868869835d4d5752009ee7f0f940fbb9a117b96279c643a2db8d8ac7ebfbfffc03e47c97a448bbc1e4553536b31f29f09e12efc0ff70da59204212bcc80bd00ee671839b07927a2fd0f33691581940e555c0a262d355ad17f15b16e0d7c20bd2fbc899d996ead75e16431091008b60184ca18f089537413207076db3a9632bd424d1b66fb1eb2ef041769c5cfa1d1e4c42721e1ae2f206d8f77164ecebc86badcce9de32efb8f9e1039250e2603a80d7847db647b46ff6506a399aef1bcd01070064ccfaec3d092b1bac67eea065431c31780b16e725709221eac7ed9f762fccb3c1bc88ab838492479a9640aaa246709b6ed3450b97e330204638e3a38caca427c79f7d06b8ae295d16143374cdd50d388eaab509c07200d098996c0947e627901606db1b41367dbd5297dbfd963368460220bd5f33512d1a3eff7c73a3901d6a7374bc85c75c880439497700fcd5ed7c1d1a21952557a3b0cd3ae76327b3284e62cc9bcfabc1fee1081bf51e6b8ab84b40246ce15c91e7bbbf594ebfb8161150131c2afb9791e2a874f86f117b917eb8c935551500e4249c08deccedb80dbfe6e8b91a3fa1ee6527b81306ede0fa0ed56c7ae31d7708ef2528790175472a6703fb5e4a9899a81b4a9a7eded7f26a4205a09b2069d22f4752b0ec50ed2f84a90247fc0e19dde48a232ab26d55d6ee8c35792b19486fc1856763aa9316c29f71d4daf0c8225157e25f19558443fd42e58c4d89e7133411ffffd8ecc9ed20cdef366fe6953c6e50f17a00965b29c08f2a8c843e2407ebdbe8a126b2570f565ad21e18c1040b32e0d28e017b0ae6cc001748fe281a778d3aff2f25f0155d6c708fee55a724c8c0fb7c5feb481e1f01d8c65953a1b229f3587226de5194a7b912f61fb1b964a368cb5a6390d195d73107b0c09c8ea556573bd0d83f5fef72251fcca79012efd020d74615e4725f7cb9341c0304eadf3c60f596be737bfa2fd14563304c8e99be067980bddb752b0882407a465c456878093cbb7125fab80be344e22ac88b72f8e6b59b689936554717d38b36d97badd3ec2dfbc9bed44c5784fd27f4c1c46bec0c38bf2cdce7f6cffdee13f4da065dd7c07bff5e6b3d7af3b266390cca08060ff8da62e758ff2e665fdc2af3efd8ee3ee11d878d051b2a1628be0e214acb2d897476c7b84a8ecc9523905050f8c85d3345a3fb86e6a7889d22e596d554855bf03e54baf0d2e6d51419d2857bd1471eb9c056fa9fdf5d3bebd8d45b418c7737607a811b09599fbef0a1538a89f48f6c53bbfa63a70d485fd8757c75d4e0e14cfdefc0bcbb3269de886a0909c29f082dca111a118e4fa175be6090c912e6a7b939bf975963e69a3284aea17f86cef2e88592e61671daa0e40655c5a3db19575f76f0f3e85aa7daff6120c0dddfc6df110a41516aaf0b5a5c3fc3e8c656a4af935023a4fbc99e600ea00048d0aaf18a8d55eaf36771eaed1903d7af291a5d24f12d25e0798cc30ca5799b045da0b2a3fb8bdce597bd20643310fcc3bb601d91497de1225f38442e536dcc351d01b39297748141e51b990f0b49c8d9be35b477ab4affdcee1b8d0188ee0b632ea71bbb59b2785ce2ea4a658d587c2a380f9d2acd4b3ec10d50fe454146438434eb51e269a5d4bd706c7697e29dc69674db2e4e6c5e57f437d5a2bdb47c9153707ff9476ba5d26429110ea700eb9aa1ef2af96be75b134aafe765739c9b24a45968d92b264db089f6022b04e942c59e9b22bf068089fd29e441fd2be176ff450dbe7c7a06435cf6370e17a5e257364c529cedca34af62c152070de88a3cb05b9c9dff030c18fac073c77c6cf04e47e4ae6255675aa19d9ae49f66f659b42b011925c727f6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
