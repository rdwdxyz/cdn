<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef49740ed45fd6f8562ac3d38b16ab9ddabd019f2634c941b432dbe091c2e90312360420353f7cbf6fca158ab12933cdaab34f82144a897048b53beeba2b4186ba6d7bf79ebc81a2f4586e6e86b19408bed1396ceba0f7241068b388c238a0e3c537fdd8225f6fb3f8ceeba75a0c537bd7be5f1001e159d6fc34dea9ece21b11917d43218a6d55d32e879b256965fa86f2ae741f4e901e68594cb6ce141e9e7434d887da0c35410e8f15bd493bf33d6e4956dbfc7cf32163f3a9d6854f6f17c2a9073f20f12f6a7c336217d3af108da8925423950c75126fc940b3496042fdd7f8ee49c68c60495b48d8e92b76a1fa1282f1737379c8c949a5db78e95c186c45c24c96046d851db063994e6fa93a948b2dbbba650f43fd8b54019e07111df153175b130ae7bc8ba35367162269c7440442973aaca1845642f6509b5a3dcada9f9589f4adb48372577a94cc887b73d748a091de4c9db34840b11489b95140db35d7737e1a4216ee1ef492864e888eae0f984a35c24001ae6b07c5aca4872bd8f9df47b914f35ba60175b1411e277861953aa1ef381d750e8fb4456995d7e5672f2e08b89acf48930e8e156ee1ed4f7762910efef79d3890c8ff47cea3bd0677c81bf80790540506d63fb04d641a87899588acbca6436a68acfcd0629cb00253069f679994cde24d8b3e432c033763352c50f018abf42463ab676634093f00e86ca16692069549e21e970cf8984713516498d0efac1d3f47c09067c9448562924df023cb9fda2f42a21e3dc8ef8cc683369379ff1a23fa9169b0a6d54baf39757f6028f0e624d55bc88c3c1d19f8146a0350ef7df9cb09baa6f1fc1b83a56ab008b47f94ab2cabb1389ab6c48b2a2b166a4cc7876bc2b63cd24d4b81fd8fc5196e599cd1ac9be9c32fd09965830ff017866098ed8b764f91e64e39b1389d1d49ef3a8ba8f3e153ba87c9208c0ad634f9f56564acd0bf6c0bcb82115537c7f702557d3ddc874323d11ef0e73e17bb2468b4a85928646bc3d260636c531770f725c4ac282509909141683c8b9de98292fbb2216d9342d22b5c73f1bbc2a179706404319897e2e9bfe2cf44ece3eb7752d8b307e9a0b8a5e5f17e563460f783646e1acff6c1e0e76382c2483421640d094e34224d52f9d104b8ed85f7cda9fb740cf7182f8298b2af9457d45967cb56a417329f70b4b819435cbc301e6dc385e92cc756e9b2808ceecc7bb65bcf36f8ea4993ebdc4a7f46c940ed5e87b9995a710be550c387f4b2e69049412b3f95d574f4fc43e1521a15df8d3aa40613ca82ce957f86188c45dfb5df6e831a19309ae595e06c96a156816ea1bccb2080c2e60f249fda64e3588f8689bc4263687882ad3004683dfdb8d87facd4ec1c69cadd6fdbbccab27f6bce42b4acf31d0ea3e4151e3a3f257f63ebd7048d8bd4c3ff7d8af180956cb654504865bd2aff9390f7064e9167ee77cf650ddff9a34518fd330f40c8df5101d3546e84a04044a6529b707928aae60809b0df7f3c1328a00fec60f48ccb951b5bd2218f0dc2dc17175b1c190023bcee2be3a4d22ce82fe8433c0d3aa81b2698164bf2a5d2cdb3de4d592d37da4746e52018f2ab956a9d7af547556435046d3f1743b0a616bfad28d6ee216b9d21b87b439121bc22219464702d27d5b7082ad19314ef6cba6378a7639a7913260a4c605ebb96d6b09e0edc32480b68458fe5d17b05cd6c6724ee218fbc40308697e5e6890f0f63bdd712c0eab5844aa0639b04ce043c3d9a54aaa9c80a7cc01c195e79b229c3f21a343913b07fb286f6db3bbe956c458536eb74273f8bdf50fc7456850b654fe6fb66a1c8f878e2009cbd525ce47e6f5ce75e644d7991981c4e63e2835c0aa18ca14e8608d871c25bad73c32bc60d350182696bf91761648681b9118cd8790e0e780047dee2eb3acf6782cd4be139ba3a0a4c4397d407493c229af6b6a0a9ff30603fb80d5a6c61a0001af68c501b8e0638265dd17e8698468b23e5f69db4725166c6825998d9460aaaeb60b3dd54de6bfde0e1139c0d5f52cb2af102290bdf8909a9356260e82514ef450446e237d8798fd81281bbd426b75e29549d7158c0aa0761c7ccdf9a0e6be36a209b69021471472bda9b3acf39c774b2c20e67395a4dbce85b02c519d3d2f6965186ec61cc2210a17c4926165109dd8a6838c0f51acfee99b1bdd3f3ce44559ac966a120a4fec4830ca5539c9aec84c478cf82dc9a7924144dc5e3054388f3ff9f22f5274cd3a4c202f83636ee4c569c6d510a224ac789e2e2219b25dd5910be8393b3ebf9d8efd70824f89d57031be096438a9d77fbdcaaa774c2d4641f0515f006de42633c75e42ef99f0e30e748bfe3175467758a236d161e8cd16885b3c54b2f513e28d823b89379ad96a43cc4a3ff5877699597ff7ca8dbf02f2c08cd21543eb110aeac979e4429c1133144b27d859d136624dc3f62762e664c576b8b6bab336a862f7ec5961c69e70a0685d8cd27a8447b608f00bfbe0dd3e9423e043f75cce8efbf5d504218b346e5254de5498460f1f1e43f8511ee03fe00a9f54631c5bbbbed8ad6849928cc64ac3f6a2496f0abc29a9c280ebbac7463e730207361a834d7a9eb8bf54a88e692db91e61415731d3ce38b3a125f8252f741ce755f147c573e9ee40a2b3399a7b7a0684ab84ca03179fe3bf9ed1e08dd28241053a6007cf73cab334811d4ddce20e0c63cd70f3b2db8cccc025afbae545af04305c3cd9a6d27c8f52297d31319144f67d43e8dd79fddc449a49c2075bd27d6a60d60003951fae61862fa4b96419a218ac00055739717f82cbfddbe429021a7f56c76c9ecb63492dcf2e258eeeab225edfc005e6fbb6b7543acf98df0b2410db6091a6aa66001382c230b9848df1d0a6b5ee6ecb45e7ab21b8adaba586a4444862fce058ceacdc4d36d1b8715fcc9525b7041ff0d36a7b644570da9d07acd503437b7bcfff29cf4af85fafb612cec342611630a93b3825ec0a3ea2cd6da28a0dd07153f1ec6cfd5310a9bc41dd89cd8b292d62e2a410208388321266657cf8affdbe863895381b2ce4c4c7a8af90d3989c73ab5c07dd0c7ddb478ac58400fcc9d15c42ebe200d259ae15c98e1b3aea2308d710534979a0016df3b46672748511670bd00fb0cbd2519972f29eae59a3fa0a7209fb5f5907b52f0e0d25a1cb1e510ebf9398dc71e747c259b22d763f0a25ff75ec7736dcccb333c8a37462d23eda6e9158df96559a27a2c3dc6edb7dc2f131177b62ad89758480ce6bd844e8c45589150787292fa05864d06c32d55d6eb15c68a97409757a6d10d1b99a5b418cb46b50d9f37f5c54f2314d9d457f7b2de7a7ca74bb7217614c36707dfb4e9c66cbe3115bfc4c131329390254720148ec5b6b87bdad64f3f54e3e3641cbca9ee826509949ca2489c87ffb6fc2608ef001b7bfec6982c980c9ad8368f3df4002e09250af639e624311eecfa979a8bfa08799344db5bd954efd20437bd98f9266fb4d0c462f1b12fd57b098c1bbd5e451b555911a7a42655a30ca24fc03342b7df20bbc3f4c182797754d658ff518dd4b8e4431662e2526f2ddf1ce2dc3f790f0fc78a8544ca41f36a1ace95e80bee6750da972d97cc5bfde153ee4195dac3767332def7ffc940c9d052172f1be44cf01f8b00c3873bac6d5535b8d931eb3f32e5c60832ed444db26bef05e1292e8b1983248bb0945ed4e6487d980377df5b7b1ca3324f22cd8fe91d2a1327ef3ecb2df6b9ed7ad18a7795fda8cccdc5b8a887162f7b57d795ffc4cf030cab18850267a41622544ac475d24fd3b7dcbe789b75c782025a5745f482119bf4699d80a66efcbde1d10b094b2ac49d3307083f15ee0686b6634ed1ebb51733bce60dc180085c1a526345f9f4624d6d5fa23d806d3ff2bcf8db0a4d7a006dc8b82f221b3cdca81d839e5ec196699d0c392955b364d4f3c6ee697fc3a9afbb02c796301614a5d97f2c21de2ce743925ce68494b6d11ecb184018999314826ef0fc0b69819d494f67c0892de72aa1924fb444788e8efaf1f173dc96a72df050b7bba330933570960bcfde76d8af279b114b8c95c336d168f58be65af594e1cb80f6a1b15e67bef8d35b23b5afdce28505d037e73ec2cd9092da1176d59405902781b6eef6e542543efe72a445ebe8f224f6be716c157bbac54fa92747bbb00bc67ae699f3e98610f8ab7cca5a3d44550521d44dd35412fee2e7f72c0b3c0fe6068a2e83a44f48715f18bc19282919906ed63235eea748939047647b44351bf91fc8066905daf3a959199085741c22e3c19ba53f3b81e7f26c46677ed36a9bf6cfe2bd288c0734d8b50927381c3de14c33f3ad4a6cad902148cc4ba2046078177e693429d9f118930dbe07b8f59f3f80a6f6f0c016f102be54660b915738f18f80dac1256b1c8dc46e2e6a65fd6d3ebf2d1d2d3c05da6af2bbb37d665c959d658a5f5a97fca5972b340908ac8d6bc120e85f561230bed574e528274190f03a0fec0ba1f97d0200ffbaf1b796cff549588bab199e7e0cb55a08666be6106409a6ae268ed971133b0e932bfaea1c14fc1e0d18990b4ce57adc4eb0d03f088e394a36fadb6658025eac222d23af9bb755321892346866d40133e69e511c37724661b26342d04bcaadd414f29cce76a181063499fb09ab4a32a1f82f8376f07c51abc9c78d8f8a90bc03a542697b54761112ba9b702419914ff494082ce2b930792fa84b885f81d842d79c34e2f9edfc927d906cb7c0c0fbf3cd898c7cf78944ef81ce7d1fac1609dfcb0b61206c6d493f4d890b77b2becce0ae05f2dd6e33d9610f3fa342ff43bdffbe1a0d939fcee7c028f684245edab8be82f63451b371e5ae1af42fe379bb2ced21074e4e8ccf3a2fa9831db71c80e4c518f4380b21509ab5579f4dcb4a7610d3b6cec05990889f386da2ac1968b4a3305f63a0a68668212e3621dead68dd693ce4e8fdf5537c1f38264dd0e4dba28bec989e98eeda8750c15264e52e626b375812627c465650964c649c7e88909e317ada84a2c2e1348e7da1059454cf7758883af8c069727095056f20681cbb5e1c0c1945c53b2071a282942152247f5c0c7ab00a0946ef86052bf37a9cb119f72ed43cc1f71c6bd74dcc9f5e360b9efeb40eb25ece8ee6fe9c11446aa35e2bd0d35ae0367d7ac5e5a36e5b7d0709f9eee67e8475c2a2bd352d5762f10bdec030b3ef01020c1a5431c918e57e594180ed02b8495e07befc3ee0cd0fec50a853a8f7116fafe23a4834a8b01adf49dc43843d1aa5a1c986a6719aed16701006b46b9916e9298fbf39fd5f4d79543bb9d5e7473d2d5299105cc7f9911106057e997428e9df1442936d6cf0d9190c390b6a867010bd2094e2eeaa44a0002f838ec2273ca9b0a4c3e091fe30bde87836520b44dc4b517efcb5acb1aceacd9966947a7772c7909116d3c4e6e550ac34ab5c11038cb59712279bcd02ea63a6ff2495b9fb3dfb4e5fc63b26032e9788867f87c44dc3a9e8a136783d090957ca0db8581057b4fa53c334895219dcfee2bca7e9d02bec6b0f23a15ae048152dd1a798db808338d7c20c76dbf5630fb15a822cabbe1e3bc159dadf6e2e7a3583c3e6cd8913e813320964c5e698aef2c81e741f0c11cd1a5c68d993184e6f7836c09db8849c3680c20a3ca3c2e0c7069263c1e9e20e7b368df74e3b7ed4bd7aed203eb5047c9e790a1f33106689b70fe4f094f55e76442a71ec0c6b60c8a2ec1f248d2ffc684f26cc46071e115a4c3ef1ee32ee67e957f6999303f0645ee7a5d3d41ad00ccee31ab7654feab431a9c983365086fe49cdc30f975a517614821015254be6e638673176d3993ce44ea8f6087411d6a686a65042948e1668218a7c358f0db65a0175349e113a06b1572a3fe6725f5e5b4d085fcadbd686f0e89d3e7f608aec4d24931708096acb60f8f4f933970b3df49ffcc8a3c02fd20ea5a6aa1aca7004e551f621b8d37f5dfd79a1514dcc21044482bd0297be4cd1ba269e127289ccb3bb29673cbeaddc07732e9a5e036c076276bf16d08499587617a6ad344ce6de38aae59276bf8c2289632cc5911aa6f21b624e4ad767e7096de63b5131f1222bee02e5475f0225996d5e64e2e9630e74df6209422ef0f306b7f2601bf5ff39ae946488690228ebcef3e370dd45dbd1324a2bd330bc7bac4f2ee8fcacd8cce16ffdee25e44860597ea1c83509b99a2ced2b58a90e54cd2d8abeaa319a58ac6b70ad357b07a63ce9b5289ee1291340fb6c20e6284e6fcfbadffd188ed3276be39ca37c0b2b86f00d0ce0f1975616b4000dcab74923400b4c1fc02748ee0963433fccdb1f9154c4748b0e1d08c50b78ee243970b7c9af30f94dbe0e7221f4cb5644b4754ff76d8586bd9707e0490008365614589ce50e42892cf68192dee9319cbea18921e2e8e96a2da44a5aba52847ab7b0a8bfed2b1210cabd849811c8a84237d1885145697a1e9b1d4133dab418f5e06efc8629439745b2887bfd3f0de855653b96b3eab687fd7f93471b31c680b83994bd56b7fea35780f879a37f6e4c1aae13b1fe3d8a43df43f6777c5aed02c19ec672595190f3e13552e247c8d43127bd64ce775c578e77aaf7f86311edca3dc4a223a8994af1f6d6e4f4869969cbacab1d3d0b33250f0678d42ee021f37de126bbdc89fe74bef25065d663138e570c9d7b745fe71abce2dde08f78f4f3522f5403f512368781042cf0bb27a675a51cc3ac164c97057a0f8ca281a46fe8c177836567a037df0c8b2e1d1230ef4a440ddd4e6a0a79f4afed30152f510ebb31bb6cd26fba891e39b79ef3846de50ef9bd01e8565a73d09175d9ecad51a84bd7f590c885be97f8dc913be073f0b2120fb56a87972d8d96c15a064c29770e91a3118e758636932f9b4706ccb6925b8425817b8781ca1ea1bc65431f26b092cb9473b060238717903ee4eaa1c0cf1bb20dcb3b4191d2ea1906ad2d995798e2ea879e06ad47b1bf8f94f49de0ddf5c545cd17cb83d78a32556d489d37d1380ceb859ef39f06d4fad366f8c6375581d7569751a4b7a49bce0ddddadc8f98778c1a2af35343aecc74e7a6dfe33e43335f1b47ad75b3c3d60dab4acb703760018d73499121c408b388ed48c321739396c9062968e82ed079007fc136879dad8090a25beb7a0309cdab916c23e0b8a6a9471304acc1ee09251d76acaffdcd68e4c414cecb1134828c78816cf4a6a108756f2d03968ee814cbcfb685b0b01acb5735ded53db23c1109365dc97b3241f1999cce47d969b6df3a48fb7f957f1fd777d123e29fa7560d8dfa4743b20c7484449a76a1367dac793ff3aee384d53fd224cd36c274797cc116d8819bdebf95753478a8d3b4b601cf97bd896c5ff022278521b8a6eb5b7b70f1ceccd5b49f27f4f285217187ea5de3d6d4a81e7ee4a4919f187010371cddd23af8ad018dea38e281c8421a66e66ae54c66b1196a8c4f287dc5f78a3094e7fdd6e222fa31736339539ea9e95e28da78cc1d1b80affbcc755693c1b221407877a3d451ce9032566b1cd762885b7079e3268375d1a94cf6b5309014bb8fb2a495a857bdcfe97ff78ea58bd88536be62d385a0c1495c60bf8aaa4a60b3565de5063e85663ac886d6301dcb3381fd53b7f031a5803fa27520df994301de5e183ed712b806dc4cebdc2a01426d2f8d5ad9d6db4e02f5db1c45b187840322d62cbfaf07cfd2a20fd3582192b876d96b66fad26c52de94dafbdba2e0dca7524bd12182663fd9886e4be0b443095ad725bcba8d49a34561ab5cf8254d4e262e61f353ee6106efcbecbf7b7e4a6a72d846935f547a3cf7668c9d99ce7e2e995324cbabf504051cf49761ea4e8a742c8b7edcfd8c23aa3713dc5a2fe088744dca00450e59244c0615823ad978d674e11e1a505f74fc2054ba4c019cd6d20076ca34d3166a8db0e29fa4aa8538942073e1200eb7859fa586f2ed335aead9532f243e6d66ce91f81050019140030f3cbfd7ae390ff915f67955e450b9d72e82000fe75e7e9063adfa49a65dba2ee492cc4ca3d6155bdaa51cca1138a63f2042a409d34de049f38cf3d61924ec5321d0cda8cb88d01aa27c5dc4bc7a56d40b4c7892dfa7becf9e0259dd170af5218b3291c0ad7bec2a84fe3c97673feb86ea8db0855601364b98e6fab4cb51fd5cb3268da7265350cbb8d1a64aff659ec4cc7a780efdfbf8cf8eb25b2c92c1654639b9d4ef8604bf033fcaba84fd122909870778b6f0ca3443d9f1fdf05bfb8eedeb8e4abf17231eff53d73ffb1d097a2044d882e01eba156bcbbe35e6c87a6384f182884d8f5c1052df789776b2e0a69817b92e4415a6f8b84e8691e8fd5d6c6aa127c79978a9baa4934b371af2b6cf4926513af6471131823cfb19abec3070f86792764c0a45b34aec920b0aacd9f9c76e1c2f60490430919f677b71b9b94abef2aa8a3c87a82bea028aa30058ab5c07433d05baf4d473d3b7f51de2c798605c7ebb1ba752201d5cee895a2266533295c988fb6e74b5dd80f0a6e7ff0ecce2d2ece1febdfe5407ea6d7548ca551c5e03bf306063f95160279cd27aa7bc948cd6f0d3688816e962a020a4063c0fc962a4fe68c38a43b3c95369af844c76b702f85c062e1c4c7af37bd8954ef907ce8e52d3f770fbad0a01339b8c6edec6265db44ae31cf39de26456951c3b9bfdca7654ac7e0cba9213ab126a2f4f8b167f5d13970ac5d6833c7c47c1597dc3b7cf4de0e56a4b89017dc7807db312a6c9b0496e00d1dcd18365cac5543bf0d08bfb6a72f8635165e5d8a595ff5a4789741ad6083137b5a3fbecdc47f0131186ed7216eec3425ae534879cc186bf3078d46109b4ca11bb819700c77a3326384eece9be65ac4fbcd8ff86356095226b1710dbb3ff57c83ff7182940785dcb72f99eef0aa08ea500d08f63c16f419934d333902cd8dd41de33fc48a7cc6bb05a0b3987fa0cbd048ac7ff8a2ce079600ac054046f9c9f3c2bde8dbedcd4fd41b58b05c6bd5071e90a4397276d39ed24ad88482c651d918c6c8eb27fa28d41f558e7d72045c7d2650a18ae48911c5830d4d1f0a55f1b2ef87fceef2e84b885cd252c3edc2caa27b381291f2cbf90ed135b6c9e45671223079ea24a6030a7daa0c7eb82f414e6a7ec2d1842ef483d4a26997c890c01711ea260473f726df4109409387784c6a3955e8a1472052eae5ea113ce66fd6185f54afbe6dea17bbd82c8d5d00780cedf2aea2c965cc2503943b0a2f3105c7a45525b3ab461ac745d0c5e3f0e83305b1e66fabdcc512a506bc989e721c2b9b3cfda05de0fdd80aea40f5887d6550ed324d2bee26916be8d9c94c1639000a98106806730278e23391aa78044bd7d25e8594c752d8e1a749b089ccbc3298494c8f0ca05e3acfd7e7423e7238f6ce04d8c5354028c80905f2f9e0692bfbd03529b9ab847e3fb2e631ead752ef433ad856fc253ba257ed9886fc20d01b1ee498677cb9280ef71d02c8e9bcf17a82077cc0e5c917abe333e319f1230cd17779ca96b3f4d6a3d2b970d27465a5f6936b4bb8785a53b31f9e9c1bf15a98a141c7de6ee8ce9928c4307ac3e5add3110db134462795a7eddc8c4839dd0233961bfbfdda870fa38cc3e68195956918ab1b8c8e8e1abb4db1c1ea354d303b9b023086724a560ae36ffda1bd16c57b7f1c5f2581227079d60ae9a44d5fabea8c28f473b11d05dce9ff4104d01652c8b697ea4d5d996b9e91fbee4b89e56b7abffe89f1ad66c068962675fe48b00b4bd8629f621374b464f70aba90e909f525068a9725e3c222b120692ff8fe5ab31bc67dd93074b7ea350ba557deab76941ed8d15d7e056d09413cd67aef14a3844570843a0a36efce47b17bc22eab7065f2bce9e49f74fa9f1d4c85202af0bfcee2f6315b047d0fb64f5706fad0219aa76afa01d263d8f18c3e9ae0563a7027cd6608c66414e0179149b79474c5548b697855e2d859efb5a7341f356a039cf052802b6590e0ab20c25e4a562cf3d7253084928424c24ee622681494cc8972b12904cffba9bc13b5e9d3b198c5ed1161ab1c1d821f0ae38e16a3dbcd3f091219de9d6c367703d25f30bd91d1d1f77a1b1c1b7ca17783895271f94a6d3257682615c4ccc0af6d8476120a7cb5529ea6134ad8f7af57112248228a1ec31a855aa8692e1975952cb1a3990a7a680c1f1cf79a3726afdfbec96b568cb536ded5f84e965f5cb5025ee26533a2eb2e00720d76c80290f9cea7863cd1ef4e9d389a6e0844abee073693529ee3048d92e8129096378cb4464d76dcd66a5f9242743dd544c5a08ecb055fab9b777145e2a676402a15dbd7f0aa36e2844172638535bd8aa8576a6375580fae3cea8f9f7f7ffdda40b324a6a4bcc68ebeb1b546a5f163bafef2548b30c908c8d2ba860a0b8c729da564be7e7163a0798e4a85d89354aac68ca0f2e73100b122b9d1fc76d9922f335d8e789aa5810bbd681de51d096f8627d2895aa1f642d74724fdd09f3c3d94275bac74d28b583b10112fc085c6e5c8166c8359da9b53ea5e39863031be32899ee8f2565cca4753e2e321dbb645c6106b9174256d2fdb1c35d948799add807f8a7c3c5c80934305ad5d7b3b38d3f8984fb3dd2ac983e275e0165f2fe19dfcd699479046ae97cf4dddd3247c955d74195d31056907942d10b8ebc25409dd6a73da4471759aecb8a50ec42063242b4cad66f8178ea0fc2d04170ab15e82aa206a4c6eb3453919dfe8be140740a621ce4e4fac695711bdfa24988c1c82a1c10223e24adfbe09033d86f025c20c2d32d972c342d8a7ab67c155b412045b53b8490bcc18ae3a609a23ae392bc13c1b90f81490a2f12247426c911cc06af8f1b40354009adf5a553a717d85ff002993bfc29c295f159a3e7d842d7e1ca99473d7b32e4373c0e4d5a7f5d291d02d3d99eea64ccacd0acbcd02dd8785e72a2e1f0c018acbdcbafeda49e8732543abcbd57ec06499ae2e74faf3d21c307a39015c35ff25d735d00c612225a52dcfa60d5a50ea7a5e4e1a322cee00e5bb68418f34862c1223adc95d2a38811999806eb88e45cfa3a7125ce19e588336fd7fd0f6dd42e8409f8c3a3787e71322e1c2381b71d71b601a0bf3c4062fb266d55bf4042d8a4e43bcf977108a7edc8c60b8f1ba304750c10404b5d09345bf70a6f88125f1b7d448ad286064959394dcc985240f0c13a7b780e19f6c268783d99e8f02f9e2bf188a16d204df4a2537d9adf6528612ed99491d6d05dfd118a9b60359af3045d1386b323d7956ca9f8cfc6536bdc63e762793801e67ad58d04bfe5efe8fbc219669d17f3e52b8881dc999e1624dcaea37fd7497b74f93969c09b891115eb69546b2ce2cbcf34e2c4c1747a9098582e80b44153ece5ecb9037def81c5eb7ee057f885eb6190420cbf69c3e5e70c8a7862d13074f30c2e45227a64796738d51e8db9a80c7c75df4258eaece65e667dea498dc73b7a2fcdf95ea185619c5af22f8897c234a43ed618dec21cc7f6e4467480a8fdcbce4eff9853d07048bb0066274dc69ceed2423e693096b118211350497f1c6fcbef530535385ab0b0f9545de38f58dc296b2ea434ffccc2123f73127c5c49c554e7a0f4c282c9ec2c78a8af49258d6fc688f47b660263f908b7d3cf00e8cf81f9ca89814849abc1f60fd4682e77c183bda3af34f85bf668d235e50846423c403fe0d98c83ae9d680b7b89305ebc63e6bf17407cb2ad2fb0cbb0b675367a4a76d8a19bf402d1c4f15a227947ef7aa41b28f488fcbf26465830a78691b7faf1432a5c608eeb29148b7cf85a386eacacb8006fc7131fd357cf022d15f11e6c78f6bf8e1bab23aa326022f0dc96dd7f78cd06ba830d23da970511552158d9d2a8011d46840e4621c239097898219051ad8ff39b617ba6830058bbfc85fe9b4bcc8ba42df49d017280e106bd883badaa8a4d286cf5a370b5d268441ad4ed11b1130ce4abcf2a968e327752cc6f5264ecb18326a89818aac550566a62d7785bc1941fd5ced2af450dc04b4c6cb0fb169f4899c5173faa7fd64022bba10bdc01003843610cade2859d0d96d51eb74ec2b53b4c516bd43ff3e96b7ec83fa19806a0dd5e531a5374392c1752bb306e92797a7ee7aaf5d6f5cf1ad0881780cd8b98918da2b9524386f739b4039995917a914219e74b5acc5ec03e3ef4d5142c6eea5e976cfcabd91bf9a3077ad6f3d255199648bad4b83d7ce8eac16756e2284cf9c30f878d87235daa921a7dde360c19d765cd3672bdc3cff8a3231ab9cd73dbd99fff891fcbdaa6ccf356c51f7bedad11cf0499fb03b7fda7de61fd642af870d7577a4e9a56bdd0187f783ccab59c93465cd3f6874ff020005191be30e07cc90c1ce0bbe52e728ed574cf67d3d45fb1fd860405dbbe5a2403d4d7aa428a6e9b52c1dd7d06f5cd173b283b9264c24cc40ca9a9f87a0a31336e405c46c2120e73652ec1f5b5def8d0892e93f75aeeea61313b0ab173e832daf2b18681f9722efe641ee3b465b529642efa040461f3a90a771015612dfa076d2b9e606df797d31aadcaae3d82a6b30bfe050842f808ed1919a178854ded5f51f50fc65391961b9a32a05fd4c764fee19c80937585e886a8092d0bb05a37e1412aad6458750e73521746608b870a4fc17fb73591de460f36dd244fb2470392567abd1715c8ae8651b8974cec7623046a45494d9ed3bdf0fbc1920efffc08ab547d1ca2871179c027121de03d84140db2be6d13d534b7e734262102171885b6fdbb51948266a07e62f2f244da561e347910991ce18ea3f0a0e48a903ba46b45cf6c681c8a683c81d3c005525d12e25e111667b2e9211779a0f19494b4f9a75cdaf48318b893c77d36520799b1030513659f9d1b2ce72dc287bac0e45f5799eda24bf8fe4444c7812e01901fc187ff570f6d590824d3c2f315ac3e661d70426cd6413e37935e8affd5a3d96e351fc419aed465b1dc396016f35b7cbed3f66c783dc23a86b91eccc6e31f54ee96e9a69ee8ff778c196f7b007349a8faf169a1effb8f1c4336f83372814933c5c59c9e49ebf411f749ece6576ab8337d2c860479f81257326d4976e707185dba3f7458a88d2c1a7fd96c16c16c9065042dbbb85a27f8e8a75849a487fbf0deaccae736b2181d45d6fc417a15bd5f90e25e7a0cfe0f9457980b156c8f37c1052af1e0ab633cad25836a3591329ab42b961b4624bdc8e6ed872a7b34a5260d80902f9bd7ebba1e3c41e1a1bb91c90b01ee577583f576b5515986fb70430ae544fe8063404931fa809428474a41ba5d9797f9336711397ff7ab255625b96128cc17fa7c79daea80bbf3086e67376c6f6d61fdeebecff534ba3d68cc9071ea6ee79952d1336eef83486434f4744f2cd716dcfc8274142a99dfdc572d79f18dd956d4723d9910c7da6346c408d3d014d0ef89a802b7b0aab3588cc076fceb73fe0d5bdbb997b965f53e1b7436a9b4e258634dfcd09d5fa032519dd98b5903dab68462afa74739a5dd6f2ef9a2f1540783027c0e5ef14a44ab029df010c623975d5ab011eacca244c018d573c89a6fe28a19055e2c65cb1fc9dd8e462e8d4b8e52a4e5dc110ba21f6aca5abfef688e1057197b9ddf5d99a93552dc0e6c07bbd095dc2238a0ba5960d85c7372984721e90bae47a1bfbce594042c2372b5f32e97a39f07eeda5f9ff3cd568dee26f868db20400536667c070befa992d8e5eb22931aeb321ac203e13656925dd6bd23e0b9851e6b917618f9d3a8fb6ea63cbd1e366fec79aa0fc46c0fca5d5fe5c84e49f150026250dfa3a13806f99b645e84d2d7d69f4c75e1a265cc543ef73ee551c416ae66289ac69a92b7c3fca32c6ee0aa41eaca20d22078c4144ebc096324530941897d974b945854fd850afb2aaaef71bd45c085dab5a8e8106dfeb4edd48c0d415c5a75b69e90ac4ae23eb7d098c970c015bc9b80d44e87f09037cbc6194f8064de985bb5a0790df0329370bdbb4c3546cb727359c7e1b88a90831d840b70d0b9dd0f0d73ab191fb5082e4f2ef21b6703e3a7ac141d30e7e047795ccdf545e1bb12f78fad2314376234d982f53021283b389e1a45d27d45de45d9847c9058f7753fd6b6b985d9af4ecb86aa71ca4fbf466b9767ccf61656ea1048de279cf0ab6831af2bd93fd79caa2b40dec6ef021dd168d55ecc720ad0680c77d7c8f6e901c42924ead6d7e7e27f36e6d306e909f5112bbb1720c41e00e83aa10d35f0725542c5940ae506213fac7bca7b7478a4d2302b73fc83c1d9b62b5986191140868d37dc398f92dea3e6d946b5fd8e666b7d151670a92306a6397f0c6dadd569ef1a7974c0e4f2d6619f3d312a1a3fe58886db06cb069132ac31f25e67c848a459fe76983df1d998f9ea840eec9b088f486e2debff2916c820beb8bd00dab04cd3288727215428f8e81c520592c6819cabc869d74ba25afc65e03e6d5566ba608501b4d2de776a616948bd8cfcb5772a57f403cae02a3b1f4397d018c92201aae3d058fee954a467752897b0a2fdc18a4aae86837e228d51346eec7de85bd7aca9960a4a6b8d0984d49d0ec97c7b6618c05c9a073f548fe835b27b58325f20b139a74d44b73443e45173313303d5d047b97bedc071ab157cc862b216e45247612bb29f925aacf09f880e2894053ae25f2de6aaf879e2dbf0fd1c7b8bc05f2feb7eaad8ffd7231daca61fcd89754c3caf391914178096bd657137d2c985e8efb3b80536924a2115a1734692c887f1efc5c1b05f9ef876dc93ffe185d06a393478cf5553792215f8d17e3de0998acadf35721e74d8792cf4838a6f7f7ea686efa4e7de6188af552258b35cf160e7887a4a29a8c42980d26f0534785b0aabfcf32640caab9b8bf58d6a45a9cedff60c399f5a5633c53701ab56d22ebc969f4a03d2d19b9fa5e8487628316380529efa44d7bc24a296a6e897e6ca25f3772ec369bc432fac011f602f41b6cb03e53ff85c85850be6ce73c8647e3a16f9128a80372e16da07314e465d4f4398cb33b601ac6542ac641b48a56453c2a0129cf99c89087ae089d91cde2f76076a67cb3c1cf880b93c860a8847cca6440012de4e9ca472e10930510c0ad63843fdb08f19d5504210bd61003a7800200ba77dd55ac5585f9cc874d9e51610742cc0ccfc77cee53d41a961b1f5b0258498fb288eac0c25175ed9e9b6d8d98af36e95d99ea24735628cbbcc72b57ff3efd48dea6379a952b3b7dbb9d26ed2bf9d4be762359d538ed96e1412a30f6c09ade1f76ee1bd62e58418c352c94d0ba04c7cf74a01f230e9d3fdd4f8f3604a738bf6ef09bf044de16b722477be9339c7d85a5a63a92674ad95ef6f6b6504ca28bce0aeb8594443018f42a49ebe84326b1a51b149c8b6afc1dfd64e5a3130937e8e0ece7d2fbc7e0c2d718b1b3cb150bebe53b1d4b962c900ce57654bb5f2219719b1c7f78814e4b2717c3cd0b3d0cac04fe93cf1117098716949aefad5273225fdaf01329d69729cd6b9c81f34908aceb49ff52599ccd8d65695e342ba4211d3ee1726886e3c7cf5e45d9362178430dddf73741b0661b5d708880c6919dfb5b436c1cbca25c8b300f1d7b5468b18a4c725aa0d1a6759a20a8dd20dc96b74b5a4d6834ece8f4725afda2feca43ab359f16766b49726666b897dce64a45fafcbf864ab4d0f55347fa2c9f61a841f3406cabe7a653a0bb7def9eef21acfb9461d36a0f76da207691a5f8c6ba5ef5c5e954e576f862eaa1046a9e277620d44dd4ed8fa81d6de79b20090e96e4d460a826a4610a6658804f038dc468a35895c8e06f2206f6498631bf9d71bed7960e9f172cdf23cbab7f6d383b37aca561a65361f084032f74d65bc2e65e59cf3927a1e3cf1987498452c1f7ae3ac71c953bd6859c6ae0974a65b46311e5ca1201ba4d60d293500f2c1caf45e24c98a1db50771f47327b9d29c7af96c9dd2c7c16cc72c82dd3c6e3b28e8d701b983ca815faa87d1e2973b22800f221fa0ec85c18d86eb86effc006350262aa5c725524284a54fc8d206998d9dbcba5b541d7af509f7f95ede40274e4b4254fa662ba2acf64052cfc81d5364947e85696a4c8222b034eedd4aacfa0c62ecf63b49d2d834a6797ce5499a494f4ac689e5eb0fc61181fafd9132905ab2b5a921546c6f902cb2db61d0c33e1e7b02a599806b069b3a30de7ec7b9c74ffabbe22f6370daf11218e7698a743a5d881ed07c86bd1569303c3ef572aaca6139b576c18da64d805ee23111e319d63a8f3cffeabbde412b9859db376dd9dc8029b78e6f93e5dd24e7b25cda4c624fb7fcf51ac98d24d45a3fe6c2c18d76bd7409ad63e15ac79a2f10281f9c904d70f772b579570c496a8d0137aa75a543ff89c9cc9ca785a2bbd67c29d6d5fb042c3a5fc6cd410c85f2866a4f42ca098f40f196c71a50607f3d7cf295253bb6ea5f781c579e4d3275f0ea815a96b4c8f5ef076907d7070e149f20ab516124fd3466dffe89c05e0bdde294bf3993664e02374177ae6918f970fc702e5bb373ba6eb205469a4b2343e257fb4af5dd0e673e71d023ebfe7b17df7be8e3e6cbf6b2827116aeea5bea35e8a1873f390e367326d886ce217cd18b4a4e295e7ed7f08b188f7903bbf14acb05662aa69ced9e156e721e936fb36177a7e4f2fa835e17ffc933b1c079a4f679f02e0287962332de6a73ea1c0528fd0ab84ab51678f60714881f409f4fe782a32c478e48390a841b8a11596e3ab4e02dd7562fce096844881ecc656adb49c4b3c9ad636723a38bf0f457f8a65454ca8752b8b031c9cb4b97d123ae80436af2fca928aba1bf6df67918c8fed12b2e6a135fa033af8879f2443b5c774e818ba2ab002cc2c40cdc830744f7cf59e1c0d5efc0059959cd157969d6f54aa1e7587a3b80c783d8bbca9d763746ced6ffffdf532b6665936c296d002fc943edb3639d6fe4f9d4a79ac8f388418096f5d5b78d7634c1965befda123768c2d3468fbac1f188f4a69aa0c229c8fce4a16e6f2854434986395028eb5d9d9793e3e805dd328f2d05db5d866e6f197e584df2a49115e6a46b8410953abd94bf045f10ee4f323e99605599a17c03a10d9ce417310d34fcd947e4a969fa6015f16b876922bde5ca9a3d9a960242ab8f2e122bf149fcb34d04eb7cee3f6566f9ca51c439a2adcf7201a66fdbc0fc18f8bd467a9b76c7f8c86ad2b8ff0238b89856327b629e1ac000fc780c247830ce54b0ebeebbbf2cad1de02e586426b73d9714e491df1e4cf843c2f1ad91cbaf9558cc55ad04d157bccd02896c98d54869d68246af54ddb57141dc8480f051f21056e74aae11a3826d03bc53f9fa256ed8a85be908064b00bafed405f0000ded23397e9747280636f5d48abb1307b6fb3c2206630b5c00cb355d619999776b3c74bac4d36593e533b50f2504a19f7f13aa922e12dca12c96b254e52c5af6d47e6032e7bd0ad74618b066cbd85b35ea739e018a5e93d6fd5702eb5be7aab34d80a5c5413fbca230b9dfa79ebc682bbf8f157c3961b30ec9805c772fa705adf58486cbfdd80f1037833dad4ca75b258153aabeb6e99b75d583d99e2704ce26aa663b5635e44586336751be17d7f995cd4589686210bc5c9c2446d6f560b89aa595c61f49e775352f7141511946e0f0f7f6e0bdb8180f25553f318e067d25deef5eade568fd21622e273534fdfa8ee7702ea9907262ed72a9e07edb5631b54d3bbb5122a78385e97769630464e2cab33a56ad0cb6057c9659e5fe7ae8d936f25b257d03a9fa6d5b955cf8b60adfd3889c55bde835f3c2929318cc9cdf36e2612be2e0d2d45faad2f89abc03a3133ce40a60d05cf6bdb347140c242c0cf8f45c7229cfcfe7317a6e001c4931a74915f045bb1f8e2ef789a6b3b154b937e7d0bf9b6940f06d108c93fdd9ec96562abb63bb4414ffd7d3f942ed8d3ae477274b8d6cdb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
