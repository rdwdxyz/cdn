<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fa55c5ca0f5d2313561c6e26339ae34d5a19f37cceb438812d159ca0efd38343979a8d493f8e77755e286bf9b54bd17c0b6f8664d7ac201a0a6d370b709be24e0a2e484b5254391130070e67c02319dfdf3880ccd55d68e3eddf0ed6975ece824083047fc7912e5165e490b56228b042ad724313783a8107f9de3d132517e5618cd139569066238778191c88e5ce35ad6a84ed5c3a3bfd7f1e45037cc9a3cd007d4840d2cff660e5208e122ebfe511b0b037e596248e9951717b2ce866f441912d45607718b2fb1637745bcbb8aad23d88327b86b1c7843e786f42ac18207f445cb62022ab0c442c9aa90fa1f5e3a3f56c5dea891003b99bcb8429be459a3fbd787e0e1df8978936a0a7a48621aa0a6d6076cf86f778cbcd669a6bc8eb5adc3e616285a8a6e5640702162ea10bb4034a6382d785eef78f3f49d9f7f62b0f217ef964053214a601160821e8432f5c5ec248db03d7dc8facf043939de1301843da2ffbb63298ad9331e957b47e435b951f83a034389ad5a373f404f68d1811ae411df2ec89f1c054469b4b52ab8b3fdf62cabf8094fad96b6d46b10622958c0609ff120a598a743e63f259347ee64215818fa5e5cce6ec6e164ccb4390bd9681f30e9aa111939c2efb6a9e18f2e8e23849682a3b5f318ea904fbbfb6237f26da240d9ec93e15d3dd9e8927612ca96f70c7236f5debe2512bc2203bd22e8f8ce192acc188bc7a6ef52139fb9a60fc4dcc1bee3d470daebf554e056f200f255e7983dcf73279eb51d071ccc85aeffb2540bae76cd4e60e428b14826379ff324ebfedb0d98e9e92940e4a928fc49b77e39ecf171e9980a30aadfe5c0ffe9fe3f1cf1c5ece70fc72d1bcfbdafc736af03495573687f4ced421681daf6c834b2a762728e32e978f20938a8cef01b056731c2fadea804e9713187b8edf618a7aa31b826680e74a0bcd04d3937229965045402f880487d935e5083b99569c38750f39a8b190875187049fc16f8a16c79f275d3970174e52a309078eeca4c21f6a775355916673af8d6233a5bb1fea434db4689015a1811af359f2d92e09ee1f31ba55e64af66dad236cd093693f8f6ad08fafcee579c9148a8753f206bf7339df1df5b9a63c0adff08adb3bc9b7dcf6c49f5ae69f59e1a54176816fb3c03d86d934a1996bee839e134a6c7af52ff97099805ddd4c14bdf94c2c955f3fd15ad9d5bbf154594af5f53fed926c19e7a07c67dde761a99081b1a924ef64a0938f263bf78cbe12ae300ffa2b0b3601dd5dca82fd17494df79ee4773e80711128a6597da35cdb51648f0ffe5084b4927254fe0eccf8d1091b9faa2c3b5193cfa4dc712d5176b1306b408031bee4001f0cb9ceb75ac3f38186a14824c68d048f264f43acb6b0f4682acf2a6f745fd37206c61696291f32a67b8a4c5bf0d584c9afe6a3b7ae5a7f3faceb8c703ff90e0b00ea8afdf30b78bad5b802add851c1c7d4afb9abec76e2cb694e60fc917949ff0e76bab8cd96b82c4c2c67dfd86f91834487981629a227c8eafef2055fd18f1135c450053cc0111a15dd60248dc4c85946858bc9716385a5b2efe8e08eac13f2ba81b350fe1e46ded265bfd2230b96bb87985194d4b55b36666067e8ce8af82a15059f7a520235b8b323629674924b7dcee187006ae08c220f35865751d3bc9000742e6235d0b0bff1220b3731b132e8face32f4dfb6eb023e46feaabf67df458ed53958dccd7aad1b7c5770297eba5feaffa312cf3dc6998284beafbc3ca3fb6fadfdbafb6e3ffc64a461fbe929324a60dc399c3d16292636a4f64171b2af2854f626e8eb755d18841c54a3cfe40a331d42feadf3ff92c8eaf7cf772fef5f55061c2443ce39aa148b2413083cd40d593ead527a296b7f62efbce8f7d97005d5c5c7131405931e436e7cac911e4c61a323fbc8ac0e520ebd8a22e5e4e5742eb2912ec5f53cb3fceaff2aaf9fd31d9217db9b46953f7e29389bad27f334e86528557097fdbc01d90ac7730aa690c7e516bae3ebc1c3798169cc7822ac6dc9d3d6d2dcb62ad5ccf66dd2afe16d7f60db855ddcc3bc1a5fa3377b8031e3a4fbd3230fc5bcac9d22eb52cd6c1ceda4430e41f6136bf01170eadcf91df6399a8455fda9f9ddcd88d78359e007a214b564333fa7edc7e4ee98360ef9487171bdd79a220457599acbac6e4db5d19ee557d203715c0081dc0b5f72fbccfb2eab57642abee5cc2a338717f15716b49d7794e5286f8d56ba716593ea6a8d070d0cd1e7b3c8db7a1bfdb005a15843a2a56537dc92921ea198785a1f3431ac9dbc250821ef9d03d2e5708435b78aeaffc9c18686d5bcfbd21db7ae8254e0667b54661ff48d4410180e8b595372d78699589c135b781993c5c2aa575a7220282701ca387e61ecd8880e5c973a21e9f25ccc0275631c8273f24cc3677d63c801ae7b9eab3d2e8956c5cf47daee787c4c5c74259ddd654070dd283b5ade41e295f013d941c8d24c72dfdae0ebcbd610175a2903dda66734f767d45d8a209d7b7ccf27a26d15f0b35fc2c991a9221a35cce91c84e6714fee42949420b842b90991d504f866e62c4b7caa419796b6dd84c5f5c2dedd7fc7626a2e69595d2412b25dbf99d6e1b4dc4fa47171b96a228e6469205fa8528e0f04bcc2f17f1d2c6c9975047cec8dc062a05e1f7041331eb388362e17fac6c9a5ff9b9c9a7bda2d44aaab22c22b67488d6eef968bd48d78459ade8a660d7c8ebc3bd1a93f6ce852b37545b8f725d99a5c2a71fa24ca31e13c8b46902939d0bc4a26fb0e12c6fa6cc4d4308ff82be2a5324a05de194b1e949a03fddbad7f66fab1a612af75b44a1f6924a2d454c2bd5d50b5829a7bc519ba6e1fcd8d926ceb20c77127fcbad39e289f2b39a22886209daaf347d885487253fadf98db1fb2da7572440773d31fe1746a2172dcecc39dca74bea33f5280660b3573a2771e58829a0f55d8fab01ad0e0316d19e9b9a890780ef2c5b2552d0d8685f8611de15a146985e727b866ee71f75d973bf2648e950c30f4598e22274b0c47e1011d59f2b836895f627eec0c31dbe469f64ac40b30d7dfd458045b13938c2ed8a040f525e98305f3779c806056af6e4cecc118688329048462e799a3e5fb3f3d5f8420429f2282ee9922d770baced2ac6bf90f23fcb34c2ed51e1baebcffa0de70b9ab4b876c7a35664d8721534c19b88b07e5e7bb23e6476c2c7bf9e41a7b8bc905e9462628624243f6b92313e4ebac8960a932545031318aa24bee083515e3c28df734ea663dcdadfdf4af462bf65b521af7fe0dbea88cc9003ad49dbcc995362db6928a7923aa1b1c45bf07d02e324e69c2d484bd7c932c00eb29c6a59edb4de05c74627c9a0f8265b7cf40a008f706e71b7809f0ad2affe6441364d8b69d3724aacbd6cc4c6689e320dfdf9089bfbcc45bfe8642f54bdce6082173043bed9504932a30db61e40063c697237223835d09786abe273987696abcbfd76fa2f30e253097826794ff0acdb8234c477b07562f09e6c0eac7c3dbf03b8e496600a4b16b1503ab60e5709190cfe66cf3379e13c20618f17de6bbb0aab3ed91a97645a820bfdd5dd5a6840a68ab4e5c36d9bcfbee89e8a389776ffc3cf483b97309319894736de4f75da177f739453897ea4a49a4e4e2f10f29d998e9f314308994ec5f8a2d572c62723c4eb44be589ae79fe215d63368b84df73f9a5eef133fc5199475460ee03bc38678fd7fd3a3dd041228614e35634b4dcb174b2c2bf13b1d8db62169b45519aff4d301e520a25c798d7d1f5bf5767aa4e63116c22c5b60b2f6c8f4fa5cc2793077fd98c3973203fe011d100e2336acdfb3e56d155abc89ef072962b9b4280d752761c610011d6c47b61b5822654aba5d1fd389992159b897eb38c9fb405c159fb23070f253d9e527d0e763d64a1b9864e29ccdbfd21d4dea4cce950f195c03bf767ed95e081f9c31e14944c680e149191d933455bbc77b6664c3b8695996c54aab305292c9869c24d8b80e564f01cc7ffc5d39ee61045b3872e8dfd198d66e96e8bfa2818492832a389818ad11fd3b17ffcc120ab77733552ed21955f70618b94047b571b8042406703a51c6c35e46be2ac8ddb8d14992583a470ab7cf05284434403e9571bb5df889cbc114da53c927fc0ed678f2cf0cab814b89efc38a90554e74ea2f8fe173d8aa883099bb9c671e3498590c6d63ad828dd82788607ed0098dddfe005f467e8b8fef8731a903f2971b091e6cead753f8edaf991d7333df045273fda4e2fcdc77d561338528057c06a424559990d86104f855cf7f208a16273eedecbc9b8cc6eddc89353a11be364ad3dfb84ef90ed73b91ce394e4c0ce73fa87042549a94bcc41410e7e5237d53e61cb5402f52bbbd3ff944f76bbf61689d0ee5e22948c87b2729392d8fd8a47286ae9c5d4f6f327fac6a5aa45ec8643fa0a39cc2f70c04b86c100d55d03fbaf3b31652eb9b2dff554e450e13c366a792ddae87db50db02ebf6fae630a6feae9e9ac9ff1c95aaab3104d8948f6c604855d10fca91ef440c9ca4bbc675750e5aea656922b14e86d90c79960db859576b263034ba8d247cf977bcbb6d09663865941e953a38e3d0bc773068318908ebfbbad688bbde94d6e38f2303d4b50fbe58243250b8e902a3176820cd655899f608ac8a790aad1a4b42439fc8f8a4b67395b86e3eedd23a82d4ccfba71bf9f24743d09f208639e4917dbe7c32488379c59cd6e4d345c7e08ba210814b2f1d1cdb413d4fcc70f992802da349b901c74746a449f40e50766659c3bf6cb72f5a1fa4fbde4db62a0969a0a7739848734f168e154fd89d754e348cfd36c86bf6432ffb8dd5e6098b8b5835e1ccf9b281d81db74e32f305037e6025967cf60f2bb58bf976c39ac09410b0a546a3867c4dc486e8dab97c47e702f11330f2d559a80fffbc6e719081f5d7b7013430c0bd793e5189630fff570834aac637587a75dbd51f5411de00ded709ad9785284c43f9fa281bbfc15cfc794e931b3f13323a981f9e49f28c0b2b4fb241674d2ed7238e89d0ff11a9b3ef47aa8fc3bc752961f3e8289e5fc11f1c1869373751084ab3123e21717d853e60eaa4e69135583d684d3b9cff6b8f8d184215da98466a5f6f5624751406589ea2ce256427f1088460be002e3e27f51b69514374427929c4097ffafa4d0ecae4e4c40607c525b20df40aac4d83587be48a77d7ef2d1d123fb6c8b6e04fcd328a567509993e4095dd390a0014562c4e7116c6e0d7ae576f63dc59e3a36366280931da55458f61147d27f8308c369279f0732a6a8665531aa775a523883a1ed2afb720d6742f84a8db7540c903cdd05e271caddf93dfaa51aa0945408bdc85c100b4a58efee1dcd07e3bed24aa2a36ee85e74c5ec296a1b001217943cb5cfeaba9de696f69a05a8a51b50b4338ee9b78cf232a9f903b0fce842a2b11ed15078ab9efe58ec40acf15adb3ecb1eed63f91d845f7aa7696d5162b82ffee1f3838b70475865221f8ead7f38fd615a036e3204f267df97e0a6ff53bcd9ec35e7735489802a6db48f31924a336396d9d65dc5cf942214bd559c34e4684c5e0a2c0086d5f6cc6b51e51961cd353a3c23ea446b3c0325cea25946adc81122f5458fdcf26e44723f82a30d3dfd548cad356f9c10b6f70d5c78e410e3801cb8fc962a1b68e67e73d7c45b1fff01729b553bc19e7235a46530e79a7b74a01e8287c2aab2f061d503e9675c0b3c9b2e1ef3d78de5c075e32ab7d7ee52cbc326774c790e75732fee6742f6031e46f63757918e71cf0aa757862a4010d31aa5eae73eacb58bfac89bbaf9a6fd76cfb36c1a06254ef021fa6c9df1b3162174235eb94b17675448b47c33dd151c21a551421f42c541f31960a7bab2084a37a11ba74f0bb7809e5d0c7c85a1de0bbb5c7f705e235c8c9bbbb759a03259f84bcb994e3fea5190880f42d18436a0f5accc3c862897306be4361273f54e41202cff150f762495e0c6f247535ba37b9be55bbb6fadca8fc00a5bf6739d9b8aec1512777143cbb1b286a0ea2acd6c78c24f1d45f57ef072c7f8b09dabe747d770a4338da460f1755912de4a16ff0450ed64c1e3816947340e7a61ba465c28ef8f0a83a963b7b416954a450995e414eca5f1473a74e6c5393ccb95e2646f6dab4c7c0cf729c3c4d7f1752083ca62c5d6f326b7f0bd3eb33dad49cb079088d483ff76bf6fec2bee7bfded7d11ccbc69b6337ff57c33fe768925d5c9f1982bda34364a9e867088799fecda58922d803aae9e74c240504e8a55a3a878045b244966e6c963d686570906d5587da70a59a6d813caf692caf16dae31ec31afbb271e85e9175925854ef70f21b84e1d8866c4323fc01a96d943be72ec7f5d4039cc25411cf3429acdf02b37c76e2f10359a0d2bbed6cd497118b37d3d0dacbde9e9093281900a8927cb198f5da7cd2cc545b6f13d92f2bd709d7d0ac30dab2553b11e978951e82e6111a372fcef6f0f5c1d3d4c5af847ea7806566ebf524e5b163f3aec2867bd38f9191b323df8c013f1d31921a2fb5a05d74de1db37645073e8bafb233eacfd79c919b478f3dbde26eed977589ab62fae3e1efb35211571ccfeb3a66810a7eaee0ab98b0ef54c8d896ffc4d1eb60244541883f734f7899f2cffa2cddbc3dcc5e651718bd54a95ab29cd3081e5a38bd5c00ae4d091bf03cef7e05717766beaa17b57cb3397fbea83e7bb891a54988cc761307ecf0726c1ab448e243471e575c78b8f3f72097cfb721cbaadef6d837235929dc1b4a8033cdca4e46f21de9bd4556a829508e6ae48b5d8e38f685a48143f7c7a6bf051ae3074ee770b392d01b85f59d36002dfb7fcd518b9cd1c7a297895ff929ed94326440d63e0f5f97dd781a48573d82d7bcef8cf8515b88e4c8a5ac192770693b2c6f5fed0c85c1af054280bed838e12bec611f0654d156c18b2bdb6b5bf86b68d6a4ad073c460103752db4c2387b71535a2692f6e7f53d76736e4c0fe11e9e7059210a7b75bf6699679ddba7336f01a885888167ccd88d442a587ce758ca72357643b5a7d9dc8ae6369e49c80e51845623b619568e68b3dab5e507666d836eb2a12fa6c08f98b37f39efb75f06c7398f5cafbc5cafcb64ba4ad1938d8bd4a0243a7d8121d4f63664dea5799e6eedaa9e69a3a151633d90629e4b1fada820032b5cf30ed8d86e220c892ed3595aeb0370386629165827b1088bcad74bb2825193647af8604d41dd33897840a1f13140804fa1855059ed39f397934358a7e11f214fb02a324bbff4039e1fb8a4e9b8302e6044c382d17364e32fe2aa4a7334756c8d5c331666c84f9d3ebabe692049ecd6ddfae24cadfe3ed52f8a6bdd189ebae5a3fe81b7735ace1e6c59817e2bc58f73a84f5079ede38b76f9d94aafd7a5e233476f070d43d214c9be167deffe6fcbb222826bd0c331fb4df255c5787f8a84f0a83c9a927eaf70fb26bd680275b459facf0e968759b6dad0238b58f65e3670bce8cf07fa448208e39a39d7cf1a7b4cd848a129e55fa8fa9911bc2d45f80dfd33c614f168edc95248a90814f4e5161975c235b393d3c59a2934175580c018fa6d1e04012aa0fa0612030c6b83c46bbe0dd5a82ee5c5f2090b6af13fae3772f59cb773e6c8ce873838f14b88b8b7be6c32cb207eca3fd479d402ef190ecda96f999916bf658b570042d4d243933f79d339c94f3c4fe6d5e9f031cdd985bb0336ddfc3a4deb679012116197fdf20d445f506b11dff189a852c72df2c1115e87907eb0c80b43359207a6b589dbacd0c4ea5200870b4ac5f1bea6962a7dd4fa4de08d35fe3dea8425b69f6635f76d1f0dc9fedc83f2622560e339015125632836320c81a7e5883fd16f9c6d78675b53b967f51eaa125cca8ba9387804b9fa752ba1ba3d1357061088bb02bee76e91d548a7f48d22e07c53d8cfe99f8451dd0ffdba90fb7a703e68d31ad52f40ef6b818d122cc242e9e2d816f695f61f67561cb84dd3c48087c1c0f71528892990089c3a2d573c465658d05efb7e1ed9f13028684e1484c63c2256ef8e51cf50df8883c91cd74b120e9ea4ceb69aa53208de1b534b370f66b22c71eeded47ea0a85142a3d2465a9520b15d0953936f347d7628f244b0d20189fe1c959d8054b529ef1f8cc2f441a21e7c2baa06665c765f5fc67b676024431c4b8dc63e62c246c4713bf1de83144bbd57415de7c09356e15c165036706db5517269b97d5bd4ca4d362acc1595614934b64db4e68a2ef2777151abe7c701ba5abd8c4d1281145b872991ecb115552372c4b0aa7e77ed8d33ce81a924777b6db61586f0c333061317d4e8f3eaf768175f8e11c90f1417a9ea339580ca7d718308ab239b9df5949fa328a0bd262868ab2cdd93ad66a02f2955fc7991e2ae7a4a3e4cafd8e8576eb7926e4695579d91d6e847fa2b4b227617f2cf7ad6922007628e92bed59cf434e4f767c0105ed834ca8628087b72a40251079df48de6ced5266c1eee550db7eec5884c3a4ae86c4d47bbad878ba1ad741d651cdd3eee8ec1344278eb66d7019687c35a0140124bc3fb63bfd40f8f4dbf4b9c32f01a48ea2e794755cfab8f17e40713b743f88697d6d633d50bbd590fbe53a1b3783fac14b3686a84a8d7db74894e6b323a1b5b2bdee948899da30c6d9d9b41acfbcb0e6cc6c81c42b034e0aaa574bfd136c15674c2ef26c9c17bf29bdb9081a0b792f0d11d98dd6a6cb4a9c666f0e1197ff4c6da0d5216e6de50fb81edef713915e238450570fdfbcd57a00a48a65411ca08a35ef52a8d76ea8da5dd42fa47b2611a516e5837584693f7657cfc949cd65e62712d530853d8a8fa6b4f13680bc9474fd6e0d42e020e51727b197e85cb5de3b27bf14748c2ae56c753188789fd0dbf34d3426c01a4252a27631d1b2df0553012c43e76cd6922f1854261de3fae56b8169e95246120fc5ea9e85770519b211e5bcc80dec8ebbf6786678818d6a8f8343214a80a5e510edda992d3f87a67e2d5bbed179bcd4b46b960f21ed7ed242d3910149a604cae278cd511c9a8aeba90cf1ea80ec720e33b4f638ff41e7eca7f6c8fdd449530f7cb3283dd6c06ab5fb66516f046b1b88ba5269015099c0e796d3ad47c01429c38a756a060a348ce772862af4c5def600abe4deaaaaa82556ad3d5115bb60d83c7c1e816ec666b0326005f71b2847b2df25021de7b5b71b57dc471da0f97ceac52f111cf04eff90843b7407fc93e6c0558d0df7026695eb061227f1d674cb23323a3903f58c57de38fb52699c0c4f65260588ef4202ba2882fdf435eaad296dd1ee856f71a9016439a6b3dedf68bf347fb96f422c6676c37d9b4d7164e815953f91fe22f888a8fdcf561c9e4ff64304bba3f61161aea4b45d432996f5b81216c3522d6224a1d07d837243b925e6f45fe2d8baf1f06c8133afdd0f2f168b71a22c60d3805606eafafa804e10578becd4a8150c1404372676cfcf82e5473fa42fdd03d4b5b968515a78e85e09b7adea07980d90684238986ba36fe96db517ed1329ba58f3a9e6d6cc711743379b1c662862a11ef65c4018b116573551e597829bf39f7ee47d29d41f5dc2248090df1a0bdb3b8ec1340daceec32b418c7faf5e9b4d0b08722b7a936aafb69d82300ddac7b12bb66944e81c4851198cfec60506e0529c5c449c0476c0f9f1b0573595ceb514de287cd82b9657da1d12bbf8f2c4147050c3e0184d4d1a2eea2958b55d6ee6443dbaccd022d56af2cd4d58e4c2a15c26a89bde6444a5dc21d96fc903f77d69c37db0dcaa7dfda1ec4363e00674c6a53f9aabe4988573182428c66ddb43db0bd07c92e022c8792f0db222a08f193b18beed02badafd0cd0f39df03ef85b1ac3770e94150df7e766a274bbbf2a324c3c79113f8362fdf238029225506e2c6d8074173a41ef7d087fdae0d01dfea6c1bf897b848b8475d5ba46f672651f66ca6b6ccc9067311bcb53959b1cfaaeb218d92dcf8c486b22224cffd04fd753962eb79bf912b73e3e8490ca86aff5c25c1000314b120e7e3fe096f94959378f37900d4b2b30e0b5f904fb79e84413d71d7d8ff558d5f5f7a9221d298f16e1f3e4e2b63eb4716072b4127088381cd60218022b4184cbc6caeaa1a46575c37f52bc4556a14cc27516629f8e7b04ebdba4e8a3601856b1c86152542bcc38f86f665647575ab1c43208749b944cc82cae1c50e64770ff6b03a11320a6b1ecf3d85a274672a3572435eb34e92384b512cca6fce6db2ca3939647ca32d8887298ec28167ed773e0432722e3a522f483c6c194cef2a2507526d288ed3ce419a0debfb30f416098e5d5baec3de58623b2f1331f6ace28adb970eb47ead17df2160d29170fa2ccac3238492fd7f7792650221918126323110caa87e7fe37e5412d30af4fba148dd761246f660ae8b3160f0acb5f9bbc4abd0e296d7677be43cbd8b18e7645002aa085f5bdb8e1cd8d1cef4e66f5bded0d6a5a5c61d24ed638e0826d24f094c5ae307fc8d29c9f0f7e0d7dc4ec17c2229917458f0bbe9e2349b2f11ad8441da066e274ea897cc7fa213b317ccb4e3c00e637ebc0cdebc1262f94ee1474f9149b15356882ef2fd824d515ace2e86141fcefb52222b2ffa67d241313378b560663c5ec25d26a157a5cc1e81bf8eb034b8ddb35e5310ae6e40d5fc0032409c4c67c90f9092ba59d6465240f822064ec087cb8c42d1a2e30c57292047f69ac39e7527f18774a8a756f39a5aeac952361c3a886829b1b0863ec62607b8098608a2a7496f4a5766db0d5a595103f00ceb888981913c39e855028d508c657c4f7876630681a006b4b6318a5e7ae29e9f6346bfa2ee00170a9a4118f0c3dab8ed76681d418bc3344f434248f0e41be10a58806253cb1fa0529f727bdc76635ecc05f95f0f66639f39c70fd258f6923d2e2fb383cd1690e109c077b97573e4241c4d47407bdd502d9c284692512076841073944e961a4b18a16e3635259d1f15f4c1c1d996cd7ca3bd9f5bf9a0e55d75b22632c0e16fd719c49eb72548c702696dde6e7603d7b5c95262212ed95486c806241a8de3cc9acf83ad41be6139b87859654b094771c22e5dcc19ef47a86f9468317871a0024de1b8333c0d5741f0d0758120b5d275b96272ba13536c06dde1068b13b40306caeef63047af8cbc84b72bf20f00d0aff556a99a1ba8f44ddc7f0b4e04c887e4e6903887d987e1df52396626f2c67ba6b87e8172057412f2dddce46efa8e25da52b2aea2563c3b9df8e4f0f7e4b3410f8dc1963b49804abee527aa527ca0b3840f3512d487af58259142c5fc348fd27f3327204015030eb9597d79f2ba9667ab5c3876995b7b356ad1a5b3951f40c860c1b093b60e7534bbee0e7963df1e164d88f54b13af463a635a236cc2cfc8beb5c057b6abc55e39a1e377e5214d2f8572d3bd23df0bec2ba2c6cff29e5abf845b350abd11680ecbac44f8db6f9910da915a0c6f48f2c5555f7b9003da9d1c21218f53069459950ae1d0e6cc9010005c5d155784e56b83849cdc151c9bc3ad916d91bae7b9733bc14e45d8ca578e1d269f773323a3e07a052e68db2f7f2145f3fcbbe26913be63200747e2ca7bd68bc60b2fce46e07d7a1f9a663b01d34fea354ac492b315047e44e0491134cb90d1be2f770c626889c79df533233079c9470411ab711915f8bfd7aa2548043fe9ad6b2f900ecb90e01c9eeb0b65635722506115bbe9974fa707d22f4998b0be342fb104a0411de59da3a9cfc2969dbabce7949bec5124ec32a211e7e490a37f6d4e88f8ad994f2b633c0f2bfa1b8efa7f8bb56e958afaf8cb744b57a6a477cfe7539f10ddfefc9e1b6713a357c2de1493ad2cc0fe6274854a2938ed56e53e652e0b5db1a42f1efbb0bc0db85bb8f305e0960b8177aa65ba306ff9b20e11c719d0fd730cc578a1759b9c33d7be8c963e014976ef73e5bfcfd3d668550d9ba29fabee529a58c88fda119a0a7ddf0289ad47b9ba89a93c00d1cf706fa18622e6cf9933474236f7a57b256b319aafc33156259e63b52498092ed387b1346763f1a21b17df99f0eb229f5da47749ba52248e624046140c88c57eb0ca210296c8f85471e2c84a11c818f46aaa532925c46c4e4f526271e5e4e3e731b7ba29ebfd8941d81e8c9849e6a5e09130d8bba1f71fb9e1a94b011ce8df4bbb1219df7a5f3b58e40195d0349edd114881e31435d3f485d1216718dbf90a49568136af7f77ccc33a8b3f2b4a53e683380d48f13df5b24bb171c7767cc08ab506a672fdeda6578482ac9f1154ebfd920df8297860b9fa112000ff028774ee478afda0251f50a3d09332720eb10cc4c453fe739d4b8e527d0a90f65fa38552be46878f733b4dde174be67147e3cd1caa2312afe9b213c9a22f61d371a00d4daca44a10edcfbf32dd729d6271f5bec19503d7877d0110f83ef4b7a7ea847d73d9e450599fc1b5ab6999e3b3620353d894521002d649400eaec012f560e2df9368845bf85e55e78fdf95debaf00d4721b5dc1ea0325443b2714c1d1ef50006c09d01e0cec77cc308fe563c175f059660591b509d8e607cb55c36574198bb80f9a7de7f668b3d6ff52c5aaf4ef89b6dc65398b9985e80914a1e85e01ccea6b0e49e31d14cc39bdaca74f79c49ca8183baee24ae892d250cd20256df9ba540b2b00a3ce4763be2a6dd3df1ca7002ee8ea9f91af1764446a5ed94f052b1f17e6ce45ee5268c65f61c8a9e7759cc7dd614a1eb586c11bc18e012a888f6a70a2035a826182ff21f1cc1adfc77e756cd4c3e0ffc2c155099ce6b62253ac4660a1dac693ec8a73e2f9543962d2fbfe95943b43b3aa15e522ed6f249695227179089323f89da1bb2105cef377cbfe9385d0a9175584ca3dad7f1300465764863ee2e51d23825b5c138b00f21143ab4a77548ff5c6c9d252351f4e096b4bdb93e0a8f37ae89778887b2a4f685b33f57b7e85771ff3a93e5c349dac71a4cf6b7a37046f3a8d43c4f4df7135b62489c6c4366474de8c06f2e4c6503d0d4876eab4e1e8da28d9f3b1772e55901f23ea4775a0839e28afde9a5c36abfcb9c3fce8f63aee832dc5e47e067e4a744f601978cd0458a502c9f8e460c3ea0ddd5401c6e60c749ff6a1afef00c8454f995f1fc0b55f95343d2b01e88bc9c21a262783a7a6d06c08e40ecd529f504b31b9d9d20697ccb0c2e218d17de9ae1c70b351b1292ebda73339b163e2f4206b70d443b717647c2d1a43f8fe4509f8a45a0e7bf4fb828af38186f28127ce02b83e60ec3c548700d91c0bb505aafe6a91fbe0b1838c81ab36066852638389d76a46e5bba104252532d8172bc0c9df484b24cf7bac37121cde606f2f8d1b4412e8bde82aa076553546a55e3cdca1b42851ad8bfa10b7f8c7146912a14bf7afdfdf90f05d0f8a4813a564f034f4f00b3ae199bfc4481215e8fbb08ecc90bfc95dee57c7f9629e13614ace9ca8ce5fb723aa921bc667de1713e56d0caa263c7ce61f230ee5ae223e43ff31de3c4b01f481745b6c46ea8a7109e052d94fed9be4e5fc4067e6ba1a2bd09fa01eec170173ce04971fe63f36991a33e331731fe89f032d887d5d22bf359e1b04f29156246996a19c29dbf363b65d837301350ef2469fbafb9fcae73bf0b32f49c32fd526fa053bf3119edb31e869a14dc413d143a89cf789fac5f3f8e22b666bd980256d3e5fb16a8652b68920a228568d5e5785dd854f13db95e5c93e0da47fb1ad49429ce7318be6c1305e28f8a955f1740c6177fc7b2298b8052c84589ef6df4a73d75df18af06ff101f6d118b6dea77e05248b20d1c081ba025fb00f335143799f20c7f2eeac051365c2fc0a4fa3b4b6a162671c880268469944b22f58ce456a22ca67ad4db03d5a2b7688a6710a00d2a3e197ece56b34a1c7999f0c87e4dfa7fdba237ccb58a96d8fdb1d89d65be84015ad3a123d98d201e23f989c5a991f4bd176e085736e18bc356d63074392426ed35484dc3e234081e376c2ed26e83f6943d0f141094278b3dbe615fbeb196b0afd92658f73ff7cf5ffda9f2817d70ca249d0ffcfa0d87671925c5bff1f939f25d37dabe7d73747a057f5e597286679df4a73f2d7fae43c20e086e48005c85eb054229106ed8e7c0c46f08972add07d5222c3fdfd3942461e1f52a1c62c5ca75322ffcfbcecdd525e2769db03bc5153e5c03e0fc7f9a5e708499c5e94f69602270f4b2c5c232db5682e7f42a528c5729cf91494bba61e2a2a140d72912ae64a75956578a265a61e0e123e35a60fb5647b5dc15221183f1a7482f78d59bdfeefc2334334d6d65b8bab34a4a43950c35d8ec8db5b887256d225c233f16baeb7ac1f944f9554821e08aafe3133ca0cd30f45e5b3a5bf0eb2c111525ba2b4ea3e9dacdf5f4fbde62085e06d80c867efcc770670e547afa868adbc0ff19cbf801906236097ce25e795084aa066f49c3aded3f741afdb19b441e7c98a96bbac5b07963deedf25173ca344034c21ce19ab1021def11765de2ff9bd405985ca42ea70c537966772a58445db2fd0319b8f2b0eedfa6df17279faee8d587c9b1945708b0bbb2e4a950c113d0e406aa958f43a1b572cfe2f154eba3b328d0cf480eb38f64481bc589ceef5af158484efda5b7ba91060519d4391ed2a54137c71e33d86a34f58dc579895979edb5097b5d3c054221379b98bf60b4f6fda247e0ca76a9e034a038489080b8956cc71b5101a35153cd147b111317245a47acee7f7251ed16735ce2c79353ae1f485e993e0eaa84e94eac01206cfb50692012fa07cbd9590a5de3d02e6f7c2bb909b7e09352cf2d812c569536fc0d6c01ab4f8150bcebe0f0873a051469217d6d30304de27294ab1bcf2131d716a2f3c06feca7c3408d9bf0288869a473b9ad2064b573700e9dfff0223a54e800db1802cc81ca5ae383269ee97197387efae0d62dbb7662dfce90c5a8aba38a8cbad1fb48d35bb03f573cc99d8e299f71902d94874d48b29327bc89fb983543a9a13919019a6179ce801aeddcbac7fe55b87371587c33504685aa355883f004d5a611bb6e2a14c37df24ea1a488dc2c32e6bae83e03680e5f50cf885a49ae7ac13c43a2b49257af9af4a1451e2cc4dc9231d3ee568c786e6d687b203150f94fe2d4fa26c1b619840992540ee69f3e62577a056c5870147d7e07fdf3e83d9800871955a4308914cc46666e3d17cfc0e063e6cdac95fac5b7fd69df35f309a706bff8cb2d4d28f4904ca4789cd90c061d35c2fcb2a0a896f7e7bff45bde3e9bda68c8fd482c16ff1da2285305ef4709d92f54192a32df1ad405c72ea7cd037e8698a36e5aea6c0376a79ff6756d25a4e55aa36b8c9e3aeb4d64eb71427ce86ff8bb9d5d1a88766571c2215a865daba36da4d26f5db1d75810485928fa8c5f51a83f00609e1fc1ba4de0df9030e0b1026b0eb3a9b6d2a9877ddddc3a7d63967f78b9eb973f21c5c65b6eca5cf6449257b780d3951eaee0f711709c360bd1c55c1264443c4313c7f12aeb9790ff7c1327ec3a233cf115b6e28b95b3c7b5dcd83044a47d3e4b9541c0529c408293058c2fb41df10048ace595543cd9ae2c668a3b47dace2bfdeda470ec36f8b5fd71b261bcc55d8097a99e511ce35fd2a5c48d43db0edfc9f47f1338642de40c7f9fdc4b2840c805bf99f1f53cc6b546e3390cf5ea9ebb3f7dbed2ffa53358244b2a79911dc72d5e38ffefd6a7a958c162fa52e06c868720135491d7745452a06004c3806568dbbccd46f12699fc8b6d3cb909fbfce872f76874f02ba16b23e9f0569f3e3a94afb6359260f817933dd1f18798ee0064927540e71b3cf5ae99a266122fc28b0627776041ffe55998876b7ac3373a39bdca8c6dd70590669ca639e80b95536a6539d8ca3be71b892a0cab14ef61b2ed315aebc6a4d4de3ff2f29e3dbc0424b0b6c5650fc3d4e783cbf2af3cbf4a677115690fca5003f37fc4434291fdb673234376d8342d8387fcfe05c5fa984bd2100c7b829a6ea69b61951975be64195b80bbe114d37f2a28b947310253decba673326d0d4900c0191f5d45296718d091e4cda648e2142c7234d2cba6c3f93ad91540aa454ad4f02f391b893491b90169b51f845db471ecab7e87e3c97d440466429a88f17b25cc891b19c3f68caae59cdcb0ca7dd8d5dd925bef3a251395527d68a346e40d1bf98e2591dcb2f05ab8f0eecb1a7b22b570066330212994b0543601115907fd0daf77964e53319562cfef5fec68073a2da339667bb8e15a79a9c573d543e9c3ef08451a7cfa63b39d87307f99750c4e0d11c9b084ac5619f0a96ece30980f0ad8354b580a4861794170b086ca51be70016b297e91298ae347dde49ad6901e8814f57a9219f4b7c3eed68fb14273d5be567a8062a9ec1612bfe62ab556f8a209db6d91995b7c7e7eef8932f97d2ed1130df2619a4eaadb4ecc30ee9e49bd5cd94898a1c1ddeb153f4399b4ce71de2c76968b1c471d6aba5d2089e0faf51e8f1fcb1c23133459a4e18d28cc204e2da34e1d38a002a0d0ae6fba8dc7f902beb79e9a4a0f507f086699e0e383bd241cf4f939550b5976e03363110cc9bfd7538c8322a2911fb0408d11d839be15a8ddab8fac720878ff2fd9badc5eebfa54494287b8c24cf4375a9a0e2b6c08b8fdcb62f7612220fedea637193506009b6ac99c97667ba4dd1d9628bf9e2a7342f332ed3b37b00b91db334ae8a6a528770eabf34c88fc8f8edb5f9c8ae4f4ca47e7646602ce2287bf147f9314c2fec0c57f6f90d4b6c1e4ede7f9ec3f84fd7b0a0ced289c67bc96aef2536fd6cbf013b3c2515030a14cea94e8100ff7e2fa5df6d32ecb4a53500a24eb046ec549d44d9801aee5837d9dfd2af86e2d58ae0cdbf9c54009369a6926573b3c668b482eb085299c07ca0fc42bbda9c3d3b6880f837a0f1ccefab6d73c182a6109eb60546306901bd8170889cd2f3fb65b7b01eb2335454258455a1dda9c777c154e9518d984ea496661f1f2abde1cec1ba571e4f959170cb39ac9456d35b5f8148acf45089e584f9c3f2604b5f9634e9330bc5d63a5ec9eb675f2149b26989240df2a9d13a21be4e1086b3d8e2a1134d48b9ed278d26bddfc4bf59241c144943d9cde6dced77e139ae3817f6fd0b2b404647282f58fda5b40b10f61df14b90b6676ae335a44a77c7fd28ac96fab1184e3fb343c6f956b6aa632f5ee76044554b5a270ec4745e2865d5f677420a6ed64bf682b1a9050a0245a7aab26078a1f5b9df4751030e4d644b11c7a45f8990d2d5cd39af053d76b28d09d318f1061323127ec9fdc288b8d2defeb550cf4caff56f6a5b8ab81eaa41a58e3d6f5c215a3fea1aa6d784a3f18d60a1f49dbef48ff7a4f5122fb3605312c16d6c1a3644babc446b44e3168b3396d8af6735223a272269b8fb4cb7a76bfadd9a551be41bbf01298cf1c64d39a826c5e217b6e33c0f3b15da3ecbfaa330f0c5e354d762815082d003bcc01eb2863ef88dcf1a50d6faae920f3a190ebf0d98796d375e77179bf47789b6a295360d6a0bbb71507d4b842af507b422f4c63252b6abdd1bab7b3c17ab57e50907b77fca22a23c1a0a0bac4bce503020273454c20f722706e81025319c8d8f070a68071f7bdbba0756afdbb22415d4287407fab545b6ca81247e5306ac9b6ce5170a59f6ea7164be98b035481e63a1b7cd20ea4b54f8b657590cd3bed9fab718e7445f8d2c97ef811c8cacf64e06afd7a1afe84454c12f2e3723852587dea8a82fd56e20b006e076c17af94a29c07aae7dd3c7ecf43becacd1f6a1ee277bc0e9280eef74aa94825f5873de7e03b1631aaa4c4f52740804ae477cfb8ee1749ac5fe4476bd072dd9a43a847387a72205bd71467db03e7f35ff71dd3d5bdc5f36d2cd0ed853d3ab62e54326a7f5bc8b2a5428368f15c97e2047ce5bae73f17394c6300f25d8438300b208b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
