<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d334469fda71dd3f6c771478d252b03999c281081559e8a90cc3f862ae044a5094867285da39a5ff28901c76172749abc563b6b692f40f578068f0181f64052a67c1a1507329f5df7f5f6732886b231babce3a772e663a929993939c1599aaa17baf67c35d2a89a76de3b2a0ac719b4c76b82b17786802a433a5a0b5b8aa13b119be106a14a93842e5df405a082a5e81b9df10782be34ccbf4fe6f94cf6df382c6862919f014608fae5782eaf3e4457651ff3c5748691ffab8958ae19895933292862369ada0e91aaeb40c98a5e525ca99578fda3c57bce989137b98db6161028a0f178b1baf6d93a2bd617ad6435bff72bd7e6e5de852431b5a28003834da4affe5d10758ffdd1ea3f083b52ae4e6a67be33a64d0cc0605c3805cf12e5bb2a94b0027d7af257c1911a4c1066dac108d8d8cfe78fe41b8a7dc4ebbf7ee7e753d815cf79b0460aab7ff91b94f037b534e4f299bab52043dac6a55f095cf6eace93585a303bb692329a6f84a89b676306f711e4fd910e10c360f4133f019030e682160a5558343d243e51a1ba31a7246ff8f18b755846edf91ed2962664ff4e8db34529cb8e90304cde6e85eb3a905c518467e0007595ced5a60deff6070b58e5fe1ec997a31924beada3e6ed6c0dfc05d8c5daf583b9511c08969186876d8fb631e82efe6e6e18c848a1609f11dbf77dda52c23cb7161dab9a75673d668bdb5467a9b2b9be9afcce2d1cbfe78572b56561db3d6daf4fc6655051290831f62a5ce76ccad2eb5af40fe3d26a127a4625e499984dbcb302510dbc53e6b5f235bb12309f6d67de4b917f5819676b0cb8ddd843297692ba3faa55ac548940f140214782a40060cded1712d11eb4cdef457b4d5da43771e02667c81616361b81a75e8da3cc890681be42b7536dfc67030aa44b26cef3c7cb397b23994ecab2c37dcc5c9e7c811c77721451e66808119f845424c0d0a3a8312c55402cad62e54e99171b32475c313ed76e68ea396e4a3e34be307b867e4f0a7f3a8dc27f7caf8b214c23c792f1cfca571ad92e474ff6863df83be512fe6b8680b6a8f06eee2f1844bf0a9a11f5c16cb1ca7d23c0df3b5aa099bf723140aa5ae01537a3ab152764b899ba57630770de7118c8a7279c316b511b357dd6e083d859f137d3df3c68f9641ee2f4c3b6ee34f5367999da81ca6216725486e1abdb72c22487c808b16923d5bfcf463de619625940d3d4c72b9050f07ef1a39c50f14e289d3e19e5bb4dc30cd71aed9e119048b0919f0add76b81a1e2d517215279e9be9477fe9a0a5c9edc67edef4f33e10e35d46945a6522d9ec30098f93299228c414870d89530209b3604aaf3fef6ba7fbe489b2d4252a66b75debdbee4b0201a9143b2016052a86279a8c7de22b9f9163df3054ea9a6727aa63e865ce7a0137d64844031338f7f95d7e3d8775847d22ac7f16a4d0758ed9d117e91240ca0d68bb71d4bc284a3ceb545c5bd8ec119db8170c606940af575fe210d1aded7d0d3d1d1694d77f3dda34a5af5e77f24f095ec69c40315a1e1d873f89d15a7fd24a01209eb13e55c24b3aaf54376c84881ffa486a0a1f61e9357b26f4c4164ac2a5fbd3f06d3b2e2b1a9c8f39d1f28af691267f08ca2fef1d3010c9a6b69bab8e4cbd83f7623e9e0873da46fd9f5b65292a349fc48d099a24de710fb2b48566cf1b6724f367a8c80494e5ff07ee5ba5f30515f1fb9698528583d54ec17043ba8f0ca4d3b4cbbb13798d55934ee86dbf206163636348c8545a4295dc585c93d6adefd43235020bd7982ece6f6a9cd4d8fb8dbd0e6ad0cc287519b4ed707b6ed46c795d92e9cd225aa73c9594285ead95bfb27be312c2c1861818672882e8c763689dee558b23878f63e3c2d3677eea244cff1f9bc1f08c0bdf5aa6d3fbe13313a49d4515468699d84bdad956b49cb4131e53927d69e91538f77fca58cc88925b79d59ef1f74f69af10389a34f022ab8d488f035852d5ab6969f66bd502baeba44d1ef96b06435d7678013fde5a4d07bb4df5fd4e919675ef5dce172257dd72eb11b9ee281da347e43e9a6e8af7d9938364bcce8791187d7f446588b2444925545a398fc5e73e17a6a6356191b3f5bc23d19ae6fdf544f4e5c25eba18f202e3e0d51de49c1d0700514c264841529cb644334a627fcce2a885bc66d42a6ea7c44d0031c85e1e8d6d72daf8ea950f9cf9834cf12b44a9a1f83a518862969d3793fb3115f4cb25aa9f438c34ffa5510673c11115277fdea1c3a01229c60b8e04c003694bd3a64022450b922e42fb2af942315b88a89fc69024e86671ff830ea0e62dcf3f087656628b2a1f8ba8010d835643689807adc34c7bf9ff292a21ecd13898325d08a8895ce2dfa6092d2f528763c865ead6fe1947f850addd5021eee0031333e38099140063c8512d864b8b8b12068978ff12b5e43a93c6fe36b0bb77ca07558d896ed5db8b3dd27fd882e2cef4b84a6118368456465f27f94c71b3827d5efd487e261b76db3b194194f299ad1d9e90b2b283ec9b030be9f67eac43712d05d8f60b6d49ac31512b82f7a0be77bc0aa879f397113e98fb7a37b6785ddaa7b8332c2a33fae8e6c20a6583ceed113c2c1dbace1fcfc19e53f1e271e55e2a6d949fcd4557c55bd425f5abf2baeae94f30bab2e87f62ab6c77b04495db531c82ce7c241202d9b8d98fddaa4174bdf78c85f4bbd6e2f1f205a0f53e5a745404fa80d0768d16e63871e446f2b1f14b765139360e08dbbea7eb9cf037150bba0b79163b20633e65a95d2153d8b25d072108114cf7f4ac80edd9fac09dbfadf2bbbd383a831307f16ec45f7ed5392c3261aa04528b2f37494fe9c993f22019f5f7ceaea72ae39c33bd0619ad70e2134ab896e188999c06a66a7dedbd1cb9f7fe483afd1f5e5449c6fae4b0e4fa175c55cfef3476f4800838192adfdd115e2981cb65176e68f11090d9639a4ef8e906c47482091a20193188c7712e98463be64740bbe909646bdd6c27039d2c64312c8f43f77b860d75a566a2015d7be57a1ee1043176ed03bb57262b5f3b43d4faef62cc6ede8ea000f372049e49f633dff80fdcd0ffe78fdb95cb1eb1c4de1078254727be4be0de97ec37f1a2a03dc7a8992b5fea3617450620535b901ef874ceb08db269bd2bc92e78b099fd4008e87f5f11f607774ef9f856b5dcf16263ccfe8e4d5192ecf16e7e1f0c065784407e240f4ded4690c41d70f7b60a307f82b1a96ea56581416567a67cccff290ed99cde24fe1c39180592f0b15e208fd7d8c01a9a70b7a002bc5c8b99c9bc86f7d71b3b98551277fc9d683a39e2ef8a997402df6bdca8cacb55bf959052d37a575d4a75563228bcf55b7b6b18d630805aa2feb5c7a90c5ef0154d848377477a87acab110da05d9ae2563c87e9cf52a75185a4650d4b4160950e4aaef4d8f673a9e084aaad6b7fa2987cc6a58680090cff4ac747ba4a284b55992d1a3c7658c68ff172a925cafbeef3e49e6ea43a67c360be7f3e2909d8c1cb784cc39de89abf9e6917ef9d01c2430c1c1ce13e5dfb90f99fd895fddbf3d042690ddc0204033a51870a878467f2edea3d26da4f37bec6f051acfc61e7ef9548f8e99ce8833689d4b92b0c7686e4d88aa7b8d56ebbdb08caca17cd1c34d6017867512169ea0129826c7af96888d34fb4324f5672fae81d359fc91e60a95154cb956e63bf8441f8057cd480533189260f9b7afc51fdd99ccda9e013f22633d1f06b1bbcacfdee9abeabb877cc6a6ea2df9a4b9122381321e8c9aec97f93ec363da022658128e6daca936f8ec744b6efc0536d15730e72af927f6e381aa407fc8b93133b31a0422e42f4b5e2e2053ac94f5deeaa712b26645effd0dc8872b19764916cf0b62c15c0d84de3c5f2c81f984575f9a266a7061dbd28789032aa2900770ae283457ef518c276301cc57aa1ccc65c484ac7ef3f8f1ff38324f26212b0aefe1f1e1849e1753bb08b7befb98606b7c9113fb7ff2a012e09d5277535baf70cd1b2ac417a1eae3cb58e7024b708ec39865daff06ad63bab9ef0fb266e4acdbccb2f29edd6c5e138929906b401d5c7c879b82c7e597047dbec2e594fed4068b4cdd09ebf1e2a0fa83382bd252904ab61736b287ca8a0d2d05017fe018809c8f16cdfedf16488589ef4b0f6c4757f5b784a89c245da7fb8d3b9ae9949621f603b5374908b4643b99ff7a0382fda8563435ec8972841c1dc9f50770cf2bec3d42bd9a5723af13669c1a0b17ccc86ac6a78c2dfa089f11a08dad14a48cdc51ebeb43958c7c0b9f37844ad309501e79bedc2d4aaf8fb29d14c5f7a4d3c7af8dd4af679add7bdbe438fa914f86a124b0bbd6a42ab724e1e6678de24be8c35c4993e060c36250922dd7d8cc69af7421b01a45dd1dad3f8f824ec083eab00a425b1cda666c6c676111e906de8a9c2dc990decdb5d2f54653f9bdf032331b8a26b3b98f11a11a2cbbdd8ed15668966d1ab47ca0813bcd7c769172140c7f3409baca5077e408ec65648a3bf8a40303498fbba7fd5e8a3cb05566c329ee222d7541b5118b916712fe77472eda53b64df0ad7cbedab0fc85ec966cb727ef515db7495fa0fa09f81fa13af1704fe0c8360b7ed7eca04cb4081fcda8718e75f7bc95a25ad8d8c5331bc740be19bab8724217d83b8f77d7a1cdbcf3fa4cfd3cef0cab949e06873b43ca42c653f45ffaa3e3efb33ad5ad837619fd6b327c8753f6e6410db1e3262c2bbe2291fef0382d0d2034777423e19a7566543e20401313e09adab2b753d1bb33113771a868e06116e9507b2324f885ae58cfadbd30974969f674fa7b164b1fcd594a2261ced5241d6e4fecc80b54ac5854f5270da6a071c6621cba1e583c9531154355c89b6e99939a98dfc50e3d8d0cb970e49ace013c15e5be1a54870da628fba2f7a9f50af7b92f25dca142f6d28dbd260d5696998cd2ef688f13e253c1dfdf00a786901765c25acb6476ec32f64dae64ff21d115956c867a706f6d048ed1daed67b4cac9d31ef02881d7319f191a13a0b01f6e211fa7e0a5ce520d797e4e2a0c4b7bf86232c9d0ec93b911f6b879e89a482b865a7bc0cd831ed0d0b810379cb3ea72f1f7fe64664eca6c95c9800603e5bf7fe9ab31a3228cd3a04def5c8b989f75ca2314c9d0ceb45a0f86abb1889d04ebfcade5d9947d69ea62bc907d08f110d22bdad9c5997f0b06df6ccf68beed6154feef75557c2ac8310e4673ba4873f4f95b430e2b8c2a565263f0f77008c0051f5502a678c133056ab29f6faf243fe7f548a08d99dccce8e6301152a2add0a04171350d4b36389d20b4e25a1e0e181317310d4f3a18525fdf72d9e5a4ae3e362bc3a95904e6a89ccf1f00d8c5b8bfa981bc10687c878262bc4119ae29906914fb771edfd3433260ca3c13db96cd8e816c03b7d67ea4817549bcfd65283dc2b5af737892b6fe3d5bfa112708612d943635faaa8770b61a6aa44acb0e5dd645af91d0456f983ad29be12303a0ed6fbfd1262e4773529265f5770e642fe5b8c70b5823d4b8427c82d23ab14e6304db5d1a89f2096cd8af001ec0062f5aefa80b63339f507f98c4db3d81e54ba33d1add042abb1a342872e489d95e3e8447dc7282d021f5e494ff85dd397a6adb5a2821d0490922f2cc6e946698d4098edc9b12cbc6b769e20a9e529ca2006cf01b4b84e7d95b9c673fc42790d5b4393065eba33fef4f778b1b96bd9c97565283696aa9a197c41b87aa2d86464cd134f0b26dfdb4da7f85feb8531d594a79dd04c242ebe9e0e03991f3d4e29dddb247658c6a2a3f67973f9fbc7c6593298aed9b3b8d344d1abae9982b461ff55d619d71d42661745c7570cdb21c09a7ede2cec5f6404c0fdd6a307f83fc50358830f33d128801e0cf7a1e0290f556f0601a4ebbeb3ba457e72590e9e31bcbd8217dfe6b958ac8eb938ffc9312470bb38f12d0f9942b347577671ede4547e284ea02c836502efd08993020325b1a9a75bc75478a2326d0afc66d1a5ecad0004850476a9599b5f4c2910e91f9cebacd022c2bf6b80142d7093aadabb271f075c7d7479bad1da2067e6f3b026ef47da969c6d2f0444bbfdc751cb433d076c7aaae9834b2b0abf1263adcb8f37c35253727bef9ede11f799263080c639f70b2d9e5a8d8d065248c14c747c3b07c5c9ba1ba38769de67ab9d3119b7a181d1bb3bd900560b85c739044f87a4b6697c91ad1418b2d05dd5e10530f7afc7bc451d7009a0ea1875734155a65bcf76aa6c13440f4effb27d43c3bb4ccd2de6e0f61d72f51531f49565c172827ca272952308826d6441cccd6e6d0373c76c1a9ac001a4895ff1039241e6dc5abcd5a758184162bbdf4b053a292655ac724beee2b271fe2856940cc05a284c640fa6477c579038285995fb348cce40f5d31c5565361d745648d5fdc3713854f3d9230e3b778bb8ba911f9925dd83a2ff6999bfbefa2db4b8b8941a1800e5c0faa45974c29c2ab847f7e22188d7e70e39c1d83045e4ab8c2fd709b57403c833f9e72a2833f131d6d432850da3534e307e2428e97868dda3e8a8c08ea65069f9aa05d0d4778494c48ce816c352892e890d2e6defb42728e77af3ddc2528d53f077b13f544986e4a2320359a628d40475c2c689bf5fb4d6ae22e21b191db20bb88f37610a7a9dd69508a96df9dfb22b0dc0ecba0a3b34b34ee63e388eeedced0263c3f14547d872310be4a4e057b9a512dcaf3c039af9465925a101aaf5cb5f25838840df0780355df96c2d1647c36aa18f8a817182e9696c3e3af80aa292ab35dc126e05ed513c966257fd838f7636a2657eaedbfec7e68906a63ac9f04d11f3f5166e6136c8e39e780fd3e84b38c274314cffdf34969f5db7b7ca6d21b9a4c958880ef253e9f28636e5d23d536fbcd1a398c37cce539b802e6598b8bdc0ad771e626e1295edd5700a396e24dd08d77c7ac48c93778bfc4d684308328694174822e0fbbf42bd0061b5cfed774567272af1cfab8b10d667fe070c1a5130f4fb8a356422ce67e080ba040869fc2fbb55b3be659b5eb14f0cbb8b367fc0f33da928f9d0899b93f99924044bb3c6d06281de4c58abb1ae21d5a11b5a5cb131df3ae9da5faa4ee10b355fee497c6dfd5667c4c7bc66162af853ded4588d00efc27937da64c21a7797e7d68b4a9dc5e4321346731513a9faade0101d879adf6595f6ef0168dcc8797c190e21bdcebfd8993203447417aa5ec4b62af5ace9396f002bd8b1dd6bd1f0fd46cb2783b9b8719c5673df17899698210baa0c31d69032c6b00127e3e6a99bef38c71f207346ee1592ee7cf8cb7faf1db3611d245e30623fbce4b0f7fb7bf02ce0e4d029be501031c848500cd4fa7cf2e9f15fc01a42d28c5634e9ed0e59545b89217790b23f4236130826514dacfd0257e1f6f2313ad5d2936f9f11f9a86092e9104d0b6e42c7fb9c29ff91a4e8b22f56f5ba3ed17281edc0e3aeee11ed2c55267f2018ce466874a363803247bf5076d92653dcb5898412a72d02569d90fc410431ee48cc5550192350aaa1dea0fe7d5be234adc095e17370892343e20c2cce3dc53bc7e7dfc0d4ea4fe4e6428b75727223dd8722f26fc535d235ec71398a4530ada3b7f6a90b88fdab2e9ea843428504182f343a05befbb9c32b9d776bcb0750ccf596e316e04d66bfee3e4a80414dfa56fe9a3fca0371ef8e0d284a7c7cacf69e0842c24bb93c0fdc7e12e9164f090a2707300fd1943f60e11a7951f6d0cc414fbbb26b4196527ea8fded1c01013dc12cb426f80a6ea4c534eb9352b2d415a605d801b217c4a8dc973074e2c6569631527c808522bfb99a0b753d68f4dce2736debab430a58848f4df79f38e7a6e817bb61aadb90b1919482818b7db9c4ffd8cfbcec46afa4413ecd613f775d10c1d09f75686111074d710c3ee913e7135c2b76de2d55448616db7f72d903efcc7c05a90d488c95afd0160196ef4f936db43251c76bff503ada963d65f425d87996c7250ec782648fa1810e3cc49858a5e19093081334ee2095120466656e5a97a6f5f408c6a1f0e7ccf9e6805224d573e41c25419cceca3a7ee3f62d2bfde6a78242fce7cf7c16d30ffc27f5954b571166634b68c1642b1ee9ed00e835d06e0f2b3708ead5d72c6164d3ced857c51327b42c1457a18e5d6d8c0e3e5124412f1f14e872e5a1b32d5da3c5bfe39081472ca51f73b8f7350467e64d13f68e2d99e70dd472a0899ecfedc1c172c7fd27032b0e7f419fbe37bc6cfbb23b09f05475b4541a86f8ad6ffe8fd9b69983e6902fc9996ae267227f83d8ee51323f53fa75527e7876fe74bed6d4c36bfaa40d6aa63c417819a88ab35b15405c04acc3d01ba26adb854d37b49c5b67afbdf1fd9d6c461e43b17ae989d859713c516d714e14fc958279b4c32c365bc04d4c1bac356214179ecf562b94daeb0d3217a817838efd983eb6bacaa3a78bae0817443c298926a61c5e98d74ae8b85f4cdd75331991fd5afbceec58e83b96c9072ac6db38d8f3dc0333c8343c988cad62ccc74824c7a84b90600823cfc1790b4f9bbc9668534713187863d77675884973cff3ce4043e06f2fefe9504bee3fc2efbcf3dd290951eb44fc5b5c53d195d0beb0950167bbe3f3ca29763ee9d9cc14b6c6e5f341ca3f8ccb214e81435d4901af681a9ab93e95c112e6ae766b73917a9ed1192f092e8021ac2250e1dc4197629f9cbe05681ed07a2223e697ed2817b8b16ba0356339581c9c66a69e725d3044660c5fd939b519bad2b9b7a99f0603a5949855a297de606585486d47eef36581501749eb21467fd23cc28f2bbae67a1ff1163d82a0887e12188f571aee9d92133692e3b822c51c0b7ab90a2da980616818213b6d7147f5ebb5a63962c9632f7ff6cca83cd33b18411de4b26b881d0a488db927c43dcb44d8f413ef345c48997c7c27e7292bc2031ba7382af77e580976cf2516ffe5842d864caa642890b8c5dec55e97c5eedd4eb2bdbaf9feff21fe900725e3b0ce3103b5f8a4408222eeba141d4491ba66c32c8b7a77a88f5502b0b251e8ca0e1cd6666329ce1c65c1bef9eaa7050062fad4b1186a50bb8762a9558027cd2f149d3b578414102f428e88ed4dd47b7a2c4d633ab2fcbda4a40d01aec07bd8b8a94ec2a4289e1f1762501faee0de8efb48e059484df8aa914545b1b9de5713c30f4e146d5dd9e6af34e7707454d71f4c73e421c6dddeb0f1cea47007f26ddfb47a76510f5e7299d4ddf1fff479617531b4b0cbabe1cb4289b7645f09f5afa30616f2bb0813d7da51d1674f233157a9a43d9b8921b766f0eea7d060188f9c74fa0169e0efcd15945122d0b8dee4c47cbeb8eca020bf0ed71e5819b23d2d760d5f1c18154b10e9c4690ca676c859c3d5fc67a42bf2d031145b876f860d4f45d4b702dafb8a819c3c3df66d24edd71c061c507484f3faf2f04e251b62842e53c435190cc1d441d7977e115b57d29276e19a4bd4b57cfc861153e1f169e8b59fa4e489acea58e816eb2eb138c20920e1272c9d5e82e36616139819d8e073aaceab5440f390a46a106a761bd24f291415590c4082ab062cf579623773c591a88e57e4c0d59c14f763b14c63886c51749b69dc1284ca6fdf3f232141bd3742f9b6665484ef1bcfae44c35b788a3d398e162c873ef3307beece5da46d452b3cba3456741c4b3d2ddf93e3402444e3849582777c0446d963ec4d30f12f586308290ece80aafbb809879920f81ee36712c795d3d0181866787f53aea64941b3a71bb00a57fed496d512ee5df0e4c89899a0bcb4718d97e34320221f8ff47fb5f2fdf70c5abdb310c2ba18041e3f17c7e8c4cc4e62c52857194a8a3af92f9fc23cfbe2b22a969aedbb9036d993174c74c843014faec7f7def23fa3980114f44e3db9c564d4fd12d5c11a76b7f6cc45a0bedd35bd874df470684a7adce2c920b81ad44ebb8978eee5ca685cdb3ff075505909824be20a4bc015d2d8b039246cfa36ef4137d161c613907a482dd02a0a344973a79983447b3467b518ae632778ab6ae190f1c4dab8c5083567d1bf73fd3ba659e95bb463a0838e951adcf69f9f5e720919be9002addc0a0022cc2dd275f6d732a6bf848324937db0606abcf5668d30cf42020ef449c2982e4921c01907bbd3453ba59e66c5b99e0322fc3b7c3c77ef8bc473399c40a847194195c23dfbfe078f11c986fc7714d8d4297440122a7bc878c630ce9f6fc48829a025e16b01d7c2e3f5deb6b21c95621507060390117917306938d7690e17b40cb64e6286296a7b73379be013c5c994addba2bbc04e50e885e47fc7d8b250c30a79880d11f95e43669d32b46678fc755c5a03772f4dd6608a8b192ed9788fe4982a12551fe138a9d3e9ced8daf588256adfdc368577ebc7a65a33d0a3c5d86f3d428e62e4fe03da048c4b4a64a94293081472cbf5dde11ac4ac7fbef60ccb1760d76fdb6da1ade66ad3d294abdc74db8b6c247c54760136d227d4297accfa90b8edc4df37b103e6fc4faba7ec37cdc7b3e3a388859a407ae01c4e60d89f8a9966acfd849268bd256e63a4ed10256a9a1515abca0ad4410b8a5e5c2fa6bf52d1fff4696dca5a736761d8a5d5cb3f5ae0f7537dae72bc2abb13666b13f64ffe0afc5c48d943049887169d6f8dc44d08646cdaa7ddabd40a8c6b8982b43e99aa8a772d3f3d8508afd61daf964f75216032afaf7f08dafd93a9e23907ae8270cf73e10f353ea3b5cee4a86476b0c8cf25ec761068ac05281981d5ec459b871f53b5f99d6975ec3bbab4f4b3bcc950459aaa7fa42628c92f2a71530a4708266d358336c207e5d007a25ac094570afa34fa53cb1130e60129c4f2a948f9f9c2da8480bb5067ca7bd3640d936010ab113fb44ba671a702de1db1048b1548ead34d87f9d981be020ae526a810c2ff7ca9cdc40b582aad35bfe5001827762090c22bd7b71053489f5780a92775b49271846ef30c22ffc0d0e6ae64b051a66dbfb2fad26eabfef7eae1b1b942f3e28d2bd0b1c7bb630ab36580ed030c97e236863799da595857b9306ed10c4ac78e83b9e647dbad88702d493aef8d62956306a2f4a35f21df71e3c5bef4e1673b48bb29d4dfbe22d0e61e9a5edd4cb70e0a1f5eb9edfd09019584033d52fba4d09c988d3a47e0f899a55087e57f1fcb674eb9759dce76385b24b8398f51743a217262d123fd0b727623eafa8ce44fcaee4f6a7ddd243c80221790a811a295286dc19d623ba754f146a3053e0e75b9047f1f6a8b4b5de1dcb12a303d4dd19c66fbe9666446ab9ce8530cf9b04bf335ca23a7156bd33041a9d2f79470d2e32409eb559d940edb592e4367eb5ebd700aa461c264c5e11559d394fc46b44e587c9b2814693820bd0d8f386aeff9dab08bbaeffdb506bd4ddaae5cee9d5ad6a54fdb656972c72376beedb4e1481422960758165f91f256fde4241f63d95be18f415ef71c232189482308b6e09e18958e062093516c749c8918cc2f151f18a965644ba275ad5a74fec97c58293b10a05d7f9f4efad9f1173c2eb5e68bf52a13a9024b372711a81ec3eef907fa2d913a1ad72f3e5ebd523461ba21e4b9d10ec11a460cf56c35cca58e6da91a1f3a6b5a5009de8a5fd2ba8a152e694cac44c4628750f0458b76b3f35adb9c45f07ebfc0a7c47cd40941b243e4d2fd85f4077f4e6491d425eeff92a6682978125f9902d473af6ff2f729a697a8ca0684ef50950e92239ed66a242be874056ab98fd0fdd47a7c0de8161cdc4df2b93e9df417eb5f1cd3c361897f5a9a581037738a60aeb002b92d1435fcd59c8101ef772756c98370b9639099e2c6854204b4f8631f1b46a76edfdbd77c9eba24b1fb5b09c102010bc0074cd7fec9fd714502a88d253d50e8d7a20d42b3ca70c2cb3d2ee29b86f0b65068ea08ed09cf7eb5400f865895699ed3a7fc0f4a37e8aec06c715113ca2f735d4ac359031849d3bad95605b1bd14ae8c42099de1baa3781f301e7714f3fb5abdf7bc1f949f7b3c483385146751d36fec5ff73821bf3767a50f9e80815892900971cef653084fefdec87106239efb16aef4414cdb80092e951797db78fc8d98b2cd56c0dc4cc2dcde60ef149160dc0459f708dcd8a4faf1d37b0b6a3020626f7a466a30a181619bfad500c774986612ba3d92afd5e09dad7afb930d808abf4abe7f726a170d5f911b02dfd05e7654d1c752bff9321d661d9e620233df04571093ee4f94efe90a96e265458e30139c52316fd5d8afc04b31918fd72da1b162a6725b55cdaa55285f3c6cde77b7fbbdaec82f0c2166e50e8569fca36e828bef8dd15b0855ef3fb8dabf307fd6303f23935f6efc7b31c386c55aab50efca4ea831c58ff818804c33f6c26060063f714de4b5870ad0b4f41501999d210e39b0969dee8d47fece0b8b7166d130a5963c5ef04f7ac06bd5594d74fea1b876f1eaca8e33fa33772193da7b335e1c864b11bed89738919cdebb7c95d718e8eb5b017b1b8bd0cbc96990f934919f6d3031bcce36744568df6571c46315a88f1daadbc62a69dfa038daf4196f6fb8ecb5789cc1d2725e5c78708a70719626e856943fd92e0d9056ba432a83d37803826cc888a7a9a9a67e9237b99a99fb110e52f32671a958e16d7f0ca074f73926465ba1a6d126a9fc86f1536bb05ab3fe249d7e43805f5ed645828eb130397bcee4a24585e180d01adef1c413ba57ff2e9369b8d60e97679068b63c9c4439f72fae6298a26a6f12d58cbd4c3b7cda7ea4940e6ee98418bc6aab927e1839b9a28ad028668cb8cc73dc9ad5ee8bee50d37313e5a499d12117b9e785a60aba072cc97ceef448cb72bb46de1b6ef3a5510a7ebdf3e195109ae793df61ecdb478ef70fd50519b8fd699ed2331b1678846a8eb26a1789f370818bb4c812835cf5f1bd2dfe1addf1b9a9e1334e9ddeb84f238fd236c80e37cf1b9555824512ebb69defe01e378f2d1095929f81b2c1e680a8d1bef20cdf4e4269151cd21153109edcd7d09e70a2c94d0e57f6a59cfcc05ad04c52e4ab9fd712db98173ba25c2c59f8a0b9c02f07a7329b8f6a7bbafd30194f7ee2ab5e834c4839a9c23c973734efbb90b30c97af66c5c015fa0cd2ae635b8213d9f99ed7cb868c425d247fd3734d9e954fe9fcc32396f692f68d8775cf7a3bd4a619a8e6c42e59616d55144964fece3b646c5d34b083838c916f00550159462f7c28cad0ffd8b8f58804e3a1f49eeca9f3beed3ad7d2d30fcf07bb918843dde4054f378e143f7a837c10f820e9822c5d7183c298ae6850463aab275c1e817271f38b31eb00fbaa084866a9975e77cc4b7bffc7be4bf8ed1ae6d550b49f93312288936a0bfeda2cef7489d51f2022a714e9592aa60467018fe3b460dbe3129067688a6a3a3ff6b8727f656ad916e31401a0665db22ca33bf901c6301e318d284ef1baa2b1dbcb8a49ccdbf5ff40aeef7f2ce535c12c015b0b4c388eccc07f4c51b2b4bd3d81bed1ccecc0cfd800e4810d1d87fcbde80e9524dbe441380f092db3cdd41d10c77aa5a570fb1a9703dd869e0688554c8927063878873b4786be15e57ba2a70dd3bb0ba8326b6509a5408031651dc6732658a01559f076331ebbd972db0374c187a1580bb5eb77b39130000f68f100ec11748f7dcddfe64afc1dd9544f38e18ea44493ce4ba92ec5a0d5323adcfc98cd23d9e92a6d0f2453f3283133fdc88b9a0114ed9b657e41f66c1e9a9c4215f554233b6e0a1e1bbf6140386fb8e31b75c54b77a6bc237a6f324a7b98196200b1347be72037df6fd2b85ad10d5e63fe4372ec041cb95215fbc7fe0af3a324fe6c32a7cc41ed74a4dc497236d53790e8fdaf58c78ef148d5d9722f23c31e3001f2da1a27443b48009e2e7db70f19125c87da8526a0a26ecfc7e3f81def8192325c212a83c1df8871e1a3a95514d5b57481fb977fd4988c257945d2211b5e8a63cdc6134e693db782192d149aaf3f901efa76ba5d36b002bf30a10533f3b3f39cf3449f3d91d87b3b16847d181fc3a3bac53a8d02b63c0743fe12b827cf4767640857673c50530a544046749992ea4743419d0500fcfe705568bb15aa940aaf4a4ba0831e8fdbb694b7c130e0a7eb8955a7fc55cf59e6a0fcc1007acf7aad652ba603250c482e7de871504232c6232ee0aa64d2ca5e884a7f9f3e5cd150a35654b0aa41fd06daa87afd70980e57988ce7cad536ed181c7ad92a7393add33f6bd10c279773dd8b0f9130eee86d7252b57cf5a7a45a9d0d61986f25ec4a4aadc9170d7f2761cc5f55fd85cc5e94726b271d983904870b4b3b431f009f36f57644bf97f67ca5f206cd7d5166d6947d6f5fb0ea6657ccdbf8d78921df5d027d803c8349774e85212dcc49fde2737e8b762491885d13c1f1ba2ec2e1005f90e00e1ed9914a939e6747789a3bca52a155a3d748b5ee8629d05712303909b92850b8039cc65b89e7885fbcf743c86df8fb8c0691d1de6fa4c84cecca908e6b1be71e87d9010f48555c88897a0bec1c3431d54f5b1974a8a5c922f8b74103af4c2e8dd6f0ac048099a8c3d9c4dc0dc252cd12c003c94a9de9ad91b77c4cc034d5c4aabbabee0863ea900371e5e1ce1ae731b8a26639cecc3a161410b19a41394b08f633ae3d928e81fca18ee512468a86e6f26eafd3c095392c26d4b99f8ebd7e4327b4523813849a1bac5f6df016c9e778635f20d7fbb31715cbfbadf8be4ae14ed0392ab869eba1a811c843bcd477aff38c2c269af96a2e55448952eca557f48c3e1f77e3063d44db5dc62eec604bad3cbecd9ff3dad82ae023102137ab86e1156dff60af8b4d1256088dc14f1ffe0c89ddaabc20091dd5576e422ce5eb1680f6d5bd568ce57a2a2db47f633cc8af83685cd419c29e0a0e2a55686a62c44ccbebc3e124ed464eaafa2fd976e6d61af9044e8a10980b981f24e9019db0b7e397954c470cd0ef20ee15a57a0301e40627d0ca82931d0b1045448d7cb4bfaf23d0f0425b91c3cfa2e788decea04e2c3ed61a77fdeeeb4b216bd6b2508b36bd1c54aab2f6004cb96942ae26d53936013052d31f49f8430886813f2071127240e8fa01a279c02360ea4c62522a94d6c172600039642e52a191df0f6b8d8fe06fbdc5c53b97a0ec9ac46ae92d9b6f421d339915778dc93721a8d07138cad391943ab07dd010e2c249886c2aaab905d648125563a4d14c910b847338bf38df7c72ef7f9230fbef9e4cbff3f80ea667ef28cd923a0b19a081385e2053944aa50c7dfb62c79f2ac3df7943be06a5879c4385f0600d8b9e5f4cb057ee4306a5b8fc8df5d688a32bad7e0433ce8aed18b47bd8641d241ebddfbeb051b547df571d33bccbbfde357be869dbe939860db3a72fbed6e0543578aa70d2a7c5c9a749f0c27afb25f1a2d36f27f518cb0f6b96f5b18c035cdfdf47939aa4f380da6de6e61e02b598bbe7845e661e7a716651d18909ea1615a2364b521a91fdf26c1b76d922c9dccc80615e77eccd293f2105d586df5ac6304f1ea0ed34e672f0dba874f218b800af189d6774829e03284b672893d0831b078f19cd9a2aa231e3dd6871e127d9e604df3d6e85e927cc4b72c0d8e6b24343a8c9b2fc4ec494afecfe1f4abe2c18044ecffba78cb8fc085bbbf08fc1c8636a05b37cce7dd112bd20a52b1e2c29d97795abaa0661a218687beed87a7bf9ce1af79d1a8847f84f950d705816420aa9f16040c3909db6721a741334bf0603c368f792a4fd2bcc7674c52fcec73d547f89909256c99c22b8856250ef6300a9d6b8250cd180c0bdc1a09f4b2cb67b31195ee6be29c49820a04661e7a36e31816092adb23e4b78c2dec114d2ddfaa8f7dbbd5650a8e0dbd07294e592d6fc04f931df6f4b4d64d97adb8190abbf38e4d2e3b244c8caf4161423eeaed899eb8667e715ceb98d901e67109fb897ed1ed6d856af259d762f404d0533f7237c3a4eb512edcd2571ddec6c9a66bd577104e78510265a1fea3ba10433dc6a76353b3fffecdca34618c99b575f3223e8f50adbe39217a5dec4424933b58cd478f02dd7c9fbcfd0d85c43835af2cf66bc69a38aa680285aab344d111ca742ec2d655873c7fd938583234f1e954f85459e80d7af795fdc9b1a6601d9346f93ceb24247539af6658fae7c448da899dff1d49940831bedbd811852e68e5e32a4a53acebb516ac8e0671059462f95f5a3ab6608c265a670aafc2f463a2ad44ff19fbe4d8cb34485754571f5fb4929cd3d5585904e89b1eb2486059c90bc639017d3cc7e03855fd9d136753a90e0447c16a6de9661a46175e876519f0ddabdb08ac3952d126cf6e608b509caa9084378b0c2bdd32b3c47201317e45636ae3f6f8fccede47e979f7afe491250babdc70beaa9540c47f66c3123e1ea8535e036e4e9366e465548e6cb7999f819ae0b259238d53b95f6d548b1593f926961ccd0cd02631006ff4425eef3c6807bbaf7908de89c1470db015a4bad3a49b61ca83c725ae29c67e1076d4d27f7e212743a00bbbec83695fad02ede0a03ef18940557fd2a2d8069863716ad28959da8fb4b329c30fa9795df056568f51e4a7869b0491963c0d473ceb84df63b0ef3322be7ab984e18bcf31881573ab2ac64be8e31118f0ac9fa63a73e60d5ea6822316480573dcd7c030277376d920a9672bea66fdd820a7dd3ccf6e11ea83f4ae86ce5c516c6f56cddf78c5e3fcaf4f463327b27274436035bc1b4c907f41ccadbc71e9848c84a6464b028ad02fe3d6f49e1f93816d0ab8a67c7f73400952b60715b70452d58690d3938e5164e272c8862247c5ad969c951c64e0e284790df365d73f51cc7478b802ce96ce5b6bc23de0f248503722c4982f0e143dbe18d0fdb213cda262464168c4948b7aa170afc4f80378b38c3766801371bec63050a57b4c7bc47eec3681d4787bce7ad7382a32acc1bad6750d30913e22ff79c377baf74a4be9dd9f67e2e83119070da52ee71ac0319b040a2ec3e3a7271b34a2e93fa6f6bf49a6586f1750c25921e993b15cbf262ab2b2ef59e5bb61db418eef785e84ea6265207592af11bb96fa12939d5cbc78639219fea283a0fc3c3bf9fde24c871c4bfc763918c6dd4b4b7dd32c78400242624b4f848d32d2f748c8ee448ff156922d159855e46433dffcc6445a81ea865a532f20a8f6b5c691e3a295bd179f2db34ad7774296d06fab094fb5b9a635e015fb5f1ea645ab093e8c7cd92acbad77c1ffe6bbbce0140ac3866cb2750ea539be14cc4c5ffaa10cc693517264cd89a25a03cf75c4189e800ec4c4e4c37a313b40b855a577b738f413820b87cc552388efc25edae6d4f97c9072cafe88647a51055aa5c6755551ad0c0da9da6dbb5ef1d729eec88fba1fec20764d9f19381b26c229d1e3507cf1e1281b0752cab36cb8e4addce8dcb1b490e56809530adf507bed490de892baa567178f6e3c41b55e63c8e72fb3f727f88ba52ff6e510b2742aba9731da08be54360c6f745d72577ffa3b6fd5bd0def2021d6648740add33b665ffc983c50dedeb7c38c4824fc7a0a12f8c9389d9a04c399926a5ebee6468b8d60092b5164850bfe82a094ea5d022bdab3b880c92a485ba52e36cbf6468c1204602dcb59b0caff9d13377cb631ae4693bda05cf8efd95094971128205d27a2947277917e5861b72247613cf43eed10356e22659e3faabd43f59d9cb043722245050f691712010d10339dd3fb23e4a7029f230c8370dacba46e32f0a282fd9e49a2030e8e7d0506640b766cbb681534fc98097b4b6d6583f1da66dc8e3473f21677dfac4fb4db095cdf21afef1030ba6cf069a84c5583df8b02c04bd6a91d902eb0cc09de8556f668cc907f54098855a1e51bf87a900b128e834e2d96b470a81f593b11d64aae904000fd691509017407b7151a528d3df2bde8112956d6afdbd5a634cd210bf289e758f54829e5057340d3597f748aadf9c159b3e36","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
