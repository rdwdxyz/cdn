<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e6c199c17a8bbc6afc71639707d71cca6f50360df01793da1df90394d751ab35f036db0e0a960d17829047e1bd83a35687ce9250644fc868a20fb17046e34ab308464eda4f16661216e025095b53a0e0cdd97be09fe284bfc97dda62a1b2c8c4c86d574ac1f74646849f894b1a32fa87d88be36ec170ab1f6fe11af0d9eb3804be83de72e486b6d6a9933612787473cd42c61cd1dccf221c11c79eede1b18e1ed4bc35581e38af5d07c7e4e5c56e3c347899d13e5af923db3b32b756cb2a2758cba90048fa74b7b63b151360d560952d41958da20ce9ef42330c08e887d077c8b1e1bb8935b03de739d79fdf2bfde33ffe573672bc036227ec56da49844777dc6fed6d8e5466f644760c5938786513100c7f25aa825f3c6ea70f4165162ce26dc0b87dba28c5b08e2e397082951029ae985500af0492c3be284f77a876bd584b2b2126869a300c6045405ea72342c8a8067f8fb300b548783a1bd69d422d74234de881f8c3d6391ff2d0b9456a09ec7646fbdb6a3fc02b7aa30e6b394d14b4b50c9c15e91b7cdf9a8b7a6d73042a4bed971664df90ce92b5e74c6bf59e8d0fe0be2626ea268357345e441f0358104d9913865a5f318958a65e95d5ee6165344596ea9415dbd67b6c7f8de7f27ad8908923a0fff8b3c24efb10e93aa50b5f13934e86c067c894863c636fe35f4258af65ca19ad4100fe7d45bcfef99ba035536ebbd72646ea9ee46958019f31e9ac5e215e95cec732bc5ecfa66fe7489ad0f49ef923a4805690baf16dfe4fd6d3d82f1960a257c52d958784466df2e358d26ba73c52db8d74de829beff5763aab51490000cfecf389e0854c7f18b5079f845c81f3c60c2594d64e20e1ba5ca7b766d195945ba20df59635e027f0deb23ab87f105a0e92d57c2fbbc6937722f5d2ce5404f96be5d3ffcbce32eb2412f9ab222d9886dbf8923e3fa473096cf678e83af64110e8709e9b2a9d2383be807e8af3a80c658e0898efdd7798db59a97809565de2b5024207e613715f2427338df43d9cbbd7a983dd4e7793ed7797f08ab31ba284999a7286d47788e1ca529efae34a91c75e50716f77cd64e1133c9505c00ea0116276dec61c1049564498c870c8e5e4fdf699133fda5fe76184d62f1bd59df7c9be4396d6a78ecf3fd77276e83fdbbaa9c103746f5e92d8e7b687d0d19e137ad7d89576cd91db62c7e1ab79a7384683ce0f2172168ea88cc57cb6c1800d1c19159dc517964f332bd41e30f10e35fe36d458c92a845284b8eb338890bcc21386211cd44bce3ef36bed5f34ba7f9bf80bd32c6b1192c27cc5c2258f11b08795b32702c210dfa99329ec0519ebefedbe10fec865862b9c41f4709dd6a600bfc9532a08e3c735cb7809ce0c3d84470e9e637bbd6f28d9e394462911c161961d8abe1e4d5d0193b96cdc62bffe7f6552b8e3c8a9f071780a33e590f955b2d0655804b2172287a6b08c9643c596895e04df46b7246d99a30ce59dfdab7df194cd95a4d75153785fe307510c0da2345ba2151e60281aa08d8fe7d0c6f10a99e8199876cb95334a18060ea5b2c0e2add7d808dec8bb204aafd8ab57e22d968bc510260e5148bd0c18f9fc6e2a6600edb09c7f518a61897174147712a9a204c10ea7fd4454fd4cf93920ce09cbd9cd4deb28e36fe2048820ab49a77472a1935fb04402bd2b2a0cdb8b1477d721f4324d00affbb93b963825d0461c8c3484540dc0680174c7856c58519426701ce167ed2130dd14734f2cc0d2ce8fe5535c10409fbf46f5b27cfc9e72712dbc2318446f4141a931a8c62ed45b7da4a81c9704cf1e7fcf1821ed068f6b02377d4a62c9f590ffb8f56c95f5975e6ddfd56403fa9d81a14ca8f0094935552371c936f00b84eccbf6fd1a66609b9561ee382e5aeb49e1da1c8854f0e24a3830cc1b34cec50924343087e9436710e22b18b1c540fe820156d70fffd95822965f3b8764d8c4854b6d89b3323d6f8390a65890b4b2e0e8b5f3babd3c33229b53ab3f8c8766b08283d9e6b02995c5abb729cf5cee77d14b694c7281c71a1b11dc19f3e0cb2d083d8b0f98a478b9653d5df669a0d61df297d11748e1bbdfe2f3a4aa1197ab23be717365bc5fa1e43cea9b912b2596c7e3553d4c6e9f236e81b7830f7ec2b239f70a31038e7a98a79b02dd2df1e6f46964c30bcdd1ebed563668de4a92054e9631c279122354c1ecc19a8fa9c9bb0c725afac93b1fb13eb21f9cf90a7efbc1d4e9cce216a8306fd97656aba2f81a4529fb4fed930d6f91bd04c76f7abbe455e3d3646c30087e9b2b9ed9c6556faefc33ed6e1f1b482c6ed5d6a70a4ce3d03024e2338c294de314f33580b0f38c76fa4d0f2d3981d99a77b5e7f9fec4f92231b5c44f25c53cb871fef4fa3dc11ccd7c92541452e38460eca3d0dff93a4876eff77bd76fad8da170622501a3afb0f3e3725a57e35719838ee01754e8dadb2fe0fe75ad84124b9ad671aa6c1e466a1af79f2213ceb5dea177a252efd01a22595a7c1bc08a83d6ff8346214e7565437dd7239e4ffc04ee6273896a4522a9e07dd418675ae5aa2d6579a92e35b6036ba784df25e962cedbb3fb641e162aba88c8254ae2eefdd2fe841b19901a5020744e614dcd84a94d05e925b0b4488d64f086e85e5900983869ddfaa137aa44dd8b61c0936ecf9d4a89f925b581b0d27ff3b15f558cdd62596c47559530e4ed68873d90de8512db818e332e5ac926b1635cdb22b1f717efbabdcd26eb450a259c020b65b65f514056774942908ce08444f96e4fc15e14b6c8b4642e0467a9f178431a07ceb401fb7f044239270378f370a73f89930458857c86fc32b2fe6320265604e0f245fc6384515cf849ccc32dd6394937746a13fe3872675e9194e050a4bac3c454c20c2b0d9f98a0e3aabd5191b08e9be19ab56660645313153d2e9f3832bad47353b7beb0f8cd408178ef42995a0be44d2891d23f4b6e5ebcaba7473de4202b619397080b57a1a66b2473706b85f9ccea5b767df2f780522bd388f936e9b363373ab979ca9a79daf85714271fdc026d6fecfc4074985b3f623b6f1254034187cfe7ae8ebdfc231f21af4c644ab5e002de3a7d6e8125615773375cf56d80fd5146ce7b4c627c53b51825d79653411ec10537b3a19b331aaaf7af6801a3bcdbffbaa928789ed6b33e48cb489e3f4e99f5e4c148862a3eb28d86f0853a85a14e5dc1c52b23c98a520240fc2fd08713bfa2df333dae7603c2780a895f7056f386debdf28ab47f909b474f4da6e3bf4827cabdc201b49f9c6c4459ebe10df73e3270c1dd4b860303b24d91a2e62d2c610ad56db39703473e909e57b0777d5e2447382db8e839cdc4b95e7bd1f74bb23d54d77ae41de42a6bc5f0a0360a87109f9097a0360b0b1c1230a6cd4055d7eae1cc92d97445ffccdf3f034224823b219f4140793c6ea2710114948a287f1522cce6d7cf69c4471ca75fb8b7ea5c87bff01526f3a0181ace3282beefbf07e7df5af1f59991eff351b1a4f6606d54cb5ce0462c7ee405d73c2242000dd5292fadc9aa224bebcee54ec94af4cc6c4d1eb39d96fea7e310796e4e2d2151d48dfffe817e2850d5285f0123729453609c1b2c9f62beeefe176d9a3ffceaa71f6c85a78164e746c10804dc08a771791ef86930f882cee2f61251b68c4b6514cb1897fb15669df479a9ebbdc3013d73a65b5097ba42ddd136cb84e076b3c9a1c22303f71664a31e162a5a43faa72113f03f49cd2d7838dd12d8842b7b73a7b238bfaa66c8494768fff730a0331fbe51de4dab1d11e0e724dff0153258631d81ce1f746fe1781804abb4df3240ae1f2ac0179edbfaa8277a17694f566f13a6df9aa01d1ec40242bc1d2971a8005c66f6145ca491aae787223d9037b798513a79dca7518a073432992753c5e6a7d83c9a25fcc0b78bf663ccc9248818c60991303e61bb7465ab44291e06725cc8625aa00c594b3d49f89f31112b322e0a9438ab7d50ce611fe68bc84c02002ccbc21b6fc487a4dcc9909fe672cc1ef553420daa6de5629dc179c06982bbd494543b9f2f3465b6a0e4e68266c6391563a42fd5438dd9f8d7c3459d68e3dede81a02997a98d8b2dc800fd014b9732e935a6031575f272471013f890e8bf58d0c05e6d57f4164ab1a70b2888b8e758f2ff3c5fb46eb8148766bf2460a09229a4ed6a70aeda990e38f59e0d9962475ead20f550edbce1a6ca810ff9881081de99f85c65f39ca16e286e3f3bef322ccf7e3c2fd3172308cf85b182a8f270a51aaa86be46ebfebe83a302a0868119a744d71c309c50d1964c1250dc431114e913c59d8693bdbfa29f6052b722514ea5e32cafc0bc78dd415f2f629241c1ca792fd51fb40803a14166f7db690cc5ee29175cbcb2a56af554b6aeead118c99f2434b40503d9de82b8301589ec638d23242499ca21ff813e9ab57cd2da1c06963fbefc52470208184173c6f1b0e543fd53ff07d69e83598075cefc7e4e3a0f9f451580c960fdcda7a18acbb3fbaaf3a9e498730d4e73c37bcc879b29f898395c1c05ca59403df44bc208cb5be549502f26150b00d70a766b9740c6d166866bedf3218b70cc02e9453f468d209300e5e02528d51c2cf6e57e8f17c12a9b6e1e09b0451282f5cfc8d7af02349105356d32dccdb5a0a664ec6bf196ba75a47c26364bbc5f4a8e574827bae5edfbcc5279868d363b08e1aea596b4a8a925c1285d1283f21bcdc3bc0766c616a4509da5220d4f04dc0d9653d158886dae7ed8f0be93179f143dee89fbdd533ea9bbd09b629575692687bafa3dbbc2ee9dbbf57c9610b37f76d9afdc725551a6436e153e98879c4bc6d28a0c828b69b58d85c91702755a75609479bedfa7de6a6def7be661531c4547e73870acbcdaf0e66ff7dd4d3e9b0ebb5122fffc494e32b8ce1238dea32c4b5e21a60bf96f1edec132b4b21c4f267e0bc6ce1a5780f722cafc2920cb610c0bdd6883f3e21410b6d7b67cd71a6742eff6e418e231fb98ce60b689f6b996b3a0c65956df7b08f2734292e0c05bfa4e4623b2a04d6fa690d3f62d7f07a82e77eb1bd39c60e804f2e60ff8fab7f87b6a221ed3d7072e19afc63a79a33fb74b94698cab11327e45ab7f63d3e06416761aef7ab3f2f2904335aaacfa908d4188abb7985e34556d346e71cb90e0d753ec4cf72d8bb859d8a0049dee7cd8ac2fdb9c7a380323a9e73dc29d12d065370da078337fdc65075db94bdb6756f045f4686006a50c95ca7fd2f87ab5c3ae9754632c46d48c9591121a57f03a0980b191e98634f5770bf9a403f278c862bf541fb2c60a672f4ee0414e96d4243872412f49412bd97aa21b34521313ac23cb33bb7301d7f71f90d7804ffbe584cdd2e285d8e6212251ac3dde05ba2ec769cd2f30e6f4d607d7b6d854df7f12ff86cc2f10ca68695ee347215ec99c4f214ac72ced1615253ed19f6980810818c9e3ead0e9f65163bed642fe2efc867cb426231c76cb33b823863b2fd6b3987066e9997ac5bffd210527377457b49cf82f59d4cff83fd9a9944d8fb94caf9703fb73c0382e3f515f549c98b78d39fba065406ce31fe34b4196a985d171f0839705cf4f6ed6ec4dbafc2ebc52531494daa33c89d589343d5b993dabb382801fb3a46adf93cae6c322617bfa0ff4aa29a1d904333d7d2ea3375c7140eb0840bbb2188a1f4c0761ac94c9b6821b55adba95adc07cfeb8b5d4f1325cae85ce4f5d9ee8a26d41f200452642d8015d4b55c43f04c6fb06f1f09aecc49148d763718c01e74b8a3e00ad446090e700b7615e9a9651c7efe3a74df2d5b061509aa6d8db0f0610e6b21df93df60168598fbd9fe0240c5f15eaa7b3c25ca96b079f25b731e73f958d54f00d973d0a75c93f148f71576facb8f678485b1e3b3251d082d4cc1765f3dac53e16d164fcced4e1e48b5bb87be8c7522e470980a2f933db04efbb576879af6dc8025464df5d57fc4e9c3296e146b940b64bd77bc156686388e4b09b936d5d63c256e2c21c241f4ba21dbc16029c0eb5daba579134dc1f5f22d411e8a6d3dd53a1a9382beba31ded9fd69c9000a0fe766549b346e80a56fd8f5a0d7f527d177cb35445c596cdbd379ff0559ca5629f58ef402a77fe7c1808df4d974ae366595c9a89169a41aed8431816f3d4c1af889b568b14b38c45e15201a853b91a9026ace8ebf1234b74bda447e242b29b2dab7b5c76e79df57985abceb4f1e2e4fdd8c584a55026e39f9636cfae207fb24d9fbad91a3e18a7d76e15e697fa5da1c7f02de3fd7e24bb7a80ece94fc6f8dccd62af2be5c2f7e6bb138b9603112a096e1fe1687988ba991dd4989cafb62c89c5a36820f361df4c1b4947e29be766dd25fa7f390bc026286f116ff2bd9825957094d82e4c3da740510ba96ec5bb9bed3a80cd506c4641d3633255ec32bbfc34897b1942b91606f44f12fcf9ce145d150a86536a2337357ba2d3c82336f18a866c0c1ef16be36dc22b10161a5425f013e7ba4e66a8f4e21a1b3dce8588de61494f7e10508b34ab871038eb4a0c4f461efa3b3c26437d64eecb0f556c1cca50f87bcb44f4f82b7ab57a1964d85e446bdf443b236f4d2382771058af6d9ce225b50cd09fc92c2dd00e86bb2e8bb23bb8a033a599532fc35af88323708767a24784118f25ac5f28e7377f582c3a7b6dd6b7fddde96263583f4345639f99baf7de55c2d9c729d0e19fdfb2403dc475696ce7e16f4772732f31d998bc17324ede3b2b483be03043e22faa3f5129c31b7f878fd5239430f0bb5faba371e17a7ffb2094f3bc891fffde8a94880a46866ea1e7151391270596fb4dfa1f0163b8900724a13315b3dd98705e1d37d16bc89247a4b28dcd178c006eecdaabd7f55fd410d109f8f767361a51532be2b2ddf891596ceb4b0a64e246c476180b452d9f094b6dfb7672fe6494dd479af957d535edf2d3b7a4cb14fdd1cbf92d6309188e92bce5f72311eca5602558076040c33611b48585e32dfd6f1526d528ec0036c6cbd48074d9e0ff7954c03e8b8ab7b1935386cf616d55b7bf828a8168fcaf771ff79c0eff94bf5314899ac1c2e59831f9693ae8348fa3ddf829ad830e18002769edf2f32250f0c2c820d266e318bb3532ccd76f7d7078a41bb6f08e5fad44c6f4cdff4e06549909e0aa27b87be61c331fa0ead131817af557c391a7148fe3035f274786767469efc0170b080466bc0504f4600372ac1c1e0ec61fd57ca06002a10a8bb09e026f77171584a1aed01488a85023843aabca105d9bba4b63a27da2ff2c131a9ed0806d33439b358f9b781cd51e39075fba6144bf05a02e3fe49349b9945835cf8b1e8026769fbfe6ca2e01854dd95f9899094605e087d2f2b190cbb8946703a518af4ccc63681d48819122cc3898df69041b33d20f3140e0a5950286876aae8404f1fc4533e0cde46cb95cb86b81d7cdf386c801246599f4613e1f71ec013e8b16fc52d7d7bde5a7651ec57e4c079e3eb69de79370ab618f1bb7cd18766adbdfe4cfdd6527d03e272f4aef3a4d23f181891ac621c60b2d56518204c34c2ad6ffe6955facfd22f1cc2434b4e1f066126409a3b7a26e5ed944f66b95fb3e900b6402d292152626e6847c42e61044f71269c778e026bfae4e3daa8efffbdd7c9d655b27c6dcee11b5e74f12bcd529e246897bd5dd9a65c0be2095c402519404d58dc024e62774464863bb0dba8f31a93c7f8748e231feb7f9e509138814d8a89e92332cbb5f025baec97b4ab1ab6e7e9143e0e93c51140707eaaeeee60c507539e77d7b578b8e5c0b7eba65b1020befd3f19264d4bc57ac3aa793211cbe9dc5e9b1df1b9a82a1e13fae114fbf253325eb7babfbc00454f89f5704ddbd4df3c80c67ba941fb4a0b7905088d82efad32abea1ac82d79dd76803fe68ee03faf0a3391b998b5e7ed0eac2937312ebee5bb766bcd37e9a9bf867c39c1b6ec8aec5d9ea29010933a5b88ac15085fc3a0e7f4b03c4a9823784acb6ab85aaedc687cee13631b0b27269edae5bcd82f2ba585abb393fcd9b701d2bca75c29aed97a70527f15f5c000d01b9e2b665dd17d04a3a4bacf2b7b0ec15ee38fd756c6db05f69fa8244fa75f90a1e37e32eb4666e8e826af52f2c1064705c413e71e50a174b1d0b11494f1c2c0d120e2768ca54876ba86e78656339aa801c0f392a2ceb6e4ba913ee581317489fa20942ad85f8ac1a5dd2b0b995efc70b1d04da9a2714ec2bc2f2758513f038a0912a31934d3f6ca1228acb3a536d96bc7a7c0499473e1b183c03501243ace8eb3ce0396ae7e3a9a101f25ad0e842dba61a668e85b82ee6299b3b6d5dffe4104c2e5d82c9f65f1dd348e92ebb5b9bc6bec6ec6d902e147f8a41d1ba80af6b22724c2c27e091e35e6eb8136e9a19f75df4122e757b17de898b348e9221067ae3fe75254e2c03a60e083a987168e0f7f96d84be057e880c954dfba567b8ef35bbc86e29b5da51ad6f92d2628b3670bdb3a853ddfb31e4cdd9258c946dc927a10016af0cc7dd0662f776a12a0523b4b01ed21ee941d8fac1aa377c466a9c4255b6769f1e93812ba4c29e6cd58cb8c0eb6efa3a80fe5a2b03e05d0c1f4b682695ddaaf5532c0ba1a14ca717c1ba55e534758ed085112e340042b07c2b6b709a90921c19b40291d668cd16f688094c469278fe5bcbe54c9afebd8ea1e04f84a5e3bec4fa1b01b92cab263cd12cf233383b799e9baae1f74de1c3b8013e0fea03c81f4555bc6596e8b5ed13a52c3347f79117128d185d8043f6ad65a3a971c9195384738d0cf3aa8cc8bd2a5aa9ee8fb35dc7834c40ea5bfe04771cbfbd469643beed1cb640a95236b772cffba8063c18761183b7dbdf37baafb720f72a45f972578ea663133508cbffb8c9d484287f6ecd4b736aabc5dca623c0cf21547fd8788a519c3e52039c941a83aa90e8ff3dc244192561226ad837edecc37bc491af6535625cdc9d5d117b46f96fabb28404d12991c5a67abac3791eb3c0be269226ec32a064b32f3bdd235350fe89f059c9aa60bd5113ceb7390dbc6c7b14fd2ae7d7e6a59d37f8fce5c1e20b568e445c1c37891adb6e9dbf949fbe94d9f57163d7404d225b081b04bdc795ce929a5f56b4b342dab980838fdfef64d17f6993f023279bc39440451d1dcca37f3d5b20e381affd11b5d2316f83f2a6bf4763061a598fec22ab9c42983e7c70b7cc1ba2b87e1578fbbd9984533823adcd1617560af9c60b4992232f458db14b92d944fdd989a32bc05ef76b753ab2181726c938de9002740c41d3169d0fb2f66ab3b4c8f5f69cc28a86f605ac513d98cfc5a605ab74c27427e9b0f251862356cd794738c09b2eba4f5c999224afc6303c1f5276bf04928ae08be01086b1cdc3cb1728b07503a5742046353711257c5ab091dd70475707749ebab109e6ead7bc7777c2ea163d96153155ee3480bb255da33c588cc3c37d47205c3e168df46f54653e3567ef3098cfdb924f2c7816f04c503b16a9672a2d2db85d352ad57a33c90fc8b92a91185b3c9a801411021b10c97a020b3f589c95854495bf5f79f84634a2dec8738b58c63d8fd37b4f29157495bc1554299f135f25b18a86ad870646c1ec586516a36c0ae47e41a581f60e815dd6027a69abb16788edd98e8440f801c21f9201cfda5333a45d5df0191d0e6c89704b7ded2016905934c22811c3e47ef2ff6a467a825589f2be9563283172e469acee7dbabff46c0f8133ad6222c14e35cc53dcbb41162b43305ed8bd183c77ce97430f2eba7711b3f600ae9729c410d53f09c50cfbf7b29d3d55069c83ad812f7e47887ae55c99d7cbf604c09d99f6593904d0bda30a81afa153e6a51011ee03189ef097dab4971688a3a259ed524d955aa98de5cc916c6074c96a6d3f804c946dbfc01eebd167461be8e0d603eebfba00098feb09a641a45588f44010b5e50ab6be81be2311f12c4e3202f9c3dae7e97441e599353630465d0d60a1e02578d926a7a5e0405ae6139bdb14ad8c4ed2f4882f7247d87f0c27a2810713b709810fc66de442174cbb7ab7adf645b8a185b1f7fe2c1a70c27bc5b5ed6bbe234d0775cafea342d3e3d12df7400293593cb8e9cdef3d61f97dd5862e3f76a34e6ee1a6a91fef91b1cbbb5b96b6a09919efd19f71aaca970361e0eec4944c01729f79d61e35547da777a46e2e5ed4a7e09685e7d3e332151b234cbc0359db27ab4c954d9c826248c07cba160bc247c2e8ee0ad1986d33a9bb76a63ab3222258f01bc18fc65ed40986867bfb1353a7c50bfbf5021d37bec13c34f572b8f7b4a02b97ca177ffb1c2bf89d1f5f2c46f0802759ada4d4bc98aa92a1bc8e4c8908d0fbeec390c47df8b342db7520be626b941002b923875eba4939c44225d7acff8113d6c4f7f4f52f3f81c8bc764b4a61c3ddebad521da4ede759d695c49c1c07429f90e3ffb0fa47ff88f73bcff1322067b8a89aeedec335c0f052db6c209f84e2a798511daecb766a583b6c2d7060e2ff88211b06629ad43b9f0c96e69d89edae88ff9593ea86c796e844eb3685ea5b9821a8cd48ece458e2333b21826f92db5cc840b4304ff240f2fb96cd4fea9e78ef635c774aaba2fc02e2708731ed9cffb8c1ab2b666b4577e476d9f6af010b770f044c18a509ae9e25f65c910936025a4a36b1f55b60af9377baf50e585c14728ef79bd016d057adbbf91dbeb5addca28be9cce1b3d56204df0b5fd9823a90ce5fcdfc0090979f221a834688f6a152d5da0320605b06dbb2503bda435b643c54e438709f4a6ac8950bbb97d12a2e419c7d8bb45a264c40dc4b2d2639300956a311ad2e2a23fd76caa07313cc044baf79810035e15821c511c9fce37bd7f9cae4cde0b6e68641cf1257e4b11f9f48efa9c9e9769d9624362ac5a24fab61c311a2b5dc47f734783642278fa34bf24199022c2c1f6c336e8f1ad177e14241955740cbe93158b3780c21068c9e6238344842bf0a2e46f5fc642f7c2644b9951af2536a9664e3ee5b0e0d603545d428695df0506e78d285a78d7f8c6e642130922378eb2c1a924dc0a270399c69289e6cc151a0a2946e10b604af7539e40a9d95d7b8cb1e326ba1cd72e32ae0e7f07781cd9af7b5cbc468afe44e2f2dfbf69854d42369ce372b5d9cb67ebd7984be3dffb592556a9bea7d72e622ddcd82f1c94e83638e0a35680f8c4b8059b23d395da27a2bacf22eed3ac00c2f302a9ecc65ba7dc529d3f3331c0f9c5eb61a6a43d86f1aa2dc06ef99b660e6320a4b05b1a798b1d6d8dc6a0656895c862ea4450c1b5e2aed04e06fd296cb67f6481f713aad5790dc6b7404e6a66c926b2b0bce3bf908f1f755d66aa0d2c59097cb2f5d4dd5701eb2bd295740f6b18f1ae9b6c121f2420839296a3f134117e2375ac283595685cd4a18a456230c9d75f2340d3dc4b833135196b1c69c331ea41a92edf94f60e379114841d3d0fb11771a5f78a224f2c04f7bb0a532a42299694ae38b463eb240eede5b2150f2960ebdb1ada021ec4c6518e5095d7d8bc8d4215307416d2bb8b5eb42092d4d5b855208cba2a94a17a09fee18459f4bb9e7a92d048b9428d341106f032e7c525381e986b2218091549c922aefb67a77ae7e1f6b3348e2c69589049912fca938562af092d9f6b829978e59bf4f21573c6982c5701261261ef09f4ce5c1fa2e576cb13d3d6928fc92f7dc07353aa7e3a74df359075251fbecafdf11214c42da6cf2f4f0649acba1c0c24d837ef1e4055c18336ed4cc4532db0ee56ccf36673722cfa383f7d5e3c747fee7292876bb273b32d54f47de0cae9f606c904db54b2515795520cd00eb2d80dfb29239b1aef9979decd9652b34fcf0b97fcaab52e3a573f62bb7ea4454446d2f831bda0bacc54f352f39b0972a401a59190d5a25473cbb273dd5cc7794673b64a11cbd4639d30cce26af9372ae1e2c73ce4b6fdf55abc2abd71811b177947810ecfd1806617a066310933b35a7b93e25e952eed7e750a4e64e20a9c290046b8807e365545c9c39125ec800b69cbc6ed33aa33b36726059ed7c31c4fc0c43a688e59b51be1da4d6f0d3847346f92bbd98d88a70e105ce62c07e381d2cb0eb150af7917f8a806e18a80caa7978cc16b28e0125cef38c991070e8fc8590035580a3d7f13aa79294036c50d5de38b347886d0bb9f2fbe7fcfafd18274ca7508c45413995b9b97c942690562ffcbc2ca1c235e03bc3109b6f30d342e02e7e8c06189bc71bdabccb337b5e77a51f464426cf1b7fd5526c4459e9e8331dd1a6c7af3d8c86d04ee3b7aed01532199145bd7aa825ae088db7d6fc03940a9fae2c83711dbc385b1b92d2ea6683324b3da67a28dd352b1a8c9b9523e723bae53283ef53241a972442364f2f2e034ef19b56004a0be1cb7a0b3a95a3077f731ef0bf114ac4ade1d093f3c158cb98be2abf82573b5993c98f6e26e7aa1397fd983b9639f425cb050eef75ae604b57f303199e0d5e9c0d44a033a9c119590e45fc704415afb3dcc9e557a12ec250a04a96ad019f990671d89c6fdd9072933005229429c717c531b50131767eb7f03986961a42e763826a55a6fc7e08afdb348593f3b4b80a639a2e0f07ba37657bf26d178e177c89bda48d05b6f5abd164af038d310f09271abac8b77283d96eb55f76ebb69b75e38ee5a5a22d3e05cb0019b96bd88a259c31bf6f78e56460f8975bbfdaaeea7da3408509eed72e320d3099f76a5a511a5f23a93433e71715b6975b8b20df8b53bc2c43831d3b05b68132de5fa8877b20767f4f1a076eff26d98b416a561b127cc01a54d9d04373c580e5cb813603a9b8a6ef3565b87d31d43109b2c1b3a4f2e42757b0233fe01405345cae657df78609fd8629399f6d73d7209530b0e600fcbfc58d4c3850f8224e6d8642dbb16a8270e9f5750f1ae498875cae3d8eba2f5f784c884625e0eab52906448e34f9f9c68632f3ace850cdd3982b53cc3161ce372ac09e2cc745ecb559d0f6a228af7719a0f1eb842c7310a628b4c4a2922ec6ac87712cae031c5ecc53767d0eb6e054202a23a49030c860a518bc3048b815b53369fb52794d7a8964f14e57fc372f8821541757ca9d21b54704dedbc68c7d4cb175d5ae5cda41be0ba41cf95c52bd7ed4af764037ca9ef19523f10577a9cce389c86956d90bdcfe216dd83a8d75c9342373455c4c44740d155bc25ede02b24dfb43ee610590a138b26affc6f4405c301816032ca948694b8800c7072d8dbae4a9ef1a6edd3aba04cd8237db28f6e1066af8d20c579c8b7d08cb847d7fb87d9da1a486a5b9fc91f83cdeeea54f714921c044b4928bef4fb55f21df3d9d433b7531aee8de57b23a583a653f9a6ec0d382d0c24c956db314d9f4e395c0e82f240ee388080e98d122d5790901d3e402d361df2bfec6250fc4e67c11381d887f5ff21e937fc72edf1f497e1628ba2e6060b81e346758e99acc7d070b0e968b30cde74f12da12b89de954f4ca556adce02c5c74288ba02d2a338a6b8c53f05c295b0ca6179916f81caf2ef7ff3a8eeda468d1a5c416d51b6deadb20b455976a3257ce796084ea0d070c698316c53b29c1d951428f35481d50da316999ab222e478087f3fc2f96f3f4c248f9df37d32c51c03be11b7b716065ff5c61fab3179152a50425126846ac96e07f2519ce0eebd91f79003515a8bb24dd9050dead1eb74a00897d8ecf1e835b303045c9b69de346622a03b8eabbe9d4963bc2df0d6b097e85313e747180460499fb4a18e9c7c297c83cc861ec8858145c9eb67a40f9a24f5c66726e7a8e34753873e765f7c86ab36e1616e0c03fc6f8e8143a73c8cc40786d0aebd515ab05274de8280be5b11d2429ee022169823af0eb5ba97f89941bbef98b1c7b5239ac9b62c7882b2b1aa0acd0781b8291658dea9d117ec293ad95528c6dfe3b94bb5ab98dbdd075c56ca71c0471607bb792d4a4da291c5258850e307b867f6df396a79efd48ca4411a4d6a5352d5b05d6e984cfc4770d15df902cf2709b228cbe1fe452ddf85987d2489bc8b53ab511089100ba4a0378709728c66c95f4e13892e898fb5b49248f607c2b7f0680ce5e10865ad4503b2a228c2728e31f698b0cc96121446003f96acf519a7df5394c1bf2b738dbc01132c9938d806d46dd1c131c05ae7e0120d4de93d2bc5abcfe0990c7581691f6a6705a10f2471cc5f8811bce1ef402a85c4d5ce079adf605fdc23f8013909e9e7e234e40a8994fcb09c1c4f9914871984c6c5e480647ad509ef6d9e867401c6ab537cad146e703e754af60745f802337ad7c1b1e00dae1615859bfbdd6834b5d41ebd92fb9b1e528bfbc28cababb6e6862ffee05b945f96b19f57ad8e51304623ab9532af379add07b6012a439d6bd5b75f7991d83fb2bba6ec6162e7581138e7a4e53b7dc86ef79149bc79e6664fc5cbf4f52e482c7806b7b568ba571d68ff4c6b99a6ef914703fbccf4e73aee97bc1045792bd5f0e705a3179cd4a2fa485bde01dd337be537a476bcb508a5891171bdf47d482f08c650d562f02f2f8edd1df38486d7d169e4c05bfea2db3eac8326e03699fe2adff58e9e5106ddecd2656c6da01654b6c68ed329ad764755df2bf3b0fe1be762373066840ba53b63745f0f497af94c27a26adf170179a087a4c13e71df30ae780e3937f8b81e1971b35d4687b6e46015bbf544dff7dcd6ee52771cd9f1db6f27395a5acb4e80acd25119d43c6a4213ccf505dcd8606697c9ca412954d3d0dcef801639ec6506fe790e4b2e509667452d3c5444eee8502bf2c58fa989247587a527589fad1206ebbd083cb814d4c2d6e4cf4584f0f31d3c7b68aaedc99d0d01ea5f66538008ee2564b994a0c07347079d793ac30721887b8dcf61f7ad0f66c078eca08b40e3109c11baad2d568c8c6ad173407f16eb20a7eb1d59c51336bf70e4eab7c19e63060c958dde74517d79df40160af91e985ecbc168b31085cae1873856a97a6fcfec87ff4eb5ff8168eca24a2bfe0de3392f6cd68efdeeeeb2f5e71121cf4bd77c0162b7abd5d2d0104ff0e8383af6795e0b7dafcd89f03a42afa6c9bf1aaaafb4d00a3fe92f2d212bb458159595f056bd805ff07e6f390250edded48a4dffacfa2cf38cdb0bf1bc8458da046acf443b453b4b4c7ef648ccb7a20ecbf4ae0b1555b63a0e1383ce93a1b1b3e4b1a65743cc84acb3cc1977344c576ffb0c48806011df5651d2e8bf8795f19e1fd34fe637cb016fdae6451fd08087d20008979d59bcafa2f3d02f56c8edaa443ec44693cd12641197314e9ec5a16dd76a92ea504d0e636af77b054b5314d41ad9deaea6dcf373645a241c4fb410cdaf2d1c34af42187300c3d5d81fabe1a3e6b99d71a56723313a581aba34df48a7b56fe2f471c82168c6d3c768f821207b3485df38b34415f050360363cca4fffc8d5ecc9ebc6b1211e916b0ce106672ae26ade749c6479d5d3ced9df0c140185db4e7e9c754514e18fe4f7fe02cfd48a093872cf5da793f9e96de876aaa2b0c252557372e247bc845264815eef0d29f763a1e500614458a4610e68d3fa6e846e3bfe9caa73bea4e4a9eb05ac63c2e821d3c8eeeb8a647f02dab640123752fd715e36666410847e101dfe71fa77631a3a5d857fbf37fe31ed023d815f64933fe94c9b6946980b10bbe8c4723a0b8f1681d410942d2200e1239891930119e1afcfc234c4cf56e33c4c6a913b7d9241264dbad291b62b7009481987e2c6ed64b68788782caf46ddb11f37b6a2c7cea6f9ee4c3a475c151c5248c44bc944fa2b40c93deb6f18cd5438453a3db9023c53feaed355f550a4b539ef99ee4bf99aaf7dd83156c71ce389eb9a3dcdda2b80f5085b911e17768b8552a84afc8c7b35b58a7f20f131afd2340e3d418b8c2ce0af81c2b207d48fb916fd25a1c63a31b3f417b62218d112d80feb03925fe7a17073f26a2da5afa3fe794a79636a735526baae404583455ae616e16180d0a850bdc542ba3a9e32e9636df19f455ceb7b3914e5a55215d9474d5b9eb9e1b9ce265469d589bd25ff47f2a9311d0ad441793860ad0c3007a5471b8f134fa6e386625cfe76a1f3ca83774b66cafa26b774d2e81a539a8af23f14a92e1de182cfbeae36009d6704d6efed4aae393198344d2d7f3523624a1bdcc3569499f76038f34550494832814a53e1b10f8e1936fe7694f8f5cddd24558925bef0a06c1a1f592875a8596c9d3291b02a6a04ab14a97a5d8e4d71418b71c1d371228a52c0510f0dfea815bcfa49100005fac1ce4878047e1b45be833a3961e18d3c5ea8641a2975042931a83d528f192377e81e9033752dacb3c89ffc7b2acb21bc144f4cbe2530956e8a4785c7841d054047c1254c6ede2a40055bcdc5db81a5dd89342df7adfde2238691ec8722ffa5ac087883a784bb54090d8e7c7086d33247f89d003a2512e916d8408bbe680577e18503e03408523d95b245307fdb61e1682c8c53feec81d99065fba765baa1ae412770850b9c8f60148f6b7ad8252c19a337f15164b3026cf209be68c4ebf2bc1ee5ce9dfc2cd615411c519b4b66ca6aa3136aa74946668670699f698f8195915504ae172f7823d3f3d57d04e7b8b68ddf3d89c630eabbf442be2012456da726ee3ce7af27898e56da9786a69213229be3570dda98089339c5fe41b5999bebeeb8b4b44dd508d9d9f5746a3aaa82ea0ce5570bce9156d41bc335752dc9e20c741e41112719a5e0fcf88ece71fe710c0a77afa57fead81ebbab974b2ac17f7d8223406b0a6a65c455f08f01eea694e850ecb8d4bccf37887ac6d6a6edddd6474d6657a9d73f0f09f112b6883c1ac6aaccbafed3523996a103122ccfe0ad105fb72430013f3928c51b20d8dd9fdd6d3d5ff4f6aca6c8a8edd0621938581ef04a0e179fe410be0aaebfcac6abe635e09b7312fc3eafcbff8b54c8eeb1fc347f16e6d2c7dadc0587fbbb161f4f08a5093c092c8b34429d491e546d125c493619dbc5e99061800c61405e60e6961f754ff07e83db817699dd63345bc29caf60fe6ac77bf5822713f5742cfc0ec84a5c2d8422ec0e38260bc2fccc529690f33b355b3c7334b0731d390db4021f29dc74381470ec8d3d72bf5a841390c216ec354d5b4056b5094462b29b810c43ca87ecceb8b5ebad167e911597e28afa47303b113722fbb08c0d76d705b17bf79599fb240cc9df297e39f58041f8d53d5a82fd20e209f3be3b9f6fe86857089b9de77e983167ae4d6fed9f6db55665acb1bfa7e24257d9c385b5d7b22983a9474f1a97417323a65d184f7d24539bde5f231bc8b8d80eec9a0780ac0a912ad23108ad637d0dd1ebd2c29dc227319a80c9eab7979574fd56415ada36f210cb59d3253ae72a4e26f9c7146a09b3b858d59e6fc4e5233c4d923de7a0923d6cf79b29b24d59058fb2bdb49ecf6bc18886b2ecc02d91bb970bd030bd22895c3224dbf0f80f43fa06ecda13aa110f69d3f27d28f6e04d2a3a9c9fb85b72b14fc9de5d0ff9048c4e309a665f45221d45dcf706a520115ed6554a4f05a039da3e90714d311eabd7b5c330799d583d681728518af7e92261688956390fa910579e4d64df351ea916a4f7dc262a1a37de19846fe6a06ee60f70da6391f9d2a1614f71afa7a4195fe09733dcdfe75e14ed1d2079b431b83bf77cf13b3e9512340efe36526b08ad4074eaf2f0ec6974ce21883ebd463763d8e7e01fc5845a0647d455dd8f2dda07f8246eab18fa8d3203e3a478b54f8be1a5af47a366d722cbf4e48dd8cee49d6e57abd4bf0ee71c1017712d2f49bf0ebd1972022698206eb9b421c99a0fab41e9524ad6f9d076665fac5f3491c66fbe59f857150dc0a6bc70f9897f1a3b44af555397927e6d0f784b2339b088513727891cfb39bca26b60604b57da7fd9e07e0360d6e78bbe35b7b54b8e5dff0056b6709e36666b2852a224ce3102ffcf55823b33bfeb850ee7f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
