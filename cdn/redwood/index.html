<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5df5f618e22bd936abd55606f57ef484e192cd13b6c89ffeff77375d74904d5360aa2196947f26a3cc09bad00ddcaac5149a6b2275d88684f79b9cc9ca73c59820aaf6bc82f0ef9a8f69d3e36fbfb9486e67bddc6cc10dc6a442aff7418e4ddad9954f3fc6b133ccfbb9d4d20783de1073a91f59830373618918ffdcf015ee120a1cf239bf7921d58e372bd5c219ba836c8839271fbc52f348af30d8910332fae969f85ffbd932ccef4af458ca4be41af2425bc1e7c255ea7e59e241205c37036baf7746ba665fa7e364bc6c9fd3ba38aa48d8ec07008f303a28e778b9f16e496f1a581b8b7f48cc2e9a6ec1e909199b21d4557769b58e918d4ed6b47daf4c9ca1b17c980436718aebccb70c073e979654149f997511646f8ef3b11da3e4629b6b0e7152f83db81d3fd0feb629aae64d3b3731103fe30842e780384a83d655774e72db570644c85adbcfcecf75c6c23aef10095f4b2ec88a417c77018f306a513bb1b83634e9b924661b89b8a1e67baa23e3d3d97fa3e563a8f22ac86c20bad9cb31a989df828f4b2d3331abf86258a36df4022a0e664bcbc3e60ed0f0265c17d68f5d0d73ae40446a72217934ee5e6467007f99b7a25fe87ac0f802a2c334c31e3e8f7ac9723b1d1f396438e812557b57409b96747a90186c38d3e4908dc3fe24e219cf599dd08fd8adbdfcb8a5a00de2ab16a8b4f3fe0b3f4514241c54ba1527c58e00713161020a28af8f3828808e65915e3e7760904bc7018604832ff8cf67bd062e4612a0f29907de38d2f42c7ec32ee4be85e676db602d042cddac4b24a1e6d4a816f4d87d1fb19403d1815967aa32ab48355e7f9d9760d21580484df32572a1e2feab74e4f6fb9b34908647216cbaf1f32507e18f6d2e64e781253efa518a5a6d96d26e95065ac9f1e129ffcdd5fa7b9b44c8884d341b30235982248ea74eb72a324179acf0d282824e5456701977c8f0f0256088b1d265ce4c273b7bf02f6f0aa4f3bba4d959e45c3c9022534c5068f840bc433a0770d5c71d503db6013b095f2704495435161ec6cba0174500920c5ce2a9fffe9bc0c75aebaebb344be6204da7e1066904bc536f0089318ce136cfbe9dc7eaeafb1789e070f41cde2c814b059b825e09321e8ff7028256ae191031feb8690adeebf81b9e05311406899afe3a37f48cb5c1db4f91ba5871bcdb17a2a1392b220c724ea385dc32867cc21ca9a0c9c8b8eba04687f27967036972a1a8c94b50b4b03ae52befeb801400860473e223a55c7c53ca73f95e50e964481d7824f169240a44b54bbdd6c935d41c36bb568563e7ac6e960c172ba7cf2cc6f8585fb1bac51ccd77094dde3010648e5b2490b08235babc3968227b3e221ac67815f48c84318c7bbb5a59089aa4c57a3a4c6ac159d5c038d13be038c4cdeac2b969fb91cd7fc5539c11e9dd03085dfff11ce73137b24c19837e4f9bf4277d79d14b4ff455567ee26a5a55c3dd3a0fc570280a903f0024f718296bb23bb4ae7727f62534067a54bb9b602a44f9f35bfe73b28c1bbb8b46ecfed1d94070cfa022e23e2118909f96d0aa354931e0cbf60016840d83577d548e79fd1bf35173b9172df9a6d8e1afdde88ef4ea4b9f7f825fa28b7ab45f4fd577deef02de751ea536ebf75a7a9ed684f9fb7cf02509e6e1b230e053942ffdbfacda4de168c2dbac55a31763f59719037b812fc8e5e1a97e8ae77becb7ec04e8b0ae62361c91c761836f5fdd710d9254621a0bcce87ccb180d02c90cba1056a04c1f69c9b1d118635744960930085cdd82cadf80f903c965de28f2b27c9a606491dc26200f42ede3c9ba1f2e28b99e9db14c51c13cf67d4626ee8419daa0b66c039cb48836c3e82e3bb03aad8a6cf067f8b023fbb78ae1d046b7a9eff79a4e09253f5789ea86b552a295a825f40158737cba1208ee76672c21adc61eef0b27335e0834c52e8ae96607af6f05ecee5af04539c1d1e54d439b664bf51a97d19791c0b7e8f64838804ef41d833b8f7aff421e41b59e66864e1a27f25f6e2fd1eac706e24aea975504e12ec4184f5b55c9d640f0e3e9a4523945d35d20c13a16907b698ae044459d2daaba6cbba40b6b59ab979d85438b2d2580b537f6dab55111b058df0fc28556aadc25b9700047bdb41d4cb050a088f8c88aa36d8268c19674c413620a7b7e96cf137d9ec596083a206cfb23f380242f3de77f5d37a7f001ba103f7bd406986a013605624ba00ac2fde0b2ec06a0379fb5e6674ef84ec7b0f9e67d434cf83fc3837929cdc1186ad4a4893a23b1be1643ab75a456720b1c5b5a0dd549d0aef277c29e5da63940679929c530e5141502a60f915f3658a5b9fb95750f86cba60108854ef9f2a3b8470f45b29f1369fbcfbe22ac3485e526a32da138583089ae97e29ac19a454bfadf71fe98d7b2a9e5cbee76c10712a1d8fd3f90788436d908f62a062d4258b0a8f128f417f470f1b0b63f962e989f19ad0f0a0d180547f8f36e87796941b141c2e616f623aa467b820b92f3c20b478c02f7daf680967e36d81b153d54b59ed9745d1f7aa45d47e58fa632853930fa15d8e7d326914210e5430ad2c40c4ff3c84ce53b933dbf2e5aa8d0799392a01a6f2f4d07cdb9247889abdcfcbd7d4a2a0ebfd52b7f5d9fd9fc9732dc8c78a18d5a62c296b27bddb97ef9c82153cdd6959a5f6df6b654267915951c709f54b29f0235192f68528db9afcf1131df26cd94b2e5ce83d5d679c863bc86e2d25689ddd5e478bfb0fde83f1f0cf211b793c37c00dd331d55904a4322b08409d81842e17ba7851d966ff75dbd0fbfb1136010aca7142e4cdb1796e96dd20731313a5c76aabcdbfce738e52703f2c475e71bef47354265738f5a2f41641e8f4b8f6ff8a22a5254980f1897b8749ed58429e32f16aea799c3af6f2b96bcc6ec1578123bba6c017ca975ce74f39916ce77d7c6812d41f7ce8d640a3f36feee6b63350961e71c43a347ab500b80bf36dc18b77db0610639a7ded62775f1916002b52182759675d842bf633cfd1754f1e0e3bbee1893758ba322460ccad742887b04253527ffec63cd343c018a1ad2b1b5ed300c1c49cd5354cc148ca3e369a9266a12ffee92a6f4a3e2ed48cb114c135e748cbe60b94318d2af41820e986eb9e66b378e769f86f00f0d09d8e9f81e37ddaa42be29d86862e4de3fb038e14798eaa1db56b5d3dfa553d91cd9ff5287c4e846756bb80f78806c3e005c2fa77ff17d659fce442eafa8d945f7eedb513cf3d1064c453eece2c46ffc064b6296817f8b3073a7fbbd29587796d90a72bd053d6493801558e674c763c344c1888b06481d4556dd860c2325c6cca75a4a58c343e90fe1a914f61fd8bebd0d914349985641a04452024ecf1bac13b43298dfa7e2c717564c7ff0b0de6dd9d402259345f3412b30c94fcb55e196ee3ec35cc3df6311e1042607418cef571d8fb15b02990581f1c8b5de72beb28c61a4b0df07d0619c4b342bfeb98308f3ef36f6ab90c67f2b74d2ef680f2bd7e0e68d6ea22227096a3b62e6d56d5f68e8765afa90bf31ba6eb65d971e5d6a53eb7344f04db78742e3bbc9d36034bdc649d295b2205e6a8cee42e6fd34c8b5e1cd8043edde6341f62e4d47a0a54423ac025e5247815b4f1c392dc4d56dbfe3057da5dd2c08328216143d6c7ec3095ad916fc9fa5eb9623bf26767a5da1a890ea094d9e926e6196e23e40d4cd89392e165fbecaec84ac79730d12f43111b1c6ec3ad34c5327c1fbdc92b56cdd5ce038ace95c068c519d4521c7026860f889704b192406ca928d4b56f1a70cdbfc285231a7d9019faed6518032aac6666b02333746785b60ab191a3f1a7d74a2cb681ad8a1e38bf91207e633145b798baffca3a1f66a4eb5398428b08aa0485f68a122748b125dff382ec20b35bdd96de398c6d2fdf6419c1ec8ac269f66946b68568c58ec5e1aa320c16ec9868aeb93da5b5d78d2702b2a4fda9e84485976848edd47e7795b3f7dc1d0a0df2353d71c2abba16e6f565c5af6255ec3111446985ad65027d03d9ed4bd7ace52b2a63d5c29defa59bde7dfa2188b39737dac908094909c1f53babc6cb00c7480e5330fe899908456c9356a1c8fd6fddc87c720bb84ea2866b3cd0c21522b9345cdd0fb90237b978ff54100ff5f060b19f3ae44e002393558d8017edb5dbebf8843733d277acf5df21f706da5655cc280ee8fed7127a5ce40a8794b7d6a3f4ca2fe810662d5ebbc5a714528c3613d5f04ae02a4e8ab53de2aa61dbc322f40cbc60ea3f1e41376ed050bf0053a39ab8b385e15e1f8a15e9a0837f1b94ce2ab19543c8db8fb4f96339fbabf4e845f54653c2d972035ebfe654309ad0124cbc2f02d8dfd3b3d1170bb5c2141d0f5f0c246cf878a6db6e9ef8bec5e795cb636746f1272db848554c73c2d4678eabc9bb9ae5b227c8de7128575f82ac4c0fd834429324ca368f918e872a4eafb9086b42b63792f161536b5e4d8cdba48d27c9fdec25b8f199d61940e36725f97403337c6538d34d7b381048303f69137937fa877a9c30acdc781acfa337f1eac1f5401185cea0e95eeb67a5047e42d9749f90305fc1c747b70532960437c94a36d63fa9054732aa64b2c6b1fb26b4c713dc769bf7fc98288ad92de9d05552f502541e19f06e9e3a6c19d7c7aea1c370928ea2e9a8f6de552cfbe164324b74062929620d1e721e8ce93d730eb4b96fe2752f320e8b1b9fcbf3977b98e565d4da133dfe20cf94426b294b12132d809c5d93bc0d2c7ef14a70ab77bf8d31ad6af78b1e734dd9423c42056ea1fd358e71c709ee887d64831bd6e8b971cdbc1a476afdaeebd06ed3dcd85909b1c7d73cab7e7742766edf59fd5221ce8836268f557cf8b756c4d3ff1f3f6f70f349b8c4137ce29d0c6086b47572c3f4ef842fe04539738340f78c92ed834264cfb80425c46055cd3d6f8ea1332e6024fe2dc9dbb1cc31d29028cff3ec015d0a906e02afd72c8a45ef2a69af60beac49757b5e09e1a34aa81b08505f9ddb958ba550342476c6d809e67ade4eb64a25e41a350d75f8addef46d0a288b22b70478e5d8e0a1573aefad2b70ac488aeb8ba85003037c93f5f57c42ad52d423553aa80f40a0150de1240124210ea80b12b42b5b60a90db7d6e095ecc5db607ee71af2b12ad72be9878b864ca0f84f7cf6cecbc138ee3355636b193b276a691e57d5109ed5c837c0186ece9ac7c6732ba8f401d00e41dd6a6edef23b319d037ca0b3e68543e5ad3c5696bd23c867cac4dbf3e3078a0741a42b6cae98f39fae1ccc8476e0d0a1e3b02a27d174b4c3262b32bd27de74ec0fd466e7cf5b441fb0fc434173d94ed46ac1b4d8a274c3a4792d86270a7af4750a33a83c3cbc12fdd832d8ec866ad388503af87ea633ac730d2ab3fb3975164b270e7eb40d1e8acfbdec3448b2ae420529c4c4a8eea1c229ffb6704fd449fe54d0894d43d49e55a1e5a1cc9f723efea62f164bb6cf7aa683d47d38e30b746a923e3115e6dc37308818147e80d2486f278d6505461d35013eed084dfd63372b858ae69cb4dee0191f4359e06de04b54b396cd6c315952b0ed02658bed1f96795dbfa4220502816cfa7cd60751e1cf92497fdb7f62af6761b96c7cebea616246f6eaccae473836ac0e32e48af8b1c05169dd17c1d43488c293a06031b98d791794a43464b54ec3398458b69ad00bb0f8dde51122e0d360ee78c3b09206dcca8bae23f9500537975f3e667842657d490be381949e5bb951dcb9cb1cf817deb3e9471dc4bc60ddbd576c9ad35aeb2300c3c7e3f9254f388c8593778fa8eaf9177789466190d0c845c51e68e06bf0161efcbfb7839cb13c15393c9b526c057756fa48c4b653f909d38c4f21cfaa20801b8ff2d030b0c11729250abedf821f5cc9d45221a89f639a04afa775462a018355bca12f7876d58e2d247c6ff150ffa7c524507867491654eb1cd175a6570525c955770e39c5ff6de8cc735c78d943df2b927d3810465691495b67c3a0da0003e29216e5fb051b8fb70edad385a79edf736f5f9c19ae0029c5e27dc9712bc69d16adbc96d58980e697810afc548399763ca4ea97e1eab97f0c108df87771e0968a291860c372569bb9410c8fa369b48e8be7913733dd51ac9a1ef28a5d203077e832bff1bdebcc41e76f0f5f73ccd1d86e6ec9e2eb228fe0d9f74109b05432b69b6ac1daca00da1ccdf1a62c55a9abcf412003b9918e2087bea5c7e56bf1421fe9fa2051462fb321c2f928aef2db64aa8d5fcbbb15a84ac15990913f596e99aa40edd8f2692a5a642f934c5187cbe3b7ded1769a3782349c1625dc173ac5f124d1c9d782477feea6d270ba83da1486ba8e0bc875456a9e28c3ed692eaa3d5bd19b70a877ebbaa4962ea86cb65e9fe0f53451cac64c8bdfbae0ea3d0645bb87cbddf17225294c3e97d0657441b11c1c23b82f835e064dd86d42f5e065c03ebfef216f3931dc142a9f82860670c4e2d571fb4347242a243385e5743cbaa66423830360badd93bccbb2d6737e7f5decc8216e4f073166af847e673c8c3636f7e48beda453147c01be7894fe412601e976ca0e81db91757d5d721852409470919d849ce461ba7116601fd0a4d1028c6a2642bc77ab2a57f20abbebb31d7bd0a850ad08fd88590204988dee2e7383943ae5ad6beba57d3bff0ba7e5cfa6cb96a4b06a733ce0c5bdb89d1303084c5429941c0f7dd9d73cc9b9592ac5e1fa8210255d8875127f486417ffd2edf8632c9efa4fb98bf227fa3d64dfd54a5cb806d4610dc256055e6256bc4c21c69df8eb8cfb0639d74facb648ca272634d84404923d4fc130b72cc53b5e010b3fcbb1e7f63fc91649bea3fc9750c2f82a16eb05e6d5cd87f7962a87ded5f9856860aa6a820caf05afc7949ca4da37bc436cc96854b6eaae2b413e68d034630bc17b8a93480555d1c3a1cf1f0ac1342161ac7b7b19ec6f1dfe45b26735f8a0f4b0efb9a43db74a844335384f7450bdd81df74097c040668665058c4aef17c635c70717e4c45e60428c42bd86717e21a7b12565d389759cfef691c7bd65ad224498f4ccbef0b46a96aca0a6f3162f06e16de17b92e455c146ede3ac2c07f24638981f3b11436eeb57ccce280550cdd8ef549019a9052f037526dfd446dd2a6a4d5ef778cc22f8da5c0dd14e77c0bf241da215f2861fde0dd926e8ac04e1308f10af26b4c6ff349dec458f3a6ed014daf96aca5bacc1af5bd63c9bdf758c03e8191c98aee564b26745d94c8a297af24201cd04c741d9e6391c6ac433092b4dc8a358376a5b75ed20c0b8075bdbd4db470659ac350762ac523fb84ed530a2daaadfb13229fdd94cb81e386892d2fd8fd03a883a5e756524fa3484adf10f9c2f881363c980e2fc4373e7166dff99aae22c9f906264689f2313f480a6afa71eaf892e5495d7cb41deb8f1baae675de426cd9397f7dbd4c6b925b2085b0e1c49e2f0dc9c8e10ab960b42bb2e035e2798e9211d18029e016b498c2aa018d69c7619977f09abd11882ce3bf0a0cf2d3f9f72862a6fb78ac594f058a4464752b38b0210c33077a8d51475a090de2d7e26973ecb41095416b69427c0ae2d8a9eda12d9e364669877471ee60a8d0fa685d8bae61a75494d44da088ddc75879221ce740975ba03659543d2d2da5d8df296412789f4e43f32cdca0d981d9c8988ee88657aa69bf27c366e3f68537dafd9cea7f72cf3776dda4be403152547cdf24e49e544174c9748c9656aba2f5e89cbe3a30ea14129d2c79d4875525bc8d82b300aab39201a4618860a6aa982f8abbda97d11ef6fda3d7d5a0486a03e6681672c4b3e03f50578bb8296283f2c4d24d3ed94151ac5e04d1f82409d6e32f5d679648f750d74e6c117606721f6301c0c3a457e454031da6d70c9c8d9ef8242ef8b315e1074a3aa088cffe24d2e2373dc939356592b9c048a9d5548ca0d2e5950686aeaef2c31c7985ae40b13ed712b2ca0920ce8b6c86a3b9591a2ddebe38665bee42916572e0dac43f587fec2c8dd529530613062a2611251671b147b677aeb0748b00fb8b6a43f7e61ef0ac85803d93b29b1f25bc7029294ce5863dd4f7259f74e3210e053a28bad909e8f56ae5b6ab6f5c8bea252e98ea4de5b352932d56b4d6b3186a22efb7df93f58983010048d8e3b0414ddf6dd7fee533626971f6e4d43e504b05b340d11bdb4be27a6d728fdf115e82aa30e7ad91b0e83546e2e459bd644ae2e31361cb757600cc48b8a52936792161d5accb0ebad12cdaca76b7e55aff3dac619c2171289248eec71408f7341d00eb82ac98d735131272a57bf1b906453b77f56f3751d1461d427ab099d8e304dd43eb28103e64c54b319f4b9b538172b55c7a7bb74a0a5e5ad4609757bb8822d3de9f43685c2e5e0bd142495ecb7bf4ce6c8f3be383ac80d86fc34ccbe6bf1bae46a9780f42e06c804e6b6560d5c4eb0ab79b401c67122e531ac9e3ec85cde4b83669a3f5a8bfa015154e9bbc830625df63c7fa120a14e41c199e6f6e6d5bd75fc10213ce6869f32283e9ac7bf6ac13bb0f2f164b87c9760e7f39e4117cad24e742264852268b7d27441411a72d13df1851782f7a0d9edf800a02e7416c80ddf2499dc553f84eff70c9242744f25b6c2a0381480faa552204aefa3e97a20e8a11db8d0837a5a77df209d3a2fb8013de89e815243b42b016e7c381f230885b670546561b25b6b54abe816790ff44852c1a4392f2e73105c868f26acd658b9e04f08051c766acc15944a2c9c60c60b4737fea3d810b9b675fd39964c0091cf3d7981753fa4594d6315e375231780ee53c746246e2f7aa34bebc18c5138099dae5956c4611a1d0f669e8a2541ab126c9d53f036f0ec28d33459d2a6ccf3a2ad7c9a4e76398bba1df618b17e91b25ed4437d9dbc3f33ab2e659872fe2ff81296323f66508e78ebf2b5c7f2c71649ec4f1ffd51e32ea9ddf77d465edb6b1074d010e244c520b65cebe1a71342299c49d0b5e557d083443a2f27cce3b536eaa5ce49293d72f319f608aff78f775cb5f61774c10dae94bc68f30615bceb94f1c4b68a99269aac3c0f4d95d9815c4d73d5e69a40349cf8bb81dc3f35bd847070f81b5e706f2468cff93a31b88b8b62673786c48267fe5352620a595e8f7a0cfc0df8b0421646ba98180c9fe979bad3469087a294a6f2967c7a73736aba132a77c3a026d00cc4e62d94b76a140d43311716c4728fdb0d682fa08a26a3800c8be3c5651aa40bf7796cf0f49c8c7b3bd6616cbd2517c68b5ebddfa08d9445ada6a59316e5a5fb880bf3fbae39fac819eadcd6ca8f0ede960e4ae73d55a0053924327793713e92f7f79dbfdd4acfb151c3d84d416ccb04bb6b78489b959925d575c8074da7eae42a89ed1170f0a31daa7dd864c3610f1e9ae059342f805a88edd6756cfede53bd0188838839cef2ca996b5fbf38d9562f1525f920a6b95cd8133714bf00bf2c11f5b8cbf3b4e332372dc08a49eec0eed4ab7c4f793e61050210839b7c6d0027c141c37324e092494cad6e5546f8ff7185a4270942a6dc3ff0f1651c42f51f87fb94caed81c2f14239625ad696d6411b891840b4c19535751ed246f504b3540989017c723c34ff96accbc7917897ad2969498d0adca0545d5cdf8d9c617b5c269e49319b59c5c21209e64db8d0fda9029e5ee2c64ed982ecb2651cf7ef3a882c75d5f35f397dc691b16f94ca28911ce275720e00483dbda7e7892c50441e6b9dbf84abbeeb509cf5ae7c93cef0c5cfff2de6a17ec4a16845437e16389f3acbcd272068616f1850987a58c1efff89c38a7ef1350a9312415549b1c32ec23bb639ba9edd21aa9add8981fdb6f77a7173f386e97fcdf6d7ac1b9f23befeb996b7f7c472a983609cc5858e73fefceae3694baed6096558abfd5e9d4e7148cb1dec9d458e8e95037e159e31912468524c01bd979a4fca604a3f14ca348830af75164977c6e9e6718dbd68e1e931397e5c81ab773890be818b8bc7b26104292680c96f87edf25e0b38ad7b721960f1777eb6f8dddc6169ddd54d2e036e666f2631aff4460d873d21249e6241b34c314639cbba5b158002ce967fe12ac9f2f0bfac9bf78001776e4f2925b380e480e2e3f2d0a6916d46345843f8129a6f737cfdddbff75b4aaf1c8791fef8fd86f9ceca1449c4062b87721da1291a69451453299f24530081e2f70e61ad974562459f40662ec8f84bb20b001319a80c075abe67b8ea96dbc82cd68d9add1d875fea9f1a5fef0c46233583c21dc74c357f54d78c5d116f82e460b8bfccf4a8e36d09fcc3e68ae0c1f39edad11e81e6a8cc42c1bb7713f7b980eac1d5f15c9608c13b37dd0a03cf058256a1fc18cbc511e3873c8d50a0b0461059d2690e4c562cbbba3ab266746670af178511f73ea94c071e2884bf13316edd0f8676f9c6d2b8cabc504366fa5713d315c24e6e115b3d89751178eaf2f1c57e282b744119efeb1373f4c71436646ca5f899814336fe347b615a78fe0a03ca45d4a24ab14bbf4099ab955dfb171bd8abc013dbf4d40bf461ecbe4dbd66e273594c71eaf153048995324e46dc9c9e29ec7b793646b3d76b40b6094b3ff202ca81f136a43ede33e9d4a552356416d8f4088fab043faf022312d9b56b19b93ccb6db923159a631011f1ee216782a384ab9e35c0aff79dd492a857f8f9766e01c49ab97ee9e57dbf31fd0022532300b5a178323d1c64b2579f78cfe0aee4a16e674bf7c9f55dc6c47a19d92410636279ca56c04feaf5ef9971deac81c1843d07554b755035a0c114f959db87e14c6096e01427a0a28fde6ed39231b55c4916ca0b55efa3b331525947917c9c23304849a2d7f082e03c6d2088f5d951a9fc210b140397b698d77351f48ddf028c8ed5f85acf14d671cb9741cd8d0c3d8764b4bc2fb9ace216be01a6530ea483e32679ec100a74acbfffbf56f2c759fcca5d11c18ab84e63b7269dd2847580db8f0dff9f56ba033375bbc339e14915020c12ca6c9e6153c86a6e39aa636bc932a45853034d7bc542ba0585e0c84e533a5e00db7ff969a144c3f4a009425fdeb1bea1cb47789d35935025ae7d650d4212c68770b87cfe8347e0122f07313d563a1f772c3128939691a0ced45c56980a11a5f8ecc31231cac798411c1c1c3238f0635fa47ea141e2d658187c5d8d5a2105d6fbadd6079009b851f670745038c1eefed719d7502df59c5283d92ea76272b46a0f38316c99d1f618b057d4dc40c2ba9ae955da8719e5db992aad9a60126d7d0448c2916a957ed71bf71a0469663093b82625bce5db6d7a8bd4aca25e0db55700f679b55050228946a8b6ee212b94a3369ce16d74d7b15b455c7ab273ea444f5919f2c3e5e0c7d82543a3c6ff02e3575ef98785cd886043db6d225d1be2f6bbf6ab13cba58755e9afbda00aec5042694824084335432a3b34299067b5378375319f036e635873696795c6d2eb8527c51da82c90abdf96c2e25fd94dc50c00063d1dc4263088b68e0040638aaffc23e63c2205111643243cd82ff1fce369b1baad10366835c6ee9a89cb50e8bd0becf499ee9322edd082077d0cd12ae074eaccc53cf03ea3e9d03dd54585d98d18ceb1db8b76f63d620bddf6252db764df758d11b9cc55688c40902eeef6e151ebf6adbd808f420dbbfeb37919538ee4e51e184a9c08f88f0eecdb3a71eee32ec0ee554f833f619ec31420d4f85fdcab2d947b0fd693d9206955d1276942a1d573e707502757899404825c4aecc1ddda7f9096ed368b58b42fe5d77addc3ff7b05c95dd2f0fe44e8424aa68a79b78986b9776ff141191b8ac6bb34fc00c56a0054a1719d2e849965e303c6f2539dd700fee22b5884276f7eab2f184cf5a11641a375fde34e7c76e1765c209c7431ee319acc234a14a0158c3be8fc60c29189a39ecb11f20830fe80cd651e24c4585146355541424b91df9f4eb18aad784c0e294e6111713b9aad3dcad95da364e1f603ffeb1f7e3ed89c8ba76fd44bd41802554da0154179494b0cfe635e9991f4f3d4b9764d2f7de454f83e4a757c9db843d4227dbab99b0189226d6c96c618b2e1b0bb7872c85e544915d93c68ed4f7dc64307c53822a6a0492f604195d323d8592f512ef08dffae45281a186d56ab4081c6497a114665975d6f3b644348cbd35b3eb7327e68a0434ebf86212df069ea75ca8b089b7ec96914ac107fa9a41f604beeec2fb76bebba5c061aa6ad69f280008ec9b74dd9e6ed596d828b3afa2df61bb081c6c0be4819d562878cf62f230305b318f07ae1c8a54c0880e6fe592a8d23a1c57f1e6612e3191e28001db0b005c4c950ae1c8f9a6bb95801dd5a0cfb1f7bc3d82477c0d3e958e9006d6a0046f7bec15c046706ac954402662f1306fb43983ca4f2986c5ee8523e020b3fcecaf3440124f933ec94edcff2b993a21fa1adf2e626c633542653c400b6701e7ba122a26c014c143f0fcb123bff936a8a9a03c5b535ad1596611e1d7024b7514a2f221d61a0274fd014b3ea8e45e937f11794f9c7132ca539712babbf48ed0e6a21dadbd58da7bf7ea07419583b43b8044a61cef8db51978d7b953e53cb530cacd326c4f5eb821a3f5ca97c20864453f29cec55d10f34471d8eacdb4ba9eb867368eb6521941f76e4827fcf00ad2340d76d970612e67fdf7d0b268912244d8eba6a76d824d9b156ae667d0ff9366d631d87efb131d7521f5bd468830f4547be31d70eb827301261f4d9421c9c87ca4b96e1757d7ed1ec247784221a9f8526e07d3b620686fd8dcda7cea540e533b8da8a5e77313785b27d4823671f6e08bdc10fe6cb7c61140e5e900121e447d9ca59d85d749ef0a211ab44acfb4cee731ea79de758619966436224566879925b97dae7c07058e325d358a2cb2350d90e8215cc0b3f781a58bc4244e5093f5df080ecfa6d0a5bc8a6131718de8a5eef3775de084a18daf52560bd22445e78809fefe67e7e925a806567c8c587c40255671c6d8d74c807545754abdf656a547615211bfb6c4faf5fc92610f8b6328a173adbbeb21308925c7dd9aebebd964b60eaaf59c5bf25bd3c8512aae25c297de2b4acf1cb2c6c6263c376013b2fdb429623c02cc0c6c7f123243f7e0e9e3cdc01e7e002c5d586e249cfcab1faada75c15ffddd40c3be92c272db59078a4b518d8e330c095b3b2f020e1c15cd69a31ea8f239854ecc48db02f05647db81baf4b1503c3696d323298ede31f3e193ce81b22359018c1ce70ba15fa3ee7d1de3f408b26dc2b36902130617222392d1883ef05d53aa7ad31b68994ab39654253be171fae3e9abb6cc249ccc5da0936e3021d592fbc42d0fe09dcde1dba129c77f53d62e9bcf73ba078f9170f26eee3d9b132c4b0a24205fe84a937624a1f81e0970ba28f339fda17ec416dac893998d31ce84446515d1deb854740764b7ff7bd9418c31a3ea2053405661834724e79155125f1078262d3a1366528eff229de92444880426ca7d7e205c79086f42db5b7cf062e31610d09d80ebc9b6533413f8588410bb4f3dab0667cbe4372e9d97debfb11c4c54da35df957c2cdff6945f1c6e69f95baa057819bca540776b02f9f7a905ab9fd32e15a6ed3f4e76daf0845f35fd36ba5af7e5afd168febad465fd1124a0f47d2f253cc0ec827b41f272df16bed90eb6ace99923ec00f68414c3e47ba1d821180eb65c4e98797fd69fc9d41c0a581825a75660406ee3b6412826bc80e784718aaeb4c2bbe4658353f7df6e82307d5a5de418611c61ffe72292ac1aa860247700c33051b52c5d660abd6cebf12d555e50f1636cfc44cbcd829994258026d13cb1ab25bb03f6e511048aedb4673f8d7c3efe154ae0a02e7174ebfca80fdcb24f29642ad9e50b92489990873d76ef02085eb03beafccdc5c00fef3dc57eebc46f65c07b5c91928c8c4a37d3f8d909fc42990e118d4480cd807fe2f9ac3a25a54cfc9e34dae9ad72c5749f859071fecdb81950253d2f032dcc72fbf75704e1bb83db8a94bac32490ffe87f450abeadc069cfc2e7d4b7db13fb1655893ef63ce37016ae0570bde8eeb0ce77d481a628085907a72dc5daa3d202b935e4da917c1f68ae98203986b2cdc9761fd2d123236318a0d92b3201ba8b24bb9c82e9eb47eb5fc35c7cbcafd4c403380379685a9c2d8610a026ab5d23f01ba8a5ae328887081bff5f8d56fd6558297c6ff31bafeac10befafce18d213c9441fe26dc5f002069699f787df3a44c8915a120d75887baf59d807df43c3d63970d8a6e040d71071997abdc92a69b8f3cc7aebe3ca9e2dc77b4697cd636b3916adf597791db5b9169857005fc427002d2c3265a942bb45b384ed3be823fb8cf671039a3200b469120e490c0bba81eb3ec6d4f90c0d0fa3fb2732d663f12aa92651ec2e65718803daf3b08b9b990166dda29f869be2782b3f58aeab937290165c357c2fc3a0e706e7b71f73266acf2d6d4128d04836f7e3dc8d8918513be2f58c87387284f5f217833ca8e798dfc7ecaae4a44fddd941ec98519d6e9cb98eae7c23b9bee308cc17a08f4ef85bc4392bc314324456180b0efa1037fe3e52b664fbb1834b0924686885178d235c73497baee5c1ca1a054b8110eddc27e051623675bd3fae2ebc054a49b375738a7ed525a521a9a8b783c0930e88ef0b097afcebf0f5212dfc348bfabcb2f192381fd457d1ba825c76ce1f94366307fd9848788be6d7dbf7778833e8b9877d9123b070f55ed9ec732cf61e32ae4c075589fc2ff7bd24102c1056ba761855cccea13cfcd198c8d6c35f4cf2f65799ce344c029ad9a1adc75ad85923be25cefb7c6045d93d13f80f7a5bf3be94fb3b4cacb0be67d5d785b5d689c82f7ee387df8d0929602bf973330504911a948176f4702734cbd27cd8fd4d355550775e38e2203662493a9991d35e7efdfdbdc1e10d9a4468524c668fc24c37aba6209b9f7ea2e13774d465f4607e78b0f92a00cb257abecafb73d8f1fb694adb3d8a68f791356161e7ded87411fcbabf0d9baf31af4faafa5302d3b2650da749e3fcccddf5d69024a75682e300c0edd935b54901a50adf3b94ef336a8dca05ac397205e4987c8ad3bd959eba6449252625a0190d88cdbf2a89bba14c9910692e320a736aff813238b325868cc25306e17152785c4ede168aab8803767cdad59df03546b722fdb4247ae99423fc8d7b511f0870bd759926d881475842696277b1d4344b0e7f2a09706e70d587a6ab412c0f21bd61b0e63999814b6733ddb3cf539c4514c159187242f58e5047a6082c1279ee9b00b796558483aa78fd828ca5df7acb6058d419d8e0fafed225f249f6c23f01804a9ff3c49d24dbef34a9ecee7b6ae74052f51ac7d91f1c98868bd6abcd7c8f4ed6487574632f8d5d734badb00808a991e848c0c3c5d8ff7b74a5e6efde4139fc6c71d491fb57a93820df5469500daf27a65823fbdb229c45a110b1102323c746a22e2a08e8ca36d929abe9f29a69efc187a893cd901b395babdb163dc4022541dfdc39db260224a5bb0e0ebc11f8811a02d78853c21ef4e7f6a00940f42ee8092dcd41374268e694056c23d5634bab9d477e5faaf20807ce5059d5fba75b867908e141d888fcc07210e9773b9457aaa8b7eaf2df8ebe9b8fe2f9b3558285e6fb4dfe9a7d7280b02b1342779b14ff388c50c6e86f2013483d381b9e9fcd880302dfbfc6006256ffa52a1606c9be15709c5c8a726be585644505e2629bb527db145451f54436542fe7b92fc962832a3ae70857bf16edda3dfec3a3ebaadb9175649ac070704417f7353f5fd0c3800bce664909000d0ec2a980438e09b0ae9c4127a0445ea2eb72649af888cdd9a7493e8314b99335e76d3388dc428bf7a12aff1db64a2f193e257bbc27764765e2288f1a9841a9fdc169b408198ff9927d9b640aa0b1ab0deba13675751c58136c58d1e3e58f9b04b6dfd22800b09efdb21416d1eba7953abd2d161a9f915daf706f09bcdd30544a0313288982913fae427f930ee724d2458c499cb4aaf6564abcf519747077fdf66dcac42c7c783a28c97d1bbaaa89b9dc706176ca5d6d891bfc671ac63fc93dd76e1910bcd180085a0f2cf8653f5d0ddc800a6cd8f44231fc33d5c58a0fa425d7baba8dff62fd5c0a89798254efe886ab83cc13581d99ebc82ab954e4331bd0ec4adb5d66eae110f30397ffe3a6b9faeef96615e6b23d52c14f7b683e1c9520056083f2fd126a35325fdc0b63c3b60c47277ec4907de932781eeaa43efe0ffea26d3cd44bfc285b2566e769b8cb5042f91ebe2996509617a82a9098c0a162988caef851935c1d820bab8389e37743269803ff27a05890e93a01bf54014d33efb339bfb3631e2c5c57350d64fa8115821259d0b5a0f4246f2b263437d477eda67e4457d1fab5b943919961b707acc58ad2afd09b107cc1c5bd80d29f4fb33cbcfb6accf10f74e7e61d188754bb76bf9ec6b0ca2d9fb20d175c41645eba7e901b4cf0c5d0ca08ac834f3d7e43e0e6868a191c73dfa9082bc8b7c62ad01ffb6aaed38ac7e1e95d844728f34654ed465ce0a90c49e0a543bb874f569b214bfee4be87ab123e16c145bd40f6fe96033c19370d8caf923d49325928b5a50a27bae79ded73b36a94ba3a6665d3f9a45008c4aa1f28e51f4b792d56a5e4759b0f863f6e3f2f4c796675ab921f53b77b7ba74c50c2cdc4e896e909820154f0f744d6357f588df323d59e5997b0b56eac9e236cb80c6a38ae3535d1b17c238563392419ba45bf67ed0dc637cf6160b75285fa5128e780f1bccb065ff4677a763bf335c88697c7cabfffcc6bcbe0e79c68c74d4e546d77f06102a192b7c2bd6dc17757bd90771c9cf09f31a468ef14a968b1514b671c5f80ab34bfd14768a403731af4969c62faf4dfae765ede9c638f2c4e1e39550d7e53888bd10b58c47ebd499507bce9301ad0c38c678cdf34c1d0c83784517b74dfcb9ee3bffd8564e54104aadd8ba35c65a50da3250640938c20595442485ffb977aaa106c1a915cf7d5fbb7e030a2c32671fe8f3982b11e651aedc409d93bf34020da3cdab3a8a2e2de63eabaca802ec58d0cf161ddde2233de57b9e7e833e0c2115581908b4aa5c343dd800690b792f303f2b788ea5eb0bdb7cb45b4f7dfd26d4abf52398c92f5644b04b83f8f0e0f4fadc3811a1ccc01791cb89956ad03d95f04789b672916493d5b12ac25f287d784b947b4dd5716824f596e9cfc5701049b3ec7e092ef11ee989ea507c0c65011044cb0864da39d0c7ed286f9c2b373e1a48985550aec6b8bdf218b7a9191e849080127ab74c0cbea10246d87b070026e92fdc290456dc087d4755a964082af853d03335f2fef2105ecff3ec4f84ac77a3d9e56f7e9944f6b87c1de036d7e6827d4be62392421d7d8b2a0f2c74249a31b75b469e7e7f32fa525448126f4bbe9134800190b33e975f71dc6176094352c29e42773216d5bd54c0aa9c6e4a04fd7db332447d3968d73e10ef1ca2bbe8b67a1b619e59eb772420349224d87612b0411c2fb09f1fad4346343e38f378f9eda4541d22c30a662418d3a3a0611e965b193bdab738e3f06c346512e1f922c19c1339dcb41c65bd63201c601ad349d43296ff38789111e87b32631f942275d25b5d7c04ef3f5d00c30b01f7f3a822ba860faad76a147ec72c78eab35ecba4efe3ef302a9f003d66c323edcd83fc0a6374f486db3ca1b53741f14c1c8385cc389491c4502b23c0312b5a3bee5e4e006f89952a7321524f7ab2291c5c78d6585043d140f257181b3647f27741d8f17f250a8633fe8981040b507c79b17f65d4cb08abdda15b4c5a66f1968371fd5fbb1ac50d7da9ee7106a9dd38ef8b8700d03eacc93679c4c826cbc7fc0fca0a1cb0f00dddd56a5c88291ba4397c529bc23c15e85ac5583d7cdff8c55f93b0ffb426ebfe3633ff120b0b7e60cccc1f8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
