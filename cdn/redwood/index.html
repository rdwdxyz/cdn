<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d2bb5d6c70204474ccfbf2303c5bfa0888432312a230b6ff53635497df1b0238cf9bb6d43cc5ed907b6143528717f083b87d098d6375c9543567553625101239f05f6d65e86f17b9c7ff2dfbee08bb79e54af79628fa292474c3cdac0b9e3311b21bb1911bcf42634b1591626045fff26eee7c014a43706c91e594f97ea3a9b0289dbc3a331a2b5d232d2a6494b5f0c8942a07fb5fc51c165ec24e926b9f10890483c024ca716649e5cb867657a883a554fa46868ba662bc331e57b927c7a40c4d0b81f063868386f0fece9384b7a6038f364d7dd3b9d50305bae5ceeedc27de924f12fb35cc5c5fc2024ab65543ffdb3f0c5a483bcaa96a8ee3c99e900b6c02989dc9a621ee760f97634ee17c88f02fea3748d0c0c67aa637ff1f80ee68ea079658ad82f357c6917b6a659811ac6b693b5389408577bf211988d44c8e311c4e86396956f8d29502706e2081de68a2a8e8e61503d9a1567c54781a013b88f4a79b764e7206a4352d634b6135a46aa942aa7e90fcef15458e2b74ed8098289259ef91547f5e4ad7c3025d500ba89ff2d52174bc439d4edbedcf5bd96dcc08a02b3f89c4c36255c939291b91b961bd910abc767830148dffba52028ecae0fa9675d059a09b697b25e26ce37d073c23d88dd2abfa6b5c4fdb47f369e11c092d39db60160c9ab6b27e09d51da22190b563327cf293cccdeadd4affac2df822b820567cc33485a6597fb1058e3b8b24da48c86ac8ddf6786ca36dc9b6bf78be90f496a714caefa7bf3cd3979b32c1d8ea23f89b6fedf6016c8247bfd1152965882ad882ed81785f84d655680dcaa05d2f6f48a2a6f0af4b55c7534746df87a575fb0820df15c81718043280997be31e73169e4b3cfe7fe5e09350e562cc51d0f5b2fd57770731aaab34a5bbbc77637d7e7fc0a853dc5f94220f304081191655632867a367192a9da6a47fe59370a164009fe9a1d145336c408d46df35a5d4698198b960b549f9ee7fbf91332be110f921919e1635b4e8347c9445260ba027c5d81eecbf1c450cd33df18a7c556d5233bfd6f76ab90a1437de0d756e11d7d1a5202315e8b7b4c3999e15ef7f9704b2ae1bed80a2379dee39fa4349209741708ab5e44220512371ff0c1a4675c16ee9d8b4d77663971f7fc54f235ae3996845fa3d6c0e1492fa8da9665ee7a58cc2db4f487522f68ab57acbdd3146bcb110be1e48670ec315ee1e732a7280a5e8ac4d4b67609d22470a0f27a55b9f2ec4816d787131e2581d905a3be7e7b615f7849d94229a7e9dde80d20a70099c11c21b3e82c9fdb741d14668f1be31fcc1de1f641ee44f50542bff195cec58cbca6582f1eb52b3d2d3569fabf058b3a1fad575c6ffd835aeac116c68fe744a6a984e66146a355a9e0ccbaa1b7951567d9aea10e96c5bb8cff34781a7f1483ef08dbc1a15a2636583bd74484c319b1e2af19e7fb3804e299fef55653891d5c645e89f1476d33126c5751420b6df33f7536074a2a1d4dd768309e4aa6560497023d5713b5b6a01e252c9ceee1e690e0adc80cc39b27a7c85f01b8c6da600f6987e38bafdefdaf9b64d99584b7e084d7b95d654d9e8d8615840b17614a4f115b46c05a4b14901464240e969afc185cc3bda3736890a2afb93443bf96f56f2322787491b6cf46bc5405bdcdd07f5741ae5cdf8e56e34ef6d7d78ec5595bc390fcb4b9f9635ea6a85028caef54d8cbcc8cac3cd97c468b2d5b9efe2d871c0881ef1bb92ed344358aacd7886f5b33ce739a5f79f28fceb6351d703c9b2419edd0c4a0c7da577dfed3d788685a4dfacdc967ffbd689dcb5818acf6ff098133446a10b573ec3569440424421c6709532145088cf58a91ae25233bb4fe65deeba0a3743c4c0dddaee5b0f610074522e78bd580a4a49e5ecca27309b9faa33afe716b41699be2c9c5f8934db68817bf9d8e40549cbf33a0ced275e0e4c3051ecacc319f178a3bb5deac6417101e0dffc2a3c101dddf1c2cf409092f4195f612e856601811cc6959f023503d7eafdf74c74683fdef8c5b857b0ac6d9b53cc57d6130647d98032e9b51b0a1c9d98ea6cc3d1c2654cf39798f0a766ea08ea8fd8265b2c03d4b0444f195d105d44eec6329a0cc190d7a9e2b4284f33c38090632a0c4c7b64f46fce57d62fdbcd6736d4974e0a54f2224796b96662b4057d2460d4a43f0194cc048fdcdbc721592ec48997d6b0b066074b2ebac4436818ba3ac7f10d46ff9b1eea9be263bfff520ee537b86d9acc3607d9b0165f85872e5c59d60e7af23c757c95f5f483589d0ed0bae48e7ea1061d7371273f26a2198df34cfac04e4bac8b90fba6c06ca23d45deac6d885744367d93c214dd05e0ce15baa1181da36abbd6bf6bea1fcf1201f23314903cc0126eff478f71b67589120766f801ceb5a37b65999d33a73c33111d5d9489382addced35599be05616e1813ce2c136df21590e61df8ff2b659dd50ebfee398dd9f6b1deb1cce419a964682e980c01158484bf97b062baba91718c64544126919dbf33ac08f916d2d83025b1c62a84377d335c3757a9825af3f6e2f0ddf5c02d0673e826922f22b83416c0f0487652c7ccf3bb17817fff275a15d7046dee4c8ee3a2a38b77ecdcad313a91142a8fb422e9e07d102586825e848ceb0686facbf4f8ada5f8af03084bed72840c4111063eba90251db4deac0ad68e4c7637c46214f93b8f77b0af92d7a41df39948539b10c6859ee5ccad86d631487aab77d96a018eb206873fd67766a0760a267f499efadf3b941e7578bd59723b1d5e403a9b5eeb35d04cc4126038651255a5b3f4c43c3bbfed6e68184dc0630648974a2f815ff8df895e97e065ec4e15d58159a066eeb2ad41dcbc4a56936b69a5f50feb6c8ec2d299aac0275480ae6644d8dc3f7100c3956e20abee7ce6207a2df26971af9c21ee7261b417f52b88ec6cf79864c160911a845b63874923df9839a600c57089b98ed06545eb7b766e5d45e7df31579fe0242357f1e09cb9c1280b503d14bdae8aa06b56232d5dcdb04667c6f9025934ed669fa756721adb4ab6c5d29f95f65b884d9b02367ec90872d0ae8e7250e87b42b2629487d554cd196d12e02c269a8c6f1931d7662c6d9ba9bad140346fc435f5d7e26a71b93ee4311e34b924105de222c5a61541997d0ad703aaad6b61a60a3e3a8f64118c2995e871c47c83991fc70a2b384e5b76a6de9093d1e63e75896eeab8d656735c372233f58fb369f835f9d88af0dd9725710c83cbb98d7eb25f61d3d8697817c98ee54c2535a0c75942207fca39599195a71023b34f151b2aa494d9cf641e0a5f04daf60e7765e81777cf0a7258a33a11cf77223dea6b063ec28fab14d2b97b15a9a403430a991e72d16ff0165020994a2c33d93da2f8b15fe58aeb70d345dc771c7cf133d9d2ed747750a2ee088742218c6b27e36b1be63645083b3ba2a938b19126524b79b46cdf002a641173fd28131f86ce3b68d3afbc1f0b97b98a6205d33632a80ca96b95d9c28475201006ab287b4d3ae501722bd6a593c1443414081760938f3194c0df94eee3e2ca5ea67ae387a8be0edf56103f9186658760fc0e0afa51a2dd261f3dc5e1b43074f644fa4d1091fbbd6ac07c4190b94d9f79ffafc55b678d7886fb7a9b1b316368b94c38e132cd097a4d5eba0a16f53bb354d9b22ffe51a0f5b5aeab7a6d042596d6432e76ed92718efed64406910404298a49f8cb7189e98c2a4b0629c45aa40a7129dbdbc0055aabddcfffc115c5e10d464eda3f5e48c94c22590a215ffaea2700808eb9b012a815d8b3ab54f3870490e7110f462a0b514da66091dd307964468092cb789cbf90ec4eec66a3c6b6bfeb9a1566dc2b271cab8859e2f1021ef94aa032ed3eea268d2575f52f503a43f9c895f16a35db9b64db6d910ff01b006921777a03f40293d690dedb5df9f66d348b0f921981d4740a8131a63c960cfe14de7fb5eb503a6210f1bb375109125662ae6a413c35df9b6b6394b04c2aaa51a824a4bd02dca1ca397c414c85e8df5eeadb25dcf85878c11908009335fbc4f012ec038ac32e09088f24b990993b7fa175c729c3eae95c80f41c997257b0e108ec654f1fc4a8217ae768b5df55ced76504cd15a943ac8357a216440b2b25688a99ac5d4ff77fd2c971f10bae30f83a0e419e5b1cdf2a4abcde49e7af959554259d27725fb0bd7927019fc5e8b16f0e7b26efb060fe4cc3d67442f6d3bdd45f325a86a99fd8de58ce8ba7a9881976587e63238ac81b5742e0d6fc966b8879fa939da31cf570872db5de4433886e38babfdbd4337062fa7850b0f00f2a7ba1e4982fa952b807f33e1572581a20a9c7f1b708987f415cb9c4cc72cbb1dad364caadfa11e2422b8e6b3da462d3624128ee8b58b50331c73d3d92ce660219a2c8a2ff2f1cfbe70bfbed690c9852eadcbbde77b2ad546a2dd35cb472ceef2053b4c8a2a7db730dae7d9e0addb0bb3525854d2049888b15f5be05ae9e9a5c4428482f9ddbda1f709f262c9a62c22f6425656b74811b4407a208eb357bb6609546df6ec94f682be3679435e9d78f314d8bdc42964d35ac9fab2b4c1dc88c76f7e44212e9755fa1874864b370bdcdc046835059e3a48c609b022c0549f4e02cf4f4edf3f3b7ec1e15a504d9b37f0279a4bfa27550f50176063aa6a02f9bf5daa4c9132469acdb1b53fb85b49d1daab2abb952158b717464574672a3aff3c65936fc218379ef5c06d949551678228007d007043d9f76f8e7670309f90984af66b6128392fd7ef6090f91cde7d9e49c7692806b587f9c7799b92fb24c27303570862028ff70c2913c48c6cb6bfeee502b65194be3f4dfceb6f01e0b805d9e285f8ef749c1204437ac77a2ee538749ee5edcaee11771a1d06a944fd13c66ad712ef368071237739f226e674354fa6694b66336d2ab99cb03f2c0507c70c50ea0483e20db71c1218805ff849c9cbe867de3486352ff26c14df8584b8dd40128b035e7e5f0e0efa2adaa3716bc1169c25526effbf925a7bc95b8029fc257a4c1eb88de0f034043026132bf13f9018d72ecc88a13bf2e2ca3eacaab9ad78656ebc34f5897fae50d26199a5cc39a74918f0e62fd7e625d382aabed5479f95a110f10f301768a965588049a913986c5e5441851c12d52b91519414430a7273f6eefdc89612bf6c8cd839ed8ace204cabca19512b156208a224871ae900b53bd0054dc1cd0bac33880bf02e1619f5b823254018913ef2ec9f12ca8e6ae54393225560ef219a39732c10b6c10071a76aeeb3adbd56b715929d3ca2237e03422c09128520d09d6182e2371dfda3f71c36dbd28afc8e3ce927af24e94bee1853a9c331fa47dd1c73ea6cf37dd702e3edb1714b26214cca0afabed0254ab36ce030be11c70f245a420c0fd2f760f016fa805ef8ad0f7139bedbb8ee2b060008fc0e2a486ccd77eff295e1d020fe0239f636824c2e037beb27ee9127a4e3f0936e766ba46e7b87d5ecff713cd0a39a959df5220c018c7208bea09d111899e4de9a930dcc684a5180a1c72228ad5807fd3073081d4aa87398b22452e48945845f86d3a75c8abc1c4fc65dbf3e5a278a7a010780d499a3a347bb5a15ef61b5f1dbf555930d4801116f0c9db7dca129c1cdce4658719906cb022bf2674faf3bf75b11b6e80ae40e143bb83307b122101bd16a3e9c96b6a837912fcf2c6009750e1adafbaf28fe5f53b34ce3cdb132915162598b68db3a3f39fc684b8dc9c199dedc4e63ab7586c0107d3f888c5ff7c79a1ed968205f5c6462ce954b888d96a3b227c48e198a3f5df6c06e51022c9f5e2ab9bb84ed91818956b463cf0f02f650b69f49171b66c77c18f24b495dfb116fc57d30b18177bd863ec367a88947ab98b186595ea049f4cdb04eaf31d0e16941f129bbf0eb1baf92a19172a3d73198806fc4dcae93b0a336ba7b5cbb05f86bebafd163518028feb2bccf16b6b5a307bcf56383b0351cdc3173d3f57be88471f27a0177dac3a3979d97563141921ee392af2d67b13f688b79c3673401f135c8a7b7de8ea5af8e0e5186093f98bf9199851d78ef845eb6bb87572d456fbf47e744ffda7374c49469afc51cbf9fa420d83bc7f328191222670deb347184396a7c28e5f6a03a9d29f494aaa25e1a45e2c2a13ead7d0f6631d64d8d1fabeba8f82bad206fd9814b444b663debf45ff9ef9ad866c90f9944d9303ea40a3d79743d1c92a5bf5d6808d76a0a3a0b28c9208e921fea39249f932c32b2717a0601951a775c3e06f5a63083e0cd4405e73a840d4e68a3ec083ba53933eaa28810e71967476ee3e4484f3dafb5785760e3256fffbbc87b4a5ade93d5e6359fee0cdecefff4cf3dd18d681fc694e9a6e7eacc40ac96e35aae7bdabba2ba8bd3a0fa700a268e799b8232d616ded6a5e4289750f9416f3cc493c3999f21142ff6ef9df0ae5299fd748db668520e6d3772814de4e264e77972d8d68c149512b5848d7687a14b33b2342e76bdbf293a2167167a65add478bc25e25ec89cbcdae449c437e42dda42ac93e30d40a6381df86ecc7933ebc17f990ca25af44903a56da4c1f001f4bbfa9d317d6c3a1b41c93f6150c54c170e053fb83852edb138d9b2a960ef78f175055667532e64ea864f6f117f6b0ec7981fa1e61b59fa5d23fcc0365b1ca636bda87ab98d34f59740d6c297a3c54419c3658fd9a1fa26ce6e3087917a7f1db8d1c175c9371a19f7fd0e47fdf83123f34d388c44b6379fa09a36aab34c7d12bc22edb6fb1c2a69bc69eaf5eae030f08a0e8226f84a4dd978415410d57f3a89cf8ba214e2fd707fa361f7b5db6dea694c55671356676384bc22d3a1989dcea3c171e13c58643e8ef5e5ddfd739175382f874a0b792145b3080c692f86753ee4684925c9950720a5ce8f931e6adabba8a337159ce638419b8844f80e137b3c69757e6fdbb25b1d9b6e00a3d6b063770922098f21546d101f3c4e98084b9779a8b9228cac42bd0259b395a471e27ee63d06f7a04d5ae1944b84824a43c8d8d5488796ef2024906fc25864b860c83adc926e7a2f91b172fbacf7f5cd011f5738ff92c3c8644f4412cdfc5751128cecf17cb83f9c8abc03f034af090ce839f0bcf8e49cffb9cdd337e7e95ebdbb87f69508e9ed45a6aa5b31be517c58427a091bdcc8aa063beac8f5456e920611fefc5f2877896e5927f1e8c729e872b6c9a4715ffd78f31e27d95fe690622db100c232e6409896e32a65e9e40360912823ce3c436b6a4664abe78c0b7ff1ab38036d7cf47b4c1cce47621f7971dcedec8e045ff1f6a747f2e2d8556cc189801eb9057bfd4e99381690b1cd0a14e348cbaf47a961bdb2c2ada984a47fac32a3911c9a0f5d0da45a48f2a4eaefc96c793d6de131b5e37e239ecda0eff6dd47607339e0457ae5b0f88918ff9859f3869dc3dfef6ffebc20027b1215939d76c356ecddd7f9eb3e644a905ee2c1206c46dfd5648e4213f504dcdb72cfa3aec1fc0d5b6d45611e649cfae213866fbabdd259fcef4ae32ee52ee048512cfd1e49b1dd16419cbea8e4dfca2384e43c0351131b0b67fac32e1657aa3ee7f6d93f1010f5e10935b4a6b33b6a1213d1e16fef1166c9be82fc353da85b7a180584e6b3cf41fb5eb6630f6ffcd6b06a5cf6e3a27989dc60254063e7e74dba8992b5513e87db12ca2714ed10c32c2bcc93c83b0d5851e997e8056fc59008ac0d16b0a043cfc8dcaa78750608b2e9d65f35685d2329eb6a34095135428b5ca70c5d57c57337f3c2760d3fed422fcce741d36f12883c889df578c4b5fb395abc03fadd4c82b1bf4f9fdd62c1a1eed86c9ade1791f43317fa9333723258cbcd26996b2d996cb9a864ca8670a6adba6df310e23cc927de6ca13d184f46a5fd4efd8ff6c42c2a378bf991d5b65ce01539355807b038ae8ccbf46dd0545ff0511a4434ef3e833c2d6c4907db80f2960da97720b449baeadeb491bfaa9e02e830455deab54c53405e1dfa69acd31229b0add9b165eced7ea23f26b32595e547807ab463318e8b505936e0dc94403aebdea04d7ac607a8d814648aa85091620ee1c77760572cd2385ba325918e5783ff506b3e71852d6da943c44817fca02640cd3740de56d9dd3175659af78554cbfbd9c00a1de02eb589b1aec0241e617aad93e4055d05cf9959e1e03689dce5adb1af75c974ad92710dfd838739cdfa76615ea6094262228f6b4bef7b6d1495191965b11b08f094fe56904f14f0727cfbe5882a9241942819e21a6f95b171792d69c67d5d1b6006919a494e100e1287f2142595d4a70d2104c28319cc2624c5734060c4b9db2511e5639674ef1d69408bd3be125790569a91db7a99997a38e462826d72699b75e6669eb2c8090ac509d25ac78f639a16cdb1c28c03bbc8911536c7db700041ecdad3e700c40a5e1eea393bb28745d06a065a841476d27fe29edb0e71acfd248b695e091628d27578278238366a62646d3247e91c8005a2c8c4bcb010bc4817fb00d1f913c9c23a794e41c9164a659d7adb010815d5a1241349e7d166f9fd4596b297ed8306bc4dcf6ca5e8c9621c58cbe0c73d7a50a31e1094ae8f2654988e2bb996301e0808f8cec7eba9d3e8d41f1a5cc7f7af7f49ddd1b679ef34b738eca2ba07fc4587ead9693eeb3b806b6a1656b1022a08a841d0264290aae79ef8b64d8525e83c5558b94198b38d5049cd3c455aeb1e400cd7d227da245b71acc50286c60b84faf9ba2fef5953dae8acf5ea3f3aba2e636c263555532616448a0c1390bd8f74335473f6e857f7360baff343b65c800652e872395bd25064640a8cd9681a207e1e81127e917bd85815817f4d15ec1cb8c042ad9e6dd9f556fc37b3f212c6a860d9f1ce65cc9912874c64bae0098452ff6ea18f825c3892bb1d29d61daea7a9dc3b6de2be98971e4471e5f1150a68f0f7db16a25ec2c96c9984f95e648c67906de2f963799a2fb282a9f8ff015819be1c4609db987aa04d472a20edbc59d1750ff2dc8aedc038832e8472dcc482a2781defc6a12caf6f3ed4b50aa8c7896f647ed15e51ce8e8cc06bb2172237b6ae0dc1710d8f8f83b333d66f5a6544501dd51acd930f9c75795a1c5323418e535678e8f1dc4a44c0d06b98c562d4ef4757da881fa13a14adc398f92035e45fd9c996ecf08430edc96c2f42a3fb11652b46a508a5a4d5a2f8cee6a7c5124df5a492242e04f9843782c0133ce6f93a7bea587c751baee441a40838f74ed8f95007712717108736499fb6e481a36d818cb1a09cde17d15bc560983c4becf9deaa49466bb1d302bee80c268620bdecab2f9ec32d8af17c728fe9d413b164c60cdea129116a7a454632ab4b2f32f442e50955f468892d687fc3368ad722c038b931a9a754a3dfbcaa09b70c22abc702019ef55f7138bf1c4df2fdfb8eadf3daf4f370c83e60bda7e84caef14b390e0a01498bf49b32fc23a6ee4f0613ff88aa8345c2a66c7f82444fe5b1b13ff2f482b133adfb00e37f1e09a5ad5c89b8111afcd20b5960d97ff4c7a09a6bb74931bda5779281a413283792bf4f4fb18a52d3715e5954dc5021a58b882734d71decb3ce509b24cd1aa8143561c45e11bd3e3938edae40f6c4b9799b15dba3d6a8bf4adb04ff03e9c09eb9c55760a92c230945b8234f929e739c3a0be9a1efa50c2426af7233093e6233ba5cfd25637a6db7752d9e9650d422bee8a69b346fa7b16b42fb04027cc5b64c12124ea2f796bd694003ce3b1815f329dad2b76b17deff16604063fabd0396f3591d0703552bc75daebfc8970fe21ac04016f7c1fe3b9e135fa6367ddfd1f9d441e26aa5b5febf2e74733f2116e8799666419c18cba6d0bc8e98a892c92498ae1f2d835ea6b7d72f7749950f57af82b58981fb4fde3c787b2aac5ba9bb75fd9dec5984e422af629a4f6be459b346dafccac7a371c0610f0a3e44b564f4c6db2fed464de626dfce14bc775653d43fa5841a00ff555464f72b3a02952b7273ccff7841adf7179d60a5cec33e262b663f49a7a8736b235818d30cdaeef9b793c44e44797fb1f41dafd4b32263c2382702708e0e3029387372b0f8b58eb190dd19c9deded49134e278846ce41cb10c39206d8062f45e29ebbb119a110c7196dd7cf388706b236358aaf4aa79da65357cdb7ac947071365ae22ed1055ba9464e5f3f4219b8109f0d9ff73d9d8a159c3b326ef1e09a12ff48dad071e893ea890c3755940f263a3b38a1217ab191e088797012fce230221f21b4d073fd3934698feee757812bf7889c94c89b5c195438b12099e4267322d249be48be4d6fb79f8e6f50382d341bc6b05a08cc1648bf3280bd6062f8ce224fd2c02d779c07f50199b5532887812f471ba51a4e06479196364fde25e755f4555868c468be1fa79c0f7ad5f35dc90859d47a0ca64c3a18c7143eda2ddac5b505403549a1a1bb0d0d3fd079701edf5538ba9ce8cc703dbff101211853ece3adc6745194216edcacdfd166dffd5380aeb39f0a0ca77b7e5208b176a129fd19cf753b3b033f5fae29e4be3204142d41400c0e75418b72a12e99c27e193f6824c326031885065d18b3517842cf8023b8516a9a93e907f3935b425d9d40efefe9df2bf0cc0e92c05c6a84661e850329ef35758fd9c49f389ca454a4246a264b9a3a88ffc3fb0c263a96328a5b70485460a9ff5e73d511574901ae3872ebb9f2f03127bf0a07e52ab704f7867f6af32ebb8354a9acadb80604cd6f5b202cda7bd0d092a96a2df5cc7416bf934dedf7683fdbf47ef4fc38ebbe12578515d0f5149d6fe1324cddd2958a781283f72d62ac91d069a634ce98f931b3b72eaec7a0ac88af4cad6bebc2b638387a62d66a6d1f7faed6ca539a19ad0cea6c9c6dd427cf0a5d8cfb0a6f8e2c963918a582dae81bef9dc0203dd610fc46f0ea01a35f76710bdb12e11b1fb80c2b7ece72af1b79b52bc9eaeabe55b77325a03b4e526235eab19a7a41ffa717e78246c98582a9607d79391aa553ed610d122bba2b9fa7495f3ec98de2514ffe3398185217446b2a3b9ea4f6b59117602e6e9550a2131a4d1ea4663a33ca2204350f5cbd77c5ef3341a76a4a54cc4562e99174c973ae3cbacd260c49d4e201db8a1179c7e4e8f4a747dc1277cbf23500c835b4a5328fab0c60aad4b4939380cd2ee5238d54e93dcd4beb9c4f8b9a52c13d5c6601725c58d3593c6a737323cf2715248f3af19505d5f01792e1075d145838d617ddca0d0738738fd5bc5a161858cf5849b7b7f96bbd5e177b0f598cac10963ccff8132cb70cc6c23a391c4e011a531c5def3a1866db2ac3416de3780fd04e5373a7f1c56f93ac6c497ef6edb04f4bee97a4ed33997e0c6d2f001579684abe0a78d4c1df047fa928c2e2f86feb026b9524c14bed905bae303e0d45cf9a3b82f406e1da35d58148a61dc1fd74df232ffbde4f71c659d813c1c17d5a3b2ebe425ae2784a007d5a345daa883f32bab930cd1dea6648f8801d3eaa8df743d5854295148702c9402c2f9c5c7f49aff5dfb5b5c7edf47997695ad917271915a8050098c492a3f26d47e8767702a55d272d18007ada33b3845d911129f8c46f3597e6fbf01f99e187f7e50e5c78c0acd2499da3d094530e322e0c930c4c7ddf4cc4941c755172f902af4d4c70e9e7c979132a9338c88f2dec15a7cb770365444831b49da0cf379dc1c9e4c5122a67404c0b864742ba2909dcd338a85e42f0b312dc4e6e87d9b164396d90f453acd967b9b4ec6288780c4b2738ddaf194c875acb6e61f2ca7fd8f66c0c2dea2944a433cc75b4938a82a1ab0b78734c89280a355415046513b96d48f493b2cdf32d4b1728a1a803c7fbfbd3afe7b55f5e1797f408f629b40727ceaaae7763c213dcf8055ccd21159877faf6b5173a6e927472c91c02bd20dea3d258f3d1892831bccb72b29dfa34203e4ae5327be8df30327d0de86fe5b13b7ce73093408e496ba5a80e78dd12f142aa6133025a2e803b737e6800211eea34dd2aa4fb3e22a20eff84e5dafc4208f8be069f39ba579820863c45e4dc4fd81168545d0c343d98bf2847c00485444cbda893cb5fc70dcfce1bc7b8c2bcdcdad3af1b5f5212a6ff6b608dddb61faf7bcb8ef3b16b68ee40211c7f6fac38804e089bad175929a672f0463df8db27279e1539df582eeaa882eaecf52b05b24a4be8457fe4aa256b6fad313d7fa6aab604e3f3d7e67d415cb2b4d1227232fe3c19c99d16f26a7fc4c7e04374c418f7570f9f9d018b1c8727e333bb27f9cc1ff773997031dfe6da55705d8ad279499c58479177b4c762d9bfb6b37ad63983936febcb6eb39a591d65f3e650eb3281cfdf549d53b63b10e83c94e95754ddf31cc80927b3fa272c0183468e8a7d6093f2b87b6614cf6492f3c9d0adb6161d4197b922a6872458b8b0b55ccbe1f8f06e29c4ff802301f33d0ed61bc806a4add24fd16e0636898083a1106827a89c92483a513fe297b0c547e0929db4eac4d70d228d3e745eba810a95e8660b218f42dd01ac403e3607f1e3b561fda1117b661c2ed8df57dc1fd0a47d9b8a0fe4ed07fab30c244f26f28a9f84714cf3cb9b62f42941149fec349d74a0b0d00d20bfebabc4a495fb522ca736496c3b4925be32614b3e66141a3e542c192c597fddc52288c00c99a4b2dea66fb2fc908661c09acb3e0337ac7245ca4e1f3f0adce21fdcdd00a52ae7fbc0b665c219c883c892bd4b7506a0203b6a586b4da68eb0831861cc0bb664a5b6b8c892fd2dd0bda43643133b3000ef36cd6af5d595cca1d6cec14f196e04786e8289800336827e34fc9a167a9f566e93eba3a86ab52c555454076e9b0792122548d5f2a98e7a6ec349ddbdb456d358756712fa86553ea838c5579e19a0ce543cecfb7f7b839a1e763764b73de96c53557e93fb049970a1982e4e20803daec731c80e9a416499cf9182631d58dcaf4a456922909a97d4556fd8659eda5c18018197c8d80bd5cc7b1d5f7ec1791b356d0a9a304a5bd1f8185a65b9abb8dfe7e8a8f24beb09dd2fa1f21f25095675834660e2b8643ec014f2b3526d79efb8c5e292cb2a3e5b09208621722bb73b897fbb3a3b62dc406c4ae86c316d1b09385e5d834d91a5541298be452773c1c66d2018501f0146ca173fbe57572443b750284148ca5267fe1b4d03a4283057e96e9ae4fbfb31e138b57516ff11d77f25f25dae69d0ed84c6cfed87fc53c7e620e00064e7160a3f54f119ca1c23d42a6dda11cca9dc559a1becd810ea325bc1bfa6791e25887cc4b888f9b6c0fb3adfdc54e303ec9f68a84b7c196315407fd90abb3dfafe20f2af6fb135dd76aca02f416ae7c59dff6d4caad7c9cae653af4afc7bf535a6f924d7a67c640653949eefa324aeddd2cbf80af091a545e8da49770ca623190a7ffc2e4602257b6d361c0933501569e4afdd666d306c5327be040f0a428f45e7e64263bec6d87c662b02e11fa30a069e5cb7ec247618dd66f593ba92e25e96af6fb0b18aa03f92033ab8dadde85c8dfdc6f84303269a011deb6d2614ebe4382c8eda8ce0577ed81d9a0b5cb8b16d52cdb610e86300b5a30a187775d72dce03bf05ed99ba29a431940fd2b87f5807c8e93a0371be63955a624c1ed9f21e441cd60bb7e61027d790a7649dd97cfc03ccf8e08c91523c0aec33ceafa27db272e08276b17ebfa4018a45f990008e4808084d7c3c8fd2accd6f7a057bd93e2fdd9397c27d0c8ca12d1175a6cfd2676a674d25f000dd4886ae9a33377d9c49b83ee6c6aa71a3508c89b98e94a5720504f4a2be29225f703b3f6adc7ca05232f2d924e10f4e103aaec9205625ed82d26678aaf1c4a2acb8eda5ffca5d1cd4d240eb260593fe35dab6380c65238c25d2e03e1265bd7a2c35859b10bbc1b9b2110dc28a7b7fdb4de926326ce9dfba40d9a68b936309c69b57d9b9c47d76049b35adad16f91ef7d0ae79817abdb0149f43198a11d8421b8492c127be52fef72d2b947e4e46cffb9e0a04bd2554403cde0cbe47c821940e4b23c3fb9877e2d629c8966eb6aa25d6139d958d8ec7c061e2a3ddea85914d45f423911870e9c8bfe690ad1cd6202d6328ee82ede2b99ef5a46643844e00e8df2ebc065d03a1fb92af53c1877a71ba4cae3f11d10a89a1fde5a9912cef80657c3adfc1ec112c9d21d7dced27211de600ea388ade176e7568160166e5cb99f731d7d3760dd206e798111892f99dda4e891253c37ab4e22dcb033445efbed04b0e174948247864f645c8997b2a2e809743ac87d1cbbced15ff70720000885550e8cbdb93cf543b049136ca3e50746218283639facc8b01d4f2d725d4fbab50e6fd28fd7e822b530909cbc883e9d8acc539e1ae956453bb072ad33df72bb7ac61f26ea91bc8a28278df9a8e3e7f3bfe3b47496f72e0ad2d77048567d7ad7d7117107fcaab324b636bedae5c087b1c15804530b45e2a0dc278c6049462e5ba6715030341131135204e19183af301ccbea35c25a317a8c2a78c4b9c8780bbd82a8ec798e6f5b4c1a1f2e7349c58750ada792505e8121aa750d5b71c173b850c9fc5140dab0df706b6296c801db807e5a88273b53647d550f20f29228ca6cf0334d54b7eb0326214962a335ff32ccc6343223c81646745c6cb53d136b4b75d9d114cd1e24144396a432cd0c71ee155d70dd16e09d48fb933918e794d9264e79f8d25aa70020f80bae63928ca229472c06a2042766397552ac202c16e751db5c36d98ae9c9208632e7ef640518cea467391b8bea75944176df73af9b1686127e875455278cf96cca5a110462de0b6b444cb8225f3912978fe8c8a9072576f28ef8c5a6fa2190ba821a0a83918468169e4f31deb0504c29b3bfba30c6f6ae9217a40c3f4815838b83a46854a8171d478ddedbd11ace82ae87a61594632959d4bd2e32ee2232dce853a7cacccaa310df046dea376b6d1949dc2854db561e1a412a9e3a8bc60d814bfc982f88dd440681099e3844fbfcb3c3478bf603530cded1e93c38e7f899fda5114e44cb1269850e641c22c2c70df850d803ce44c96ebac04d4c415ce0fe52049838efdb65e3c23f064735921805ac00c8c241ae13099fb420ad53ca9444438ff2f73c671655b5f5695acaf09053cb823c3507dcf1a4ddec6fc7d4e730219cc8d369ef63cc4fdf177c491583c8cca92cfce8cf08f642c1c34538f59a1f6ee4644e3f94620840ced3c61c3f1d5cea4409e647e455628a222b2810a9342264937d6874470b5a7cd3944a976d9463d44b3d18c2647a6dd545b628c2bf4aed7e7003111a584603906d7d79126d0bcc59f34b81c3a39722a6567f405c8c307cb0d67971b3901f87161c55dcf36b399f55514b97cebf73d3e4138ebf7ae225067e8ef8d776608941025d6ca04801fe5a2487d9ea65345193a8122b34615c26f466e2bc74e1a55600e1b146d53b14dc2152a1a0e549e45638de0fc4234ba14824d6fef31663aa63de74822f2e1a97ae498b3b3a2a89b93d48d327e6349528be92544babd46e9d7da404bf8d1d8e121d46ecb476484685027ef8b46bb77afacb21af9abe7db69764e76215f054a39b9cc3d5932e8d2e542862105f8710d286350fbd6fbe331ff7b9982fad3c83f51f8f51b35fe56e373ce3a273bfb322e3bef200b63dc5838c852caeb9d2e379aef8b2fcc0acb484166e7f12eff7f4c9bfd357c9b5e96c9d7b462d690f4ccb65743a1ecafa10335888e9472b7fef5b7227e06955a466e7505d06a5e42fb72d10b81d58a246839316883374b787cb765404c7f2b0028d5335f4434ee28567afd61b48fd2ab9c2baf4d92480e7627ff8bb5a931f41b3b6ddbc67c5efcf817492af026176ea81bf182aa9aaaa3d320d95b5f5bb25146e158c8f4d88e411adf2403a8d61dd195d0565d8b5b618253f3350d650392a82a07e607b340d8cc140e6432745229d319ab32f5beb936dc6214866e2c629174a06b9d0466330216583e31b7e0f613361b4e1901ceeb0f28d317237119989f99c0326588b24c7bfdf525e843664d4a3feff628016f9ff2a39b552580c64d132d0e80e58ea077105134ef050311b2b9c0a83d7d7b60b87bd473a54bb2dfb735a7719618edd8fb43f71cbdb40e3af157613d60f080722df8c034203c252ad2ebccc99260183bec327a17714b6d5b5856200f7704b199e4283263b988b0d97ff501c4f26670ca1d72d853530a2df3877f9df66d4ff8dd9770b46cf082307546f0eb3bb7a301334e1af8d66688d815632a2cadbe9eac1571c3e39fa939c0c205d310f3f0489ffdad5dabf5cf7dbcbbc73a0f2db2a915f1f9f27e02642058804d9f41d0514639210b0460a1cb5c9d521ea799b467cae27834d1a3941320bc0abdef169920109d8a0231f7dec99faaee7f4601b6a66a7b238a81323ed1d25e010d56768b3042d7a9f53a69bdbf7d8dbdf279277c62329fa09681fbc422e22680b5a1a1fe68084697db41ca925ed12e75d9ddbd1acd642a235348c30d423e97e22c86e1ea93b52279761b313b4894c3b8a416d56f1aa275d6696da14742ecd3070b4dc63809be0a3f01f87d335005dd5dc409b2471377ff159c1b155aa35c63583b62c30c3af32e94f41ca71851d112727e78e8dc3cc621f33292b89bdfafcb00a620caa7c3821fb5dfbf22fac7b9a82ee44cc73ce44eda1870501548602d45cbd43e1e34b7185b4edb3955f119e9e1cb919bb30e615cafe88b5b8a642eeabbbebbb8615a39a66506d0f93c86dda3c881ba1524e1fdad45b4a2e2193ed2eb28388158d08f7c21c045319ea11388810e31cb1f227e63dc85f386f6fd2a7f223c67dd701bd37f458cf387cc2f89e246e81a903eb3276a94b77f7f509d89ac733e97fa8b24d076898634bad823fa43a896ee183b65ac9fab2fd7b90fa274631858e94255b1708a9e242c838e3c94c820bed29bd3c37bf876a115e9b9731542a1174ff7f3286953585570ad5701bdc96cd53094f2863c61b674a8323b1c717c45af471e04bd4458753ffb4283e651a39eefacfcc6c3e41781bbc9a65f57390adbec9cc5159882e01322aa7fa3f07c271644e6768a934cca915d5084f6c7f8816386c38bb942462b3452e54ec75379de420618bba62f76988a0001a9b3498f844e1b16439d7675a96e447143438181ffbc56fddd1d18ea4390a7c79ad7b9a480cfaa34a255c7a76f5630c61110cd9a1a21ebc4d06ce7f089811fdf261a28ae3734f53cff76402ae47d96366dc3e46b3847c1f50bdf0d535a0c91f05ad7accaf98d4427d9b3523c30741252b2c4468f4095441b8555d8a93950196b294e9835431d0038bb1dc3073abd35ed06c7661af5d7e676188e00aff527c53409e1b2698cb9f926724332e256cabd8131566fe5685ff741ba2c7c7e2d993f5fae20063feb01b0f2df18b1cb56526975c11de71ae9875cf63d3eb4c9e3caf32cfe959e45aa68204637185801a48d8969a06c6bffaf8f09c3437d0e9a9a200425e70ee766f06d10746a610361baa90c83c820eec2dfcc415d12673c3ce4b07f90a8e6ddd9346a19fa0dd2f9bd9d18e7df70732ba1a130121dbcb49a8f5a86b98c380f1c5c20083d064bedfbe0e08df3296ca9ede35ed934d26bd05857d7230355ad8c55fa2aade31e8f92d482f73872197a04f90ceb13f45ee533a681352f41518fd3dcde64f5ce09b6bf5214a45d50eb50134b51745985de8b1f53877e4831a68282d86e3fe54e5360ada877658795ed10e05a9a85b9353f5e72161fd29c3ed24e0eb99b23aa652b0ae94c7d78ccb258a157f7da54dff6df961828024cc4d5dfb9520ff1b4cf63f4cad9a9bdcd28ea4713abd96b82d6e969a4f4e906a53d9a01507f755fbc9b90d40262522611cdcf7a63e3a2b5ac1ea5541aa1b81ada014fc23a504ea395e61a3f924689603f74b6011f6b65ae1f5d6e913aae9b9f7c05723f619f6bf950950f1cca28a047265d1d539ee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
