<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9349fad574636de2f07925e57dea76cd6c8938ff8499467f3fc2d319c9652a0628d4fca3f217a36f9cca06d9575bb286c45152595fbcd321192fa995c874ca4970ea541f37c4614ea3c2e064b3ea4cfcd3bbefc1f6c54ef08cf15e54d15c7a64cc5bae46c4dd87031091d4d4de39b46ff66375b2f56055e0f96f1b4aeae482f76332deeee83cfaf5d0d407ecedaac7bd7351e0cb1f464a57a0b0fccf76368ac531ae6e31ac4206d0797c7a81492fd822d8e8afab6f96d7ad39d3c1f44f459c15891011cf0a21527649c1e8341183b0546bac06ca2eb63b9cf4fd990f38c2a608f0f70a6fbafea2fc5c6f9007c363c22cf77b28cacce07d3d9a43950118067fab5740ad9ecafea3c2ff296dc13a63d2a0c7a71ef9f77edfd513f00cf8d60faec8ce6859893e45120e3f96a19c8cc80ee8b2409d845ba83465c07ac95fdfb375a2c0dbff7166ef6e53e047185fe3c00661e26933ad24b0383172eb06765e6675cab7056d1a21bb29899278f05f4a54a2cd4915d0116d7357e43af17a691823c84c2e7b571f64e83118045ff49d0e50fa9190e61a72338a2b52dba55a50e37a2d5d0e65f899eadf6497803e3882a2a3e54a90e0171d303b3c9d93910edd6c789b28465c1d30db7a4386212fc0ae97a75232620dca7db42f6e7f665377d116ee59d62092e7c3c1604bf6edbe72005e52b559d0e4b0efea3b7a51f3cbbcd38bb10c4c8920c278cdb6ec70147ccaae7957f6754fda93b2509275b0369692313739e21d7a42c72702845f9b0d98710fc2c21ab448f6caaf64d41e023708585ed660c32aeb9810634fd852d77b546dfbb3a9dcd25bd458d1d04b3b68f5888f1ad87d0ba874f3f2c75b871c1a2280bfbcf10cbe6745c5278af2f6068e12535928863c5d566d9fde7120f27a92755e7b6c96d5b265d40e31ff9583a74a2cc839e2c8aaf58df027d4135f2f81a45ac4df27fa3e8ab32ebded376edc4900594be4e478dc61698d952b11226956aded69dbf345fb7474eecfb796341cf1c69f64306ce97b99e90d6479e8249e17d544745a8b8d0f85d406da663b7a46443f7763effac17683043ff1a13a91ac47dd30c0263e68e55d608366f6c4e7290bfaf470b7d086e0968050f29f03bc3fa4297f397411dc64dc73b270b4b1cd26071671ccbe2ae9a3f97ab1c70fed031cf0c9218471a72182ceeda39c0080db5868fddfd2db1b85902585df514a609a00e8e21dfdb4eaa6bf0202d7a84f8904055aa47293d640770ce169c1de88f5c44da3f97d65a3f89168597aaa4588ba046a15a3353a4d11b06dc1b45dd0048dedaa220bce65f6c6b865d20052f82beb56d4e6affa8961ffe72f38775ea3a88f6351df676575f3cb64500f037dfa77695f56c17fe274a29558f3f6fcd5d3fc0decf22b02f75204b47bdc1852413efa86fab76a180543e3513231a26c74fdf34bee2a1f77404514625e9ebe2c2e81259a826f8b0bad6d3b03046de1cead57a57c3001bc12d269203e672c2a666f46d0abd843772e2e024504f10154a2fa6314de5b50634be2404252f40b0423c6b9b3501cf9d95fb8451e52b1c346c3bf24fc740469753599200f9bf859bc70677bfd6139b87a4a8a58e61dc290d96dcb4930e461aa5769e2d4ba9c8e89de641d6ab61db1d5b4deba90758012665867fb8937d70be2b9121de3f4dbcc24f285635094025f097889758158805e4bb4d18c40949707f6677f21546d7f4c937464db389ab1b19f539017c03f10cf9d9568807d407b9c26fea9818313e2bb7389564d570a842a0443baa9cfe45f013be111248312ff6c7d30c5a87a9952caaee21d0616174c569c865f1f690c31a90261d72746f34611baadf619e84130244284f99b189c3eee9c0cb6eb721b132242acaba540d38fd459dd8de812e43a8a60d8db9d69e392f569dbb34e43f160d991a110d54867f12d2fa715a5fc4e106f5c990f96903c0b347b2720be9ca60732e4c62989b9df9701cc81d555c477eddfd391cae4329465129cda9821a7f9e1e4b853d2369569b2317528710e18113b35afae2eabbab1ee44cb93ea073f26c3c5f538d0fb11790976fb8b1b757c62e79bfe9cf471b4bf874ef97b8a299a596912529e1d66d1b6d587631a523d49dbdb03f3b2ae70ceedee3de943b22395ca02853e9d691b2c61a68357594cc39a83f426b779c4a835c57900f87394d2b494014f098e5f2e824ca56570c67bc4fd32a2af5a1b399ff9a42fbfde42deabbff2fbb88a122e8640dec5a7edc713704a8458013f9e16a0aa881169c97aa804cc8e969e92161836842b40ee162cb006807c8f2680f6ac8b1423b1fe7298164aa2ecb9b74e84dd4711bfa8e9ef73e4c486ab8b70dd7d0cd2e634928cec4bc1d2cc5aba2ffa37fed6aaaf67d647acd1196979e9754441b7ff5fa8a52177063dfd4af0878701a5eef394b160ab62507ff33e50fb82b901f69f9e34c45afc0f4100acfe6d0e204a15dcaae279b36bbbaf5faa88ad78d899306534404403184397ef980e7b6fda22b56fcef9322877f0606c9afb7c5fefd85fe25a6745d48c4d4b00c41b54abe217cefb77b1ce24e25968383431cc8d10911e045dcaf2539599bd3d7805abc6befded51205dcd15fce9baf73c3514a12bc605be20149e4684098a464be50ef912fc976059d2a7299bef3c792f2e28015fca7bbfc00ebc9553c15e062aa286679d3323d457730ea96588520d2fe04fb8cc4a034b8d260afca9f038fe9a317fef2df2a599dd3f56eb2b99daf82422857a6f580d5606239f4c716b6c97f5dec9a07f1ee8afcb04e4a00febb29fdfea706e8941bb4c6e23073eded2d5351b1d5cf08546574c6feb0a967be6a049e86c11714ca4f36d5828ab7d259b0f77551c28254ec5679778854cfbbc889da3781d3c247d61d8da1252fc2678e7f10184d442e3b43b0742df3b22b5ffd64bbdf3123e0ce50f1634f60f8b84aea57925f93e073f89204efacb21bdeb3a4b520c5bc14b7888f4c78b81c709f40588a1cb79a1e98b0e4f60ee1450d0f190f1fb60e908b53a1326ef23a091af8d43672201b05676a8326f0694783bd7ad7215a8dbf41b11ac0bfccbf7f0a50d11851521acc42af835bc3d10804aee90837932985e91bc9301c5316992d4162df3c2b4534013da70e70784f6e6b707c5b934a34a7b98678bcca6880972dd5a05b1cf068cf99fd879f69351c060c2f796b31063fac143ddf58930af5b9eb610b65b783ccbc33851d341a78051371a1fdcc929cc057c7d63f13a3bafc23010bedb826edce1db8003808c46547cedb79848368ef339097f4edfe30f48b33f88d2c7ec60529bab684e896bba9c7423ed6ae94f44623ec2e3d5ae516eb7876188a8bf65025f66433f3e15bd086f82c624fc7a597ef74e8ae561eff3b6f2c74789c812b20ecfe4e5e8307c87274dd9c32d9c67c2c87232a09646528fa7a6004b55e6457120d2b81b7d079bffa818b31df97d270e66b7172422399ae06afd07b34796878528b9999a46195781eb80b6b8166eaa55b9a5fa569f68a2c49f1a80beb1621ae02657b892ca67138520626893382dc06aac8ea08fde78d52c9d2e10034ccc9579d16b6dcf1fba8276e152b7a45df115573362c52b336c2d47c785310ce0560f55abd43031433ce5a6e9b491d1f23c95e58f141f4ad6edebe4e3bc69e988f209cd0df806c35918a44cff8063b1fad30a58534ac02a4ed6e24bfd89f95ebe7d3583bb8293ab5ed96acf9c6bc3ae9427ad3729c3e6f739d4fc694f26df99fda64d9feab29b1d0f553b99c06cebd233684b226390644f760eac9de3695593b1887e0b777fdc73ee89f4557b0854b2e3120930f2e3f2f3818d0a2d8e878aa43046b7ac757cc634186c84f6fe26ed0dc8eb6469953614438b0ede5e306c84182186f9945af28d69ed452a749b7f38b38bbfcb5b99ba90343274f826ba63bf5d26ca4c371dee3a8b884e649d6b2c88012a709d39f9a8dd8d30427d9f7c8d8de8adaf5212f2a54a74aabc41badeee61537aecfb7d6930494f2e69ae91696f8ab0e2d3f25eefe828781bc72a41434b7c5f536161e9e22f79588eed8002932f195c71de95f1a1b221b3bb50eda6879a222d37e9358587b463fc39c62acc6af9a3c5bedfe9c2a5da74359e81a09f7910e7be71ac383af0d1bd9126084cbe93d34bfa847bf044467e5cfc94d2a8a70d1d323785b4794cd77fedc54bf54181e7f44ea540f057076dc363d54c3c44921f660b0a712497d96284930629f85664ae92d99846c4591d1d016da6d5a77342612d205d103371b5835253419c98daec5629c74208b079bd0b121534beba9ed5376b42d69c2664b103ade4724069488c8b6049eb3af0f25e0faa61f4b0b0feac730212241d2e834088bd810e407ec5f85ed3f2107ef2f8fdf8d285163798639153d06f4de1a76e59d3179ae13c9f88cdea8e503f18f22f99a528fa4f724a692a3af967163aadfcada7e897672f8b4aeaf6826082e5e45e74431a8605635ecf53a37b920164bd820319b50b726a8370c90bea918abbd0962ce1d9b75042400b9881a60ef16d67437c71b8cb9271fdd9de4c632f4c6db6ad2f8f2433204ee8cabc50c25055572475530418d968fef752f7702f7929c8f21db852a54d43ae789b75514875aa63abc1b60cf54b1d5a91deaf73e327812448255ea9a42620cfc82ca28ad1cc6ac3431d97d22401d3318a7323c1cbd3a0578a757eaf25a3c048542253a6cd00d06049b5432274cb127da574d8f09f671d539fb650d4b84470ec80d2ebfec43bb622007692b3409a6069f4c431d32983999369000d28af67fd2bc25a292c5ff1a72a6cc0676408e54f5097ce7abaf0b41fa8cdf7591a0967b199ac9f0889a4fe7d1efb41ce04df195e08dff6a42d9988ca2becb9992baba08242d7ae1b86d03c403c170dde2c165b6ca63095b64870f42814b7e88821e08ed16355785d2473d96662ee45d0fc76279cdfb5014486dcf9a9d281e2f444257c3cc31e085c1cde6dfd087859b675bbfa62dc650741ce719c7c4c8bd350367823e1ea286296b3c4b86b0075e8c7ac08e4d34403971293fd9aabb5d58b8c3c0c1eda3176ea4a576f1c0ded3f52b1d3873ffd575db78a77037c2637b836c86826190bf7c29268e27671a0c645a15e146014e2be28d93ec85858f3e40a8bce7bb5cc59271ab6947f22b8896cf049af82cf9b32ed6a622e8aa0b43d20e66d4c8055bac52b453a31b40e32708e1dc4e5a696c37f987ed1864a20171e2cd593eba7554bc1d1a47efa23c155d4189730af06ac688e5786a0469254b7ff265e066df14ad5688e5959bb3c139de248c3b50299224f28808552bb9c5fbe720f66e05295e7d2d2009f900188fdd035b9b0c1f41d28a945347d223910ba3cc0c08d93e904aa55001043f9d23cee8deb569fded774fcedc4623cdefebdd01b650c2e00d0898a8045352a83fb181cdb0dd5fe8f99c554ae04f82997266de972505ad596ccaedc4f0fca2d3d5c57eb5da54977cfadaccce94ce74a8c06de76918524b23512e180a33bde196c4e22a0ca0dac92806c60067b887f2998b028069a4672abd2e0d2358e80f2f31093ed51ffef6d1277da8f35e4e45f866e635a750a6e97ffcc7b495da3cf78dd85410652447574f442dcc74bac33438041ff803685c7077bfccc7a530964cebf3cfc4414762c6954caea1be2c06da87943470fd5aba0bd1cd252394a3ee5b3088070ae3508875707808053bba46d4474b05a49d28cd21471ca56865515489558ed24dc147988d872a171dcd627ecbbbd6782938ac3fab1a1b7167c04a5155b0dd93f81b07602ec535f50ae976ebcbe88ff26192476ed0ba86be84c7a4c76e76f1deb4861fe62dc1f51570ff89cba8baa57ac43076d2b69afd2662a0a79992b777b235f4276ebaee2cdb21d0a029c7b4afd4185502aa5fdd61561884735318cfa69065e2f11fcb5fc5958de7a995a51420d381cdcbb7be08ffa1f05eade1637e241848e9b2c87ff0597da30fb976f0778790e7dcf9107a584cf069094e9d0e656cbca6aecfe855ceb46a3abe4697e2c86b27edb0d108cdc3eb0955a61375d2d05b2766440d46cc18a55746456e99c30edcd2d426c4ff170903a3ce05b3bed104bce0eaa1f2f09328eba41a8232c86484d6fcab753a2438601f7b72e5eb94c5ccf2727052de49e5d6f92a8310883acb88dc500d8de3b677a05a6c989517d53d6110a8c780bebed1e693deef5ca91b345b5f286ec5025882db162dc9bb1b1f06af632c3e09f17955f395f7731c174ab57d167e3bf06fe6e55fb95caf603b230ec89786042bc699c85e289d65dbbb6f991e6fb859be8b04d6783dfb75c030d6be2fc7ac2f66f19ac29af263fbbf23a1e85d528a50333c064ef1187e23e4511b711fc03db184ac23e1c6e2209913870a3388a922c39c2fa3ed055738ce6d200472e9743909b5e5a1375328b5e2cea262dba53f38bc7ef7fc11b6a723df12531bcba63a36e557fe9e7f8ae5a107f814e3b07483169c2915187b83f0713d16a44686fab5f84475407d65b6a9ef1134618898bed75376b62ebe79e777fec775536fa50f21f17814bc5c2e45927ae472aa32a65e07f62a36ade497d8d9d9a3f2c8dcdd47b22fdb5f2fbd03d8721d26fd3c93730abd4cc30911f96dafa9f0bea7d409be891a2aa684affca710a7f5108aa27897adbd17840c04ccb8c6aa4eae8415a94ce58c5d95e016560687dc7b7b29ce1c0ea854679158c613e5b94c0e7b1c7783a8099db3884063c4fbd52c966eee24a395340b36903f5996da169787f9df62b37ecb2a74a52f317797b6e740a44fb1867068b006d27d774e5855f61e8c227475556426c936e66b18e3a80d117400986918d75bb91cfb19be99b3b67c5f171b379c2221ed814aea6e5953cd981c5f7964deda4b2b89b9d0976549ec47b365a8964b8f417edad6763081106c3c00871d12017e65cfd3dfb931d30ade0a8cca2c71ceface7db28a8c37b6b448366622380b07a59c79086103b63e341901d2106bae99132f5b237841dcda75e89a5fd5c1f70e8ab421e6ed47ed50141fbfdbeb28d2dcf578498d1dd1d987208ab3f520e0ea76bed550ac64a249c27e207a1f5c5f070b909f3d21ca81232021d27f5e590d1ba467c8aa3314db9770d0ea78fe57246c00c439304801651d069bfb4c2c6d86a278b4a6300e6897e9d12f3ccd31d4f8b6a66eb193b542dbcf61493df28ffeccde76ac7df108a58afe2d528cf0262f78fe368931862b5d0a394726fe99bd4db5395fb8a51d4da3b773efa09b8165e6bf2e22e8920ae9ae765e7314de510bc6c047ab48798f65aec0ee116e9d63b27438d8a8fbd72f69d2eac62a156887cd211c87227bca15e573648425ee1d14677efc8a26e60363cfc1758e0890f5e1befc2fc63e6fd9f36725f489a1b8065c588aff378cf234a04cb66b6aac53c8ee02ef2a36bf83a83a26a74dd8c4baf074b9eac3d5b2fea55233cd62456540397d886bb7d0a44dc7d1fae6e8d376b5292ca113a831fc157ddb9c3ae7224371109b185146d18441e25af5ad1217b9129d257a63f71ecfd37ecab4eddeb866bd8295f8ea11ebda265317869d09dc650c4ed410e92432061962a61b1c10c5001a098d8979f4de774c4bef7c66d950020b4972a0fa6103d536f2596ca3c12a715a2418402d3a8e4a12ac64c014cd36dff554981e8897286b84ad4d9e33e3a62910e6c289496ecb184bb179040f19382944b439fb3cf5c02244983019fb45b1fb00761bcf81e6b8282f146a34cf1f04cb91f19f42a7c327423239085fcfd55f985c3a374324fb5c50976c97416872f9b5acf93ee4dc04676363e10521aa0bbefbf9ecdae8a5440f01fa066d00642904a9d1b08074ab7660133a9a50afda4596a13ac2ecb7b4e2f5b44e61b5ddba0e5d9039cab3d5909cbea8a9b495d3197766f333773e2bebb634997e0481eba673ad781610f0fdfe44a53c1c6a1ca02d08f14676d9493d36eb1cd6762e2610cff3a8ec821c67d7046cb39643fca0b80b9c56161260caec2ad0786d00a4012a95a139525a1d512e6cc6ce558ec6062fa6ac9956372fd9f34c54bb088858cf5b5a44556d5cf884cd25a1ce850533e02530017f3cba6a91dd04f33f9c24baae8c3408722ce6efabee24541b0968b887ed7c04abfefce4d3e32f61e16d3d3ae222dfb3e2a1d65856db16181a459a798bb889324b936d80205520280de4307be49e204ad9f6f03aeef88b3c7a817e9605c32528822450ff62de406e03aba7e9fbbc65816fb952c37aaa873c489907c8fc4223d7a392ef2e2761b4f089d441e1541de59c74e3fc4f7f8d9f14ef57058b2a47ca65789ab768b7603f3d9c4620137db0c28f4868478fc80ef3dc75fedb0d37c507557f31f26f6a73c46237cc1ed3abf3da8934986ae11b96fb520d7dad9bbe895ae0b27d11f73e7c4b93d2276b4b83b56d9849a2d1a6c5a9b3974ff0ca0c597b1382cc9c3c9811b218c96a1b79b327158cd148cc44607603298f5510cb074095bb1c8b7955737a49ddbb65a30888568a29ff360822d2314975e347fecdec9416e24a5633d6d2c3ed25443822a8bb50f0e95c17b9ba79236a7f6b935bc28db632b09462d274bf459def19470df21777604ed9d5352cf3f20790bf09c0b9dd387891a57cc43b155fc7adc1e154c0a301890a2d29f920027c2973ce72fd21fd5b976011c05cad5642990b93a1f58bfbe3f5b5b66c01a371c8e65e9884110722412ffaad874e9448df3be68b059a196e6eb34b482ad9f6d97afb490207b8c0a1ff00a2d69fa581d89a896249eda72ab75772592a90f9693e66d705e478c8355a0d524504d949a0e727e6f7e754ecc54c4a11f811108e1cea958ac3624a2a926eb60db51d5cfa0386d2b4d69c24ad060140a514f730a4b96e578412e3c517f62e3cee673482d26b68b517d3bc22d3df4c24ade6e1ba62cce9ecc40687c23c88413b5030d9dcfbfcd45050e280b9193348a794a3615564f4dca9761fbdfbc9e212107f6dda439304172b7f3ec3a84700de5509bee8b492dba9d0789f0c8edb53c27e05dfd521ba5d2cde4b3967307c6bc72023d3a6f85c0ff83cce097b3f2ab6db0d08e48c75e75045d84eaf6a0765fe379d1a95fae4c60947767d900bf25e13f005d8daf75ed1884de212fa68afff8b429f3c15bb4c42f88b39681dc348026b0ff2fe40184edc7031d56d1704a4cccb89010b8beb64cad26eb820b717747fcf199b13673dbd6d7312d6c097eef5df063364a4c720517cfbe5dc6e46345be7eb79c3ce3f00e400f71fccd3737b3c6ebfb35675e4828e402b4f68da58e8e246c4c36f0db5083994a77f32559013bac020a1f16221048f0ea7e86f90040bdde9afba71f17bc7b1b32674800b91c9d803053edd8a199560f2a1cdc571ca2a761c51b1859f43e8a8255f0c7afbadac1a400c98a32317fbcfb0ca80afab1d6b8b45924e41e0f9541b93ddc48885173c09e378b640e658e93448a15ab52344fb44768a86c85fd9231fc89a0e31b0b9c95c33bfcd671b6d21450edc776063a0b97152ffb3a82d54411956c9171ebcb33568ff7a3b5cbc0837002d829a2d08a0706d246ffa603e0a9e6ac6a57c1277e4eac537c2b8a13d359b2927fe330fe4031e213ed2aa93b640ae0e252854c4f565b3431c689a5b92866af665f0f8ca281fa860a0faf2dc01c9e88e902662596fba3068de5c9f2064723d8f1e7f0f57570b1ea4e7f72fc1f5bf276b5baecc08c59ffb53d2527232b346df6559109a1fa79fe93c8656dedfc0375c2dcd6e2aa9eac956b6bf76a2446a911de541061a421feca652c6d987f39abb7249a4192f509d0beb264bd2487d171ce74df99bbd2ab8a3e2d1a94d0022ca0ea460843572975d468fa73010fd340c7212e4b5bf7d485c0d8af1e1d4d99eef54babb2f7295e8807b86e312418effdd9115e19d55dc8bac8cf37725446bebb268d9411b9fd2253ed6d1bc9a636b00c3f508f4c5fb172b01cfb28d6dde9aaaedd0c156c422781600abea47c01dc7e0cadcbf6c4b36bd657d5ffdc6125d9eab01928b16f27f637223851e3fdc438af8b1a4080681a508354d6a8ba789155bebec14c494c05af9e43d3ae0b99d4a7298abfe9c5ecf823e4347ecc59c6a305a9174a53b6d8664e32204d34794c73fb365a865a1fc289a719d7004351d0ba0eb2cdc57cfa617c7bd36cbb89fc1c50161dcae1fe908d4d474859eb79c7387a4c05f53ad5f56f0955dbbb421ab3d09ea31c7b28fd80f9e684198730f37b940e4d674b725904a8e6542d167a0f66364dc216b52f9134753becd4083861095f8d4c0b5ca55d3774d1921e993dc24ac56599a3421b4e6c0fba19555c491decac19b20977e8135c528e8d95c3a58dbf18d63fcf9d0225d679914b6fc282ad7598584e01164e93b3932740b612626870abd523b4f38d02fe7d83d5475da4a64dcfe56620474a561d390034361768a1975ad487a31d6780e6463b23d214d797579164c9096f1c43647fcecf7a3f8aed1b365fc7145381024a6c4bb987031bacbb084d6359adebaa2c53b2a708ad4b10fe27de9e46ff9e81818f5f118a78ef927e8f78b313b183e9979fb991c872c6fd7bdda944d4063aeb16fc75258496d999bef170b6146045af0952bed822f306868a9a35f4c06747e7f8d9d4dafbc1e15b541bf7127069c34a978bf0ac0d838579b90679b6c0021414327bae5f9bf59ddabdc3739f2c71a6d6de361c3b3095eeecbe0d1a1cbb38edc679f1ce578c377565c0c3ca5efe660955a8667edbd0030eb43d50ca2966073dd286e4e1dcd4dbbc6c2ac501377a98982216ca552631a8680ea6d7d2014b0972d156a24f145cb65d32552bee220c7cb199427e5d20f76ba499de6d8631ee865ae4200bbe6ac88282294da4a337b0751209208c2a3e1ba75fa373f9f32ac1972bc595741bd53126808c5b5eb169712a474b3dd96f8a05b0cb3701afceafaac45f6ab376313cdd6fc14e09d85d1b9510c5a1cf72e67d01c7d2924411408c90a0e0598545f7d16b87f6d54fa71ea88ddcfc8d611073c35f34a714dca4768c4afbc7bf3ece79198ffdccdfb13bd734c850ba7200d9f60469cf46000e0f350476e24475234b7652ed2c3c5c84894b6a5437c7d0df5a53a254927576a24132d19e7434a7418587f9fb5be9f8780375b68deeac467c316eca85f0761449b70db0db03eb2d34ec821cda5c24e3851a37a0d07efa66e121160528862bef3bac1f1acaf9ea733ec42a9c23878b97e2350ed1431197adf834e211340716a9e5e9dfa164617486de306172db737b423832f10f04b1565a2e2df595fc65fda80d0f5f8d384208e539b2399461c67b57ba97cc16c4b3e52804f08bb4838c20cb554a53673eef5a14fcaeeb1bf86c213fd1f663cb7bc63c5a9a1a2ddd70a991523cb23e21c5943d16c49b4cdb754b0b0355f1600a45e04c28839f203162bbd0a93e0b95b7d531532e509edbc8660cf67eeca072f7f366b03348036d333c535abdda8d33670666eb4f9827fe9b8ce578da89229ce40ce7257c5e52adbd93bbad79804c8a9129a78b26bf2ad44ef6429856f2d75d1486d3f804a85f49a1dc809f23fad82fff6368be1314e378892aaa650ad275bc12b5ddbcbe8fdaf910a6ef51e1977190adf5279ab7d128d37c5efb79f633b39253856b54ff1922cffeebf493e106d65ad816226886859fc22ca13884bc2a37d8f93d2331d8906dbf1891dcd94e6f41a505899973ff41f2f73452bc439ccdc5413307366638e17f657d72b581d049d870cfed1fa6dc49b408e2a371ce068f107920f43aca4ec97eee09ffd09b8851a4558a2b44f2f3fd686eb13c461d6d6b06a1cde2c95b2dd62534055e70ab4beb8e4ebd292dc44d5ef443b09462c213b361268072ac8580e6faa6998dc2271f640971f17c458b2e4592be56cd5231d4527bf3bbcfb15fcb9a54a8a5fd3c7d1c426b1d0f0ebe4181d122d2a923ce50f513ca7b4304aa437a13e057c4f6b9e2b69ab8556366a322ce9c6fd2eb3c567505576cf70861f84614d46df25d21d0c025b75201e9959817d94ab46485aed1caba155a5e4d0ac9476aeb30458263cb24a715f1932db7064b784ecf5111c5787108559672a751b942af86222732b9f5163c70156e31aa22d1d9d69b23fd9758751c08bce7527d2234ca66fcb0742bef274bdd3f6dd174b46c82e4267e12bd60a0e894bd8ffe2e760a3c2cf5d638941b1d8dc141443df5aa858c77687470e52a91be9ab1ae596c2ac722ea371d3cbcd9a02ccf84d22f62b3769c5e3ddef2a241b7ffa7c99aa1035da346dae9e4c1f2c0701fc47a1105702258ea8937a5370d9654d0ee6cea90658eafbf7e1fb7bb78b5e760edaf1bd2f5e0b00cebfe48883267ebfbadf3723a5ece3a85d93bd65b8505e7356901758025073ab3dba25976a0873c28939eb7adf6aa937a701d4797c5b74ec601d19f0703bb3c4da28dc808cff8860496c7ae6c10c5550c677ec1041724e2977fde87c1a55f65c95e96cef00a2837dc435f349cc1567229e69ef17f366b9426890de2409f356044c988c613ce53171a3aea027f4031fc6d7b442ccf51bcf8ab8d1d657453a9f4d0a4cf2609bf9fa09be2d2b108e256da4870b7fc0d9fb95e76f59eb5b0c0804889fa56549a1480c41ae091c474197d3e5ecccfdfef90359eb391a6e18fd8132548b6ae591b214c31f102a981ae309bdf91ff148d38fa141c9bbdf7e3e101424de6806ccbd9895962f05794259f105a075ca1353aa99e91a43c9b1160bda201cc4e0b2fcbe96e5575dc83c4800c77dae4e38310db495d61b61e120f8514d12fb61eaed8c15ee8ca0528ba5a3bece5f1b7cef78a34a5095b6885ea43ee750eb93ac6581f647e6f57bd0675e27f6b2163b17d0941c2bc695a21f55ffdb999a8bca7bc7c016dc729e474959586c2881005570dfc8dff73b85da2974735bdc09c01be5cddf192d205dcdd2b1b74bd7c4e233fca81fb161d1c71a0a5641ec4c9166690138b5f9a4a3a468f514b28bacc2ca4bbfade93a8a4437da3058a559d2211e46ded0645af6cd55556c98a46a7765b96f3d67d4dd63b5d73a65e365ff31e363c1b74397a9882d76f13961f861656e176e68e970aee434d5c8edd9649ffafdb72e516b259d81a000a5ad80725eaf0bbf8d5aae3977ee7bde49d8182039924822f3f21c77975dd7cf3d17884ae74dc09bebed36a01c790a348435b1aa8f987dec7a54d0a9f71ed1516194c18e72e06cde489514b9e0d16a9c5472d7db4439ca320f74330b404cd5a3d61f1527f5d4b49c50b05e80226741bb6acb94f3575ebe324eed8e5d1cf47259f56ed8a24354c200ac3f6fdbf09586a927723840948b33c4fc5ee9d6711a5d9c2fb8a0476fcf977338f0bbb665aa3a807961de67c8c96802a79b151a6f8b0421b93b989b5b77c4e9ffb1fa2d46a5ca52f69a7b8b0c86ccc4dc3fce00bafff1623983a6c51812bf588c1209fa90d21fbe45eb9e191f5ef170bf7bdf7a35b3d38cab470d4a90643347cb376a4bc3911d9336af1e08e4475e729f137e82d12816ec8b1bd27b42ef5ad5d8ebd565b6e162d11d2087ed08a4fddc192111e2985e12991ddb48ab85d471762c94acb273f789682b9f597cc2bed13479693b3478b9adfc63dcad0e487704687ae1bf9f35ab9b82bf322e155f8954e97e34700c33f6b798d4dfcb69257dd06f2dc755460218941d33f8d3cef65357c7add69b4c5d9c8a09184d473e1f381a5fe85b501689912ef95b220255317e708bace2f2b2cb303ee51518c58d595517d6cef1cfea92f37848737e5c31118d9f267940cf009f57bc3d1718d1eb167fb3d766deaaea598f7eef0a517edded997a8a2000b29073d13e4c3ad4efec18f65ffd8ca87e270a7137727935d5faf0fe673d0c3ace8fee134c53e4ac28d84f5d6f47a88de636c1c73111c1d6a1ab750b6fd3ebaf9ece5e3c25aa00acd4303e86d8c9fe4ca3c2dd8ddd0b3a8d118e9939ce11271cf4b5f5a03ea858d0604ef4ac176c46bb3c545d0d068b623f957cc97bc2830415ebd121d72889e5b19a5bca674705aef7552fa2e07759afcc1bf7b88599e032af0013f9c3b1a32e65a86adcc2f68f0298b9d54f6c718721c6a2eba0fd7c20c3ff3f01c9b5d6f807cf42003fc25ce6e7facfbac479c73233f2119c6fc7541027cca75851421ddb865b99d574bc12372fca5584af536cab4877483fbf141c35cd737f4dd89e25d7d80186687329fef713d3546ebebb8649b173747a297e2b3a1091c1712de0000b4dbf1d4b1422486e1955411b8a6f40147eba5261fa55860a18855ca270d800ff74d056f8fd8434d6e7f1c5c8d3d0046e72b026a3396503c8ad31d8ca44e3b10841c50996cd140c010cc1db5cc162816295914bb7bb278af8321325147e1df93e46eef4a19e7bb80c9d6329c282000b7d33dbaf6cb1e669d9969228e2a1e8040a97348de5e6ab2ef4fb5f171464fe4fcdbe82e7c9d5361e8d92bd9cb669abd5e9ede3fe797382839e13befdf124717cf5c33fbf02e5448da69e336032795ba7da44fb93480f8d0a9302502d76d658ed965efac936a82dcf3c5acc7c2441824b72c624c49ba11a56ff10d9954b7e386c643bbed2f566b49036f723317f5c6dbe38a116ac3ba29b317e44819b0f39dcbf6d585b14ed2f72c5b3255ba17000d4e60fc2d33b244b8d308d8d447fe2d905f4d9eefad8e9c5a78a94934bb175f81a362be9438345aed03091939c9e43829fcd3badce115e96091c7e066ded3e933638af70db87662e49e564af53c8f7f8abb2fb39a5bb2fb28f8df999cf6cfe37523f8fba6e759ab52bcbd46fbad3d124f411c7d2afc1257ba0ad5b2487d70bc02ef711b0963c17c4d93d2807485dead79e3b9d8216fcc1c88f696aa7062422134790ce0e39b8fae739484ca1962329016101cad009602a3edc1a1516df29da73cc333a6af393b258deb4d7ac447f37c23cd81f9ee4594e9838d8fff7cf8fdcfac1a1cf8c76167cca9237a05b697c48ad8652f9a87ae1aba535ae8bbe70e33ff633f02a8d363d8e117541e735d081","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
