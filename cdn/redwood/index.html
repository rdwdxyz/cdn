<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ec8d59eb689000744b6ad0f23117722873da2e416fd73431dc0ec702cd167cb87cafe39d9d22558dbf84c43ad6caba2467b95bcb90726172723134230f23de54f144189ba79c36c43fdcc907504d7aac09fda440aee03002c632313e8054d5ab376e6bf29884097097075de9ad342de4debf0188bf20fd5cba8ab3f5a5ad9a3b9ef6e2b3ddc8b3dcb35aea80dc8624f3a40bfa0d676a0328bb583bba4ea324a3cec17b826f34e8d7a757d7fc45aeac4b1eea31b7d153dcdd0a6c90badd5d28ed1b5770b236f159ab2d45989d7196380306bb9a0cee36ef7fbacb71348763d59646774dfd09eec0bcfa5833345861dd272dfb57375945a030e9b41bf606144d6ca73f7f9ccb5bea201547e5b0de1ccb869308436637f97338026fd3a10a782097763a39885001331383bace9ad77d63bdd30b30f37538a31b78b86110f497a5e47b129cc91eaedc4965e7fe540eb98070b203e0c6fe8870b59f66bdfc4a054898a808f1254a2321f24cb67060cc7290b68e1108f7fd178d09b0f91832b13efbdc30d5294bb935cf930dc2d1b282d76c34df6862a30cf864681a853223722904ac1799079e51d789a893a5f01aab0538cd910ad742758f584659142afac239711f02a556f250c72ed164e842002d11f9f2b857203de43579ae8096c14354329943431e65f537457032fa5b3d0de74d85e4c47a32937b27f4dff7f5c67ccdab0f0401c02e552fc34a22690845e37344329bf4387f079b57e056c8b344a6aaa9b70b6f3893c92f417537bb9731f0df245ea0f3e0fffb54794dec51fd7d6aafa06d855cf0762a1956489cf673d10876ccce6cee59d2707ad50ea190d0d45f2c7187395764fc46ab4b7aa0f05c0601096798d6a573bdbdc85cf42a164f8c5746c47503f6f7fc3b1fedce5bda81b30f67fa43dc2a8ecc4ec7912dbd3734bb8a1ba468aa8756d5715455fb88521c133df7886a1d0b6ec498ccefb8bf3ea8f1e6772bf7c19221a58bb21f8beb3d5ef8be94b6d6d5a9bbe5c2473239c3862cdd5b1c7689da8cb9c8bd78596134a6c18d973f225b79ba7e8852d54462becc5cdaa8ca95674b95a94daeb90adc9990a81db3841bb1f3c094e3c14811b7d3cb9ee7018aa77d0389f23f55c8c9c9e98ccfc626ebde9af92ce3519236d28c6d713a0c44c438132339aebe338e19aef98a23cb168fc2423c8cf602e09dcf2e0a082d27143d39786120d30f0763a8bb8733dc780457dcb400a6fb1209f0186880ffce68d6ab996c95455e43c19d78dc24f45e5021932390452ab227722d32765ab2e6101a35ef34a4404c01372a6baff835e0bccabf06e617cc25e374fc95ef0404cbf39b2671e1091a18b3dc1f1fd7e4f9fdfa1b269eb428e75256ca420fcbec289f86b45c52b9dd792ad3845d1bfb9a92de01ca29f541f7525e45010af1a85ac16e8b18ab4a7bd5b03e76576931efc9364f18332e414cd0f0f637ac5024a2dae632bb7366c3bf278acbe4388ba45b92b591fba327119d61801cf44978793b09937c2c43b602605a7bb340277fd37d7e5f631ef236fef67bcd57e783154bdd4cec920bdc2a72a7063973c6e1139aa7a1813efb4f2a393ab22803f165a3bcb7f9e7113066bb85777d8d4f2083c9a398b1a5ce08f8b9f4499a603321deeb02ac7553837455e1f67372fb387cc24d60ccb235af88a3cc145fac63a7c27e69450eb53cfc71fb2446815a860a94614f767f6134e5dd1fbd785f7699bb6aa5f0b452befe50a3b0e0410d53b1eca2d1d1a220f9c7bf325275b4b3c37c2c2ad34fa15b3c9196c6febec22c52340ee15715726605bbb467edb9deb4e1cc1a9f00bca08e94fdc689b960094807ac43a6256f2678bb69f5b11db774d5418f2da92eaed85dad73829db6a0035334325b2311b219da6a2d7fe5f680a7540fbc84073b2ee6a76e453b4840d096abc027b4250558b3edf69057944cdd543e238437d65177cd67d88554f7341b5a0dc34dabd8376e805fe7479c61eddc84b75f7c135e572a84ec30eaff7a876345dae34098b36b20c4fc52a98c10cf2c0203c3dd1224de5473584cdffcb63bf2f7065f18e1f5fafdc5bea55d5345d3527adc00d1dd72c0151e710b7f781835d649c708d93dd2ea9bd394d107d9a14d51103a4503e2dc83a88de5f24c125ce31856fe90d1b9388a8fc57a3be6a6b8b431367d2c2d0e0981da7cd738054abc5ac8c3a00185dc9b629c6619369fcc8f4b307061aa690241b135ab5be5a9fbe08d7ffcdf08876bcc21440b1cf2dfabe5c59e0ea2ee5154de3bab25022ab6909d3be5d33b5e1fb63f1a32857950c5c8f5d630bad2feb455b9c395e33bddea861f265d2979b528587d404e77aa7b0c9f8f2463ff6dac4e5c0c9a7701d4013f19c4e7c35a2deba339d6d49625cb9415470148db297b613496f2654818f3acb0f0ef43eda36a18c31f1af2a8d6e2905b7794e584289a35b91879da5edd1107056bd521ff76129a5a24a03e6828127493d4df9ffb65afcdd3a75acd2f1a14e64aba5449604f948df6286209b20668dbcfb4cc2ebd0b7c33ba4e8b4cf7918525c17e4468c1a0b77bd7769c8271f4cd4103d845f831b77d6e6cee5cd7818a76242e24ba0798adffd7dcd0424d14d4881e8bc39aceab025c35c5b22f15a23976dfab5354918a59dc7e99bb9777e40150d9088e2e108184e34ee78d5f1b49e46856fd176175078ed7536d7878b2983fa4d254125c69c6314fdbb367bc269ff2e6fa7297e828bb6ec4b3612a36e39b677be518f67771199620b471d94577158e67ebafea47c4b652c043d43c356e39960d2ff6411a452dfc90263d109ef02346fce88a96bec2df4be21f9c514ff901c2a1149672b6b8672fbda6a28dc3133609df717d4f8cdb0e973623b0ee2c9b3b7b7c028a8f9c60a6ad883e18893cb875ae6e654b4caef1961fa466c1a50486ca3c843643ba8a8bbc81052a0796c5cfa93c2fe5b48c84bc9b3104904349567219c0f5f085daaa435930ec6c191146bdbd87658f5c530e0a2bd8de1ddc8d1d4ca68a4aad2b917c8bbfd5aa8a262e14c8498c09390a2bea56dcea293e7d7101642de717ae32ac668cc34f0fad4ede48f6c3844fb23d3a789b6f74bf960f9b1115109dbb89fcbbcf988dcd4357a06549b669d9a99f0e00c33895bc7add27e4817ebfab8174bfd714df406febfddac0a3567ab52405374650b54aba5951004ae00b25023e128db295c7517eeb7e77b878b573a16390b8bcaba2733c173274be3eb294a35c1030ed81a184a4d339e61266df8d99ee1921ac25be7c3b99a90f7f5b997e6114066a45bc4139288d6c91bd2f9fd55c3f5feb0aa0afdae383fef584156160cc81d49f16762b3312a2b36fd28c9366a03b22ceb60d08d600e097ac0343cd948f3613551d2c9e6e3920bac1ff10316bb8f2578e3083cabb35106931ad14f59905616b19482421300223ecdcf861e09e0d73bd620f42e0914eca46bbbf95f3f0dd0ae01d12675a9ef0d4a0fd5ad3f7049c6f781b54d92e7f95b02b56d2ac1835ad1aeb50f4dc03ffc8592a868046a1f7103e4aab34738dff9be96114bf3748dab0f2403b5e36ef671a28a8f0785dcb3ea54ff22882648c301cec112b3f1789832262f0eb85196cf9fb7283d670cf5b440a06e0ec91e9c33c46d809d3bce9d4b1d2c91f2c0b7ed868f1af76b3c8ff49503f36067ce155cf8aa2a942602d30c58d22ed8358d1755330ab03a029417a1c39a7d8c4dac28db7ef6a8260abc58b039132c19d026c92a81b7cce97171783e4814a4bb58a38fbf1bbfb6fd82e6a48e6b78ca6d60b9b4d5e63a1f0ede36498c0795ede670afff6afd7934d2e7ffa848b22df4df7d474149b99e8dda7883562c655399b9c79abe3ed2a54454cbd1297820ed4c0c78b56efd98416e858f964b3904ba02cd364f2069e4a5db76e545cc683b66f449cf46c5b33567f698bba0ffa47350e58dacf36a2542e13ed00238e7cb8e7cf8f87ba8a4f4d753ae994e9eb0a91a19dea4596d4a5388f091c0f6493ee38bd1dab3e97bc36267bdbad12fd3144e0678ebc85177bd4634d59af68741a41973719238a7602f731919ad95051834412ed7fc5c829b792777ce360bb2ffe472b39629373eca2b308155823bbcce19b4957c68eaebd89e0e1a3c7c2fabd25b688e9eeb82daa241a158fccc3dd6c402242df795e614222855828948fcef158cf15db45ad3a2a531b1c9dae1d0f236dff73c9b1614f54f3efcb6f4039b39c26945c63e6de68fb828953a2cb8fad1f52929e179631f71e1e8120ccc5edda6c8b8d056c648cbe9738d1e86876ef40ce9b01c9475045a46b28cbbba202403fc4ab252248d446dfe13c1062ea6f93690ec3ca47f3afc3022f04ec9552b3cbf56c1b13f4d3ab4db96b8b7b45a78fdd945c2abb35a6c23f4f64875f2034430dbeee71db4661fd96889693797461eb4b3ff7532e6c1a9e120f883fe887efa32a7027e403fa9fa88eccd0de5a9273741df2891e7d667be6fcd2263a9939bd0c5df0bd417ecbfa9692e2e7a727e03cc67381a9b876efda442a300b480c650b2c178c1a508aa491aacd3a7831035b5b5d6399c535f78a4b37354f94c83ba30a1bb7c8589a6c2da13ffd5fc4aba47a66f63cdf3b5fdc6110f6f8398454f71b2f7798ef4d7487c83b24c67cb1f3efd604492b2aabc012b63a9bd59d3b754057c752ba41e682fce8f4b4400e70872cba6bd682d7b349c3fc3fa21c39c5b4542ec19f3dbdaee9518bb4d6e6be9e45ef2c9f6f9f1853650945b7013f2ae685af6ff556f38aa7a4b538009f411799ed3e5537ec304defc07142b482a17665e05d12ad953fb96b8ce1b8647b85aa019df8332afc1f6dac84e59b110b260f387df321189465be465dae2836fb58fce510ec3f83863172c1cac96a50e635d3b62a24d6aa0565234a4a56c87b09136943dc9b8a14d2686a476026417b41b8f425a25e27fe10ba4e80e4c87ee7c5606530c33381c3e37c7eecbbdf2793c60caebc20c75ff288ecb0714633b6ae1386c9bedfd3c419c98e42a397af66f28711b544b7e71e8259cc71abfbaca1264007b8e33af5d9b9d3f4cfdaa90d62df728e5a34d29b5fab133d5c15a31de42cf014c0e710ef40d9ab61d9d96f4ea462ffc81481ea35a74938314136fd8b526aa436f5dbf04d1e6628cc9ca5e5bf569de0dd53128958098391aeb4c2c2c4253339c79dec7671201e68331e3a9a988c043714c42afd9077910f1133854adb33c16b15392de0679332b5d9c3dffde7013851c838c2e9b72639d9009951629588773f17dd3276d400ac3da06560a01d23e0547b521bd2e7730ee89519dd5136f008cd63273baf6e64420f1107135888b72dabb2bb087b62b7ae6a5413a4c49218f1b96e00a311e1ea9960673d362a36f8d385697c44e32c05a12ea3136a49e4c47fadcce595417f5a86de34ebdc5de09b754b8c6f753ecd537244d4553c4262ca8c9ddcc0e902e2ac82465dc15c866325d7879093dc70ac8bf829dffd813f897a751e41697e04ad1bf4684793c5df02b751dc5e3b4455c637affd31acffe443cfa1646a4c785a9acd61d0f259234b51f35298c1b0da8616de09caceece740ee5cbbd9937fe81869181e6f41ea33ccebc64d5823dbcb2e97aa7bf874f785a60c3eadc4cc463f41860efc682204ff6ca7f2600717807f3e0036673c668899649a48f327c29f98c1e7a9944bc7f29ae615d96a9d556fc1608d5425db2c1d109c5432564d5fe9f42e77d2a320d6af5b2dba0bb17500ed5410d75d294d8278e3ffbe64752c4f094f7c79605845f71474ad43455f5be9de65f1da940a818e045425a914187b1b72053f96d66d05f5d027ff15adc08e882bc37a45f34d12e85748f3bc7461ec287060689b7da2768aadfea2845f87933d316d80bcd71f0798021e991df0289fb31c230c77cd95eff7666a4a3d188e6942d73f7844c667154b98ec9f892cb2d4122cacfb2f79e794ca0b0c3397bce883fa51af80b9cac3c3dbded12aa1d5d8e50f0c0b57ffe206fb6694fc79ccb17538f9bbbf094249fbd666528b54590e5d4cfccf979934ad23f75387a024e9a41fb9350f92204076f15a3a7f4d315afbac248da99b9b5348c318ef5c34aa5bfe430793bb6d88c2aca4dd77240f7cf87247f3f0a01bfd8bb32ca44d9a2b32cefa1bb72982b603274b757cd53f9f294795ee42c8168db62505725e5049df1c223cd4ff486ccfde2bb8abc7d787361426ba485cc721a8d52184cc3726ed52d3f69650af126db69646931d1fbce8991fa0821fdb796cb6d9a1a87dea017d47c1560bc501df39af47d7af1ac6bdbfdc459f23a3d37169e84ff71b66cd3bca23f498cc643b2b3dc1c8d50a6058199c1dfe9c5fa3220d6adc24e4600a15c2c4d07b92c1003bd2da5c43ca74a8779cb8b331734d6611c66237fbdcfc7f678606e64458f0b0a0feb474102360a3a4961f0f2e20a5d21659337371bfda6d364b066f12a4503d54ac0111c66a14735132ca708dbb340f1b00a18b5373172dbe929348e8d0baa3de600ed7779bd9efc7b0c0177880efa3fac38cd81fa1226feb8d0086cd3a4b0f4269680c4f48729d0a876959e9c2fd0a1a7c374e5937f6cec65b3c762c044c437251045371f5ff111c2560e43a25bc3dc1b4629dbbfc026b21ab59ebf745f308555e092748290fa85696ac2a33130019c9a68d5c7dda61fe4178eacd103303c801212a70e8c8afd804354679b85973ceaee6c5840aa6b1a334640d9147805cb2140578ee78ffaa1d89e4468ba329f035682875fceca0006d5d73de466bfccaa7de74f994092095eba40c521c789df88ac034f122f92036460816a05a88c9cdab31c2d4d11d3565c54cfab4392ed5a133dc00bbf7c2b0e643b2b036c07a53a536ed88228c49a5b6fc2807304d04c967b426c31c023ae33c0c073d109c6ebae369916f2b46a3b4e8a785ce2bacb86124124651d20f7559c0e41c0c440d8207d9d129bf2451aa0a40334caa552951e5c4cf2e99a9f219a661bbb11a842ab762a8ee1bd45aa14f840d0777fca1766e5c4d5d47479d59381718f41bf8685dd5859efab604ef2e3c74d1937dfb921795f117aee2885a10bb35b3c5bb4c01e81226b63d57cfb6c780e1b33fe89af18541b7f44ddc29118f38c87710d8877c1d3e241fe1e13c9e60ffdf6f80580bb8594791f05e2224f4d4a68377f66450cd662d439af3274b838156a21ade99078f5fa6f2bdb23a2f5b7780ac984b9a4e99faae36bf37368dc02f56bdc0b7bee8acbebf856f5602332ba7232bc7264705bf238bcf17e2d7f3305e5c20477439df5de1bf897a66d70ff00e1994e420e5a810ac2afd11f1f6211e665a8bba55e29f194d2ec0442f60359bfaefb4892e519c9b4921cb4687a2e60b412711215724b6377ec7b7010fb4118512195dae67ab7e368caed864529ba4bed797342a02652835bd82671f8c89a1819a7b0eeda4ae5f684bb44dea23f0ec8296019046e9d791670e1d5d82ce7ed96efcbc578eb0b70e5b5f118177bb2d8153ac0749dfa6d240a8a56cb1a13c677f150882bb35d3c1b157bf8a2167611b2b1e2c2eb0af8e3620abde564f31187d1b8808442cec39b929aac9a0a59539e56acc8edf632caf2a4e6b27320c87647f59b65234bf388d801a1e4aca50719e803ced5508548a71411bbb574f216020d3246d9717fcd77f53e35b3afa8fcf667fd94d7385e62f72941ab62153d463f3f67a37683e1a475983f03e516d31c44f1e6e807064a0ccd4f22c06ec2242cc6f1399e8691fd981a0694eb88fec9bd839c648a8e0198d5328d87254ed1fe90a53a8c2df2adb79906cbf3af7ecfe54a0cd4909c5b885dfc0831b0bef38c19812281334aaf4e6baa4435c682c4b04ad356d635f06e4fa67b133a92d46130678f72403bd796d0b9dab76216a7a1f2d453e39d14b095709109e5022638abdecb9244079a8a3721d6efc43bcafbe0e27180f65b85977f57c8e47f32765f0f026a66eafb0a14ef638746999014c851c7b96d8de5ea8e31179b23c2946572702cba7d6bd5c026626064445d83c78192a15a8660b8252ffea883d4bf0d436a7cbcb94752ed4ba5fb4ded52155e7ec7f22cfcd92128d123f54f6d6e5d06029c2e71117c4590cbb063e0eafba256ea8f7c983d5927f8fe46af3841d9869374449dc212f6341502e7d02b49b43f6bbb7eaf05a6176b02f2edda24aff562da9d4567bf4f6c01f121efdd06a7c82729de1285fcabccd136607974479c885794e7b5a9cfcd28831a771079ec7c0936986635679566f8afe65a5a50a3317142a99c8898189ad27e4789c1adea2499e66fc44504d5e1a1d26877ae17f1e2591e0183dff92a2bf6e1d37cd8007084533c216a18e1749f86babf002837df8cc3eab0b1f5346402ff09bdc31f26aaffc0e522f07839604b7ead9f11de3ca3dd930bf1eaabe54ad72127be763ed5a7e1e0ad04b2016128fb49fa67ca0219dbaa558d822cafe6656ce9acb3528c360eedc63f38119c307ed6c139e4cb9dfca683bf13f0b462834eed90f4bc793cfff60284de2a4c7ec40a10ca7b939f0f3cb411a272e1c6c4fb198f6eda524466ee1763fcf7a8aaf4461af0878b6aceb554585972b4827777d41acc7c235623dcbb23c49d0e3282155a97ffc522dc50306fd107b323acbd5d0eff061974f6f08b1828be678616e518994745c781083e111e9d6581b877f9a87a5cef97bd074a8b88d87d0aa7882c65796458cbe515b9423fd87587229a5b46dabefc79acc2597bb2c7ce0d96adf5452ac41ce91ef3db9f3ebe8cd8023ac72b7ddeaa94a8590242c05b393a5a14b861d6d96fa3f66509daab5bad5a9f7e3bb010449d500319524ad7cdc6aabdb71c305fe74c61b734979a855bea0e3b967948f7606762cd661ecea11b1263e4ffea3ca6758da5c0b09d1551ae26162c8d2f638a0e961f9ddb27d318980b72e2288002408dc89b2d492328d5aa6cda6bccd7dbd2cac7ff26d2baa5eb56a65616981dadfdddbd995b500f00f7ddcbfac79d2e006efc42b9df706cc7db87d6b7a4cb341c243c424b9627de8364e95628f306a625abba5d2f4561f6ce961f2c8b17f5cb2a1646e3b679439f5f9fe9ee99188d54dfc09ff39f02bcf66dd99c7ae42a2934c29cb5ae959655df2bb6e93dc607d1ed5132b0d8da5f0b943c2a3baa300d0b9d387a8bda98d0a14931d224d2397fa3eaedcf427154aceedfacdc887336a5c4c0155fad9bece6d8d68ed3284a712a771c0b9071951627fdd08d37830ca02713233c716f6e5eb8853d66c343a6eaf29e0214dada49141a2a40dba3c21efd1bd50630b6a9b2da6cabd8efcab4a6d1e1db4d0c661557209ce4df3256d17dc1cee758d55e8c8a1e5b1af70c2c702d4c24f861d51328b06949dfe66e4a0e981dd03ca47ad3cbc2aed85653e21be79a6927c08f4bd84d68df2c2294c66cd4aa12e9dc8d2d8b9c212bd879eb3159345398a7306172eddffcc4f3868bc2c932a58e6ab69bfd29e4a4b9258d74a679bcf86829ccbf1f329cf9d3d1471bce7a0b277f02f739f7eb08f5cbac824a305718a1de991d58cb66b3a4d801d778fb28ecd4f1ead8c08946bdd67fa7a555792030f36280e4ecf036a03f1cd829ecc3e02ab1222c9d9a7332a850e5eccc37a59b98d0a7d51726c7a15d69656bd106958e54806d1d0b77d38c9506b1e4596dc3a9f86a52ba7bac4934d8aa29fdb2ca07d8b942adccb9c4d5adfb59a916aff6ad259841039b28b8a54904901dfd1be17e8e266206b3e6acc7a840887bba7b708bbb0168d754178c340661ccd3429b40e8cf870fcd5197196cc8ad1a1822afd55ab61f84011c208921643e5624b8759904cb542ca3417b990a91cd4b2b02e291ea39a98fe5f176708668202c75c71fbf04bbe84a1ab354201962535455e5c4c81cd47fbd5c9f4ffe00325e349d2f4e4f7fd75795b57a0ad45453ad86d02d5047f3db168490f97ddd29302c38772ddc006317ad86f9cd442cb604d68f2483b1dee563fec1eec40cb499cdc33b7895567a5598a4f9069e8871ac060b6782dc181bb06880b2aade67903e6bb9125b7a457be43abee6432c76aa48583c666953e524cc3069ef9467178607b693953dee2c8e1702a655fbf4df368a5aaefa2733d7120ec46fd2fbc4c811463553cefbfb8bde736313a34c2b831b410149c87450481cee45307d226929fe895fa54c804dc5e5e343598fdda96d8ade2622507749e9444a320053e6eacb517f7fb3fd3e954f93d5ff0e2299bd67f93a5cf21af6b744ce24e4141641e70e961a3b0a080afe196546fbb11d446e200871c85684e3df40c1763730dc4e7c6b6cefd1182b6139532e44a5572cdd166f0afca2682710951350bd89cdbde49441f98d47247430263b13b9ed8d88a8ca7c433a1c01e4ba741baf91bba0c3a18dc306f5ac81f5057d6167acfe14c34862b2f42197ee0f49046d5884d27010fd4dafd27abadc633bd1109f58dfbcf6c49d668a514345c1f611be62bd4fe5a20b62081dc4f467dd4cabd052bf1b2e30f688128c7e3aaf957508444da7c4527dc2be9fccb131a46f7a19da6b95d0569a3105d9763cc3867707f85db4385bb86e62b9af40acfcaa5c37874f38fe157e4d9e55f1208e8adebb021bc674f9e1c227cd730269396f3d1f089fae491f41454257ab943930b172980d1f53a85060baceca0c4073ff90c2aa5ead6e97f3c249a04b49960dda6e7dcb254f56bfbc1f09e797956d64201c2ff27ddac74ce3e733f3f2e653dbf3f29adce44e3ae2f88c8c22ae22e32df6462dba50c8f7f86169761803e0b597915161992776f536c39d4b5ada03c0d982fb3bb0f3f97bf7beae926519351fc8180a771d6a838fdd1ccc169372bbeb8b313564b5622afe67bda4487eaaa536cccf760bb07f9f0da882ac359e8841e97b3373c04dbb40595cb8236aa8b8378cf100bc41a24736f25f8584e55dc951f6166af6fd25a5d62d4c6fb7ac751452bab127800cffea8b9ccf6ec33dd98eff7c3384076f925381da65e748ad45a0738bb9bd311dac2e7b0ccabc0188efe2a54f8bdd144759f70fa066777228478d000de32744552921737952156b04ccd61a75acb670cdfde6d4ac1d2a7030a50dc3f2105f39078cd31825fbe277a6a93fc871c2c425e1e3df97032b8c37ece5616796b180020d4c9a61db3369a8c71faf844684fa1c0e1b701ecfa0cd255de6096187cb4a6fa5149b818dbe6472ec83e509ad270db06092f2240e250aa811688dfe6517a31e4971572d29ea852e43bcaded91edf0683d30737133753069dbfdd40bb9972d9f613a95263df1e01511cb1155815e2c6578c56ae69cd53b7190494cfe5c5e67620e5575e0d491b83306189b677c71622e5bf52f0817dcf4f6838be3f1efc2d5f1fc788e58e35e2380f890a68626f8fa4276db41bb370f5e63d70fa7ef2c44e51da0a7d97d0bf4b18e2834e2f8d7861093fcffab24dfb17b734588e5176dd2ab293cab423f01c674502be8051c5dac25ff190ebc0a7e996cd0990161a5e664e60916bdf051ae69a7a8a190ecce460eb70fa9c007a79f65040124c362cdc35ad6b381d262b72213c16c9b5b6da3a4d3b6c682af5f714d9743c84ab75cacfece75c3ffb5b2d9200d9464c9f57d3149d26a55c9268f94b87505db023850747430c46dff9838c28320566d531a753f87d659eb90b30cd644a115ab4eeb56ac5de309b38565e9a6db3b3f7b25c9b66428081a12012526a1ff632de61b9f3f093731c68b87c0e471f3b2506e24e2e31a64aafe06488de9d4d201fc5b27157d3f2d1ca89f3c867bb2357b7bcd28d6a2a00396ade5115e4d643a642425218b7ae4f54cffb5b647c2a1d8dcb717a0247d791bbf9eb1bb61c9bd86ee4b35901729f8ec1dedfca1364ef45e71ae6ec415086eaa3cd47ee4dc81ec3b44dd8a4b2ab3525f4b3853facad8847738d30fd1662d2e4b03e48487d59e084450c25822ef46af1693b59b6ee00f37f17db63a11318f60664d976e370a55f19d64cf79208a38e84aa73b11e44f8968080d5ef626e663cd000c23534ddc3e1ef24efb8f8155a1209fe0618f5dccfc27f86286a4a9778e656529088490a24be24f1ddb333110cad8d2d03eab19cc6ddcb461d607177c6e6b4ce80f537f92cc787838fab2488f74954e2eeecb6906a1d681c8a5e7f507ed8287f3f9c9012a0af6713e2031f03b323d9984751c7d557433dad0f5c74ab711867d8b14ac98f697d75f9609997614ad197ac556f0c0fb8dc945d5a942ce6ba50e7867a15a95b0a1b9c00b3a762e5d9d928087c16ab6c03da769dbf243e89e0c60ae185c6e88f5d4b36862d842784e62fd0f102d7c6b162e6f718edc5c33092fd05048d3a2f8527684be536ebb5e15dd248f3038f6706854baeed2ef9f77c27cd6eed89c547c36e5f53e3e2302fc9fb6905f3dc73616cf456e3d7deceabff818609d62a52b1555b91c7c777b7a32dc2e14c7a21444f369196580c43039b577819ca03934ce2d0b680e93437b4355fde68e4053a9a30f25417fa6a0f1520a23391b89a04d50c580a731427d2eb54f5cf84ff790ee53f853e6565795d6127dcb0375c3f3728efe419df3b66ff39c02e7df23c0843adc454390ee09a3e4299a4be14a8e7032b8a4d2839dc86886a3bf001daf15ad611d269fe33227fa18df887650423891ecb30255921ca305d0bbde6edb025cdd073315d30b773892795276670c83741c2f9aca8fa728769d70fdef3945f9b72edca115a142ae66c25558569463000de0c535c3ddcede358bf7c4a0bd30d7439874aa1641564364d7ca5f54404b1bf273e7d2cd5984c6b9e52e10b5d670b3ffe2185e2a553cfca417a203a472ca35001b9150196460a34b733f2a1685f51d5d96c8a95609eaa07c4a8b4b2932db0e53c941008f930603aba87c68c4e33e4e112f02714f8cf08b9a34e70e88a7abb4fc75a931deadcbfb1c1f48ae7dc7e7f1c84032a644cb75d76bc459a74bfe27ced6ceb05a4eb95a0229c6e1d3cc91feb962cfff9b368779831932299b8aeb95121cd5444fb7acac8c85440a2e841bc9e41aa995b041dfe628fff400176c32089ceb1eeb1955a4ca10bdd101d4ebfb2e7b1625d0dcac71b6710673666aa1889a8e157134449aca1acddf8876b5af26508b1f9e5ace8d79c115367bdfed93650c8613ae44e6cc6090786eefacad5438564d02a1f33817e9a21137d93bb389ce91f9100d212e5a061d292f2cdcf2877f692419d00647b9f295b685eb09111ad5e92f60ac50ac41bf773698941c0e2ecb8b13f58ba72a73b2355851bc39669a2937618db2bd6247f76c22c400a384150a3aa55e69b84ae9d64d79c254cdd50b0c4486f5990555833a178f8a6c4818c6d0090ce4b65406d1660fc280246a926374cf91fb0a3727fd9fdd11fe8e8938fd20d1428b8d2c212f2edd13386aa5027548e72f0157073c05c1d6eef2fe789fbf2df1e4df39040cc162e174dcd34573294f00b5e1b4567783fb321c8a71ece2bada16e4a4d0fba8308869b27967c13902294b16500214770f96ca43b3d73ffbd9d6dadf426a061f366842bbd3ea7b302e1877a6860bb017542fb4904defa39796643c61ecfb0eca83768120fc3466a2382e547b9b562c4ef1a3948a7898811f4129f7902f474b5bdf35977a30d9cfc6b0ab51a5435b7ab2223570b84bacb5ce34970f15f91b792265d922369a5cb8e2538be654cd42acc3fd0d41919194fe9d3eb9960fbb171f51a5cf9d82855e2332e5f8598cdc49fe3faa651ba3baada341d78dc8cc8cc5e961c62130ef4d04f3b930e879147043654ea5faf0b70e5e7e66737ee4bd5657c69b00ddc9e0ab289a5a6eb184cc2c283e6b21b324fe9ef4ba9bd9e7b11e9ea6f9e2232ef41c2ef1c7b129ab85c2b7f7f410b7c380f5c2574f435c66bb4d7c04893ec9bd9718750f236d711d44af7790e63dae73b24fd405954cdd30e1e893e9060c3bfab60f826e88c1d3d60f1dcf7505785fe65778f4b566499d8bb25982ef8cb4af47c6fa365dbb9aded13c0b36a349d6c4723a23a75c6ee63b57b3f81446efaaa01129f08fee8ca5636d1362aae9e53633c5b74bd03c7df275e31a5dfc3f1743f08427732e566e9e7cb23502f02695ae8d166ff2529a9bdfd7cc43ac3c04e4ae072dc7bec8206e2289aa27ab52224592be07ed40afa1e9aaa2d52820b710acfac9ccc708f8746d9fbb1b30ae05e64f2c2afb540fd1957e552f1f18bf1629dbbc241f0ec63c31dc4f631cffb292b4e894854b8c33b8f5bcb3fb3168fefcc43933e5b4131b4b22319b2b22968d47d3b9dffe542169255ba6e02b16152e4d9438d3c743d26f64af6aac77971cb7f66abb502a9b0ad22a34ea78c0ae6c26a2d8bc88a560754c17d3e2d3d97856ef8305e822f953d301bb7ee09870518bb84a305a5e11f30fd2cb0d509af8bd574176b84d92b91fb2818060244686c83380ded1ebc4172debf646781ffec8813ad501b859463acae0effd0de93626468bd94b2c5b72f77d551bc2503f895afb49937fab259d315712c04bac36bf66bc7b5d94ad5c0715363df94319af695a3c5b9e18be30b8cd1f3b0033c816ad4109f185c080f2fd8602c5e2abe59cb8f150147db653c96e3671295cfcf7d12838df6cdda6d327bede2f18a035f55b9c49215c44201febdb9bcf984318cecc02033032c1ae02f71ae64ae81c14011622e9bc2ef229b406302c886fb20cf4bf73ec1a6f70856bb1141ed06b580e46fa4686e83d90720f504dbfac00039cc2e733a8cc64d271fdc2bb47950953c7a819612e9a9a5a512bbaffceeae2bd7e89fe6d3f1fc18123466e2b336aae722de682a514d040d8b94e139efcd77b2e7c157917b413c24f5fd725e4b4bf36b50f70f7cdb5dbf7cdcb38836563dea6d01872775ff7f080ff8d0e45e8eefdb12f303e0dbad9e0b99385ba91b6a7a258832fd2e667f46dc8252eee0c044ed1d1752bbf90c4cfeee3941b5e365d512cfa215ac59347d609f9748c79c19f764a8ad440db37776d65084e30d5a5de88c0fcec6a288475d3de1229be7c13cefa85da417057cae5bde48dc868dd11793b5fe3698bf4d63753a83d6563ad3a670b51ada2bbaa9c7bc93e0cf34202d42fdbc9ab4fdbe7846bccc1e5db88c4c503de9f15e65d2eceba3526d5ec02cc29ccdc97e6a4728f4a717fdfbd4702ad8c4c21169c8a1ca52df922a2c5e2c178cd8f8f3dc54db71a07565057e5342b30849a49d3d3694a58468493ab40ada8e19eff39bc4daafdc9b14eb11057a4052c57fcde6f04f261d1ca8eebaae8808ff42b324040246544cba31df2789593316832513c3dda97d9ba95836955100bf41b1dd3b76fb1eb4a9367bc8a22cc27ea974ae4309f1643496462e0451d3559f1a5629b0fbe1a274b8d5448b63b610af66837cb947879b75375aa5bb205be2b7c42b8fd339f25f2edece02028fcf3b2f8d2934231fae77afae330d55b885d457b3b091d092ae6a405573ff13acebeeb4807baa1f6ff57ae1268eb70a76af1ebea3fd27c871ed01a49dcee827550821c1e4ecb3dde520851721224fbaa3eeb1c69d7d1d53364c726486e9142e03cf239ed7aba47c80e720c21c08695a332bb12bfab2672bf7a2c920d6c64c31d75afb6addb70f29a1fe0d4215cd6934ed48af6e3f80f3100285c326b576473e0d642aabd92d21ac27969792e52150a9281b34c7ef812a079e3efc36b98c1aff2212fd08c80057c3366ca51651f0be2177ace1ffa448fd5cd7b40fccb216976de8180a97b061deba8346d0a349506a78c26d091c9fd1f84e4dec256984b5f18ea5714ec78823855c97d57b90801faa1b5859e93788f97c15ed05d73a4bd2811c29902d3c38b8af0509866e384df8b14de0e831b455f6a3ac4cdcf44c6d9e3291a798cf619cd99d4f9d071d5022112be41cd964c0354d69e96079b90d3aded05ada66025422bb5d289478375d7fa6646cca7349da813158f06b1db3c5a17338de69ffe4e85839afd02455921833052f0bc04d27acbad320ca1048110615a9a5830f0272cca37c383a294ab48b5ec727617b125da07d5d284f5fb60892c00b11e89858edfec5066965caa87a55be1f294518fd45524acdc80ee361fd6327672b6244a2e8a552ad696e8c2db08ce8380d5f4b4d2914d07c9dc7393b6a8ea9ceed22f0f8b492bed0a84a91b86c1b4a6bdea01bffab734f38343c90a2200e9072098f71577a3d0a4c1ca80828b3b8d5fe67f1383cb227f1a71fb472bb94c937b54902415bf4f45ff333b61ef8f1d52c4617f1824eb6b221deb820215d7eaf67b8195eb792582e799aba3034cf5ffca810a44a3fb0e8e1ee6905127af33e7795f35409a51261411f9bfefb593f4fce3ae9f5ac560e4d247b2f694a01916a1560c3bbc4177cd44eeaf5cf0803342abefe387bb5eda2d5c6ae1d8b75847a9488847cd2d7be751e7dad1ed3e76083ed86a917a339a4b0c3f8d9f423bce139f0aa4ffc2249ad72b04e22c8187f8671d8085c19e8b920b9c1c53b710e1e0ec9adf5451f1f7531777ffa5f399493d1f6ccd1d0a8d09cc7831d87e0b7f29c9a80916a4facdb90537240a5c495c544d4179e79bcb5c9c0c227b1bd335ef98d5600c1004d6422380cdd19c35e35d895684eb8836b3b5cab1d9d2564a1ef4d8fd45b53bc644bc644c75150c63eb5da8f1918a1aee82b70e7e219b07b8aa2295547c5510628c2581155f96f7ca5870f1d29436ce3d04f1f1e9ca97879d871e99c89f557ae549771b7f77651985ced7634f33f68301397410c8cf2517fa45a369838239c29c40cc162ca37e17c2afcc7e108bb98c16cbdac1289a71c959dd74b6edb7f7543c212ed55309b19b8e784893f27c26e679f9a9d3240f54517f508d88cfe3c580427c5033cb808119f3f212f48f30cc8b9b773416701f12655315d0f15e0a3ea1bf5907046f526128fcbd550572cb8d3a3c5acdfe4237114702f2ca4250dad0ce908974c89e3abc4e5c7beb9766f8e84afef312381b6c39f16d11db84468c49207a6c95733eb140ab5478d862c237410164e60fadc6348b7b52527c8a3f3580b8ffc34237955dd74418d8ce5c37c6e0f890ebd3b763279943ed88fbfd12ba8d4c0674b73d845c0b4643c3e4fcba7971497f4c1229c018b8821054c44c44b0c99201774a1ce5d204ef5a7da1109b01b5ddd1f1cc952cc223d170b8b0b3ff90ba4c836ad3940705805ff2499f73bb8ce07cdd9ecef7f64ed31097ccb87f2450c5685ef7bea5f1652cc84ccbb99aa2c66b62a494afe210707d941ae74e9c73b287a75ef08ec0bd8b12b7f8b2fe3488660176d39c7e0f32416e200867e8a47f5b9168f2c321aa8656e892a72ba27c96310136494a1a49df77bcdb0e935c0e00cfe4df62b2dd94fc8f6acf22ebc16b13892f2bb3121c61ce571fd02e8b261f04ca61aa55003626d5a0d9e7ffae70b65a00a34b40c410d1a579d2ef163197fa23f023199c058e6c5b617984b4a97469bcee145d8888a7b05dcc334cf16280faa755b4b7d890b39f6db43b8b1376c01318675c226232589cda99bf4cd6735ff9375db75db9ea7b5b109bdf98835083f522c522172ccfc42ab3cf126959fdf8cee4d6100115a67b41b4e69b3f82af483b5d6eacbebcb952b924695e4698895a7817cbf54a06f3977ce64985d86dc3fa29ea72024fc928f35c2aab83c00b6886e107a6dc3b1f5af80cd35092c14953abbe34165609ccc08a6b3584d20728a3ebf799feee38a9b8690866868f32b76ec0a2c1c02262cd063f38836d26452ffceac4582953746014bf4e753e0fe2a0d60530b8b2f2ed3c032337b3a6545b63b534e3250302db97eed60d39e5e9cea1842a963ee2b5ee8e0705955b2ecf92f56d9fa9fb964d0e1ba51c8e24841c5284596b8d00dd865c2528d1f6d0053e752076d631f400acc4e396706bd1af04c90a71720f79ada597138f697f0029eb046fcb2e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
