<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ba6506146f1ef567dad73b3821271d6017d150fbf74431ed20fde85161cb0b3eec7b18e257b5e6cd0cd3e65f3c460562b98d20580d7c7490a49414ddf4a163da974b61b6b2867ef0b22e7aac87ca218d1d9d439d141e779e639e60bb4e858fdfafd403c2a064c332de30ceda46a9f85462b0035a6b682ffdbb1ebd9aca9e24488f464bfdfb2d0a08e2788cf7924739efc953337448a4f410b77b16a4a0f69103253703d91e40f73ed060e5c1f7c26b063820d2b25c3a59a71f4bc85a9ca5ad9529a22fed307dba452d1c4fddba64a7ce1f34be9f0228439b89043939ad7cae59d3bcc5a41b6b510e63890b9e2d3d0849ef81b9e5b492f68d8fefca153169ea88a74cef9923143914def0fe2f11fa63548f79446b756a7c259e8452630c4310f0677d876a6bce729d00171aeb31fc746e61ca21d1c7ba77fc7f3a428423ff158dde25ac2384e9d20369e0fe25d6ae18974fad98989955545d4b35730fe2bcaf893a551053594a36af5675b45b23631c8e61028334416742c0adccb0195db75d1cef492454c5b575a648a9b773b76f55d17d6127972be87551ace961fe6523789f64eafbfc717c85d6a814f3bd3a7d368106a577909638a777b06de0aa0dc6a2386573976791af537e8ec43f4b039280e7f9d5ba58b938b9ab1f51e218f9c0dbd94b0f211d8541a5021e9e476a580c8dd8dd976a9bfd2f1445a50ad3b8894bc87ed3e949d06a3e43cb26f5ec7e2466f300802488d64989f72a7a901a88e83b2a03e4409594f0dd18bdb167b706d909100c56b0a2d2a131acee19d3982b5ebcbb64bdf2056fdb7505c76ff6926de197d927c020b874e808eb5e63fbb10529e85ae8e051604d9e68ffb15a3fd3a2c146ed9ff448a95e2e9f1d2b8f16a5b90bf7869de55fb4df5bc2b97ccfbd183745cc3bdfcdc6d84cb37fcae521063302ef3c44be7cbd498bd5724f2a3dc681a302fcf0ae2f4745a184d9637cac88ffce5311f70adcd71d9fb6a97921fc986c60139242d77f9af6a564327819a13acd2df3bad061cc4c06f6f2d59aacdc82a54a532ae63d4ccbab0b55f5d0c47cc55c6afac25333af09702f5b7abb3c08f38896c6f00dcda823cda8e913936bf555e3547b0184a651542624ce8fb0baf5cc5b52986fb2be51b1a4bc62232534f283ba24ac12840c4ad626cbe2eabd578d12ba56bda36baef0b9e04c4994788c1107c78722264f96c2ebf594f122b07cb30bbae66023dccdd0c9336ac9c6d3ae1b0d68e37ff0c3377173b7ffc631d2f85cef8a771d9cb894b6c558b39af2e2ab7e16da18c015fb5d4ab05e8074b08bdb44c1d7225f571f8a4bb2f4c08415cce05b79dd691fced63375693fe82f92d2421a9a958f868da834185e548870cfdb6c3f97858b26da67a72482615039cea5ee3548e1ed0235e91a1efae54f7dfb517235f81bab22aa91e2a8ca812aad8603c5f904612603be73ac1e530e43e3819274aa0814cc669ae9ade4f2f2eeb262ae151ff9b9a942458a9bd7d4d16584288973ed79c4174d7aa8d75bc666ac1448eab7516632f0d5e0b743ec4a4a3b21583901a457d9928843d7897e3079c99a61b23f441d048b68ad94f9ecb73521072f31f9759fdd037514b01cb69aefd10eea3cdb91aca13a2ee7479f6bf78157f3646f54df4790177ebc31a72c517689e4cae2416d3d5082aa919c0dd049bd3b655d86ce4e70ae9dc600d56cc769621045b9c32652b20704b6a8bb197ed384a9606d73c3b178b420da53082fc7f9815c4895f4147428eed76589c50b8cb992a9d6bae46a0c062f9d2d2a2a8e46708d2a1f29710429eb097f191f8ce2ef172f59182e34a18f3f02e5ef284e235d5fd2d5d4d351fdd06a2d1a7420bb577ae8937e67eab8f907d85ae76745867ada9b6307d94283730607920ddf9f38f2acd071ae4ce7ea8af090b2867c94c31f74612a0b1b363823bf88d99e7282440c70ab2b11f83f70c47ce20987d916d96e188d0ba3abe3cc38bc48d11789670fb501cd0be13fae7656d91da488e649a5a271a969b9945e95c5d6ca90bf0a4993f81edc49e67bbdb9afac640c5d2f6c077585fb23a48bc8addfdd91b5bdf0730cfe8c527126fddea476c217f8e1e2a0d22a4a09a65d0af80705de3cb1941f22c1be1ef269b789ada464ee4cb39f954a3631d2802b3e64d0989a917d9b27ea4c1daea20e00887a71d739a2397093006956e70578bf6393742827ca7ea293ced27e9fb787f09510223fd4e16fd084886abaec1170d4f91d6282da6a9bccdad611b2e4964916306d86a5c7bf5f605383b8d08669912265b7d24a8c83be4d42fb2c8ab5c96a273996591ec2e6cd62a1c348705874f7e292bbfd2004dea29690272953c4c95f13a9a12a0a9d20101f00ec4fcd4a514f96d12b0955d42cc1f8379d6469c19675aaa8218edbcb7c503b289e53fd1f09fc763d52f297989dabacf11ef9e4f4a64338dbac73a524169e930951c9b0433bd7f5e8aa66ab606bcf908f384b3d4bab6a563df0aea60eb6c2e391e47d712616fe95b4aafb9e15d8ad36c3710439a78de568fc440782406b35ebb540a087f17201fd31a678b52874287cc7e316370503b92cf37a8b5c6ee643d89d07fdc6b9a74e3e75ce81c11e6ed9cc954d0abed168e2d6066e5e28e9df00fcb41e5ff4fabd89a5aa6ac4bab453abd99fd9b16f67a87edd1716fed86ef2ad4cdaa4fd7dd9efb213197b95563f3230c6659eaea7ed517405010c1b0f9b8cb61a86caf61481bd34d62dded45a1570f114937001c5d32b50b6a7014718ca6b6416b219b2bf85971ed2b55eb865ef90e8449eb8d720ce3f42c3586536a30ce969e96379ae5acb7823f2313ece71f6ecf7b8842fe0409dfa0708c298230c4423c551af7a704e9e6084d62bfb872c17ead7ba3b25ae1d468e2b81ba0b5656dafaf89f1fc03c933325ef8f3226277ba8ee1ac4ab0149f1ae6edb2ab2a6fb3b19340d90e72b263b88503851f841dee5b1e9151e795e412d477bcef1c87deee938b2bd022841db4f77e558a04e4913bc62f349b120337a653709ab950ae9c58337ba9dd755dc0e7e96bef91bebc965983ebf10c85ef53264aa9868f92788adc7bf0e76a9f388c462e281920f593025dd385c8eeab91d993d31f8721d811aa5e0f5c11e0fd87fc5de0fd07e96ff7d1b1728976faddd4c2a2c3e5720d16e637b1aa7bb1b0dec6971ffb19eba5ba775770bef553bdd2967333f9daa213a068485bf8c3b67320c2d538ed0956362592e64f7df5fe0ee095730ad8071d81c06f8fc0660ab399b120ded4149c1c651db298288d8521a8576668c4d57e2dbaa09dab20fd5e6fec0f2c97e910417b2c3589373be53b72dbd0d9a1aea28757caab3a943e0ee6b4c962b7e3a2d59845b14a3fee44c7d270b0e629d6b56601c6e774ec76e864ef124cc4087ee109e7115de0552b837eaa8322244bdfb4673255f62e91d5b8f6129b5f13ca84e8d52f02c452cadaa9fadf94ea0ca5ee05e1b34609504b2a2476fcb6802747f88553755e2102fa256ae64339e8620568141136208e1a7d00991c6b4fdd3920f545ef23743ae384188ebb6afa2159d8ccce61e1e84b380ea39af14ecfa76f449b208563081cdd6e9a19bb6151e67e55f33fd243df9074519982fc6ba3d041c383529160fbfe82fb660ad0ffcfb753ea10f6921d22f9f9a6e18ea0308f4508a2323f214bb487e1e9ed883b1f8a56d1b220855d6f6f9e805feaaca64c361620b7e5fb119378cc937568099698916ba3f229c52b62dd74e898ce09872507f2534fea130706f47f7e64a61288df4eb3acc4c081808c6ff30dc7b0a8fdceba96d4358bc664b0d6f82f43aedee780c6caa7727d3041987e1883b85352ecd04ff1b5c1988f23541e302a905617bbfb79cb65c2a0855dc06bdd9ddc86119515264a3e871130a94ecff053279e0dbcb6c5746333181b2082a4f3d041c78e45a33b1faccca0a616845a7eb282c76f23b16eb8979ab254bf5bb3271f6f035024556e12d012d513fb58fd7c5c85fbe7a3a554af1b9876b9a01cf6cabf89b7ef547c824a5c43645c7fa48dccf51015df5d8a0045cf80d78276470596ce151d2a74a9a3dd0b41e63138c486427ac23857c04c531f12fba4679116db068825fdb05838f5f238f26414646c352c197cd1ad510fab9900dce3de74dfecc0f5424067264d2e57137bdb86a7478c864586ce63fcf6369c8362d1995b570adaef3830325b65a7446532f8227f536be89552d533d989d1c46b3890d92f62bd1999c71cc4373b0014d54f81e330d96b25296624ae2e7d3f1e58310c27f1559c5526d220b3fe78f2bdeb24309174cbea2725e8beec5e28e614dd772a113377d0683e36931066a71866f3742edfc285e48bfdce17a1620ec03a943d66454420b24c9bf888e26b297736e3ae677b477a726e8aa399affef85b2c1c56dce095631e6ace0791339e4845ca6fa8f6cd91fde3e30b35dc98e2d3d684bb9412e62f4dd57f88f112199cfac129215abf2c396e77269b422fe3149732d1a9c4a4337f6578376d5b568850e651df1ca451ca28b42a28f07ba82bd42307ab5e71ae9e9b83bcf9d5f8a21fee623bcdf4b7f8d7b1735327891c8ef1377925903502b89a19a37b70e0055376f21c890bad8160b4568b5ae64078b09a4d3d363f499d8b3b41796f12ca30ec7681eca4e12c0c6eca942f3afe2e50ac2e046ee6322a3e6b0870ab5ea1cf5130ba102bf35f89d187048ca29a8a10abf32dcd72726ee3458165fd4f8301dcd1fc6e7fccc405846ff8a2acb6c27efd9ab27d005f1407c470bdaf8917b1fba05b0b1051331bee1c7636d0650160048e97140693179b3f3357e6b1ddf16954c6a9c3c6ecb006aa2ed1787dbb6e192acd2bcd386670757c8c2cdec57fff14e0d1df96fc415e9eec91d38695f97f463085533801a208f6dafe9f8bccce7a06059d64be6a92e6c4454350730820a357fffaeb78f11d217b9519a4bfad483537b2e7caab16d7f95eb4f0ebcd72acc8ea00683b75880f51fa9080b382794bacbbca92679a86e0ec39e1174ba8f3aca08a3abfa3fe79b09f4db803bcc19e05419683c2b17a9f7dc872fb7a192fad05f4456fb27e74d59ab662f8061c0ba93fd68fd83f2ad345159c55e4068ad8f3f66f87aeee575d3ab9ad2e05b3e76e7cefd36475d2f704f9b528c25dd3f05eeb9f957e8f4b43d9a275111f683cb44fbf53fe8549ee7ca6353f013f80ded4de914ae95fd854d65fa8a6915581b0ba689eef60936c33e0210f9c44fdf5d38b9e1ad7aea9ab184750b1a530ce48db02631557aeeece4a6d53cc82d91378ddd6646effef42135d14766452f7945bb04021a9e52c66a2c05af4da3895f6821073ad5a7348fb613f1f79e7dc75f9424ae6ecbac768b826d166e736d7f95951929883f4e59766bd55141b7338e704f1cde80df6f96e50db773fa10e90b4d44dd78d4d96733fb5d6fe2f7284b9782f37e717aeb345a13d927bf310ceb27fc9f9d6a281dacde7fe6513288763d130a56b378cb49b82448a5c70cdb6b6a49d4e5e5f355eb5e98a2c44a43f2cfc97b048191590d30de6cf9ddf20db440febe7744761f24a27f7fd3f1796ddf0cae8050ed1541a2a23fdfa5df33090ac3e35bc137fc305cfb941e70acfda8efef876229022b999b7d77021ea2cc60ecef6be9d29b1a24fa83ecf0d181cc33f196235ba78577d33b4279f748a639c7aa678977f6bd676e8afb357bbc9f57c79000e58948b729081dda7112cf1abb0efccae2e4204951fce6e9d34cc4d3d262c689d38e3f7679a4a5c837d3e57bd08db9a9e0f6786cf0174ee667071634a47a51516816a334aacb4547c68576aaca684177ecd6213b7a3cd3d22bd4a086f36a4f715cb7e84cb6db4127f372deb810e23fceac9a43baa90ebc72ee4eef914b364a2450b92bfa39a2a2a410f0d7569b1af6bb6548521b466cc37fb9c951e9c8932c8d326ac7d67e0cca217427cd78b6808c29f0bc5a86e5b9b0baa019c6c08fa7dda4c00f417f4df9f70dd3e7ee0659610ac7425e3574768843eeb3eebdcd8f6f0073bfef134e2302ab68a953c70648ecd8dc1414b5cb39a5e5111577dac45246d0388cc28b8eb311f02378209434d3a102e05ee7a9610ab211505450b345b1477d2e85a2bec601edb9411512cc0a964fa75c4c1d6cac75331bba0a925afc764729f9b6ee7fee1b6f97d9210ea68973b3ed4455ebc3e461d663523bf62c2481e6df81b24a76f0c32deb1a96296a564a9a48a63a7e314fc095ba3ce1eca7d3e67dc4427868234b010f0c5d4e75834a2ec8428c8d782dfe77082289228171e9e07f493b3c668eba50614d4553a894f303b37589f16148a2bbb8be9c0087828c39918289316c901982f103bc3223a1a2ebedab885aa464c51e1bc13d6aa27f4421e433abf7ac075559d16f1ca4cc465bcdc6acd5740a6d7cd4dbc273a487010f09e942f5b73fcdd78de94e64ebcf8d35f0a468ff0af190a71dcbd3df22d0bc82ef36b88ffcb00470b734d5f651a52e829ce049f600f944d3dabaf56657ee3a3ef581106634cd48b0aefffe8c9c6d550852a73683e625c1c514167cf8a24141bc1d43be60c9c10ba2e6da984d0944e7ac498ddf711453e045648abeab58e2923ae74434ac62af93fbd52f392d3406df891d7ebe99f09254dedee942062bcf5b80c2eb0c028423a8b87f324e243e2c8976d047ab3a7b48d8efcd14d79788853d095a054c67e6e99b3baf18b87db0cd976107ccbf28f067b9371e1c0a13a8ef4006097c0bf010936bb983b70537f4a52374a770026f134c8780f06e53eccb64b8beb04aec07a503802bf702f848221175d37cf9a7426bab66626794e71aa0dbb472528aed4ad66b72c072d088c84c7fc17ed75e98d4143494740f1aa63558ec0534e6f1fc9f01a77e6fc51282389567eab73b8a20f58a0789c529c358f4b7b1ddb6af6a89747ccab126310044a8c9397d4e7b62eaeaa360e7bf7d9b18a56879628cdd86ab5b3f87a97bc37cbc3fa6a8854fbdd26e7f6530a8e52f2d4fc3cab9620e1b07e7b7930cc1a6dae99c190f2b9ff11ea3f10a77dfbddff524d05f7627379838268058a718bb97f2899d0d2940d153fe4844f97a526224fd0afcb0ef6dac3c9911718236ae4d969aac66f447a2a67c591f6caa22e8da56d403ed5ba8cb1e96ab5525cfa52893afbee8d12d48ea15bf0c17a4b1c83cf23cbfa4e3d595331acfce87becde06bc1298ab389f61bc984f8ab6e552bc86b7010d988d5e994be32ac5427f35ffe41e81479fc1ebc4efb2384792c542427373cfa03acf048d049cc9b65e29ed70f46ca5d80d11da266a30c06c1c26434c47a0a6fd1805766f1b166a5aa8106fedae8960ea9126373692f35c72d0774becfa277e21f9fd2284034c9b88b27e7fb97f778f3ce09405fa24474aa4fe1898fd6d456015a6a6311e2043749bf31732dcbbab0a6290a0c148f395786914bfbb68762fdc9a77ed8f6578e1777b3f4c1610a85e254ee6e91cd078a6b69e6605e8b16a5c000fa6f6840f6042b07ecbe8f13904daab4790c08c07f709dd1217e92b5931bd5e3cbaf4b315a29d8af87114c1e040e37df82def96265405f330398bf8cf429a36a8dc8effcf6067a180359678ccec784347638b6bbc53a7288cd2b3baa942aa1f3875c8188a37f11ca139cfda3f97dfb2bd04c7e47aa365a7dbc303a54c4fb71da19cf5118f6a984195e3bc4722cc0eb00d58091e9341d5479cb3ed13cea0946d8b6986fcfa74d1aab79bee98decebcb563c2fbb0b518235dcdccbc577371018da349bd1cec47bb4a87462e650a77dbb6925e4eaa8e99e4d5a1e33f58cf532104f1d7b1a85940291a0c5cbbb0749f735082f637e2ce9cc1b0cfbca8807eceabe90ffdc4fad3b3c826dca7da4606a9dcb4ad3da9ef9021ecacd828d805237b3f49ab4afdcb42b0d4308dee267d083ae82b01f63e0b4b9fd2ee07a665e25a9821e0847c64bb640c3c352f5f1b4817003aec469f9ea9c8d966847d1fbfdc45bcb3fd6e37d26937213a2196581c78ff54ceef942f8d60e65a3be2ced64a7c8631c41dd09930bd53474de974f2a4581f0199803dacdc4ae1d2d0fb120bce640723a55a35e32965db29914ca5a94a8807c8ce51d696db6fd98f57cfc6a73c8bc1e51b2434ad84fd0571bb8c016eafda287d70c5436c163f2a2cafd88477563e513a09f89566ddbe3ce1a266707c15d3350059644600a2b9a64ffa6dc9b4542dc954441b504de0f4bf8ac4eecb7401018e143e773a23262308d33cd589a2e4fda0adb1f32ecc1f2ead172498026910e3793437cab92c1f5a5d9d2989a4c3ae9f22f09b4062af5c3b55f79ed2b9b3d194e88253126b1ed174ac788da808e97262f517878e53db57eeb189290c1d0ca539a62c7956a2612ff6df333d2d307617a039aa74ad061cfe2fc462d91afd964eacec8c1b87dfb685780ea11a35cdace3210d6efa96c804fdeb4156389e5badf3d933de4b23f4082602a3ca1355e89cc0213582f8d9909ad2a596784317fa3bb5fce2a3e98f0c7d922a37267c705ead6d19000edb88e21c2c02d6bbbea577f7a9e2fec6431ce710a5bfd0e2781e1f2688adee83efe58c2dcbc3658e59a36ed7ab5cd6727b4f2f9a0b3b6487649a831819db2cbd6f2a46cd6a5fd2f2bc8e42e21b5fd7d71a585b4abcd60e29e4c868961a2253248dbb11c42fcc679fdc7dac6afc19ca86144b09a36ffb31b1f79db766d64a0e53f39308e50655a817657986bae2af8779e8c5c1b745a72c6bdffe812f34c6b0b49645b211234518294cce17171c3ba4e715fbe2d1fd700327566209b8b11dac2380b9f06ef226bf987b4d4b3ba78a845778fb246396889f3741c23865758eecdec8607e0196c2f6c18abd32ccc4093a0e5bbb2055cb2d59589e7bc3e3c5ba5a870558100cf5885191ff605a550061be44b386ec8c3003a9869bf9ddc99d0c2d90ffde32c6f571b8baa72473849d1ab804a5185ee04164cadabbb25db737170bd1c680e135a5677e13e22b41831c4a5ecedb525b820ac95d0b615cc9f03d8243e7dd39493af2edcf330bf15299b8df8adaa4364745e520b5f71cc1cca252fc8ceaaef58a633c85c6420b906278af95c720e2b5cd9336bae27a4381de458df75649b1f12ddfc63a21cf3dc5e245f47fc9c7d0a9b6b86568fde8d6b18e2337c8731d52588f921d10e85053900673e911c28d9b796d103c0d3d57e444249c7050dccae4a87da4f193f28507877e7482541413970c20061150a01852e1c6996a111e03bd78e7e590de2c90cc0536f415b42eb9fdc54e234b560fc2513657321ce701e87dc638bb5a475d819f7ec04f50e3767211464cdc58bef872b8833a9ae563c6afb136d6bc36262bedd22abc94c3e93d121183e2dc677dcae13b5c931734fcd5cf2c354e58f1f17da13de6f24607d950bc1637998e1acebb191e16d2949e031cc7cd0f49d8c12e1e41d21e77b609a03624c6a8fc2b9367ef069d218d6a5b1044aa20c6db52371dccb282a0e4edc1be242b47d58ff10209a708985f3fdf07733285741ebd1864d8f48112d4650a127654a9745ff363b0e4e0e29e93f3e06594a910634dd2d54dbc063e7b09deb558b5c9ff8623f953511d1618fe2db65d3c0bf17041c05fba62369761e46e1639471ec92536e23707c4895a93a58bd4a22692cbb1d022de1be79092cb221bb65d4d4e22b669256ecc5873ec3628916a60b1bb4c13d26595063c6e93e54b29b70505285b10fbaa78905b0539ae69b75afca50b1ca689df714495dfc1ef0e9d7672109b17503843facbb8628022ac01d482c0543d6492ba3cb92f281af70594ee3af0e6c505acac4d2e0e87ae8b3aab43f13fb0a7b191503b7b84b1e9d5c62ea61352270ff4860bb3357feb89af0fefa879253cc4becc0a88d8458921847e32cb103bfea56f47e3230810a137943c9ff7b901178ab7457a1461b81904e4c4f84b255f04b903efc2948785f83f4a697c30b542c31ce9fd5a6c2ea2a613da094ca1dc271a241367c1eb026893bd4e77caa30bba67616b0ab335d02b1a4cb6b29ba40db727e9b28c8c90151f804ac34e132f413cbcf64795a47dbab77f05921307d7a4299e1fe960de1d1c4d1293d53d870c4750b30dead28b5493db4c8ae29325ac3fdc507b98ff0e29b0bf602777cffc1037ba373247874b6683b8d98c91de417e6578a7935ed41c0f16e0de90e7fb6cc0c5c02899b0f430fd9ab659149eadb7ce48452d9913bbd73f8826ea9b87d542d99ce0e727c3e068edec4e72fc885cd5bef800603d113831f38db9ca3fc29a9a49f00de80c52f7bc919b8c1ee2377fa343ad5ca8cf11292711242bfa5748c3b3fca0dcd1ffd266434e2666f1df54cf7846a1028f6ee7586b11a2c2400efa8512ea12b91577e25b10cc5de94e8994661f22eb1bf50eb9f88187e3597ee77301b6c6ea3fc86b8ba134ae4122fc93321b7c076e8b61e641469f35f38ecbb314ce70a96e02389f9d7cba9f2d268775034826ff99ebc16a0202bee4b6246bf33aeace06bb80cd7a736a2b37f913ee95a9f95ac2c76a522af27e1bfc24aa78ccffc64a47af5660d730e39efbaf4363c1eddcd43d4f9028cdb1875899cd1ecb352b96360564b39e5e09d6d284c387f22793215de00c0ccda24045575ef9d1d7023d722321b57b9f7a628792c332a11f0bdd46291d9da50b0789713530026e092270161ebbed823709b8c63e84910e7ea334f8c8f47cc99a0eecbc0ff4d723bc61da1f0a1f6ced6c878e1bdf051f713db1a6509ef15901894725fd6024270cf340a253bad3cb1f43eebe729425ef13927814e2a899f15e2d998e5fea617a976c2c13b9988fcf6a8ce00eeae56b662a136fb99e313d04df87a92a399d647674b9152eca0d6cc15448b14b5d17e8939d3aabe6d8d5a12644d9213be3080cced5356910ef4ddcf5c4b2b4f49e19252d5220b4a3fac048c85e51e0ea40184696200d7112e4576ee94fe22dbec02b5d88576e6d608060f4f0eaf49addcb5c783b29bcc92938d3894f73341e9bee7b19eb7f9c205088f58f34e22db72fb80b98b5120a38fc6c5ea25914be1c081fcc5db161e32610b6671be0acf1b3ed235d331713b52d8157cf270ee789b04a8cd1dccf208c644360e442ab3fb440362ec0142e5ca58ad8c178b6cbf00e463d0a9a219b535bc888108205543089c17bfdea5d8a72ff02fbeb7bf6653e6da106be8e8a37762304136aef3b213e76351b3f7a3ae28b12c44b8b97eb26a419cd1ce92101a9c07a545a1cd9316e2ea51e79862e19bce7fe973209e066afeb03af0ee6e0d9e693b199d1dbf2ab5c155d5f75be82aad72ddd30137ea87b8e277cef5baa19a7f640be66cf8c51009bb0c05b76f4be3c7ef07b20c4f36db7270b30028316d3ddb383e7bcbfa2047e1d685d8e97971a0faecf0c2a7063a6113792bb20fcf7b7818216e035c5bb0f522f7418585441015b6fff90e9cddc29235a505f71a33e431c433553585d6dad29b9eed56e8690a991c9805b5f593a4cd242e4c2e18f35742855db1d8d92a4fdbb4f86ab9d9e5976102ea098b13f0cb03421700b1ad142f97bf1076fd977deeaabcb15d71129c5f84409df36c1ae5794a3c82547acfb3564c9978c79ac9b2d52ee24071a9c6d7997ad9cb200cdb7c6c3df9abb1cc11da2a2df22020e74504dca454c5963c2214135777ca3eac4e32aa8dee3e9ce27ddba3d36525d8afca06a677e06a1056d14c3a8f41d764f252800a66319413e6ff6c06ecf57392a14f0a7482bb5fcd478543249a16fc1590b2df6237ae0393d9b1e748a1c503f588bae188644e652e4f917af803265f517131aed11aa05f39f93146a1a7893fd83f776315019ef5784be299f90589747d1acf059befb09b5be17f47111f71e4f9244094a6496411b26cfbbb18196989f3838305718af1869547740103ffb9bb7c5f47d89460a3a9b46d2dcc806bd29abae5fe6ab60573397f31cc19ac7745f09032d3fa85be9773eb9b7d0c197ee21fa8c8710e7cc61c5c85387446a8df9db15de1d1459ec1cd64ab43f58cc175e24b40d7cda82a3ad128fe14377d24aadadc959a5909c84ffa6f5fe823da5f4570c380737d09b6dba182669ed7684fef3ac197c0b42de10b7adabc94179f74b7ff77321644f157aa45bd96015a94947e5079caf307cfc00a66f760a284a24509e1ce47f6fed6f686c931aa56c8b29b82a77ec4dd1caf0a5853ee0f2a0c1d898f54f126923e388639690f205d522c6a8618530edfcc0c505c2bdf4da21354b1d2a820fec6c58dc5a6cb2aa3c2f118399ed8f323a770aaec5f95dce4d5a6a3e61aa8dad09c740990b15344461ce6b59a01099840fb7622c16e85e6735d04881159050677382d9487d4dfc01da89514291bd69228b39e7fb0fea6c3390d30fdeb8a99de135e1bb1084003cf0442c8eae8aacf01a70a9208530e7242e4bb1303eff8a5e5fa58a8c9f9e53404e75e603accadeaa080e72a5c26f83c6005fb0e74111d4b7ad520633229cc202fff4c5d9b0bca9e65e9305ce3302ae77ab8acab2e32639f2682a4ac38e8e19ded94ab05e9362cb2da384ea4807e33dde0d132d8c08278db94eaba5f1be855f5d1617cd265b56f4663c264812dc61589e570d5b302f3be6230913b1c9f2a1a58ef57c5be1e7e966806179eb216e0edd526906b5db94b72dabbda2a6022c50cd5611fb9c4266f821e43e8c7bbd4de2bf1bd94c5a47eca0c04eed572007a03177b2da5d2b9394fbfabd8d95dc3ebdc41757a3c1aa9dc13729bbe2a2c9e25eb0c078db547ed306ce57ebdf966927c831f96007d355bfb63652d9df5f1b019305292bf17d417a808c4ad1a6bf9a9661ad5d617a9e7a998b7c3fa763cbd88e1cfeddc547e2916f56b0054a0ca795e64ee3b28e416b335db351afed91e41cf5ff09d844e9a13cb11a5a41e79eecd73447f76fe8e5324a54d31006fcbf92f2c65dca07c3af7038b7c06531571cf2d49cb7ed6b141be31fd65041f429d700d60526fec39d9164a59468dbb3cbd13835e59dbc30a76ba505b682a3d8293fe471732734bbeb6f2d3b0cf32c34865bfcad1249d9022ec3ee1a03c05a9b3c3fa9e78bd28d68b60465e893be7f8d835f924663c98a13954cee54738188e8bae46ebb351c03bbcc85599223b0a6ebd7b4564af8dcd30f6074b0570ae2c10a80f4708d6b7d5d7d1f7b82686d92e1cf5c5f2e877ac05d7f2558d01bf43f50bbe3eaeee9a445d878d312373e74c475032874cbe601c9bdc62ce95cac91ed39a0780aa747573087916036450e67e11449c9cc00cceaf76676fc4f0da7b5f5d3e3e5790eb86a506d743dbe2db0812c2cacd960648ba1067b7310ba01ed99ccd5e7e2233510aa006e3b0636dc62a85c29c26dff454f94958b07ea1c3b17c88240f0a7645f1f50f188ddf3b6f8be689bc71ae9145a5bad69abe64865748107a134f26239f6c6b9e5e9478e5c4fae273d507a2b06d93007dea15508e2edead0080ec7612399e54421381ad5434213d5dfa5500c1f0358cfb95f3fd3267ea202b479e5905740fd023d049fe56d4b23d19f878c902af8c7bfd0c870d9857a10ce8e9a59b0648f28aafba517780c71fd1c4fe8662889657ca0561c88a7137db639635f8af90300a7ed88a9bc73015cf6af27cf4e723fa784f90407d5cc0d010304bd602bb40bc9287df9fc49fa9eaa1da05a6459db253ac7bd47ccd39626182a1ac008d8b26f760fe09d56714e921f021582049823c50f5569ba244832c250c06983460bdbe5c9141b0145aadc542dff76ea50238bf8f471353aec41942d5e886956c9bc4499182ec16545eb42f3b2d833687b3b696f424937c4b59fe84bb966552af91a112d4b67a22285119ef63a11bf322026c4165062f8c1e2a0e71d098f3ab86762985c63f74e9cc7e71f9f065d0c10646550ceffdcf5c100257eeb62efe62c913c5bcacabab2ce34e4fda96386a3dfad65358bc4e47335a988f85e4345bda4027d40632c0d565185e181f3fd93a6b2a39ab0c56a03a5bb66653f323bcfb53d0dd4cdf76d75c075da4294e5fd3fb3cd7c55e9980bb604cc03cab2b60dfd90725682f575b8a01c1d621c697e382fc95c81d82a3cffc5e795acdc4e7750ce617a7e66a119a5b148c6cdd5d9f58d0c444f53811d22c5152e79b3fdc4f32eaf87ba93ece10b09f2126264427bbb4c12ab33c8257186c3d1e44a93f954c58548d225d1464128021c2184b4c39d2a48002d97673e525073112190cbbab2e08f24c6bc9ca13ad4af28e8197c65ab289fcdbaff79189f53fc593b2951ed4889599f08fc1fd0b87e0e36bc3a9cfd10da847a5c05715d3ee4d1c25fc5b8dd13f83dce018c34e91c1b0ba0465c8b50babbed72e80315eb58ce12dfbfeb717066ec338b2365e8f892fec3924696e1a77a1358d0aa580e1151d27cd8b6aeee57e374968af1eb21b3c1ad29f70d000b82227239c7b521993f5c21556cf07a62162f34d34d992371f3a2a3206c26733e74c383541118114ad1cdd38625d056f9516faca0cfa0e51165ac81ee07ffadac1b22138120d0b4b63f31db74b1458164498f594952e1fe6887255ca4972413641c2511bf4d93c097a629dcac0e9a402ff0b4bf924dc4c0d45b63d1bbade45a84d1a3be4d91c6eebe5918b7a5d002683ecbcf52fc8fbcf629a3b58e9655d044c756171b0bf1c4adc2694dfb3d11498c4b592cfedfb4c997f3884022a95f36327476bd8543cc3dea39311d9490cde39125af05f4817e01dcc594b4041ac89bd9584f4b3939bf71a639da09974bb6131601737e77bd8ab9e065bd66242220a5fa8800fef0bbf592bc25dddabdbb976a95e2b117cf97728cc969f096bd761543e2460223a57e7d0bdb7e310d3e41f79dca9a382d60317097dbaa4b246fb96279aa44c1a8c6c29efc29836ae6018df5b5e406bf596e68bab54e4b4dea229e122ece33d2f90e5e722d7eaa82f76438fe05b6ccdc473c75126505f4db3d52b5ff5dfef9960621bf76e2a1b289cec971dda47811f982cc7459754092c5c0553ddee3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
