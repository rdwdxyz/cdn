<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95c3a998b901b53eb4e3811137f5c2c4b1b0b601f0bb4a863c778fc4fa95e65a020b72e1c5ae76b5ae581e6bd976084c4ff2b775d4a97de7e017c4edd1de55f5db7a464c1f16ff823cefa7629ddbd0cfeb773575505dad768296be6b7b93b73aff59c8961ac87117c1d7fe6595aa201051bea5f68ea4b68af9ec759f5a5106699cc8cdfaf0839e609e1cbe08573a9761262f6bedd39b51e1ac512b863ecc1ea6af4d0ba89062a6441548138ffb4cc792b2baa06b2ba432d7a19b03375a9b0e322e1a7c1a7bcc9a3dac6024a47a677d14c6f042875e92ae0de81ed294d4d057e61ec7d0603c888bf9912fac33a0d530f8a007760826ea974a49d6a0cc6b52f7b2ce870bd1aa981af3f1d34780e4121d3e35e6fdbba5e0f87705130d4a75ea57ce91ca785dce1cf0e8fec609d07c8cb06a1d752f7637bb94d19fdfbbfd0ef8a192bc30d98c7bc3c0f6d6e26ffec6de960dbf911f37b46da0fbb33f04363e7e5cd074d6c6cb177de670966efa18bd0b4087ac0f3ea29bf5232c197c7c5bab46431f3e606a0269b4afe78d2dff2f5443a81e6c334c3b8607172fd898fa878f6048b3d601482bc57ebead5593c5db6daaf8126d3f7495a59ad6f02bede72da98b88763c60ca5e5dabd27a3bc096c38e5bffd676e21f296d076c5a78ea8e60886902b8c5e88bd6c0c0f58930a28bd7578ce78e2c523ee15ee684e016de938b5d12105b1d2ad4906f819aa5f5cd221a175aaac63b0d39070ce662da44d95b721a91df15677fdf7d098ff279516f05c213f53d7c7dd3e365ce14ba7e7e8b677c788b1cdb49aa97b2a2b259a1bf08d2f03b0165ac8a5e6773d4a427b6b2029c66c251993c3072ed825a1400e3de481be266ec58d46c963db9c51719b419090de1bf80e859032cd11c49995d53768942fb77db0b2a7279cd08038aacc12cc6d7f662adfb7892e1b2d5d0accf34a255869aabc958927e07627afe2eb8f58caac54518d9722874eafdfaec7866f5320755003c9608d8eb472ba6ae2ebce49d4c953056681bba1932b291ef183f1b87dd7fd1cf3888eca287b01d4036c0a18878172290f84eb0d4f1d30079ff86756b0a2add20590f1208527556c5e1b994209cdc82ee3fc3e8266e84412bcdca9f8d23d628ed7bd28d8136106520f4094b259121b96aaf0ceba4b78b7c413467934edb8262bc65af18c2613948728ab40669fd1243b6dd4cd9fa01786d66ee9c428c9a5f4305742335e7061bedc738257283b81b82d635039d267a1d1488fa394bf2e40ac48b3b48d95045b79fc06dc25688227defd65346e0b259fd17a3f5cd0f42cc3f7af60c0d42560612dc1acf26277cc4b1c009bbdcb7c917bfeafaec2c7a8950556a8fa6883c03e9d1da7a3979fed19d6fc67d98a24625c946a092c042175b89f41a53a862c3d75d68c84be7cdecda26bed2102803a00e57f57b738f235f0cb472d813befaffe865027ce16c6a0db2c9e631c821e6e91140d99b15804922b9c8e450a3fe4847a3087bff5bd2764c9ff58789f8c6ff4aea32e60e6d438d54bb8a63ef22aefc84ed69f174fa4a7199e2e699594abc2866c6b49e9b6f18c95476774701913488f246b629317fbf1fbb3ef856182a7776fc4397344f726ad248e2676edf0be8ff751abfff242f264bd27021bcfd8c2d1070d7fabeb97dab6fdfe232719d5cc697269611cef1caf31685ea3ebf48264ad536a1bcc806a6b60a298d5b4dbf6b1d59f1f65782ea47f982a5fb7a8a6840bd595b0a63722a004c5518e75eeaa879ded8d77289dc7d5104f24c35f989c298db1dad4cbbe0bb7f673ae62fa73c653d196190055e7be95dac56bbc54d401ad00d8bfcb80cad2581f977fb4b6e5307a5f04296b8da3b1b9d9c087249022485d605d5434e5c82339f3a367e21b74dbdf8461d9d6ed90ee698738a3443afc8664dcdf2f856486f2dc7f71f6abdb46a9f900c4699782fab240a260b27bc88818451dffb9ff37500857f85d706723c0f847e4cd0fbf767aae92b27eef599f0b6fb817ac0ab2f4ff856b4a45c699577c603e5f06633a1c64d34b27b95a1d24c62be4a2e241bdde2c8dca43586b6647ef8e5e620958ecd5d66c9b3eb6b7431e91682bd98e9754db5efd46685744792fa5d75019908ebc24d207f51da4a902f846d3c0fdcc11aacdaaf58bcdde5368f7fb74c94d4048ab44a535515a03427d8d7b854c7b0b0130f99c5f92b89cff59862faee8eea54d134070d63670acfef7b547ffa9796b2cea85e9d0e46740eae7d484bf24bc2f7f1ddbf55980d84bf291c6010e8d4c7e51942e65cab8b96458ab22066a2cfdc7b793c44094197a045767247ed59c902a1c7f9fdb104554317751b0f9499353b26560ab63f0db9610d6b3eb3f7ed98118faf3ad5dccb5f9d19e95515f7d9a5f15ca2353203d5cf19cc3bee0fccef3f616ad2b3c0b35b7984171a7be8471f0e4a5da30a824f16becc2e339268c4938e6951b6b49e7f004fd8799c23780e596e99cdfc6afcfad5d7fe76371746b00e5e4722242b13aeb0788637ef2f4801889eef690bcea2337facae1f7060d10fab175aa4a3391a72c61adceaa528bcef263bf061d3300bcbece7a5bd4f26617fee9b547a6945aa370acae8ca213a84d4d1966c3f3d36c2267a8c9c282f6f07c00a067118ace46382557e35612e1a13f537ff838cc3d5b0d6b973e640e91dc09a2121d889169d4a3ff2e40c2961ed3b7d961626c85aef009ea29f8d84bac287a3fb47ecc194d68d0f72b2e94441f74864bade79bc6c6b9d2a56badaad0b5950239d68295a3175cd23a19f20b4cd9b5f7565f625ee67b1449516faa7fcfb966f6d7430f0bb60b2b4d82c77782ff152dc93f7fbe90322cd4602d64c08fe6b56f3e61f659149f1525a9c800d7b2e66060703f230236d721ca1f3b7fd88444a0e44ea1ac3da19f130cc30513a1698fcc355d40396b216873a37e91c41ab27324313f433e9b43b46a6c540e08712250e01f6177a2d3974337b758ea2e831b10603c49375434ba5705a2624de9472906b0b30a3712d9fdde328671e9e3158db83744a606abccf59531677cf06ed433ef70f9e7bed8c6590580a683ae311cd2d51de8ded69b2f594914fcfcb0da541a0571452139606c7b4ab64d884f553f12e82d2003ce983d49ca0c1c9840e973eceb0fca782eab7e9e8897530508b57cf2b19d01f06b936dd7e51c59568f5739d8c334180bd8be73b1fab2071a1190a1d10d7fa5bddbf88059b517ecabe0f36ae924b272b59502f3d1be982507c21dde617c1574f4c2f810da9d7fe556b46ea4d62a4d9334d964aca953cd3ef010e76cec00b0157acc4bd8305095c8ad217be2d4e98e51cd4ecc8c757936e34dc6f41d80152845a659b1e53b93630331cbac9f7a7a4e35a61f11b1c781b67637108e2f87562a93a7fe7f87e7af121518b484962641cc78e987675bf385b7321bd75c0e98d92025361f74c2ee3b462caaeb6ade16f7c5f88d325a0f63a90d48d2d1b69506bcce09fe8f358908b3945ac329b0371389bc8a378ab9af06988bc6281553c70b5659f0723442a36ecd4b83f3ecc62f14bfc7b623e7bd427cb81cb884d4364c72b2d66deaaf168337e3bb7990cfaf41eb477b0626d8050a865fb84e19a923547509509093ab6ff7afea4ff14219782d1f9c98d4788490474af4137147b9756c8469ee1d18055b3f9322f610691336ad31f79819e72f6134ecbd40423f61ec5f8b20412ad55004c7cc3541221176216fbb93b24f5b825d2621856e48b0a819f89a1f3638f1607c6ac922cfb4b5b8d28611248a8c0b99f25441f34523d8ae18aff0dfbbf2abd402facc72f313af9e92e08cc6ab811493b96f220ea76701c6339a798597604f51730d6e3b910030dccbc8172dae1ad1245f5336bfc3f49f5b386f63d7eb19049405f802f700452ae0d12ccd5e35881ae75d1bd5ae885034cd44e23f1b0ce0d3b30269df38f3b4759635a16b8a8e4947f77f7b15df5f935f5a00c2bc261a51b9ebc92cbf5e809aed51e76f66f6e00fdb34f82957b493bb00cfca1ae89220584b0ce98c599a6331ce33f00d7cda3886f651343d32a90713684a1224668538ebd007d106b5e4aad89d38325a9d0d325f8cf12e57ec7f8aa96389fca7716d55515fca263e51ee20b3344eeb029f255070e24e366d5fb271f5a593c1cda1182d1febc7ef5fce31b3aa275530aaaf6f20ba1254449d3bf509ef361e2505298bd054ac15bfe9360ea7d36e3c80b69860738de4f9137be335223069cb7ddc62514030eeaabdd5f6b4a4d880ce79d8b0395508dd78424f3674d7bb46d1f50a05226fb1e281d0e92eaf877f2f3ed1b5474d056ce9c7714055abce1e21eb212c5fbf9956ede2b99bb783d2e7bd1b32db447cf9a7d3682ef29a4d292ce9e1f65b91bd49e0b6ef0aee1a960f98a50efea2c82a5d13f7c433eed9390c6dbab671e822d15e1ec3e4234bab285b4a62eec05f7555fa57ff6df2d709c8eb421f8092cd5b46a98c298b2bd59b99ebdb01a86b20b5aefeee9cde83d90faf32062308ecb5e7a47ec1bef30f52f781522753fa58e25ef84a52130f432b7a871e132bd39b535f57c5b42521383e2c242ddca5eee3af9dd628055eb24922c0465eee4b8d2296b6ae7ad5eb920ca20b185650aada34ebd6b9f33daefddfcbbbdb4680890e5240294f79305e2cfa02cd8731d06e25f21880ae43880203d69472b2049358f6e479dee3b2c6b43973229b473439ea5a8d62b925bf3c53923c3c256797f986afd64e30173d303f012e9d957d116410bdc54bac72df17d6d3cba07f42e31912eeca5783f955acf05a5c08ff3ad8031399b3baeeb7a37ccd4b1ab4195a6379cb3d529f284eec16a535c780f7fd18e4a054dc2d6e2f053944fc39a7315ea76b2c74c5d92275b402611754d38a073c2357693a763282ac1713ef102014899f0ca7bb76b0b35d88ea1389ee666a9748cf0b8447fa5eec8ada6e95e00176e0ebfb96709067fc86e73d5b55d5f5eb3d3c96cffe5e9f165356608c3219f009205a1247575e8b19f0b6a06a15b0c78b5f8f0ade90948da174eb58c290b294477d01763383ebab226552741a5383eef6f0e820e9ee56a5e5b42ede5a2d77cb9a0810e66e58beb3de441a3ce6eecf23a1465f6c7a5166802d645b948797f4d73328e9cdc06936b532ab989f0a20620916433332223dc210f21a4d9fe3cd06b05f3ebeec64275e403ececd8f6d495aaabcac4eace8e23cc190d99be64e72e2dae52a63efaaa0593d1b4bb22c7a8b5681fdcbdc03782af0ba2bf426f880d161b63ce4f0ac87fe0529808cdc7aa2a24be4c3bebd614a32d6c8fc6ad82ed014060ca582664f3e1cfd237a6bd77c8cca52dd4a7702747d4f5739df81ed313de5726379d6e6c7d5c7ff573855c102ec3a01c93603de027c1a273dd29f691019349d14db0bbe179af6c469dad07a30f1d1a4a2efb9aa10102ecca0e28d8ead795bedf6647b174d39acdfe80f3a7256b31a6023ff172b973c85e98f5289e695db12ea4e48bb4f159071a787c9c696d5b69e306b1a0e5482b172d0e2e28e2f9121a2411c247cd623d667b1639f67e245fd327f34325ed710db444583111076ac758979afbcaadd0544cc3b4e78cc5fc0239636721847734fedf2262445b44a236d08f71f3380384e6dddb8aa07222e0072bfc8695f68fc2fc47f27c3922ede5acd34de3cbeb95d695df8afd6bc4e5c241327cfc3372a31d4cc602c03161798b4044a7c5f649f92deacb5181428977ec29ab2176a669299990baa87502fe602143c339d667db34a794580a60cd99b25223f39fcebc6c4a66c0667d466f2ca02e67d0c3163897b6fe459f2a1462e2072fa1d77bc2089d641eac014860a7b79d121117c86bafc452b64a00ddda9d81393dcdf8b4f65c3731fe0182f91ebb21a28af138ca850cb309f7855664f41c3937d8f3e62f9099d1ff8ae58b2bf7d15752eb647381f2905b5d8739b24710c3a8588014fea4e3af6c264d2a69ee5be753072e39225b0835f1c993c5f36c91f06972b4abec64a7741d9cfe513682ce0c5a454fa29234c1e332f2af68b94cc24bc2fa203d8b2dcf9cf4d9a8c657f5a1653942aa0467154df8791e43b47963c2b9f4e9b02871c65ed2a8cf20fa6e6a708d443edc2e5321822b5e745c3489bc8aa1444b929cd3bf43a088dedfe7e86f2f20923906d7d893f08c0a8eebf75b85b98c11c145c0ec681452dccd91077b0b34ee01d89b89166cb8efff3e7cfe2adbb55c39e205f15f23a61c5a7fe198e06838c19d6ae8104f36347a5e58c43be162e4a9eaa51a0417641767a966577ef14f557741347c49f81df6fc1cd1a13a3ec3a5ee8575f644a9aa2c534f7833bc8535963e7c27f8ef4613f6cdc3803481b360c410917500b82a8595edc29b706e328878bc3c2ad95c9c7e6fb921425050ad5d9d5387c691720ad59b8111f80d5dd94e8f93fd3500c46055a919c3159656646de150c21762101f9f67df096f5dd0ddaa4ee9816eacf3609f381147ef8841b37350f4cf839da89049817e038c221148d73c2f672d78f232b540896bcd2ff5820866a8719d3c8040932352befb33272615f66c92f7e04ad2c8aa9b8a46fe1fcc359c4415759dace2151edb946f52d9fe910a494b1783f3587b7cc7560c7b7fec4b2642ab5ffbb86303ec8834934355e4daab44f18c2cf74f066bd8c1d96654eae12c8c72c25053c6b2440e491d0e761664f047508aaef0d6aee73ad2260a47f41fc549afa55a630c0848415b2bf12971b22e8cd134ae908f4ae6856b53aa4cc1473d9d9dd27e085b293ac1439406b9ec8134e166851fee2f2387c813f6259d7cc0e2ae64810a12e88ed8c5937b24c1582ab4ae51f1ccf96af5e084e5325abb67654ab68aebf005e4963ed8c73d8893e82af1e38ff08e3ab6ea79aab82dab89ffe18477d4258851e367a5895905320d376576f0f4ecdc5264050f2c2ff2a3794149798b3352efdaf15180a245c5ca6055143c9ba37d2331717254db84cdb04dc4cf83a4adba13b1722d8b49b0f269233375922e42313113a0380e9f8cca84317f8c9c8762b4908432fd9d69f7d07c6f145e1e1b03df011c13f355c0119e99417689da1196615623974df598837dba06428462476778cd57f76125c21ec7ec23f00c4a98601a4f2b5efa0dfd88ea2974bc50783927d4009a00f1e5590cd9e2ee095cd2b0bc2145c771eff51c2f94fad5cd91275b1990a08e5ce735f4ac4878b7c446a4e7496d469e256f05cb6c50e759919cd56ff2aae3f758a90397f81535ab728f887582e9f588ef844d6541af9f8f1fe9327bdbb160f618300c74f26cbcd0aecfce735c80de7f79633e01f670d10e2dc691c2469782da84f9fe55bfe0ff1776cc36be3b0bd706ec69f3030119874e329ccb849c554f66bad3a98264de9da84a2904bb37bee5077003a765170a73fd3a7c37b8bbd5af9ade018bc2a1331618c3ecdf3d4dfddee9a1be4c9e6a1df64a07922a254246e428566265ddf06a6d0295e6ee635123dfe7bf4ae06a05f290c42c81ab10022b53a9f37d9828bf17eda093ec766861ed938c15ad5cac400e6155f1299f9547ab2a4785f0cbfc37518f38c33953e1c8739a3164c53d0b3927f7be08152c3cabe1edf02d1b0691f2304c76fda74f33323141c04c4d58927d082d96766f1722b47026f7857e6e8c62f71caa63459319ea4eb53fcd6c10251c0c2e2a02df3ab4fd584e4a6d2525dedd23ac3f40366e96f3d1ace22b01bba68cf07914e47ce74f6d43ae06a624f64abf2e8ca61800439848fd0060a649d5eafeb77c6da13762d6062f97652d63918b153f8cb0d00623a3954248d05b2e83810c85b586af2b03c406f9f4b01c9ac6062080a8bb3f89b2b6924305129f825ecf8c6b72ab924a12f7e325b9da1fb4dafb5958d8a1e6b3c853fd63dbd67fab8f110b03e719ea8e682a8abd4cfc757b42b870cf061f82fba48f76ef778064a4198f44a69aa0770efd2331c3190fabaaed8416efa814c2dff826dc626c7a34060817bc641d4abd6614b05bef63d003ce0dadacb58a260ac6050211dd08d925d539ddd1dff6bab950663e763bc0232e4075407f567f2475a71001b18be82bd97d196a111cda3e0cd36b7f121a8a326a14a77574475b38ce7a2efd380c518be7a7413da09ce8919adb8b8dd6d3f23a3eb9f230ceb4f44ee98acefd2e1b5255649db3dab963784a9ac93f36044a3751ade26887cacb7f67715332802f028de8bf075e4f2e2d7b830c205b4da077d9dc8d248970fc5ed209c341a40162af817c261a2c333902add6585a0478a1ec687ec424c1de6dc4d1933cda831840ec157a820a8d3f840948d6c327f46e631d87c23e4ab68418e5b7fb27c8b4c7069458e4e586279f7978dd9d72f88eff1208b2fd903ddc42c867d0efa51068e134a09d960c5a7cd0e7fa70197111f4e9f93248ee3689fb6729a6305d8d087b0bb63ccf9cafba96286e4a7bc9cbb27f0b8a2870326057d0cb9cfc9f0031ff2dd38eae51133f774815e5e00111e2223ab3cb12e3f65a078b8e1bb515add1da01711f829925bfa0dc320528ee33c0603593acafaee5e9dcabc210d0fd7a9a56e5b8d18d7b1cdb5a0f451e1569ca2a7dd7dd0f5daf2d9c8468bec665113e96d7c09edafb8c3cc853a6672151639a6f2fe72c6d96acc7e6299cdf96632e500f55ed91565aa26ad91e77d7246620a9dd016593727229b8525389936c02b9ad3de17963abbd74263cda8700c993d801b859f522ce703160084fb95d22555a71c7dae1b3a8f1dbfec0e2219e347f4317bfcb4bbede30e1e635d3ef2fbfb68cc35068cd2776e97b6cc960f96ba5f57951e3522e8fb20ad5241e1781d1ab3b8440891b65f847608b5c97baa21ec4da7c6f99a3ecf87796366eb149fbcf5a2e4174a288284ef646f5f818270019aa342df2229d3780985609e33368e306b72780cb3dd5a574a13b25e2570b6dfaea4a4f2a406a3863bb318863ad628c6a27bf34678cfadd2961a2fdba26b180c9d9d0944ca014c7b746c914ba4f5b4c1e2434f34146d3ba32304af89c88930312810597a39085c512750171b647cc5920e67cb5c7301acb220d5a9db9ee5901f3eea14fbdf8fceace28daca62990bbce25a2149d4ddf9b8645592c033c5a065a31fd87bb3737b1172ae5b5aa794158e24d0fcf11cbab070807ac10e62dbd9a3905230f5be753d3e859e90f5b55e55c8953f043194dcbbb84bc8618137cabaedcdd9d35c9b87b53a4330eaf3d006865b85c3d7cc74d5893e61c59fa30818e74f4574cc509cd8e35ecba77472ba004150e8aa5c465c9ebc288250a1a2b4c19456886a465a5959f4925310691f6244ab2da2c7c866d84c83791f4c0a2420a7745b07f414536e17acd64ae1f76fb5433fb195adb731e8b2f7015b180ee0074d3d6aef6cc57a82ea183ef9e6393a4d95c2754e931d6c22d6a84dce5c21b7a6300d936ad975ac89b3745b263f7d3cf536d736d1ec38e18ebe6963165a08b95c8becd43b3234bf487685b51dc892e08b7792e1993930921f90691f15371ae52f4571488617fdc25e0545dee925269ec4b00ecaa47f2f9dc924379b1a394c101c5bf0a530814b45c986ff07056b371f44312760ead4c97d271ff2bbaba6bd669e514af613354fa092c008e5203f38fe222408c24f89c0a4cbc207114a9f1ddeeef2aed929544c786de3851d8670bd654823e07337a19ffcc3a7e029c38ace44123fcfe593e3d9116473e7c278e7a29fd9d4ae470627596cdd7fc1d9f731eaa8fd732d37bd272dbd4048ea8c115e0cce7eb919d356b31adfcf20d2b8287d2fcded92b313fe8d0fccb370df5146b08ee9c77faa8e39c88976cc9f33485e3a306c31eaa9e9d2d8b62f3b8b436ac0037af8df5065676668ecd290794a6f307c77135c65d84a770cf0b673449d17ae9787109453460bb89480d2378ce9d60436b7e32f966808be13bdfbcaa7bbeb19bcff283dcb827953346b29da66c7f704e5189b5fa8765293cb3f2b46d670a172352229056062cc45935275c4c1aaa69691927ed3c01b6c4a2dbb289fdb1894e9b56ade3c6c0c7120e61667cf27fe37e0d52b9d34919983155cc0a1465a279ecb613572b1f8a7b392ed480efd5a3b222b71afcf886dda9f95be42462fc1c8191091f1f525590385a02f388f96c7e1dffaab1c981e94425b3486fd18a2aa6ee0494bedfe9d37055e1971e2f8995348abffaac1c1f84056e98b7f6850c826927292beff413b1f88b0317958d766cdcc746dfe53064140c987abbb2509579e854c54cf28221020147018109a0147b5acc92afbe9a799df66f63ffac26c5c6305eda5000e844d12d7827642ccb8fc7ee25d65161781574a00d7e38e8b0e035d202a56f9466b69f88a6d1f52b9604c997c472b4c4c72b5ecb12df4d7348a0d510c9efbb64a8ce14e43301355ccc387453116595e84f5b4e585f7fd45f8bb1cbdf5b5e3b112d7dd9436ff8d7bbcfac88018829ed55980ab317629a95a8d6c225c7c991b9fe6e47846179a7030c902ddb88021f1670bfac2424488123bdd83c9bc5fea3f641612e6178fa435ce4d24c3d45f880935643a5be2538210107aa1512ea4adb45ad8ca091510235f55c43ca1225e25f0bb54c32da9875a3352374392ff60c0e2fefc6404a0db3ef1ce6564ba1abf59864f54fc57c73a3b5a357b7c34d14765d5469028796f80952ce7e0b1fd2b4b98b3cb6a86fd124421a7e3829aa7bdf9fca31b5d63d7e4f54c065a41add0ccc1cccbfaef528687dc7a2c0d4bd98ead51a24045153f7f8938e2db672a63998ab6f3cee7d247e88caefb3f7f9e14e121ebe9dd3747b6e05bfbe67c532937dda815aa7f9b2419806d485bb68fc33d059b43b313f37775b8a8deec2e1ce72ca49a0083b8482384430381f1ab7a4aaebd8146a8cecf3ac75d48423afaea83066776264d48ebfd323cb7e2ff07f97feee8e3c7e584c7aa2a24d614102005f06d2745f1005f01a0ac6a399f7f0f40dd2e16f1a8c0f1b68b85202423fc21ba1435ef9c7291167ae908d1324c3cc5b3cb56082254b5803c811a62f32d08a993077e0130f047975c04a614233a53380363ce86eb7ab95ba8d614d28267dbe1f6a26118f613688b478d937702dcce6ee589fffba9b074cf9294840da419bbae5a701ccd4c8f70069411238b59cbba499117d64dbfa3bcb61f00ef4628d4f76e5d5930a992a702bc1ce8c0ba64bac62dd04bf9954144e86247a51fb7a423bd757ef2c474a42d7f98f04d61682d328d44d32c48e14d8a39ea090fa7a76320785ffe0dc89e73db92b025271cdebc1758d373edf7e92157d72fc3c5c7223f1eb95012a24072866594f4158b5f1f408ebdf7edccffaa27f62f89e1dfe2ded210a25a7fae47a1db7788e778dacfbc8f182fb237932149ad3e06feb75033dad40681f23fec7f7a5f93f23134bd1ffc6f2272606def320614fc1fe1cd616bfd35e31aa209d0faca73fcf6beec2b16cb7f827868d4212f8a4031f298a9a886ee8f448462746f1a4565fbd25702bde07cfaa9356f0d7ce9de19572aa15902eec24c8660f3858d70b98d7223d632a0d1c369804fdf27aad3ae9164ed396326ff8389c4cc6907fcf007c3d1f671f37b5357d3d55e16bfcd1aa6f873f69c66e2d6a502af1db21e8b4ea9bae4b0e06409f550b45c86dbe9d95d774187281b4c754f525547ec8179c1315b9e4a933d2596b82fdf25cc79357013f0c70e34425a05d621b4d7898dae7dde884c7220700ac726fe904c7a8dbbfafd0fdaeeddc50c50af1adfc46ae77c30c9019d12ecc363058af353a54c5a5af546a0ff530d0de3e32b5b77801812b82de0d0d4747d3ad78f4268b574dcf8a9088be8854cc653b28f2973e9433a8f8dd5b1d33a31d0c12a8b3708064a8932c604f85180690a83e22010cf30e886b04b706a123b2ba6b4fbac3a131b16363481b2acc5db65adb64c0d8df7adf057eb7607f436e1ea4b2b1e9f93c05d070d1929c2a3674eeea0095dda3cf8b052646de24d165f9c29cdd972e2d8dcc7aeab985795d83d01e360b9ba2a240c29a576d1cd69ab4dec57c9e7e98b190c54ce056cccf7674b36afb8332bae1b6a6923862d991214fde2d9a6c1806c29ab757c85fbaa6e96e290b879144bf812bd5fb038df5ecf4d11426424ebfa5817eac2de904c24909b1059fa6cad380ca8223cdcfd4bfe26c81e54f87e6f3641d5e8d61e7759fbeb1f1e6b777a87fbb01cdf612da59313a81b349a97a9f6c3a32fab7364ee94567d4f47f9256ed6533a65bf5f1789317e063cfe4e1ec5bc1b6ac7cc58e58686c7960038ed8973d284249f082ef65072a6df08d6367d527818a9d936e5db062cca5ad42b339bfa6403688c1a34aa69674fe9f68fd2ac7980e1fb8220da5fc4e29e314fec6cc5546c9c9a4f5890168e809e47ac5a5edf29515d24ced4a6f547ca26609881644b503b9e36125091921d466d6da9bc8084f598c7b412c2417d99cc5f3db5bc89159327b2205a66ee3bdefa2634c605e58bbb86caedb44914809152b65d1ac67d839aee1b49f52de6b4eb6b645a1725a20af2b206d8f5fd9cabe73d8b08b739ae61cee7737e07303d20d6ad286b45d2c475526dc53dcc87a375f719c4105ef92307ab6504761a6770789200f4310371b296828c44e6f9a2316c0234f5f51963688415dc926203604d2720de982a2d51b4817c28cf9139aec5afb821e94b34d75a79f5e681e0cbdae26c4ffffdeac6f1bf69fd43c231dfe3f044d3491f94de5be4cc4fad695c46e2bb2e37656a9d835a661cbcf34d7af28a9457aec410753df22baa48d1f8c1b21dd542eacb2c24a7f375917813e228e5c712e2a1c38ef145f1d2db238a91f67852c7dcb678dfa01a59482713602d6ae067cb925fabf88aee6071ab7d88a73908a8fa684a8919d7076f5c2774750a4a83d609f4bffa1ded5394128d1f0d1ceb6b39cb9b39a58befcea07fdf95f1235d40aae3490de41bfdb15c476413e4accf7524a2ad4b8a656ec18a88383d4ea590e49d11e549e58e0c51e8a7f7472e1c6af47f7550c290097c62420f518155e9f874114e09f4f898b38b183fe16fe333184a50e563599b5c8094a4dc6d22df7f76f361ace03dd9b0fbe7d3708bb89bf2b0e0afd0b8cea1ecd97bcd0448e2f5829b779bbc8f7e2bc73b0c4505c27f4d2afc6b6ce388214cbb7329ec1480e3eccf0cfe4213a14607ecbecf59714126035b2bf43c3509a288b51b497a9a50b65a49d78380159bdf57f4d18f1bbbbe2a019220844d06ec45112c79aab957869f4ce97f83c99881ce4f8ed90144597c10798bb492523bedaff657927b7a4d4a74565ec1c14ecd227d82b7ab287050df6f9b1e6788324bd51f0ac04b70638a1a415202a017f84754cea32eea4b81da9d1ed60a413b865442271265d7b8f3aea4cf5b2e7cecd0649b5134379efc725ae23f8367a36e886e68a6a559b6ca3a6927fb9525649293c366dd38151674bf7e49312f60e0fafa9cb6f09c0d2c493218a6a278b54e21dd0f0ef1171933355826f5884dcc1a273cfa43bc5189aa40e4b9feaca81cb11ae82a7cd122d0d8b5bdc54f0eacefd9fcac8cf7e1b0531e2fb0f8d1b6258b16dde4277bb34b01ba8fe514d75a605ca8593abe5878964d0d34235d2bfe774a1bacf5d6f90ca18d2a20f7a9e0f08ee43af956669406a4d17143d9b91f8c21baf9a8534a7426350a22218dad4bf6721b696e05f78c4083782cddbcb6cc6f34de90013568b3da936f35302320734b2a6f5aefec78232ac512ecade58d1bfd762e502482e43e7bd13ce259edda3a18f8f6f6d4bb1a6b224bd49bc9ea979881e576c2478f20d6440cbd590eab9b946624b9bfb542e5a3da20a764d38f0d54fa2358c87bbfffb5c1ecb81c19b7896b8ff8bf17b5086732f4e785326c4297265032e7d3430695e750c9cc59a0ee07d3abc35b7eb4d5aebb63b3f9e53d74751eec4fe32273751bf2ecaf65355905838b5b51651ea32a92ee0fc8e822d3e50d721a2d287fad30a1fb6e701e96a14fb951aa20782c6db05510319051664905c3b390c472dce96b9d31d8c026c867eb84b9b26af27e7520ae3495d5794ba2f829bb4aeabe3d3322fda3397bb6ebef3b6472d5c5a46c03c8c6ea95af039ec0b4557a8a0ac1eb7b8456cc1be59c252c3b0b30074ea560cdbcdd14babb5b1d4fd0b07c7063d8fdcb9c90107509e9d19cc759e032c9abfd7d1d29d144afff31193e9c9c72ed3c9fa85b9ccda46596283f2eb146d9f7bd3ec7fed57cc53390bb5fa0e10806584ea7bf630bc8663b4e55737419560e3b12c6ef94bb501de3768c5786d3824cda7dec3282ec9bbe41894bb4c18a03d14b4679bd4c28218e1b8c7aa6a8c38e24a75d7e7397d141f38f2fc09bc1df6fa90c218b35ab2a8c372ef50a1a6dc9b7f22cce992915d0d296d0ab9f2b43533026ecd40d65e8feff3bd72b675720d3612d19a5f357ca53846e5cc29121bc92a031e5e52a2d74d1a45847a24494fede34e1bc970d5ea6e141ed5a4e64c46829ea6b0184606be58ec2faa69397245f669b7a2ee1a4f885b76a005142032517ea67719d3cdce717ec4746941f8e7e5110a82a9a431006d29306ec8a76a0f9307e9fda3451fffa112cb5b0eb80f1de55027ef210cb66ea797c7f7ae9757662950dbb2721bfa3d4a63ad9858f05e1614821be6ae3f256f4b0714a071723f6d41271fdaf30c4fb98592a6a585955dd86bd615702e4206a528d42f3b7cd2c52763cfcd2da845dad838a9f69bbff374bff8629e6a8b0e3357d4bfb8d4dd0520e3ecb79c894f78dd6890f9a10eb45f335803c77bd6c629192e1e483e84f09b3b2d0fcb15505ce06bb02d4d0d3d2b38f03636d3d335a0160921bdd43d0d23df8e058f1aab9a5a261da22c4d8daebe6f173166041162eec4bfff3f7a002277b18e45a4a0da09d12e332a3b97b529d11b5275a0cb8b5f555c31ed3b91fd6b9d95ae56a5e8d8b8fa26cbb418df227c58d221d017acbaba325bd6e389467b111c6d3a4ab0f55897dce2935be162e3d2a024878","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
