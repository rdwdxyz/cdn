<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f017a4951f615fe324cc0eec855abdd4d8f2fa09946f1607bc116060c377ce3bef6895b7bb618f58774c427fc9a26575a64e071a45f8fd679922a0f84b14f70a02f4be0d27a7bb7935af2cb87f1f31179b5cdbc528818261396050943a1d3a83fa86dcdce37bae31fc9f1bf19d0952f9f4688f05da777e7920b4604ca6dcbae23de16ca04e513491b029d9a0aa70e61b557d48ce063484a09c1714a4e774e585ceb0ccc79a4db9b4ef42bb5f7bc5d4077b318dc61f482c3f21a559219fcbfad19b8a31a14afa0994041d0eb817fa97db66bb1eb46e4f3cec620e9ddb459efae66e5a21a65a20976b43d288f8fe5e1f98c242bd6ac96e288290beb9cccff38d464409b54fdc5262e5f637701eeb20c7051e3d2c7f64807b2d6e67102ea1e7d56f72b26b9f960e3f82d1a6176f422f8a1bd6d073b4ef4881564702e7634008e74e63ae1dee4403301e263e0a10f5bb93eafff1b2cc3265e8f260045a13c3da5c8793359e7a63fff0cc5faa2048d058f5a3d4b3a0ceba9d0226ca758956d3fae9ef50acd81ed920276e3c556be637c0f275f9b11b446c3774f0bcda8d7c7d05a9b46dec4fed9340e086616f0955a533060cc65b4a77d2ae3bd6939c850a03d7d7304489c544e6dba746f93ace9b185efc44ecc5563924c6c2f005549bae13b12ace0abffec2824d954087b7b48f6b07048000c251d47362b07583421742fa01bda7c70aa39beeaa259390918f7a41141bae7f58bb0e552bb1385d6eb74d873fe8d3a4e2b06f2bbce2d1bf9a98236342a3e9ec1fe1cd2f8ea47c323a79f57f69d0208c68a89fd21cd966c7486123750a59497259f6f408bbad21a9bfe8a001b2913e871bb3d604eb691cfc2d5a0a859fbe350ec618bc5c286eb4807ca5886b20214d5e7ea39592b99c6e78515f92fd0a2642c94b581e6c8c8c3dafcc55007b858d5fffaa1bb1abf052f3289396178fa46044960a91fbe71402d96e7db6089ddc2b41e087d618bb06cab87e9222bce0ebcdfb0797857b6f53c50257836e2e075bf7de736d2aca0cea5864295ecaa4f644dfc6a8ea1bbf3259d53e14bd434f79b4fb8ec666e185a00b5b8b98214db17469b8d0989b4707fc318c9db322040975c9379000dc3057099a8fb7a0fcc79f555b4cf159ed576fff48ae8b4002265b64913808ee34c67b62d0d59ee16e4d68842fdebb588bb99b54ac775f0fa18845c77cef89fc34a00fcf138acb18f9c9d42135cc8653a12de7b9da828a6d5df9ff87bbb2fc0141ccd46d7aff2914afeab52ed58eb9b18060767d43208424019b9d65b48fd13de2afe5c38e64b158eabd34590532b9774fda9287a688fe27f0ec8398cf45b1051cd6cf96b9b03760cbb063f1dee5e3951762880a6fcce397fd5a11fada2aad5032f80fc3186e2dc31fd521239c8ce0d33fcd1699e6db8ecbab3742152b080faa6c5898e2b95f66663cebd8eede032ebed576988523533424a1441e6848d695c11aba1df5248a17af1fa4de9f6415b9bce2c7d2261d828d8dc2944045d4291267116a31b354eba312a860e26c485863660b6dbbd958631bcbdda243e7334df7bb5dc814cc08bb39c81aa9fafef1816bb9f9147abbaa933d1a223b84036fb9863502405a7099024dea1c5db400a4c75999914e496cce006f37ebe3ed29cf45f2169245c27d96c43dda3c3a3c76033f21ec831f00682beb509980ec3879a9b841910354b47c8e6ddd087664f5152828f2048fe4314abae79866d03d3ebcb5afe19ed4574e1315bc5f91246789c8c1a66220bbad95b5669b6034c4521ab0d7779bd7343acfc6bf9d50fc5cdf2d72cefb8183f2e0ea26e44fed2d14a2a83c1122c5112567a64c11103735b36ff8a01c673f988d9723829c8108816bd8940faac641829fc9ac5bb9a08d5e96b0516903bab00ae7dd32b08f8f32132ada3b21cf86a79891159acf8033ff0b295487604953fc9663ec7b90190daeeb7b12c60d50b6a4a9e9c298a21a9722a593f3b72408c74bab0aae1afe99b9a0442475256256142ca21cbd829a6d239f71bc648d0cf1602b60fb85200dcbc16b4259ed124394c2140d69de7abd43307d90acf64af83e6c853d4db65671d3814a7c8043d8cefc62a2ed8597c7fc0b0a8853bfa101789c354cb364256a226b1d306bc8697d87971261103d5f071e4cf087c0b7fa64a85be8afc9856a17b0e4dbc214641264ba980fa1e61375851f005cef7902f0b2c2d6cf05a7b6a0ca5be81bbf5ff37969fcc172185143849dc9fffb5d7ae090719d104856899cc66d89e2a2ee7a1edc6d89cd83a29fb2b6cb9b05cca4cdf1bf8a83cf3a325597509cfd9b287c366adae1af727ce5381ac0854fc425b9bbb1d16b39384ac1762e5cfd03c3989c9cda7fc42efc1e85182c01eaec841ff6691a2e50a1b223e282319747b82dc7cae5b52339139e9d83ba3837a44499ab2bddf9421a64fd6e81b59f5e673cad51740c768ad42a8508a2dff994f5e791119c97051675f791bd88a8ec012e507e20a7be1eec0bd47fe93226ca164507811fe112105ceea0ef05e623ccb6892c2dbd7fcd310881a8d504b5954a471ba594d62236f739cee8779af6db134ddb15851180a8ce8d9621aaa4f21ca56a75a1884bc94c531f1f9912c348ff57b16a961430f92d0be1afc48cbf1698fbaecc7a30f9393eec4defead172a4bf1b5faa7723e228db9d31759085c0d0971fac65da01535f411253acbed288a36d9b9a81e605edc93e3283c7b8a7d441b0baafab9c4d9a54749622853df25b48e6135b3c09dce53ba5f0361117fb1c4678244e4bbe99104038c1642bcf3f4f57cc2c7e00be25db6599f81e3ab74ca99f81e96956c22316b0f121e85b7054d9adad44821dbfa0ab6cfd7de58aa1ab7e5f8fa5eb02adecbe70b11cf9c8a6e5aaa126e80bc848558cb87cc45550648971ebd748a7c55fd2c0aeb491e4baa9cbf2e5ba2cc0040309e3dc3033a19214c88689ba5ca6e96fcd94ff29c293be28d2b20917a182e59603e2401f2364f556cb3b72e07cbb9a085f062349cb078f09de089c15e26fc7028fe1a3d95ac46d0b55d21666b32a6dd701f6dbbc9779410608b302c582071df893b9158d9d7f7fb7f8be62d45ae975f262f4587a33d3bca120b18e3373aaaadb84726c5615be320e88ec3fb0f16ed6ed46af40caa063b568db6a1db077ff37eb88879822ffccd26b77c2f70d771602660cddd93e62825c34218d3dfb9f39b515ddf13bc127d27a35eec09486819676312656fbf7e360b617b03edad1c0762a87cb27825444191f7ca402c81d33959045049d17ecf3edfa3c8e40bf91921454d9c8b08f76012b597d29f2d9e2b5f1e315b61734f2161d040e042cb54f8acf6b5acc3c97d251dafbd77262027061a2d3dcab8d945f6251e5b38f2c0297d852974fc99488cadc1adc21f8b5543ae6546c2a4ed584fe7366c8e54e1150af30f4e845f51585b884f142f7d602cfde76c5b3c7ef4d0454eb72514e69917dda20b0b6f95ffaee13a4f7d7086e73514377d3dfaf15cdf7e1ed8cf80a9f171695d1224bc9c6cf6e164b9dc8e06e44b98bb043efe07a79867b0042285b235d421cf05a5cb71e19e9023c9b0e5431ed06bd88d55cc0e556786f11d581c9250e6b02c8041421acad9e13416d9050f57a38623571aba7cb5e2776d8117a27cd3e2dc9296ca3e584eaa4ace0b54e2562a5f6542a4fee78f5b78aabc432f8193a4d37b52549a285e0d623ea293d20d09ba4e92037571527f536f747a3135c1e06b26f45e7cff40a62289d26e269bec6b76fb36d43c79db3e5ce8bd308a8e6b048343cc849b85b246925f0711d3eca0e52950034118673cf584e789a10391f4ab8dd88f0512b1a652c0b30f6abb24ee93ba82d2941f627060bf2fcb19800a80adebeafc0dd1b794e79f3ec03915ae53c59b62c7ddaed7fb29435b64b44264de4418eed95a774110aba4d34d4efe0a0e25aacdfd06d9ac2f5da40a0d0e0349de0d8b76176a060650aec0ac54ce8109c8f2e0953612422dc95f40a5e2d7e46ba1f332796bfc359bb6b129e57209278833ec2284d5e0335c076cd6df6244ab130aa1aa8f27ecb4b3e5c5eb7d76b4858469c63f29d571214668695536088772a09ac37a5351705738301e90310a6b38a1cd544c6070a5a5b08eef67910ff9de5b49d742edc4488130c990446c6df4edc652c8d891afd539833a723972fba0229c8a99958d06b3387e0705792a0ea86b8911c3e46ecead8967882c3f88e87c71ce7ef7fa86581a3d4a5cbdefd9a85f917a7d4c5ac200ee6fbe11111f30f2de2eebb5bb62d5664969e54729891098f09039f1c916d9a905a6c3177f229116faa934f8fbbef182301de912fe58bd62a793454c284f48229baa6ee469c4868c22afde7f1311e84184e8542bacc434a52b39a5da262118e5a284a301697f3186210b4bad853721e17f7d30db71c044eb3b60df181b9ca4e47483c16f31c530a60f42e3eab6c57243bd4a61694d8a8bb2a345f5133ffbb595d6e1f4ad63db356d9958e568e70aa2f211fc48ca57a23fc0f8e267ff3b22550450ca05d456204e97d3fbfb537a9b94fe9db79fa2b806b89e58e2c336c7b04f2fa076c4910991bea4577b1e3ef8d979f17ee0a6d900ed5cba18d687384ba87a0ccbc51f71f6a32f063c15209274d596b599db71feacf543f7a965bc8caf6411a4bc8fcfeb11683475c6001c4f28452ac41b73335cc469f357ad242ab4b32f518385498e3a2898a8811f31d50230ff1f1d2a56a70ab91fe0b0dc9bf07426d20c6f9ae592bf714331dbe7c9a591fee26b94695666de1553e628d43de5a2f0d0a46b8a8025c7d37db1595f4c94435bdb54feedff8e150fb45852130140381241e6e43c606d20b803f51d1b64f085231b164c90377abafd0cf611b3e7f5b5a66cb320eeecd1a1a1e2bdfe7f7dc01b87f1f5e4b24efba4cba0c9efd1b5e104553a1f598eeec1812be7d6f58959353b3b13245f026808d887965842b5b34dcfa5c3a1d68e0fcdf2cde1aeac6d475c50d09c1203d88b6cd7324b99f8f86809c2793961a588eb39fc8eb39d608aad37aaa6fafe181ebb430969b8e6a34f00e1b7546034a9c9650604d8557931edb266133e13a7f85abe59c75d9cab0b71e1bfbfc295654e2e8859ea63134447da1817fa851029171e0cee8e1c9e31d8aebe72beb736c2c595b31da8bac8038e16a43e1e3499d1c0ceaf0bf7ab3117d6c8e7a112310de4728f3b9442d6bbaf10b6f0153bf90cd0071b9b8e1cd563029df6a32b3b9296d1c91f6e89af539c987ad218d6a3d7235415bc7356631edf103346236a7107d27cca768459915526398ecf24f205eab8c456ebbb6cd2ffab670d1cc6570a34d5272cc42531438594e7c455a29047ecf9b7b641b78037222e4b27c9001ed91aae513aa3a2ff21819d4dfab0b8b3ebe4870c7b621b54ec1afba4ba05628cbe3a2ec1221de05dc79486cf9062b4bacaa11d46c1b30e9737db7edf1f9626af5b407bb7da0823b1288d0431046259c98549e6e8fb2fc76fca49c9b44e73b08f4a5db1319f7645aee099cbc9bbdd956d35f230f448bd43f3770a4a38fbb506289638d1d0edd1420dfe31781735fb62f24c7c238ca8987195070ed85b7fe1e6b1632ed77cc8e35c66a197c883ea2f36b8f37bd8f60b135eeca8f011ec7a88f2da8af7fe12acb4371a968644ee92663963f073a3fcb56cf9611d0150642bb904733f2509c1134bf69a36bdb264bba63402b9fc65ab446b2aa98dabec17a515ed5f7c6c518e6c715f7b899f14424c51bd5d2fc124fc17720b5e16625113cf8addf0792942d87d2fd44cede0aaa36ec4e39924354abd88cc197db6cef71a08e071962609807f1a500f4a7a92e8549b3d34cd6ec743bc1cfbc548997232497f4f7420b2e770599a9776bf8c312a9484d72831bad2f265d7d8befcc12183c16f25f1383610bfbeb21c57b03d1d78b5307b6bb95dd85eb4ddc1016a4fcf54775958baf38e86f8fb1244a5993188b3f0967bb378710e073a17bb3058d3d705f6872a2f4d4b35424d57d4733e98883d01cebd86994c378c39870196725c1e645ddc9ac3a4927f44f7422fe2ea3dd46f5ac8262deccd85bf76966fd6c8ba86668a1d99d3c5ae79de9d101088e1139dfed84b269a3362d5757720c574a5152224f354a49869620cc1903c0666ab418a627fd27de32dd9108336cb1fe55b1cf818e545ce35dd69e0b2c570acb5009d09ef457ddc5abe0efb1bcbe64afcbeb812552874d3451e9d76611bbfc568a9ad1f0b711e70a0733b191a1da0f166b15fe3e8d0b22d04b65602436264c7d9ea0f3e3ce5c7fa30327014a05feff0a598ed817df2b22d95f8ce4cdda913197735b18a69ce42e68636bcbce09e1959b8877e96348265c7f4661e682f0c1fe3c56579192721aed150a933a07d18365669e8731ff5cde720284ece6eceeab6455c82dc6ecf540f3cadf1493ac7ac25763720ae0b47e4a81095d25dc9502957e718b17cbb585321f1c937de1b681cd0d56303a460ea83b480059a99c11d3a5f4edfd9c77999d6b7856e2b258aa58a399858f694d713a5ebb6ddcdaedae7d4f2d8df5369401c837745cba4c915818b346e811bdb2c59063e5beca183dd5e7fb79ec189de7c3340dd3270f4990cdcb0001806eb39ad02046526a4078b6484a5367730a310bf1b319546b9178d80a3448c8b1296920c133891ef7a51a1464b9a8833daf60084c3833f9d1e30f69a87a3564255d52364d2ddfb3a83fadec0f93874d25a43cb06665142fb8950e032e68b0ab42960d9ee10421e03916cc101a544f9823cd8fc5e5645c0167742318a2812a0f880880fa39694d4d456f33dad0bd139c4b65ec36253e9d2e7c0b255d73d1d0d9521872f88fc43e1d843b8b05dfda13e24520f986b3419e5c26eb3b88ed1b7382656069a6d6c79f9b1bd0615c26a599b039520fa94d538ba45915ac8f785d1f30f2704dc30324c79cdc123208cf97ebf0aecf1521d062e42ebb4005fe34d89d6437566a494c30d8b20b7c95c5bc2ff14cb1025f82f0f0f7c2b475a241a90a9546611b2d555dcdf00b4a6524c88f08882b3cc1c7fae9ec2d6d95bc324f934857f73a218ca19c2b85e099f6e960d502df08e886d86ad8f8bace59fe3632d85efaf3da8dd57aecb806c52fe4dcf7ef573c56a529766a32c73ac1fbc92727d9531b8e05f1ec2e0ec8b08620791e375ef637dc9a5106c71e5815633e2d9e846ba093c607680a59de0f721d11c80eddca33e950f0df92b6cdaf3431d6fb5cbfa550b1036d35423a86ba033fc92f0592a08beb24ce0339260f473d4e622a0a100d4ea8091ca48d11f3e5d5f0c16e2e037b26815bb078d3d9dfe51a938a1cc558b99fe6e23002370448d926eaa525d4bdd7b0c791e531b27ade6d3c4422d8f702df2213fdf79792016affcc4492f57655a91b348798059003f8c8a55dbad76297a8f1ef5f433544240b547228c2c603886c39b28649a42946bea96c51988c987f3e52339e3e8cf1433a5d741ad36acbf83d0515d46fd77f8262e71fd01017116f45b654585c7bc7deb73ac4887eb320ab4aaf0a1db8b4897cd219e5fddc3ea8159bd54974be8dffdb45d5acf33edb37e6f30396fe8a398fbfb7c31ae1a1e5f0f567479e7287e547e5422c9c6497e7f62e1bbdb1dd6bafbe2e10d3e1399b4b7cbc9f6bb81b3395b6f5437eb026062f5c63f119d9340702d8d8a34ad9082d5719fd1011e27875baf7a86e7312afca2de13d7c099e1ee3996eee0759048d7e220dc7986b58bbaf03be5226451eedfa8110dbab3573690ba22d9dabfd82193d118a7a01229b31ab8cd4ebf6aa3a28d3e1d34d2b91739f9898e02ec1bd3309adb0f5eab6f61f7049aca34536c0c4a68c99682fefecc586a02b263a569980df6d3a4110ffba9f7b86493c18098e392cf69fb9e5e8533a1ad10efa7d1f9d90943542d659990bc228c12b87acc3adec728c92d3e785499715d097f08f2c5de65340b248b808966e3dc094c5a1c927598e69f0f52a2d75636c8b487a0d9200d34295b794fbf5488f860141f6767386dab91170b9bf66e24ed54433d2afa7120a218e8c3a937b3cd65dd0aeacbc561c74a5346dc40be3ce03d409cec42cc4dfcca29b48375c1264a84deddfeeb6f0d5e13aa991af1627cf5ac80365351830d005de5f09e19a1d8a9fabd73f2a8d5bf3ecdf824b3948bea5c68a66d77885c71390f6bba1f407ccf2765cd51d554ec6ee7134cec33e6f71a5599e99af5bc7dbecfdc570cad9a8a8a732ec766df2f3d150e9022e7d9ea2b5038674a4dcb32faadd12c66b0b4be7f7ce4e57facc7988cf837d0b08e7a9a84a21c3dc3852226f66fddea8e78531a2fb148bb255d1b69941ff961063fa2b65381dd820aa5ed9ae3fe569995149c67f321dad365b59100b3da60fa4fa3270ac701f3c8571b48ba86832946d358e631e908e2affe016b2a6eba52d34e098c1512b0073d4013c09865673499aa9f29f721db0f0ef8cb84814f8e600dd276a90ed187382e21fe1897b7c59535f2e3105b9d03b7371078ec3a36fc0e33e4788a9e601d0efe025068401b81194164261c62129c1006d3bf2c539c5e60becb910e627d7f8c2b34e1db7a71130468baf891a29808f608adfd9adc158474c4be0bf3c5d0eab7e0dbeef77af02dc998c33160e0091b03432d395b29afede985b277cebc76e06f9e501a305d3be30399f5d6891e314b93fd9935a85e14523058c1264081ddc1cff7d7ae056eb6ec5d78b0c086d409ed7f930f48572b0dc0eccfa893b2744a155abfe750947585010eb8345d768fe1891575040c65a0f30b2b02d4fd2bab84575a8f0e7e97b97c884a3605e747d7f3bbe387986fb45c909427075b80d5519ece0aadfe4f5bf74ff31e613cc4b73cba23975fabdf1c8ae7ee26205b7976722bd33068fb2231b1d9c858fc3555cc164502b2b5290a08447b4ca0cb692d7db61591d98257afbd7baa24f4797f34684adfd0e755e3b57e84f5d0928048333f6789d686a6aeee3629f34af5898b934aec0730edba62727d8ba237c252eb3b181152816fa1306d18fd3db7d647380856f2312aca0d18c0410e996a5b6010baaa59150c2324d953b7f641278c6376a2cf877b9ad788a364a9433333215ef09099f7dff4544cb83dc7c2b52b42f4d9f4895104b78a076247359c3b847016583cef12a739b9b7a9b01e619bc162b197d09b56f1c37a47951e76023fb2ac2d530157616038961618aae7030e0a037197c662672e0e85b3ae997fabc9378f4144069e01af028282b73080e2503ff268f4b53fef772bb57d06e4547e3b589059a2b75046090d896d901240b24960b94030cf2cc9672f5aae8771962184934d6faaeaffc860164f6bcdd7ff668bbfd19c608544a6bec77b9fb0cc9f6d1b6b23e1b1712ee611a02dcd53a894aaa5c66786a027e0e214b840a891e7bf616c2976bf5df9cdad8f4cb775ceef4494a2cca4dcd4c5eeb7db7d82e5ceba80c4b2d74d189557ad361214300c23528d3e95450d3fba84a78395664a6d65569c28453aa10a608ad465d2d1a6765d0606784947fb34d132488fd38a0bb84e9a191ae3029e997ff9af0cdcde01af7f7382b69f4dbace65a68f8145fef155e6fafcaf67bed2d3cf37242d374aff007e66a334f27cad64c726f7b48674a9566d1ddfa2bc88b24d5e36778591b130d0e87f2aec9b73ec2ebf7cb7a7d17893b42d976357b0f223512b32f1da8492cbf06bd29834df836adae66424346d9597bf49f45f158dde5fc396bd49218ed78ce837ea85edbe7ac7221d6fce6c7a82ec0ef068aff251df2674ad9835a7ad3534f4873fa0852f1bff699326359e9e084a67148fe64d5d241c8f6dd25dd08893817084b5b5216239eb7ebe61555051e6906d36629d25d0d1ebdb7c4f3080e160efa7f5c357d751c8beddc953e7662bc7413fa237cda0897c8d2d2a6b0d8087f29e093d848697d25abf2f8077048caf828673be42a6d5f2b23a0a0d545d6cc00c00775052e4e59ecd2e72b38d823638e4f986a1df5772b5be1d31e718b6aec89d8be3f919c746da15d5e28f908946222d78bca323340311a35ee3ed02dbc7a9a6139bec3075232686e9c775b83df55e4fc2b813180123d1705378caa3f12375affa52b5224f6a2763fd03455f2975e9a486a7e34a5f659646c90d532cf67deb6c885cd823da73aa75a6e865b7a01bff0bed226144062ab499da1c6daf78982641c3b6aabc2f1d1709e33e69b6efcb4e658490356ad8e5eb67b9a46b9ca927b364e67dd40bcd586aafaf402ea21debbce509f8a319f4bb5b56eb978e3fa3712501bef763fa02096ac092b0662e37b36ec20195f3d26eb2ffada8fb3902a45fc46af79b6fbf54b9153bd81163450e10388cc6fa6cb40c4ba694b260ea59ca7a0872b799e770c4e57ad608b2f00858f364836895361bd96232da6902c257ad1b47120c629340232e5edb62b84fd1d58162d11f767b05ba856c47f5ab7aca25fa9091fa7a5347f26357c790548c3e70d525e97bbc0bde90c9371d13f01e00909b7207d4b4559d175a003f5b6fdf7aba5bd655afd67179a4c5126c8a2aee9e2da17c9eed78fd55018ddd9c107b3c99e3b7878244db84cfc705a23c371cb4c5edc137a28d80082d2657e2e51958222a1878009b8d43239c58134a7db82eeeb4580b28312a3a8427b267f91ddbe7d8aad7154985e646ec3113df3ff27fcc1018c88932f3916d97c58f6ceaedb63a5aade7c43d0a9a864caac827dc35523594fffcb6a7551447218ee270af4972b7cad44a14165dc136e9c3cf15f8b8e577f5d5075c8a6739c0e17fb7da9e66063088784f5f7043acd9cf580ebfecc31eae6968c40c16b5b74ede357c1243530cdbdd57afc4f65ebee7ca92d269ceb1552d1ebf822dd94c9d69728b24b015406669b4730f28383e6a1c2d1ccd2633225087556fee6229af00f3c1d399870c6b4efb982c05ec6ea90d459fbc0d58be6ed1dbaaf9adf59d72c4bea0fd9b41f9ae4c7364c58a36bbaf1861f5cd07e739a0cd9d9505c2e4b887b2b81f9fe32e7e536970daa8f9fc33c0e102936b1221f7d1cc8a8a5c4e00217d7046cb2d95c72ec4bc6ea0331f81caf65977ecc30d339b3ad216e6ed0310e105fb6f0d31a9dfadd5b22561c02d414ce475be83a04cff808b7910c36ad2634f7b2d0cc41f484c0d09b47e5b5682e727bdf591d1ecb9c429c65761d236dc2df1a34d1aed62af719cd078a2fdc1e539fac6a339cc6c24ca08f63d694f879db11a817c4c73d1d9b93263ec6330bc3e70470630a9f56d87a8d5ddf1f16e015bc2f93c141788396a4d02660cb22029071edfa7a2d292482c5e33be07fd45ca2379188a419aaa26ca19fe2d6edd589a8dcfeea9dc5e56bb272f69836208ec06b0c40f24e135c936d1a04899e2b3fbed1a8e710959934454efff5f2f8c165d753817ed7e9c5805cbc4c10dcb9c2ae074b9cb0ee9d9cbdd3b737bd620769796349bd66ae80589801b28b8b66ad55eee77f53a7fa0dc4ef86b071615508b75cadc63277ed52e67f86194be4fa0c67059bacab4706c129994cc3dda94dbaa43354be0158f956a61133e65fc118c9994676208be008f8bdea43e2bac192fdd1069d3380ec08f4e6574950b950db428180f9363b3da4d6ec96d8b82eca4521e67dd6d7062e569c488bc2a27fc551b130b7156997281444bf6db40d83c93f5ab6532618b58b484713306df856262bec67f8aadb36a4a9e5c67bc937d6af3f948c9fd97de2206a3407c63cd4b40e7a6c0cb08084d3e26b2d6982d875ba744c78b95f424f5f11aaa0bb3cf63f2c1023c7c6b74f8e681fa69450f94a1615acd36cd248fae6b963827f155e2074a8eed5b0fb53ea5629aca5c2ab95d22fd21c44e546750c90e44225cff9425e5b78e36e4264f8317746d61f9b6b1a0f38f99207b5344b613f90db3fe0e37003824ebe1013f9861a2a7891c55150fbb52329a8b9c954c82ebdbb05d8b9a1185bdced44dc9761ec3a5eed7096b58143f49cf3155b80f055a556db883c5f0294e5cee3b45e31ec464dbdc8c78046a428f4eda6b0c51f438171d846bfd1047212783eb1e90582962db92f48caae2a0f0f3be0d5d0b970b2d96decf09702a69ea48d08337a5e5ad25dcd0868e10b823447cc005208f46b2156395a116275ead9c3927c4e1b238ec7ef927c6c227beaf1ecbfae1d50aec0376001ddc871a75d10d67424dbf2c2ac34f1d1deb54119412fbd6bf2f1b4beb5285e4b28098a79f230dfd84adc6d06499bd66c8a2c341424949e52055eeae62d30e72313a6f7fcbaa6d447adaa317cd3243b0b40adf2db3f3cc5987f736475dd0cdbc9f02a7e3cbba7d3c86cf48006bb53f231f618fd09b3c5ebd63b6366d66f61d91b874f30d93be6a76337751f4cb41b0fe3c42406c48ce5d507c1d14ec1daa5ef41f270f8a2e720bdf577839a92ddf318ffc45261a9778d2500b17b06bf6f0cca34e81cc8216010e0a978acf8b5fa310c0ccc3845ff8bf89c1ae341f90d00be227055e596bd57dce5de8ab78d0c52aec71cf6dfdf30c970297fdd7e258e7dc2e4323faea66af353955147cb6eff16444cbbae31dded828629a477624cf5a2049d65462514fc1ab31af5ba38d366bed098eabd95cdd95a1e0d31329101c26634ddf98e55796b1b03804b2dfc8e435bf41912b118ac0e5a49d37f4ae0619f2edcfb4aacbebedb2ecea05765d9de90972ae7744bdcbeaca8d67ed237b6d6f93f0b10f5b19b3b3200efa8674667326d5fa132f2de45de14b8fb37c85b14aa43ab410bacbc4faa9063832048277aaf100fb13f7a46be23191ae35702f8dfd829ae6cbed7c03c874929a5ef3e198ea41d4f96d545ecd26305eabc02360b7abecac153bec67fc77a555b382336c0f2f6918696199ac802c01a9faa068108ccf17d8e329602847b150aff15053590f05ec5fe881c21389b3e6151da3123d01e3132de0096ec4182a47e19f39c993a32d501bd9a9c1463a1209c7297c51506473bac58bf1a03221bbf86fdaf5c27bd9d551bed36e70af2a320cc81cb9cc07729a8d8425bb3b6b5d57f4a4ccec9dd60201c107dcbd315d6647d068c80a64ab8513815af0a322f909602ab557822bdaf6d86b1ce843a865357301ac010881d408f6089d2070bdd8a9c3041785bfe3b0bc73b031d3ffbadda4bd46bfcb229d942823e52c6fcd8ccf623d567fc5a887361047db0e5c3636ccca7c6a1c98025611799f0b207fcde9a736b1556e0fe6d834af6225fc6c2f292e7eacfda80b063d91be2c57a87256bf7d8f8f4cf9a4661d84d12aa8ee6f9a240e9b3103c82ec7e0b3b80e7a699b0d28ff44fb3efe14e1337f35f42413daa22f08f9f235931d9925c025bbe7f8f0315462ffc918acf21377d42f8b6ecbdf701d88cd1483c2b41f8b68f903570c2aff04e7eb7fae3799ee2551bac77fb58ad748c611193d569000f8d0569d8554cb74c3332b3f55c21224f638bdcae05322ac71dbc585a65756919ddadbf29a2618beba7fbb00d17b02bab0b1c949008821bcbed13066275c535460113b917279607982325f93e3423527322a9b5c533b5215f1881a5412a7a39a1596d69bcbabde0aaa3f2411e4c88a13e9d6cd4d306a6cf09643261d9b9d368dba6b15d0e983d53c42422fcc40be3acd8f0c55251787212df018ba2074a579a28afb5bd02f2a4b576f94b95c90c3980265f6d0b24f34f3b9ae49633629ce737bc41cce46de7075414e052b5e375b5f159f8c37019afd7fb0911aa51f624a6d561c86688fb01754f9386b70e3d35695038dc43d602946d989061e8785c197b61ec91db08e12a101effa5cd5ba302519d430ef2bf3069e3f469db85dce83a3ce73335c860f357ab04d15b74f1cfc2602d73b8578d7a34ecc2c1ce0b0b427a01619c335339d400847cdc148563c3a50738e93e30b205c25c896565adeccdb07ab3411a4e96b918e879693aac0de914b80c6a82b53635e64c49b539f24db70f28ef8f99be26095ee4fa5a8da67f06b3254f548da894d5bc96cdcc0f60466b69f2e7e4947d28e712e8f71178f9905584c3d8f97dbdf24b551f7aa4e3d44e4a18ae7de4e3d2d27bdf72c440224e262f47cd3052d2efd2ea4c9679b8fa93e7f17cc742086f9c00f1d2c5818bd3bd4d6653b21b4a5e6038d2b2f670f477d86af25337eaa8e15c8910aa9ad8b43ff6b17f8981b9feed364726886041e9cd0caf2dcdf267c42ea28b94a91a186bbf14e8ebc99fcb56472e472957aa55d96a65f398c153cdaf28affac1722d257cd06cec40ab57379d8f4008e91d012cb12b5232ace93a8acc2e47dca3f1e17f5723c75b470f3d0cda790ea2c404e7e7aa06361d7a5fc8e0d884c590534433f935e1006e5e49910f0140d39b11c8439c936fd754d02c362c0e013c38d71cb0443f218f3ceb7a7957176e69892c858a6a6cb2f53053d0ef7342e06ee2878d408a34cd1a16ee955e7f7eeb1a4ea3df42919b568a40ef454430740e81ae69b27652a2d6c57bc898b3ddb357bee45910465bfd0f783bdc63fcda7bf58baf88f537e55d3f93f511ada3041ab222874663a750083f9d1fe7df6c7d606a4bddbab5d46a46df9a72991f98cd13c3fa7ee287656ac2bb2781219d9da2995a8d0a71298dff2d5ed6b8937c7db4aad912f460bb01b16de897c2e7dfa4d36e96eb4f7c783ec3c3e6d1e764fa6e05d5b3c7f05eab1d23ff8226fced2b95d4b7fa285727f3b2c61e0aad11b75914731dcc109c1e47e2ad838088799aed788459cad59780633952005ec01f8e7d18d9c2a59e383304b6644d002e316c9e02ac48076df63b82f4386e48c54e7f9e5a19c166bb6a7e94ba81dff8ead57340bf8b94c6274becded123c0756ae9a56e3db5bbf67be836ba6f47a01848b5365c5f205fd68d06343d2b3e5b19102b77c6b2127b1c77ce983585a323bc2ee92810df1dd3ace572756f95f6177ce5d80f17ccdf2b18427e4e3a66a34e7f65963d3809c4326506d71a09d72ca3407a0cfda9a1e53df5ffb8f6cf338d770fe779945284b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
