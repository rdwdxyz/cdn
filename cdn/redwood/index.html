<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"016a3a879d6ad35d95ec9eecd083c3d61b02f25d99dc17b6d1b57ace856bc05868ce3a269d0e45c55cc7c7f178f9323c96b2817865688bbf275bf733e222dd22bc4a33fce9a340dffa5f7f14ed1f353e770f8e3c48af84d57d393d0fd1bc7ea9c4ba5b3cd962103d81f8c1308801e5d72188ae898f76033de6eb804f4c93ad88752d9d2c5dff8bd8f8b57dfb03a9cbb01b06bdc7fd3d529a5763ead8d9a1e3e034f8e7327b1b7d5a121a927e60d0f43d862c49dd04f6767338bcd6101cd47f1ebe2863244df300cb28e4b951d3049c2f0012d838ce120f07651849455d496db57f21dc6936813058feae11357cd23ad41443a84216ae557e084da1873547f766133e106f33c920dda00288eaef9fb0fae011892befdadf31abcf0a6483c9f5ae2536596da35dc277e0125c664e2d352b1a188508893cbc0e3ee7c208ff9e70ad1bf2c926c0f28701d9bae5fc81468c050eb0e2249158414bfecd06a2706eb621f51851678d4a5a36af2e1c91d3ff5e4a660b69360327ef61e3786563f225440e280b08a46df498d9d92b7142f1d1db27fee6c57a698f19e96c20fc90357c2a9343f91a8b9fdb6ae4477833cb46c945675a0f7af7d8a074b0950ca45929dcc9f34614aba513bfa4c1c96580a21a7ffe75b4a5e80afd80b3d433cf104cb537b2670716635d9876fa5e4effafc660ae42b130618db635217d3bad228888f84c37e267c1392143366354da9eb19a54227c3ce22475ea2a7e72a2406c3817ebe61024bbc2f9550c81cc78c41d7c7cc143ca638ff6b1691ee229e642ba5b9dd3292f4e86ff4603b29abfa6fe8d91297e3335c34dddb1d9a369da6326121b9ec6bd1447fe859c193c2482e1ec50c04a214f7ccea41fc75a48c009964583b2c39b1546f67bc01afd28ce56132181aced0119fce26a6f9b80ffdb52d106cb24e540999701d29ea39a70248ee52cb5d686e5ac3feed3acfa09b5d5fe81fd792fa619cc9d5b8f780e19eb840e0edd08b246cf4075ade8368ca5d5cf69c7498a49d586aa0d115e3df5b0eee862865c7d1ce79f18a1eb96968b446021a46dcb7ddb06f2a011e412f9131b735d40894d353beebbf15426084d330a5c1d1d04e2bd054c5757782dde9c9c8451fcaa7595f553c57519aef7021eab933ca8d4682606e2803063e123625dc2f7ee37d1b5a15a6ec79ebbf6329baabd2b69d346f304de141c191ecfc41edd2bd05c88f4778018bee0c2a70d4a424e99c8aef1861be11bd9c0b3dc925bc0a485a1049f167afe76be0768131ce701f032ff539a2c7ad0a24b01df17f7e267ffeb3f66428bfed72621d22ee9693b057b591b63b023e855515e7b13d395ee539990405e3858951fb6253e4e80b51207ea9eab6fa482f4a26bd90849bd80484c592d42c4ab7d76d64dc44ce8f29eb86fb970bc62d6cc7d3aa64b9ece0a5c471b7d96e35349886670ba8a7c78d87ac570bb8a6b28a9d43c00e7859cc577b64d29c4646bc5ad8786922b84d4c9ec6d488a190f3f01b72a6b0b3eb83cf6962f2e142d8ad4259b6c004117cf5178ad6a337239e5fa3f5fdeb35cabb4e2187b628a40a123fff4a757aae55ee9013dbf4138b6fc894b193f619fe5adb84545e0ef92940b512dc4c6de1b00990a1d7d516cd438b5d48a9c7834d3131f71c94d2def1190edb44a834d43f0e95fee5d99cb76021e93ded655344c4c548f4336313d487b716c5de4f48e73ab7cd00f282f34714275759152efff9988501fc4f0cb0e8afbe9f933147f1e1f452e3c92f66eff4e8a79b65beb8586c8ce216c4b79a99269b5d1a046ab8f4148642d34b47fe427f2caabdab510786eeb4bc6b9b96eeea2ad1ed60df56c82bef297aef0fea83f93e4cb0230418ffa51317974751e3ecc13a6dde5c8f746ec96dc48f7fd5fe597a61cbb4f3742cb9fe70e7fede2ac57441d879ee7d4c088e98c5e6758f8a0cbe5b8588063c8759c22f976b738962bd549fc7397aee2b76b782c48e8f23f1ae8ce4fa7afba73520753d0c7ff20b020c81cec7550357bde84df66138b8564a478d4c6ad85770971dd6c661578e57a53a0d11bbf0a24845fc889b45bf544c1f3e237f2535ba99c18365b94b28d8e9f41ecc8d5a39e211bc514d0e78bb82ff748431a96fd386df0daf33a279c4aa08442b9a7d1f74f6872021460b0c438d3e20ab33431f71732aa55c992947931cce6f0429906ffd0e31cd4cca00c16c0fe96a42bead60e370ebdccb2ef501c52a0b24888b1ec700c72b0260427d27f35d995f143fdf076f9bf5b61dafc880b3905b9571d52e5dacd947147f0cb57097d1618f37b3e1f07521baa4bca11c28c66efa16e9a60520e5b6d36d0eda4f8b1745afd564091649f77f94e3ce68cc1d3fbf11594f69e48943b00e9ff5311d11bc567412ce84bb5ef26de35f2480c5c9c688aabccfd0e4efaf511865d90421016c8f8686423b2b970dd84e0652954f7d8ffbe735df25282029229cf0b042afbeeb7253b426753d9acb74923c87f776aa355e7c342ba71a1be394b4f396894dcd15319c72173d63ecccc347db10d70440eaeb9be32a2e7c7cd311608eae2458ef54bfd698fcda7cf21243a4d851178331cf211f5e37bc37dc804b1a07b09ef919f9da99bce999cf8694d77faca338b51c7fda545a34cd5e35bfc7bc5c798c484a3583f6cfa991335fba0a77dffa37a7618fa3ba50fbb989c2dbc6bfdcdd2db7bf77042828654c7dde448a23bccb94f02355a60fa857bddbcf5a81851a5d6c1fddc2038860e8a4198e5a321bd27717861ebc921ee32f3d25bc134f7d3f14b83954001e0419d7ee926dab00cba52b9d6f79e9225a91661556b7882fd6624d310669e0334daf5cf23d59cef19f1a51cdd99a05b94dfe49cfcbb9770e1d6d6360d22d2d081fbbfabfebd59b8f635162dc2d507a742c7c6f8d107d044315ca93eab1f0dd922f6e00523756f98b20f6c7b72909fe34e5b241b61502b073b02bba987b5dc529e0a4ef9c85daecad0bbe3054c3023ab412947c6ca242fe69822e263d539e3cc60b2b70b5fcae0c7394368ff3d805310bde64832f89f96d66f4b4f27a0611e2a48b67aeed7b68eb34c7fd39408efaf91648601675befdb5bf44ac53c43f4493609815e4ac2e764bf30dbd078d147919807065c01f862415e8bde4bf61c51fdc7da52f5f31b0706b658c36d6f194d806c68ab8ca7645e01dee0b252f287ec24c4e436e387a575dcbb60789daee4dcf1be0a3fbab6f308e79787299a99a5830bfbf4b8219f26dbcbc70f07daacc1c22cc9de949b192ffce14d8ade34f3a80fb418a2245276599a7da8c7d779c621a48d6577afa24ccd44cc40090340c31579c94a9f807d51c87fd7401f6b9b24b0aef3261e1ea67977fb245b48249f9d342444befd3fc74ab28c9f3ea8be09499bc61b17de9ae06049f23c8128009567ddf23c35c47afc69dafbdbee1156703705878a994f4945d809daa6f3fb322656d806de7a2b352bfacfa65d150422c3a6a9fb270c4e035d7df467d020f1ca5c266e4d36fa46f8ed60cd9585ae4f55fdbc4cbce2f996d660594c6da3030e7840c0feb387dd4c460c2d22595b11e95a09448fb3c92a98169623a82c6a07ccabd23580d82cd33711279bec3ed6c8a1edf3f38cf99cea3069c91bcd2d90855cce59cd7d7c4ffa7dae29b13fc99ed3beb0bc6b9748655aaecb9fe8023036f3b207890544771e8b28e384386250b4ff07e4e51b568ff8641db54a31ed6e4878cd40d1940bad66b812ac4a7605cb0519756530222ae46f6904540d483193a4e098c83c5a78de44a26428537d3d9ee35a024b3ae4613e92e716b5cd83f6df5afe5c35e74a641ae4f44abed570a3872863c603a8a0e0c49273a34848645fb8c235bac0e70f69fcca4d767ee4c347bf7cbf5f7bd98dceb36c0dee05a3a75beca834b5cfafbece95894381b1cc06a0a9a791395e372cec3e31342bd95cc1140ce1d0a5ced7d50af965d1e7a3b6908a44f69cb2e56b179e0f741a82343e415802c881a3639a7fc569d3be1f95fd615dfef878379a1ecc433de6cd91b8c1511ca09029412ac706d85fee3eff16e4df8d653c58457e26deb1bf75908754bf8a60db136b8380215de485f41e61440ce6671c86933042cda4ad3e8347add0254104e9a41255096968925f5da3220b04392559eb7ba13bd145fcab011aa7614b132ba216b40e598c3af4b541dcda2e6275f322437a6a07e9bd847fd73fd66509b187abc54e75ee8430dd4c569aca71d3cc7c37a1cfdb1c27367665f2ff228c9e47a74a2c08975556654e902ca9650609bd9ccbda425497286bf6c100f78d9c397fb5c21e2030268f6b33d5a4f9dd3eaa3465d1542ec01a6f2c7faef27950bc2eb469aa65e1aa2092f10bcd2b3818a1b7b47dca72e493d9b6f658f8af93bb5b39b13c7394b1f26ed4ab375398618d6e128d2fffb24aecb072d4989f0ab5207928c9a6f5b450d3e0f2ef02aea935a12d0f34e2c7b15bf7ea3cac03961205926b953184bdac74de81df5686cf63c527cdfa83027fc399790317808d1e006def281bdbe961e9c40baffb17e7dffbf4b8b1545cb764741f0ac672d14b72998eefed5db464094a2805a146f906a90542f0706fd7142852538db1f86c343cd1d5fd1d570ffebd03fb40d385f1d015271650af9694fe69ae43776265adfe48d07ef101f1f460201286cb03e3922760442af9f5e55caa2ccda44917a1741fd3706cfff27e2ca49d6ddff19b01f438e1d0a5252d74cc1b2020e8dab20679f589facbf2f207552c05fe8a6b150c54ddd9b43ceb5f15135c5a0a7d52e9fe62025d0b35f215ecdf66e361e323f884da040fefda432623f66d96a1bf13ff6a26c137f3f1286a3145cb3119ff2e7f564e3ef452b910680d2cbb37c500a21741d7230923739ff95a4752a71fd7a0e061743c916691a104bbe58792d7fde881b8d7bf26abbd727c6ddd0c3467ef5950b46e678633d381be258a3171b6569f908b0ebf83d470da68831523dada0cab2be14c75c0c3b9e12047069189878ff1b5a8479ebd610fe8d4dd3013c4f559bf249c74806c4a5078de5604b30353f40c76544a6c3f32e73e434b57b02c59225abdd54d1fcb4bdfe0742b1df0a70871c5d9652ddb68f23cf3deab9691c475163c47273c07c11ae09ba3bce3c1c378150c9aa58a61e57610ed1cc914454d10984eca8e8e9bb42ddf1dbe8d0bba5e30d6997cb6226f4def6cf59057ebcfaa41b5fb67c46e447efc31401e61a1d304bc4ceaee71fafa631329b173788182cf9a24a2222d27913253285a3cd8592d8bf06c55f82e4562a0792c8ef325810a123b7ff193c46661f791e0a7a88d386ee875316959fe67b8ca703a6e533b2ddae3a9ae79782f18f6a4f4650035c9be802ff25f62d121dd0c09be43a859ec6904a834a3701c495cd968c2dd252723e5e45d1d0d50cf67ba1431cff21da8d0ec1f7ee07a18c333065df716a9b5b52c86ef4d9e8dad604ab811345f79c8e9855ace7dfa44a5f7d2562aa3dd52f137fcefed89f5f02a0bf1ab236869c7e29a6ce86b36e34813acc0f46e998a562a81a8d05d6dc6c01696ddb083900e113120821726022c97e6d4e86fdb11aebdafbe4e897e250ed26b231c272b91daf7c5989196709136132e08b993f6e24b65443584636fe66a6b822b852d66d90cbd073a5230789713a1417479e8957fd42931346ee531080ccd6b4d60c4ece6d3dc67455ec34b1229f9af475a12526dd44cce4f9e353fbb5b4830794174ca59dffc2b0d5ec1af79d502bd43407c343b893e08f36c96fa85d7651a634f7674ea60ab7d55adc3753d46c7a5564e0fe12f337841087d4a561aeb0e334473818abf2bbc061721256a46b1272873cb566b830ebf284d8c3dad25f7f46fdcd0c71e08b6472103092aa809c0bd3bcd9921812f1cee8e286985776dfa55ff2e11eda7923bf71180613928c9bb97e901e5994226f2031e0fb9199000f9caaec8cfc4d283ab900a50c9b4f20f7a01590d14d5cb9064218220c8ee29e5d9ba12d15cebf48514b082e778dc3dc8559b67466769e9da0d366fd8ad2ef1607f037c7d0594869765331692c98b1b86c131f3049afbc9c5e0b7f95098c3fe731202b655f4dcb54e5bb6213ce0ecc38901eb2b4c35e6269a30e672f0cd12d34ce7b496a55043b1633dd6c21d15a46fb32e88151c7718cd815ef93acd6de344d93877364a473a7390037cf760cc2dff662bb4a3f4f8c39b53951d034d2e3b44e108731dd0650cd5aad7ba180b2780969f46d0908fe16dbaff5a6e194dc98d9ac2bdf5e9278c64c865163b2d02f55728ebf95794bc49846bd98476c29238dcf40c27b279def092cefe9984ae2b084cb3cba1cba508a276063a739713eb0eacd80586c79a476767c01e98cd3b5be23a22ad0e4fb29b626e8a1c1da71c0c589346eb4eb384f0bc61315001a41c7837c82d4eb19d55a7e31aa01a23780dcf778486f986ce130fc6f2c2117fe16dcc7625c46b7d46bc8879a499f9c56a3fe30cff7152941838ac38a8a56943043401c4ae51b8bdfae4b9ed67d7b4f0515db7629daf55b4b186dc7e8f6f0c4885db8f10ec82a14fed17278c65b2eaf88ed038ebfcd97b6da95894d45c51fc79daa2b28514c2c7595588f6fea665dfa68f23cd8993aeb4009b3ae534a9ba9bbd132e04e81a6d0c46944195a12063f98458aaf5058c934f8da7eebe07bd3882b04f8fe054a1c0a6e0212773564a61e6afce7f89bd1e9a3df34ae0dc216aaaa949f9d716285f19b8e8bf4df47196f911b7eddaa3600f8a1f33f70bd7d856ab7fbe66d1be2676715ea582a1d06e3105548c543b4499ead1ea3e0f90fef1b98e6b1c16e3f99658185bf06ad20efcb27e48ef184e7886db029c5c88bf03c8c195b5ddc2e3715cdee5ad8d4b88f16840ff37d0200876d49c42706b2957f90bb293bb3fb31349d04ff838bd3c78543a56587b3b55e102dc84df1b484d2d6f3d74a21e885d0d57f9b1954a23ee3cb9fb2c57da118673bfebf738cb46032a7467a354ba79c0ded82f2745bef9485630e3b4011238ccaa869b4fac62bee351be71009e0201aed34f6255885fc1dcc03d0235b665d2841135a7b64ea15018148f5f36975bae36f15e8cc894f68ddba103ffa836714d04009a05c14ba39ad80cd9f85eaab90d35d87be5249d98fcf8871ca4e5c72aae361facc539bd56da67c6b69501759476653b7cb4b18e46f22a5138abe3c76b8c10d3e6b8cde3a01a2286cb955a459d473e6ea5c3b3ccc7f62ecb2f6d014f6fe6f3793b243641c62d104f9349984676a0298abe8d6d193cd27e6837985b3459b8c36a4d1b3b675740e895f793af7e77a3fc59f2ced1c31f035f34b63ae3dc6321c6e91fde5f8510b690ecc3f972c9cad3025676fe7573474500490283c5c7eac909f1e54ba0e4403d1a006c2b6c006c1ecc819b9433f2b5abe6396d2101283026a71095cadacec6dc3191f94d1eccacdab25fb90e8ff1f7aa446a7bbe224c270eb07dc11546a23e0e7564c63ac7bd35c33845d2ffd7896156fca0719f01ff028ed4b18122337cdae5b96cce7c6d67d2279dec2e64b55353f6435106ec3653558fd0d0b785f6d09e852738050e0388a62c3685d7d21565e40c0362dbeb54ebc24f45072a657b8ce61e574addf88777ef85d7af5de76d4f48d23327ce8ec40df0cff29b0df6e7bab595839159f82fd5fadcb5aafbddcc31e8d8f409728145e6458eaa10cec31f30f178de34100f91e893f0334dd0267ce1ac49482de02d53668a2c92c6ef5280c27ce1820e7464e8eb175abbe254ee32638d6fa49d0da901801838a963cfafa5632c59feef6f8061311bb126aada5777b49288434902479b0a2cf0dc0244cc032714c97cb5d4a209b27dfc6e34a1608fc91cdf3a3238e64ab5cb4bb242bc2e0961637b54981154d9312674efa4e6ada3757afca100331ceb92affb8880629d9f5af9d71b34d2bea100632afc26e11873cd69ca528c9b48375be78f3db66d7cd2bab28e0023a89d6cc386019231a463d81bd80b7c037d1e9bea841530532498af6d09d597ff432abc06e383ee431b31b5887f83e022473fb96df80776fbfbaad80b56a764e6aa135943d846f4bcdae81fcf1203ccd6d67d848831e6c31c0996de8c1bf1fc0081171a038b7a9bbb67b9f8811e6caa5a6db670893fac694ced87721d65b948d8473afc680433dbd2690b6d6dca5c445b5a17b4bd4aedffa03128ac0303fc35ff4de8c23ea0184b898d7eda7520c6626ea59f1a7f4ec9074ad58932b20d2a1576da265feaef4e8a3a2922f8a848275a3888e0f140f122704b18c33cb8a11708b1a5b63ce6b558edaf09735ba6efe87dfc1e493c0e0b006df42474875c5526f9ccabbc90c099cd72d89cf9d90478555996b7a2e4e8d94c4f403f4cd7fcabf04514a23e871ea13989af03440df09f905ec7a470178da5185000d77a15779f72a94e86643c83d10a81abb3d6b98269962941f65433d9058e42a0231f70833301d7b01df6843a8b86675ba0f5eeb0df48c45f426689e880eec593768f6b58d117f2da68812f4094f71319e2c621f7e9a8ee9cd4850536babdaef0f0e6009aeb676302d59c43324380f82c2f1dcb4d2a9ec538b36e08a26ba9e7d35a93f8b68388d9bbc9d0554bedd42f9f6219a5e8cac86262bd60c606a91a19d9526175356a34be7e4c655015557fb0d970fa64dc4cf764f9ad42050c7129b253223fbb965d580b9911ad50a5fb6a67da738379c5b51da49d6d1d99ecc1a0c70cde6a036d8d34fafe05aa82a00bb9c85b32c3b06369d375c9fa2d6e5a66fafb6795825bdb931483e83aed9166c95efab3c4d17f4f8a6b5aecf50c3aea61cb031673d1c7548fa5aa05e73367c52f7de7ff088e5a864011d6d2cfef9bed3011d834683dd94592ae23f059dfb8c3b896d1369d974d0a8aeb157f3475266ccb14af16bde706ddf40bc732b35264268f78efbe502575409fb44fd0f0c04533e132c4b19b46a72652c0ac8e37a54441cf748fce2f268953e816da07c6ffd91be4d778c9c2ecb8bfb8b97b6531c9aabf458b63fcf8d33e61c4f4a5f2e279905249d1e259c078df596becb183272a099ebed1e36a1b6518aca79041587de88abb34629a2a7b9e794ac8404e113ffa095073553381845edc580fbf1ceea4045e83969e70b186534f05f22a8021f099f4f5940da4d4dbfcf3af2820019faca2ddadbb274ae5f11c768dd5f19d70d50f776405db53e09309f7c468865234f438c399dde3d340d867599ca0964d5e46d2c354034d91040faca1922d558e6a3f998516cdd1ff9f5769502c597625c8e7bc8be3096dcc3483f87b40caf9c52fed43b26a89993d5df2acc0bf8f796a97901e677b25ad249b28708e19ef5fb5a9818000117427d80ace03c9ee3076fe8ad98a1152ca55fc25a67b78d1ecb540f1561f4f37e016f553a4598db16a289c4e86fc680b8e0cfc53d4806ef8289cbfa24f5681ea442828277b5f05d4b9f94917e4399f7dd778bf058be983dc8724407e4ab9074e119a7b0419d432496737882025b2f98aa51498c5521d7c52c721c880db564d0d4e80e2794fb3876717e8320380729643ceabd0180b656d357494dbf5cc9593a4aefe64768419fdcad6193712703e1695b1b3c388894951405f95d298e3ed26ec8a9dc51b91e0ec428ff1f07181ce7710532dd03d7b10a3b40d706bcaae40e554041d1ef675df8a308533e6b308e4247e32d4a6f9294880a33a60433fabea54a8067e94a5be6dcc1ca0d8ce1b7e809f83bab91a68043642a6b1a67c4116d74906fe68b98469e7a8f190afc99788d1af602d5e1494ce1695444387f1633b8857bad8a5409a66b42e8aac6b2f1b8f53313fa855bf1992ab367c0647758e8cf2a7ae2b541ce9971db878d2ded4fd4449e3191cd68f0d2ed788605ab607dfdd3ef28333d6608c253736f295bbb855d4c1e330ea2b6035da1f00f1f29a17ece484ae46f4b843d945a19712a4abb3ed4ced2ac43eeefd9f2a42468ff2fb675017e6b944a5e5beb7d4e113b6451c0d3f587f6417ce8bc04f7b74b456b86a6e8edf07cdead516e3d423aea8fb5f0a91591a9e1dbd1c8e9d0f76c5efde18504951089696b334f206d2308750355b5dcdc78192117c32ee55dd096485eccdb64be19ecf7abf299947f6f818a6f72b1b00ce27d87adae9aa4a3063ecba51375b2099d4882505e8df35b0e5d73b1527bc38081cdb8664edd93273b3814101f286d43fce33b3fc7568160a0bfaf7fa522269a69c646bff42e57bd3688c0d74cb907cb780a1af29797022008f0936632ae521ef18874738f9ad1c2dac799c8423c8f52fd4bece2c5cf3169a8efcbe71e92bf3335adc4993d1f8c8e0b3978f0f4c60361c197716c6f3610eb1d056e67dd3f57e2a20319cb4c661381ba9b66a7bce3c9f835cd9b80c1ce2aafdc59f40ec46282ba98ccaab547a4123df5b205aced7e34ec69445efd96cbeaf2943e21e87748ecb74e3e3310d9f55bf8ad808f9359c587e68c1749b84b14ac72522736017db0a76da13a8af6bfdd507528bc20bf70fa33c44834b9ebe1695ea15497c38b8f0afb6bd94419bb003c1dc64177290e9530e723a3e24688c7d4b047fc4985a6cb4c354bcc6fef4578addc6dcc5c980a59884bb31816f287d3c91d7a49ce24039270b9f4629e1737a91c3e7daf1806f71da3d962d55c189fcc5cb5660de85bbc4fd6b6dbd653fef957a5fecd1e8e69a551f126722d16224ff64f5a373ef7c58bbdcf3ed9083394915e8427ae370cbb7bbdff2a6766e50f1d503f5449afdbeda48a4a296d6cc7ea82376ab1de2aeadbff5c973a3f88ad6c613a96b8a7b41d130f68a14663c41228d52486a538b8393c67e7589b8752c1a58227c8f6245e23c151812dad9a88d1a12a82a102f00a0576810cd1bc9c0a11f070bda42eaa61026a08d80ab45b4332f5ba38b83b9c0d4ed914c07b6811e2d2b4676055caf3a0f24acbcba21e9ecf56770c65b61fd1aa8b8b7a9ccb767873513504035858e3fa277dccaf69919375de44e20dcc99cbf124b939a48867ca48cfee172fc91e8b507743a563bc45760b6cf2f09ab858bb889cd7741e1a7cb5bd65aad50fc61a14b6df7a150d626adc04aaf0cf258ea47023616c661f9c543dbc59cd7eff1d638f2f789cc44484313ce3ab8658ab7df04ccfdbbbc2639aabbefd161971f7962c3e9d09ff05fda86c19ce7769547c50bb32c999c5188df31cf1714c93f618ab7e5bae7015f8af04cabcd10deec54a5b3883520f2ede83e5275972064cb1398518d990683f29c4436bd95b51004284b3b84c8ef2a5b0e219dd8a3773f79ed48c6d9764667076c458bb7f4ed4c45b58c6d447419033c6b30927da28593069925acb191a6d6b66f2b801756defa7711d8bf40b30766f7154919391e0faf3ec27ad659c91e9b5abc6dcb75e97b390ed5aa09732dcfe60da5a45179161f4aa0e71eb3ecf4ec2b691c2955d8674ce514ae9f63e39b72bfe857061a55725fc3152adf4f7920295d505cfbd3648595cb927f7c87e618fcf9c9ef6a0ebb8bb29fd353fdc801d030d3f4941f3d7dbb947703e7f20d458135ab22fcb11f06cb3fb2c56c1269be78bd18bfbde8ef268efffa82bc0cf384ae3cb6a6a65b273a2c94b4945eb8a4e27e8a31b7cdab00fe474ad2c653f55793e2a1ed28dbdc52caf72acab53e71b9a5aeec50dd14d2068f4e0a4436632e578d7a8e5cb93cc0ab836010456f6d8aa899a65ae582528c6bf546edbb6967834b413f89c3a9aa05d97bd6d6957dc3b0413fd2c53f54c6f178b166d187b82eca9ed9f3ccda9a9916a5434212e79cba5f60bcc3f857f30ae16811639a0386496eb6e8c5d1c9ccbe4318d3e2a160fa3392211f2308c7cac2e1e804c3596b6a90102bcfb780314836c5bc9aa47afb1c208be94cc3f5ff7189c66e8f2fd2ed801fbe08b999f52aaba6c5dc08b6cd6258048e45fd3d338d2f692975d6ef02125c8dd0dcef5a480c6303a5a15988af4ea1076ad8a4c72c0d8793367c1fa1509b2bfd0d792ebc3c725d849f60525202274b75c61073827ce499c5ba15062c2ddccfd364f7c3a57a7ab39b248806755df189b00e534ab87c577713097ba12178c868a8c4ae18109cb77a8eaae6741a37c8eb8aabacaef43c9b1b0606b07b873d27d9e49eb76e71fdf4a12fbc1b4584510b2f41a62ef560d70a488a91b332228bcf4705c4344d9b8932b4189dc4b237ba87a611aad78e6aeec7d200a72149c539bfdd404aead0d1bc5d35580283667c7878e114dec0916e41035a5cfdef29ecace65e4d6d8c97b09c4ee58e5f3a979fa31e18745279975a247ec22bf9e5ef9c3531318145d5d2ae1ea5edb5fa1b37f63da13cd730dca16f26523fc7b82d5e46f4ad59a6cca398216719742a7afd4bbd1021607a34d03dec8c6d2c0a5662c6da8a73614372c32090837ccf572e61a95201971d338d0fa12ad9fca50b19c22e08606de1bd0b690bc761e4dc96596e1c67d3e85a68868186100884725c5a6c7d78bc46bb348a537e0d6582e3ceec5b6cc3b3ec422bcc046a7275e3c0070a56686532abc73f88fb2b7b7b82d182ee7e01d6b20146a11f208a2cef8284eb8186488ef5d9aa81d2adee6475f7122338f52ee69f3be41bee0e47e0a69d539e1984a662687a071be98a68c34093d24f4e600e02b5c5a9cc51a89b746bde95f23a9f4ece96cddc5bfde7b52e6ecabfb7980caf131d79ac1e3995c1366e19e260f224c6fa627e3dd30122f875d9317ea387eeaf31cee5f041cd495aa456c226358764c030ee45eaae93774849fe398c40d35c63c74009965b98de5000ac40704a8120c7d179470b2d151b2d72f1a7a77fc4cc50bafb72efa95c5d1bc583a861abe44e333581650c28bf1abdf5f8a31fa47c429aadfb1b6c9c99dbd90c70a8b472e43d254ffb0dfcbaadf68dd92ceffe6a0c0b4a8f6e015ac6026ea9b0d0b9d1965b29a185d757e292bf9f3968954576f55258a161a8e44ac5822498e675a46d603f0606998e1e361894fe82f1fea67fb140129321eba2aec0357841d4b831f9e66bdcca147bc4895b1c1c1e530504be9977bc363a34fdb10583035b9ec3c74998408358aac1a1ed7540969e3d36d04fd4206efbb69cabb8d33e91993a20f66679e6e471a5b7c76dcb7be67d4878ca824d44dffeab0f0575c11c7e44ff06e56c5db442b896469d785c9c4892a31e108d40ebdd55c586c2d03c78ae2e11b6f3a62138b5a18b804f5b7a28fb204a899a0d4f79957330df9bc4507044b32956a8d9a02c2079e9b13ad002922c990886355d8233a821e50f41710fa634ca9e270eca87b38b6653e73f5f8ecfc9e1e78b4a1629ed6299bb74a618339ff8772c50e04444d5d7a3baf709df3dc19daa66acbb76a24dc138180987a0936c223054c50408e09add179fdf4f2415f92c03a790ccf14e64ba32c53350ae7dbb7fee62fd21c7d21e28f7edc87c09f565e064cbf6bc01c4fa7717a2c1ac13c7946c4e6f9957e7034076c27186fbb46911e57bda5c3b042aeb9d672f6434fe58db2ee045008764e3807804a4ea44dc6f79b057b85a03173a590b544dcc195df8a5add74f0f692b465dd5642e1cd849ed5036030d9485ab8e62079b7059f384b9aaa5054c8c469267a61f0e8c6bba2651a894a436e610a728b9d8caca2d57411781f4fb19db7c33e5df6c88b879424b16cb4a88340beb681c156d9c3ff28bdf758a21bfa8838449313dd1ee7e2a93e4bd1df32f7a70fa44cd73878a7633d4de49690751dbd7291db2bf9b5310cecab6c1ea8ef39fbb3341ae3e658a9fc7f83bdba28fc9b0b3accf74c9eed07f10d2520904f9c9b8cdf8e2d2418d0ed3df25b4ce2f77c80b206226cab527643eb1d202e3e28b5047c37695971845e0b2d23ccb7c037e61e8e704c77a948902276922b05796e6a7ece489d4ba493aa7a8e02259d8e23c7354edb680a8b38feb7afa05c3dde92f1d808037238187ace5fbbe2d64dd3d0f60a4ca043dd7e84905e8564da5d7a40c8a49642428604f25ad51acc0ed77fb0b5f2fcbd4e123e360d3c35793e16b6d1ac60353e0a5c6673fc3beb769728ee1231eb10d1677bf563e9f92d0e4a91dc0bbef490e5fa6b6a68e44552ab8569a69a988a655a24968727b967a0b05101877667d944abcec83b4b5cde9c9d2cc720595b2a35bd298fc007c758fb90a7d1edac9deb68978749b544bab2fffe9b9202069f2c5132fd1c60a3801fb375296ee23b71eeec8f60d2a66b30e7e455ac155f55e6b8e8787349ccab14cf065860712924a538c78ee5340543ea57dc1e04086d28c8dfe994dddfd44d57d1410fdb484ec9805a659c6f1afbea6d0e6227426ef5be739e8b63797d8e2a942c8bbf3ff9be1ab4e7474dfbbb02a4d55ad828238ba222a2d755a2b40225aa3ca8bd84c25073b6963358c9d2f75e06caad0f39c5390e22ce042789f12b2e079a1fc31101c8d2ddb5939a1ce91cb89306e218eb95928e6e8923b0f349d08981374de0a4a04c586446bc0c452ab0b33aa7bba0911e5c303a5aa9f9b2c4daca02e5198793655898a2db6e485e72c3b9f1cf981db26c7788d8291d93b847ef75b3856ee59479cbc72cd61c436c467539bd37385e324c64dc2c1d208317e6f269caf361bf83eeee02ed370bfa879c3b1f98158ba468a62b5bad9dc81d58d63ab622779c1bd7ceae130b73dd8df91bb1dc7b897a19d81be8f41251f8acbb9b2df479fc35fe931287fe9dbd9d63fa27a39bff02da515b6ee64c61368937b1b3e5a33df312d704648f94c330f3d14f97c1f4f90aab229e01c583a33587c6d9b18f348208825b53144b6d4352bfec330ded6ec1108471affefff0a5a71ee32ad286a3db45cdb4c3ab4e4668f88e6ebe523a8309bfe7922ca76b9192f084176a737a4460511f873f55aafe9b2a94d2749255bc954e9cede46ec32faaf4e0b2e892887a230bacf4f2616f9b658fd83e1698cac2d8296f8c1db4f4e48c1ddf3919d2b6f97af0a19dba6c8f941059968fa0b4c03dffbf3897adbfdd67a94f2344f78cc5897bc2e1aa492aad9f150d001277e4513791367c9acbee8ba4fc7b25bfae97ca729cba0e75dcaf52b81a917baac508dae88f33fee4100c1434f927feb5162c0968978f87ec38db6edc10d3e91bc3343a0a5afacd2c3fb0b985a3e36198144a89c81154474efc20a64ebf4f8e2dfecc40e41fd7d8b65833eba576d4b1080b305b7b13b1f72a60b3e544b966ee02cd236150b206e4eaf66f724d4dc75be4d5f98c93c478131bc14a77ca6a2fb7557f25b632e178d18e7e4a8e2b2f5392522e75092ceb57d11b737876254ec4fe3334ccbce9f154cd26abfe67387250203f824634c9a6d4290adc2402fbbfc2766514769a160ecff0715f29c1a3f2727c1c7f65edbc45f512047166c792345c62dd10ef96bb644030b24ce5796e6a7a215fb6d659e76a010c5fd904c456122c187dc988298af9b4f96a845330146b5e6ead2a2a9a03a10be82bcaacef1f87e16d883fd9f921709e9344e2d02fa8552c81b667093dd6d3db2fdd182df6b68166d0f3e8b610b561fd5fcb3d9ba9c12bb402cf4953958716051fd438fd101bb5532847479d560e92bbca49babc3af394387c5ca266c3f7550826907bbbbb5e8822634e63d273618c39f50d95008ac63b80f9b79a4f5f1eacb5fd6d9719432bf52cda89e3f601153666c1a15ff1551dd80289cb84cf88eb461f23ce0eb45a5003e9789058cf1fed8dee36a023df9f59fc569af3bc8e7ae8aa449573aca6e93ab80446af955c74ab17f51a68fcc4d96abccb0fc11d37186b0c6cf54bbe5a0aade9478ce6b8b4f7ae665e7f89d0a5ba8fa0b507e873cee274ff195b5a073b332d3d54606193502e2fa7969adb94a6f9677fe16f7a0688d1670aae81cc1d39411da8b3ecee5650c4ada6f2f43ee7f0b558e5ffb85eb86e028a7050f6a6918d590eac394b720b1d7aa9229b12865c30380a2f2d26ef242d7a5c777421a3ad9b6492d2fc23efbc72e74aaff8258087b3e5e56fa26b497ad6cfe81fc7a1d0da1da16188e818e25032c76f003d9bbe70fcdc1986f9ce84090d8b449c51fad350c01fbc331a59505d8d8dc8748786bcc96bae3c6d649d3a02b0fb2cdc94dfcd44791a082012081f78dcd5fa5967fec5ecb9c5a2bb58cb25fdd9133821d929d0e7c98b0f6de908363086e3c27303a5e8563bec182664b03ee665231adc5b105af503f40a14cf3bb375048bd88e8d48fe66569c9dfdc5ffdda08dee20611416ed091ab0b9cb51dca620eda49f68b867736dc9570dd180254ffa9d3f6e22cad31222adb6f0d688881451e744e64f73370ab306da22b584bb06ce3382e5415cb4ee442c472db9638197c32e3f718e72f093a4bba37333ad6b38ce54aac0bf1501eaee5b1f8db1027cc51c3ae6e8252d9f55a9f2045d38edc596a37221c7ec2cec5adcfebb8d29d0c76a9db7d7b3ab27895d464d6f7ab7d5b75eb4202c71d0787e1b88fd7537a5a82031c929ffbb857f473802ae58273a61f4046a6e906d3678f434fac5ef9f598199543e4add0749b9d2962617cbfd0549efe324a14675e0399f063dc1a001f4d9aafe09982cc263ef0ff66afa7338f1235e33e273b2b9dcdc270033d600b36d16772ef20a5d0fb20f2cd0bd4bf6539b869f61c6e1d5b2f7e65da8f54010f2a50d6e6121d3dddd32c6afe47c63a6ac96b2fac24acb7b6b5bf53eebdd5e3ebdf1f6bbc9dcdeb0a73fcdefd26f7242433956b39a045d200d96fc765fae05e35cb0b7ef22c2a4662c9f731ce34266b4eb8c629f9787f13a4b3d3f4d47be19593769c7f37b67f4ce74fc37aa425b5b6596858d6c77cb3a11daa2427681fe00d7ec7340ed2009784cc8c3cba4268f09137fb1394c0276a4903275c164707edbc3c8000e83a8dbe7f24b1f139190411ac93ed55120b113b33792e7cec2283eb284f163ac00e2814df8eb17244a8671e9b167a5f8db1b5236ddb60985bf475e5ea3f2ab55248632558d2edbb62cfefbe4a34001bf55c3a79165d227d8a453078cd1783041f3793feb1b47a955d4d69e68650a42b468f7b8d728c75d6e5bbf5d4257bb5bad55f912ff68d9f0c42ff78289423d6cab3fa6d1b57fd2f00a5d19474ac62525f4df66510ad4f459696f6d30dbb498edd322520f7b09a706af53158600d42629d2daed2146b7ed0e95935c655737122b44da18e9ee284650fa405e76039552dc4674fe1ce217d6ad96d39528dfb6f03a70cdea32f10e5a462ead02fc93b575cfc13055b94a988d68ba4297142beca76d6dd22def0f6cebdd1edd78bbd13a62f87367b396490535d4248b519a23f245ab8681455ba816485ee296d67b93510b4ac84fdb634693bc7aee128bdf25811397ccb841a68b2c5c0c03ebd51c201cfec003c8479619d3797e87e620a0e6e693514a70b0785848dbe3023c4357634196a294520abac10bc93fb99efada55317faec6d15d97f80b101a68e2b3e421d747142c0b5a676a49a234bda55d08aff2539d39c7a9a4dab5a99d2eca5de3aaad7d62b4ee3ec25bcfdd3c683cc6f32fd71579dd0a3567a6ad63451e83b4f1e0d02480804a8dccb8d35ddaf0bec33bf3c22247d025bb84e08ff5d20bd81893b63b8eb011f183b4d8fd8a4ee255b1b71ac1d8ef2e8475cfa9f98c7e9dcfbdbff754336200c869b6a6f95841d518232b4259dc38e5f4db7c92d55000ef0a97f65eb22d980f7feff4005429d512ba43c4e6747f5096f98e085f25be6d09a1afa63ec84848ca9b05d42d9aa668127ddcb4fd8b0217d62ce1ad05a0fbffda86271b50e139976ff427d1bc938926c3c7bdbf35045aaa0bec9c41d0c10dca8a98664d0b27a997a7bd730423267fce2f2a2947a9ee2c2ab9befc8ae43dc8c000494c4e9aafb810271b542124f205fc8d7837fc1e4d8a0cf129abc7ac31a9c7be21cb2415129c9d0c4c3702491aa5adbe6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
