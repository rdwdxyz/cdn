<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9ebce3f6e7f24b8797bc0cec9e78e66bec0abcf292d5e302c33c404e073c67ede871539d94c3a2d02569da2016a5055d7c4c9f19226cbc2d0cc4c1a4815d4f71d62541c2222df07e240ebc2918554e0c547d4a115478fa89952299b61462b95c62b80c014cf6f807cf3f803bc3ff5626ed0a9691fbea8209d7315330a9861e8517937290d564ff1189b8b0a8033e2b9a3e7e8868a49acfac1154f0d7749eef2a2e26b7f4e1469db033c2a8a7ac864475a38c72724dda1200e096fc3f752a84e36268f99d477d90ddf31a5630b91a20cb2965bbf93134f8bc5fc0c5b34593dcd47975c2aa00a2977ab3a655dbe4cd19c32075a7630f2d90db31a6fe845fde07f75e735adca4d5944c238cafa4c752e32b255e390a6367bb1f7dee0b5d28cb4e033ac5b2d08ba2520aa8522f38a2d261974f016f72f913d987a22f7a3af6171aceb9400cd7133e64e2be55ea05ba4f4ccd74492c862f386ae90bd3ce2aaaa839392080b2e068d0c9f6cfc9d05fbd0f9257f64ba3ff66024d4894d1c096ba02577b034023ed37ba34750a426995da885768fd92f892369ea1098c3e670e670116be416f688afd8fba4c50b7fc7d43615fe69cf994f04d45b6f33d9b268d00798bea4bf1c9906ae57d652c4b8aeaefe037c0ea182aa2508a2a9625484f40b3fdfcfb1402c105d52953114c6ca962848a6a7000bd95485bcb7b014abf8f637682cba6ed6559ba6a985e2b9faaeb2d2cf5f1b2ea500884afda4e8319e79f493d91897d557b1e93fe7beb992c86852195d37a2f905af808403c415889fa68c86f19cfa81e3f272d076053c37c09f3b2219b0efb4b384a76bcb0a027fe4277fcd1623e80830b9f34982470f5d92d5985391d89b393df75bea49db659a1148b6fd4d215771e58c9998c913faa62e59fb34c89d03936e583ad89e7647764f1a5417076cb8acd34820b2a6bd5985b1388acc32d21efd9d14048d15dae087d467204f01618106b883383ee093edad13930124b9d9302a0bdcccdcb4af61d2f42a93eb301a4714eb012ecd32595c3eb14d92e8d52f54783bfacb4f498a29cb8bc1dd783d3e0ff371a328b27eca747fe8d0abb06e6ec8b46f44110bf576207b8e9fe9c4bd0fc0920f4602faae0934113db0b8a2d1de18b001e18497778ac54fa8ce12b1f78b79fd2aab2e54ebd44ba3632842dd7beb5f903bd132c55a231b626700b1259163ecab47346d9e1b974d2cea547581c09391efa85ec22d705bcfcb9b321f30b10ef35f2848ef92c944fbcd1eb1374cdfb43d90cce56fee97ff53c73cbe2abd5c0ede8af5fe7189838f835de85a89c9bbfc63419e523b026d52691743f9fd9599ce7b04281f816752476f74db35360c23b328a1a1982e2105451b2233888350568adff081068c1f9960f22f90b2b05abaf6a65bb061164537acaaa5bb60eab356e85fc88a8b970d0e39f5ba40018def0bfc070509d85fa310e473517c660d73d40e101a9741fd4f504bf350208b30a5c86dc4ada069bfbff1b058b4ef0d8c00717c24b11f79ea1276be77bf413470773a30c8bccd19f70466d5fbfa66b9346c35fea451307672600d40418a80bf339e3375fcbd7dad2454a12ee077e8d1a01fa009d7e0742735ea0d3728d5f5672692b915717eb93b9e75e507a454b86a473d12db565c56e727ba4a44111890aee40547bd44320b0bfd7251a2acbb5f55f00c0c06a8f820adaea6e26dff94b76a9a6b3259037b4a29d725348b35369c6470a685e405c0c0bf07241fa1830175f7d09547013062662c9796f2e0c3ecbf79d31c1eddf8bde84393e799921d2ad78043c5fb52a5ba55406095263ae1cd89c906eeb76ead09e9c5b462d98b3d11a99acf347120a0185a4176f75d32fbbc696134cab5f5b96be691b6de710eb5a1532cc136a8a0712e43597d500f75ed1d13b84c05e547ce3e44eecdd413d95fd74c56478b53952630878f2e6d6c863feea942462a07b57d25036f291ff2bbf7a698516f6bbb55ac88b1e65ba98dd6f26c923f74f62c438b053f31d3133cc6f2492e6971550a08bc7ddfc19de272d56a5d30e09f8fd7586f8d2037adb0ab9d7403d9e681dacd02d8eced13812ed80276251125b839b033fd04b2fe0e37c1468ad0a0e84e89b15de8f76a228e3065b7538ff1664ac18e1495e1b587f97cd3cad606055870016bba5ae2c537572571981713ef615fd1e72fd5245338b63e59959a7020df40852fd3b86a8385fcbbb6b941a4de7f53c0353885e5410d9fdfee9c8ca9e359761682e2b6fc80e680fb0371e58bbce41e3e268f20dc4671e43b32e668e880c1e2c69908c94b252b2ef5a34429a3f9cb5f559db49d3951f271b493eaa8ebd5dcc826b165af9138965dc5e89d6edb6d4876c7d18ccafccef6678c3786ff8b3ecf0f3e6e32bd072b0d4fb4c51ea61a1c70502608c5c3ab1e8c5bc35f6cdf73603a7068f3b7ae137547c553a08cdda221567ae33c38b30435e0b6f4a0fa9061b05f2eb9d572786535eef91cc671c3f73d63582cad6f3149c7ba19dce02d9a854048f94346c94532c9f634b58bd92ad4e5558e3cd189493af2efbbead1225d56a723432da2630a6fb80d631daa08f714b83c3596454f291529f7e428733efc863cd4e60d964b3b69f9160eeff3efc88e518276914c7172acb04a931b2060f21597d27b545f6e15bfdbd4de95d997c882617199fb332ebe6f9696f68dc6c9f5816245d81c4beaf1b4acecba9ee8ca546c709cff6d1ccb0c05c7b599d8902fa30a6174b544166668aa7494734844649535361ad258f7321877ddfd9ea0a454f438c72780e79c1b0a73f4f9ab4c1251fdda6cf0ea108ae9c5cd06b01f062adcef1a2ef82a1be3e64b65f7047fb490e79b02a1a4e34aff91668f87cdd1b410adf9bee1c88dfe8a3ff83672865eec775b6db58878cc255dd2326f1dfbeb0781285d1a9e90602c5e35c3945b21869e8436d54e04812d78a0895347ccb609ad40e0b172ece687f5c52011fbb61643d836e04293e46fb4d2ba264a7b3a0b4747dd64c263d8d5a60bc910433b738dcf54a1c1902cb3675273e0cb83a181060b4069445ae2bfb68a3b8bfb927a0b1fde0e04437b94eae3d65ba53ea9bb03a15728b25208307f3fb0373dfdd20c30ee5303174b1931711a1105e36ef88c9c00c478d1dd465cb4e5358cc8487849371432774204d44e8f521173524c1078885fe96ef2c00f2e5faafb90d563cc7a4ecc142cab9cb05e590e742b992eba31be2a635146f07c6cc595cd65e5344c54487d211bc9f68571dde518738d76e89811979e19b76d713a08fd51fc4be506e0b563f048a0ef67007349e072a98eb8615a9b6c071efbf3341a7acd32be9a2a0a5ca0494d9aca319dd3ea106e8e6c1f21e5ddfe0bf19e5383b1de6920ffddde8a9fa15cd37d5cd3983c1aefed36a90a0b10706255012d5cb82dc3c94d00fe44717c5ab07e73788b8065bdab0e1b2808e146e9680853972d5d4c196b57694710bcfb5e9d4782f3ada5ca8ecf420e5964075ebfe4f1f0b152cd71baf914dc8eb56eae4663c4cbe6523fecaee44c7042feccd3a970edeb6e8b7a3ed1d01ddf731a5c085644ac4083177c9ab625ba522ca3595ac5ec9a1aa68aad6c8483abcb6d46568ac160363651145f2d21ba4c567d20887b07623ee6919d9b7975aa4e94aae497469e52e3f0ab78ab349c24489464062fa01ca100e8a60bfe63af42c377a4bb87ef2c19b8b7fe9155e96bd32bb4dd62b1c048c372bbdc0c526a1fd40209384b2c23e901071e12bfd92a15118a9d043566054665195bfefcda1961c3eef86b8b7874ac055d57ff5736d21ca05ba5aa69941d256378ec7282cc447df1618e2790b4e5e2d96aced1b13752740b3d42e5c8ec2e9a6a0eafba2bd3fa6b89870f8261bef759b1df68d2119c37b2573e4dc0b5c71f661d9c9ce21f486f84473ee7d95326119287959d17d12aabfc674d5f1ade9938cea79e9395a7118cd10edf302f0ad4e11c343f9f3c8ad230b08607829020dc9af1f97017df2554d1bed51fdbaa2534cb5e187567f74700a3962df84c91ab6379928024ed9af2db52cd5abf2464dac4a5ac51eaccb9b1819467410a7bab2b9ab70dfcfe63022d007a7dc32c6941e5d71517f8613b8302249e73651d3cd02ec89b634c6c581ba926b934dd8504bed7c8b67e5ba407c5fda348eaaac300cc34429c2196ba923410d920e77f92428240e46b65fb6fb84542d2f692c0047a948959fcb6856a72966b2e7b0ebb22d43c76da3b38786aa22b5f372d5f5a5f90e505cf6507ce9c08ee25efcdd1b805615ff2c215b99769f769e4e570249a118190ae25be78a592b16bc6df4d73f116be318d5a472da96931059f08d5f04224e5f25237480164b24ec8ebe43df7fd9c32c2025bcccc39379c936f891f1cc6272135d8c7c569fd46a62dd3a2546037e0104489c4f4ee8e89bfabb947284a05056defabf3027db66d84275b29b06915114dd1654b7d92c821cdd5d63be78f2692e9ff87d03fdb71dffd140c2507b3bcadd579aa5fe226d0c0b9567745f7425c1838e4de3308caa3aa0ecc1dfcba012d3f81d51682db3f0c451bcbe39c3af3aee28d17b5875108bbdaed14520ba040311755721db29c6cba1257f0ea4059d31665d40a4e3bae11a47178a4648e4e5640cc8067d0ead205c26b9ce474c40bb71f212cb926bed8dd071824f40077fa32336415b8ddac7b8f58dc523f85564c1c328a4d2ae8989411c271e5065ed75eac8c495ee324603462c7c3538b7d759b0a151fe42ae9ee425417ebf0126c3323e218d7ae59d9447ec9a32375a1a8907683d5eb6d081279c86393e9c26ebb5d056b7c66230c21ddee8092641dc3c7c098a5f0bb42681fd9eee3356b38eaf89518457b747608253dc3dd9e77a04513f5a6e5653382191263c2d37d572ad81c538c607475efd60427470eccb22c7a8e71b9edd647d0baca61a6f1e6b4b03d1a92546b977f98858e1af0911344bb2e338ccafc94d715297cc12f26d308d267ed67b7f0598622f24d4cfc9414416a39bf76b1a8b141770c9072fbef20717a0933fd7e40ecf850d52b694ea57f53724256092e303ffd926094785ba69cd0a124fedba54a73ea427b7bb3a083ed47dc3815e5ff401d61427b5b9c57cae5a3dbfd7db44d097e6e6dc51af7dc49a4b9dea433fa49f4592b31063bebb650327f0626972de1b091dc954b2b31e6732d29c4e0a8eca869a75cdc48a0cdac87ad21f8583b9859b00a3787eefa2a7dee19c3bbfe1f618d2d752974d71a55337e4a607953f5db27b1a915640f9b5327bf196b3043ad541256f0c0cc6d03ff8c06d4b13e932398381ba1f9394cac45e2f743fd06281c7a1ae8b1a855aa9c341a248018df852550c2033a4e13f25188dffe78e60ae9d93ee52f15ae97742951d394353e612c386d083c79291d41c080ebc6321c2174414231d8c12c2889c1f9f268c72a06960b9b44a02c4ef766e6fe8bbb1d7c0776fc548b7b05fb3c714a2b86a88e1fefe073ee79e31aa0b89acc0f140116de8f9471c01a535beb05144e5aa672b9797516037b02f33d8ae76e03fbbec87caa4a5fefdb0765b9318a6363a1b727c8a9a837f572d8e1bcf2106f9039cd3c8442f35de9fc3de1a4b6c8769ec76655ea548c6455ddd8a398154ea6a80ae220789251134d81a93ac921ca484401636a8011cc5caec2bef79e2f15b0a490555c5aef25994f8efc2bc24feae41fd16e2e50024bcd1516d0d2c06ccc304bdc19b6d9be661e6951d36ac1f9857a2c6c3e37f9ed271d448753a6b29e3953150584296d244645d2cd1b289e47368d6018ba5f977984346cabf1b4728292ce5368343bb8a74717e4eb0889fb583a448baecabf3e0bee27694b36d4af01737e4ffa452c5064bbe20a74f83c124ec8ad423e6663cdddd0184485927098e4a46f64a2c4841ff71e803f21bbe948872e90b8d184901353c9d3b5d82c6fc0dbda8a47ea46d37f62221ee7df7c3c3e317dba0b5e7709ed4b7a5d8f688ec86d2e8b6163c5d365d3326cf80a87dabc9b58881531d9d234b0ba56ec31e6f12cc8c8b1190b6f317dd6c1bcb47eb72bf8bcb5b40316148134914dc190499c7c43cd52344c0dca0511d28b57e702ebf1fcc3cfb543e589a31c9416cac568273f0e49a6f8f994c67efafe4326b0868dc3999adc2b5816996db563a5da2b5ee44789d82cc58976d9322aa031268b735e5a26773aaa584470bcb751c9a7ef104ae56d216292e2858abec01fe5af7032599033c9ab2bb1d134e4a026814270ca1f5b6e4f1bf60d6b13bdbcd5d80745d6a1613fd54931792be25955123f3ac5c3e98ba6fcf53c59f3dc22b2f1f81145c637d9071b962ad2deeb6a515b4d4a7c7ca9066979a12d6aecdf6e5fb8175f26a6ae0252732bc4654b7d6ac0c48573b738950a3ed47b7ebbab1f861ba138554b90eaed74721228e8d88446033c2c196c1fd08fb2a3892a844cbdbdc5ecdce4d418cfaa93f9e5a0cb2733f2cda1527cfa5c34f695d70c2935c26e83d762075ff9ede81093a482894c597a315926ba0cb54120a91b4968416fe841ab9b9a48fd9ec39f73e25e47c2ddb18cf79c91c9a8c77f8567b280b96bfd4882eda9d2ac864eaf5cb4acffc25eac56766373885e443a8dddb067bcaed47fb2ae0cbdd6282c51b0a6c093433f0a5f6b6bec97a809c954a655de9e68eb7335c46c5b45370ba2c856b0b5ddf9b023902fc07694ddb69607c596fc09767e99e41c50fca0cab25df5fc412775f8eb84c92f49ce10ce64581cfb0c61499aaa0fdf86203f012422cfbc1eb98796feeee08549106a44da80c72c4b5a0d8867a489d4cfaf63e1746270e5b9aa1d28b6755c034303c2c5e0ccc0d1bb5560d314ea9b50456cf9d8a0e7f3b941b47a4ae41d3d9b79aa3492e5e526cd3bb2390cbca7b3c5834e1afadad27e5ffe968be8200616d61c5ce327fdcc8915bef1f87f2ca0b0714f205ebb3ba82dc63928158a895a87a54cc61adf2250d07b10b161d6abae0ce0ad2aeef0ef6e38eb531239075a46baf465df89d9e9c62df60b88811d4431c62b1510d77e6cdb02449f8d9564281eac9a4247a3d63625ac9739f2ead17c41e304d1975a1e93e700b2afbec4e5af94f8e928c432078bc3b2f24ac07c9a748c66359f3fab7a6457525552c6a41951e9e2d08f8bb4343fd793797588f0358fdd41870a5717fecc9e77ebc6a61a0f356bc0743eb326141312bd39ca3551c2f8c9e169bc8515c26143f8aee000c376e7432f8d82033710f8046d8a3293f96aebbf7daeb215379a919f8f3a3428c9ca8392342e22fd517ea7cb9d27a7c4905d9a9febc76713ba212b794e69dfb13df63aa3601981efa5377089f994472dfe8ff71fdd8596ff8196db30dc0f743ccaab4a8c6ed8fd600e1e1d1a48904a04d47b7114c8a5c6fac1a7335b150fb07174626909f18247ec8caaeb39be001f474e2e582a0eae94df717e339df06d2122fee3335809ff18968f602195272e8d1b8bef90db62431b4971c9d2d23f240e9ae147b4122a6aa10091f830f636fb2d1f023a8c1348fef0cc4bf3b1e7f1f5b81aaa88c2c5cf5eb121329ad99fd801cefb7d96692122b19bb93398ca47207dde40c478e65db859f35f70160a90ac3d2a1606fbd261c61277d0cfb8d879c361858a15d7a5f97b9bfa55d47b7333baa92dbe733397e7d885a98ee9e8de8c51024791d1b87957f1283926f6de26f82e28da3994e8c895a415d45ce0f98d73920b1d4d66ec25dff2559cc5d66cef7e6519c10f207bab70e178c38b60d21451d8e953a1f98c793de468143ff8e081844207c4f79734f45e01f27b61c1f49a0f7d8caff5c36285cd946fc4501fcbf5d97c3838f3b63be0bdfd973d33c41abaea853048307c05fe1bf06cdb0ae85932ad9585a9fabf5fbd4d65ff5093c3b4e0a6be76d4342314d1da9347ae784ac551398e84a9dedf09bad27c404ab28aee85e6c62074039126885471dd77b6031dd17e1b0b15891b1af79567f6d1dc61236b0e71cc2ea3f679bbd9806cee5e2a5df7543bf58343ef20db2bb4cc6e0c74c4a00db520131142a1c9ba97afbd7f5abe71bdbf9409d39adfe02b5beb80705dac2d8b8a06a142e77d735cec2586ac6b13519f5e5a0a602db0abb8559a3b81e2c0055aad3e2115efcce67c9c49e063e073c484ef3fd78b7d1d537fcab81ca4d8161ffdb7e4f6f2825fc6a900b61c58fb1f32f90ebc729fbb69312f953915ded204f44f860aac4ef5f320199d1921298803952b3c1c88b25ef2da4fe8aee2ca9498083c6e975533f6288d0c21bae55a7779b145b68b4b25d0ec0f89bf764c7eac7a3af4838514a1864a31a2d5b0d2f99eb5a46a7e87c0a01bccd1be4dfd4c3b98868532cc3fcbbafe1bb19cb7336dd5732da04112f648fd485cf4bfa36e8973c384837b9cb1cf8208f0fe649abe624dcf528d6210c9edf51457b208bdd4a8ac07f94cbcb1526f292fabe68e255064e59b919e06adc2712ed9c288ed006e07e1de1a7200d75c768f5ccbbe8101bb2b8b5ebb93ad46bfaab43a3cc1428fa1b1ebc4425c4ac09b03d4598fb172ac620f57912b0f6def5563d5138a5cf1dd43fff45630aaebb62901063ff6a37aa9ba6131eae7ce9307ee6f2c5b90a491966abadc7486aa86bca818416b081e848d72a0b46aefb9964aa8e880e08116a83078f1c7ef35f9f8e17eedae8a67f46e05ea435813a3ec6412df53ef8fe499a1c9f94f19588375e2ceebcfe9376f1ac5ae00d77158bcadfe7537dcb8c3a711cbdaeab64f80a73770dfc7bd64bdf45af899f96be423ed64ed7e215150decf8df4f6f36e9a5acda933a32d02843d62898593dd3efebe14d019c4a0e42b75bf72121f1597f44d1cd09f442ba777291b36a68ff94e96e2553eab8f02590d4c88e8ba9e45f0410d197a562889f59bc20eee747ce8d1cc730064d065d949b4d366ac2fab5338519b5b3f12b24f40f536e10993ac5f5a080f80acb953233504a52c44aa9c50de11662b753719759f8f0d88a0ebc7eb312c730254b1b56c6f23e4d9d502a39d8c61b7f1c931086fc61c236284ce760e03af5ff50d27303fa3569fcd35891a803d7904d61d69ad7b26428beffff37b7bc6cbd4da1dde8aae28b4bd315e84600e98800cab76e3b7048979092ee8d33a60a764531d31cf70b58bdc3863e1e110f1fcc1892c05004624904d380d49afb330b649c4f87adaa277c9ae161b2f11760133208e7db3633cc3292954d8f9fbefbf10b1319c2e8ac07256fb27a0186b890494e4ca015b4ea93e6c85355d1c6f08bbb6f786be1ab1ff421a91a14a036f0d54bae2c9b42761cd07a6b840fef887ab6d542403303d768b7884b327c7058c29b9cfa05ae8c0eb187148a052e50071ff0294b06f8779d1b5cbffa04609010daada370f422f246d2ea624ef7010b5854f34d79999418d31d15d7f647065dc38906e8b51f00798ea32a5c615f219a44c980ac634b4811fcbfba19a707e5d31402bc2671dcbaecc992337d3a7ede23a0f3a8d8f6215c3457140b78ef1eebd1c1818e1b646796ce5f540053319b61cbc5e8a85d0efceb474792550ca93aae5aa113625c705aae122cc5acbe3d7ab7b7e0ee427f6e6060993de257380e6b581e43ee2665736af8234de9bea00b6e8e147079af9a0c1e17f0d0570c2c2f5a238c0ab0072f092aa3b0f612461aa8fdc756306ed2e26c6dc1364f1ef4c3d9b43653fed89a07eba6c3cbf11ce85d31b925a4a430b6640795a60531dd4450597590b808ed062dd46dcddb3bf346b06fce0f333302db0da5652702a3b0a8ecae11bc4bc19ef27f0973d02694e8b72f9bc55bcdf5d5e25404e1f954de99c0d694d15a0570b27576fa76b42dd75f15cee8e8fa1e2e622405751efb0f380919f2c1a918aa35935a0dd883f6d75990b9ebf4d673072e01448497631baf39098722cc736b74e6343298ae3e4cb6c408f44a5279de2eef6a711305e611be3eb8cf1894e3b8094fbed9adafb4f928a2bac54f68b97c865b1566c0e762b6e466e7f4d8a0b767f294d28e00c067966d506ddfa1cfd4ba3779a34d2979bedc20052e882120098625522e5cb7211dcb777d01dd0fe725b61b9a6c87760ed9db56cdc0b9a0c79e30ce82016fc8dd3a5d09cfa4285f1c8bf16fd17853e030780be01ff07c6aed49f61c4fa3f4de8731d5236fbce542a1ed10d24f3f137fb14dadc05a7e3bc72fc86eb81ec711d937324213d8d22859148c6c356ce471252da5f204bbd3764d602d4dcf4784f3c450d2b94283ce2dc28235df00589792f1956a560b7e258aa8c75085379ba4b7c26cdd472d8b69340da6c4f6ffa3660b144aefd4ab54f289820846a9506e5434b3f567552a706ebcc5275e2f9e2ae98e2947645e2655e7b6059266620bd38d6abce7a3c1dc2b9b23119b781ed96b140dddc69667896d533b670861e030644a9dc66e38b30a95bd66fa9eb219b5f0e23c93a91c993cc6545f31ca2109572f2e3acc573917ba3d5310f3ca1916f6880c98b3ca8f2fe6ffa66a631be30f2c7d7387d1ca6b1f2809c0e50fa97f26c863edc1b920e848d8d20ac9c53e8e6d88df58f7b2805a6b9dad7d3749ed18c3ad611786615f816473f7d953e31991d8f2e24fdff942c3880c463b5f48a6e4554c0096e0d4a1992a39f6c15df4ea6828f6887d848ed8bac5558755a0e676cfed6d19c3b54c1fadcc792f9b0563405e7f25e227140f3e99a5b63d185a0d38e4513acb9eaa60ee8d6c126a58bf444c8a8aa3f508d8549abf8d2581808a679881b74bd3372864b98b4c273feab57c48111f122d0e4302dc06ade962e846d57164003a3297336daa684fb85e0c6fbe07e7c5d07071f053abc7518a1f1097aae9aa7f0fe6d4ed1ced86d97ed197867ad25aa6eb475aabf425fbca86d118e2da0b5366765cb3508d4cb413bcfa3143227b15d9121ca29bde164043d67b89456827cf7f757c0ec1f4c92a813208ff1f775731dcf462bc502d29db71106225a2b4b891119bcc08179d48a4333322fa621bad97fde83884403626301625705d57884b0fd1441b4ba914c70bc0cfe015d5047a600e8f7e5089fb2c6de8a33d7cfeda063f27af4c176fb2aa4bf813a3e37d8f0cf4512cd2b289440298b3a229c2e1f917a39c44de63c5e1006a6b240d61bda40493fe6bb925f88932d677bae171e2153d893eb8e16cd26cff7a198ef54c8e91a9cfd37e047d32e9e47701dfa34b4492a1796d82d68781aff010e4f12c4072de061f3743b9965d0d936b1ea24261d83819db2879fb2704ca673ae92a8394e4cd725aadcedb0739ffb2da8ba6de5f44532e24f00ac2a8ad6efc9193693a1cb966b745595c89a02c8da265a0e660589f5805150b7cd91f2fc35908f566ffa182b06c7fcf1627f68c8109774df45bb84625bbb2218b3ae4e95084756e84b38add432df7cf5de26903f70a20d85d23df1ae953fe2068d982afce5fa9f78202aa31bc6425d0916955ec8a4f57cd2d19db70bc738db7f1de54946b34ecec03404b49b600e34dd8c91896e05a430d85d5b94d68ea6e7a99aeaa7787e8f922e88c57d1817156d6d764a975ad0a2c6f5b71f46ba23fea73d15143401c11c71b3ada3cd5c0bb23aadf51516c856440d64b080f1ac7001cef6b3c8e96683f3acaa2663404d5b4c8e8815f6aef30fad71b1f1e7cabf979b1c54271b2480637e4b643f1cc0a80aba7219a735cc8c506bad1249871f099744cbc2c7f08b00d818240bab4d047f920ccedb172c8d81e9766a4cc3aa0d5f965c9c39cbad2af93af3f9149436593b9117fb7782dafed784ff1b4f2549088b39f126234d999b8ad16a9baf051dd77f02b5c8ca8ff2c8caaa9fb25b20f13f42bc15b47635e7bc68b2dc4ccc08996ae74d375669cfa4917e77c7d6fb7b3ec6bd5a10b2122c7f17d83ce4bc0411f9230bb95332b6cd40bfba813f62463b8bf0015a44ff26f79838a206ece2d225b27dc7d4dbde28f4ec841f93a0712e5091a6b45228e356e4a5d74c450abc7174d28c61942884e4bce6e73edcd851a166585f550d0aa5dd6bb682f8d810597ab75179888d75db0ada45c0ca8cf543ee34d1c663001e79ce9bba8c85ea2750c51c34fffd567498123aed210f4e2e789c24c4b2d32c02e763768dd9732d9e8080c9868df442daded53e9fa7bfef6fbc878c1c4947e64755cf0449b7f05ca65fc2f0f55902b4219e77077f775555366d109c06c11b774e812c863d674775e4d1b2103776b9bde6fa900f2991280b16941a3ab9964e7d7daf3249d79fc0bcab9d63d82313c9b9717344450496ee8f2f1552204afb0f9a8cf5cffd5c7f5ac3674932917e74df1e815c1a51e0c0d8542829b4876e1b92033d0798bcf91b12ecf9032dc2e35d2543990853e845cefee70d791b18d8830531be2497c6c9c0a9a23f0f7f27df1ab3266cec5bb98e741d51aaf7951f7cd0f0875b229e38eec13e77d0296bc8d014974419677243717153c20ae53fd41eeb3cd5b61f98b72f33ed2bae5c98c6fc14a8be149c3e1bacf5aeb6de87d4da369b79631a6cf110cf417e4c878c0cce2e94a1de08ce9ff3499259b7487fe7a62b83f8977996893a33bb0f6d65bdac1f95378eda25e6c0bed88a35c15c72f21c8a7a9b17ac299cd178179ca94e4ee0aeaca36dea9c1f1fd14edef7264d9c14a612b52717b1ddba963fcba7591339fe419777a9e860274686b2bfc551549316cea4ccef03919d9e73546528b3d0adabb6c9cd46173aaf3dc14c1d313d6eff67516fd312aa90977275af4ef0275b0ee0448dbc4231900b2c355f0ea4cfca0d90bd2323f13cc855e0bcc8af743d570f93252e7cfbe772c5cab3e516538e460d7c7b820cd31f9457cd657233d79aea56324d4d49059812833ec412875fee6f7767589143d52c16b20db9750f4df6258086acffe94146fc7254b697e9cab11f53b8d9f3f7e8a206f5ade3e42f51b0e70dadb86f2077f0d6f180dc42f62fa6955414803ea689425bf5749b82eec8f1c2ad5d69387ee093552d61c1ea97380db8c0090cb7ef1957ea0fb14a3c1035d192bbe389ab3d7159d0fa07d4e10c049c3452a4d774e9f00af00164cc0716a2d7a56b6fc84e884d7709d55439135742722b27c12eb31037950a1cce1787e38b371510774cc15493fa3ae63a1f30bd9b828ed29c2e7e9712111dc5f2be83ca2bef07897ffdf4de220eeb3b301a841e22e4a51cb9288b6380e48742ccd7fad01921d561518e87525b9f25a5e296150fc0ba58b839548d7f9f679a3a7866ca64a07fc84ffe4dec20ab2932d8c6745bee1017c59a3ae7cb2e5c1f1d7f776f8a2cb8a2e3f0bbf347988a3b0d58614b51f5fd18edec486d4d875c25c467a4299f5402597aab64b38c074c236aac2ed6dc69bb603927d15f5e746bf24fec4dc47318d9b114c40a6b5f69a52dc3fd0330ed3413cf18f27632514cef0b1f42597157a9ea98f42c68b4504ac639af626f082dc5f535180090a3f262209fcebdc0a8d372a111dfa6a0a367cda29ed9140b1805c332cfaa06c1799cdda2ee64d0fec55301cb216ba477c4474338fdb157a4d21084b0b3eeefa2921553aed5580e7f2e517dd6a0814008b8a730e6de27ad4e9debf7d2bc762dad54ac743e1bc61c9bfeee474de5fc7f6b21b2f1a0d0c942bf949f888bb675e6b94fb777f1fa885de92e11d31b287e7d9f87bc22fc4608099d2755bf3bbc081c0df75b97f26c44053765bdc5731fd4b8bbbb7521b5eefcf7f3276c103ccbc2bca0830fc72434e21a6a1cb150bbb428547ec9b74f498d924d3442b2469a8f41ae95eb1b5f433468a511a8fe9d99f95f50cfebe662efffcfbf32599dc637c707cdcc2af9739b72d24f5904b41ebefbb6ab513d9a6901148ec7a2dc25c931e6674293f08839ae40797efbfaa67a011acd05fa339a0744ab233be02b1dbe0570eea299219527e81891680ff5cdaf805adcfc3a77e5ec79eef486cb3bfc59096458bb737fd83140a5a0fa7950a8557e730dab555a3198ed8f3312fc3980a08128b37c0e17d838468bcd1207b7a1ab17826badada51d862683113491a91f1519892d445ff02b711479c9adacde0409bf2f014bcc077c689e1a6198d06e97fa7aeb040926c3740ba020ccf6a19724c3bbb5e88871ec4c3b194b8616013780c6807da3da9fa2249b6e013aaa945b4ae6a55b3d6ac9f4b34e5084a2bdeb1e33d9dbafc9fec3079231744d532674d1b6ccf52faaf4b6bd4d6055440d805ed811b0b433dc3a4615c8caecf11ff0afcc2fae74ad8ef88007f7aa99007e2d4a744868a8958168b30cfc9137a3e4420926953fa77357404821ee99e85bbdd6e334785a0e33e3849f0899f9a870c65da97facbfc200919d0234734598a3264c5fc4e63129c2e7361f4c6cd116fa3c1e0e394c76b37173f2017036a9959ba1412a7ab34b612ae2dcf74aa96e3be094a1c1e7e363a14dafcc3297a280d196b6702c3386899db5ac8d588fffeb5d6e6e7715f5e8fb41a8925b7a0d3fb0a27ddc45cc8ed5df574dae98c69f892879b133925d6ec0039886137b231ce19746d4ec7bbe5e9a04874effe2492ba4fb8154a9a1099095a11431fe74dac41b0a7cd3c36344adf28179cc3b28506827c5ce709c5971700bf2d8bb81233660cbab564ea1216b33f9f2d84e51187940e7071266d09b77c2df4e7db43eafa26891e2099c9fec433ada9915003138b2a2401868ad29f06ef99d91edcf5be4c844f058b90b8bf5c9cba480ba7383bf6e5b8b48cd4efd20a301303417e77d082ca3b7896db82b9503d96335965918bb075a343b0a3d729bc96d7da0e0ec9edce45ff0b3b448b41df9270438251e6811452245edb7a87aee997616a4b227da0cc96bf73edb5f8a09e05a115dd431eaaffc2778417d5c07c2faab5349eb551779bb47c2d166f22edc2393098ffeffea4812a2421bd7ca6ee6dc65bd147f1a16ac7777f76774468df5c190b342d247dbaf402c79139cb74d0bec513e303ec928d6a45bb084d1c4e02911c5bdd5daddd73b9ec9b1653ec4c01e248a47567b5527c3c4ba62a24639eb5fb614261485ad6dc9350e23d7c14cd42ed9208088734d2d46031ab60e0a12b8dc6bc5a7c7352e793833c3d8f9b13f410fb8105a4bf74e585aebb9a91c0e3e14f4c89ea86ddacf219a493fff38835778867440d97076897004e1f10cb08028b19d72570b2e533f25901eb497910d203b5e596e83d265bee523ee80e1cf6b4a0b0acb0fced4141f23f35228e6ce1b4601e756d9f1dcccba7cbed5970dd1322343fdd3e8040cb9d028da37fa87c0232b3c80d13a1f4e762dcbad31b174e88f584c5b56f2bd3872fa61d1b02eff332a1eafc619642ff1817a465c71808266423ebbbc4b9714bd3cd807cb5178adb4ab087d95ef00183e996781d869734930ce5a4449f188bf98b55d33e74204978de1c0c2ed0cf1942e1e5c83ae830fce5cf7b5879b66b2debc48a03fb9b7ac71f91b157fd62e9ccb965f375c51e654fa2dd13da5f83392b99b144b85c83a90b3b6d8f06a165c888a353c94147b93e6d05cfcf29e495f178557ea24934db3403ff644580ba017a9ebc84c4065a87a09e0971d19fa58650d86dfc8fdd3f2b806cedd68fc09f158af77cc8258390c2adc448eb2b44f282cf872a3d6d4a2af685593026369cc0e15ab6dd454ffa25d2a948fa9097367ad537d49f24f94c9420d2815dc01e2c78b18b4c76eac86d8d1347c06facc0bf7bbbfd6b16fdf720a36139fa2bc1f127cb374e84f0d7bed6817b1ef29e42bb7e5f784de48cad4a409c56f1246c1c12700fef60c703b63c4c895011e50b76d3469894c8c13e8a322df899a663751eeaf3160d88ace3c4e311cf7acda41a990b026404bedf6b1e0307043c50d5728c1bb8ded25608183a338b987992ef3061397dbf17a45033e4bc6a9c0449b08f660329d84f4061e84c3980a26e65c0e35fb0df4975316a144b16372e499e5afa72d41fb6de53d4e0baee423d6e605ca59edcb16d3c507facb13080f95b0e7b1f3553328489ed47fa9645afc1f98ca9cb82e5303c59ec219b369ad769417579fb0c61b6cc8987d0e802378b2db34acbbf8e05f682f12ad94da70119e870cd2431176271a060601e8c346f918e881d709673988eae2c24cffd15277568f76f9f3f1ca49fa2667c5b235c6b879d574bc7d5e622cbe896683806bc1b94d09a5e1a6cca147355444253e38cd7e36ed4cca30b145f8c5865613f62a9f1c746ea5c3c2f413b05e223bd7fe0cff2f02efb20830fb32edbdfdd861bb7c9f5676069153722106a4178ca04aaefc9204fba72772733bae99cd876d90d1dfcf5163689cbc7879faa23b711aca49248c9482f986a8d76070d552ecfca752e2b3d692389041427c941c8bb6ccd436b4d8c01611cf3ab3fe978ca2c77d83101aec1cbc32a81b6333e601fae08e712970e2639c256329c77f3c77e303db2e346e15b1b5897feb553999a94c7266648f01c261aef989c3f7f1181e354d84f2a35a37a315481c2424be588dad17f83b74afbb3fe2cce45c6a094091c0213ddd74c96b43fdbaf547a809223f477d5c89370d1f5fbcbcd59956f05a62a7a4f060dd58efde9a4c27d503a6b5249db76b72965b8e071a2a535c62f3f8a92849180243c871f275b306572c24a7601b7d9b8e79371faa5e8c6ef36d524e73866565b55cbd6a25917c1fce990afa94d27d5cf0f41e39e8533b10404fc8330e0498f1dae2420434a41d5114a692e4a03f99bd2ac0ae88fbb3042967e196309298f3d9f683aba992bda3996415ca044b658a686cac6f986d10f6cd74595ab35118c0720858006b6d96bc0a8b8f91fd3498a9f505a1a325be4cf42332f30e6af9046f915b1823bf5445a33fd9c6df38fc4ac6e4fcd0c343e5d3bf1d5d00388bdf84d26c12d9c74461525f2d1f38098b82aa2ed5c0da5f6e580b93189aaba6fb28eb8f1c72366178f6dd2a7ba17eb5ffd9509fba13a6050cdf458cbdec7376a76daf41f232e3d7e4b1ebdabbe38069d13bab76ab2d9e3bd35f50f6222ba4cd4af53466141bfd87062f345d0e805324ec144d3ca2274b595c9fdb81764b233f82feac94c1241df7d03591c4697d47a0e58595a630c466b7a4830c2b30fe559066fadc472ed730e2e6b17c0c9778e932402c346797318ccb0f279f3f34732f1745af5cc44dcadf709a3f31dae5a457e2d36e749449eda67c1c0954459dd12072dbd8bb596b58593b00904ee47bc6b4bd9321e131c2d19d543af27bdbd2e17346a120ae46a55d0abc5da7176e5e9e0efa37a1a3275c3d5f772959a0de589ac9a54733393ad4ca7e5cc28781ddbf9ab6de945c9143f4d9d65ba79cff6b33a59c01e9b29e07b6ccb5c7fff7d8a6769f35c08692bed7ec6639727b612481f16e496808dbf5c969fa12d93e1288fdcef7db8641e345defb0920c069ceea1d9cd44b87fdcbb3e17fe61147f423bef7dd851d369367c3741ac6eccd8f2588e254f2a2fa0e24e681a1e32d8202fc9a41fabdd9d1be6e6da916efb278182fdab5ade97fc1ec9904ef25178e6f07e56fdac0028bb23eefa31a5033f0e73cf43011fabd211cb8647cc07cdc8b5cc87666e58714b1f355fe9f3ec5683ccdcb9e559e12e25f07d73c9da24c01154025ffb79d8c730adbcb4120932e25cbcbe85efe76ae72fcd2d54a39f289b2b84ffd8c57b77de245a6bc4afcd3e6edfe97ba298403d394000b16263df6f8b751556d863455c5aae1384fbf2f7c2cf211ef8091e56296153aa1131d02d920e0024b31b3f947ddc560a72dcb01db051932121a54ecfa1c7e4e39af5073f34deb7f4253d658410de04957ec638e7601fe13b296311d9369c8d7113123378123e1db6d767e942a99699a98db65c61bbfe3ecba16a158c09dc641ace4293231312f256e1f45b930f503fd4998bfcd43fc08925a7762282a8c633918a780768067644fd328a7edcc5679ef82b32627383a0f3ac84468","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
