<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81f2878ecb6fc2cc7bf7fbc0ed480abaac97e79e040336b5b81915efc448bba75638fc5528b1cba163b0b47506cade0a75d3cb83d3536767945ef70187936de293a3b68b12b43cd0a2db4baf8eb390a3ad52955488a3fbfcdaf0e413285ba9316eb5bb168818182bdd44913223ed060b23ac98dfa05909bafcea22750b8df8aae2ce2d0574c7f5caa66ea9f9cfc3ed71507198e06872c6ed21ad292eade1e3e0ed23b041c096c4810d9e4ec65e4758edf9e69dbf066ad6c4e04f4042bd13180d0b01ed5d6e9e26e537c40a95ced13ed060e5fe38a811106a2b1fa7a1be0e1543cb507d85320907f0064e1c82c2482799db347f92e3396d5b7785638c4b634813866e283d8f0c04c9b7ac5bd7f9cc7216a690c8440954a56eac8038c945fb0e45647f9c23f5e6576f6f352f0ede4656e6669e4b0faa530e05335cf475f37bea280c359d0e71cb8537741ac57d5b6c7197fd7a864b32bf7d4761332aeae9a1734056776232ffbce9b67cf2f5462497b84aee02fed93ec8fa822a3506eb74c72d4099d5193fd428110724195a376927edd137fa4391feaf563ad5f6756e4bf0c8bf3b104f84fff9744cb0b5fda20fa1f648663abc0174dfb75a1e5388d08d734e3f81faa8d72751444690309dc5ff6962d14ffbcf5dbad9183673a1ce7768c2c6143c52e26ded2da4f2a6281f9ee52a4d6ad040353495648af6659b4220b6c6b3d8609e60aa313bdae3d67629001319a9ed8c9e311e6899320d17515d8b8c23f6a43822f8b136403f6c8f9066fd410068a2782f3ef2abcade2e894f0563c95cc0b4c4195ead4a8035ae6619695ae2650e378311f8d34b6fe5e9b021dbf32e5c408e7f4770f87b880df6c63e0cf1fff475d8af93d12b2bd234bb9f87669c6f3b5e9833dba6463b4744c4e680efc963d2cdc2db78c2e1eff08869517003838a7b2ef5647b2b682b4a05ceeacf114896df367f0b09e82c7cb3ffef4f28dae1d01eb88885cd231d67c5280857f85ddb2aed2b0c73cc4dc355ef72f8441573982da39ad78e9e2e82276b457ac09c4430f015a8a26a240068d6fd4d795e3ae93d270fcb234a91b870b171ca6fe3341ee9534f4fd50ff573aafa52c48622a39394811a0665bc514bf37299e71d384f50540e6e8ada7725c2ece2059be7da5f70e09c80acbf2b5f8523c0ea1421f727ab6ee26671d3640fc4b2873a4910b3825eafd24d95494bd6b2b088e52d9a77d6bb21fd136a4d3c79845fa610dbffa6d46f7a694e050a21127626597d62766484d2086c9d006b8a852f3d4bdc9fddf03fbc33ec6f5201735bf9e4e48d159ffd1ed7822dad0e480fdef61d08827a1933a2d58848f1873ac147642d092aafc8f4eef09aa307955cc2bfdd34db9a0413713c3e59bc2d66bc664fa1c1de56b3463779fb74e94f2659e201fb3038f9b1c87a43ecd1d359bc8bdb961d088cd7d4b56091174711023e79c2ce77b28e11bec2924fa9dd939775f7cc5570b6b6b21a3c47d077b9c8cbec48e0f860d8eebb3a14316f025b42c1e0faf5681d3d6cfd0eb7966674c8684e1f1fc1469344d76241c4df482ce63c652d48d39e62596f217019be1072dfd56bdc4a90ca918740f333161586db270ac42892915897a718de7f2389e0034510f60be7e981158ce30e4327635592955623189f4aa5717482cac67f72cf2183a960da7e12f5e61011e7cfc3b2c306a99c98b7864f6e6d22c8f5dae4ffb955f3b1539ca4dcac05ac9f14ab07cdab44e060a27b1c30db6856ed00165f9f61756e63f7297e572a6787443bc08a130a64f8b5bb13a2e008c78a6a603bd93acedde64c56f402b4222590948bef9101432b2a5d5b9876a4f38958413235446b307411c30e22c65f7bf1ff6bc682333e055d461bde6c3ecca27c208ff036040269645baaf08f230dd02953203ec5ba11bfffbc820b4f1936feb43c66b3341590a0c18a1c451c65913c2bda36df6cfaf05f0f5f22c19aafb10576a0851e7652c446567a417ae7a48694ca5cb158d475b2d1dc1ea9f25f257c12882191520b8dd83505c9e6861950ec07b7240fb7eb5ef13a7034a802af9c5ebe129127a301b8a5a92076824c396ab863c54bad44eb8aaa89421b173c9c9ac3d7ff80f86ac8e3555b93e0ef3553e2265ec00f085cb2e0e2c3dac0b525f7ed6d458e6442c62fa60444498d2ff3600ad6aae47b54164677f511081a0c5c7582b2469975f8e5ca38d4d096b8546a9f910fe30d5512c1a102da2ac173fcb99e8870166c0f5ce0e8b9da3ff3a13b9749e769ff5e5204fa4143707cdbd44cd7053761b8c783625f45d0f3e11277fe988341b337cf68ef0e002c6754b52cedd228aedf87a7228a77f6aa3a43904eeacb38510f913eafdcad83683aca14f74357ce11604a48caae3b18cbbc968658cf01ba69573376df6fa148bc7360f02090241351a8411692832131aa0ab1cf790ff848b63a4ffcfcd52cf2e05fe70fccd4ef6e618d77dafdf6118275d55b1918da4d288538280602ad3b7a1623a915556a1ca6b6b16df704f9c162d415ef0784aeb56d4924683ee10ba0ae50817dbcfc15cf7ac53f9d9ccbb45dd80646309b11803c3e15fbc447b573b5f3592180c3dad8befd40c572c0517d8307c9f2cb830f98237eaad3ee96d703d4e25555d8f202b6b4ddeb4b6ef322c9071170f81cdfe7a037a37790e2e99d84352e1bb58f88948677c26dbb4e798a2a1e804704fbd2423f1ca71aaf65c3876fe81fada2d974f4c69fa9f4018c0d5238e111222a0de3123576b897bfb680d6968bf8bb9ab584965f62fd3051bb25218dc5c6340765c0de8ddc78d810dcda0fea042276e508a4afbc25cc85feb6ebbe6ee492a33835f8997226166967be104393cb69fe068137a95275550ab92a407f6175ff00d61f4dbbc8faf0fbcc2261f28cfb528882fd69fd1a950b88bcaae8242be992366f5ef8648a20dc20edbb07efb0e712b9cef8cd8a3757183bc1c6ba319c85d57ae0bee57b7fb9d22aea2c4fc5f34f3e9064778514eef9146f8bf3fb829cbdfebbfb9dce1ac6edc0eacdc29c1af4d522f3c54f2ab9e3380e1c508e012f97d2ce7915e9846e4713f0902aa380ad3079d6d7f875e31cacb94c07f8cb94f96e5932dee0e36ce25bd035de9dd90e0a3fbd8cfcb85287a2236c0e9cb80f1bead7d8810d901eb02c81b8a65e8a5cecfa3b1381e83140dda55403578015a1bc26dd989baab8c637e41d0340c3717220fe7eff022fcccc45752bb362267f490d9738d1ce5d027899b80ea96c0f4317f129b40ea7f615c5be530b57215100230c739dad63b4d14ffe9e0c2dba54d5e0c11c3f338c4a681643a6fe8e8a51b9427e16bfe66a0dbfc4d2de67834b57bbae1189650cb792e06993963920bfbb2143b652b47599fd9259c4b3987172351ec170a4c04a1334c36de46490250917493a4a1303dd2b8700117ad743902190330f526eaf9f36b485a852bd8085d0232a4743a035adac98db3fa8a7b5b72529a859a3d5f594d131cc6cd6a35b33bcd7c34558bd829418300afc35c2a841628017eba656dd08e2fa18b40b7fb7063b1399cd969c5e37ad99661d5133cc33c8e4a63cb4537913f3aefa923b984e54177e9257ec24d7440d02688d315ce806c0d04afaa39e3789e13e657ada157755f42e72bd0b606faeffecd80bbb3fe866abbd0137dced794fd968d2b331a432738827730681226d0859545423c3737f8807e3c9e28ee130b3551a26c5c4299ce611eb39fae119acc6d11a18085415a3700503c0b61792c84d228469a529a0c3c6c92356599d14c8305565953e52bf4f72f60addbb0817fc0c08c3e90243dcfd411e8d916b7ce8e63720f2a5b1f32dc70b040d38a9413f6a5d8d50c172d1fc54340620143441b9c0349a61f2c97a77487b6f52d23ba10c17a21747432deead51f1e7c9a1fead2710b4654084a0867c81d5a7acbdbffec13d1eb6ca76b05d315c712c0bf316d5a03f2af9615a4cabd0469ed16a3b0f85d1ab865ba984dafa60a231695921a10a3f468036101675b3761e64bf6dca81c513a0bfd2893feebaffa74261dce65f8f3854aeeeae6a8c71a85cf0fb629774783fd19f1464aa4eb0819930cd2c3a4d1639ff3404bed1a59cbc73d31119ae1b784f29f016005910909718fb5f457ad1d993786c77d439a5d6ff74945d7c950a40ad438ae631fdd3bb36229c88ccdfe0c73f683305e8a6c1335d2bd11ef70e6fbe5d514876cf8982d9324d99774616d7a95c34b282412e49719816078699214e706d21651fab3a47ecc94bdca668265db9e6e975bf27fefd76d126f1d426b9f702dc4cc7ca54a017181f69ccf2118fc7368e50542f076147711e258fb832788cc4383997925eabc6cd591e31858e32575c52d33ebc0993d1cbcc384878f178ddba192341408797d4e997dd0e30cefd5df372765e71e9f45c7741e215e243692f8cb89c54eb67c344147bcc4ae649fef07112b405aefdffcd7cde96624b5ed4097f99c0332a5ee118c8a0ce9ad87adeb5a184e0f579cd7a988b33ef2b3f8740a7fbe0bf44dcceca291f2192d47c5b011d2eecca67286bbee6144ddb5c77f78235d788a407deeb93b125a0f7b09e228e8d2d40f694c50813f5ca395ebf3ecff4507d5e1fca5fa81cb0215746820393fe1d37d460f5dee85d11fb643c6bca4eaf90578198db425da87268e7d6f2174bc4d8cee98a15674fa18b6c0c4a171a4e5ab62d4152f72da40bd0eda17a8e7c6d14e44a54143803e98b085f05fc134506a3ba1b1ca85770b97c3d48c867303023c88c953a35ad5aefd8c2bc48c278db9ef425e556fb4a27aa7b0090135984a9771bf9501be3738b11b173e883510697dd2905ac72d68a3e7fabd4649e4187212630e3b4404da24d92e32f927d99af72e6ccbcad21879f2610c84a74cd441caa73e654eccfacc4f14daffc3b89b3b850a06b9ae155869b00ac0cd000012731693d51eebd37b6e1f05a22837bd3cd8ae15f084976cbb488ebd281ff7ebd94581a5e7e25600fc42ab033656675c1cf57a45a1c9247ce2e87e8e277c6d679672dd6ae6fabca9259c0c043b8e20826bae5f50b9dfcf7256be8ed717fd570edc17d5034f0187d17bb8c13c8d3c54cfb4ac660541b79dac9cf3cf6693f0f963d1809023ffc9daf89e3d05b10c99d7d9a6967664e2213fbe196b401b89707214bae16307a953f06224b014ef3b2fc0bc71965ff10cb5c3160b86d434dcc291f7987deed5f0eb0779ce5eef916ddd93fa8232328c48837c5e8f08a12cbb2ab3e34fc2655bea3884b956827e5446517d4c92bd86a2dd8d375fd3cbc005ca776ec2f9f4ddc52982af0df1abb04b11e27b73ef3f3f52580be654aeb50d5e364c8425e3c244074ce7b95980cb4811cda31ce6db6b53989db1cc08d4be2d0f2641a862212b47ebac23ddbe955e634d944cbd05396686aa4a19ae47846cd21d78e319886ac58a686ea57a78a38844c247bd2fc2c6f0c9a6db1530d74a918f8cf40899da231a2da0e7df17adab67407401d190c29458698bf98a677288eefdec4186c27ab5cd2e373c650a3e71ba74bac0884011226df871cdbd57951e21d2851defed29e07c5c338baad7af1147e0d41212c98f2873c4b3d0cd25ea02988e2b80823df84912a5e023db8e865b1f45691e9859ec634dff8c37758ecaf6352b21e9e16ab31f7006b30d474d5f1fb6db552b4e2be33677f022e189cf8229130460ea64f1ec1486f8b9c6a69134b778ab53499977f4aa22d2c9689bbfa26bf15cc2f26b395d4ba21e177e4dd82d7252ffb54d1ac3eb4582beb52802694c7d1d187bdbca68a7c51c4e62711bd023cc206f543c07083deb0a587836a20270446aed0b1725355a4c485792c5dc1d7645ae0e673f3b70ed4b25af3c6ec08c7403abd601804cc061395f2f1e278a85bf65847a9d05f52fb8abdb3bed8e31b0b55c9c957923eaa58b2bc80e1b5a3738210c70bc41c99cff23ce4a240e56806471ff9b44d63f715a5c664e7834b657014016aa214be67dff437aba51b040e3f3df3fdb9338fe271465d30fd9a4b1e31b2af83da99ea5a0e315bcfce4c47f6757fe479de84db5718ec5134aab383d402c80ea6b1cab2f45d98b709c5f631c3fdd7e1ceddb49de33b6725e11ea23e68feeb3243cbc58903cb44593eb02ac1a821b646625e9c71555c9ce3b54a7d9968bd1c3c4d2e9048ccd920371f40d5cc2c13cda498236a4f20b28e3e7aa137d096255775f9679e693f816043a7d74bf69aba0415db479c234d4c41cf084f73493a6cd71326e2f5ca4dcf641ef9be322524b01f389cafe5460a486e5e5b06310dd032a050ccff4e1d3485d2472921fffe9e0d8ef797570dd94782c5dd248209d5ccbcb30a3c5c44f51acafd80da19f3167e35ffba71aa680e31ab76e4e7a90fbb6d8b95ee07d008aa1c8f6b4ba20eab2fdd851ecdefb64706c423f8be98d559143d5a52cf6f01f1de3903ed9619cda5dac0d096ae8bffbdd3e99595ea7cb14173c41f8e6739cc93224d14695f66774f95c8fc1261884f5eb1dc8e5bbfd3ad5f24cd5c1b6de770ca05d5464fdb457482dbdc1c1b66604c2ff088fec744fc3cd2093d4fd838b425e868857976376befed584b51b4a8473540871c0bc4c457dfe63acd9a3adb348ca68146dafbbfcea2ad27ce21233a564e9c18efecf820d9cddace97f12f4dc263679cd4955c09902f3c1b171d831f9d4be3fe51f146a187121b31857f5b5fa84e290a8e9339d78e94555f82af8694295ed8152ddfc43927c8e77146fdb7d35e7552748a42cdca4395dc1093b99ffef83265ab1e53dead3da46060fce1a8c27906bba8c45f158bb24c353d47cd119921ebdb1c38767d95d66f91e2cd041bf2ab356f359083a66af574979e76252fb6f2ca9c1b8ddea4df87f09261c6c91e82ee4f4418ed7f1e568ca7504163ef9d80981e88f04babee72631fac54f9187a996e05edae2b072976f2aba6a0a2e6aaf5c2b743f613017b5ddbd1f3f19f61e093c35aafac61cd0b2e1e61e3933ff5c2f94a4bf402083bf0529e4c6d10b53f36a8fd1207198dbc61cc600b433ffccc4fce59ddc182b70b1a471fdff62e8093e72ff60fb4ac358a62932868ee31ce898b1341ea2eaa24cd97dca851b65239170714163e84a135dd02b69d7d4da69d830793907aecca7882bbf302a8572b7df2e41b10a4e949b3147c0b23c7676c864f6a3bfe2729aa72bdc9e934f2829695c493e2c0266009891e891b926951b8a372203b5a407253716e271f57f557f9481785e53a32091679335d8c0aa62c0ae679188c86e9ca44e1280a4a4db1828f0844441f6803acea8cf56f8c6092cfb567d253516b4e6c7d62d4229cb56a1442e80ffd5c1c00cf60d5fe7809e24948603d4f6fa25139bf218a97f8e138298ca2571b2f79bf54b3b8db4723fb7030b9f8961224c52bd1e7919c06e9960f69851784d77e11d6c5820e0d949400e50c0a14483a9758fa6bb8023ecea7c24f6e6ecc6fc8df63eb017a99e63ad9393bac2fc18b22ba75003f4842566b2cd7ffa3a11654046cb9f9ddd3d9fc002eb1034d93961ec23e1943d7096ecf4c2b2e52924583f150ac81bfee02dae33d89b9eb54208499702733de977cf09cbda783aa8bf9f41575609e97a93e5189a5bdf9e5246ae7090844bb75702c50e1d362079609e27d16a20232d9f3a5f9a934650a242b401260473166c69f741758cfc9eeb4435bdc49cc7887d53514e025ae2fadc3933f2e31262557a0476d28e26152566f6c6a176be7edb685c98d245ae59d43de5cc152da62238489bba7367bdc413c5b67bb21d86b840ece052612b0416b12120c219afb04a91fb6ba31e2210ae3fdc69a2d7ff5f1960cb85203b668ee6f53867fe752a553765478772cfc6e13e8907c9800e6fd995bc8a10338bc943798a0068d14737bc859791e553e11089c7d067f22558cdd677199ee3255d91de3a57ed67a392bd71d7b8d08b49f73a771a9e137b514f734782ca1cf4940e0c4a995f5a0efd249230caf2c977038550082b4d5eb7b34b2bb2d67bc2064e65de0793c066234854672edb4e1abe08d22284177d02fce14be1d3952107125ae113b55b86d045d1f983d7a9290736ad593636a1531005c5438ec4e85c54ddc2e534bdcd7b436dfb2835dbc6a081b74fef5ecbedde268d0d6647d26d9dfa1d2874b22dc46bbe5dc85ed8f481434555484f474aea499e4793f8760764c49a42ac1164a1b272dce98bf5be9dcdefc26812196b8fba79c38e776e160ae48fdfd8780cac71f39f50af4a347df4dc4e32ba367b3a116d4ec812a6a526ed9c4e967f9ed56218159d8463d75dede1a1e50bc27c04fb7c3eeedcf0005eb7275f9714a2a47a65159e4652da177d6a86a6341ce1b90a034adb3eada2302066c96380a3a6d23ada8a6c6decbe7ee92985403f06c0995654ba621d78d135daf6554242854b90aecaf1edb07ea929639be3f6d74741a93ffa49f08131964ec3fa8ac40eff7cb106e46b706ca8505c90dd815f9636db1b00ff3b10bf1e4048a6514be111eabb3afe5ab17a08f52992249540a75d78238ebbf4829c3d8280cc8448c8625c02606ffb770206d22d94077613fe638638a22dc75c8c245c75caf739aebd1e5cdb8210ef20c21ac5b609027a047c57684cd4e1eb956cc75200c9f4d89e82498bc30422165734f7e5c777dc55e4e416b9209bf8a873a7257186f90fcb46daf2a435ffeca1e5e2c4d61e4dde30b5e784309c952039dd6147b252d0aa77abe10e705cfbda53a53844ae5661efe19967038e7a5540e40f4de6388e85a4aa6f1b07f29d2a39c7c090ed3e0874899ccbf8726eb1b97bc84bb067dd20f0053b9d45b09ac86aef7b8f7e2485fec9d6c3ab1fb3b6e9fd3a18967ab854f9fbab068fb00e5c70d67c6903e1a5db1df448322ea5759f41e88414b227290e94f02beb1c50c3e23b7a748205f0386cb8f5f3474bcbc3c9541588d6a2d4fc41168b10e908982a3ac62f7c3b7dcff44af2ad92f820a87a7ce94f627bc2fbc0b4e712837fc872aba22a3abec3aafe7dd7e7e1e2b5db9b96bee3cd16eaa843db92ffef5548f8255ad386f9619f3fbf3a0aa96d52af5096b06f748d1edfb80bc185e92515adc8ba2f8c767fd8f3cc355e5dd9b06d9c4cf1f7f125432a4de346b0e7ef23e62a7f4950dd364ce5ff9d124ab343f317da9e0d4fdd348c2001cf1d0a535f4f6e38906fda3aa4a0c44746fabc29c21be7979bb1e37fe25e9379e5bf62f05993807092ff6867a2be7227c16bfbb3ac849acce00c43c7e6eb89838c29bf8d796c619f7da314509f59156209a3d51d58727cee6de71b22a71eaba015cb549f206ff6ea33964dffeb2c2d15acb8016f6586a004aad3b41f2396aa391c52a5a53c9a4975e53e1878202f39702cb93a351f9d45cffc055d3d0f4901de97271370d1d71d2b112d912ee0cc103b4c95fe150040fd20693565b811b5188303677b9a95d139822fcc197bd10db33e55f82d1715d97a3e59d8e8b8d6307f4ba1434580782f86d9aa53ddd93c6631313b986695c91e72d2ffac4f05c7d15bf5a4728500ce371f1566be4e1856199e4cd8bf860bccd8aaec4ffe4b07f8b02551b04dc504626c88e45ca3263ac699674ccfd8e5c95748611118acd4dae07805d52d7c7c67a1361bc056fe1f1be3bbf0f040fda03e90424faf7b76baab0939d612e9aaee4527ac5e3f00beec7a8cd734a04ad516e50adb7e5c40f49f75a94f747947d10d8bb62e9675321511382351bed7de11a1245899c76b1f5f69230c5840cd3b31864511037dcc13916ae5fdd6c083882528567113b48f14726491e2b30978a17c31f2cb4ccf69311027c0dbb59429ef524a56f714506285f7b84c96748ea8c7f33d0b5c2a41b88d4523af3bd87c86690c766a9e38b8ad9bdf21d96c2eee2755a3d99b9987aa52d6ea64a01bb03266bf81648a70a25d4fc4c11a839943e29ead1c4b4b064d0f7a4b09c288dff42e32f7125ececb0dd2f3f529801f9f1489d49702bbfca90e0a18febcc5c79e11c229b39ea8826cb7ad9398ac4278f35162811e0818726668f69070108c4b5ade3cbe59624126d06d413655bb82f588ba030f662a7e6add08eee7d304b11c389972dd53e69d16cd54523a4ff454f0171ff917b5392b4bdb69353076d86ae9db31ea620d4b756473ab5001e0a7e1954a064b1d2b54ea735684cc3898e369be9dc9d398df6f716d224f46af9f187cd69fbf31a1636874690edd3a38631f37b076d8497cdba8584caa06437b7d0cbc9bb2e52a26c3909030605f0adb60405ad65e01e278738c954b81a0fb55832a53570b9b4dac5691ebfaba4b64f21f13722553b376fc69623c5b15c4ae55b654eb4093aefb864373500e7cd81670aa8f161c15afcd55cfb576e6da203f10a5c13e7a5958d190970998203d83c288981e103bc6719ec7e050becab0b0702ed297eeda31a091aea9a001fa1ca51b70533ba2ca22694b2e3c9749cb3e377bbb0687361f0aa75c0833ad37bf949288569af04f5d1576f1f18c2ba34f122d7ddb644b54b2a6cbf63880b0bb7f035f4d1a1325452aa5e4294fd35e03780c1d159c162084f20af61160c92b3a73402c1aa14fbdc3b6e7f9583284b52764301bc54a32b5813df4b2946e056008151e738657c74530203793d6c71b741edadbfe62e475d4e33363df5ef78b9eeb0f6de8f640a76903f4cfdf68344a6a0350fead73c00d7c4ed628805dd44e14d5a531d38d88245c1351d2821a20917fd4f120386e5c6ff9c3e2561ad4d39531607c7a4d83ace82b97d6e9444af0cea87a11339d8a9cab93097764ca9f50ec6fe848cc6e8b34c51c38596cb3e7c5001128239bdccb89c7a9bae048c85b5a393b70bf90697c4543e786d2921aac9f25f738d7f287b1b20cc4122f56c12792bf48aa96f818cba193aaad5c7f32c6d00706d726e7461b1465e852281e42c9ed0a9ee91f869cbb0c18b0fe0813c10f8fca2b81e58d0b19c62c75769b83ab76e3fe66b44a32a8079536ad354d7c9443982b64d5dcbd2c4bffe103d5e5e2af8e3af7c84fdc02ded3c7dda79bd7538c270a396762d4493fe96142f66dc0314702dab5efa18835f742489178daa4f0f1f036be68eb7f25cb4007731c8c86f9572dcb8e5084741faee82f2675e337e54ba66c7be5264ff67e1f60994a76487232edc23ec1fb7bbf38a9b1da05f7a5cf868b77d165acfc37b68c8aa017d6640f1a92a76cfe203d90c1a45f62f96aa1641f620c2b14c9881f54543e90a1d9d3268e0ccf783343ba69e43fca489f203cdb2f4086b731960f3b4f46eca05e27cc4774e74584921e98d05b7086482149eae68325413509b3eed1bb11800d3e127625a4a05502a03d03d3281830eca994269c90704860b221ff3b30fcfef13c7111afad0354a4d0b75cb4a37038c1ee710e1d18773f7ceca513b82839c6d700df0dae81ece87f11aefd3277520cdba9691a89fb1866fdc8703c97668d6d03407638d70e1935904d43df5298841eff6148b31bfacea534c7076bdc35234bb0512ff5613f25466ae305c29f5c437a213f6067923359202fb92e3d8dfdd2efa4d56ac444706be8769b9f9972745042059562827056d450a689c0276ce642cc4a9f03b1bd5c931c1538ee7da3b4fd9b655323901afb82e1e3b74ab9b364b4b0a82582bf228543c5c1b8e682c872309d887cc7339807edd99f12251eaf82fe9f0ad4ec857acd23b2f65a04fc8c7960e578c5ce7709af40f9bf7c195fa56b0d68e4a8058ad64d912d02a1b13b1d87db66f1b4fc7b719756ef809334fe15ebb0ec6a090063463e0cfb9d0f932d621a7796561bbcd3b452c119a8b6c335c1d4b0ad8d8d29d8eccb701b47307cd3cc8eee4c1b69c33baa531fb3f7cade1e36584d814a3a4d3f8440a03ba081323a1a39ff29bfe55e87ac32e7b052cacad513f60210490fb0a2a230674330e0a2795b0175219316c69536da5ca5adc7a16a8b4a095399fd8fc99ba89cd5ed05948841a2322ebfb015fc35daf7c6cdf2e53e1022b8c84c09853f767702cdf2a3924824a933b93b6119d52233cff6144f6461c536215ef29546aee540c232f0b2b061473564efef933128b1789dd46a9d3c623bceb34b8facdf7850b9c5bc092dbdb508c5a76f1d3dfdaa2e36a2ef03bc511bb33145383eb4ab3b60aedce4829cb93161854df888c7dfb3600c43181cc62450f0023549601bb5461c0622181fa0957419dcf26c4da5f055daac9ccef239af62528327bbf86f40d319077ce446bd4607a56d92cc630982bae963994c6b9d87b72bf669545bc7ea954565e513689e5025cf755ff576e1c9ae92b1041b51810554e310f0dd0bd66d96a92ee01273dcc2de6b1d6a7041be06f099df305251ca9e04434cc81b1812ca12d336d37e441420a7258584045c6a862c6283de322911e0984c510b0dee3446d381839cc67a36c180541f543844ccb88921d1c3b524862f5c4a7e7283a33485fb5689c3ce9a18c18e48af26140fe7c8686fa6bdb462f5654a7e93c96e7e30cc23a7023c7dc9f24cddfdceea9f03870fa673e3e1c1de45b16d37d64c9e808ca9ef79d127773e36d3518892724f527040afabfe8c2f4bfb7a78bc43916a087b671d19e6e91c62b8350fb00f181338b90b6057932312616f56673523f04724d6c08d867d578c3c2c01fa5a71a3d89adff075a9b3ced4fed2474c9a82c1686368013d78c29eaf5287bc79d5fba119bc33542e0338f1652747151fb79589d91a70c4a17f61443cc0817f02c10b3800931d1b52fcebf6a8ffaee5f2d8027446ce47d8840452302aa0839d87d1d178c0d684c0fbb6d55cf9fe69a227ec10e12259990419ede14d7f55bd64ff51c0cbc3cb784d11109afd93d05df707e6eab979f650d3bcfad0876c8509cc6243d7ecdf2a95ca9e03251e7337bbf69abbb9131cbf0ad39d1c523caacbc4243135e051025300565762ffaa162ea525e31bc3f79254524941ecf38c6758572b83404189bd0fe3a2545b9e71c5131191ef6422f5961eb4bb66068a3845731eefcf8fdeed83758f1af5f30ad7d5008f4defe976d6f5600ef66ab39bee5498509527531e5dca7fc683d209c3354353287bf837569f9678f9a519f01b80cdaf452196f105a1918516a300cdd8ca8e4000fc57d79adef02b40143bf3be6fca40e4d0b1662b99b0e129ba3e0d5f578e0fb6903c250abb202a09f43cf2df4c77e6e30b7b13af5921208beb698384f03e1f2982ddcc401c40a3b725bfd5133c77370972f2cab098b8a984c098d2deda44405e97c7ab4b900ce50ca9f762fe35ef05837dd78612a624863620223dd3393bd81137e6d075260278d6247592982c87942e6ee2b7883b9e8784c6bbfdd98eb2b97bb991acfa8e2fe611ae46db7953fedfbe617d0d7ef8311052b7fe9c4ab05005884e27fd511fcb4b2d44dce09f93f50d9c9e546aa8803408f05f2b992cb963f0a1a24ffa3f0bfcb31a09e13e8a95388d9370aaf170a112f62a356515f38d2baade932d47ee213e5fad28c7368f949f31ac1026d08fc35a7758540a50331d9633b738fb20991dd94b48af5cb6a032ca8bf24045b76f07f986528f5972e04e0db7981e069f50bc6f26d630f64d81d65c2d044d40df954fdbe0fe168e0c1aba77527e693dc506a01bc94a753e963a8dc77676adcdc7c7ef13f4a7087baade04d46576dd1db8a7e9c88b4cd40974ec9bb716ea0ada1440c409100c1c39ea31de605a94f477a4983791b6340ac14e151cd64414b47882c5103bedecc2942ca1e97cf9a30cbe54ca6c01e758485c28cc3e7ac0e701b727553cb1023acbd2412419dbaa306f968ae4fe4414d8d921686bd188d4d775f3c1102d3eef5666ef5bf09593f087551b2cf863166887572e26da2ae912c8a8eda2ae8ba31f8e54cd938c3a9c1de0d39cfd8208264d5810984e708e1541f20529d13cacf96a960212ed32000229e1727d81e817d459221352a72e33657431a21f2a1551b4f5f1b14f2539f36479a95dbd1959032632544ac3067cbc97a9a707ee0fbd7e2de91c912413d070eeca1a7cd3b265097937eade9f99a794de36c5fa2658eec0f243c488bcabd23ad063a61d46e3cf2c60c0074c47b4d2d7887809063b143295d23cbe5f7e00f03e42677850ff31530bec5d2b106154c49816d4398c75ecef3e1b92d251b80398a83adf020c41bb68dc56f4661652bc27a4f8960185a290d0dc821684999a9882f88193ad31392a10f664c9213912ffa336fa31c0597f386530c0bfcd42bb7e1b2a1bc596d096e54b30dc9cd6748e879a7b2dbf5aa4e69c78961faa78af9356dceda2c7e638a9022dc18b1964f0b57768f3f03e5388f743268fff8ffde6f72a38c3fe64c1f14a8a29b2e1dc3b8664ad17d3077a9fe4e6ed41a3c6fb2163754567b40edf5b9a556746627640480ea5f29a5fddfe3ca128c50226fef9820690412ed6cf8fca0f276b4657895da529336c13fb3b8093a557509074df2324f89e28a1babb8ae543dd09d2578afc6c2d80aeaa7bc1dd32736369ed536339494dee8df911ab84f664ba95fe5a9246d0f2fe5864a36fd5087e41b0020025f2eafc85ffb811a11dd2b9a5d251edb3b3ea792592e3d61bad02b40faab1b52284e17cd5932b772d247edec7dcb0e48af601bd5e294237b163b7a291b2ede0f584de4b68c77119799635e095d7bf0565063ab28fdf7520757355187a5677f4762e36d997f17bd4e8d8b60c934b12c7c0099c410409ccc39f364e65e64276773c4b19faa18e397bbe7fc6bee185b338fad9cd11207422c51efccaca746f24c63a2257d61b6ce95b002477c4b4a24ada3b3cb635a1f5377fd0bc320585db8897f1125611cad78c8536028694c1f00d3bf47600c57bd021ff2e935547dd0c443f29448c9a87f4fbca4cc5dd8636c905f5f82be24aeb5ae284ba027adfb0e10cb0bcf6f55bd86dd1c6bd723a2142643604687b85cf15fd70db15c1284b08e33fc52cc47ecb83682d64d9851948249afb5f82ad6005f1b5c4ae904f6a35fd961acfca339f807de45493c95b0ce12a0a03d294ccad3d4774a35f02b6686bf4992619aa1453ce26d85c572bb791c73588d5001dce48e0fdf70168966000cb0260013cad205d6b5820faf41aaea8d2264a01715fb2b337a9d26c795b14c087dbeac169aec67d8b9479a808775cf7c2a2fda3e88c4741227c208555fd7de998d56c1e7233237aba1644b5ece368f37d5bad620fbc8cbe981e24a6934e2a53d4a02edda446c446c28be166c173a1ac0d64b9a4b50526b430808ff50cd4496564727aa8c74d2d6554e0f40179a5377ba3d762100982f75a560add407a5488f68a0299ccedc9ad56528b68a44de6a061d60a85c00179673de2c3990c45cb53dcb256d9dc825883480f02e1bb86f77c2aca2223f6fd4790f5f95b422e7ce76cab1f0812c63cd3320b2e8cc92ecd8a3ed105ccd9837697172e3f417d7ffcd984f23c2b829f722186c7bfa13f5e46697a8598ca6d8e26add33b9c7affe1dbbd950a078db2ad74edc20bda743c8cfb14d4561b163a3bcf2b7e499bed301fbfda739fa510c33c85209560f0308bf5d79843c3deda6f3fda59a440e1e852d474060392d96f47cdbdc1169e02963c3885d1245baf96e119050770c2b025eba140fb5b2e7fa16a300f3d723c1aa2363bd3be69fd462453639099abe5981a1456d46434aecf580d0a128ed8ebe3e0e9d1f70e8ad0ab27ed5a6783fc70650318f3eba9d1bca18b470b385dba92749b47213a7993c54cae37ab7fda4bbc55d8d703501e1d2dc9759e80931f49de337fb3c90067eb9c06596444a9bdf28b4586e03ad23a6604083cb50c19734c165920112ed15fe2cd00323c48ebaba62dd7f9028bb51733855e32e83f86c3a7a635f8ec403eabc5fd5c45383fa1d39bc02326e3fa52337cb0a2f22b72e5fdc1fa199ef8733b2e64a8d1fb5cf5202e91f51e72a26fffcecb2187897db04e3d3e4d2e52a6357573b035ba73aba49817e0d321f3b7b3efb5d9b1a569ae847813b49e095a62a24344c8c55cc14550e69e98b352f32eef140d8776d08a3f3a77d8a37389409901ed4029a291fc90e8160310fad793d51b14d8261be2ae906014f550808f0c5d9615dbbfd23a7176490347b3e92aa955602d0fd5b5edc62ff32073ce3f966bb220dc2ac03a7d4c5a18c9c0187e2c95859e0a2ed2f3194c70b428f3ccb1b9b6dc4f1dcff81f275762c8c04631f7dd5c557c21935936afb3a439ae000904bc1e9de518802c87eaf41f496d4894e225b04166c434346a09876e18647922e3abdf0d0dc7a881ebaccccfc10363ad186f16ddb93cbc9eb911163feb48cf90ce347ada23c9cc40b21d4661a270f9cdc6c1ed70cb250b2c16e5b373665a8c3444cf0a79e3d6f39fa47ce18da2b08eecf0464b41901afeda67dbae185fe34b7d660a645a6aa29faf35fbe34c4c3d47468f0d7b347f869e1d7b10b9a5119fce36ecde2f792c96765acb28205afd0b7646a97260f6dba058abbb15664083d85effc614253052719c8bffd664f1be4723d062ca4fa787e3560ef5df7f7fd0b9acd379667a239192ca72f7618bbc0931de7b78c8ab9e06ec571895e9e3f43fd6abf60665fe262c700946e57ea79d75ea4daea9c019171779ea20fc0c571d6a3cfcc3d9e1e8e6cfe3bcc0eb01d765a3f8c6cf039da6dd92cb3d0bdbfadbfe89b1e74e575b197101e8579991b376cedab355fba51d9484432c8bb6444e6f48256787194b8706e7a12f2c150877477e36d6fbe92a4a4a6fa62999f9fbc9683bbbcf26ab93ad515f73163860c64a0f4d2d95af5be431f4b77d38a6e83c3c2dde3d30d0328e7b5e07978c2748b89fb18386795601311843353cc50b6da9e890b35be63a31b861c64d003bd730fcb80773c9e70046949dbe029bc60d35345992f2bb6bd66d793551ffe1b0420c04e04287e668cbd5b6d716ac2f2e245539f6d64f9937cbd46d9ad8231648b83485bfb1fff0afb28f26529eeb42921783e62245c0ea65964afc6954635053a862c65e10a32667d30c8629cf2d79deadb9ed0047836efb170e46fb00effd9dccc9b28231b52d4398985ac90c3c54dbe158104b0319a091d7629079a38c0c5fdfc6a0be96359567bc51b9fa00cf65fcc2792a6e871d9e55d6abcb83418cb40df572b8354d51d537993dbfd2739aae4b8555749b35fd29bf71b6959e08cec012c5052d22fade5a680fa8bc305448d92255b1696c993b85e84721eab6c9f56e86a5d4c80238796bc143b8a008b42895a5b1dbabc9ca22648b644f94fa5741da66d20328fdbaf514ba7c1f06cc4a9094f25d734620b2ff43e13a649f53eff0816a73ee1541c435358033e112a34de1c2f7f328d810322132837e5368c8bafbdbb39bf0ec34c0e0b6c08f029d938ebfbf85165f13cfe667d8d4856978d57b93caae931af4f1255f2199819ae0a1b28310ffa55a9fe979933db0d4c62b6c5091bd3e6fa5ec8af724bdc8f184dce85a1389eb737dc39d75ec377269341b8a85d38432264a6c9ed7c707f297dfc24ee8a6a5680479a9855191d411a23b1175083342d3e35b77e5fde5c90b7b675b7cd0f136864dcdcf849e9d2e0fd7a44d9019767377869d7ae62d5de3d2b2e95323b0d3fb3a1b55093228c48a8c46d5cac81a1db89ebc455aecee7e66514bd13649a7d043d95579b0dcab6f13bed0f0a67887b1d4a390a34146e5b605a8d2f0b55730e9064832adbd718de17b4b5bddf1626ba027f7df03f52dc99f917db3f3f70bb7cd650f9813d30bed4bda2c12102092101fb176f2559a2d8dc8c93ce72074c231e87fc8259e58d2e637602de55d41a058c4bd0cb0b3472140fffc84e8ca1e0b6d0253069370628a1a30c604e59d683ac5bbbb8a93817b5b6f62e561fea476c718c952b6791de3b3a1dd68ecb68b02e9256496bc4d469544cf2781452548eb6ed254383f09775d1962f8b91b6bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
