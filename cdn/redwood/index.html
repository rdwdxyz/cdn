<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de4e043ec25009aced3c6617509d7c6447577e6203007e8dfb9fc4ec204ffdbd53b3dc8a39ed69e5c254f7881c5bbf5aeae8cb15be509de217cf8e7455615666b758672e43ee3720e0e9d2b952bf60096467b7515c6f8ce38fed4ec6011bad0e5ce6bb8709d6de0f9fe48f7efbd7199e2177694cd5d85f6f594a8bc60e3a070fe7ab7ec9063897a69671edea41aef6aafdbd0d6c1357298561d79bb80cc3185cfa9a611a15fa4f4c0dae6041f082dc867197839b63354f90944760d98ccdb10990694e2fee5daf5e12cb93d9d86a5c3c6fe3351e97a914f52dbbf935b75e07a8a0eca33ca65665993af4a46c55262822e9be2addef608bd45c7400476872dc45b3ecb7b25b28a0d0ce3528319c539802558861b6c2b1c49cdcd7075572dac2827f1a10379bcfd8af793b8caafebfc51a43483a6f95438f1ac2dc3a6809259339b8965f15eb42a966089e3ebf03299ce3c7385ff46a00a70fcc2526035304e8c5e66b858a7f48b868b807017f76c1e661e32466e586b01e3f5a67fae8e793df60fa1ad6f73983da49aebbd2b943751edff4d468f0f715bd64fb973d30ed3b9c0904c5807de3b496011ee83283a29c7d72681d54b168da3f7e9fe3b5a807b8cd3a94d4773093b7ec1d3699a6e311baa79906a90d02e948bf2d006d72cd76198dd759c974b32a96ceb8665409d53284c971899af842e5907f0aaeb3f2a932cd2263ac288b42bb6d46ac9df68dd5327f8777f9e1d50701f0ca8e0ea6b170f925c356f85cfefce7aa112ce5a95ddc5f9e15903d24953fbb9126ec0b66ff478a649f825589af46d3e89ca00d8f99229055d350a8fd21dd3de1e641693ee4f4095232e722716a06020a923213d09c875a1c9cb16af373c12cf9ca98bf38dd0e986b925eb596ba755bbecb28f2226e39bed3d00352d45c25a8bd6103dffcfb671742f93b1d817c9cf6618fb674bf287c019d215d09d9d09b48ada150f25d4d5af5702d624e2e77f6775f32ed812053f491cbfb8c9ed60a965bdb7cad69aebbea7de26265efe08891c97c68038d610069bee88e2de6a8ce638418e35b7051ba4cdb3efcc3dab8aa1b8579aa647b322c5c04dfd5a4d63df803dcecc2c5a6fc6664e0ba563a0e5287b7024cf56f568fea0e52b1f59b1e738f485ee56082783855a954f799a0417b37917c08b9273c2952c187b1e246edc54ec531d4ce124bf1ca4eae71bf5dd79abde835d3824f3bc2460128ce45fae9f63f7b48552dd8ceda26291314d1debf50a7c7e6523ffdb82ede6baa17e3f3f1aed64f39f3c1801ebd8f38174113c479e1e5af7a8f2e95e7b34c30741bf358a757096b0dbc5b5afcc037061931537b9f7e37605ed877a872bc232c8d1d9acbdb823cfc04899d343c275940a282e5c1b3da32483a2ad27f007a850631b994bfc07b5b2f353a48c3bff2e2c22ab35a7beeb589247709832180e21c060877d195e3ba976472bbf95959c8ab286838c4fcbf52df6b8b9f8c9c87744df322751d79bbbe2de75720ff149bb294625f6edc293329f88c9625277e7fcae97b2a0e0165ed0a8506401d7148c2eede44da30bdcbc7c5cab898cbd1112eff684c5ec5d3c86ebf8ab53f065a83addc3c6676c01c3ca7213b49b62dd041d66d2305bdc1bbe95e204f844180fd50651116d2c1ac896b12ab1f823adb2b3b507469b7d43616af1810a46d1d921a30017cc2174953ce08b35c44b91df700e59552afa31c53e54b3c78168bd23104bdc5bb99aff06f9bc3c20179807c27a0baf12d0b24af638ec4165f931a483be34a658ef4208872646989e0ac838513e62eb15c3cf80bfbc6a60246b8c525bced87acb3c2aa33f41dd8f3f4926dcb979e6a5d9c6bf10be64095c464ecf8d9d765f192ec9712ad157748cd0fcefe0399098dc312411a39eebb32a03aa9161493c0cf5abbdbc24b8cf3e2564f3737ef5c51aba41a5b767a11e5717c5a935370879623d234d6886ea26bbae432fbd97bdb240daa6439bf79164a9a9197338ca5d5f62381a372ec7d9dc3608620ff327ea86780d37f4af4a4b6db142d974fa455a202f47fb3d7281e571f72a9b530d6962ad21969df7c0774be486c7954408ef027239a3b0ea431f6f92e3e0113a45b3ac27aabcfc77702516c4439cf2967f2382e497623cd47e0408e990f33969256d60ae3f800defd0dfde3aee2a9d423cd8b41c99a74d94680daa015beaae5c2a5e5dd2b608210641a7ef4ec381198ffe1781719846d4f644f51ad8abb3c7032ede75498413c83b38742e278c2717dccc11488d8df9e135e9de8d64b8f542985b4dba1dcbbbe388eb89240580d7121accfe17525976467deb2ed86d411dbbd0d97441d10142be5598ad337751764795b20a4bb76207bfe2a4a33cf4d38d27dc40b33a16dff592bb6a7b80403c0c54c9eedb7e8c94792e117aad6ecf339057eda4bfb46ae1e03ff0509cd704ef8f993d582f5a62ac42db065dc7a905694d18a1ccf424a66c588d7dede02c1c1c72801a39b7ac25c20322aebf41dd4a1759c93ebcc6017874755a08b47882b8288c757bf9278592f4ebcdb3e07fbddacdf3c8d7857c6f3313435fa033a0832cf931d6af0b1b435a3455230cac1de4ca4127ba1ed3d3a4f4ef5b0e029ecfe143c7025bc258c12549b10a50cc437b65164ce33236942b7cb1a9ed6cadf9fc3aa4426b12076487576e4fc7912fdb38ac4fc381f6ae04dafb27d9c89ba068559a8d5c28e9331f8d770509f24daa90078cf70fa7aeeb2586f749b09ab8a36ca2c843896a357df62f317bc7e87a6e08e079661f2072541821a1ef2c263bdcdc40636a1674b873a07dcd232df74bd7aff4624b09b75a2450f94b3acd2d44ad6ed8ad7a1aae07c24aa82140b81e9a1292f103d62de9f25af1b55fe221a8c7c840ba32fc0686ec16c058bd067d3a51cc8111c3517137029cdd360f4996a1375f42cab725d3d5c75f9cbbf0645b69556ed801d9e59e8d2d989b87d1b3fd19eda6bebc25fe5c186ae1dd818f23d8cf43bc3c0e0dba341ff5de4d4a01c4ae791e2935831f5992adc19af77442c8f6d1779f12e8723c37b5013bc71592b2825bbc7fae734d66c5dba388022d6c048c75d89c88c69a92836f0d4e03914f921a4d976e61da50c35eb1599ec23de5637bcd7a7e21d04492d778b67a6c36f2c5810c34b6285de1fc88164af7f50d102eebfe85797f16ec40fc98ccc7dd2b4386bab523cd95c7417f1f350689432368b336f32dbc087bcf8ca0e845036f482fbcca166101147ef78bc9ed2899cfc7b2812feb091b5894326fffb3b6bd038409d581276ed4ad3ab2908e5883891eb576914477c1864e50c91cb8712be4bd4abc676921de4066d3967444f6b6cbb430344246de6abb324ae774a0148a9b9c67211c375c78f31fd20b825a0e89205bf1f23b7b60ea22a35458a86e28e3a318d54c53264c0c22e99f85e286a6c5f553e78be643a6287f250f3495c2715955e20bb8429c4031a5efaca17fc50369bb04dc6cd686c81b6b094d41debcdca7758fd3416391edcea344bbb9d0111664598f1de04d7ba4f3b38cfb0d658c796fe79bd75938d76000704371e6e17e147d6fdae578afc9afd1d6b2921e5c12415fdd0d217d000daa7454605bfb06909b00bbc18c7789e34abeafa3d128f2337a653ca40b4cb9c44abfe3fd7b6c32b24fd27911fae4afe037c559f0f1995f317423d69a3e880d1ececc574cf69f841edfd85a8df646b72a287489e66b73acb61e874b668c45618b0489ceb1df159c24d652981f2987e17714f894ad298c6f0c99ac16f09fbf896a5a507aaa3d93834da72917d18526143a7699d7330ee5eee443bd8c25869d447bc2e34d14759288dcfef542becd9952ebafa8c0bb70cfa79346f6df3eaf2ebf5150e3fd2e68971c89d0e2a7df65da53dab9772109e6f0449dd93f91e7dadac2ab517fb19e7ad25733169e26243cb536d00d168b65582f488df604bde06414a40efb32472cb2d75734fc3841cb8732bb86d83974285de0e457c7ca4811e8c929a461b33a6d83242800344a8d57638603e58b144a9593b3ae93b0a29651dfb74fc3ea0a814d043ed276c2a2c02a7e00146d59e5213e3f77ebaf8964359725fd1f3b248d3c26739a21bc12b71f32b385dc89bf2f211583c77948883bfb5f3950ff64dc9a890f6a3dabec67d4f967a0b2505067189da362a3e8156ffe80eb4525d318ae427c83d0024fc22f070f345f2f9523c477fcc8f297e663dc670ec934366d264c5e3ff93359c51ec8ea015ad81d205bd72b2b5c827f91d147898fd049dd7d2159ab32bd2c02c412352a2b660e1e9fa82f8750065b88029d57f7be654107e2850a373bddb5638d77637bb6f5b1a63c2981b32dd450c5ca52ee05e312cbd87044f4df6200398291706e9f1250d8a2041e0b636a6aaaf59554e405bdc8b07f0df4bcd4cdfac5b64e680f82a5ff7e000de0d1417949af7b0074e797f4737eb4f001cfcd13585423d7c3c710de2513de0e7e69e8ce4ba8399835f4409f356ad655487b11270c18579591672d7fd0f7076c23e8befb8142b3a4c2a468b21d57786992d8e5951567864710fc7a1a05895a90815151f74a0c7b0ab706d53245b8e1d9b1fedc2facbb1974816c75975bcb916f62af2594d1e1a6a8df6d4bf41cdd5588776661ae3d5cde38827924650ee0117ed109e81d596f251ee7b04e4873567f2b0bb5139870a2add4b3f29b4df0c21aa3d60082a66edada48f7c3686307a27183142ac303d56e86ab3db85bb0917ff5a64d47661ffd747fbd03d4835b9341bfaab744ae0d15f0e034a33d152b8f64abfe6ffac5b354306614aa7757298ad110584e0c2a16e4a066bb1b3d019e95923981720f1bd8e5afa677fdc11cc9babbbda69195dce3ad999096903fbcc9f96a17287e6bee10aaa753140cde6ec41d720e5dc22e3f5d3b536fd8dd623da9260d79da886883745f828a87ca1d5fb20d1ec6e697c6b53f7a490d510cbfcda49f0765f21af642bfe2061e0152cc936ee0120485bff3617d64ff84d6e153552446eecd845e8a003493b0893cbebf8fe13d6fd82153f74dc6ac3fc34caecf2b1fc6f76b15ba7edb36d33b14dfe4b1cfc6bfeb5adb4a8c547ba65badccdabd414070e7b08bf9e0ac4fb0f61fd51942be766a49d96da6bf3149860f34fd5275353666870caebdc98902a90a6b99305d132f69e2b4f639fe5d396091ed392d079067a5adb40663dedfc0e4c649b56b34448ae5848643f188023d480d670cf112e8feeaf720d5b7c4dad0438586060b3cbd36bb5c219a6ef05f324d05df327f0d21a37c91d5c7297d77f171289fef86a4c56e17a42c49b730139c8b14df13f5be5800c576699f19dbda403fa4a14466efdec0e202b4464b233395b8705fd0c47fb6b8fd0ee58e99ee62c5c051aca7180e5c519414dba03bca93dd845225141b0425d0f65abc258fa0decbb419cfda8c64409d32f6db2d7b49d5bd2d597c40bf94fc6da6012d4fb7da4dbdc30a5c36dcc2891b4af7819b0f981c73be463b23654a6cab092d3b3f4816b1d2ca6dcb357bd3a96e44bdfbb7781413c561ae5df5714f9c8db08f78ca18efbfab2fe9df89ab48c5b51ed8c8ce21d8d34bfac77475c6b071667c73d9b42a5a63bed720596214791ac9e76c1820827f5bd117ee55cda8cb4b30e2e8c5b85b17d6a9e3b2cc0581442b7661e5f24f3273cef090f479806976d6fa281955168cb73673d723de968b0472b4e839903386288533db5fec22e088949b1757c7e1fe69b3b70325abf30f474a119ea51c0bca2049aee4ff8f3707c805388a8df2472278d669eeb6c1df5f2bb5f4c1085744dcec7c9fe40891072fcaf05a58e2c94d4e0a2872a2dc94eb156563a29d66325798d51ede8992ae757fc9a5f36466f4354e971f3bb11c52d7dcadc8880a24ead77c3818c61facf33da67ffbda9de68854cde0b58c44b7182437bd1616778986e1ae69edd98ae35802e377a9fc85faef5dc086fada842c97622708108dd26ea300ab580bd9c72172d0a1332ed7cab710371d7cabfce268473943a97d09af45b0987bd8f56e88ad0e738231dde21572e99f31f0094c9d23ba7da05014dd9f5b8dde500de70f364cc3c212b7f83dbd6db2947a45a325234728e63867d3392fe2cd93c36bc0872c5ee447260e10af4f2155feb18bae921832e593d101ea27fd6b38fdd015f1a73db79670b99f2908eb256b4b6b57412ca1a1d83caac1039738bc9c6609914d4fe4eb3567129802d2052b62622e32a0ba272a4e481cf7f130feba85e9edc3ef4212b37b5db2463203b7a2ffaf384bdcbb37fe2e4ee8308e4958ec6251a047e0f50a224d0917b4c70afda93a1314ae616dd7845a0e43306dd63965fa108f1999c9f541f9479661606c6626edcfa0425370f58bd8ac40f1eaf324c66c6118d539c55e69b34d2a79c2f826cf797a45b7870767118ac4756c6858c237c659fb7066ce0f6f90255072073331f42b9bf23799040e015b207341006cb94290d4822955e160a56d92d13f1068399f008687261c937c0b75fdda065e9095828c98667d26e1d92f47ff3cfcae1f51d530dfa2e829839e0c153afce7ac2207ca427ced7e072a54553759bf582b037228120895a5da5ec82c8fbebf7bc4144ef23bfab0fc7cfe7f947ebf87bf2c242538be8232540e2c7a4cecf5173d906983b9b29d9325c6c99f38ef3bbdc9eee9a9cc239b135b69565e0b0cc01ad3587d9e97127550da700fb69a894e5420f159d125a28f19e7d7c8d733ab843cfa86b5467f8960c58675726fc7eb4ff65a7af3c1376581d231b68b9d12fa78132b9ff9dd5fb7a1a13d6ac27e438cb9511a4b4edc7bf04c0c137fa4ea2b3936f8f3468653f7425173c26fd1c60faefc671fac053344ff397eef7c200d7a21caf79b96c267312d0a0d99e5d6df37484ed884b9b8b070d5abbbfe67d9d1e1ef4a6c8638b0cdf5b0e95971b54521becb028fa489bf8029139d2e8bddca17bd944a524ce02bd95442835f75b8b77b947e9d66def03378325832043f6468424962e62676c8535ae0c3e3f51790c9c47bfe2183b1a53e4731947ce7180e1279c0da1c94c722cc7cafd4b975e4286f111e45f2d67fa326aa68ccd3d5354e427c9b6fb29a0822a7b9ba3df5b4a4c3854018574defcc2ca0ec18c9f56f8228b0548e860f96c19b64288bceb9604424751a543d4acd597fb8a95b044a656a284fcd747bb8631f9c19d7d13fdb96d6527579e0243e633c0c41948092d92954ce099cf122fe757676378fc65dcd5ee021f3c6897fe5355218db67d52ef1a784fb52cdab4eca58b4e32fa9cf75ba357ba22fad3c949fccd4ca4a26aec98d6cf97ff471a15509b9e429e28a1604769da040eab3303bf9779e713dd39297356569e975ac39e3f5bb7f3946c43ab9bb797aedf9b8073d5323f25abfb17bebca44f812f562383b05688bd77dc1ead1f260023345d0b9fb984ff8ddfc160b5b9cb11864bfad8bfe36f9ba347703162cf306fb5194cdc8a913e8704031b5a384f145e98dd66d14d231bd7585217b38300d0456f1c2782d1d3cb8f111b3ee84ffaaccc3a0b09d525979ee4edb8b3e33d7c78f729ebdfc25fdbbc30d391c1f70f29cabb223a629e5e2736a453e48ee87dffbca27778926eac66d7e69fa82735adb7c26f9b6c31880dcfd419aaab47c8f37c1eb629e3d123c05942c7db924415f088f60b10104b0c37d46fe7780a7f0a9afb5b38f7f26ad24c569b8be936e7d33d8b9faca5229079788df4637f3ed6b0e2a5dc250a2bcaa98ccd9c81d67edcadd627e48f0eccb8dec07b4fcb8a14c108465a6b1c82820b2d22895eb8c088853b7b6472a8b8aee486d5f9486c83eceb037def8516120a834f45ae06f1c18b2c68b0c356009577c65fdd4596c893eee0dfb9e7f9c1ac2c644e1c23191766ee6f1bcb942eda46ce33197701cfb721b3990ecd84158f2f0bdcaeb3a5bc934cdb615be1c53216db2ea91c7069db7852df7fc2f7a410ff47a4d619ea0b877e4b103c79150ebda21ea6171a5ec95156b305516682e93268692dbc6bcd135287c9a54ee33f6c8e5bb4c23dd674dfa1594d1523904057dbcf24099a3b011f4ac6b7c524dcb87dfa20cde277299d09a7c07eccefaf4a8fe6d362316a373e3e213ccbe38d8b2fc8d0de6459aa437e7a3a4cb84ba155d6c10a3bbaf26cb3c88fd56028dc9051576e46b8673f011c8c3647a156aa0ed2bb67f38d53e671ece6edd2669d2dbf1ecfe1f78988bf10be5a35def4bd3591113a9f28de5da92f769889b706c53720670859e34bc3c39f5f70522b45a1bd79fc531bc0405effab3cea214427c5a7b09ffb9866063be1d13dba37ecb56311ad040bd9d6847a1506bed91537243768eb5fc110f8876fcc5a3ea48ac2320e50aa247a84007ef58d090d0f31e23f13c109f190f1652561daf1a2522ea7d4d62aeeb1e5d296331d4c7dc7a90c3a0ee94788212372975e6372a660a8ff43584704512b1395f91285e92b144bdc67109165d1d32e913a0f304f2ddcc25240cd439e8720a404a545845f70b42446e15459a9186c8caced0f315bd11fb983de21b279a178da9353ef1d8465cd81626839211e7fef35d967c7a5de0d54fa858bf5800c4c287357ace1ab34cf66e733dbbfb46ff798c20e6c70e7be22ac855c8ac4536bdbb66e1666e20ee22a9716e9837aa9ddff9305b0942c1fc517b3306a20cb8b3b188f31cd6552f7415865b2d704631d0927ee19945530f249d4427224df459458fecc7c7b3b4d5f391894a2b90a06655bccd984ef37fecc6d52eee06bbe063aba3350532bf1cd0c2d7e042d91b0ca5db8b65f355dbb5eb82ff6e58b9716fd8991bc73e107cf44dcdc8f2002fff1be17b18d6623b348329596e63b3ba50f15921849507935039ed615eff61db779fcb46a67a2165c2dc21d8f27c42bc63292acf8c5eef768152b2673cb2515969f52fb31a259b1980362aa8b68876fdb3e1dc58fd7d9f1b5d28d76aef50335e997b01559ee8632b3da27d67540e111f420a5ce86f176054d896673b7f121c661cfd701601930691c8de4d6c932f004af6ce27400a271122074fd9b9a9daf32d407c0d06f6924c2018d61c91f27cc3ed289ee5fb5a9129152b52d457c8db4a4bfcf7486a57b7afa26c5d867c08e2b8e7511ef04f3c6022dc5c0c876a1ab657cc22af2d21621f3c7119e720354c896a57f447e68b1ba8416f86417d64479e5bf60eef7bde5b70d6af7cec0dca65b48dd7896eaf199a3d6636cc026e3aa3075bdc85d4f16900dd3654566eec75bf4038758fe697ecbde9cd8c73c5b82cd79f638415c4d7b05b2792705361c45a78626b0274d35da346ffa4fc1fcf55526371214bc26ad56422006cadef3771801e3f8eb70970cc6c10e44d5088673e538b5526c34e3fcd3118ff41d8b71f5b48a0e896bea4e0924cdbb1c22c19df484b6e7d09b4a7e8c5dc823534d34f322fd114d4a98f97af1b2e995b3452874e07067ac76157778df419b90f0cd16958849390c419f703b63735f25d0ac067de368f42a86d17199ea7d5dbc1aacecc3ac7f1b0a61ffa8493b1ede3acec7eac9f058ecd09cf8cd35d70b6df7d6546ebcfef7dc081b0f6e8de04e5b3e1e18ad6f18f36fa06e0aee5acda988950168c8dcd21ed59ee071f65a7814ac3ab9b6e60d001365e2dbf9d7ece53ca3ac26a1ad3da80a6ba1e0eff6559e0fcd5b2ff7f9c37496033a300c0ca9db92cf2db56b6447b7085371125000588b08dcae1e986593a0eda4ace70fc0934868887cbc04646db2fd17d982ee221aa8ac46456ac1f10507310d2cb27624a25a8f76942b61a6faf1485003bbda2b23f01a3284d333f2eb412f9a354709459f8ad6e1a6429c25223b26380985c808bcfe0ccb1e1a7db60d01bed6e93e67c892eaecf8f151c9096ca4591090867f5400f853f7f89d39ee30b3c1ebd88ab60367a237dbc0232a9249099b73fafec73a1c9c256bd1098556e28ebfc0d9594747feeb01e11c9c916b93a4bacd253743e27acbaefe96b2e1d7be377a41fddc46131d86da8311eb1839226cfdebdfdb74cc254a446068e3e63a2dcc508b5d48b78c4a47c794022ee0c767ae81c529d4f191f95c871de807136cc9ba972ddc6f0df607d8720130eac8e2ac19adabcdba890d4ff64d63410b727e8bde175b5ee1c854269c04a98de1e8c9aa2404257f62bd3c7bbcd3fbe7b69d2ec57a8767b79ff359a16a751d6c267dbf359f7b93470346897529e58e464634af6552b431f95e6ab0273d30452c6144fe81c02ffbd465515a9d9c959e2fd0f4f1a6ca4b26dc7b0acdc135d3acde033c90698a63f6eea9646197ad2e6398ed2f93edd779c4b25b8f2c9816d463b6f6bfffb82698643a0c54f093d789446c66ec0557161033075433585d387ce0f6646dd6229edfd2ba7c7ee042a26eead45d35fcda37e0f298a52e003f0c5bfcf0b28b885af23b1ec6fb35f2ec7755967d4fef67661553e15f4fcee0f648e2a8643f1364a840fb3e80876d5c64496f53fd67b0dee6e97da647fdf79ce63d9817ebbfda19ebcbb549a2827d7ca8ae7c9eb018a646e893377eb60ea8b36286a037b671f7493b6804ba4d5fb8a18d49fc556a74cd91816b898225ab4a47d67790e23e3e8bb2abc12c10657f54d4c2faa8a089d550259fc8dac70e95791d6e850ef276b960d505c2207b37151c7feb98f958d774cb935c9585628d05324275a41e98d566b256b08f9e31df1124fdde3453e81a2a140b998e026da99248265ec037a8345e14500fb5473ca7c752b30fa7c81493336235a977559d632b5a8b4142d284e3a0f94ce8310c5ae8f4f59e9ed1630d76fd17137ddbe84df82285a8d9c2782b7d4f751f7a000d5c516b55c34e0534648e754dc879363d8bc437a5a51f11742358350a8c0a6bc3b83eb86f85d57bbf007ba02fafd22f4acef8639f205f35dedb0dc7e6db2a8393c9bb37f84454ca1b565499e478a05e6b4b93ed2f57974a7c2108bac9e1948d21211e5464cf35e9216ea748392f9d5ca964f927e4af87e348125e3013783d90039742b066b61d2ab119b7b10a00ec21d6f58f0d2fa62aac13ee7373d450f0fec917d69831423d12c268592b8bbd063a9b4772011e7b4b1c1d7f683f38f17b3d796e44c4d8ed7ad71c9b981aba2cad355a56aab4293ff53b3e725dbef32f82b60882358d6d92d5aa07f2e8f7783e3b78cde64adc4cd08c7940e3a6ab0a9f2da70b4256994626b5fb957bfd80b660eb73578f7ee37dcbfe3637eb8f3debabe842dd84a7562010baf8925f26b13087f77b3941901ae5a8a72d4a7f856c8333468635b9775f38c93af4bcfc9f02c0b7d1c2c29b2e5fb9dbbca87f9830a43ffa409a7281a97e5be7d0a295bfd25bb4cd49b3a2bf8e6075bc6ccc82aab394aa72c29643f9f224a63ca617b9eab64561cab5166faf6be9d381f2aa160c69f9594f42839925ab37e4f242317c8064c5be797fa6397368aad1ca6dc3e348e54ea74330a39f0cc92e1f67ac8ec529af9209608b7f08c3e06203d66b3f3a735a852897b0e1667b8c3d8bd30963aedc6504d70497fbfa148361d4c81b1c9bb79929d585fff9016de435aeb0a4b8130dfc2b69d7bf537f8f21f90a196cebaacd3136e63cbeb35376690c035c15c005237874a0b37d9244ac58bf228a99d21a02c4005e95166dd643b2f921373bc5bbc0caa3d5e1a7b131a8f7d513d0d75364a044f0cedbb54a2f4e473c0892a3e0558c0216435c6ea60053ea0efc4c242babdfdb071019867f7990e3005a1b7d89e82653d0733d445ec6454e783487adcbfef10bde16e2c0a5477ce3efac27923fd038d0317b4655fb48a7841988bdae336c87fb71afdcfc548abd671430f4628d0fe4f8093e3c134b09a239ea825ca4cd6c1655061310857676c71c6aa5c8b4d36ad8921256eee45001ea25592e62ddd6fd30b192ec99b9a66f04117c687233906b6e896c200eccc30bae493d356a120f30210379fe82b5eb1d9214a88f990e6414ed48f59cd5cc43caf93da398649e2a6b43b781f30ea0458d337bb5225e01fd3bd463e372b05a41b519c624adebed2be5d2a73a88802d077f8777fcaa6840187db2860fa35837f2b4642bfabb2b754cefa96bb1f8cd57f8a70bb6b7895cfc5557c59abbcefa561cc60c00a0b4b9287dcf96f3acb5fb0eb2427669d1abfbab5732cfbeb2fff50e0cbe9d41260e46f5884000ed92c6d4541f7dcff3273bb9fa0f5d1c2e9efbc8b93dff5cb9e5632d6fe0458eb96b2296294d2d164aeec307a8d8d63f2e5a3b48852950dbca9c1fdc13b1d3a284e65c769656d789d1e388187717f3b9fe64c1150984847679badbe5983819a6bf6d21adc495e6a2ed961e9d6facb20036c1a7fac4ff64d473e47ba253a3396c0481a5807bc95873b25ac66f5ffb7c2a19c36edbda4388b48f204ca6b80b26776de341cc1009c7413d0d6f14abbe41085d212e5f4b1eefb56f8db00c51caea179cde4ae8cc0e9f3fac7a393e512be1a4c626a115b07f99be68524ef541a6801da371e1dbf50731538c662a8301ebe6532616dafeaafcfd17a07d1bbab9b9f9578357667c6b62d267dbc238f1569ac17bc4c0cb4a2381d985396f2ff809b37903bd86506db923dc9f4efc7dfea1719192f02c9900c4bca4aba85786ea7aee12a732091d0d57dc56d27f2311b23b5263a911c80a43204584bdca587c69ac793ff8e6956b4e25fffc34599b12a5ade3df12b3f48783123ae24aea437ddd01ea545bba334338ebdf94bcd2334404a19704de275e468357e8ce9e69a87a55d3b3bcfe6dfb439e0cc53d4444891a014989b065bbc3ceb5f52eb13ae6abc620184b09d34a99ff725eaaff81d4cca41bdbc197d8e3a4844394771a45467e46af533bd0351b2b16684f67389d3c9742893e8a7c57c800f96d93f3e0fbd7ae5c8f2df5487628e30c9ca7c544b68a6a79e7789bb60e1e858cfcb2ef66146dbf1c46e34792bbfd5e0767daffc5a3b0a5191acd7a947cd22a5aef760910134267de38fad6900df8710a6e1e1d156d9071ead31435a1acf72a8e13555629b78a9bfe81e4751d5cad0483ff5794583600ccf269c8fa09d2d3d2adfbf9bb4fdf07ddb5d70d01ce92313ba0cdc63d65fc47b47508b1437db1da3701ad416026b31e78d23e53d586230e59003347999efffaefd8c809019bec72b9a2dd5007ee9b061b2e6f5aa13e82c2a540f3f3bd8034355eb078c467145289cff87a9236da6ff3363a43f59188f69af4aea5d1ec13c87bf9aae8a216f4932d8a43ee917abfccdff6929602e425c47f85c7b2cb387fcd9a7c40fb2376f6c6814504350c29a2f70638094bd0d59a9e8d2a00a9bbd37849c77d212a1032493894d3b10004029fe1e328d7709bf9e748a5ed6a4fd464888ca2598af31c639fb1605e1a2e8a902f367dd7faf5cc0335ef2200f5e7038e39fe04fa6e6651c4a303d519531e4fc84327e296641aba92ca533cb2b82af09825c58b3468b5d90929a1174011dd1681ed41143f425803fb83f3abb3a6106f783a3a3ad704563d1bb914c278506badb8a91e3fdfcc20d0085476830d827421915594389fb20aae83a7ce5cc735d291f3c3e14c088b7a529c558144a7b886535d3bea08862dad2f60009ca90bfdc7844afdccc20c02ac361a4cd2e8d75029627376ea7d35c779e9e8c08f7e0819c08368b67eb48b1b8a6329241426f468c42340dc606c3a8310bb6a3286168cda4e6a9d771d66f5e28a51e5b68faaac2c52a1c18c3968449ee5cc397c3242302d32c0d12ded866a5b85a60f88688a55e5c6cc5918b629baf13c313a12bb97c488c417e7a25f1dda8d76e4e8f3a4b41849aeaf0c284f9e5c23effae357f6bbd4c72eb54580d6960e160481fedbc98ea30322c278c362929aef45ce51d052a4e46c5f0132533294b836f2948a4197938e80e7bf930967f4a09bd8aaa47819c4e798012b049d7cc2f404ccb3ef6070f444596a8031db2df7c250bcf7dd34ab9ca6cb5b5f3366fc9e7b4841070fda92e751b76d495ee595e49ff69e24d76b532921c9ef05230de2d701c8fbfd0ce590be346b4c7533532d18ea9ce8078fc5a9a26894478255fc2de050e15f8fe669115594cedcb39323381195dbc7f7ce5e8a1a8ccac807afcd554ed30f6a5c2c5248fe28f10db641a7262999b70e4b89936d8ece4dfc5ccdc0cd7dabd06f054b32dae9c039b213b5581d1280cf78120eab030d1ecd8a4d03f9dcb4edd907bad3b90afe19da807e6611ce6a1fb379f6e92f766ec19d8e330328b146af7ea879bf28b7a82982ca2191959422dc638db83de775fa2e36f81922b000d2ed295ac7e1a5f0c31e328d4b069b4e3ebad4f7e7d55c4a806886532924244673a6881a74076a0c5b72f37ca01ca6c1dbb879503db7a88fd4dcc2dc82f05029ceb4008d7390d2c6a97ba0d0ad420bc74689c8e575881a8b6df0a2560db0f139fc78b6682d461f07d312de793adcf9227c7207992e92c6a9c1219be5d9547e7262a08351aff9629a3760bcebc88bedf8cd78a4d39d78399a070b03d7fe55c049474b169d632f3c10422da6423862d59cdefc2b91b2e45ac642f92a4cb4ad3d3dd9def071341e0438345c3c9fd84b96c5e4ec34629de5e24f2dc52077c658bd9626e5f8fb9ebebabb455b83de19ad725120a79d4c77fccd5d403ad9770878a947fdcf00777c605474870dbd8c776bec62ce091d8b317b91e578997e0849df4a6f3e4f091595d87627c3a62a127fb7790c62d2396d7fb1704462e3314a8e3bf6a1355945cf434ac8c57bba04e8b309384a92540014c8c8a7b80471b88f98bcb2247f1f7bddaa4c0e970ebf45e0c977249acadd74561e6ce3e438e140c49703c564137b200f0349fb9c59ae62876eb51eccaa2fce9e430a0bb640109d90108cb8c9e2fdfb240a872361a3c4a952b824dae1db02e646c88b89ed2b6b0cace8b4570293531986d4168bcc674935bd223ca620834801b03489fb9c49c5209e8653fc0db227847a771b205446b837aec15856ea548559e44fadbd5a11f0995e51545113291a96a0a5ed02dded0b75179be619a42520339706cbf4bf4a2a5bca496be30d15275296718c231c51c9c9a0dbf47ebc26f253f52c003c1669de84dd84819e0fd1c80c5002b13a909119842693d450697ca8ea8356efea5f75b9e9c27030ea07626d19141b2013bc6c486fc05603d1e5ad734b7c001b6a38ed2153d47b88d25918a8ff2a35d0dd4676a5dce6eb80a035c8265417fef9289d13c02318c6c54923f013378c73ef730c0a90bb1da652f44bb104617334c4af0f9a657bef7f2c2c5ee713652cb935a063edccfe28bf4f528fcad0480879fd38b08a6551bb64aaad44aa2b3ca6c7311828df0686975c5da54bddb69800f636ee65ba43f14037341f0134d884d00d8c07443e37dc40da137dec092d3c9714936efe9ec73738ef64ce9721358b58f112a6fe3011fa4b87da20d3bd5af882b9245f1dfb429bc25d98974d069dd132f6dfb8328cec2f05c067d7152e67ba1637f1088d1bef4afa37c1dbd6e7a09c7acc6d35247197016b5d706832d66bd39a582162ef9dcf2362e90b8ac4e7c32b1f5a9aab3d565f42a442aba2a7a0e39494e10552203dc293417678d52535fc5cd9f6ae975642297659e240e531162a3e27485b3b03a2efc3c31e19b2d0c6cf0c273cb44111c5e87d85942b1bc93acf4c1afda702a11e5bc90f0e5f03d4af247282e298741d8a6d093436bb76da57abf9ae7bdf03b27d50c44f65b34547248bee86d617f2e1e3a6fc67be7a56373adb12e9a9aaa53007f18f746b09e1549ecc06b953f96d13cfb4a20b79a9fc704ee3e4c73227409fd15a933ffd964457e4dc30c8995ab753d8e7e8a6587a4101c28886b882a219d57cff5ffa584906f9d4b107845734c62b89678e0c65c0bb0243514ab058e29acd0a92bdaf3c7e008f21b0f8ac443fda32b56878acc0aa11b26a05a02bde4db5574cf2e528b5768983427e37921a7a2e54b2a05ab9b79bdeff5ed571929a65ec281c584c5016b0304ca8a4350aaca85cd10daf5043d576febf3fdf17d324b732cbf1a659bee279c3cd23bc73f8a33f32c1f3d9d245e9ef072c94ecd8a8f362a748095ca9003b33716d0f754b6612ec8a8e2b0fe3c0640d4850f893e1c9ced09765ee2aea9238325cb31fcfb1b321de0ffb25fec520bb7a5bb27ef8702be808350f3d5eb7c33f144f50147bf720f97832ba05eb738a634a0b0a13e214df5a5d5cd9bfcef202382ed9dcc6e5757935ac34f767eaefa0e3307b04771cb55275e8fb1e0e4907794410beb06ee801a109957cf9065cd3e09511f4d98edae76b5f9d08316cd094fcd0836635947ed06f0c909f0f64ddd467da31ae07f64fc5d7cfd5f0e27731a53ef728ded5f414b86a531e371cc560b7df337d45a7c3f1a67e2f7a346685792ae76bdf2506d919e65cbed4b30e1f867d9f8bafa22d918ee3d765aa84aa9f97fa0a596127e022c22e640edfdb54e3a9c393f0e32d0c6aaa261be2562f3a9c93ec80d28d2f884c3234795e5a7fd946562027e892bc87832bd99a79e95e6adc311ce142bbb6ea81b40bdad0f542540499eb1cbeb1e6537431cd7fa715ebe1785b9be322e7ec84ff3bb56e7bab9950eaa03182a02780fd22f18e1f64a200fca8670f206dd876023261ef83533b86ed70db769d1b768c23f208a7b89f6d9e04587533b34e988c2516c3a7366daf64eda7fa78767a823892424e9ec787ee39acd3ea4dbb8f3317b63100574e1ac08d51825904073096a31906e51bd3b23f0819e74f8787c0b8500a871b641625c381ae18440f60e55fdec521ce01e42a84f66b64f7e847f431c02d93b2ce07cf1c96068914730ee5dd10718a4a2d13c18fcc019088fdaeb6bca27f8d85392f01ab1041da03cbc724f4bffd491192c319893f44741d068125f4d935bded8a87bb3738c249417d6873721602659d68dd1b3aa2ced0f866e83e76ea4dfc45b527b75bcdcc4932fc115ed0e56cdff832bfe19cf1de6afd7901e3f5a03a500a188ec2e6686cebd43f6e06b0925809b09b4677a0bd6c479d61710857be3c28798ed83079e9f887a7e88b93f51cb2ba1c69f6bf59cad2f6eca72e129023399c6b3532cd975457ab5879631cfb1cecba4ea394a86bbdb8c0dcf483bb017428b556d3e75a40a870469cfed73c83c47af53ae338646e29e4e741025b59e4db00aec8dd150e896c1898ee6bb1bb07493174f793288500e4287f969ed80dc9603b240e468e0984e35f6b5c7baa9a4d318f0203dc42d371b77ef373719745677777ee313305aa94eab8676e4ed1fe927c6464c8a62c37879160450252eb080b4a7fbbf8f788dd769bc46acb3203ae61d0b5903fc3ef261bccc57b54c83fca0f2a687e346c237d6d0482db132531b4627a63de8fd29a0fae16e237bdbf935691ba4bdfa7c8b418ca2eacacdeaf8e6322ef4817dd3110cbd3da742142cea949f615dbdc42e3419e7e577e66dddd64a08cdbe961b2946de1d7c15c3bfa90a937560406abd15e6cc9cddf3d55f2324ba15908f8d0be5f4071484a9b22d395479aaff3833feabfd5b4dfcc8a460b3699d9fd24bdce1b25bd18a1b97da74a0d23244b3434c7a1af7b8729631f8bc756720e9a4535eea286f7ca9db62124e0c94b58c80f6546f44e78885dfaf4107b7557a7fab76248008d8429a61fe4e62b0f1f2253f6e4580cba99c3cbda8a56d346c087d5481e01d7a76fde9c0b65ba819af0ee6475aaa340acd984642f6670ef6124b4f31f0783823d6c7eec8df153ce5728ad66369c2d020cce8388d6965a7ce156ba6d27f66e6b43c541f21aa28f169cab49cf8418b0621600aeaee433e10c8c31b79f2de75cdf0edb188bc59d37914235545344d08d9d79aad1746e0f29da527f8b0192ee29278e9ed621ba298263c5077e6e31ad75cfe86041d25e094461c5613f37f77e5d29313a5fc2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
