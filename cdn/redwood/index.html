<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a264551ebf950fd9da756ab6b5d9065f86b85360a7f377836c020bfdcb3f1a534278f5a350e3510199a83177d156150a7c9fb86931e7ebf1107d6c084d196bc495b24f8fa65f77b34479df9a642a919a2390d11d2cac96ba25134c22adaf8737ec00bc38e6120b862633a1d349b86b7fc983b5ffe82d149575f72442e1fcd56a2360010f559eb942434ec2964a86c536c5b3232e7304c22deaded0aa6a91f7a293861aa6ce42374a24d47b4444b45385694682318d6da86c6d79bb218f21ddf285924f4cba095960f2dc92dd93eb9f390ca281720770906f614b6f902e19a4baa2397e82fb55e0ed3558b01bce86eac913d5ff5edacf75091de609088d8c6a0f6cfe38f86c37fef47bc432a5bb0fc126c0452ac1d347259b07b88f9ef987cce28f1900d01dffddd11e766dfb24f10ce2dbfc2f0f227633ee4a057856aea01654b2b3e67a051f83ed1c7e59f3971af161053b7aea7e127488231c1773dab71875938dc3ae94f9a1d4572ab8f229cad3f9e658f5721a9edfb5ecc6d4ea3c2675fd88d7a2806ffb55137bb3732e8c707afa29e43daa2370056d33b9e6df3b7d87c75a080ebc0682467863d53fb4cb843f90d111416d6721f5b148748444d15ee52872d1780d6aa405488ca61afa869ca1dd45649f0ea9116a1383ec481f2b22f473fcb7c30d32c3639ef19ef9c8aa41eaebcfb1f1af2cb8a7450bf8d831991abf80029fc0db884b42e7f11de089f7497530570d899131ea319661981b7a6f2ab7b3ee8ee1a1e5ed7103d16860a73dc6317e0b6460d195061472f3d39d85d8a42a85fe1135e286c4cf1cb635f460849a94cb2a6090e72340bdfef93358354b4478cb0ba84af894781cb082b5ae558f9bbc966ec5d3f370d41e5d1244a91df5e86a97c487df138996c49a64240562c64c75bcf3589874d285aa8d1ae122376c096e7b757be512193b8db0cbcd2e9604fb745a1e8020d41dfcc9fe9b9da627ae178172a1c85d5e0b1bc3534afec93c581a499a228b685ab4be5be358749f1ed333f0fd2df9e037c8ed2bf9a86d9976b87cbeca4ff4bfa982f684e06549cdfc99e5fa17cfa5b9207414c74c9b1eac78e57b40ea3d9e8b046abe42fc7a1feaf7e9c0740e295b3904724d4ce00a66fb44125a69f492de51c4bd8c389f469f9c9764108baa3a7d8d09d61750ee2bfdac75a02dfb96f5fc7fbf9e8ac1c5b71d3353ff2eaf1cf81447eee6a6d9044f2fcc5a9eba3def72dbe5e3c1f8c1d403f4033d5dc2510a89f670f89b2eb89933508530eb0eb135aa50cb1ebe8755a93a9b903107f115089e3cf024cf71c385d9152659f482ed7cc29dd1a1745fe20f2d4562c0c02fc196437ea19ccb9780d4d3dbffe124ff729aebb8b97a2894f295efd116d06c39efa91d3ed88d25f8be7f5fb2596b331373ee82e64653bab4eee38ea08df55ca6f6ec2ed139d0948d1aa18610a6971ff5632f052330a2ef4fe548acf78158700c22d0226b1a3801f905705ed085a65a0138119192303f1072ff8f5b0b6ca280877c4aa79aa88d4c4693d8a4d8c6cfd7167012112d814d201de15409b72dd7d963902ae5524b8ac62e4f2b0d642196a4ea5294442b271fb5a866bf09c85f2ae54a326898b32736f1e89ee7061fae278a698e7dca62146e3ac70901b7284506cb4432dbcc5be4e51b194c8c4f3520dc739035fc701ec0370b0e73334c2f8ccc5421fa02b84eb3f0ebc69caddc6e6f004e123eeaf1e7a2d54d74d42dfe8bdf264a6b8852ace4261f9560e7a81e5dc3fb93a634b8d66b22e7a147278ebc1fa9f8eeb448a01a421554969b9546141ab20f117a6fabecb9d22c5993797fe43fee595c073073e026e055c6bc89c435521f91248b2730280b8eb1bef53daf972a834e54b068b9c7e0b50e64e26addb2ad44c404b4aa5bf2adf7bb409aa19b2354e50d9575b38da7fdae555c9462a4db2221d525c17405af5ce5048a9de860857f60ef663888ad79cddbaeca901532b70cd8eca3d61877d83593e508d86e2721f8429a8f9fbb1f57866b744a1ebf8942fa68a88bb0805260065f55f09e55d70acaa5ae0bd885848085aa5c9ca3ba05fc47f1d616a292523e316e7e49a585fba4461b5d72d724bf4af37da0bf8cc4a1d1d9a0568c38db585aae37950209fd0b4e25afd71697d75a65f675389bdf557890e655d3203505bee8b13e2f318c2470a827cf1b4d5b38ba040dc24614ed8810947e3d9ded24fc417015a18f93e9ba8255e995609bcf1aa58e8f59ace046522edbd3e37fc0a7a5b892360726e1ddca72ab64f7524114ad14faf0afd4a64fce847b8376837ffb71f1d3153a4c19eb7f35527f9e67aae2d2865151d5dd63b406d2fa72333c616967288fea499cf5256e8a9e50817dad43687df82636371a6b2bfd5846e958e602cb2dc629aba10ced3841bbb9958e194db8958f9a07f1f026a3bd3e86941f48c755dbf5944748e7ce4d43be7bdaec33472a031403a1fc3d0c36a75235eb00f7194688d31e0fc7e5306992495ef0c9307cb31522f8e62515d6018f3e2630409bc1267164a63c8b72e3fa56eb257ffd6c12c728ae3deece1f4dc3693cdbf2323b4612a120febdba19cae14504aae9f196fd5e919240560dfe479c28cb1d7874be9e53873fc5f0c0b5c8bf7ed0670f759a6f3f001c4a51ee92913be31103ee3e6826a551f20227e9c89d9601eadb5903c3cae2ca94709c0d7f4f4531d451ea2663322a3356993895c1482b4a327ca858ea5d5dd18642c3587f6dc0cc6aa596dbda183a2761a71a8ffcb4fe7b6445437f1959a8141533aa2e89468bf6ebe5e81b53bbad9a5875f1c7756d1c833ad8b3ba42321589b59c3b3ddf29d034816e73a3e6e702cf735abdac549073c430fcfe6e828127302f041d6ca1c326dc8b62d9571f631c3a50bb727a4b2b7058430ee98f5ad01f594ac64d7d6ce03a8860e98f9ce5ff36b98ade3a3bf226206dfc7c84ee9c85c7479eca89ae848aece49fddb5ac96261a956d3e8a33adc492f9b7cec8a4324dcaf219e20af2bb2c02e80081b2b81a9fc9a5d824c8b6de53ab7e683533f32e9d4d4c243b89220067e3f37e04fd590d56d6878eba54072b65395c81922a80474335b9621e61c9d30b093016120d883dd4c392e2db6bae19d8e606bffe4a3fd01b0cae07b895317f7d780a2d87c337de47b0c02bf94fd37264e1e72e975d48a2fb25a742eaf4b00834837af5d97ef62dea1c5f6c54699f5850dfc2d53bfe662853c8acbb8141264081641e910f60f9333ed189e11ff8f2212c9cbc48ec9089aeeedc469a0cac8831c8351633145dba13f64bfa1a4c65fbd7b34f2833a30b4ed9d9442c3fbfc7a0a81cb0be52f9d57e8ec2948f099f81c201c39effc779e6590697d894bc8452e9090e4506fa094afce72ed35d740620f2e8f75b3dff9fe103c3dfbf451bf1e0ace3b0e1b072ee8bb6949e6cdc512e4abd6df60edf31f789d0beb983ecb94d1e45063eeac81d9f3c170dbb28d06d201dbaed605515d309a7d62d8d10c7b01c736eaf490da90b80723abc7bf1f7931c3b1c8ebd0fe0b5e21bfa9c97a37e9139a13eaf8db6fee8dc6b9b6a34811d2927e3a01ba398d2269c0649d6ee4ccb74aff12e224beae31aa2ee6ae2325db840cb4987f35c3fd9d5dbce90c47516a204859f64a9f5d020329923b21e4e92d0d5396e741f21b97a416b5469c20d8b0b99455082c2a487982dd583d072e2cc571bd7878ff3a7d1b89fccb83e807aa9f364c7f62c44017ddfe44f769301c6fadc19e29b7c189fae91e8fa9dcb6cc78e92e0f950e3b5c85e51e7882c54a99b5ad475e84d2fb6127562ad6940cf946965e2b5a8451cd06bc6bdfb5fb775703024cdd60119237a48adb2f6fc05648fcc4a8be805ad2ff7d76d55925a9ccb8dae87930a29c12df657b836491e2dee534ca440e7c5c4a4f14fd5681a001895a164642f66d01143d049b135e622a441628bb05e47a8179dae28cd8b8ce771d620dd50fc6506eca2ca693f21516e62cde798c02a9e2499e8ca590ad629b7281ea7766a51e957a21b2090294e4a17d9e81135eede174fe4ee2241442d9a0145110f488cdca27211734530099b843226a76840f6cdc843019546f4d77258394ebe97d987cbc9fa378b3ceb70251afd37a396b281e0003551604cb5ebc9aa536cfacb9590886ffe6ff8cdd873b107e8e93adc0fa46985c9fd852224dcc159d69ccd4e15f3679f6cd0a7c934cbb5651869c4d90f4c60c6905dc090124881a9728e17b955305bb8c3595ef2710e43cc6352d0e066729fdde0901209489d15ec7cb119e3da6890a9c61cb0367fd619d380c3e88af442e6bc829d9c26f877d0152d435c02ab2eea5a29fa3348002a0ffe14cc64a9272bd57f828afc79d478b2b056ce7ef221cd05f4938a5418f17df82dfff4fa027075f7f493c3bfcc59f02bf4b7f813afad7fbeee13047cc3d691cbe60dd0e6fc0d81afd1704e59d5e1d107f7716ac4f9a4dda4f25d5f67d7ac7bbd57ef0d99a0491b93ea37536f7d475987103ef24354f9b04c9e6f9cd6a915d96e9e3ced746a9afc5c1bca78b2e226486010a8c04f093145d84d3c25305d63a9f9c6f60112e24335cb840a8aa2ebd662f4bd83ef3a48d820dae15ea67e82f1e9542a0e8d84e67819ec7051a35c9647a28bc57938b9b86cacae26b5ac39fbaa550add4545bf11c37afa9f582d9b7586701860a34d523c88c11bd7c74cdaec7613ceac4fa2b6342bb3106e5ac1769a0db3ff2dc1e4dfe3d8e16797ffe825fbd531a0de5aab6b4f7735d6f57616955f9f4de23fecae003a869562c43025117dfdc12d940587b65559f73785d502f7f93084666699f0d63437c6923e37395a896a1775801f6b11f81284b5326071c0097c3365fdc78047a92c495f906d90895e275cc086796fcf7ded90ddbe2f719b03c583ec66c77f50c59b536e98c3c09ae476bd071baf9ea0525f7c0a4040501c6a34b5ff1a526672968dde215365556d8d6978e588042dfbf492f6d65acfb698241d9f7ef162df851b472266d7742a9a9d356054d05033746ef3a2913b112f4c007f251550075592dc99a9c64dcd0d9dd11678182f1ee61fecfe6e2c3fdb4b3b54d6481164ecbd48a97441f09aa07d3dbcf135c71335683b0ee5645ad5a8b7ad4b7356670a7ac85e020ec43a183e90b612d4cd4e0100dde03bbf62281f739106858dff64a032645c1bef2edfbfda2966fe4e489b6fa662bd3fb4d2abcfa7ca8d0ba6853b5f3e1ff0c829969cc5d8066f2b7338a3d96e7e4889718a8f5b2fb350ce316b1f5999c21ec705e0a2e8aa866428da5e14faa451ca4f1367874053807e310da2960d874e37c8346bf04f40621c7e610016bec0a8327fbbaf9e9c3d85b230364c71e60ac7c32f800d613ae02423bb1f11c9b22a8bd908da4720cd873d3bcde5e846cde0188f648d834b20827355d853a2bcdf765674045f311a29761e710fe4fec50be60f47bfd20e7ab5c31e8cfb6a65a791fe0f2ecd417104cf89e6f78ddb4c0938d365c2d6741486b2d833e341a4e70e9ce1335afa254e1ea34179750c8b3785f86c7681d39b6fab7bd8d0b84f466f234f234d7da41f714d8bf27c07405893b0cee3b33fffd783175357e30c15d44dc8be14c68f372c89657e777688b1c68c738e15c677482092a7b22bd24aec417e4027bfbf5d59513cf96240b208a96420d50923755e01029538226f2b497428e433f155501247538be22f0e81b9ee4d4f432ee1e3afe74a69d4f17ec6a6ec122c561a8701807a302408e44a6fc72bffe02992794972fa2a6910a2204bbed2d54941ee3a99fcead4ce10c220f7bd7011649c02678431891a326da37c7d421ed8078e8d6b20acdc79b105e3092ca36db8001778179e73bff930edc16ce26ecf28929d7a96ecea34c48653f2a0a42f25b011046170b09d8e85d4873c85c4a2bf17cacea49fb64428690401cfb92e37e5aa6e1367938c6bedd95ea454fc07ba755b7e05ba8da27a92e39166046a6662e58e78144f9de56afbe87ab01758238626bd695ddd9668181dcc434d69414eddfe8206c73ad92c615b36e938fa8d85ee2533c93b0b02795df036966a440b5951e79917e41605367edd8f384e9a1781b11275146dec9a617724675b0d554f2df4f43b9717797cf0f6eeb0f51df0f9ce18605bce2472921c76746a64536bfd12cf8c970d7f71c599e3a8b07b07c968f68bf961ddf3a9dfe4bf173f4f7f70e8c284b57abd2e617d7733ba93509635276641a92de91f863022f2be38eb943382ccc1184aa542e750d2fae52bbfca7325143d3c3c7fda20765cc26afd076154ad8e3182f23e567612f6bcea38bbc7ed0ed7609899e713a2d32b7e31656001a6bed31e46348428c555417201265346b0180766ce59cbc14dabdb97f1cb363a9361711c46a6657b086c55703a0ba62ff65192e3cd9d6fcce3589726271592ec80bef5afea65ad9228d9e28088cf5377ced31fe25227f991e2b41a5233a31611abde052e50024a90a15403ce2cb4e44a0f00e5ca86e9224a10df5406bcbbc8c83a468fb2904a93144ac7cfe22c4c54e1387d77de95f6430225178e178038d722c7c357dc3114e030b7b6baedcc9fa0c4d7d7f7931a64f3c9b24e1318912776c05402fe4d0fe2a68590d38f4b0f3c495952a2c4243e8fe72d07f96f6f376326c221208737692d23379d523235abb48b1b048f6450693f4693f99b4fa07788f2174da7901a2d1e14a32d08e60b7a3870d8489f85b57124f5304f69130788b3e5f4da27c9bd3b15cf3d5c98af3fab6b48d3c71c3b6f28fa6310c5f0b55a3e3c8a35369b390297c719c68b57b111227247ec2c1513d2f1b29435254cfd585bdf1ebc72628fb71ee82b9f81c0af3ac9649e906f970db24a9f419c3dc539eb7efe645fb2eba05ec693d07796c230171673f18abfb60771cb354e35a6ec4365f802a68d68d4f8d84597a47bd897b21613a9227f84f968d8f483f64f8ac10cc86048358ca24f0a3b3a1b416df0ca00d12e83fa40b30f23897689c9ecf8e6e2b15120b6d8f3df5802ccb3d747dc8ab43910381826e6a7967bf2d2abb6547a476838fc0de82e6711e52b7d37d95955b49248a7527266b2a87bd65112ec48fe37c73e3cc46bd6e259ca0e6ab78cbf8ee0b4e01769fdae18e60cb881eaada26d97a0531729b93023bc9fbd5916a639aee6bf8f4d477dff39d3b3b42e478773215a4ab80d775b047adf5e17d0a4c2d4f6dee3015eba940fa9bc4ed785672b9434b8b1156b7ede09ee3947385f6450ea4909fd989ba0bc094aaf8504b4dcb0b230412378334d11e5793bf8f85e20d4e6da9f2bc3cd514da5370563c40c952df32f4ab338967753b5f391ec5ce6b52da974e3598261166ded59e3735dfc479a9eddbc9977abb64042e337749fcf17620f56278bf7951372e1bfb386a6cc4bf1450dc1e812ff38d9d16bab56d48fa294f7f9ba1250b808915f8e2018345db23149d6e42567c3d41ea9d35b145481cf24af6430a7aed6619295de49c1047ed39b22d3b1b06ac8ec8e603cb61f2b13e5f42e9e5278db85a086c025331549ccf159ea7b5af989cce7f90afa138b2ea03773c71b58205f8c1c6d516a226b3d2703fbb2d6bcbf7ccfd1dc9bca43673ee6d7f1e6b430066336fde340689a48ab222a603385fdb9a148db1217401c851ee471ee2a14793adb57d9daa628c9d9c93aa35dc92bfadfcdecd27ad6f0d095a82d617f4f680f8acc73a60d9067bc22b02187771cc575904daef68ecb1452293895cb37b6612c4028deb0d12ee7a3bc65cf4e6dbb3a6cb06a2312d564b947084306ff53c4694ddba44ccebc8da4ae6ccc0538ca245f41da37c44bae4f21d7a67c01516a4a6343fa25e23cc62b0008fc4efc333f73d66eb5f256f2a7c2ec3c57b050c6d23b64a77adc82913f5177fdffaf4b3cbd679c3136e09b22f042d85d4e95be8826577586d3da6ffeca889702f1ffe0c31f68ce40b107c2109156269ef37e95492f73ab02eb64f73536fac5f59d0712353260d0cac929d0d1f11fb8bd045765e951123da135ba49db2b1de3972046075cf4b234682b1304017a793a1c2068abe6eae6b5c9469db8e5d25670f6761ff60ae6d2fb46a2aa77f0b4771b4ea99a241d8793b21d8cdfdff0c2bdc52ef648499b77800f393706bafec9095e0b993fafa3ef04d1e382f055a43a322e7055607bb1d2bc336a82b1a5cb66f251f4c1c143a5f124dca7c2239bf34bab5541cb25ad666e4b148c9f6d740150e7938a414b51c47acda7e8d3c1737b516fe3c209aab18551bfbcccf68f79bdf380a4e368c46aefed17130a054879b53f3ed05498c50aadea438aa9a280e684410f44776e9680871953b6de56a6d9c2e5d6abb68a10f5fdb837ecbd659ad5c93e1b856e764b5577c308a04f8082b8074c4435c789a345eda1c156633cd2d03998f8b95a20500ba0a57fb8f13d17a264fd4cc35f55a6de0c7deb8fb6cb3e23372de060a93b4f23237e6f764fb6e42bb9de2c08fbe152b7fc6a08bd28e275d8e999859cce91ba70264e54c4d33803e97dca32421337566f9652768de0747ac07f7b68ccd558b12c50e2d4bdec61ec7d8df9f236ed409352245c5fe779ed168d9a41beb9a3f0e9564d5fc880b73e6c7b58ee4073933ea4bc7fa17638e92bc970eee09e2c182ec397273f34a5f80249a09ed4a3c1d385e7320c6ddfdd82697d119d90537303883fa8bb439e41f3de36b4300cc4f038d229a3001d81533a04efc4df7763bb166546457db893cd4fb8acd8d1b04c3683df571b159bd2d0a8584aca19a521588a6cb62e318460ae3dded5e3c16d038104d3d402d45c5122f8bc493ebc7b253cb3c2b8805aca18137bc9e4a3617b817692e098c5ce2a52df01739abf739efd450117fe3dbb7ab66929740dbcba3e5e28dce0f45455e256d3acac0bcbeec6d1c4ec6c7204bab288eb565557b8f406d77e0e2792abe2a505f9840fba0ea3856fd1d81d09313271835dc73af472137606c390de610524e042f46076613de6086aecd0150e414946836efdcb276fa4b775f944f0684885230b2a8b6cd7e33c079a20a9844e51c687f9c378e7d41f565e2bb1d669751f8ea15eddaf57a857481aa64e5299095e8576f66eef01da85a3fbb6fcc15473349b73a019f8dcce19b3e4a087eacbb769fc5b70480d1ae7b2fe06dfddbb49c9b0b9e90bad42cf8b1726d594c79041cb81406f9e52294562aaf24216481230aa9fcdbf6446f08096ced4d6a244e6ce0c16ba93ed951304b6d080348835015c2fe4ce6794a213292b30bd3423dfedcb24da11e6cfb7a0748b323d33a663252c925ffdf0e79c0dc21c3830769241b247d326624803f44a3ceed9388ab8162b22f6fd5fa79901a59e08060d0578fd9e6aec3a91888b452735089e435b755cbd69d35854e8f75c1f83fa44d231486a13ef6ca6d080363b48ea1a5ee9bb989da966a1a1e0756ac99cfd21d405744ce2542b6fa2cd07b3cff603cb201835bd8024aa4de477eae630bfb28baab2680b29a15b2a92d56e95a021ac74d2a4e4afb332972946eabf7402550fd2210be138e3a591828453bb5a1f60ba91a5de6518bea3b69f4fdef0f0dbc84bddc49b5e46ae96d552ee1bf8b19ec5d5c2da6624f1c04af38cd2f4fd9d0bcb801101359442dd330294169c1edaa91462ef47c42087432bf709871fccacbdd31e61c8e6c7efbb750884364f63077c2fab1552041451785f311b3750456012800a105c4e4758850a2108080e27d2acab61d75604fdff5bee9c25ffc9d2a3f4c1cf8278b9fab276d46e4b723e5ceede366c7fb4dd191545dd41186b57fee4bc079a6f89f165c8f93b7e52e31a385fd74bdf35fc60f2d31d8f2884074bf1f384f71e809996d1d30792a876b723242088ec3ca8201b337fb3dac1b1cfef4cf5f12db18eb1f00c34644e12c1794e1a45d193f837fcf3860c2a36fa93e7a8e10aa901e8592124460e21a2399fddf060f0d68cf6dfe01f787b15bbeb54146986fdc8ac15dc305abe87ba5930945811b5c2df865131a088884a0127b3d83038cd3320319d70bf4cc7c5f045859621ca4a85596e47aa17b4ac1ff069d478da0c73982b848ae70cdf9fd2bfffa15be74c5ac9bb59f9b97705dd53ae62ea6b616b31d0c5a9983d8dca5c8686ce9606b390ccfbe6fcd1112fb65810b6da4f4c538616c5b82051dff92b8802ac5ebce64955b96e8c250e246836e0743dded9427f8d4d040ecd661a7a2a5b9bf3bfd43f49ff7c2939e2682b8854c21680c984227347fe995ab3ea1739a43b3b0c5679e1260dc9750ab10de806db6a933e6bb3efdc191acf4263702a5303871969e6292b138bfc923db2a64d7c7354c0435c627658dd87fdb66fefe83a47220b6016ceae2b6b2128d2cde317c23a80f1736f36656915b21607b2a3bbe81490586d1ab5fee62c891fb83b7cf3a716e24b8db08b6f1eab00609bd8521879e1f925672ee27b109796bd23ea7414235a52c57a9ae6f4dc3d67042994b487534e56abd5f3b599158115784fa782c47fe69ca82e18f6138bac5e37cbe6cc94bd352e92353db2bc09fe1280bde81d23e89ff7cd69be87ed74ef9519fc6d0a0d3cc6fb6623d4c6cbcbb08501be6bd4e2f627a8ff255d36916fbd9e6fb832151fe507b43e90caecd7c1ad198d793a5975720cbb31a21a4a6718986e8d577bb1ae2438cd805fecf8772fbe7450d1feac574253fe32ff926ba79460b3c02686ef62dc2e1a580647b228ce3487f28f14c134a99a28938b63fbc35391c3599f8419bb3aa14c26fbb735de1a6d6d9c34f756c63f6fa08c2c37cb7b7c064b816b89430f00422cf6b904e0421e5fc53e6e85d65b25c9bf8270a99d6ed40214a71099e1acb542f58e8f07de315c0cf320038e5281f7ab40841fed31469b0d9bca23755f815f183aa5732179efab9e8b5114e503c4fa8892e24d4cde7046289067a9a84b5e4f66deeacc92e6524d8790d18dbf99f801ea54110b041b7d4599574302491e749d73db9a90c58b480092d3d0bcd2bc685327375407adacbe33b0897b4622d2cf8b0efa3c85cff6e930d6b530fc8ec0647cb1212c209a534c68ebe636f53146b2d778ba1946f3ebdc8baa8028dd42e89e674e50206c373de66616e852dfb41bb9ed25bf4dbab56efe8f4f9d3ad7fb6953fe595ae55f702fe67548bab6c3d8ab6efa4c10ee9a5bc35dd66c96fb30d5b38204d37d5e72e5658b60cc05f61ca0794186e3651148c17919a2b571e04cbd0a828ca994fde4042c53562bc824703e3ebe04ca48cf3f43cd78361ac7c7d9409f9721f484d007c5aa041b1ff9d3e69553cbcc014f3563001e3707b15b1acf013530338124808c1380d53946fbc828b68611a7f193ff3a128692800289aefe6c07669a96cfbed1a5af961d21dc98e8a20a3a34b0f13efbabddde3db481d7aea77c6ef00d46c987c82f554db03f2bd4884b54e3958a33fc42590c95caeedba51081f708b4322479c7ac75ebd54c38da8a3d6d18df429670d355afc34227b385c28e104d21fd0fd94b6b869330e81dc51252ed9b5f521f090766e049fd57fd909967d56888ceba4216841d26751f32612eed408b3e70106b0bea33227224073025d8d69a059885b4f85da531061dae63fbc065b7443997b83d39b0e90dc54a4add79a5517c745d16a4b7b1e238869af65059e34a78eaa732f52c2a756bf1a936bf1459246651aa8c4ff733e89c77d135ce8acdb42c21f22eaee5b3e0c380f4c7bc636cce7f22f1307d46282af81a7539c1e7f1419a9a9141dd36feb5a5129fe39d95872a38a7ab5218e985898592dcb536986971348a4493a67f1402d5e910f2a375bc528ffaa5374fb99905dca055eb6e0ba3f6f64ead5096d6b96b9010169437810c359ae0f8ae892180586f0fc500f073d12511a57a7b2505cd269880744f0c69e19e52dafdbda062ba34da232cbaf5e625cfb39f2358de91300609ab0b08b218c3e415dabfe189a2c0068d50b6a322efe9ad903e311e6ed57894631c3253d08ae35217cd1731d7ac381bb34613dbc65bb690d2c2573ecf75460b64dcc730927750e6686fd48c3310b5f2f4d340515842bbf9798044453ab0701e56e7265641301e4caa869dafe725b95907ec43eb7d460fc3f93d450c31b1722358becaee4b2d55ee15b1a3f8cd681219a737a3b8a067a5bb1c1c6791c94a79715c92ffe47ed7c357441a604d7440b60b9edbeb1e9e3368673ffd3cc4b425ef43578e8540b0064ee31d2c8196b4be7a99c01bc3f76615591df56c01db4cf887b938ca390b07fab485ced309ec3095df9fcfedb2461b7aafb2f741c4f05ac9e91f5aecf59474d03c4c7406cc8a5cc35ff48c1b14c0cb41570d5dc32a236e4367e462a0910d1803e05d521c69d25bcc02ae94d5f61b1772ce34871924ee125c280b90c6a6e381ce9657409a865afd4d1b4fc8588914ba1c8372717f68c0ef67638b141203e249868eaf7088a240546429896eb4a043d85d5953e68329e8e8e57425a0ab1b9a1801f84c25c4a2a4d70170cf8304a312243b35f0b08c8a44fd7da3b053040db688b4aacd7b86088d7903ccb63f72d2c9a16153608be339d4ff2ce05e93aee0eb67af64bbcc41e2d975ad95e26ada27215270e64a055eb5c0b1fc95eb5489f34fc4a29e9ae482522cffadbd1b61ad71a85abe1a5ea0b23256a9c55e52579b8157e5978e3c2c4ba27e8a1dbdbe9ce73d743be50bcea46d58648a844e3e0857052b84ae7c62a0fa36ae68d4566731cebae4ac50a547de837e52c2ca091f195c0343b8ce729ba3a3a1ef16cbcf6f8299158dac2a67664e12d5c6bc23115a0a1bfe85146bf9264815a75c3778c1e7d0ac912c91d2ba78bd9dbf1f4fd820380a58be9b808a1b677ab90bb38a389ca13d2a594ac7a16396d3936baa5bc3b0f12f65a1e9a82f206f67f0b6f031609fbabf22c2d6ba379713c0a158e287bd3f2f8c50b1608ae61f62adf715a3b00ab89334e4345844f11fa220a05b084ad7590d30c17124300721d0e6a856765787fbb0a964c131bedc0cf0b7d4d7660d1de0b97ab3c5724cfca0d86e55f1a85f78567ae0b3ac4dc71de7450ee00cd4c9569a8723037192563e859ae53c3c08400ccdb719c9923ba23a6550e731d0079f61d8fe3fba2ea3dbe95272d690f8771bfd0bd3e0d273260d9bd49df800016dd17ac16ade902d1eef522be6f5834b7dd47858573afe038d26c6b812524d9326312c569bd146928c44d2882050e901453ee2085e5f72080965c71d8919dd3860615cf6e141c1f4f7a91de9a7a827c6217d21b1286e17d3cf00028c633eb80c6d80a55aa697f3d9111fd6c0f750427f679f4bf5c08fedcc8e39682de6878b9a934fa2edce4ee240830250465d8dbe6ab524e911aa2addd044889456762c5ef98367482aefd345d0328c88546459a709a2109c95f41c4549e06d05f598e08b6af40bb4b233be787224b27874e2e04bd9e54dafa75730d02ae09fe9672e3ab887129ae1a537394685fd9d991c1ba17a7e11e94d2c6ebb4775b56f1d81b47466791ff5dc3b1de2bd5ab8b78e431cb4944766c21fcad90f00d892c14f6f25935b1207be8a26e4d8cc7559314a44b24613b108895444913356a4312dbd3648d0f29f05187ad5f7b328e1b7a9c394697da392e6a98c2d39007cd3fecd49cfae0bfe13cc07e8893ab3da43ce9207e283a56fdb080bff716b5d1e86f1fc9a3add8e7a84dc04186f4fed1195a8839e844ba7f34ec7ec8e4aee70bfef57b319fb1338a1860eab872eba420292131a6fa5a4491cd47a176112a37775635f6a59e5954761f45e7c94c289e9d3cee139dbdf01f58ff733faadfec72130e5ac10721f048cdc247d596a9119ae3e8471263c8eb5f6c7976058ebc9da873c4503dd357ca5335e0567cbb7e16f92fd79060ce5c9b134584a6b37d8bf5ec9fe018757bf2f22044c7be78f127245b8751d1c0a16acb79cbb137b1f90674f0751835051dbb5042a4c335a45f81996e9b20b6c0aca522a2647248b8bbfecff3660de4afde7f6a97d2dfe50aa5c256928a2abece8b66fed20e5ea64ed55a89cfb3369c958294a025aecac5d96c9949f91dd8f97d3dcfe5ff253af66323b91aede8e44c9e602822e5742e4155fc10a3930d67f0cd67ed5d5a7de67dc4b759e073a9dd8682ae568802cf621c007f2dde732a461d83ea196ad52ec279e9a0ca3f6f98b4d950359874de3b9484340b9d66517838447bade7804ce0c9baac4b66bfc2b0bf90ec0a1f9cf32ce6b7d2d2985831fd6c5999ed331c700284c62a7ccfba145d1549407109b65dd444de9248c283bd2a253e236014c7dacc6a08b767794302fed59a10010532ae6cb56bf6038152f6491feb89c27bdc03c24e5993fb790dd44efb91659b224a3fe254a358094070c66c4f2fa2872f6436183af468942ca6bc6689dd15842b424e3c5f22806e3c0255b7408b9aae96a5133598ebe3ddb561c5d092e093e85574321eab5f366112a4b14421abf874e511aa758f548d61ad6bf7e48055e3570f1701e9dfe1ab496fbbeae06ec843c5fb0045450cb49bb3e8e9e335aa5d198e03e9e01fd1c02ffd119e499e30e1e2f9df9f2dfcfbf50d72b64da931e28a45c93280e13f6d17aabd98bd8784db085e703ce83243c9149ca9395f07485b6ce8fce94c44bb58a809c55a386c0c6f0a7e3c1e5832688b1033908f291a96a8ec45e0f4f70e6d2976aee0f80dea2375c91e9fc9b1f7b54b648567443fd7a047df3549515eae62de90f392d8172c0c3e1eab7caa7c39f6d8dc249f0f1ef13cf60d77ceda80b448581afed6da8c8c3af0f0de08638dacf5b01ce2e3f130073e5074b2a2058363796de7cbfb88dfd559946c05bfaab95562c0eecb7746dcf1fe2a7a9ae1f2e68016b1b1adba5473c0c9ef6621db626e879b5908ed776513a62ea0a80287a3d8a4385e8aea62aaffae21858e15734ce46d67a55535345fb048eab08c3b13373d7d2d413816ba45573cf43b956b7129218768ba15d9b55928a199f147dd625c6f25baebacd915a08957f45f287c82858eb711d457f498a5ac18d5b4c1f5f5bd30ff941b9df779f021f75ed95dfff151ad3bb3feed9499ad1151b889737660a30c04b87ab8fd9bf14b196044697071ad2e8e708c73668c5eedb23de9e2b069fab1fe0a21a2101a6b17f24e88676b27dfc78ab1b07825f892f4868cf805d700f85e6ad825663e29f70828d5e6478202b2062aef9ebf1147aeba357ba6aa0735174443882dc7fcfbc40e48a4743d78e718bd569c76808f6b5241937dd7a73e6f10dd7cab0d80f37946e26183aa588d8aa97a40dd9918bcd78de419416a45704e055feb2e17c64298728cd5712b04677dcb0cf3fd1cad83b77ab592ad187903b014b0944efce643f2a8ff6ea9405c7684cfaf403fe04e17b1b6019808f5712b8e3d05c9c45c5605ea2b7cc82c7e2624917b4b15071d850922d552b4be5f1af59c2ea30778fda9559716eebf19e2b159003fbb3b91ce0246dc6c64e17fcd1f40365e050fd7b790baa92541b817c96cd62918c8ca111f7a8c5f8d40daa28d23bba92b356e3f79de45fa6291f7fa6681133cd84eb1145812598f2ee4dbb54cae7b324d173e9665d02c5a2cfb869589b090f8d0527d5a51bf03be8320019884110382a8f63bcb44e0b6ec8044dd4f53efc89b6095bb60f8331e64f9ee7e64e29bac468d9fc2f0e571d71e412684fc68e2acff2237aebb886d25fe64343a04873c8ab87d6482d7b5ee307533702d678b11a73a4030576aadaadc3fcadf424eef9c0d934eca752aa8b76b6d9bae39cf4f5be09240f335601cc049cab079e5442c2c2262e1b2545bc849b62fd7c0216e96beea6cab4df2f1f5c7f1b4689db0f5b34dce005db6399e798514f6764726d36b4f50ffe1d90fae9a818bb4d2b1c11005e030c548eba797d849556c0c805ece2be4284c3a82e33355a97f05aea656b4bd6fe4992f0091a894decc0471ebeecb4845c85df9e1d5aff31ed29205b323091dc10d365e2b9575e3cca4e3f2d0446bbbaa8e5ca8138770bba9575874546dee563f2764004f9f6c6769c6cc10c89272d4d5e788f97578a02a4d1ffe3d858fe7e8e91ca265a2980e0ea1275aa15aa880c9c4fcc8f0a9fe86fedf8be8358196f640d3e7b13542601b522568d1f8162809bc2b5e78ae82bd04d509967320bd24efe032f7a4cc6bfa60f8ec10abaf31d44857ad53b4e75e38a4d5202bf4d41a3fb38d84daf296ce0157212a65fc37d3a33c6a2086ff1e1366a0285232702b445ae4a1304d95dfdca3de424425163a5a156e8c51399bb08a8dff092f77ccf4000832086f3389cb700f68ebcbafa4c8b23871276ba85f26f69a628ca49aa38416439e1b5cbd027607a3be328d97e479cd7a3ef21d7251ed6d3a7f4bb54d5ba0e41748b3069598ef3199e3e089a1816c7555e0d41b99f8163db9cfbfa2c8407a4665327a927c26f1a837fc949f654abb6d7fb3d72105fceb4e2141b29e5d88bb876e01c30f658484e1e1268c29f4bcc89585a73b138038976544ecfe34c7738be51f5b7cc68b318074bd4c1b94199ed5cb225a7e322e9900334511304d132ed7d9ab35298cb3907aab389a50c6bc8f2bd4bd45cbf861e31b2d54a16110d642a78da1a6d6f60a71f263e6a0b691c9a6a28dd6b3a73d6d6b7663b711b7f5d82019881880c769c76b90543a876e79c1ef83c4c6cb62250b48b1dc6a6da6c299f74a8e7ac5daf2331f4beb74685462af6e59a66fa820c5b46d080916342643b7b384abfc5bc0c7d9c6fedcd0d77036f35d79ebd22c31224b26d39ffe6a5f93b126df740208b9cd38336082f5d2e8b12c73f89a79e65aca4582cd55efc45c3d7abaa6a7365805fecbb39a84c4886d27307acb0326c8e15f146e315d812fcc8a7b541403a1f11c6e952f759aa35af7d3ee2b2ae47e1554d5ba7a7681aa781843b5560382f0a5ba907c119d417ac4ade4c7268c9a20aa286a960d938997184ca7b2cde98e36e2f15d4d8ca52bb66f12f00011e716bc1a5d580952cf2b69e06fac3c765314c38ac446e30dc08477e2ae15afe73bcf86eeb1f51ee56c945db806226ed47d6786ecfd1d6beca38d49180926785d5ac40d32d42791552659a372c520fe167a815b4503e0d7b32392254f7ef131a39d83da6b17b947f6e2c8239dcedfac035d352d1fe7459730fceecd72fd48d4a3f2812d1dfb077e5a3cb0bb4b7c88b5529ed9ade14bdf500f6855e6ba971b113e570a2ea81af29767ceece8bd267cd753fe8b6504c019f2bfc67e854a2390250c32ef7faae27590c723d150f2516a79834e3bd17718962645a66bf3a84822698898a16c30ff3f9ee580c7afd1762ee9742ab093f96b0ec6f568f58520ba7ff43bd1e7f24decc5bec31f97aae25e913d4e22fac3dad18070420952bd43852cb0feac402adbaa4cbcff3dc4ec2c267768410ff121cdcfa8f7b3e7defaf53fb39fb729778d06780912ce10de983358216a8cfa9a5d22e969932c2d8fda3d6a06285177191b0df31e3679f5d1fd9982499d4bb2d93c7d88759bb0a761f1390cadb74a8de557771e8d09a215f34fd8462de698ddbe10145a6a231b65760a4e319c66c4b473eda78b7f02822d9edec26c1a7706d174e77062d235cfcc3412211a62a8b59f7fb51ee7772302687177beef282f72a2f500fc74777d0b7f584d9b4be5294eb02f7b62c79427edabaf9545202209b81c18a0fb155cd91ac8c33314e7525ca85dce7b13c8f2caca29d72e7082881b4e2fe2d3c17771438066a5bd25a96680b21c52bf24b869579607cf0ed1bfc32fdaaecbea364bde9980424293d5a1e35296424001200c67ca14ef044b14d7d4305160cf054fcdd3bbe855796317a2d20e64f2fd159a0daddfd037b0bc1c234edd05bc980c12e8f9f017fc2f4371a693b04d2d453e3af6343f8b8b6f78ecd6431425201cea3d75ee1ec1d3b1d5655","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
