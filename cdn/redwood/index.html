<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42c38459fb4a6062ba57aa8d26fa28624aa734eba1cda285026214181e19027681e762f161733f1f6bc66639a90fc808676a3c1ee8b48c7a859e85494b521ab9c5bba88ec553ab33ac2131ae44137a2a029e938b2877ed5d11b6dc6aac60a3069728af64c0c62148e2caaa201b920d30d6258003bd9632a5845bb2b0ca1dca456cbef45897b467cd7c2e002a7c17432cefec86009e80db6788ca9e1727bd171297c59a6f372a3d22cd1de04185b832de0af31e843258bef2864a6eedcd1363061cfb0853b03c06037bcbc31de1293f04a5a3fb39b046e18b648389aeb2cfb3a33b6f1170471069a7c8cc5c69c79a1062a0ca347d0d192513d84a0ef855f24133fb7306020f08bc04bcfb6563df4e2d09eac233ead2fb9b08686143b70396f88189bce7290307c94c34b036cbfcd97d2463971616fb89b64109c3f11207480c18efd30ce6ef943856ef6519568771121b7d73933ef4709c4b58e9a58ae2f06b66882fc26eb668b66bc4a9ad3f8564eb2cb04684e6929cd65b57a960ba208e42a05fe042ca126d4eca05694e55e37c05ccde5461f1b00f4e9d6b78de9f89fbf93d5729fae3079abce22c3498a12fd66b43c05f402b06e3c1c6e6b28888de05c2e95a75b55f3c3336423b81f0405a35b7c5ecd9a816caefa989594a907406eb52bf472178fab1cf66d786ae7bbdb7952ed943e281c32d3b6fa2150ccf69a24994b674f181ceb64a6582ab8350ddd16132428d39a31d2f01749cfe9b6d0ffa551d9071e33a4b4710ff197d0989fd00324ea304b3bfeaf461ad04d086070c7cea8e18a5973eb078d964158ea45a40b936456c60c4fde88893396dc1d952918f0b95bfb0728cfcf10f27b4439afd4c02e894597cb76c64fc04248e834b9a9b01cdf5b824a364f0d5469d1501d2cf6328061932742983aeb041c3db6e54ec7f467e788076ac00a20420cba906cc2fc7744a0e0f34bf6c5874082c6c12fa818551639c2defa0365534853f2054d4c96430d62926f859506ceb0ef8755c26264cc63113694f4914bd18b57ad4fdf49e6ac47d08843cdfc9633ab63fbc225ede4365040621a3a553f4047e69b19081146c4c5091c92d7f4c69d4bc7376469e480630c135f44db346ac9dcfec4f63ddae60f21e0136f0c6c1a6c353e9466b96ee819f65d61d50428ba086b8fd88804dc7ba2065a03db5f82c7715ae226b7b317b2b501acc2132413fc84b88c0c7915c44abf7ef45df32581e19e8cc69b4dda0f555521b44d818147637037d55129f22d55afa6cc1e2b078e48710a94e206348a3953e45892c8dc74236c4bf95f3dd8c87c020647c30c67b153fe8b5a7f929038c84cedaed6f913eb2fd7ba8f57ebeefdb1a2a6568f9634b91a7cb3fcd2796007b738ef982bd231d020f1481a664ff61bc1201f45568d70f372d55cc39e4cd9ec96a4ba1a6bcc2e8ddb6d3de6cd254042482a67dfa8416c03d6dee04e1e8db58b42104d45eb6383441066b1a005b7af3afcb925ca2a8fa9740fa2944231fd0f53bf96c02e5b5772704caf1b9cdd96fc13c3e1e3b2661e52af20e0b28364bff95bbcab27a8b4e943be4e9a93e7f493173948643951afec417d1e4da7ea7abd7aa18166250f6633909c4d5fcfc8fa6b96cfdab4bccfd9ef23d74febf1d7cc95e1ee89e2c07d58f8eac199f69a469e2eb3647b228ffb050a4daa34e319904982c5e95d2225d0d636e4be1d1b687f0fbf1e508c3b2c29c6c30112b0cc6a18230c445e2f62b222539e27e5329f7a0c76bd8e9e60a451a09d2a45cc9ce161b4b6d9b454f4e017e0cbeaaa0ae6b07a3ae92e706ed7a4cd6904ab5ae9e6c47b5dec11d295185c3ff9c42a7cff4ed830bbd0869a909f9308833b8bd28fdc3422ed63a653f76896cedd7ebc885885f2a772da86aab3aba20f1906e68081017ae4507ea94ed965f93e13b56fc4b3fa5bf4dfd9ab77c9d273b9d7d50446443d668f837a234365076bf5cd7ba1bc607b6683f4e56f914bee0f323155da712ce2a8cf96290389177eea64566145aa3041ed6553d2ac4941bf1a4540fe44a288e58d9026be1f232ef33cc67cbcef7c9c6514d02573a78e820c279994d385951d190f837988f9198e06a0f33843385f03d4f78482d5dc4b1ed4fb9a0940235b727032c0b551878fd57255ce5f3224242f56a72d48d897be1d8edd129c480c2a17eb7398a8706f0a848ce186910392126b7e6d442d4d2b97245583f5f4222af6def58aab30c266b45b1ab7e1c0e69ba8900e2fcbd422e5c79d3002b76ab96acc101993db782ab0d7b9f3306689b417693c5e3a24500f2adb4c579047246e15ef8260e4b7e3dc6d89bf05648e30b42f9400a142b3ef93b89f86dfed9ed0908f96b36dc417bf47d789ab2722a299ea9ccd31a7801fc0a59c42e794c804f469d07bb62f1c53c2484155e167fc720e6e830f1be3d7677456fa16b40491a0893c8d7bf4f6589d4420ec710e09b307eaf74f825b81f337685fe3dea1d4a2a3cf8629e4acb4225e971a157bc61fa9cea8b1ac8d94495beeaa893afd73353d7603981c5a5d540016e4cac698d63db1a6b6772ae902cd57535d23ac9aefdcf789aaae22648e6d217845483722e485509d0b61c8f643c82dd0034951cecaf5357ea9361f5a8c6b346527432423b4ee1d67a8e52f243749b5ea8210dcdb0240c0dc4f92b6cad084d496cd1d7e169f9f88545ff0931e7378c3598302ece399a2481b1a3d73036a1c0fd66ab5766f668d805ef37b551f5b86384a18e8bafd490e5c2f430363d9cffd6843d191c1da7a03023a4f6c2232b50c05a817e7db90f36755914f6d0a311ab30af0220cb6c2e66f47be88b54f702a5f93c131604f408d010cdf74fe3b9486d3e63c2a35d7777e78fb787433cab1231050a9580294967adc84cc07e252df5a2272b7941ab9aa49a5ac8f967894bc9dd7fb16a86e33fd9ba7192e8cca50d362a8ace1f09a3764b3581e63c4d341b3b35678a6a3b6cf266847fd8cf05854b8d4886b2413f3aad8b040bec6d304c148f6c56b9bb8ef9450601cf7b27d91ab1392aa0dcbb6bae60b3006028e9042ae4053eb71e108a4fd1ecac8997dfd06421c46f6726b0946e79f5703bea3896d86c300aa0a86477c7f22021f4f74329032cf5505c8f58f7c720f663e848944f110eb5b624290606da31558beba9277c2b44841bd6f49f6646fe10a9f7e1f73215ff6b5dd4f4481f07c4175c8682523b66b85949935aefa8b07d713b4eb8ea81d9f4994eedc332aea82571ce24a91b53de141cf898362408ef95b621208d894c86620651542163b2c7e6b5a2af3ea757b26f3a3677ec3426643ad879371804e9a8af34b8d0b8e2bbed3d931343236d3b4e35aaef80a5026e0da346fb7f437b195fcf57e193b1deaaefbb5353e779cbd8690785fde5216397c18d7a273adf452fba5c8aa0d60c3397d3eadf460d598867d66373d157deccaa6248e55b7d4a1de644e162551a2240da9844ab5a201b94254e6e1a2018a55cd297130047cba0cd1b249eafc8a8bea418af90ca792b1dbbdbc00535c5d0dafa9564ab0fb65725d046c7749728ba0f67a47ad5f8cd6bebc6eb3c322c4670f61fa1ac2a08ae7413742bb927b8bf18800b64460f99a8e2ce2d2fe379770330ae8dbcaea2ba72d475412a7c2d5afe9d4616a8c40195fba83e56af7f77d85afc3a514dfdd6252f5180dea8f1708a46666230e71ed7ee738980fa71219b4b16269a3aabcb3b7b8a96d62b0d864767cd283e9093792229950c07b67e73c8b07ceb987989c71edc3494b1d7cec612b85b80c560799f0dc258878e93b5a9b83652acfeb80271141d65ad3a269277ec4dba47e6fae09cd6b28b0c5cc20e08ca73fe45a5293dbc494947ab8eadb136bce4f63e9e5bcf83dbc0cc54cbbbe716436bf86c82b5df29ca6c09dfb0ee8ef3f02cb92e39707cb011ccc6b79c66b7545fe8fdb2df7f59267e63969c3cf61ac1437dc5a75ff0e5ddbf5b56736f2aa8950272e652073a28436c61dd7072b144861aa85b9ed45cd766d9754fb75d100425f791b715d0cb490346acfc71a2445570159c4f16158cab089448855b4a7638a3c7eaf2f01aab4a22923d7bfc148ae4518ae54bff52455ed69a3103f663d7251657115a2e420b0adf996c76643789e0ec5c0f47af33e9e3cc734f077c1634a31a7fc0211fb886c056fbc7b43a9e9ebf75989283cfd243d8b17e6f646cd7c074cab54f1d6ccbb60c2a45e2ea6f2c7758bfe4208d122df6a226aae951907c0acd1c453e05b59c092c3efc987a3aa19178c6f450d3d91994f62a2fb37346262ea56b987ab47fe0dea312da90bb489bedfe1f1e52470768f4b28bf51fe84d6d19b371a0c288194856845e55f6f595457d8cc98e16aa820d8cd21599ec5d1425381b6628145c618c2907d76a467acc7f4be1075557c43dd4124e01ee54ec71003e22957061332a28df281e7af64d712d3c3a75379ac12f536e55a11930050e776d415db246f4ad95c7b83f3c33160fe5aff4bbcf95d70b90b3e07a064107ca7d0b01e563e7a352e019d318a294e4f561be061aa5885496b6e21a65bea32a75a9d55724c8d715e54b859a867fced03c33233862ec8cbc2048c2b9bcc6b4768c863dcfa9feed3c0bc0a696b0af100f569ea0fcec6af97e9bba86fe1d6ca3cd17b4087fe81ecf3c034b5ed9ed4483612fd9c5347cb16af73d97907d50dfac4eea994db57c9b35f51b0b7a63fa48466d52c583ca94b500ed5ae3e6e71496244505d5af1352944a65d3ffdf718a8bf4e3ba0d38a86861660bf32ad078474b273412bf2ba109f5aa83fe5c4983668a8b8088225608f0d71c917bdec0cc01fe66c5fe1c5c833257a5edb7692679e8aa67adce462432967d4c3d9cf361aaafc04839c655dda2c0c42a74187e4b7d057db5cf02c56a00df57cd84c9b98ef082babbed04d543671137668254d87ebfcdaeba6acb8e4357b7ca9bc5e2b70b6999bcc9f39b7aec56680182370161744c7604bbb2a2f1d61dd640f02cae9aa6e6cb90487bd111c54f2bdd8462ce753660a2abca988042408afb3c979cb553d13f84247b689a1e6ce4000bdcd30e0ca251e2ce1d631f22d92d5998a82488e5cd6d5ac9e76380442d895e5b27bcc4fc065157a26455e5dd1037396849fa234aed2e3c22a78b89c530e234ae61ed971aa0af00442755e5b8cde019ffbcbd6b1ddff986543a1a48a9a19e7de655879df628e2ee19eeb1afc179cd78699fa398152c5e095560012be971235892383852794d8868a181dd4091d670ba5922cad745afbc1cf208e3564d61391cf498772fd91461ef69f54a1d8d1cf446f0f00449981b5e3b6c77af4577a817e52875aa045bb3a3e40ca2b8d6ecfee1d3ee7883d06fc5332174c44d95b36c3b4526784b40d78c397cac99c4e35f66ba1da6fe91b973b9ffbacb5b77d29848c1e79a2addf2f8d692ec19651cb302e5182452165a490645a068e90280106ba05c6399e53f8a5b7fa9acfd6ba2be175bf6fb33d67694bcffebb030361ea78f1f215f43e32b796e71b164f0ce5ede9bef5c24822c30485dc7381a870043f425d7fcc70fe137b185dd9b6ec0ca141dbbdc16434815b98d2150655997be91696763e418aac20c4eeb7f757969c4b0e33db264f2a5d353ce54a33dd59b0589bcbb51bc730c589e1a0cd0ef95ff5aa5d2ac8285cfd39a0ac0520e78df5a9b724f771ac75ffaf635a789f68a0dcdc1febc68ca8802d84e6be294774746e3fa7e9e444306b0abc748e891774abb941aec92e3587385cb2239d00c2014b189177f174eefb9f7104755af3e67fc7a6367bba105fa2432603d2cd33d3a56c60377aad76d4921233246c8405c4a977e8e0857172a265c72ed70a8a64632f2de913214a270780d69f5fd9e56db16e5a0c5f5e40c84bb7df2f04f34001446a4268d0056e210d4062ce9d48a9904f8af1705e8d2bfa59555d3fae40bd7f187d7a13516f39fe0200b4cc9d1d5ec71d052808e13872332382440ddcb52a0e0b1575e0fdf514f662986c53094597bcc9f50d381ab8df27b723b81aa5137bed756d06257bff0ac3ad03a8367b0c116e3af1e6b3437ea32fe83090f65b936bb1db10360c9922ab79daab0b2fe8e51fd68f865ace80888877bbea8affbaea96d8e6494912f2dbdaac62fd44012bc6ee9e5ce1ea0646909bfcd0da75890a9e576fb8af8be71a8022ff4fec9d5a7af25ba28f47f01de71a249daafa270797d525d404597b489601859bfc4b5be53b37f03dd8e7f7a42e566e326c6b030b07ea7194d7b1be0663bcffe4187eb4647e0d7ef3616e92f5a98327dc2e2724dba8a72d7756649d3c97cfc372eae95a4a40debe40373803890ccbe8a1712494781446324ab83bf32ef7bd518cc79df81ce7a102d0568c491753e4a1a36692b31dcdd1239a9e3eee2e4d01282e92a327f3d52e4416e6ca8af012329cb9417b5b097cb8c7b443f9fb51fee9d5f64951f7494df67858186ca6c525a1628f67af60851f6f4f1faeece548d1e67855bc887fa75bf48bcad7da6a941c9b17a2b14956181507800d305150439c410424fc333f8723f14c45b23b0172ed8398757647c62dd87c799fb8b6e0e69d52d6ad1abfc247a20f48d6ac19069cec74ad10375fa6eda7d0b63bd04a7e3fb24d1eb4bc06abd24d09197ef542d02ca6b75f53dbbfc8598da3c634d8e5274b6d9abc4533d733a88033a43f37d36d26c12273ff4b5604b70287bb933383dd9d427c9dd2f4905e6aa7ab0907085bfb3e5c8ea106db311d765a77c7e63afab5f518891c28129bf25af0e704f861595a4324aed05ee34765aa4f9028a159ebab566b0317844345f5f8b9b278e13ad851c6fb7cec76f0d35063bdd8d31c4e0871a344ee513d842cd1c6799ffad3e5fe89743228acc852f12f1fb1e881874056bd952382f0e92f68889267d7c6269345745a90a4dd160c544fb0d048dd9f61904833a14ce9780173f97da7115714392111acaf586f0a45ba74137dd69173cce9c31fc84d08e52bbf20369c8894c4afc678636f5f051fa814cc616fda7f1bbdf0cc68bb70549ca6e0427b8b082ede35d556132ebabbdbc25cefb139dc26246d4241a8cf8027804b99e3cc236143ebb50077876690f7b1899044164461120cad985df656dda664da7017c759a65f38fcbabc4cc875ab10327c286deb34fa67122049390a2f2b32abc048b2ce1febe4838887286af6f76f3194e4e8ce74670a91bda927c17c4dbc37231c389a795ed12968c333d273d78818c92fbde2d8381935ab3c94b51bce747f957b5a9f8151c097e0cdec42b6c306a9ea44e0089a752645048353a80d493cec262c0306756329bc17ac023d0c1bd27263381bee7cdcdb4baf5ec83201cb53633c6aad04da9d1cc39e16802260b448d9e0dbeea6236caa4fda594bdcc096b4917315eba09100ef9e7a52710e219b5f164e6276397c9f99c154fbb1e4008037a03bd609266aab05f2640c19018c60ee6319e056919639d4346be26bd0e8782de983ef32869ec663271fa3cee81ff266509e324f3c5ace4908d96a8448a410d2d9d75336822e64503452fc42594e9b4d4a3897d88a1003667ef2b1b4184734892b2729f6f1d7f97a4dab02db3a8adafe453ed11cd960dffa3cc1cbf17f60afc936f6031d59c3b9961f513020c143c67f76bae33d49507a74aa89ce2e1650d6f328b5af6265cb681c966b0df6087983a1860a6ea7a33b1b6c81511f1896456233744e399246381b04aeb7a57092fb5c136682cb21e31d9e48b987b89c6fd1b5db59e2377d92fd0a7c65837d8c394fd6563f911de952ae981b15e664f19ccc1f08af679f5ca2f0b99267dc58db5b374c4bdaf44353fa743556a41bed176b3bfcb7d43aa75b04e3cff837bf53f8763157667f52cfe5b811fb0369bccebabd995bdb5865327984734d0b1e6cda13d7b33fe058d07bdd905451ca0c35758102591f364811c8383983f527d46b72c0ad8aa355a858bc95432dd7a3612a74c71e858aceec50245a62ea04f510576dfca0143b0fe6dfae5f83c366e63243f0fe27e0880adccc16e9a94553a4635261aea7add2784ecfea907dc287b45e560dd18762aded7e2d7c78f3d14495c430d9cedf2e3cecc0ee27e4de1c0921d5b5209d35b26e9dd5e3efb30d6cd2bdc2647ea89c498144083f1567e823c28a392e2e78d23cc8ce11b0079f25405f4c7b09d874f0b2adacf41dcaeffb1dd2ff6697363767819c3dafdc77b1d9a4175c70158069d3b72b53b4dace909830612d75dcfeb03500a162043e5c11ee934394faff3c3ac319138e411939d0fdba3471edff2f301a48982ba1cdc3c561c95cc4990f726d11abf340f3aa1ec4ab8e9f4fc93ca6edb45b4adabc3f72f927d581ce5364abac5544b1d425a5ddefb02768d76d7c6629665fb61ca66f030981fa9548fd658ca863034770d1a153908045acf6623186d09c6620d19123fadbbcaeee0d0dc572233c55f04a4b5848b09694f443a1161c03de4aa90373501fc38c0add4ceeb13fbc21e053c5bf67ef7f6f297a4cb4afcb90bdac0e7a85a90361d17c1781aabe95f28b6413ebf504ee1a945bdb23fdc6c04113450ddbc7ed6e6cd0ba8a4ed7dda4231e0133d30c2ca539b76399b233f92566447b34fddf3f340be5722c53d91208a43b541ccaf7a7c7bc87637d56e6c356db4b96c003f3785caf107c05d98e3c6a077a608ea34ff14fc42a644c1c2d33b6e053489838411d998f3ac5476296619209766a6fe60614d312c42c878d363ffde19faa5a1835a46292480653b8e9f5f9b7774ef550a790179fbddec1243161897a631aa0aaabc7ea6dc25ddacc72acd71b83cec30fb1696cadc544014e42be3acea97cd9efe3bece503ef3505d98eee3ecacb091cac806be7d3fbf6c6279028c22a39084db1dc2288d6408d3bdf2e9b5a38d320489e58397e75e5e6bd3f14848f2358759a84a1af416dbb1803a0e868ad8af6a79daa13be4e4bea94f33677d979170cb849e32e715ae11d4b02bf51c7467a3a687bec39aba8eca15cd31f6b37f42d78dfac482db38610f34182500aad7adaf9968581cdd4392baa600a92872c003a43b65bbfc9d1460b2c0da1ded1b2a9ecbecc13f6d22699bc86e8b5fcb1a1aad09144c524d54b6d9cd86dc45cc3bd9566083de06605113027f5d491a833a6260ad840c4257c71f331f6a1aa70b07679db0ee3b9af85bbc5fbc718aa5cd3d0ae45bea81fe686af25d7cd3dcd83e7e10b5876add4d208cbda74be638759e9040377fb36a711e25cc7ce031b2fb4a7cecf3e18a5a3e9ce330be6675954a33e15e3975ce6f6260cc23af947f6458bd56f9f990800ef574dc31ac4b25a674d66c2cde70390d447a55d7f6dae69cea5b16829667babc6977f7a40df61532ae46d16bc8068addd28449619a80dfca1e04a04db331c0808d6939316269193149fb58b4cbc2de6516296a9c783a8bf8c5fd23224819addfe5909f71b7f691940ee06564089c92dfd913b0dc4a3b415d52c4a5fcbefb7e998438466c0ab82c9dafeb5111a86345407f6188e4002a559fcd0fc4229aceda086a1413dbeef9dc2c84ed5faf0dcc4e929f902d5661ed4d2cd2577f8d0fc24a7d53f4d8510868b2920aa6f83867b4c704a8f6479986831c60f36b293d59f9e3259230df6cf798d51e8b2bc7de68374be4e1eaa505bfedba84288beba93b62956d0a8bb07c6692e68b4e8f491e6b879e6346437d5c532c1e2b420ad7f0ffa7c63e95f7ac12a48874f3a38bcbf72a416506ab8f91dff4f9b49fa116e9570f9a1458c0e0929f33ce684c0164d4fe1faad42c43d9588a47756665a82c337b9ce049881f854e0d368b09cb6e6f98c056de1e2b72a01a92c65b6ad4657b89c0a8a4b4e1352989b30332a50d4aa4fd7f19ccaa0e30428d64ec95ca44dca8d0adca20ea758bb1a130ecbf373a45301f91aaa1f6fab0ace79e1ca9e3316d5d352235054edb1944d217fc378e1b9233763d9dd2db138f4d0f61bab803572a591357c08779f2161d3a487bd47d62f138ede9b62b7e1ea83850cd5e40cea887ab4bf6748ec874de20cbbe46cad8d8f2724b97e585df0e5dd3a77e033ae48d38d013e6259b66a24980d48a10d6349e6dfe3b6185dcb95f4bc2464cbb8430429a016cbf5b278aa292b5212607743425efd865f06790a44bccc0243714e86d0f3f56c936e9a8daf854b10e2fda01721685bd8c58d83b3fc9ab5054138f9ff90afbe2ebcf606476129fa55c3e8bd6f44b6048d3e54f1550683e58ae89b8217fd0f66729c25f3516e225f88d78c75b3c0994b75121910a94a0c96f1057f49b52bf8d7d15c27a03b402431b57c1238e84539c12a2ab69e9fd6e17f03a2046364c360bbbd71a92240965cdd0b1f31b89c636eab9e631a8e12f24edeba57468f049790662ad284c8dbd99fb405965d7b76b9c9cee889c62ccf4f9f69fa6d5c91eb42162155142e25c6924bb450d46588ff4f253df8125294bab5e46abd89cf67d23c86e07c30e9f42b703c1b66e3d29a57ec160c68333d81bf447f0e044cc5e35a735916a8afe1a1f327519df7ac6c6dd626528995d10a987a7a2920fa582a7ce33a5d44d7569bb8bd5635ee2922f8192e87f03d0194265ae99a7fdac9b8687d2097031a9abfb50c4b71e03e0e0647c6ee84d0f0c624458cef7891abdeb1a372eb890f5cf3809efb265b8127827657fc99d8b3fd9d4e0feb91b826f68321f9fe9a3b3dd897d470ff4015c43c9fc9c9023864c4759edb2cab57ceb4c38aeebd1784456ff6e812da929757c09e47f9fd8ac09eb6866f69a226388c05dd06e71fc2b0a92c56f74b28441c386bb19f034747706b579108a2d940549cff6a8eedc837790a15015097390d5905197197c6b3eff6034530c538eb9545b59a4961a1957f65e268317fec09d02ff1841fbdd268c714d43977461a0ffdde82fa7f0cd4fa13cc34c68aab66cf4069817bacaf72c9fae780ba737fb545297cf60555d10aeecf1b44c35833a136ea7a0583f75194c44b63fbc600f3d03a07caaf1e02427181a44410563c89d4114845f5dfd72f1cb40d38c65b91784317afa2e83e0536669a72a6e0c29b7fce874c43f69d51977c8d6424a1110ff4d51cb67a477934b6b4a92eb47e1bfd493914d4f831a277dd368dce755de88dd8c7e56dba6df2b77e933351dd6a7a40d6973964eec9f7ab9ea78b7eaa39b74f731918d1575a7768bf49e67933ad522f37056a2996772573696c2d09dd09cdf0f798be6e6d90ca30ff1e5fb681e53284e00cf455f7c8aa777a2159eb73e728890ac93dc04e84d689b203cda3b2a636771cbcf2ebebed70865ff5479874ef74b49ddb3abe9b25c45d4d777fadbc74a6d93c7ca5e605d80d889d17a819ea009c2b3f6c9e1da586677da23c6bc1e3dd3300b4b6fede692a9e2a6eca6393c7edcad21917d53538f014e0cfff62d57457804b45e09773fd2d1b1fc42c3d28a605080450fe5e73647a7184239aa1418cb61a21c2160f38e3593708c13660bc226d820d6e905704d4c280cded8055dca14e1ff3041ccf3d40c583905d48aaf08ad4d309a8bcbdd759e8ddd10e70b0d2dd97655c6c8762029dd7a454cf120008fc006254f8ece4741409e0fde0822f2bc47d7c92c8ee74c87c8c81eb16328fd337f3ae97c39ffc463b31441ee0086dd9c034c13def8a76df397f6dedc0e34874816f086a1783e87e44be54b564daae588fd3bc29b7fe33bf8cff6772a9811ca8b3c101caa09c1a3f2d1c168034ecdcdf390d596668ecf6dc740c1a204c57425692b9eb23e646080cea95da5ff8bf5f1a0da1b224fd2df876c06b76c6dc3c00128bb7f81b64907512587248c27fda4c922f4cce8c57b381a7406e32e58d25f92f9d4e206c902456b1825e9939a316ce9f099092ed27c4fc427cafc8982f329b95ea081b71cfd57a1a072011f34c5d2e69d030b358121a91c350a59fb7d57bf8dda971550d52ec59fce6d2a14daa8a44d3fbddca060de681ccee1945b3d48153b1b532d40f70f68a0ba3e92f506e032a8d34a7443abb6c66e11132aa278e59071bd84a7ff4657272ce4a98448ab023dda349d21fed74f9103e9ec1bd692b14aea575a226b636f5c8ca00196908af13909c958f817167e5b836a32a817d8fe0e09737ad11f4c668ae1aa0f8ed2504bb4aaef868d87861ee35669a21a549c4b544bc6c40001960ba66f2334b8cb32f876dd6b3939f8399e8575e38f83c31e14b5cd41e14e17e97a92cbb07d39f30f96e38f3d73a00d5f581e4bf610cf3fdb9b7d7e54193e3f7c290544aee83f3f8f4c9714f93fa416b81e64728826330239db714ca12c42b532fcfd93cc6e8857b478f79764c0f0303b19ab4abf73320601ca181dd6d84cc77a8eda5de256ee25c71c0d10a2f1cc629a5d0082b3a507bc1f3c5a8dda8df9810a25719484a1884cd2e99e4148399df20671df69c32f4d8968997837ed325580f1ec585cb31d665266f7fc439181852125165c0ee65e0d00023d363617e0c1f9dbd47a672c6e1bc02fe19cbbf0937f82bada93027c2f7d3cbf41d39c67a35a8706337c0f415bbb5b754476c52568cf71fdbeb9b01ef1877ce2ab9fb2eb8a873f6d919c527de3376d87765bb6ea4addb0117d7502b7c84cf2299af39d64ccc010ddc1c7ff213155f8f342757ae89da79b0df775d0cd21e35cc0544810be37170e0d7cb06ae02b4dee5e786686c82452d171eaadc0129927fe3fdce4913a53bcc81be31807477a7cd7c5e3d47eb111285610a213ce07fc77a87ccad769cdeb0cb18f4ae04751932bf66faf75e430e8fde6d49147ff32c1f831d27c2931c2c3fba591222174433daeb8f3db71c7ff0709af65662d67eab50ca24352d3ced558d322c904ad0ff2a0693e2460e66f4ab4994b4481ea4050682d245004606555dd003dcd676a224725cfccae0e2c4ea3db580316b49fffa45ce77ee7016814f8db917ffe862addfdad653017215e3ec5e1984955a1fd959d086bc2d2a76efd66855334d096365a7f93d95deb507cf895fcddef8ca9135e8424b68cf32477574df245e02c9e9c5314bcb43babe295be100cb84055ce410fa910ac65044bf8c8f62a25a55622fa8665046a6da583471b98fd2c91915027a1b3997787e15069f74f0b34401c8d6e449a5dc5a1e51d7e6bdd43a3e530798435a61be0f0e110ac729e99b1d92f62d050c4b7969f703144ca24467f6bbf7451faf2ff6611554aee2217cb07db431832d42c93ea2925ffc2193ca63b50313b184e4bfdaf501c6cfb30a9ff3c4eda68f780dc768e3245974bd1b6e9f97ba7148253ca1ce295f0b0bbf01000797228e5386976593b35119353f2bf27de7b8f7d8d75b4c6e464ddf13e4ef35d479391bbeac9196eff80bd4f55bd4f559a679298f72868c5ddb8ff4bd99119b43dbef5c7b844d65607c04e0f09b924a3099d4638ac9f01fba41ea50ff1d48da40afed407216e9b546f0d5e9408cfe895293e8ac2e3b2bd6c30d933216b3ff8d3d87feb22f1ae3dc62e09af30fb95016655f715b0e00b6a41c56e7a494d2e184ea332d52c9cc3acac5e6faee3416cde7f1637015bf7a130b73e04ffc85d4a0831a4306bfae06ce35e2fdf1a45a9cd1f8e430134fccde47d39b4cd0edaf81fb0394875b08932901610a54d109ec37b62ef831f00b2cf5c59a447f68e3960528a58b13084c60c7916e766da7b51ac1ce2f8701a407416dc8eea628b38d23ffec3b3ee8173f7572cfb5e326783e5ecbe0f77856e69d9a5e47e33f4b0564d9c8c0d7f03031ad22e11f07c679dfb6090b669a691d3ab5f477eda749571988a35cf235a57bb037b7d822245d860257b8530ed5dc60602a37551674c6b61ae048c455ccdcd2a5c6ebe0164f489cbb449c334e4028f94adcd29399af0742ee6df6ed089c76ee7b653b1e1b40798e41acd2cd162a124a50016e90f6258e3f2e9a8126e1df67a17f029adc209e29f27c6d7052ea009cac27411a54deef85a4e5b5b97e6afec3b7cbd2ae1f1fbfe0b5c5817955768b820b783f4f318a9ff410bb0de47de5267a7ecd472e16b5025c06d067c371ea967b81d30be7abfccd74a69cf7b40a2a89ca58597e551a5e0e06f20473283524cca0fc1000aecae69b88dbfbc67844f549e087252c945623921c191e9f779d723c82c0427c88f1dafbbc1e647a3ddc348899ae8e4719bf0d6bd718051cb39d9c80dff31235e7cfe2c6b8242390620c29f55f5ea5fc3304696a527a81d8701dcc30fcc8038dbbfb8a5e823e6167404ee96ee3b388baa1637154950935dec57d9f7238105be594a0beda9b3a30015e390981ec5ef92c230e0a50e0b12cd4820373a712437798e6f4165a3c09ccb353c6cd7599f9046e9fe69387aa4330778385a8635040ce42cabf299acc408ace5e35f922849606bbc9b1bbab084748844b4f36ab18659702b36148e4c59e9f8d95f0acde4ee2da2534ff2190d3ff9f2fd52cb12e3ab00321a516e0c3b86203a264ce0359d714ce4dd6216a375666e77016dff90e86e999592b5767ed9a2721b2038d4ab8ee884a7966a42583a31c5d6d9cdf451e6cd3a6a778665673becd071c5ef6d4d0957e7c1383450f429c2e341b5a8fd5ec8a15cbbe64b3369b61f91295ad360883c3eeff30f6ed85c4a505327cbdc8060231d04ef0789311842b20922844581b94669da407fb8f8b8603730c9846c2d51c4b5740ea0183f10f02ea7da05ea708ce555a208bde46b2fed936f8e5fc260c5fcffe536693a4e12bc6ce59239ce6ff5ec5937f4883c78bc5213bf87615f0e221689f3779b2ad021541638634f037786d696c06267a6221475ad2473a3ae09f94d7ee49ee597cfd44246dcef21fcd389c7a593df12a53a1bb3b2bec7978cc5dd3c0a596c5f4d9053365ddd966e928240d640740a0fd6ea74d08ae1af26df5aab50a0dc05768959769b86451e0eecd02784f4f2c409693213ea8e912dbdb68dd3b6bb1793d92c11a7d4fd990a7cb1171969910d88c3eac5575ff47f22ea7d39b45ddfd44ee6b2056faf1ef287b025b3879a3cb3cadf7d2bfa3c598fed1537e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
