<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18f8ee0871f35ed9daede24c528cf4981d54439fcef65d5ad0e07f0a44c2595722f4d76903d27699259c03690069102a9c11860610d046372e08e27ed9697cb0c1ceeefa94a7b4cc055e358eedd459a919115ce4210624b2952ef0ee5baea82fcf4837cc5cb9f3bd67717edc2475638a4d156721fc144c9bdcb1c31f75af654b6502a606de908b8dad2a3adfe0dde99e80e6cc7381955dcb05c39881f0c9546c489f44f45cf0f9911052b79cad8e0698f8334a57a713a53b4d8a98a84b049392b0b594f0b6368ab773a2b5d286039550ddc31a781747e3657d67c4d190ca5514299e177bc5a8157947a5823c6ffe94786218e487567bf656c9e817617ef40f13b26f9f02d2afed9bca43de4df603094a84e1f6463e0243209d510ceb4c8dc4510b482d03d232e170fc107b29b955a009ce77b844ec2c3fc11f96671d508f43a3dd94dec9d36ccbd67194a270a7ca8b78f6c25c525d6ae7b2f4eab58ac92ea3481c7c49bb5240e36c23aa251240a31e83e39905074490f9e8d9e76281fcb604a70706c310bec6fafe871c90f774c12a41d9f6e825f29557649fb8d7b4b6d266c463b76e8cf3691dbafc942ed16813f14c5e77b359b6ba8f65e7cbb9033eac0cab63d767c7ff98dc799cdc32f21af878a123612cbdc7c3aa0e0cdf79ac51e75cc8e62167114d5cfed353b68d12967b755ccbb98b6a8ae68b0e859a0eebea005451a04c15acf3d13760f2f38539b110570698728eea61b7772ecf04ac58b9351372459db4120104ad773f21f57f5f98921aa1f3f28359796658babc2d93467aa3af7fd17b2c958acaf8d4467d90427c84898f6c6af17862d500e4ccfb8b0cb71ae136cebc78cd3efc8bfd7869ce070fc5d0e527bde98f291ffb352d28d8e05f2aacfd39669a5cfc2149d00f34caa7379f86a91ab9d758e7e576e09775d3c0858d46fe3939486b3bd0e1ad057033365357fc868fd9ba67d889e112eb2bf07b3e0798f5710b4985ad3975348a2a21f922ff250eb6dc488f1c9177e245cf3a48824092726e5fbdafe07a5e4c5b6a3fa0abe540e9f7bdbf51f6b998d07f1080537763e513b4630ea939f87254bfafa025adeee797659e7b2aa3294cf76cee46c1754f8ae5fd8c03ed39d9c76d4c3a065b96d195cd2ebf061be090ae4b47ea0c790e8d2545dc0dd95d469521bc2b25594e53034174af558a2eec416d62c16fa5fde480b66b4010a9038e2f41b79ab0db661a710a4056e4b623003e6c557b8a7431f20fddc0d844e2d7136c58ff6299491f629eaaf52412f52cf2fd9cc6ecc5849abb1e5abb0940cc995018ef36564273899118755032a6050d2c0507dd0d6b03a6f9bc3b5e5fc10833174de9de432e63223feec47a31d4e80da3bd24681f4e628b357ea0d895dc62e1658b33f474813a6386c64e73c71329b567d6360554b9f4e0f1927d573e1de4d276c645c56257c4de383997ae1d0339c9daf88fb44954f2e4d052d316380ae7e9da8000e643e8b67c24b5ab2cef87038d3ae25f462ef1bc356e2d66b203f78bf7ba3d92b3907170b6a09ca4849fb1c0973c5b07572779f155274cc56e187e25b9ab9fff14a508c204e63e984b6b9df4ef62384ab9dadfda8e041511493f885e037de3211cf7b988bec9d45c3504540c75b309b69243c35f2e8ed96fca30d6576a1ad7b1c959ae5ee7f0a2669478dd851f64e70ed94a99569bd9250ef1f4e8205f522bc1ffb7458ef77d772a84212dd3d7ceaf6485db0e3ea29e573d2741f48396b73dde67307ed888d2d4e6b7dc33eed90650baa54d37fec3482539b867ba384b1c3c16193ec24592ad41ec5e51c5cd1056d062a7d77ffa1fb527c2c29682bb234eac778b2302f57d19e388fbb35a635cc631e2790d499d0be71220365b12fd23db9e4ae34c97ccd1cc5d7e784ebdfd2a2b62e4d353146dc82bf3964631910861b97bd0508042a8b2efd7cc9b93c5195d899795234da366b7cef88a31a7fcb19ffcdeff8917c854269ac0b1118dba0e7b889d5e3c0fa925725dfb934a13d0dd70f482d81caf49ce2a64369a7dd5b8ca39adea2a1eee617a20f466a67fd31168203c0d7921a2ed5875ccd93583145cce4140fc66e071814993699ad1a78293f91807eac13f6083e1669fb54be54a2327de7d1d4458eceb70867a2e615242d0515623fa4832ee41aa3a9f4a6e0de31e376326a4d677cfaf53fad12c21c240e5edb9134f15a650bcb09d4441e2271bce539b5de94f8bfe80d119a20808f0ca4fadf6a876c8f81990a6e4a1f49e3a402fe1e0acfe43b17e09cad5d455ffc36b1d17af6cdfeb28e57404989b3e2c8d3602ba62c0872cf14eccf93ff190329710ef4b907cd9dabc3b8bd3c82b8f6284dbb9bfe4be344fab3ba33193467bd29d818fd4697b0a2a4dceab48c8f85420dc4b6e7ee9e1f6de50545cd7b7d23943c4106e70bc43c39587b6209d8d09f86058294b8ae1924a75583b36a827af8a32b6e1aa447978daa1678c3cc551c0fa39fd30498247e3e3d88a6680f3aae5a5c7e19b58b788f4180c92c1eb47172826ceebcdca0dd5f84e8fbf411e5f4fc4391176a53a216532c5f3463614cf631bf44bf0ba7e9b02ab37d27f7c949d7fa028aa7a0a57fd9cab3a47f2d76e8fa83f53eb929aa81878440c5b131cdd7597a35eba24c8426ef26c4d757b47c3202f792d06c89dfccf726c0eaf693b827e78f47fe8d55dca5d536988159605ba023302bbc91a041860ed502bc412c4ca7da3c063b2ab720e010ba3f0cd4e9b3b01823037999781555e4bfe6f0ed3fd87a558016581fff40ef6d195c62aefbe3f3c66bc8bb8c7103d5c843272eca097df8f5eaa36cbd7e3110d65e6e9a524dbf9b8b974fb5f769ce492948ffa0eb9c4ec9e599c8955964a71329c66d28ca8ff3c1ca384dd6e131277e1ada15fdff11ebb6c704ddc2ecb1cb6385c9bad94bd542aa7a196c6de816a5982ddd8e6b33c3f8465bca1ed09b501562ae938d35fdc3e888594048456f128da07561ed687aee471ea4368e63f61e4b382b51b26fef0eb845c28ad76d82316b801b5d13078547171cf3378dbaea99b62a52c6443127da0a9eef5ae8932b501cd8fda14389ae354167add1d22ff89a9a930eeb79c52ca9ec55d938ce73668cfe1d4e8202fb1e7493bf58d0cbaf161e012befdda75bbd44095d3e35bfdeb5214b9777796822187c77050f008d8e46943e7ab000972aa00ee9ad1bade3003e134e745eb9f39d1ec2f2103a367ba68ca7ea72b66648946b13f574e3bf1ab4180b022f3753d38044618e66c721b4c429c150e6d9dd260fdcd02bfc6fe7a443a73fe1032e0d77a8441cb576329a36f67ac5c3292423eb9249a7840a9db398722498330f16c8eaa8417274b8665da8172f745bdd0efe597b2a92b60f35acecc3d2f7359bd60d0b694d46672c2a2cfeffc1c5552032ee7a599c30be2ec7b7491945f64c62dadb1664c4d7eb4db8997c197f5f087f363ab10b83643666b7e1b947a2d2e616f5f72edf5076e432cca03e24d0b0fbc1f2b1b5d12a115abbd8f66d7333483a827687f4dbdcb03f05b0d6a8b82326091e361aca28e97924c2dc6cde560fdb9207df3d78ce20a35c4931d40c3fe1b1b530665249f49b5dae4e9044a71784d5e631f865742ef8d9783156f42cecc590a862c8fd02079815e2c2f1e9eafca437f785e03a3c84196a01c410deff4e9f857492096286cb7fe3bd31acb2965bd3b746bcf3acbea659e3b7b5e9f50fce1743392553909e716c0e78339fa3771a199d16defeb21e86579bf68f934cd3aed27a286f160173ce2dba9c3c05876d3c1efdd39fe263d9585210a327dc48785796d03791ad45cf10a3df5373038a5a565d0010042226dcef3c07282efc8fc346f4326fd6dd60b8e5872416bc33435f91e9427c3c5498eabbfc7454cc0a8ed95b41c5cb994ed5fe69585420cf3c1549dee2ba012ebb99cfd732e081a57037a6f0e8f96eb0de6ee630ed185e881fdb156a33699f7de9b6a52e3013ff51443f5f808e3ba965d0cf7dc48534567ce84c71b01e0ac22eb2df0eb0ea76123041570bfd9962dc9eaecdd591b62959f802914c878d52e8f17036750c69240903f125263eaa53501a7fbfde8bb2981889542b1d415031e59fd3b16b15250b9a02cff566a34dd67627da984d87afa52c6c9f00fbf2b1e9b6c023dc180b5a6d2834cc0f01c663b4e1213797464a9c1f183bd687e67cc4901ec5e03013ac0bdbfff3f4917bffd7326edcc8425d51a7599a9f2e5361a69a42326619dab48743295eb597adc04db8f4d3ea22fd4fbe9547be1d87b8c2cf9bb79b3b4af607d2bc2e36d08c66839eff6d8102fa1dbc111a65fd9991e466bfbf454858df430028a16312304c15d4759496d4f0865ad9ab5e1190277ef1893de966d590fbfe3359a06c4bf6983cf08ea2f71b7f2386df5bd33ad9595908e8ffbe99788d01c684f9ca463726271fd0e84d18e59ad5fa0b2629925d5d53ece71333c0af4bdd2aca9681569e7cb19a94223933366c0fb878db869a1e1b9ce74e806eb723b495a35802063d3fe82b2235ebc41fdac7baf34426387bce00bb32227544f06374856908157f9babd7253dcef070025279ac67e442e0cbcc236ed5e1d30fbdf160aeb0e61dc881fa9d374f876b811a5cd2ca6ba1e1fee83751432d2ed5a4a3ffdb10e6b2d279a722eb9805e34bf0a443a4fe552872762bdbfed5f21e404efdefc6c2d18fc1d4a96d1a53d1f74e549f92a3f4493c3dac8320127b8ccc07bfce9e953ce7cde1fb86ff7475d51947c1749868e0ee209bae7d508575db042843fd68031b68c052415af11edeee6363d9e56f14f5f8fcc2c6c9daddc73fe3f8e04d08e0612ed3f275b99b8e3f05f8e956aea5dda2f72a4747796c123311eb5539c4cc37c8de69580812c9574affcda3f801990f8ec7009cf3d872b8e1b1000fec013bc3646e219e791619360555b21438455766529d845e41e307792e76307c09d2cfbe5c88578852ccc2b9a7665ea5954e9ced134f91187159faf3abc25e762910707f7b5a364445018dec44ddad8aad6a826ccb9689199ccb029caf790d9ed351a2412da00a42b66b72b45b203b9cafd142ea482d006307075f2abca0f4fc30c67981fb2ab6c3dbefb070833ea8c7322122f043a92390bfd6e116136fcf3b87a433466120e90c16c10e55fc1ca1cc18c6ecada6d9b997a858f07c0def990ede3f9b948ac6042992237cafb9a7056989e7ef9e01a777675ad15a0d442f119b5445c1cd7c491043e77d53d87db3e046eed7a28a4b330f0b5cf398a73639578ba888bb84a473b1d14375ee0284d28ff3d65a6957c8fcf8b5dee25127230e81beb1a8a3295b717ec35a0d0c68b1ac431187db8cc55c7a5fe834844e45801fefd430b4f0157602d630ee962bc5f3cd8208360ae193d2b3ce75f1d0ce6ef79c257ec4627a434f0167431c4d5b78eaf5e997e7ffa76e1a2f0a544515f500f4ed046857ad3edb81f5f23ded921e13f28bcf0d56d5d4cfe0dc241f622cbc8f0d7db34259520b6fcb8e509f5842dc982940ea0425582c12c1105554fef9aa97d2083ad2d7336d445cfa5c6003a3a61cb9bd7e566231c36d5ca583946d65675421bbc895cfd16d480cf37700bc12f2c4f302c252fcf7596492e70d57e35ca850e706c12e10f0f515600cced55f848c2786c528e32ff6c98fed83f16689b87c111353ac90f7f2a5f6a51d3e3c1179df808a120ba7c048d40ee6a8aa8edcb96b48c7dc7a2e35ae80b6d8ed6c9c04623d4c9bf4d0bebfb1893a17a2343393b43aad84cc85808c927f2bc9252caf8555d6c6d1528cfb0b0cc035d2846ba7e468f9f1d20724966847aeb50989b444fba65fed60d3dc900f2ee2910572a3d3db5c0b2097b8cb710bd1146152187fce0da61f0e86c2706e64924643e20c167781e5b535fad72bcf53422eeb85636ea23190a928a107f8844e40ed062c653035e357f77a0ec26cee9a53836677814412befe42b6070f66434b8cc65ca1edacd6b8a7549333c2426acb0e4513b07a80700373592fb1cff9b07585486d771fa1db4f967b7d7006340d720f62847ea452c998ce50e76612cc44ae6aba5eff9824a8d9698cfd03abde23b367fed8ac25e7e2e9f2f0c48ca85926bb5937287345566aa4b8f5a21077b5b7c31fe73ac02b1ad70dad63cc03dc4c042dcaaf9da5f4aa19924fb2f99b44babb75cc663ff71c5e5d2b8d2d6a15439da033a0afa2ed8d988a4a8546295fdb934e42ca26b81164967367169e1f4487d5f0cf6a280ad682d2435d685b3209605a3600c09838a7cae167ff31b383acbf5cd67fbfb82f634e9f8a45f0b63eb6a622b4f1fa254d6a815b7bac277c55eac42f350719eee3312ec4e02f92b9b7620e2796bd709ab3866c83fb5ff0c0b56d73def6e477d6ce3b10b9263ae6b3d6bc08aedcf9b05173dc2d72602fbaae5c168075d09780f22e8c04364f9243addbf32a36e8800bf3d364bbe5efddb6ad63966c27d45f594e409d023d066a49e9d5aac11db269820ea0d327e32514bc387c5ad8f79dbbbe833feee0affae90f037cab378cd1c16bda7ded3a09414fd6f77bf8956d05fe0d8588f759d402f5cb217fc0c047d2dbe96cb968c9e52a596047bf13b440a0433e732ca7b50f52c267dc85d51d91b969862f8a1cff985df693dda11453547db59ae47a9edd4ad2b767d52f73f57459f80f0626b23e67175ad3e8276c5c490d2c6602d91993fe586e033a54a54608511ac2202b2088610af655ce99550f3a98b27c45f8fb6da0c0c515f0019172ba2a58f1fa1b6e739486f69d7ad4ef833a78428c7a36b6076f7029dba66dbcfeace0a63383683cbe52b189c58e6361d14e8192fdfd6aa35204afae0bc4e4fc9e6237e70340945681844393165ed0475a0987f83a3ed3c9138c96c5926a459117d26d500371cf2d24c3aa0a05567d32441a1d1e83dfd21cfe591a1b50aff7fa0c92f23656c22e5f159ca05fc76b3f3ae2e7299ad2b85979cbeb821dfa6422dda54ec349a3b8def4170d936d970bd1061af443beb334a67c3f339d141d0be0b85db3e6219c099a306f0490b7b96eeef83df8d928d10c634fb353da3623f7e2fc2455e12c4e3d49dff89bc8c966caf39e9871c413f833a2804600bcdd3661f33ad6612522e18e72db2d19801f43f2b9b752bd969d2d73391dacd7c4fd16646385880849200eb5a047b45f393ef7efcfd545858cd50bb903448d9da7146985ccb95cf4332771cd3bef1af92185d85a004cf710be2cf7f4cdfee1b6d718121c8055c337ffda8cdae7e3fdc514b0a3cc6ac915277b03097eb9da09768ec1cd96753a77aac4184053c9a68b1522590e60fbeed39226581c511331e4210d7d6a599b32053dc48dce854318b24a14773346499897637f5aa31178f1f30ce2c574c67fb1ecf6ced988e9fcc66c7f97fbdd004c5c754b5c720b9e2a67502f6a584ec51c848afae87d617e8c6d778aec5d07a4aa217aaec0ac652621bd567dba87bd1628b1c95713a9564437489718993ed5d23d889ff30c62f0119d9ddab62b89d0b902a28089b146a441c0dde6182f424f81221cfa7c44c31a16d39fd55c4ceb5426e318904f62f2beca7fc6d1c38e1a97d5a3f2a9c6459c00e5f0cd94ddbfd75a0ca6b037e488d053ee8df962687ffcd504b129a927a6cd3f9772f01e6b662dcc0532cb9d1f915511119a37e90d55700c44cdabefb250bebed502634a74b17a4a01b1999302f0ff901a09e4129598fac936eef0286070a3bb8d61cb56722a10655c3d48b6d13c775f2f284cdf9cf2e5d2012ed7a31dfa7d1c8d8b3ec06bf552e2740cd0f7fe3f7c3406aa7488b20cd4dd795fbd43e3e959e61bccfa265ffef503aa3de551883f737b48a7cad1abfa1df2a2c268847e7c8e56b9f98a2fc4008ee8d95ebe5dd36ef6cb34e1af8337ffdb058f5bf4026535de13396c6ed3153739f92788169c9abbe89ccf9c504b53051c14478afd234f470316fb9de5c83c7f8c8ac994f3e178037a1a9afb860d455c54de0a42a8011060427dd402846bca9b006ae29f5f19c4f9af96aa18f38d8cea8306977dbfdc5bcc6dbbaa175b54250ed71eca70714c06601f0d848f922a4b85ca4035061c062579f6b68340652060826361394b179b3a402fdb92dc918ae9c0d5e2c8c91e93d98c363d35e7b8bab86e4515c5990774e1c6efb2e3837af0cafbaadaa2b9453fa69d251e1d148f3cf86c09cb9a9f2abac0af3537c78c0dc9253933fd21a9bd57712a1027fb2383d0a2146594028ebdc0d546737a2fa5bee6cf6c62aac2396c66d51eb17a8c417746c1f445601f2cb7ae22eddc42fee5215ec0defff796a5869232b89c16f0a042bcb6c332c1755f1e3dcdd36c002f25e33a9cc2d0a40058fe669eb9530592eb3dce096bfbb69f3bd00ef51cfda09bc1f17b2b4736df6c446e7db9c649d95b5b79847a060c6d49d3bae8d2595efcb70b3327f5cb71ce19fabe8749fbbd25a219246a750fd1923fdcdd60a4aec1e387bfc3d43d32440edd8ed9025405b1fb4bb4e9569921f06105d9f99020e30035258c3e61b35fa5f91aedc657e8482ef8f397354e523129c11ec07c5cf6f126b6a5ed59e63d4a42d39974ebcbd39723c8ff1a0b1eac3afc9b3e894265e4c12222248bad5ca412e3be4c84ef5d51b988674c838f2560eef25e221eeb7d9993224f7e4e348304eb052005bfcbcc1a9d0ea75a2b8191c256747fad1f383bb08c8b7a57c5c89c65591588981498ea46b01cbfd017de63c605971ca484c64c97054c0468870d9b35abf81f717efe6ff36195081b0b3660adb31f78e86213f99244c5a0c62646ee031c76eea6c2684699b2c95960fed78ff87524c79b6efd88b124ced15df117670061e709d2fe730b372471817d0a499c493be62eb578a6046ca2f70d0963676cfe9592ab4dddedae53e2cdb73c03fb3484f1c79ff95c407117275c283f999da015cc9c4de276742391de50b5d96b3a3a86fa5bd6e206dcffe171a704751bab962ea4d3df8db57da1811d91ee1e16a8991b48ebc35d08ea29bcc3080f5e1be5ff4ed2ee1b29a5e2d04d9d2607b8ee45eb8490083eedc0e0e9e67e261de6ac761472a8c2e115b3c31f611839480d3ec39ec29741f4049892e3779fd53e03b1686855f33b91361df193f46824c72149d2e4980ca571c5e991fbf597a5e8ad78bde086c51044a50b068cd53d96b3fc264ef8b1514064450ea5c75209ff05b271133bd0d44c83126443bb8fb10b9fde152c75cc7b7644ada52df56f24345aef6cf828b3eb7252471e6562a642aa7c825d91e8f529783d28f7e5d3daa463e6609d77ca1ce93e661011f1642ccbad0b4d1dd9d0f657834bdbb08de95791be46088358182973bb58e420a389767618c9f6d96bbff55058b1ff78e4beb54162862f20e169c11d01895d26f909a344a65be9f9752bd0d99c7f65a0bb1cae93cc5eca8478ab054a6e1ed62c182426dc21148f687aa74f1640147cfd95668e04c908557a9eb7da1fb9b60c251bc5641763d0cc97a963ce8a96850203b784d356b9acf78104ae0bb4e28653d9bdb9abec66961936f18a1864b86617b585a7624882293970911fc59bb011c61cfe752e351f2613a195372392b84a343e35067fe1793b54f05c39144713d6914c114edd1f085dd23c10f6e3b1a429cb14cd8b6153b643db844854a987f4f04b7c8ebdcf1a186cfe0a560a15dbca6e8f3f21af540b71491712c351cd69a500e14434891d95984aa73d70ce789640d3bd32e187a8ecd066a09196dd0adbafed5b45aa6e2b810c51c21b13265ea603d595fdf4e832c618f3efc73f536b6b596f2e18df56f9719176cb209e7b45db46c9ac32987de8105abb3df20ac190eeb7d3bf0e3157dd23c4352e50da407faa8bd7341e235bfa1a2b28cc4fafbaed31ea323df90e6caee020e94ccf0fcf331aff9b7bb8fac34085655adfebe6e35568ccdb5a77812ebe998e70702c5a45f748396e6c8dcecb74c4a7a3ee373693cbbe7a8632a5daae9c8b6afcccd92c7eb28fcde592da6b9e353c1241183f51faf8867403259d0f81fdc87914d21c5fbb54ae9d0015524be5e94b960b87f8333378df6d573fe9dd292cc66f9406cbad873f29c1421da0b632592df88f6fee5ecd973251fbd6c571b31a6c78064b21f76a5b142d517be35ca348087e29617c235214a6e56c97d9ec6eac2e464719f965de3cfffa82a9822db4e2ea1360e4866d1b99237418635b0238933fac34427515c9a59394139c1043364c00c1c830a7fb5e2f910b57bc517c6bb88e33f405d4b193764d008b6998bd13ed81194bf33435938274911e843670b6d256877472d316ede181e197c48e9b114a531b337f67f87fa8d8c91d5b8e6e17525fbaf530a3a0be977fab39a28c70d7152f56af8d024e3469857aa67653dbe28895595992cb0712fea816818c71997c0f696024ba999e5b07ec34276cfffcb88de9776c357d9585cb2aa89e2d969bfa3ab6a9276e21444cb6510ee14e24083e2f69ba656edb58fb7c896d3e55b80eb064ecd85904322143a2ceb936141ca96139ad6a45cdaedde222f2b565633db5ce3b0c1839f181be4fc0c97e8adbc9d73b37dccd8ddf313e4ffa0e923b49122686e90d7a1f5acf59dde86b2427d529df0d351eb32fbca335ebc1b0745685d6f59315a4d454b1b872149018bb5467bbd328ed38a7beeb32b6abc12806973f463b3e9c8c5195ecfa9afdbdfec9f9970ef0f093269edd3e9127a1be83bc1757c10d0e632a69ad8eec294f131840ae3d466e99fc793a2637b51ccf82c532c7b8c77c8c6cb2f10d19c09f6fb126be944d5be4fc84c37e17e9844f0f313fff7ce92e896e518e3438294d167458551695a691b643b4854c5b1e70a856447c5a60ff9d8137afaa723a88bb66b7228d62b9fc65909aabe56f210dded6f3c08c3c12f94fe0999077e1ae815397f20b5a45f2947438297e9426a2eab304e8780e2726ef892b5aa07499fd8e4c0fa555d9dcf79c38f742940eb3d2112e4152da4a3f140b2199799d0f3ef7ac249f7e5782d979702fd903df58524c3edee7cbbf75f05461f9e545cf72b5667970f88d847fde13490ed32fff1c1ccf9b873b2b11d9074d28c958d7597c24fb6319ea3e37d9d927e7036fe24fd3f690d6ca4fd8aa1ef514c05219756ede99761992af5d520b4bf2be195a8043fb002305b2b545e5717281f97c42d6e3c7d6cbdfa5c61b75095d181a99066110328cf320db64db10582b6abb7b1af64b4a843c78cbcbe5fafc1b1c69cbbb9833ef1c3bcb39c21528b25f650ad13351e9f2be8a9702cb5a88b384a86209bc7ea04ab9eaec62257cc8745f15c893e64f40a0e522db1fe9eeff6d6025ff570acdd1dc48cbe7856bc2b244ade799754a3cd8fc3b550bc8ca1c952b40a369927850b7192e3501f1f38471a2b895add69e6e763e8b51a505d69424c328695bca99df2dd8cef017bdc58b1e1f6c3b6142e9b6aa6ea9076de55a1f4cf336c5e195e5832290068bad744c57f897adb31ce939daf2c7603afdf88838400db499a4735822fc9c3d4280fccbe831169cb755f51fc2b6dce84830689b15e602595d9807ff9c148d76a84d3969875fa4f5041caa82372247b03e2b90f93d1b3b803b0ec099e7331227c8ed99d0fdb270876b27b599b766ea63247cae720f788fce441e6946f2fc0ccf97a89180a5ad9f4cfa8bf4f89ee879f66756cd297cca022d6008b4b03adb946e095f233f41c4148ec2854b13e4b687fa45341f88ddf7cb6f986190add7dbfef84002188ef1b3964800d706bc65a3c47c934940e89d736d9c07e3bf681a8d320e0599a6f5564ad035345561d2bbde5505cadc74a7ecb148aa36ff14239c57919ffcdf3b2844d69aecf34f8ed3b97a134d1f200444866de2954e16b4d9dfecc22839bb2d9fc37f053c6c6fa8e731fe0251cbb64ce04d59654cb11e0f7af55413b6cf840bd5a757f4cb89234174cdb7b68a61a0d814e99d435979c152de5a60cc994b5b018a736bb961b992e7287238c9de5ab298c72dde0fbaf03bdce70d77c85303580737969bcae1312854ca6a380ed8dbf7ddd77304c1ef7bc9b801b268d55327e269686b7ba27ca9702780b832502d3bd0ded781bc2c6b19d2632ec5b3741eefff7b27ee0c4eac0f599baa5e93f571fb07fd69e32408773ff6bacab942127c8c94d4860413f0dc4fe174fbc846630d931392c9f69f12014a55efe45f5e18355720800860941ce994de740531e78626d932862c69e9ecb0bc9fc47217383d49667f7ca22bfc8ddfd0d21b4fc1ba37844617f01d3325ba500609d8ebb794aa2da1b4808d529e43547f9f7d4a9ede600d40435d83d8a3429dcd43eb8f9c733469f5230ccd0b0e2a7f3d6a6378ec9a5260c509f2dde031555a55c72d4bd18faf8b7e69fdb6273f76b042b2f952b667321424a90fc51904c81d2360caf797ce31f71a6c88dd309010ccb8ab895727ec3f173cf0304beaf11c9c91b0676852b6a05f28ea92cbc6a2105a731e01c0001228376f722be28bb4e215f956d53f9b433f02e45fc99367b9ac47a2f7a254530bd163ba984936d61023bb2e4865a9c6b9eabf5af1da95ccc3a90b2564115a348876c9776ede8796d88d0c0a5063ecddb59161b3218ebf553347de867f59c4aa6e0d5f2a19f01db49b630008782d4d1b03411848280d79818bd07a3da096c7dbdacaed735fbea6d8e92d0e90cfab60c95fc6da4088c11b1a91512a70ab977d8deae0ccc8be012fe5296a20c8d926b291117873ab50c334c83786a083d677beb8cb09358f9c7c892efb40b7a98061e8fb29551b57265b5fd1029107f083b370fbbce68343fc421e09d3e4da53adc6deb4273ac11bf7d39d052ac7ea2b5aad63a7c9a1cbfada9c4813fa26a7c3ca5659acbd1beb7b245e244d265a190c1ed6b9ff26385c05627a437c6b435edabc8dc4feb258a353de65e82ca16a8807312f4ced4bf250e2c07f0db3b4f917b989490ada90715d89af5d48286ebbad91815ee4ca843ede194fe8e4ae35c8b7f64a458d57dcd1e01312120b569a32ff498f4e22d5aa625120aef53d1a1c332bb00c5f1c3f431a69421118b33c9f39e73064e3b15ab6b4b35dfe3faefead14a26182a7f20375399165821bcfd67b110b819c9460ccae6d43defba39a24d6396773466e7cf2666523f16762ca3e44ab0e1a1a738107f57531076e958426919cfd512f2ce7fffd381ba22e9da68b1ddc6d9a1bd3876d9acc089f3302a6c4e8fbf68df5f8353071b4c8018f54f36d78c4e229d4ca4a30f5b6b8f3ce973f591805caf54c028177b256fd646eb30199db9309f1261ac328ca85bc489f9431c237df743c6b40ecf81932a530f03535764e9bf64b4b475a5ac4b9bba1ed5a460188d1a4f2d7f48377fd6765f6b0228910af3b14f445594eddd892bee81cfa29097eb7b2bb78febce316e497141bf2bd15a814b73c826df0a36376f01bdf77b2f5dc8e07ec780b6bf5922c53d580bb0e0b52a5464c90923874f421b7eea98fcbbcc9c06cbe266287400e10a1b46f1633b2343ad2e97fb2bc7484d78c8a821599de5e69a2b7c960d99a14ba568e32c73ddd745f90d8f632ad84f76b91bf00368b75c858d20458afa16d12f90ad5f015daa27a19cb42d9565cca32d2c6accf285a9a1a28a16f510c490d9f6636782a78da082cec33830270f262b21ccdb5d8429945d328c668daf6f8fc3cba79db28e01bbe96efe86a2fdef3d8037c78db5efffdf325fb1056c073686bc00857d5ef2ebc1bc482adb5f8ff9155a684c959588f8cae1088ceae1ffe621191ba59d1aafc1ed40dabc69c9b9300ee54b63951a669409d7e12c65dfb77e294198ea8d8b2b3ffcdb4eec4a48f566306d43f19884cd1858a15a5757b4a00988c08584014a34a2fb5541cd15c3ac2f9c6392f2c49046160dc8cd8c31ff4967c48c8cd6929975980cb448d35cbdfd7ee7c987406bc20e8775351a791ebce99fecd233f2c82e28b11a7185750913ae1bcf49344e527b8fdc0badb6a27c4282c85ea04127edc5ea5f62ca5ec5e6e42244f6221323e5478d16323c3146816426e8f4e83d252db6986f4443d3ae3bd9297caa7464a2c7257d3694362fd5efe1957ca879b296722f89d5b10333320bcc790d47618310ffc83e6f58fd4a65554aa3b58067044fd44f8b10f5e6f7370e278e5a007403126778a80791adee91be04093d524ddd4452550b05e666711064046b14f5a972213ccfa43f39c0cc635ee302ead5f67b7dd0b53cc3630d7ba87953b4420032f39b6508512d36d9b2524bff15fca3a033abdf78dc10b5bf9c5cd026fffa9bc582ee7c351e91dad367aee32ab7c921112d6c8b9b56955a8f6d45e821ef4b19f7dd53428460588a3962d1e46260fb1d30e6ff423e1832196a5838ec62822ec4b80f972ec5cc5b191035a897c63f12c3cd46e9d9a8f01fbf6396339057e98b8a419745cd41ca33793c1ec5492f7f5b531f5b72037fc06d5fefe492b02ac2bd27b98de1297691077aa4b6cb752d5fd3c54f0f7cb1cb4f613193131e23eeac5df727de55097b3dad95620d84d9a699c895d6e65a9807a4bf0241e252313ff147d22ab5604cde3455f03b604dd5bfeaab1e167c6777e36d1c5e8d2b1c57658c832f61a8d708c56165456b3ae120bd6133257aae2c110c9921ef061db472ccbc8e0c64b0b2bdda4ff85f1f8d9bae5bb0cc1bef209356828067254162f288439fc53dbfdcf40e379d109b963fc114f123b2acabe6bc4783560591fca53edcb163f5242f9e03642ca0ce7cb8aaaeab5d76eb8e835cbce26b7f45f32120c2ee5ea2a64e7bb9577f7a48f5bd3884133b88e41388d0de5c9f8c9aebe313ffc80b65021dbd6cd297069b4df339e59a613562d98289553d8984981f3f8623a963354c9f449f57a48e01c7085cdcda32224367c85d913de75f4e846913fde6f6fd4ff42f40628d75a37f3901612242c02c3470613f837aeca68db7bf87d119b212995e702f26a97b45c1432b84f52c02536dff1aadf612f37428b63770af14000dcd1f19cf58ea28ab6f4334314c218635a2efbe2a8b78ef034d2540ab2bb15e1f86fd842f0f94ab9227602a06f68a02faf295bf47ed91085b071f99a301aad4b1999cc70be33c870d41a20c5f8bd6812edf97767c06a72b850c419514142b0401715e3bbed0b98f0ff0c31f1a6af54a0c69a52364cd096aa87761fb964b03fbef1f7061129d3392b10791b06aec31160fc935511c75f54b6a1914235cd97935a7df0fde4d50d3d6f341a689eb01959c29af7661fee7a9e3a1f50af10eb18be973e6593bb918dd4f69cbc04347a51bd153cfd992488d7a64ce98c1fd0df38205e775c9f20d4a5d734322318b92fb6d7a86c69dcd7cb4a1f713409b13ab8dad64b97fb23fcf0c0759e956911a1efa959255544a39209f0e73248c661458527f28b1e1a419bafd1d968cd05c1b5609e579fa3a8dc3739fd7d32a5e851449b5f8ad9a9acf1a825cc3744eb5b48f32d908f69b232a2615c6cb13fc0c83a3a7eca8dd24ebb4508e93a4b669dde65a0368f6b4cb7406ee156f757c538794336c34c56b7e2115b4b179c26b1ac8aa0c57e97cd2329a1ce22e00ac7db6a674cf3f770011dff16d1f247992917bcb17c3d4d7f9cde431b7be9c122d63de7b24487c44fcb3e47daaeb4e9daf3a918a7406d26cf72d7a11d5f1f8cc415c391a9bcfc48cca88d82a6273b178569c79cb46151b738fbaab83521fa957d9e9bbbeb10c7bf2f2e235a0e402199ceccab0d6c0dd5018055ebb3b021d59a0be1a7c48da1b6199e227b8391dcfb20ae7d05ff48a78422283e8c004a9984d261032c8fc88839dd0f09be3be738ad2d4f2461369e97c547445c175e714b40936bdca5f8838e30524129f8c286cfa38e86fb1bbc75a13c5a41109041b0f12f4606414c19276f58ec6793769abd80113a6a1a4c8def05bb2661dc51773c63d5f8802476121f6de13fbc10d56da7123ba10276eb8d80c651a2f7e675d76e2b7bdb7fdd81b8f7c027a4068acbc92d76911f30e37be31189a375a54544d3e9770ab6982a29d34a8b8402afd0d9ebfeb5208df7ecb862e88c404a33f9f74b19d70b5174ec83f723ad82e8f38ecadab275195991936d4bc53eec29bc975884ee45aaac7cd0459f826c04b0753d356d3f6e0ab87d24a98719c52ba2aae6fdab71d4fcd7bf38868ad1175f22608e2074da58ab39747b61acd74c621846785967e0d2a44b62254af1e2eaab96d3c4f80e3634f481b43bf1f6b89133cdafbbb6736f5a74c71b6c422424b096483f3656363192530429b0762e33d972ec9122708417874635fe8aef3798c98827e03ac4561bfb3c4de5a7364947fcea07935c7c71b3cf263ed059d127968e41119fe65a4e1af04e252f956c98a14b513be421162335e6fb60dfbf4b6afb769e85874a6d3bbcc7232e8d79684086d95c95ac9215c12250eb7f26c29bae25e873a33ad5ce2f19640624801016b7abc9bc1e8432f4aa5d34cc3b3bb3a1e6c5a549a909cb412b8a22f9be0fc479c4c7431067079374fbbc9b99d5ea088572382745e38139e3c3257a1f6929eab8428a1be2d919981376fdd1744ce7096ff12424be500e1072f69fdd3cc88dc3d7912de3132fa1967f5b01e2f944e17276084026b3e86bb0b4bd2b34824fabc23425c6b60283a66ee2d7dbc863dc6ba1cf90a043dc8d98d8b6b37f7eb4a3c9633f176e855ec8d564a9d980a60bd18b212ee4c81b506aa7aa9ded7cc9261979d5aa8d303e0149b13ba080934fd36705420f4badb4d335541151bed36b42467fbba75d4917c58d84e47ed45d8310ad5c65791ed7d760efc0f39c7c57086fd60e8a21543003179151e82e2f85ac4a2f1126faa82ce4ca520d34015401e653edbc0a8931c888dc98eb1658bc81c6bbda5ff26bba81b9baa0a02614bb0bdec0050d74ef89505007bc5421cbc312c81f5738836375362b60b84e25cb4410208393e4503ed36d994e65926322b2f54919d87b6649c050ecea3cd962bbf74e283e9cef9cc5622e7265a3394c731ec9e8993c57dac223e1f6c3b847ef6f131804d47686d2f1b48f8538ed18c6f65a48e140c8614e3d6e53219cdab7c0b41078ab6633b6f6db336e35c9d0df37ba4711e70dded92826500389f42fd976f13b71356d7f1742b6a971650cc3caa450d0f0c42f5e50dafb01cb7e5985327658d0fe3e2e0994faaea80f384265f529e9904d45face61a6dcd826dfea41aa188aecea375a463a64e4e9158d3c4aa7cf6d660db99cc7a6b06e3b43f3ed833ae0c36f4af5bada91f5c7bc741c4dc049c28265c00ca24fd9753b2cbadbcbfdd90c3e413d239d9d409d6a79a19614765a6016e4cb2766e96a5c55ec4f9c40270520a6e38286cf593dfd70a44833f9a187dbcf7c50c8681f09212a5c4d61a8c8a6b67203748e63a2d95b070c6cf210dc8a06f0b8d6496663f1ab6f2d0cfe65f192366cbb75a20f0948d49c16c6165bf037b886e1c95bfa4ba7c766971b857b5e4c7a947cf6e02b5c2b8ac5ae6efec32a62c25709dd7add0fd9bcf5de6d2d5ccf5441a4f4694a331109fce5db2549bf9dbe83cacd3e1397d7268429c69c2bcf5dd495213b3b83cea036c4fa4ecb3a3db6f70537fcdf4f16d209ad3da7283a8f7e6974c21a17306157b7dddaddf5cbd5bf0e6636c235d241f99b2d0fcd27837e933878173831faaeecfc507551419a236060e724bd9f11e4ed6b1dce633b94ced8d583426caefea585937815d4d1d110ba025341a10fba723c932a41c71638dc0e3702171a1188295ae889685ebabf9aa6c1b72e3953624291478b7c9502e6db6c9cb91648c62e504a4f75859687c442def3296e8e48a99647120a9e7891ac546911fc29aa4c58672c937a105320b903b2eacef3bfa52de19c6e0de188495b881fa82edd61eabc07b24c7361d8680f6b2b52c2de2d7fb36406c6bacad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
