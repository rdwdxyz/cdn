<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44b11d343c5c0167b2eb8f9bbcce007c57a0e310f19b5d78fd19bfdb291bbce21e985f05e6ba57f306be1eac443f188944f012012b78d7ac893f0ab3fc537f944164c3eaf7dbecae9a90cab69a4a637ff3cbba50792ee1483ab924ac8ebcb4f1eee95cd6cb7b80aeebf81b05121c150190333fc1cce7a5e7fc66b6020889c7280f73f3a8773fd9fb7aa6447db35dde96589e2d7b57c0445f28c1f21a03895e84336dce9e7eecb3bef5d1a6ace4290b4577d5b152bccab0c2c3bf35966d78613e40ac5fa3a8c39205f0ef48a8d706fb46e1f0ca3eef60cdf121aa05984a988a7ad47cbd6b687d3aaf54397dbf3effceb25e538567b71949d975d7e512d79f82fdf34420ee1c882121f5f499053fcac373d7dc8d1770a8ae62d14464848d6f3a05350fe046b13c28b7fef71f02db622071ec63f01465cd5169ba4c74b24e1969f878aea868092e8d27f7cc24e53be8b3fb153676838350b4af704a5fe1aed702f88c57b02db94bedad638a4e92c23a8bc38e9d56464035c0c4a1ddd002144380c912b13a3320609551a34d9d165732c7b414cc522087c471fbb7d6fff9e73c2bfe90ea665c7c247d66db84feb198062decc013155dd0cec134f73df5189aef7be3695d9146bc68e92144fd8f7c940a05b0beb373e5082f6d5e2668ace186c5dcdcb90fe590d5abc8e9392bfa38d0c1a505b7f197345ecb4d26afe6d87f065ef15200b59d4bfb9f8b39705a094b95b28502ecfb82c5d9e72beda7ecc7387e7df3358d3407853b9c613bd160935fd8237f09143aaf931d2e54e48821e768cd959535fd75b521fb9ecbd4e21c6caabac9834118fc4d6aeb27836b193e4f0c9cfeddbabc71135bd8ac319edb4e6d1d2fc4c8592ef1f928f98858cfc7d1730af80edc0a93a9529b65bf6a3c1ca17557ade38105de754a529fcb0be5f15a4bc937bb7b7f76ba2065778c8df53d828a556272d2c846d48eb0d60937f6a463439ed658002d3a437951312e767d57b9399fa192262bf9977463f63aba5b139bfdefd3c1c24ea3030cd08d52e0cee39e114027b030070799efbfc8ed71ab7e5c0d1e495f3e8bab567d296b6171511467d482c167631797446ff4f9c9061c0f4a155faf5e9d8827cd4745d3385f37ae966c2f9e234604338aafcee64ff47d6b1c4ad6f3c481eac92f3e3c6f614b91d797c57eba6f849b097a68e641c372297a3c54dd9a5f885a6cfbca4468765f65e199737582e5886ea3e50ccdcc3e16d0b2604b6f52e52a0e66b7e04d73a245db63594e26b98bd7ae1707f7028cdcbb82b2a788dd91ffbd6b22a217278addcee329e865439bbd8dfe6ca4ef5f040509c76baf5e95f23d802205a1887e55745fffcbbd86969feaa727938007c8ff078f3a33cdfbba92e9681c39b7381c31373997965443f179de29f313477e6410dfd2ae34e7fb8c99d0eddcac216afcb7b3c7f4767a3be90949f3256b9b46d6206aec861775a9c80843aa7a54cb1474470f1eccdcdf92e34152026be4b10f74b4f150805b233a8772e7f4cddc675ccbca375994cb2c00563279cead32197addf29de503e3d4a5ecb80a4fea268827a9fb037c6984c2aa974a353a4569e208229078a6785970501f2298ee584d440be1c27bb60aaaca995f6798181e460403676bb7cc462a03cd145cc92743446bbe5af2241ba95fa54479d23ed3e624709b2e2e6262cb05f5ebbb8aaf03d24d02b4967171f7540b13b9db2f9918f870ba822b60ccba21477986f9dc5dde69b701a4748fb15558752ec0c0c286c58f8c3e5dbad81b61beefa4ba32f82070f6c55d1c0e8b9252e8bc1ceb6551345d99c093f83351ceb65912943bcc22e20b0a187341b6b22326720466b8fbcc5110590b7f7a67edb8cc4b491d5b3de5bddffde52ac2cda5c181f1028a8a4bd1fc9830c2bbf5acd52d1bea5a9b87cbaa087c7207319c43550ba57c353b9f6cd53ae29ed43026a36eb1ddfdc2febae2dc98ac3a22fcc8b55255c5fbf6be876dad49f3d1b29f5b0b6f78d9d1931e7edc69fbc3465f9057c2ca3d2eb5cb7b225049cafc2c023906071bdce9cff948f7099a7af9a7fff4d8b28126faf1bc4b5f7f841a367f9c7356bbe09aa2bc5897386eade345da2d7dfe16fcdf557df5f145b328d88ff1bbcdb2da572d4cc9a078e66f668f458631e67ba6665cce726a3dc312907d92c738fc021b1ce572a8b20bd79c6f2fc371f3001aef217aa85d8027a393caa19d30374939407ef3c8e7c713ac36c234afc92acd404a9c4ee89af63b92f79e6036e196c7228a58da03c993132d1c91ab543ccb00c79d8efe25a92e96be8d271ce767718f644f917d9f2bc2fd89cea2f87f88f30155c6ed5a0576b867c4ec8ccd1482b2d590b0fd0283e1834a062dd956f9549fa633b11fa115e650779f4e3d7da7b31e188de570bd15722252b3cfaf0cdfdb6f81f7734c39e9d7ed170ad3bd81d060be44c483a93b3241eaa9cffd11fc9b66fa8c05b35e41dec11f54b0871ece9897d5f153575aaf4de60b7171eebc24733a2b4879aa0ac22f8c391fb9f4958befd88f2df41327e346472bb36b32bd2341dec556f266354fe2570fc4eb84d489a768c4e8bdc0050689c367bbb5700129fef62b939abf2c1b1977e83aeb9a948a0adff3aae93210791d9a784d5ee7a9e6f93b615e9770a1b6715e28164854f5bef1cb6e3158139a8b46fb1ef5354d46e79f0c6201c126f9b35fce8e4099aaf4464715856df83d29a3137883f6d698a8080e545f954305c6b0c5ec4ac098b932e00bea590cefcee9c7b211c06a33f5da98d8092b3f8290899e84e831d57d4f006a2f4ecf2ba4d8e2304f8eb8646e322ef34181e7bfc794d8bdc32da923e34b8b11ca9ec9367a1112792a65fc95629357f8c66deda1d28161b0a54af077d82997e005a8bead08c5b0481d71bc616f8a27c7848e3bada935237fc315a344d1db61b722e99abc04246fb5e44fd5fa654e0d4a2d9074708306bde84566004576fb6fa7c4729029576e12e240cce564c0c8c3bc12f04bd74a166871783ac46d7a60cfcefa70b85fb7d4c61255edcd02707fd24282c252e2a35b2daa02f96b0f35afd174ae0ff7a0776a0b09204aec3176239cf46ca1d376c08b946dd9c429aab90a7a0891a98accfc6660534d089a55ccdb6f2d13a8c0594597a572018e79766841943c68c3481c7e704931bcdab7e9aa8826fae088942fde24639e7cb902a4557a06e585981f975c6c96cf874a727408cc2b61d364ff732bc9314b3dc0569ceca2d0e6963d6274df69392f6e80f27d03f20070e7ea633bf597f5bd2d5ebcf80b52c0f35ef71f205c99652940dd19901ce7f79f6264cbb2fa56d74dfd56223e5ac6f725a2d61c23563dd3c69fb04bf5276b5e24d99f9abcd24fe0a77fb51cbc814887d72ebefa80fb434be1eaad47231fe08f11772119bdc5b60367b4761def38c02059a8c54125f9242b9760511c7416cddfed173f9465939c04958572c98f2acb3871e2d30800c46199f83c1025e5c5a950d03f4e35bb264b9ccf426579ed622554584c8685b01f890c524247349a7bad6357a53adb56379e59d73f3050568e6bb6b1c4a163fbbc66f0b69b77b011757b806c5f6c81c17ba57b05775aba6c07ab0af350e723d5a16e89faefc95de37ca0340e2f5ed33f8b8ec3fb04ed78fefbc7cade6ad53d0a3c3ce5ef5d486305d78e6517203faf73c169394b59db0902693d60d0729bda7b443e3f1f0ba877e75b6967b4a31cf0ca9016e7d90fbd2ef6caa0e7868a2a85367fd4f3d85fdd27650213da8019572fe0dae31e20d114dafa930cbb264c2727a646cc619601967ffaa3b8bc787826ddf0c53095acee50bf7565e0517b48909b9d7126fc4b0d56af3ffdfccca4b263fa21efbab7ad8739f9a8e69261130fb305f3d0f78bdd179ede8b8e73c7632082b6985e4bc4a5b440ddf77fc14492856d0dba0086e0827d85d0612c0514c009a4d313686653370571a304a4ab45c9843dbdfdd142cac1f8e66f185cfcc5bccbc2e886089bf3fae19e87bfc33af8b5c5be9d9e78d9d4ae4911ddbfbf4f45b1991b94414a75afc16f1aa07c1509bb3a72b1867ef801848dfe85bb75829a585366cd0ee3f1646c62632c9893ee1e8dd3adccda3d9a9e5d6dcb058b073662a75c26924a086f13787fef817b9e6f691f60944c82af91bb2386d33b9a0283b6a892b168f9b1234ae6d706da907b676668218c648d2cbe15fe58b7203783b21ac0f0d9e6f4cc2c16f913b1aed9f1ec49df2a01551326a7b2ee986e30d81cb987d664b63bdcaca9b157b04c135d08e92a1fe09abb3c474bbfa29f7cf0dad08de466bcabb7cda3bb2a3b059558e947cb10f57cef6c89dd3fc2a0e5ef90fac3d6c6f9ace8845b2b0becf06c788cbee1ab19c7a45044e94651ed43fb50155b83a418deacb96018b68ea8d15c36fdd3dffb939a01b4b6eebf6200b0b2cf209d903690ff1eb83e2df8cafd386807635c90644bb88fcfffd8b4309d269ef835835f1ad7acaf81756d9aa003f699f75bb22f32af1e314377dfa1db87d8667d6b1c83fe37e5c4f99cc8a272856fbed58a87fd42fe4b0cf1b60e10ef3d182d3b62b1349e85dd50cef14445c1588a19bd0c9880f06071289965bf1bc6c3e861daa915f2acf0e54c3818d6b925aff0382a82ce1bbedb1c7be50765a6fe2a3daae11a891f8c279e04f3ff5bcb2d2dfe23f0499f0bf74ce5399c3be5c4c20b482bcde377f9d09c3222a86964bf0e4f3ce1223eca3a4666939d81824a56ae4eff05d95669819412777876128c0d54ea8bec888f7e70e4d453644a7fe6dc0c0c1cca49d00c34f0364bede275c4e6101b63468e39ac07e5088941bd8e48423e83a793db93ce0186d9632c7132d00fc3da1f2a26dce468ade2f99a80de2937fde983400f9b35d342d388ade042a0c0e030cd3f5a8413db8d12a4a79a7ae99bc779b22d3d5c6e7e4f9fbbcc37980ce66260b23755b260af4ef5e7363c724fb1f08e49b1af388fe28b6a7361821e12c6605ce99c0f6fb447933a9b74eb1d91cbc3ff6565523d18f152ceaabeaf7d5b0a136a0cf8b6a48c485964bb054e799c053443d2544111080b2624dedb9e336625c7e2e71447ebb67b6493ad84a2e7532530d3f9b237706207416ab376aaa8a8ec4e26bb866b80dfd1b79a518b91239699d2ef0bbe91e08c81e356bc9de32219d540e81857d72d8ca3d80ecedfb4a666d52f0d70d5c4db94e2be1b5684157c30d0401e3d63829a7e545ef2f7d74ea772066bce60d2cc914cbd4cae9214ae7c4ea9609f7cbef9128f4cb4f0bb226d389c477ceb8ce10419d455840c5a1738f0caaf75395c18caa0c51802cf86c81992e0ab5b07820fc3c8d76d16a68b46d19f376c278336ee6e0141e3edde9287a17005f737005f71f7f17e0fabbfc941e70ec795af6a560b89736831dadbbc81b90fa946a72756704666ca599245eeaeda3dc2f3c98159f52d5c3f68e3ef4a3848d65584ff8e808b266c299a15875ad4dceab4823aa22c4d6e70f6ba9c6ed108d283c4dd511d9f2c509c3660f884f69e3cff86e9e07195aea2f20508bf4ab2068f7e75f391fbd6af687640c8e885117cfc77ebba8585184e8ee8b3baa8798f3b3035d01ee22188513f6dd2b96bc06452a9d5be0bbc6041b71c7300ff80cee1fd838ee62ce74c6610e9fc94670bf689efd84b34452d6cbba9ffc26b7c568226625cfb70288cdccad5705034bbb50e62ece33431f6afa8f0a889f24f503c61659182b4a5f0d376cebe34547e2a213ca642af11752e0d611fb307345043e5260ad45aa3671ceca46c43a71b8ea0ca1487c7c4347fe2cad6935fb9bd54404886b5aea18489a667a4e74b6f3385dceafc60e3ac5fc6fe16c44988291786d1b972bdb1be76d65dcf0f81522da7426c987d87b9d7499c7d3ece4cf4a242d5fb4bc9022c53a96c562b7c8569865165cc2b8433b6d55f7069966bc1eb9d8392baa05b3a54c42b5561b71f39d9caa4c31a0e45de9c127df00e54439c86981323fde1bc27eb6c6966f579d89bb39b24ed7f11cf93c6f9b6008d9c30282e375e9e896950c1d352b4ab78363308f83b37f0f584cd2250a798a20f132499b862951a65880fcf564275e688a6757c29c0f2103fdda9bc5e5619d4ec02625f87a9922a5ecd20fee66088adcda96530d454e08f01f0faaea84ff0abe86ccd440bb2b2c2a93c8f1d81cfbddf2829e6fcc8583349333e0cfb4e4d0910cf644b7375121725888f03ccb085bcf34e963b9e698ce1b54d7f65a3eb1c414e529ca828b0ad147206dcae683f5addfe8846a7d28b83df6858d12ed86e37b9d15860702391baefc1b6aaa46edc18ceb55bc1e083ee187c5191eb19791a4c9b712b9b9751b50aa83713e5837c6b302a40215c452afae2368d999f9e8f87638bf2f0739ac0c606b5c925bd8ca5e93e4ed86141a2dc1b889b2bffc1766d3b14c0bff708d307666833cd0d3f88f8cb7782a2e1ce5704253961b2d36d57bc1883530aa9b93d16716ea8144d36c9d70062be459020bdfd2dfba3765054ff509bec55088ca3f08440bf7f5b308b058473e359d6ecb15d58828bdd93f224c8ed5b38e3afb5c7f2698f5103828ad0f5e9c520ee056dc72159b9eea2bd075c3a44f67a44b7a7f6dfb1e3ef0e62ec764ea153a69904c97165a207ffb1fe919f41e141fd1fc2a6788054494d3f6be9dc8f2a7b2fa1acc06a06081dee8cc8e1e973351aad18eaed0204f0b9533ff4a9a5c33be41fa447a1d4b0a15222dc7bc934fafdb1ef43577e79c9ace99a7b4ce58e7d556118c9695b67c64be17ded6af510292affd051ea30cec06bb0456e928770b57af2bfd482cf709a7f9992756700589baa813c914cf9b4ffb731842cfe2ae265af284479653b8502caf71b7180055766000e3fd1d9e994fc987a02375158c34c6894ff58193e88e05eddeee8771195976914d1473e3535f9397cd24551a68ed141cbb4aab75a52dd70e75011224e1dc4975d005017535f8e36cfb7b639c72c5b48a52296b39c6c259474fcc30ac9695dd2996abdba677d3122689a68e42006985b924271246c868653986fd9d82bdf87ac6ab3d2d33f8ecb8da06b204133e92faaec7b9f4f33d9a18fd7859fb638274098997ca0db8ea0ec9d0fb5a525d6241167ef11e4ff6e4cdfa2ec28f02ef84d113eee496affcd494a4ea9cb39cbeed5bfdf01d3a6424a32cc6efda8d6b6fce45565fc76796c17b89ef64cb1037b2ba224d689b77d9a75a96c8f22eef8e461808259683fed0979bafd1b8a68ed6bc8a31a90f8aa392d9bd13a7304b186bc5f791bf008a57544cae3a9792085d95e8836ddab06c9b38c84ffa14f6384f2f2c380f85c1f9b811b18afc38439e329830f8f673d6ef80432d8e565743e47396ba49512be6ec07c9890fdb67512e43852e792699e09f4f2a2a0834fb89650dab04b0f694837dca101d1fcde906f15876b7164e7348355310bc1f8315df28dbe17585618d73ecf647990ef759f1eaa542896d6cb10527c0a1c7a6dab47fea7799c10d6a22cc086b160994949d0df0e2b72aad5cc28fc7c835d2a1a6153cb0bacda9c91a4e27804a2e27a23529f8507fb39bff1cc8fcb164a6f09da5cee34f7ee87a7e8d6e525085ac5f3d72ef50ffe7ac34d96814a09fac32a4cd9d4ef48dd7703c9c4b7163a7c0b253f9348cd39c072043a003e99ad7538b4430f35cd18b3b5f081ca4d3a597961b9230be35f1da292926b79b26bf865294d043684092dcfaabe9790c2255eff9fad0afdbd05fc31a34453cb7f8e6411e91c0cb0a56247c2a7c52d96a5e1b0aee7f81670b3361bb31a9c31a87d4f495d3dab4df14e4d79013ca9845db26b2dc4fc2142af3ac8a71f0311b5bea43784297ff9c6971f67988fd7a84b8a6901a4e1155625312230ee6415a1e12c7a5fd13cddc5d8e7af5c0b9a36ef2ff6f5dd4be34a43dc8d3a60fc4bdbaae1fc0a057a7dfd64d2c4b6a85c93a610d677cdc73443b018d835dc4d74cf73763e53f84d44fe8689293a1a7a9c18d01b8f7ee5db9960dd6191035104e2a9a4c45b144fffe14dfd9ebb6b0ac08bd52f83e8940c9aa0a2e6ffd84fc80c8adce8c4783166e1965728408d60583e5a0b71ec175b2b2ae4c0f653462c12675b0cf58040e9fba4a3e2808efc718aae3cff4edd4384b492568607a604df330b4cfdeb0719c2f56433932869f5210a2ac8ae3ac6f979d86155a264fded27291c241b60cd652e8c17daa32742cde3216875ebd2c5ef782ce987ebf7b21918d714c0f5efad1e60a6f6c4176d56b1c631c5936a2f90e737632fb68f6156b862771b84d3cac01c7fd196c8b67a78855844e3374d06e57b467290702e5e8ca1fb8c17e841277a0cd39c02c1cd5d10dad8613a2c2af0febc31343923516e2f4f1aebefbe3d83c8157f687ea774cd790bbf0830abda0e8a946e2beaf57fc763ce14e37006a64c9a984fc16e2d108087e85d60731ff3a4a7ad1b4199d5e8dc976a62ac17b623d116a719c4142d0b3dc4445aa49a1f9c1ea8d30f3c8b62cba146e6d1cf7fa6663cf97325ed20df4c8dc4223bd01cfc2b30508fdb51f1708ca7d228cf164cc8cae9ddeca7ed8e3ac0b8857bbb5905bdd307d96e637378658b774ca14a1482b4053413592fe0178050be82cc0a450faa7a082385348024db38be7cf07391b806261bedb2ff808bef1eb1cbad8004d18df1329c5d9635fa7cc5f40a3f3a76d041d04ece06d1df5f206c8d4f8d35abbe142786d4ec21227c772d1bb8ca014c9a65d91e298be422505538a947decaf97c2f7079f6f2aaab6e9d9419cde050e6f8a859d77f962cfd49c0298789938d1e6ad6b4ded35d5549f0965c74f5ed0e3b63eb043f7689bda68f197b29eee66891bacc1db5abf9e1e549c6e303cf7df2cb4cf17aadf3579a2ea7bb642449629a9db7e50e4f59c6b5d2aa0ed36bfb41834f3f0b3897a5a6aa666cf4db2f8ab55cd15c321fe8db48650bb7d537eaf44d00819ac4c69e2ae685ac423899845401742ed7621a198b2058d2351fd2899b1f8257438f43a93fc1edea87aa89b1437aacab1acb5f8d059ae4894e84c0dbbd5c02709def56f8ac3164811958c03f66e5dce4d3e5940afa3343ce2694867df139c35d1c4a56f112ba0e64465568de9d1671ced008a071876786814b42abc624ec2d5a8b0f99465e09a4149983c1495edcd7b9eb2fc0c6d177a05004420dfb9ab9a53e41ab47698d6edc34970775ab00fe9d30e998cfc89d24764388d8467c37a50a6d58f0878db5d22c0672ae7135432a02493046e615d9edc67dabed722dd57016b333e408a0affaf65886faca97bcbaaddb4fc8104e9402540f26528b1a7ed5bf458fc3aa9626259ea07fbaa34661da3c54d6acedf72f64aef254f0a0468dede2c740c421bd89ec484ea2875662a4faa119d2566ab49e32a4516041e93830104c185866a85ba13791195889ff58a66fc91295efeb705ab7d7f6662003c478394ee6c6d430867f5c2964b42f24bfad9a1b8092050a65650c2573f923b2c296f851c916380a50aae2fc28ba63ab96e4e82c45a9023d2e300e02177a7d7fdf325bd1b91aef101de6f21552758e304275ea072650a8c59bdb5379296a8a60ce8b04cdc1e2f029e3756dc41e63a73648e066a1f913bce44b4c1bc6e1ca15219ace3f33f3141c12399c9b13f6fb3777f7dc8735fe07bd9fec8702cfbf5cf5bed4914815370a366e17a4fc668981beaf9a5dca5cd0370d9d00c1087d78bf62dcbf7f39184baee501e2f6b12aa0ca3ef7acff0773f6995cfd6b2f13c68d543809a0ad91459495811118c26938ed08190e2b793c4bd9fd57df1856ad189988c663cb7038759cfe75469d13851c4e05aa995d9b5542ad458d67d931e855f7730ed1f502fc8c9dbe5d6f76506d1f16a32b146ef7e8f3f32ca5e526b8b586d92055e8ec7e90c538fc4e5b0fa58d06fe4dbbe6b30a70b87e3f4c6035ade28b17714d9045251c963e66146f2b35306a2fc77b9e77fd30d49c99bde148c31bb5b9a69b2383647d5075276f225fd62a33efc31c6fbe75ce4e48b34931731f0c1d6ccb9d30b304b65d482a9b34995a0442761f3b8b77dd2aa746d02d447c4ae22e36b9f235a838f87b4d23aae13cdbb95d39d3bcbb12b1c235c6d32a5f1ff1ed37289ed367031c73982478169627df61a712ea9780544fce16fbf3cfb37d58d64f9d14d40be966f97ef342c2d8f2d596b1d481513e122a7cb7b34056ee11a1dfc9d69e750047872e19f2ed5df5d165f212d84f5fe7091d31c880161d7792a7233c45dc91bddad300ed03142bc31a228a4e4bb2f8040a4bc660680e902723b4916a04bba86f161c9e463cff690dadf8d09d8eae9b043c72f204f1a2f2861d28707facb0bc687655fd8bf239e7b5d4026ef5649207f3f7136abe1f0db9cb1c79b8e16fd884b53aae4d69c827c0322b4ab7c1f247b766c46fe776af8a92eef36d2a7ef69ca6b30f1982a14ab5d39af5ef9184c911eba6b5905f4e97eefac0b35e2d8656826741ae2d922d59dfd8920b84e06e7851fc0225e28b96db6470246bee7055f180459432941e3ad6abb929b4cc658949db3de268a58bed515c9f002ece447ade1e32668ab5d4977e933114aea3ee7a46bc851bc6d1567b8bbd1dccc28dcc00f9b96942d76107f203f418263436edfcb4a9828fb09a7ac84801a853119d54b794ef49da94a28ad151a263101c0ed89a2235a3d200013a587092352c8f9968a4a7f224941c31ba2420e8991a68a49c4d6011090c7f43f217ea7ad138f9468643766d47f6bb7eafc7c4c84f19a21aafbbc4b0ea528cb3fdd38ab6ffb22d7ab9915608345acbd240fc1c9b6e1be54d0f5574f691c211198f5748557bf87d930787f1d4bed4172e8ec98389af7a02f50fac68a0a1b71b755c52aad94b86ee5035beccb9f9f7cc37656a0587b5b0ec089513fb166de9aef6527d9c67704988446d62ed087ffd032be029979fb7d8dcab7f451acfba6a8b12554f7c68f4b6447c352f1a7f97be7af5c0a77f1d5d60438f558b1916238ea5698fbcfca8aa54217c47606be4464e84d7cc8d80ea4b566f579981efccc2371f0ac81584f9883782902e75ca73c20e3d184fc062a44948816c7a95e69b2e58c7c524802995bbe48b6c78b1e71f479aec201884aa1efca58df83fadabc3b1462f3fdda10be5ecf0ba533e992d1d8d7cd48b5a2d590a106ebced75a508a80739d8198ab07f781abdac7729b25ec9c6e6dc9fa18edf673a2d47b034f5f907d97448126de52d13e2a1164622e79e0cd4c9839c18318cfca080ed71cc400dde39692373468fd899d1d12ccb42e30d172eeadd88847bbdf2e1315e626e48b30c636443f916cb9f92498679cf274bac82b564dae02523467a76c8f5dafe406aaa08e2fc6280842c62b1beb543adee1338860fb182add16d0e065f5ca725c967a0e264d3caf23cc623389b472871c4a7b8576a881a8da8d77c1c6f74dc6367105659fdec010dce9edcdb1022c681a35fabd2315990a13018624bb09852267a0349244d5d41b728373e5ee98998669fc5d55884bca0fee3fbc71330270597f36abad1207ed3ce0107cd4f2ca50ff1758e490790c7ff9242ffa876faec62d2feafd604729a7c54a0fc9a048d1f2596e4b48215138dc3e50ad8f1849ed1e7fdfebf4e90ba5746f5d09d9a1409736c6f9ba434b26046b4e640358d4c6ffccaa3185717bdba672c116ba3f1ef701ffa5e2fe038d1ab6cdf0623366d2f82b71d883e4e8f08e647c4a6cb2fdba2a4c39f022376747c4d1890c4b58ee118d89f4f29a04f9ebf633a1923f8c3e96d8802bcea820dce17cfde699197eed4582d114ba2029e97524c8be5baba6f359d5423107a8a1fce0a68d2625bc0cf23c3b8ca65fe844d4317919edc1912692d5a939bbccd9a0bcb55d489ca898815d037b27b74b26862a72eee1c275563247367451f1c9f5e8e00da32b8d78f16e5808a6ecbe0fed8550eb88b9ea57ab918d57391a5da84c972bbfa31c21257736294b5f26c8b724d26514e625dad2030e3331fd136f58de767a64d556688d7aba35cb97bee5df99b3522bf6462af0cb8098336eb49cab57104c293adf01bb657e00d8aa1880ea4ce85474e2d4e1a5e9a879b6543b4cbe642aa3bca42e65972e55e78989f9eb223b6104ed49d88b68fd169bb33beb5f66bc58eee2da15f4711c49561e534d3605c5b1edac22090158c897bc539c09e8a8896d73f9b9880f70833119ade98532a39081ef05e5da85abe1ae512b39550f467672875a415534d13c65acef63bae50708ee64056e6df67a79bb7dbc50c78c9f2989903cb99fa3a2d1c6fe2f1f4b43c1ba7e4256b1198d6d9f67cc1b19beb6657ff6abc2733af4e631dcbc962da8e2dc5f86826048bb840848e4f5786ff86dc5bc2a9b8e34df006997d9d828dc970c1ad94242b28451428e859a573195c44da96d69e6a152f410973361b6830498cc36b497c722fa9077b1a12e5c15ae30efb8f142e8dbe0b9a5da16e2c3b54f6f35b2b1557d270e7f7e50b131b3a330f4b0e715731febeb16e86a36a0f0ca46da638884cc6439c3981775f6ad3ba7246796759b857e0bfbdc3171353f45084f2dc8237deb796615898d69cd71ade86fc6ff130ef36c338f1d5cfbbad01e742b3ce9fbc7b9dea9cb40a859ceade627c81eb8a6d70aedb9d9f94a98b5d2a1c794b6afd003a5541fd8c96b5e29e9461c415290e6db9b31bf223860f3a93717b908d2dab2d47d9c55023a7d8e1cbeb18dfaf0d1c5866f2880aa622f2421c2e7d7308763e197b48bf6920d79d7aaaf778ff41e6fbfafd1dcf918992cdb5b7823f9d92d67c8c01cdefe079337523ba7e3c958ef27a892db28dbaf7d74f529edeaee4963f9acfeae393643df8c4771aa7891e6808595a9a6194a02bcbd39e82d18b4e032a70aebcd633634f88aa0e7440b660363293c0068127b12f913c403efacfc22cdc79846b7c889f815c651858b4a34d1805783080d1396576eea36bdc9fb246759dbebe3685068d29c1dfdd94354562097aa2e712f317ecf2a115eed340ffbaca4c326bf8fcae74c1c8425abf6e6a33614923be1f7f8c1d8a35f1955117dc9749c5562080fd098e1ca89eb60f81a75b023e24f63f8910c8a4a6c594c8eff60a4bcfd7d64341508e9cb6a3ca5e5be77545c60b79532784ba3e7e958959877e3562dbca11209ff627f7cebc63ae1d7b8c0ff0ef56413f9d7da4057c536eb3d53a0a598681d5e4360a4e52d8c7917b11b2ee2fa186b438a890081cbbc9205ef39e3875fb9a197677087346a493e26ffb4ab884ee1620f74833ed5e82801155cef84eddfc634cb0bb50f5ce3b39e66224f177c64414f0397fb7faa969a499bf0a70acb90bdc66d7a508e8139620b7d4d7c5d2bf5102d1c047760e624a69aa9c7636256569d44af298580429182c6484fc011ab72d75ed5ed0dc2a944871e00a8575c9aee4dfa6e23266fde66d92621595873656781f9466b42414db55e3718984a08f3ce6e914c3c47ebf0e404e81abdcad9252d3de91b01599acab4af21cc3fb7685c21b5db115a0bff8465a1df91375d1ee39341121e3719b74815821eb87d343151b676e9371a402221bb7a23411ecf3278266a6dff01b776475764734481d1c6c68d13982788b7b2756eddd00fa37d58f5861f2976f0f4021610c36b14d56918f98652c06f13127ca537c8212da7148d2380706519170bb340f34b77d53270bb1530c89e12401d6220f069dfafb7075a3ed21d8b830d54d0532d38024bfa504852b37aba3285ac5cf05d392295406ec287d4e3af6e84b1c386d369c2b4e0cc83827ae1e09e9f13a6e13d2e50f4e530d54fcf3ea2f755fa4cc41e9027b35a3a88cf508ac1f6f5c300d49894c4d5f436b4a383f307d2c49d3d192eae5188f9ceb35df092fa9926b249546b259bbc01ce13b33d93378bbe74c8b0e2f75a6fc328efbf80f582e5d49375256f9a40e30762cf2d595b27beff84d03addfae1d1aeae601110a95e8023e30e343a1a160962ee9ba26080e0bbbc8375aae76e07f06dc50881f171b253cfe38525dc94f0dbffee3e903e68a5ff5159da39f3a8fdfca42217799b8b49fbc7d1943263818883766edc54e88cf3fbfa654e85bb4e9b00584925dfd1f0e6b366fbcb80fdd7005c5e6e14fe362132db3dc91a94d2ae5643fdecbdbcca15409763691bb2ed3eac948fceb3c068d56f2d8ba6e545ad80154507b661e9ebe0abef78e46c045e8d3c3fd09e5e019218150a67fdf88fdde0cf1d73a512bf047ec6995f4bfb245e070c1c5399359faf25f8a52974a7f909f57f961994960dedd34c505f0b4e98da508c5f3e52c181a3ecf7d1a4f31a3e703dcf6b1150f955d8fd1b368bdecd8b9f5b3a9723d0d6275b72ac0bfc169af1f1956640909cd94e745b2d9c294e9f368301b55538c57a7ae7c8e38e9ae9b09a2776341d2e7cb512072ce3f9aca04f3227c0656dfc438a96372bdd027ec00859a5407592f80478a7ac92d31762a21f59e1acb1c52aabf437fb45c113cc6a618844bea26d4cbd6bbc843fd4f815cf3c4cd06bf029d655eae13bf1e848e5f72291b211f9b11314f9757662ab2787c5233a3cb7dafad31e7ed39a43f2e0318d0b6b129da2a55d8ec585ee5001e84a7b36f61d464cee216b834674cf8b41305a875446037e590a72f376737ea55fdb7f2914c81eb87ada59b40a2650e955c42939c79837da7f29b5e01e2ba03d9fa50609ded4e421a2251bd495893bdddee72c0056b3f899f7be1afc420eb123d29a7b7862d4487383a8644fad0d48e96fec60018c11568bca9ed0f55d53f6eed7e83f06ca7756766a2aea9f0d461ace24fa351b59bac1a1628abe24e5b02e4057695dec33b76ffc9cd2fcdd2d01f2f04fec3831818719bb9af43f197ae71f7c0c78866265f34ef233d71864a03c113901aef88b7a6787f83283e30fbc0999a980c16ac669bc683cd7ccfbb67a7a6e46067bf02ae00214748c04e8a67a577f157e5c85ef10ba6ead80bf15147576dff51024502e71712668d9944ef27857edaf5392bae7b82ae214607e510daef7064d497f0d7a15bceaf58c4b2d8043c3b85317657ea180fb87f6b3378d5456838ad28e4e87124526bb553fe73a255a84544d850f262374943f0a50d629cb45f40584ed44931db220ad52212d60e7b78fb7fecf32cc3385be316c9299ad8cf448ba0a4a4b68d2e9d270b6f115abd8b8df6a662e3c71829a4fe85c9ce33d57410656611e4f29a152f7695e353ea091e1718ad166882d577c510ba62a9a6970ebc48a4596622a7416e6a62d0770aec7ef63bb161cc10d1f35a692d537ede75ea9ab0be26dc806592e9783343c06d3d5449061b8c557d9c3d6abd881760adb9ddf8f74ff6e4f86888c51ed6217faad875a9bf7686d76fd803f0123ab5161bdfc19f12245ca7cc40eae78e004f1a49e61915f174cdd3fa791c9f48c749a5a21152383aad510bf2f2ba538f5e899cf41966480c29d522b66a79d460986bb839324de82ac273cc6db51df39c8a0f2cd80103f7c54093c70b77ca3f6acb8292076d675c4df5a1259858f849aabe15bd8023e4c7f57bb6feb2dac5db3c63230dd9a48c474fc4fd03d8e3aef9d1bfc21cd21a342e94ec37fa1c7c18a590f3e7b2b5a48a0c750376d125e0df4b8b8e75e62f20a10b25a7f5bf57a36f2c221da9aaffe072542d370222558775a65c141b0ecc77483ec8ee128a694deb92de46df263eff09c81a8a913fce8f3116f8618a16c1d53e72796b72cd57fa252c148fbdc045fee4ef8f44e48984679e80719273ca1209d8472d4cda40503e1e2b27c780483fd2ac5ca3f735979df6851f54a5c73f7ed3e0192a6336c5e24d3973e1a65af746853df4c8862a94ec169d7dd781d9b03d7c4f64552aaa012be1f320d878f472b77cb0d28f8158bc017c17753df102113ade18fa5c70652347e2b5ced7fba0de51c63fdc3da6876e96ddbbce169508f06ed99c4e145e31067f1474a6bff519cb523c44e4a06e993c46bf4af2f94cc2d62af905ef4d1b288c4649d53f34e42f760163a58d93807b79932f475a8a913a3d05275c5fcb7ff1b2371501f823f684c3d10a52040fab419c2dbbce305fe2608e608cd481acc60289888e7f915ff58caa2ae8308f67acab8901628953e856b6f720477a81386186552e78bcad045c52a796e8762cd651cc6a2c3f3d051f3ad451a9789de98ec90d7efd6492364048dab4ff06da15d249b6d8bbf7fde7b15af2e7d98f571a6df09c2accc262d07cc167207673ac475495740cbb92d123d190907d766c422c976e98d30741d29c52d451c015a3f4639b1b6b86370381916b713ec5b42ea0ede3a8e01ee57487b9774407e264ff0ce392ec7d5fe3a169278f5ab3ac12e9c3e006de7d6d17622ba1ded5d3801a422eae2cc2c3631256e48d47b62b80613ddaf53e99abb4a938f930fffe021363d028497fbd50a1f068dddbe537b000dc1474427d2ce39e63b0e211a17e0fc8715d6048a02efba15ebcf9a1a157d2ede0229b51702b371678463905a353aeb40b9cf5b03ea616bd508ebb85da377e85aebd0441c93e1d88ff00b6eec65fc85ed052a96bfb3f3ec8c295bcbcbbf3b9da3712d2d789d91d6206a7a83099fcdbc90d284f27dbfaef3b63616abf85fc26a89e7e7a13dbcf15bfd3ffd7e430954d8302fdd87368978a5c1ff8d95a96cdd8b86e6513a0ebc847c232486a34bde9be99f84edb97dc2bd88bc1cc288350400eebab47feafa5c04b64576583bde2c246ec25a8905d8b134e8a7f9b185097e47d889c7805cd510b080820adda0f017e911a49c02a9c0ea06bda02e85088790111a02acd6b83cc70447c37ab72e1ef3fc960a8cb9376fd4a7b01b4eeb6dadc74b6a0de85b340c52dfcf9332c250b4b1cff899761a667cd2975c81e5f0b0abc9b47da6d98dcb0733643b177fc2238b33ed8dadf079a3a4d52a1dc6fc61de2c3ffe234a8fea19dfeaf9aca2df26a9e2b50d3077b2d837863003cfbd572371a62c084c40e2c111eb02eccc729bcc8d4611f33628182e4b5b4fc5f8986cfbd2edf789132b34d8ec9e35755c040ab7a480da56dbbaf95f3c2a04b811dd120592f6aa886c08c56fd39f586d83e2e658030c1e9c7b1bf59a035e4b27f0c6864cd02155bb89a2ba71f149723ad8517c0ce9d219b56b29c13df0cc4d09e12d5568ed04c95a775018c21c1f42017ae29428d152e1737722cb01b6a482c46588ad4688f2f9f8d2d04f3f65032aa46bf7ee3e8cf734503d769ae76df1bbb4b64cf9a9fcc0a12a674b7f3a5990af84b42bef641dd39cc0ec8b16dd71d8143ea5293085170d510ae2d608fc73f6ef7952aa4c47eb79f8843135d6344387c1280b60d37f65e5ab90e1461260bc502200c413c02a0abece011a887b3a6821a1d40eb9dc8e937df2c6450db2d8b76f91345c4fe5a405579d3a48be82b8fbc218ec4d2ca92e1ad1a3e37cc82a0a3bb098f22805db79494b862c5ebdcfbd11cba63260f576e73fe3291f0ccf692f22a31c00bcec584beb003b63e0639a29213d571ce8ad603a743a11aba0dcf64e50706b97f3a4f659a5d87bd57c2f14c5fed659955bb81c4afebbfbda7b1084c8a54170af429f549ae6eda54fe608a28c61169d2e0eb9efb294df6b21197886862ff6dd186e33e1509dfcdcd653111c332d69d76c78261556ad195a4d4edd7adeb18b7b6976780b2fc53e145bdb83eff5ada462493eed12d771c04fa451dc594c36f74ec6143888da7435fc48fcc7c49117e28f7ebc3df3312e2de16edadea74e01808697c6dd3800eb3116aef6ef0dcdc300e2040fa5f6a5487d12c4be9ca73e5f0ac3fba4f1223a0c95ca1bdd76a302a174cee40490ba0810dc41eee49fd406d6116f3f862459549fc86d46d70b71a6599d1038ff50c4de54c3d0c1bfb7c235d7a0ee193facd196ee24df414ce0aae06af4fb735dacf3e8e66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
