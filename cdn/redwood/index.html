<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9dee0b97b06653ade0618887830ebad2f6c7edb22615729ed82c50c80475bfed0d2776c83ad336e6e1ce6ee4aa2129f1f8b6078d6e38ed4135bc8e850fb4050b5e0b771fa6a29485453d4a113f5e24d90a9464ee832e67f473b0d3d05007a75ef44163089e65fe998bfe8cac47f8232d4c6f6a7b0ce4e2c201c9c1fee2742ecbaba90a1e8c16dd56a267e3f6bcc3368fc0f2c702a63d268d618b2b72f84f89f95d79d2150c3f44defa673df0badbfaa9b5b0c847f1406ddf5a6c763d1821a5a27c7313d890af6dbf6625bcc23463815f39b3386b439b38e838d8b1f7c353f77e8559cc1ad27739de09031f5dbc2eb01440b8ba58db2a76002ae935f8b593057f902e923ae4f6905a92aa3b1d1d036a6361ef575af7886c86fe6d89853428e4b53f52267534c85083e59504c6437dc8c5345a01f4ffafeb76c5a062aee2d9fe8da37550f3169d1253704f6ba2795bbbefcdf4627b879c24cfe7406a1f352b0f2fc5e1f8e92a2af30a64bd3ba5e290286d837e6be69125549c807effa2e513682643d12408cc0862fe613f66de78479445b591cdb9054dc53e37908cf87bb76cc4ae00de65dded3b7dadac39a1d813c667f57f8a58f463c154f54eef66d60d27e9865005f34b4c384190ccd9a20ddce30a7d818d56d2e9875dc801db250941cdce771af5a54b5b84898d18916254474579133d985367983de72b9092a4806eed1c2b97594b7eadd9e6ff1c6700c44234d1cc541dfd68f7d6893211e68363c5ac16fcd30140e035116874b5a27d376c426b273d40be8c869a3b67abb031dadbd8e36ad8f65ed62800686e4613904c050ec3c0522539e9114644cb5968ec721a47b7e84b4586601a717020e6984279ad2681ec8d2c43b9d566c9015f2ef25a39987d82fcdeaeb693792f0490ff1e701b80eb1249bbe66d18d1692446fec9afa64ceb9493cc65693dd4e088f0365a5e0fd601faa6cad85148d8f7cf05ad8726d3f389abd1b22be2d9fe919fedaf4a99c7c6a15ee350b16f0c16f1f069d0a7af6f8abbb5ae69a0ccffec4d6122c9fd713a15b4935606e37c0d7527baf4bc885461a2d71a659359a7c671355a66c47b16acf17cfbdcd0a33fba137130d0340044759a2c01ede23383bc7d58cbca321b4b2db4512c35d8f149f42e9580ccf1de52c2af234bd74e9cc97cfd16f66480faef46d29e476b61db91c53d7dbc0b70682b70142668fb84c42b79dfa07ff62b29614ca1e2c9b01723df18058f246bb7a5ad5e99057c655d1c2c93bb8a2b0d8fb1378e897e3e0fb91b81f9434cb57f556b2517a65fb795ec59807358eca6aaad42717d0fd5c5892ec0fd870ac000f437dd1ec1e3170c95a89e3e10211ba8d43dcf59896a7bb95a54de189099de0fe38ae58a6a3a47a7af8678160e2db66cc24b4c18f6fb497d74ac9ce2d5f79c2a2d69361f04c2d6ea5f245f48137059455f9398817e1b959292082412cebc028ec16a8938118a36cc3b75f0a5a13517eb00c3089c45b6e959881864df0e29d3b5d98d5056cbc49c72c4ef35483c4cba6ee32a800bab3aff9fa1494683259127cc999b5f01c571fc203073895e38e477f7de7f90869f4201255eb4615c2ae74eff39e66ab2c14668b389a1c974c8f695f6db35f7d686bb992bc1478fd5434cf65331d00c1ed9caf4f793c09bc4dae14b7eaf4ebc5c8d9a21bac0b4a01ee01bea6a23a837f1173e0d77a041024c54c95ba76b0a5f09dc7f58669609577f7cab0f2341c7707864616e589b705caaa054701160ea765649b06a1a0d98f64d47b7d10c5824d4008d473a060f5e18188c9025c388d42c1f5df206f942d584cdd3b18e09b21e38474144bc54aeb1414e780b08af9eae50ee468b673a952db70768a42f049bc867a71d4fb9e5ba6aa29bd053312325943df9bd17f29348a00051ddf4b3acd49b0ea68ad90b5866f18eb5230d5864284d02a6571c54f1473b25a2f630fbe67e3ee1944162e89d777b9ff4322c1a7dcfcef0ee5c853935f1cbfa2701b9d968ac827ba9362fa7cdb0dba6d3ca1b2d9911f6907e4fc2cb2d0a9d123d332987cd0e334493ef9381410cb11d6f5366b9914cb006c5f4498b49b71f6e36222fced3ef8bf059f934b858441c165489d8f6a1247fb1d0a98bb551ca0a7cc2a21a86a4e9c2121a590af7a017437bd7f2107c4d995608a6d5068b3aa8e793b528f3adf5a5cf8ff5b260765c89bcb5ce38b2ee1879393e544a19dd9bdbef1fdd1e6dfeb3bf52fe2234d97aaec83be98b2d500bdba8e88e8c2abc53b128546531ef9724d6e502fe2a3a737e2b8eead139f015f3326faa660b5a7f2645e524d932114c93e4fbb8ddf8faf03213632e6c69526b62aa3a36cf0b6cacec613fcb2d52674620b8be16404e19c862d867f08ef48154c80110f230b3af093e7e127c22ae9b9615fa56cbdc85367fda87e5958c168329990b1c360b05824f5c06ec72472d4ec4ac465a30b5c41e28da8b70bbeffd4523b7303b861c68533db3783efa3c1200b9a922d6ec25f52668b9641bffae29deddcaa378b450663a93975f1eb5899a37650ce9ab44fec4ce3f1eed3f1729cf24e89fdba4647db4820a8fcaa22a51550e09eedd80e0ab78350192927e477892881f622b7d6d452e9de4d684ff656468816735e2c912ac1f6fc02e29e9602e2ae425544f4ade602608a0a20d6feef8a6e10a547628902c28c83571789ea155980f6f10800acba181dfd14198b9668665e37762de0f3fc08b173ceb111b2736f02db78c992a815b7e479c1178f159f117ae07fe403b822ad45203726df5c767a8c50466bb800f4e22cbec54a5233bb60eced88917f05571fea0b8e1819b2d06ec0c3c772766b22bd5341681fc32c593daa880f3f1f67259abb0affea452ce972cf7623dfd9082c84fb2c714ff9454babb2ec48416150cb4ab76d25387bf3a031454627420f53d3dfe521c6deef848cbdf9759b6e8e073e730d9afb11ac2ac472f6c7912fddfa95fe951e523c91031d01342263f40533a0e7878b0406fa55d3f5148061667d809d3b6a563507a188ec99e50e1ce829f7c603a2ac220e2c106bd7719f3e4bfef45785421bc4273c548922f4625f2588a653916acf7e2ba9922b0c90d77adbc9357516a36aa639a96804e0563df2c2cfde6cfb57e4c6da1f0cb8fac5f1c245091bb65b0230cc88cf382c32ed5e1d0ecd0996f72ce22fcfb15620be40cfe556bb4b4391eb7259a39e6db30b1b6f4303bcfb1e3996493bce3e0c854f53c61957083b4fc137445951b4cd152237d6cc97a351b614e06e3370bde15e0be0711640a20e0599a7b666ea3eb14065a90faea15fbf7bb2000083c3d8b6975c9c18c3d00eff261ec9e6ffdb927718e3a231ae7b0d40e829828df1886a736dbfd8fa090be8e8fe7eed3466eed37f21f21add8b41105426246184bf5c90b0a94eaa332a780769ba64c97a10aa8b17a2559036caba19dd933610775ea4ca100ac52bc3d04dbbd647a7a0f8fb89d7c955b5759ffba8300a6c9cbc7155c1aad85259a888739df761fab746798faad46c3fb8a5d8c406db093bfa11b0a1319669ceaa262ae8871d0a763aec7765f28f7eabf755c1969e8fdfe14fb6f4ff556be9e652f1656d7f8dfcdb691131d02ce40af96836d9e1441080675fdf790f2d394dfd5d442c66400da8ba5b64a6d06399b1d5e6942f59bf8659a4508dc26683a0bfd1edab96faa05b398c7cec6f3a962c1a6e219377338ce4985b24ab48f5bb36b4ae176c4c2dc6be58cb2736b244f4951b296ae5a315cb2aef7d72de3209bc1c9f741b23752ac3797aeb795b738d6837aeadbdce30d356866feb552b6a450820c526fbe24aa57c39d8c236f6ec8642234be3200e780bc926502b63a5d1f2f7d242ae809c607b05aa6dd0a3a839313a6e2f92d53632fc64ca5ddbabd416d6acce251421af30d1262e4a1b452a61d76403bcb259995f84863faa53392bfcbb1d791c4338f06bba8ed97fd5553e0b3bfcb17ccf3e840addd5d42bf2c89d05a815ee398feeeccea2998d8207fa3044ef87600d411ea34115066ea3a7184f72f1f0bb20e2089f48cbc80bdde82041fe744dcfe15f82a01d2e2f22fc0fd7630e80cf758c0e8030c1cefca5ee098b75cd74985eac90ced418c10b8d8dc87b32852286f99516a5c6424bcca69d63b20ce8336a9de27aeaf9fc1c53dd4939c17cf806ef9f00b30d48796e6dc96a3c80424638f1e57e6eb949ba3b58e3699f847a57dd00cb60f86df8db8dda68a3d54643afc38ac5b2518aa67e450b3a135c89fd86ea2da0def33e9e7c3aa4495c3b024e715a2262ac1c0fe11955a5e65ca632a5d23087d570468241b176ea456262bb6d0990f56943c3860b0660583b27c02bb84489d0c44b4b9ea7c5b8b6795e33a87e031189df1701753e013fef31833c7a7f785d77f05a2631fd371b53fe0b0a798ffb948ce57e2fb63e2a0ab5d79a3a7b5cc8d2cdcbf9630636e7a1a000fb788f1051d83e16bbcc9b30d38877ab49e09e4958b085312d7a8f17a0ca37f2198779a17354caaa2ac1560c495c03e8e0693e4ce0b06c9151672579514069ce9b4fe894e80ef2d2ce8ecfacc9ac550609ce7c72d29c82a7867bcaffcd8cda2c1deaca593109c71f9039ae531ab3e21604acf48d83d24669e53467f6cbf908a30f4e3f08d3f07fd14a515d7320cc8a871d34f337c3b88655b71a685d37566885a5b924a14039ef295d5d2a6f96d1e17dab35ff454876f5c5c5f835da6dc102273870a893b350dab23c7f8ecc0080bcb0719fd23238680b45e3c50b74ebecf0d3eec0dec4f80adee9bfa33204c4cf36619c365bcc99262aa068c5fd1537a1708b9a77bcc3828cbd038fa716b2bd3e79b3a7ac83cea9e7c9a1ffa74e19000921f2bfbc15eae8a8d48c4699ba1970938ff2a9954f283b7e4603cb9afd55f2c76f08994e22aeb98ac11edf14a36f7069b70efc56f914f58cf98b20418d7467cbed5b56803915f7dbd90c08156950a0d65e56199146b54c327412017d4e0f8a5ff63e8573b098eb3d3efa543af3d57310e1f6e9a45338d24f66482aa1b878120b7d653a855373086f6aee08df794a3e3bf073abbe08ecaaf0b1e0ea74a5c31e9b1fca04dcba7eafe99539b2a39373a8f54d6b0b9334973efa5dccf1e4350a3d22253e04687f6f5432f758cf5fb1b23fae1e746b62a8da9af45ad1e78ff40a692c3110a2d36ee0d8a9c7e985792427fd87e4efc96c316538a95f88ce0f5575ca806400f782c9b640001876041d5e3d7fa5dd3e46c5883756cb78e383f6155918e892c0ab7701844b496875a60fc1073bb651a9e98f39e0fa8d9b0f0163bf71ff505e745e752ca25389d31173ba24d86a2f379974990c7de55bf603d154851143dfb928642d96cc24673238900c39a69e5defe6dbf4824b8aa0da70a1581d4b2da90e96eae04d41cfa3a45a17b9af382d335ebfe74b31101d1c5127a0de52e954c92bd359032a9c8815c05a64b664feace554a0e6fef03393231f65c8d6e9c167073c92e5dd40c15b0a579eb28da3da2e7a1be44c8eb4a7f8807c906f2ce5e70d8d251956c4b8e622774aca0dff7d7dea84e527bd25ae3001fd9f531d9ed00ea574ce01926344464956c28068fc09082defffc8f2cd585398962f9427a61b08b2f977ed9e1cc74ccd4d442f3e7b9b0d4e91ca7c65b85d8e3f31472192f1bc606ea7a78be4fbb40347a69c5992c869c337bd822dbb448b74989e55623fcfc8ec0e5456acfb13f3c784f07aaf47cc18e57571374dc839426c7cd9a4d6833759235b6daa3b4280bb262621a6a0151a38061132006a629ba061849db015f8d2ac3abcf09368c29f48d337d6d45a39fab7db36f3b3386c074fcb94995a973760c1e733a0f716087dfa55cc43604ae8c285c6f06b85380f5a6d16a99ea952220d611ccffaaba96399836526e3e2a914664d4c4477bc6a9631b1f6616b97389fd0fa13219b621c31ac4c8e8386365b58dca8bb3b24b5d176ef9663fdbd0c92f534b053d3e20b936dbc3d081821bfcf4e17366ae6eda13b008ac6f7850f72bcc19142660687309d7a531bc106653ca02dc32f14d821aa671fafeff119a72090c493b953fdf1f5d50f2c1e088fe5e081cea7755244323fe64fdbf93b2c783a9e7ed9527c3603f8ace1809c473acd83b48458eb89a5b1003fe6981676a1aa3f1860e2558d4a5816cc547693390f1b1a4e1b011491bcf1f004af874dde634ae92e6a785bb37d65fc1d7dcc63c804bf191f729691e883d0d1c1bb657fa5cc6af6bb70bc9d8d300d842d06154058e8620de2a63a5b088ce4e86af021a7bb6eddaea8d1d6e50f07f9f609cfcaf9921438dc846feeb9c1e7af7762b4a8180426503582c2a620903db2c5a3bf9a9cc9f2e569238d33afc4bb2bfe2c838071386995295ae1b7d8fff1f6fe32a9fd2dbf0b0573ae573a71fa8be93faf7cc7549db48360328e7e47bef49472c48534b200347ba6766741065296f8d2c96b538344534fab2a37dff7af4bd529d24239cc8bfbe9890f3654b0ca7e11639695396ba2e38a36e0f2ac6926d4e0f23aa3e61c590584df5a28c147cc22b3a8bb209d90ad6ac5a1ac8897372917d577037bb73265ad853a08da9e65d3047861e6576521f5f8275287b66dd3142bfefe0a93eb9c192a36aeab964c29ee49dc6522d0ce14601d15d7f6a6a0186a9dc24b67c5a6d9ba004f131acce6301303686d5dd1948f4ce358c3e2fec038235306faa21ce6fabefdd45cbd31112398f1f0cdbf1494db3f9f17dbeb22187ff0607de7e39370705c7e618ad216f5d059ba907aebb026c0fc61f7dd4a01903164898934176753faf7c760f133da24abd081730c0dfa745b508de7cfc3887f7263a91e6d29e10790a88cb6e5ed9dd88e6d150b873193ba95ac55902345a647c10090e61088b893eb707526dd1952938a3b00846f41313df6c11344a79a5344a93a3864415814340a00a7a75607f227cfadc7c29268c209d74b912258588bdd23e8c41139ca5b25e92a1cb7460088b5b9732382e4015d3e398ad9db03c31d3138e652fca5ebce0926a0b669fb5554ef441fb6eb6a8e30f71df65968f13fc196e8d5cdc10b4c0a57d7a48e1829545b416b063d5996d804e3d32fc6ab97c8c05db4c1890895fcacd8b3f5e05d7abb63b46843f098e723d4465eee15603b2c565cc2102a21178381e9953022edd975fcbef90565537d37cdc64a5422b0f66c111d0a31ff5d81cb889164c6f4de7bc507719caebede784cba853d9f5ea6fed2acb1df6c8ee3ba2fc53884a3547c201111f399e80308840e9bb5a7ed85f165ad984d9efbaa3d29625e82331c366e9cb9ae895301a3248a93fea38353718afd135dfb36608e5ef7b8d48f38bb40cc7a3973be892230326bbd7c021e06992465f2c3c86f11770fd65ea0393f162348a5d4d8de1e031bfbd0cc93a38ba1b74cce78be70eac41ccb27e33ebf6b229f17831b85bb773acb5e8bdc8653c044c3178482bc352356b10a6cbf4728c25426f9ebe1446c9ec2214c5e2c95a57aa9b8cddb39f3e196138c22fa7e48f1401d226e2bc595dc17ef630da738de12482f2f3fc0037e5211015676a614b4ac0e5b98a5618c78d8fe7fef750c7649512cd611a9df7b31d2ebabca7da7c40bb28d431a81d4e34ac3b550d8ab8cfe2c11bc578658571731026ec978bc34e425a24ec75ae8f5182a4fc4d2fad91c04c9e92819a5b538fae19630b6fef15294e3666b43545783f6afb55be5d86356b59e6b314d069af90632e81b45d18db36cb9331470ae8c33e29670ce75f5214ec5bb40a46397f43b1797facd2ec114b579c026973fbc58ffa4da35bbf29089dd68e751df0440939c460e1a5f24e7ce314f4bd8d624b370380aa1b862eb7ea2faad8ae3fceaa9b4929da1a7c9a15e05754923cf6a51aab84aafcd50afff8e424303ce246d3ee1fe7f1c9001d0987b1d2d5559b179128d98af81fcf54958645ea87e7ac3fb512f368b6b4579214c54db549069a4e40bde86e45efd90b4135466240a7f957403c5d59e760f461a011b65ddcd0cb214a96c8b68adbba1e4cf7fa83ca815b5f3af41a10a418812adf2dfc802d0235729cc406fb01e521af7c0b3d42a19905d8ee0df65fc87bf01e7262b84b32e78fe51fa39a74fdd6b83f86eb3a1a4dd22e5fa5ce73231f445ad82fbd23f2b21b84eb89ae02264f48af4f6bf966783914c4ce36e9c7ac9ef1f286f8522a424960b8384a9ff490a5ffdf8581af6896c2c804fe05149ff7821fc7f93b1b946592ad832411369cd6e608b8eadea788be801d404708729b58c44b8e75de3da39cda2bdedcf94446a2aac19a8f473b8a9736cc8ebcfb4c7a133b7c25f4d4a27d93a81dd07fba02e047e9e408a1232b4da1558bc0ae101e7d24abdb49c4e02c203ca18c6730726be23f7a59d79c9fa692561b43a48a41735efd3f438a6e761611b6ebaf3be66ef0dee95ad854ff74b4737a95eb975750d9af5b5d484129d5cbe016920801d813dce6256055849c515efc25ddd37f4ab0026a4d232aaf3fbb3d5aacdeca065288ccb59dce8d32ff9561a55e5f3a13f0097b0865e004a3a256b5283a65244b4662897b88ac1e2ffb2691eb3af145feba02d10953b832a8262d14a1faa3ac8c63206b78868398b0eb589b5a45a66158f28abc5a562d132481317e909587de55a5229410284a6db1c533ecde31b0e7fc0cf23d9774ba655c21bd1209145d0a3282b9838be3f0e72318b12ea4cc18e21816b1e59ef79884f4d3bd4a511840c116d572b094775bb711349cacb14a0c9d8ca6c5df5b08c425e1849dbf0097021d3bd0b13ce0f6f0fc8f581a0ff78b0ef4b78c068fe4961243ca8196127198ec2e618c7e2d44ea30d3e937054d7e6a062c59282be09d8177605b6ac8408388ac43a6ab38931cc66391a65b0c5f032f563405154222eac6fabb727678859130e570d9cf2d256b01685dba7055da6370e4214d9772517eaf8d86de1e35b1bb1bf189562da9607bbc4ee5668bb87ad74ef748a3e7e61fc3ad684a56f39a7a4d5e81845e5c220ebf0e7ca9ef81c1a8cf7a96b8f47750735910802d0ef86c5d178418ede25fb4af3100e47b5a5d9a49efe37fa9550cc818e00097d52c92ad63c77db6d91f8bc551e32107a4372ccddf8582c5122a13cd7d35137cf171f5fa6a7e4b3d84a5938eeff5ac2fed31a1250cab67f12212ad41857d7f7129864df8d4394c8d28c1fc97006ec50bf354ac54e59ba56be2dfeaf0d3bc726d9ee40fee491ab90e7076b3d4d618f4072110d6d664e262c1144e754eecfca5be3e0dc1b5a162216b43ac7deb21120e235e1f8939221605a024c020c6b5f3ffc00ef0f310449716f0164420c37ba2fcf5e58d7d8f1e7496ae5f64c5ab2ca9d2ab2a8663c917bf8dc794fb528eef0df8a4efbdfa80fd977f5a3a8021aaea9c7beea2d258b5516c5fa5725b9aa469ea555b8fab018d04c713abbdc7211c8797ce708ed707e898d26b0f78848cf89c8a2eee7016cb4e03742c70a0a43c309a8114eeb423e39fade1f0723fee08f6efef34c1d6fb715d58becabcc1b9e8933dc5154d24edc54dfa5eaef84a5a7bdf68a63fe4681a82cc71da9d7aa5f0c0915e0ec2b8d2e7ab103e6e70e856c1755c3a85fee103bfc3b046ec4c659c4d93cf28084a759af0a0c2812249eac4222e5dd316c473b4950a8f78fb924dbdba8cd67810c57e640033fd2c298238d2be2150612505dc2dcf33b9d4464a9718c94f508273145d47d1015b2f7f60e549545cd1232dbf6e099bd160ab598f93bf10bd588745158189896047365cf44fd4257a733fc31431f30183086c58243235d7993cab3a3f62e1112a9483cdb36883970b164554cf77805081cec3bf6c65995fd327c46ca6a70a3ccc4237530764800f12e2d8a7096ae087d62adc2c6fc1a2bf882aeaf45b46731d96a54532ab5b8b25847dc125e0f085352ddd0167764e371a3e71f7b4ff16d50a92ca2df98ce133be62edf39635168d4cca7a48bca6ab696fb2adbd3a82c36f3647e8910465838402202d949df7d5ff12aa5da2e7e3cd8c79ee821137cca2e70138d61491cc3917f4c0f72c2141fbeeddfdaa037482121f76574273133c6f21d61d0b216d4afb1722fbb6b5e6856e33e76d7f9df210efe5b11c0144a3cd47c1a9c3d28881762b7cef78d5e52643f6b7b31aa7ce85c3739d42591cd6a5b771a55a5c619a0231834cce50afe2bdba678941cf3dd3219ef20cc09983cb92dc92358cbd8b484786365bd92dc7cafaf4db940fe8299a7d270333fa9be7a54e47058fbb7476c1f16a6709e5e3afdd46cf026eb23b38df81e45af78f96c7e72617de02782af8a43ad19df8b76db3660b4ec39c8bb2351bd122363f7341dc1a94358e8de18fb3e02defd897bd81ea5f8a281ae280e52c20ee41195f2286398ef28a673b9434658bf736bba88274d4b2fea35ce221956bbeaf595f419d982a944de86a540343e051f6f36a0194abf3306e3470e689625fca8ad5f27c9d7234d613cf2f4ef60227b6aabd8d138e37c435c3d6c24c02f85d334e35c8a18f39da5fde8f12a8922f75e8eb9782ba2ef9a5881cdfc46bd50fcf096470f818ed6bd0f255711e3df1ccb1dd1371971de51537e69ff4f2dae1bedeb4290d218993b8c01d445edbbf6d6c063db77080d2b2f670a87e6afbd3f61c96160e4203486dc0848edfa31ba0a2f7df1795dc9c8046a2502ff72610be0cc3646f4af2c4b41329635f6c5f168d1052c898d2646fc80532b453d31b8d163adea1a4fe19e2fddfaacf562e021efc71589ed6537a030b56ca6dde85f9d19755810c050a10d7e8e2cf690396718ad3a1ab1784f2f49209de52fc9c0277703eb54f8d042c49727c408fa82e0741a0fb5bed53d348c2f938d2149a32a38577b5f9ea167b7bb8891715a2297990e93830a9821b789c02f6163841f64e6c1c35da85bdf82116dd74444fff0cee3f53cc65dc72e2202b60b659833523b22bef4abaa78daafdad322f238288efeb1641e35068714e3887b9d2934ef60dde4388a8312721827f3b242ed1fea0ac56e4aa1442cf3dcbf0579f9ffcfd106f94dbedb0329c85e0580f0d9f43a2df74ad93bd6eab6e31ffc76ef4c8577802e184d2c6b5e83dbb47dcfee34ae8e760d9625eb392cc93eb8557b76ef425ba998e4a7c455123bd3fc4ef6dba9a65adba894afdb7e6baa904b040b7a7e95801a74f1f0b9b48abca7f8a79875326d92bc0e5ee170bc28435375087b2072cc83f60db1671e27a1f3514c8a37bf9a60c4d569937a6d97117d8ec964e415825d1923605e7e363117f74c13b941fad4e481500f940a7d5da6d0e07498deec34f59ac9b3c0583d68da067684cb35ed81d57f7714c6f1373e348b6b1e9f6a91140f7d34de7eab7b99f21cd0600b6b6ebd8df953265bc119db728b1e2ce8c1edfceeb87d5ae6b52f84cd4e3055885cfd47dfc2fae6d7583b211b52a64358f795a6a8245c3e2abd48a57bae44132f5f4180b47a13bc42a83c5a71a1265d1e26bec9d499d0db96ae8620b6300dd27e5bcb1e9734e61e46512e9d07708e612d87f8ccdc4b208c7d9dbc6b0d2eda94c616c51726e56a5d33b3f677f39a74dda6797336f4b79b95895d4635dc8dbdb430fb95da2f517aaaf2937cb082a7ce32745d99040b2fbc77e09a7981f5619c4c8e43534151fcd2509a6f7f4cc6ebc63f56d9c6c1950006fff68af39f071d1b70faed9109b7b17980967ccc40a306e31a6536fbbd889ff9939aef318c2f2f30d460594988b7961e7ddf11d604dec824dd9399e759c5ebd2a8a046b9bb8a9c2980b606f74628d09f5db332557af38d2e9e21beeb0c6a36cb22db27d3ad7ff536a5a35ba4e2a9b53bbf06356101ff0ac5cdebce4a29e5630f17fbe599a642847531928f704cdd8c7b660eec90bb99af826750a3f538d598fec7d01a8e8985d0af38790d6c03a4f45a092383eabb6ce100f76207590a06caf3ded7b549bd0f80a40bfb3a6ac3cdd63e44887c4a5cece0ad881860a8428af72ba820e7dfea7b4f454f82cf73a2ca9d71dd8644786f0b7644038f2b2f8ac74d9fc4f3c8cc9079de209caec3088bed57ef31a6006e0ed94bfbbe02c9916d21736184414f9a35e33e73e26a6a56ceb52e0ab9af6e820a85c1441b68a6d0ddaefe21e6c2fed3895e45b6c0306ad62086973891d4041586c25aec8fb6bec2a6595c61fdc5c5e88691bb5789c236104458a7b27dece1f326e5f73d58e15605ac6ded7b73780d3e2861a89fd44cacb9cbf986c16c527a8abe2fccddb32af60391cb1890fe01bc18af6f2b7b56ddfa25c3fb322077ca27cb796363b73fec3b691705c706d6c9322da18b2f29e4b4a8e79a4302ab53abc55dc4fb8c1318e74f071705647dd3e546a1cd2b85da022f116ae980073bad266dae01c8226554678ed4fff397711f898c97802524871fce458a6d52c7c4ffc62b6c93ab128aae047101c07ae8a8759ecd4b0b6387ea6ab5a147828f84d414820596ba52385d6d4bb035077396139a4f63a7e97a7bd56f2857297e98686a04113f6f51eb2279f689ecdec736bdfc487395e2712cd3a541adbbe959503e8514f19c59b8ed93fa8a73bd6c248ec4eab00854353c508957afa214289753b67bb0fbc96c5c6a25fd54b106912a24a2efa39ab3a2cea17c858d22a9ca46a845aa4fcf8f53d55c477e1bb8b9e8947eb4d646bd5b5d39b72d93dd8cb28b36eec8dfb3f69717b1bbab5c55c07480a5f47027fa007c21ce8c6e999d6222ae943890bc3813d9f7bde2e242f7ea915eefd8465c2aee01a52c499b5809a721698779737a5013e28c8fc01758293882fb6a5083f68ad16b48b26d8dea8df80b813cfadf89d9ef138ba1ffd5b88a28caa0347adf5fc39e56f94fd17c101bac9ef961140115eba7719a7100adeaf2984854fe9c0535f2b699d8ca9c909f1f7d787be3f1c419f91c74d112563e541be567173ab41beb107b20c14a92904ff5519c5b4b8e91754afe729adbe4760c743ead51dc2e7f3db132d19e0a7fb5b04e0fc11ce0c3e6caae49b6b5e904f23f3d41de2ab170788a8c0f7b2294b03039b75955179b7a52eeb5b34fd33d67e83f59fe9ed2ec007e385e22edfe05326356a7cf67c22669743f988e443f8a0031fe36e99d0ffbe64908d210c76b1ed58ff41bdebb0f42192ce9f3876da730d627e9c75548664b8a173849bfe56225e9cef43a8acb5e1317af5359cb98afb26ca2b83395b4424e025f602d79fa0bbf825b13024e34e5b7e85c1ae50452c1974899a8e91d935570f15132d1bd139a56019e09f5c123c430f6a3025141e62f4d9361da7d22d850b2cedbd6f1fc21dff9793161b771630caef59e97b2c2c6d97b92a1017ee8b14eda866da7f9fa7b975e6eab49854dd0d9578550627cc74b7a6b83a6464082c1fc57e96634e84c29333615167740b499c28786384824efae7afb22d9d3697e120f5211b7306326e7f48312ec1a80ab852fde67612683984290e3afc832f8956d6fc5c263dc02633333483b0533baf84529ead7d9446a77927da9953fbace8a624404902fff4ff5d77ca1a070ab9d92fb2c48a3f173b31ba21826e3f917eb834d9958fb94f2a3cad51c26049e99a03dffaad261e7e74ec2cc3ec89caf70f77d524a10d34c5202faba6273121160072049751c1f95a390d626244827e0f83175f721b0fb6045f3f7367e2fc2a2931a93633c9f1f77c0e98c44f8c980ccaa866e67623484324ae86e65d4e8e97bc80f2c09d47eb188d5d7899d9e634b47743088a1179ef6c71df2f5c7a486c44e04f2dec85a9bd2b23a71e6e11a5af3d070cf076202a2b0f84edafa11cf3dc3454c222f4d269f75e007a65ce94cbaa28b2994e22b8983cbd076b0de0bcb969808ba679fde64e33dc7081f5556db665288f484cb840fed4d701653c805d2abe8fdfc119954f751558698f7e11919b6c957579db0e125fec5ccf95327cf1a8135923120e0fbebef6e2caa52993856a4b8e2c79ae564c8483b733b7938d701e427c9b8f7c98b6e78a91be4d1ddab213e9a31425e75dd59dfb9268b4b26a36bfd5f0add5f09a3504adfedabb124d43db7f3ff07365bce9c6048dbe480ffed07b032a1fa0a0b050d7e340c15babb3b88a3376ca5f04a0b2e4f4d798bcd90da3498c50e39b03e01694abe598517178f09403350e182acbdf56a8af10afe1039f8258a9c9b73f1c2ad267551342dded01a5cf570e2153f1fab6ae30dbdcbf2266a4244ac8c1e16c3ac18f75376b939af5a8e0a08c0c1d2897c1ff09de87d64e4a8eb81312b28100421df54631cba5e357c025812c9b8fd444b18d79638b2819ac9ed98878f8ea1d9d6ae92bb7f73a52bd15dd1ef46514de51125275ab74a9e70fbe9f66df2970e8cd396d44478799226b1e04adebb50b7dcc652d0033b1f2ed557e95c9e73549ef08c2b7806c1f87fa3863845b0d867a7b39768287ef1bd80601e64689927a111a5bc9d5d3b570cd17d02a5f39f45cf70b27afe54a500aaa11f5f456ec05eb8400eebec3199101fedc09c3a41d5928d3071d09e4bb23ead5b52196bc4f56b0c28f2b887060149909cb6bda099ee1e39d1db10422a9ab6d580fe603fc461807b3461656ca134f20763fa08b08b2acbab9dbefba765bbb2767e2a8a8418a5aa361fec69591860b8a66de92fb1c515de3d7639074e567c87984f67116e675155288e1815cbd3656d10209d1568f2c70e170f6d2e7f4e2acefc3a24821d321ec56ee578f1a3546f91cfaecd369b483a23477de1a8e926fd607004abe18032eea18f0ed2119be1066d52e12eb76f31ff5827d71e37cc0a2ec94dff3e8a98ceb9cb153648747669487163547ad3f09295ae5b9d5d0e3e0a081d9d6bf0a6a20f44f86fd9ef6b7f2572735093489d7868d996b1592498164c1d9ac3c4f672a5f1ced3215009d47a82ae4c9b9b033dd46cdffdbf2a15bf13d3bf53a0a3e83b6ae6bdb30edba26671d0c8ee084362b3e429591ce9ece76d82311de8ba7339d6d25a6ca24da5fdc55714e8f6c87418db4128c23e1a1213834f95b4b41bdca8479d7aa3bce9f4313a17feb5ebd4e8d6a281b1e4a292044ce550038d851d88289531421c0dd28584456e8adfd27c47621ac33c754bccade487e7fccb9e38a7502ca6bda76c9d57a0c26dad10be27e932cfce5873e04c1ad17d1a3508296990ea6941eba454e51b601c44b57a4f24bc2d842cf7d396590f9f2823826b36620d9e9d76e02de9c49de4b660e2e359655a6b5bb1f540952218b2ee4336a7d1b14c1f57356e509a0c7610b58115508b955868cec85e96177a679409e586a9fffe89b8727a17cedcaab10d69a69aa18b6a97187bb83e917bf2d12e4d9049fdce02effe9acbf2dbc307f077c56fec5273c62f1abba3dda73badd3da8f09f9d77a42c9d6d80479233243b6351c3b17cafa915423b6e0f454d42095fe96503542c3c3c349f44463ed351fbe33cd3ce94d39b57384057bff5113f08922c7f8f695725f9bca89f09ae781d8d20949fbebce5956bb8a6dcca1e7c9a3aa7f279423729f5994f42e9d9ac58826ade3b7448acc2765e91dd201b582c03f55e289102ed4405bd39f6422c22a6eb7455b70f9e1ce936fea1fdfcfdb97a8c869323e6b935cc81d86b65636e78fae6eed08b0aeb7da58bd2365bbb7db39a9702938fdb1a109be1dd526c5808681ede49c938b331dd267f6db348ec4501f5584c639b56573474a07e3c0bce30fd7a409a6f004b9b9477d0ce9e629d2bb19a81b91df9ef2673526c684c4fb216aaee28ef8465578416068e78987da89c25553c75b64c84e7e9569e536fc04ce11f390a6c4036ee0d679ab8ada9ec0e1aa3de24550ba5d00262ee64b299206fd191fde5a3f870039c06bcb1feb573db242fc4216cb915c4308210378696c28c72769a976b84466cbd15f20480dd8d686be92b467dcaf7501bc5c09e7358c32e6edd4989ed4794e4bc29b8fd32a8e4c9d03c13d95518dd6de84c877ea901a2b66174a26d29a5f89e22be50af2c9d4e8478b4666826f00c313dd8a6945213bb8f0bddcada977b8d4c3f76ff05bc80252da4a039f7e7b55860ef7e2cc49af0f379bdffd08941323f2705a252262661f9f9b3bb9632c344e8c1a1389a24abdc04750c6941ff82fe719f1d565ab840f568c9271e542a03b5cba43d735dc31508d79e85711d20fb376a9e5a4bb9d733b0be3f56f6ae2504212565526a0c00d434c33f68d78c861d46fef9e9eed930f438b3e2f1407059d8645413a40addb8b22e68ce6f5d8f840f93dafbe4a426bbcb03dbc5d7916b9ec2e5b7688ee97467251c20380dbfca748e90c75c8d3f4dac9b537937d1b5b80c9e9eb126bb69740f9acb5a6b62b9e33d1fd663adab832a21eead2891846f3d956eb485a7e0f53ec642c3f3774dc2792b44b8b298bfc0a98099ad3e123fe6504736f52717921f4b5aa2d868309f5f54169d0c6627039a85dbf48cd68cee2e9b0712af0a2fc8fd0e9a87966fa3fa1ef09f71472d425461378599a24b11a3a0b511e5e929192d73c58221aaf5cdf9b64942dfb452df64dbf8e5afccde65a6546986057c15ac8526ea7244b3f521eda8e93c9b575bb31c2e6794ef8415cf8cd298de024015c989683b83a071efdd154893df6ed0b91d8fc6207d6672f97c3fbb513594ba80952bf3769bcd8a23a0fecda9bee222e83e0dd6b5d846d87cc7d8226f6a50d382b9e6da8533d3e6e7f2273c8f79b2bb9d0399de82d7e231d00d42785aa42806bd88e50030e86f30ca58b92c3b9bdda08dadf7a7f45f0efdde44222d58ffdb59f492dd86cc45b0df3bf9dc92859e11aac0338de850b05b6d453f6327fd72ff9034bfca00a268ee4ffc2ffc866b135a3abe1498e12ef5be82e9ad42f593e2e4f3907e769c924ef298d859c6a963a0b37c9711354eb9a11aaaa71e5b2910624b2adca9de619f0e411b0997ce3aa0f870803a87780612f8dab44cfafaa16f7980aff758a6314355c44c067c1aef48e902d35826266f2d91a1bf5714129b93a51c2e857a15c170d3398799be669a720e714a1dccf5cde553ebf3a470da9b1c12d2e5b732b854df2ed70d45602cd30d3eb3279330e5ca1af1b72fca7c6e0d02149db5da57edcc28a55166f7e9b1c72749e0f59b92210b3ed547cb5e9d2287d116ec598bd5529dbe79c2c77b00a4a1131a570ffa3572fb64faefb98f418e0a477fe270d5a9a1f12c2b7a1d12ddda8ae5ae751767da43572398cf6f95a50b6724a516675b6098d0bde9920f27812d6cbadec2a68e01056e9f7d0a38d37d5d4da316ee76f610a84783843c7b065e9fc396fa47ceba94149d206e19afb8bb87e1aeb14096e626736d9781fffd9568b760720d0243d3b9854239ea09cd255c19a27383721ca47036a21dbb20c4486c9e8ec1bc8e19ea228a360916bc5e79d37e3536fe67ef9781a1fa2ca3296e476743e833d326cf38407dc3b7f04dbdacad54f4465679b78b1410f4e1b6c9bc548f22c833a9216b6f9bf0c9e611658c8005cb2f42a64611e2817367b33f43133c74c76046a8f6ce87db2789bf3135bf50609378ed04c07032d5f74b17972239208613d668be3ff32cf2547b99155c092a68456cc01098d7bdfcf97b4244bcbc8b56f9321820bbd65833ffd99b60a9c0ffcd464639f180c668c43bcaa367e5f78ace858439f662d0760d707c249b362239de53597956d06b412314e3e1114df5fdb9387cb6afdc0bab264d09c1197c43dad2f15b10be83c9bb33823aa37c46c95bf1d2219b5cd1de38accdd6b8a73b2a5d3642ab0f9161d0f349220fdbb15fa1a7c9c29ff20c722e51239605d6496de5b409c1eb4930dc15234c2b98d8113706caa11e16d9c192b626a6485eb609dd1e371752d2d74dace9d4bc986aa4337445690e98de460772e9936704adc097f56e673101a62c986c829054ae5f933328b132606217a635212ae6d80511bcf63432757","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
