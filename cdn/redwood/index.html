<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3378cfbe06428abccbaf406e292f386787272d6118d8a55d839c9bef88e67e90cc3bf68fed2dc765c1e96b23a662671dcabd0b788cee6ca98ad784f27723457475fdc6c1b0b9d0b62e1ace927052861ebb3c9bc3b32e8ff56abd4f11a7ffa52624405e1e4a8c4ba7bfdc78163295d7b2c2dc5532e8bfdaeb5fdcaf70dd729fd7587fd8ce8eb1a65f86e69f209266ef7e85e83d8922540d9b175b9e78b3a44c6d10719805f0d1afbad31a1b0a745a7d22ebfabfb709567a037088b3d4026a679cbeb87bc2ac9ba425f7a7d9eb7e9a70e62090921afd7cb3753a8fae2459bd89ad1a8934d6a39c6a0899d2facd3f7cb266568f0dad0e5dfa6b41e151bd459e746d878f82bc591458910c69b3a99945142c1f2bdf1ac96506af7f211903218c8e8d8688464e03325434ae1082fdcd4c3d3ae404864da4b7d2615c54e37777b40c9107cefae1bab149e0e38577fb8b9b55679b1170d9522d68bd9da3de70c4a11fc3891d4d713322fe9d24e5ac4388f3287439123293417bc2262f1aa38746545a8c037b7669a58e931ecd896ba9e6d5505c25e0157912fa9b2cf26f7b4d9b26805494649b17de6e50e6d99317b6c0699e47e850c7f9317d398fa6806d8d7a7097a580bd1d6e25ace8705c3c7443c0eafbe069b18117d876066c6c31fdfce567c0375e19e312c245431bca771a65b55c70b6cb1f37cc8af00fd896d8e10797d8ebfe1f1e174c992ca9e3ee7fc45d61e11688e9e452f4cacba7d2578586620ae3fead5141384695bd3f5e1155e253f1dca350d72c2bd2bf9bab2a6d763db06ccbe3255bcca7144ab044375bdc66cebc155a73defc43d60356b7c23ad3a42eaa38082b11b1dda2c3bdcd1ccd20f2f4e26dbce491fc8969ed8f0cc883c591033f52a2bf167f80baa67bfb409d2ae6267efbec15b046892021420afab51150d858c23dd131b079fd60df1f09399980780d20bde770526f42c41bec08777f734a056cba882c8da241fdd698a8e4a0fbd7d3e52341f594312b0ec4d734cafc3e6fd0d07b296e8e14e0f7f6ae14e7eb6afb7c3fbc0cacb363c6b6a0caee2a72d056f4df5c6aa19931a3c850f6d7ca21c7d6914ea75f98e20f68e7aad7f91b1183575180291ad9b4a50e332d820e7e7c865a47bba2903549b702f09b259a0dea98106be5f3d473527649c4a2dc2be0e44f16190f87b293593d3c1ff03178410b556d84a3ab0f4f71725fa0883ec3207e0adb330d28082fb80f6a71353f05e3539517a9abbc62a9256044d7a61a41ed4799d208c4c968fa8db7f07abb0973ed67d4c57b0c1d41b98ce56bfd2cd7d8da850fc0eb3c111dd06f81b32a119e97b10be3ddc7264a44c92eb34e43e9c29b0b9ac863fd55fb12170f8e56d392be337e142c8b805fd9a40e1c852e6a0df6c36756c38b998554c07d02056396290251442d53b10721b8775612eef814f44b9913e333056c1c7b60f2ea77990303fcde1f89184a449fdb1ad11da0f125412353370c84f57f482ea56da43f4788665f801496b20b2ec29ad2781847f05c7e28e0314f5a0acfb3442d13f1100a449fe4e7098f0738a5f5890ec127043b2cff16299d959fde6fa61625faa0b1c0be8db66461b746f72452536270acb6af65c079e5236fce0d1ae517d67a5470922024202cd57d1e50649416cfe28e393a0da198e5cf078c338738fdf7cea2e7bace38a48f50579bfc3d260b45c6c17cfa8caac2f08df44744ec7a2584c81a9fb78a133a662602db70fb01441f6b2d6660b158f2922dc2c90dcc3898aa9b04dfa79b7e364dfb7b81b5ea8640959915c36f606872844ef73e117978d96be184f2da78b677425a1d16b99ec9f5cae73a858829af96c4a6bd70101a5c329e24a895ad1ea35b1b397aa146bb3a945b538e013ee8c38edd50c88356fc4d20ef72496d2db2f2eee7fa77a2976b5efb1302a9f4df7f72114110940c1c507109915d64894cb22e1b1f2c0d62e90830a54d1d842dd8eab07d0c8464f7d19bfdbfff065618dae77795366e0ed64cf375a38cc4879a5e91706fa68ee76513986d2b7b63f488762d63285b7cc3a08763568db6a8314717d645a54a752e5223c43137d1d9a6e3e374cd00551dac64dd6b1cdd4c2933ecc0587176a8fa332aa3416af5532171e452fa276580c3c3c3e1ee57de5845b4717178abc24445ecd785fb672d9231c38ec99c6db4a0d31e33d43d3113c116968cb130af66737fc97648e0c62afc14c8bf61d222d6f2f972b4791f7fc763210f14097c5026b3b1c16551e9b0609f1432011c491ab3407f4c4d89e1a926b54f6b84b65039076335c74a87ea922a8c5e3e64364e435cfcd57fac0e393b4a86e4ff0fb9cbbf2b3fc8f81f11cf073bd27919f67aed0b19ad54514ffee0a6e8a379b9c841588388bb1b3a97a5e983bd8f953d5cdc658d312685ae2f4fed382924e57698035b3e44f298f23516aab7728c9c6f51869da8d63e393d6930298b2f35ff1ee7b025c189b46ea8b3750e7dd097a3e1dcf144d342e9ca97909adb90269c87caf6af010bfde148027302de43885abe41f72e7c7e385077ab589cd23582e89e12ece9c2a7e0d591451079c0bc8c59c2452097f794c986c68448ca5ae5040efccd8a9a2e26af69580c8036145484699377685b69b5a3e937ddf34833bb04e847bd5ad4d7c3a87d730f1802c7e268e8facdb2887d7313ac7412c7a6f5cfa9a5aaddde7b9cfd786203d9320ba03ae4995269e0b5958ca5f2f40abeb61856e881d83222b1c2a22e70419afd13b765850f85f117ce0f348a485ddde19c6f4adc54bfad08981f21c181250abefdf7adf0802aef4e7c336c1d1d95e791fa7a1becc2c44e2e0049af9b6c0f9421a3a16a924cdfff4c51f5a711a05f8a0d818348c537ef9ef06046d6e0f90fbe40656b9a735e9075c2e8f4898e4a6c5bf93650598cfb63a5a47e04ddd64516362b8d998a8d786d2b1ddfcc434a510b1dacf32ad47aa6784f99af74c1d9e377435b1e0bcda877fbff9ea6a8c804afc31d87741bc2bccd5f610595675e0f0f928c5ac86419534f17970dd2dd4d093b1a4e4492142b2848399a305393ddb6b309e9bc8a07c940dba8011b0acf48f908087cb206f5af143e79e0bddefeea6ef5087d7b96f99d481dec4eae0480cecd87c93b99d1aa6b40cf0721ab9051954d63eb7e8a077fa9092e6b88e1dedbe00c7b680319e31bbe930a8bf00c362151e0a3bb0507d97427fec77d61fc86c36c5772b7d953fb961f35fafe85fd066b837a4cdd93923c7af366275814cfa0616843a379e3958b7747656ffc20218e8266ea735844357df27764045e2443efced5e3e640af13c48e3bcc845bd9269b90c701a392f91217cbadcbba0033050bba0610ed35b898b12dc8b6f0ce2081cd14a2d7ca04631dcffe42345c9fc9978405af27085dc55a83bdfdbc3be3cf1da53ffcfe2865842a409d6c6e882c58f4221f4723481e4936e47d548d9cbe0881b60031b19966b80f37ac7b4ce13e3b8708b2709d4c87f621bbcc9fee74046161e3329ae13cd0199fc71ce953a516df67f92f5338131720a912fe4e4de159a77774b307682affa3740235b2ab34501efb3905bcfea956fc5f820de71ba7e69890568083985e0791e6acff718ffbf1578b870278d1b251c4e9cff1e39033bbfd787ad7c6690fbd311ccbf132300513f9fe1c22286db5d15b9e9ed3686bf03e99e233ef803be5a9ab840e560ee87d5ddc669af9267eea71d5a6b306d79af56d83d45eeff08514466400a5f823fa2c8ecd4485e7008d05f047859e9bf4fc8a3173e7a8c80f781a1fe35b51b3bea2208fa1f612a843540d4ec870f2e11030ed311675ab109e036ce7ad6a61ac08b867052ce37f5e432149d5e1775ddf9ffb89d147202a64c518fa303f125c179f581755e1959b33706993d4e8012c6d7d38d2b116edee46225fd29c5703832becc5385256951d63609045c569f7ed8d7e86be0b40396e23409c6a8ec85774e027c25b82f321cce734a614385b44f6a21212893ac150e35c868ff52929a424be9c9aefed27e4e28e8a080355f37ef13270c75422fea292438be8fa4e8bf8f167b241dc172d203c7be9474d56eebd4a12227cdfdca074b121616a30e93a96507563158e46b8489dc33c9d1ab81294637b0770b1054aa677af0264bd9f08fadacab222200a693dca09b26b219a580a41ce2911ca41bd5b6f4217e96ffe1bb7818449c7c6185d80fc531d2485eaa3af5fda4aac501f3bdfb18bbe0920d1d708765291092132e772eabaa5a28dc49e589e54dcb56ad125d71feb7289ce4fc2603d2579c81e8181c1b93bd672056edfba113a68d1a7844dd3e857139dff24e3b8dbb7e3223229b164862567c54c2c7dccd18cedc7db26183246ffe3f32d7142d14fa5bc99b80c75f4ec5610d783eafa1ad6619980881a16fdc70197196364e7d32be8f0e47d14e609cc958c1bce1d08b3073084c3f9f9d284b7f2ec219a1d95a39b733f77bb56708af78540565f9073c887223c4c6ed942e7b916d9671c28bd0866e571e823665f0406db0a41b63c15ef7eb698be913aca6ab7cbe8eae1458be1dbb0a4356b04dbc12669619477dfc977c32d3e9e56fc1025e79c3823ec551f1dcc47834ced236f10d5e46878e688546cc2474863b28e888cabf7da0222580944be16e88b61453543c747d7233c97155bc9fca9e7a4f49da3cbaa6e696a406f149f38a990d509a9ee8e2c2e8a66da08ae7fde8304b7b172f5b9fbc4a8e1c5d0d7f11f694d21e9e7be17209fd0aa9653d7d712917c554ced6f1a18a6bacf85b1880ddf15084d376e454bbbdbd5214f4191b684f82b754564615660d08b35770a3240310f349788661f8c9e30f976146d765dcd212ebc2599daf9d8474d41017530454dc82b47b5deadd650fd7cda917d4483f9e7cac712fea68c9ca207173be8f599265fe85af33f10469ca60a0f5ed7f4968f8d4d0d1af246c35d1437496eb700b05778fbf799440d3a52ed665eb89315eb20bd108fb87b56cc34b77e60486f0f391d5ff4f5e4f70ee8f9a7f654b021c5bc8b4f0dff1141a3c49546d7bbe69e2217a72ce08c8928036d68452d05d25dc7caeff68d73ce68a6bb2dd72aa23fc2c8a406e72eaa1372af571b4b7aa9a12c9407d80a038b01b4df2ba42528c0cc65ce1b2c5b3465bf9948effcc26b796ba5023f0df6bd5448e12f3d8358e13304014304c93fb998cc95e40d8d5fa1fae43fc376867474d03e92bfda476e3d7a1e96569b312372c2218bbb283aee4ce8bbfbdaa455f89551b0f5e9f0b312e42d590e2d8efa37b526bc4ce2129e8efe38ff278e4341cef007b9231259d14cf65e17053d747a132ed97dea8ce70d3d64d447030c6a8cdd5c244f3993f3c7cfd9aa8bac27f3c1dc626a0be5b238fa22dcf9ea336030e7ced7b3fafa7c4bb94bfc38282921ff01923a83695a173ca10d9996e36237a18ae50fb025b440ab344ab6b0739d929fd2f41f6269c0906aa456633e7c7c3a79c9ae26db931eae6286a07994e55852670cb7fb00017e77a0b410ebd8aee850b97fe7e28ff4dbad7ab535b197926173d7ca66f71cc0459a043a2e33dceb78e56bc7c3840954f3e0e98e20b97c2916793d4aef8ef33f729a34a6105ed0f6047de76cd63100fdffa5d4e565d3e1613b395a86a467920e7d9c06a14fdf43d390c08ad6041e1c3c865844e3418e57b3e4bd050141ee0fe01e5590563c97000151bf4be4fa527231fddf6a168bcc7882728c4dd437737087f085d7ab611b350cc5508a69727e712aed93e5329a80f9dcd132a17f64bb48d488d50d4296b716482503c44855fd97128b1c262d623fd0b1d5d73131ce8331e631274cee183026ee62a577d421b95f886ce5c0cf1d55b65cae0d320d7fe390420288fe18ac9bbca7cdd7e10134d156a2c9634ef2bfa16db046185d02c225564dd066c23295d299a21ae9d1a11430ee1915dd6c6f5e1d17e1e39eb8cbebdfde5d00986a6c0ffc60305676a73d98f2345de448eeabb1782807ca0948a74b805297c9daeb60be98e87ce58597c0e25f5ce0574b75c92aab7f21aec05c5b69e5491695c1777faea74b8ee2329fd2c78ed2e1151a7f3efa7d3eaf2503f5138ed8eea709acbb786a7052bf2713fbb47ecd311b5ce1131df5b6047006f76888511c34fdc7842e9adc2f6ad9e93f1e71d615a33182d02c801fcbff7559ae9bdf18ba6aa9d51698afa10b6461e816a10b8781cd8c92eed246dbd3bc510596fe9300291994abf05a4fe01dbb7328e6f907a9207ee7c92444c801ae632a6bfcf55ba4f26e65f2b3cd291b559e6eab822e09017f6c3871a5eff1071edae70398625f803a696f404ab28a0e5de9c69aee1f85d146be99e6a23782d8b480a94a028281d5a42c2a237ea018d237f221b436994f1841bd3446ce9a114f829ad2d50861553835d5a032d18a2a796be43ff42f9c5eebc81d335a8bd7ea0fe2f7fea6a37fa52d110bbd9f7f23cbe060da8d7c47ea64329737adaff7033c976ec3c4381c5ea6d062fe74b6722e2aaa65592b2efbdca9fa92bb4ac640c3a778184469619221600e9c012edd64b0386c3a43521b8e93b18089d1cac1a4c69e7c21a5e6f10c1ad601cf3b739a86e5cd9e7681b17e6874a97df55da56ea761d8b61860e646ca92b346010187e763a1a8129cc43897f57017c6603227815da7e0f31aabd267cdd3d8a47e3604a25e7c2209cfcac6abd6370acceb42906f7466c4ef4a7e4ee216c5aa82eb34074c0124de93ffe8be95dc7d2aaf84f865c7ce76501cf0daf432fdc8e142429d918863e17e914e884730fb6e41630350667e2588a7c229b2ac7f4aa0fad1ae99a1d8fe070a51c7201b7fcb6be17b714e3f80e05ec6e7aded9f5415aa76eff35bc0c7e5e885699ff74ad5076dd7040c0b34496c2e52b2bd50c7af1a25780b6ffa85beb70c57e5549352caf4c32558eee45bef63384e5b52d4d877008068f27fc9f37e3ee503b549fd4d7ce1d773d6202b3ec1fdd3354b500bd973fb29154aab4d9cc0955b58325ecace8fe1e1055e7be561b9f72bde46654d4e3d7933e62ce9588fe381e20bbb4ab808c8813a0d429b13fbc223627afca8b5e67b913fba06aff5eb7d9a4ec954c91fbbbae54b0e9528c03af49f5dfad140437d6eee222ebc7c4add3e33797710076e0196109cc4fa22c10b8c00ceada19ae7fd850cca533a3f219ce4cd1252c6deb985fe2fef34d3c7f68ac32d0446ea4345b08d6c874f335dd7f0b84bee7e4e8e13cfc36d220f21ab7b8265cef0aa6663fb65ac5a9bcf9885bfd74ee0cdb5fa831fef03e65318db0ad5a6121213c9854e07387a613b00957e2756d1d2533679767224bec6f4bc6fad9a16564b0c87d7bc72a2e08c7488d6add390125b87f0748d7623592f3b306e2378f49cf88c3191f3ea75178bc846bffec4040de81201061e6b0233d02a31450c66e45bfe76fed36bea68d9ee8ff5f0853f70a31ef723888637070cef718c8dcb8dd9e983614177ebef87bf463c6c01227ed2930705bc5aa987b465f0e74c98c5288bbce1872c88a291495084c8153370370de2f97b4953dba67ccf380d1f5840c99b747b0824e96ce511e8524e832231fb37eda22c76ad034e4bf847014cd1d9e5f3c30e82a8ff630a78490dcfeaa4c3654c77b6028e5127c308e13c5ad5997f25e6332a4cfd836d7b0851377dfd9f19670366d75570e538536cbae0b0eb7e292ccae33ccb943984a64d59478c7ef7e3eaa0e1181c58364910ca8872f7b134bfe9c5a8c81841f6d5c47221a10f9adb0e483022ee7d76bfcc74abea8b4c984c514c1f57180ecf7b3ec609edd8e861c6700b8899bd354c4c2e0033f913044c89d44374a65c0fd95bc724b71155552182d8a1483e1fa8ba7b2c159b0e71773f8d86bd89f5ca89e76f5e6c89b798d8dba3ca36ef2667084e7f9d4f72063237794451f8cf50fc9e7aaea4e38402dfff8f3c0d000ae0d68469659b07762273c7483b7b7330361d5c1410946e6eda8c4f8374999b90d159989523f0e65eb5f368ad2561840838cffaf76e91f15669164b221893dcb26bbad68f18283c72b08c67356af2307aa333c6a417c9bf1590cb3215ebd025cc725ac397be51e58f657be95947183deb9e2e0f806095d39f1ad4c446171326b4d59deb21b8fdfe5c8e35202041833dc8d945843f48546361bc14d9d391289fde641378b3fe9a1734cbde36c0e06894ae8ee3639327a6b2f3bf5c7bc83ff43f412aec7651891a2c9f470b46e1a6bdf77862e4cd8ac5b10d6cf8ed13763e60b34cbcad17306a5a95b0063f8027632fecbefb7bc725f288bf5996f1b99d00b1610d381597c60815c84811f000ffe3c47fe1ecc8d174f0276b293735f7a351b8f18974c725a7d499d471d7ff1664b4e5be76044f04ca6ad9b45e1627e1760802fc8047759ef44cf55cf7de1bb28765beeb450d49dd36bab65c03a63649e478c82010f4822ca67535134f4a47db8497915f533b2e79ac0ccce5bf703edf705e8a7b34c51f7b31ba30d41af1e629b1eb3e2d144b27fc317e692c6eb407720fe573038c8da90f2d5e00dec780122afcb70f522747c93c28a71cf97eb5b660c069988ddb09b8d8d0e840b0d551d67809a321a3caf697e70c71266195abae7a51d9027150ea3097e3ffdeacf3f9e9cb6b39fa0d9e2ef9171598dc2ee75b7d2f7955ce08cdd195d0c5127d4cb1736f419eaf6f5870f84b09502fe065c3c2223261cd1b1d49fa988fa76e216095561b0c3b1e923b57512a1f0d5f72e9160d25e333cb7ec1a04fcb84484606a82ff16b33db1cd9b1b7ea93ba47038a87048a453e30dee78346f2538b3cddf0a73e2fbcdcbf59666d2213e85b8e80e3fd3d2cb86235dc1661109707014d55859f03cbe9bee7015226d2adb5c9a669b55b3c597cdcfc5264632db0b915246e7142a22d342a621ce1420b61bef7f41d35a7b244b992d86048a67f59bbe8e335f90ef4112c306b17a151ea7845a5c63919a7843d15114ce0a66ba18728644b8883966d3e901b0f5d7478632aeb052cb358f5e0a6474901138a694ca322e89ec10932124169557982c9cd44df6c72ef8cfc98770600ffa2e9d77c9bb090b02bdefb7263105d96ccd661a4fc4c5e240b24b94b9d46c8b2099d7fa363921c295e75c7425a3d27d45cd364f96658de69739d5b5e79b8f9fc2fe92d87cc8f81352fc5016f6ed0b1ca1c19a6c658e71e4ca04272e9d93d9b1331d167249b9567141c44d6890de11a7659e16123fb85d691dee660940c9164882ffbc2c51a276042ba22ad8239de712791ab9f4756ac01f67a75b81d5b4108244e964a40fef6ad2ee725d080c597cef32ba782569a60efa5f4ec9a4acc7c12ea7f7c48d78b42a9b7fac31b00dc593674f534f9e4dc75fd513b3e8e46a23c5b4647e0e6a58ad8084da1cf0181a089835227ab3d0fa588ddcdd14d7cf22cf3b78d84d9ef52f826eac3f5a6b5d5b053c0dbd46896d8e2baed5b174224256007a445ecd94214166aa75edd8c556f3759cf41ee30cea96dce4562620d7cab56b3b9c569c4b055766811c745e4dfc6c793bef4cee39d43e5c443604e943b4f786a88a56f774bece976a262e309e64e1f6e9f56a8448e390ed608141b56ab44582a3ce646943085de3aa7f5d008a80594cdd33d073a937b22fa7c4d3b85c23bd07a915c12af342597a24aed2a8487ecb1917f49f1581b98d2b54a46ce159e868ad7821ee44dc048e08d9f78f24068ffafaa8b6a91a359bf07e24101dcaa8b8cc16202687ab0a3758660b8b49bfec635f863d50eb457c8eab14774b96c8433ff3792ddb17aac6a3788f275af9bb2af0eec938a595775c97d2f6455cee4ef9ce8f50818d9a0f923f5bd22543c2b832abb74d1187c9f4cde921c4d3875997e7e62d97e9049e0e34e1a76ef4d5c54a4305ab48442a225342fe259c0d62bae8ff0f04ef0d963019706f140481d3f1b5bd3533fe2af7c621c5440bc670dd1570ad6a9b2563a7ac67303d4c2274a027193a3b901f7bb43e60168cb2dd60753f5b3872868e1f1f51ec50bd86b593d92d48ab94040337de5533687aef372ba2f6757684694d9800d34bcf6b5ee1416b1a1dbcd80ff559ebfc93fae18ad0208d3a210b527854989505c04d53ad42f7a5136d520324332edf8265b6d32e6302fadebbe351521e51b88e0026a21dfedb646caefe9abce7080ba74bfd48d0c4018fa3f00470e56e607ea41f8b9187a956a4bc2eab0c4adfe5b577c8087b361f4d489c5b23055204f24f850cca8d993be33ba827b11b31261050b0293859108b252bb05d4f7cc6471b07fdffee622297e5e220fc873b2fbaf4aa690b21af049c7b138edf876b8b97ee644d283b8a3f6a5bf99b1d3d4d273fb3fb8852a58d30a92ba8fd14c6aa36fdb48f15bdd42da5c59b8f224ccf9141ac8e3d073be8522c7f88809c6c1f70eaf3f7f68965ebb636f05f34bbbeecb57cd95629b0b2b632d8ce1e06b79120bed2f823c068ba6f562f9035efb9de816c0c588ac6e44108a92215267306f5faa21198364fb6221b570cd16c0659d3a2a3d1cfc5ca3dd4e064fb4ca8c06e1548c717e90df1bee41e7f75578e3c90a3be3833d7f65342408860e6b0d168b3d6a5f8def31ba27c82ab864521a283eca6967a6340ee1922bb754a78568b3cd1ca84dd277bfbb9529fa5ef0fc5ecacfb199e5d111f2fc0d87da5f3b362eeb17f1da1d455bb0b50681be56b41ff4eeb27e98642f15fc83673de8f08dc3d0453ced20ba69d2a92c9c2947536d156caf8939fdfb0dd12a82d35eb35626bd5a0d1d948948ef79fea15736e5f9ccae211ce209d3723ccedd741712d2e63139a23523324be13360d1d48cae24b5912ba00c6b0df38019708b1383a22f727ec0b2f95e2253f8caec896a4d1070aff38bd5aa835e371bf6bd4f4fbc84fe86dfbd04b3a092f09e0865a90782a57a9b1155db23752d4a0a1790d8e30d812b2e3cb30cbf3fa7a7c9d6cd2e7f1be2a94662e9a5369fb7a61f975280b0834466727f05dd457938df98c9e459489a4b055fa04d95db9d904b1a13169cebd3f3d6573e69919c4052ef99105b6e7b50d23cfe969c487b0593e1e108fc4ea94956946cdb17ac192f1998b5742c88cb9bfd4e888f2fb69f62272bf2a07fd4fa39f765605d2236a742ddb99175be3eab6ea25357fe1b02e30b49202bbb2013e258ef07ad93762f3dfc105f0d2b8e6645649bf7227d6dd57a8722a151c7cc8b0e1007d244339ae453013eabe8378905917e7c6d11dc842fa9c1ea02050ef0939fb59b6b720cce470167dad98e20d871bb85cb74289fac35e9ca8181ffc72a91acb949e79fd5946e2bddad01dc4e69a8791e5ec5177a3fa9656bc25c0bb6cfb4b4200445f4ecfd30dc8ef1f7e8d5de64e1526b13919fc5e57e213b0531ff94a78d1cbe124181a7ca941019a476c201752ee2a92fce31db1a3398517d1422f1c6325c8b3143915cfb62029773d2acb907f08d10f3595200bd82558d3dc13f1c452af7798ebff6bcf3cea0cc030066f0f8a7a7a234613180d2355f3146475d9e20ed940e9e4b569d915e32468e1f8ead780ce913e874d6375a9740a48cbead17b822d7aa7540302dbe07c4f569d8d2c1af4bb9df922dd861e223fc599a935c66f086f99dbc22f31bdbb0f6900ba0c6b5d270298b5118f8b647470efb9ce48ae9039190d12689b4daa35583c69ac370933204bce60a3a216c4abc92ddd2e57ccbbba5588c78a6a722efb22c09a515aaf23dc0e476c8a50a82849e7b6ea97ae954c0ae12ed1623a070d52221766c32a363915cc23c73a7854a84a52a2c06735ce71e6a0baf2e573b5349febbdf31e089324861bcd7f6aee84bf57d855fd0c3bdfaab06ad1b0e5ffbec6617453441d6288de86a02a7e2740cd4b025b1811881f30721687d4c7f8e9b8ab95f0e1ff2cea73357e56de9b237a5ffccfc8229c91f622b21dcc6d556e67a9e8a3e1000b7360dc093c85a3e6d70c0a304e4f4dcee7bcb796b3f65de09fb017fe690925796f2c911e86a496f73e056586dcd0131be429963b434274d13fe8423ba5c7bda20d29dd5728a2ab8d2308835bcbcef12fc4b283c86bd76666af9157e12615d811f62c9908627411d2d9bb6543232a76c0a1dbfd79ed7201480c0b7d3b2595640604032e123ee93502c6b22da8c14909ff220e5df57a6656e9022fb913d6914a24e4f6fa7eb73c653daa70fbcc5ad49fc9c5be19532a2cdf2d18be225730fae129371a1e1e2e40aa68a5d0ba273f8336f55a2e9e5507a9aa000ea3498ad39992e211bb0f8525ae8fcf6e5f283b5643a0a333fc0c5f4798fe4e46cfef3cb92879867a15d181238db1b87d05df1980323074cce0a527f3c701399a72ac21eaa07adc1e79f78ed3c63554cb0a2181e9b21c455da7971149548c56964d9f9fa20d4bffa64f48a5d1ae94cec0929a694ddd10c51916361a158b94fd5e1c991bf6aeda1c02339e5453d6db660b693994fc86792c48a979701e5ed03455624f112f412bf3ddf3b9ea04b1257c43e886a9cef7af78f8d5153c7a2d099281e10be77dcd0d68dadf238c979f0bfde2f4c594a0edaf75e929e40222e5f2a37f44c582f5fdb5d269792e9ac782a143fbb6719cd2c93e7642947761a7e75a0ab8e93bf8cd36287c012ecb49f75049f499e3497d687d5955e4e16a334c5581ff1186e192c5ad810e4a856907ba703b9efad420dd7ae259e9f570c54ae26c827f286dc6284924746e348a8674d5509b28788969b20c750b16f77d11e85ae5966b46305775c0e45490911fbbd83345fa17f3692ab4772fa1fdeb61d1d53a89827058c827bb59c870d3ad981700adef4b52c7b2c4d9270f96b4ef3c9d641c5520e37d221a9c2b6b83dfe36fb800f708e4d1d2710e6145c6d03008a496f8ca638173ae0b21a5a4278e1a374ed010dc738b939e7667b27eca041a926ce84925ee74dff6be91c80d13b4b4e139b1a060ad9c42ce59efbf46ea1fb05c7f37090b8ed3b4dfb70309e6cf2ba4666c9be1a0cb75a65f39734eb389159007542a286f51b63e47084b717940c5c628516fd6c3f4c075c8b1df6a956a443686bf3539ece7d9b1eeb68a07a862f224496f302be2c3c775a097d1558b328e5a1d38d8d243f79c5b694ce5b1a9945e140b59b187c12f9e6dfc7f388f1d01125179835a752a088f9634d4698d091066bda02922223a267dc406c40f50bc5662e74af0810439877e42be34c2b7856fb7dd264d647749670b284653ac916bc0a5dc4c576856aa98dbe9fb8aab8c321dcd3f3a552b2bb3abf91f6ecf50895c57e970d834689e9f9daed851d052b165c9e7a6b094538b523fec236ada7c40bbffbb0a207a48ecda94e33f6e57560a3996a06fd64eaa94972d1a1f54e957c2ba280d8711729017f89b19155785ca5988cfc3900d7483facc7db0047f311e4de0a25b8b009adaee17528413fcdbc0ea227b2e1d3641f7d99af0a99efbd637b52a12e0aba258a4172b1d85532b6a846fd34f77b567b2d18091ed91f39fdfbcc6060d08f6092f0af8fd2bca7eb79a20c269bcd687fac5939fddf1ef0d77e9192a51b57eff6975907bc78711b81f67af1839f598d246983743489c51f43e9d5d3c790dd78bf0e32ee5630dcb9eb4028e9866f25c7a923a65577896025aeaf78b741cd247f5fa8a2fa4e78d22273d48f23062492cb952ceb3881f99cf34ac079e03861b48fea318b4eddddd08d5af5d72fd0b45b62f037156d9414805bcdec9f40269b9cef5e03a8318e1f825e89e55e719aca1902bda0520a472e255b67bfe2b58141554566a078344ccf8a2bd22d2d19105600cdd4b33cdf11308b3edd1aef26d8ce8ac3c69df577357d3a7d80b8b29da39579eaf65c660ef427c1b4ac3b16997d0603b0ccae5cf06d4526c2557eac29e8698ea0f353b5bff8ee55b45729dabd542bac7b67f4cf9135bc3f7042e8ecbf5159a24f39219136ec75a7072b67ff46c1b2094bfa97837df5202adc5e84de6c0f084b86c1321b44aa5d2bb33a4c2fc6021b237b7ada06b9ad18ec30b01d29f6b600f98c73115dcb6e3fc7480405519c8f93eac6c25c66b944c7a417b0b9cac2a098648781f880d92e9240d0aa85573830ffa59bc17f7f7d29b9122d6059f5eb9b0e3f3fbd0263508a97a098b2aa34d5b8f74fa61dfad705905f6e60cc8e317879d42ca898c0d151c8f0acab14ead9b499c237df14fdb36e643199ac2e8d7da959c7e560124cb65fa9c17f2d0040216cf624fdde52ab55dfda9c208ce0bd3a75cbba229d87b5d73871e2684727b48bb1dbc2e08483db505a4f2faea20e9a895a79e1831048263e346b8ebbc47e3872ae212cc7e9eaef842f5621c75bf82ea760ca2626a2e31a0154e92fb6dab2e9d70e3b0ef13af3ab69e615a370c350b99b01e069d72e66ca7d388a3431625e95474f28661802cc18cba5972bfd7fcc29a4a09eb2b74c1147244f24052dcffc38991679cb0e03eb31bc0bcf1ec70a58da7ef1775035d8a56c549e0b9502e0893341fc8b58505b0604182d8ce938acc0e53c3c59fe7411166b6fcd2e6d1b589c80a63990499c4f91dbc4d187d8e05999b445ac6edf24fe7d7f76f8a8579a91abfd83eb6ab226f64081185f72fb9f285d9e698269d55c39897d1be7f1651c7cbabfff2a7312a46eb8caa1b6e38bc96d3a0c3c14ebe22a28ad59c3b81fe45d051c19298ccb9b518aa2461d393fdde5fe60d690770f5241e2c337d4f4bed3804e3e688d26be7d34b80e4f2acb4b83147fc7bb4867edfeacc797ef8e31e98d3ecff9a5fd10409a3ceee65937f7a2e6a95c2b58c669154803eea4528dfdcc2d6c0e2955412c88ec00100f77a263136be07c529182da6f93db71d117627dabfb98acfc7f93c2d9f15a6f880ba50a951bec4f14f538ae3cc6e8af9240b4ebcd83270f85ee74afc0356611523bc61bffdc98a93a296ae717407ccf636becfbe7eec99d43ce4ec6b801df497df8bae3e9b2b54e8c74658bae25d1335e91aa7ada158baf5fc6e5a9387897a96c2a689ee596678f27c60f7ef19e5b14871171147a5c90a3025b676c881c4770e7d269ed458a0db74028fab72092624fecca6b940f4a3ae4c463b7b6773c4cc86df3fa984aac8eb14286de73982c349b2258e000f90353af68144208e84e50186e0dedade4a411684a9bdfaec53919dde1bc27cd6b262058862e3c3d3db92b4fd79d5c44082211e93ae117f10beb8e90294ddd4c353580018b43476430f087d90239a799210828c6216b3d41eb43e0bf6949c766cf442ee770df00dad682ad433ef896d3dce779f629f72edee504824573410d9f468e24678df013bc6022ad74cc2646b9ee4fb46585e0b67261c36f3a20ec1eab351d65e2832cc54ed4334b95fc2851b8453a155879e6c4c5af532ee5f34b7f896266b0fbf4af8ef85f5484d5344b534729bd1d613d7d0ef6bd74414fa419d46ffba8f1b3c3fef17b7029c89ac8fd5822d46e00f8652b0ad62f4ef55f01b4c4e2bc8e4644b0d35ed0a44a7a6a0ea681af2147abac77ed82342b47cb3d4e4c75edbff4c849aee1033c2642e736edb7c2f4e3c499c53104b4e39afee7eae1b36a2d35745d9d3f35dfa1ca3d285d7da26a060dbab79510c33bf1e74fdf8309260655f4e1159bdfa7b3a280db060e371d36051731bd380357af063a8eccf574a0c60e46b82103c19d7079da291894db981c713493df408ddd48b09a9e8105150274424a9c5054cc38ceca083869b88542eca1d278cb967915c7788c30f838073ebb6928e1da3a73f91f0441b716d0803bf054c4ef293e8283cbff6e9ca357a1203bccb9144ee7ec9e8d84f2966e018dd182a154843edf086736b244bc67dc0763dd0f25fe2c77264805dcc49ce47264081b92a210ec81bd14c738818cc840abd7cdc08d0458e126ca4f521285df3fc8fbf47a7e872c5a104ee13984c0866ca32a086c36720526ed505efbb2d226b8e7d0832c7fc73af9b94e2e8ccb791a2b676ba77bec6699f14774b0918cf6319294dadb8531c3afd11567b773e21de692b13964c9a3e912ce31a7aa313eec635c04523c918137496ac4e91408f465eec7ff6cf7cc6caf109ce4a556e11a16142604272cb15c067c91005c2d031b9bf8eb509d156ec52c40dee4633e2d73275efa1622c986cb35fe31c0cab83b024c8315ea96bc0cd8bd6eaf8f243a46cd9c00f1dad3dd23baac67f32fb107e108d0ad03c50c4bffc7c6c282c2143cfb91197afacbc5106a83fd69bf6d6147dc9fecb7ff2b5ef54eff5017c3c17ac38f8f58723ad911bc683cee4959d6a2b1d6e5cf2e0f9fd361ff33dcf79e42b5bfdcb60b5ce0d6f3e4d3268be9953307121e3f6b67cba9e7e71e31d5cc7ef3efefb3c890d25e0a37325d4dcd93a4ddf898b075d9e34400b1d9952a2f74446100fc928add0e0ea13ee7c3d5eb92b842e843d54fb4860cdfbe5ac60022eb1a8e274c168b474ead17a60b5a774e7c1de370eeed0dfecf49191e03dac91a5f381d46db7f4218fba8dc924ecab5a5de39b6a6b0f3a9488f8c2db401df6a7c90d0c78544a20fde0e8ec6a5ecb933524405f84f1432f9e446ca06f34416bc634fa449516a3735b5783b51c567088c3189a3820151d1d307561ceac3c6347263c413e1911f45e370973a22f159097600aba1d9d87f49470d60317d1f2d71ed60634074f8a6c665f875e9bc78199129a961ee2db61566e3390a943a89e303fb26743bf8b3efee9570237e867fb1b81a526760a9279e907d2cd3625a7f43e4b7aaa1a3b7e3e6241d63b72e9a54a86147eeae699012f1647d95b3482f4d7b3c6c768461ffeedd885b881f144d185d5ae80da8ac22725cf851ffaa0a66a2eacf1aaad5a9d850fde18361e5dc10bb96fbf8f89b76ce5628f27db654f276d73cec984c5f7accc63157598c4761de7ad269d6d4336fb9e9aad89eb6e5f1e117b644f81f844a3717b640e25a3b574d13f4d18e4cced20bdc6ffeedaadd22faade849213d4e69b5076245f9c623fc9ea36557f40571742021bf97e689a959b0386a6d17589bd59ff7e5b22fc8935ddd33d8bc5f6d5de19f24436a21b5643211ecb8945de2e19678a92a28b0fc2d72bfa691b02e41bffc7906d24990fe8184252406cea8124bb32a1106eaa86100985c60488424a4b2b81e948ec529db2c2104cadbe4073b62fa8fbf769174c2e0a87640c87917211bc181ae11a0b8f3d5af00936692973c004476ee37e03631a3b4622b9d968624b99f6033ba95a45b1ce253ef346f4449f78b5bf5f9eef023c6a89df07b1698ca595dcfc26f2180e8f324fd8ff4270626280d6e8dcbc0ae8c78c6ff647652cfbea4465bb7c1fcdc9f710ba428768280807d4730cff2cad7183e3a2298c016a906d38af4b9529b10f259eede9961bf5d0721039d97c2773cd838f7b9a0189016265bdc6de34502756901e7b160488554126bdd95cf78e7b5ee587a6433512c499b19fb99ac3b0c4a985bca6c500ca7bea0022a7c52780058381885e30d0104ab8d58b3d9f3b1b4e31660b4a116f3e1e6a2aa2f9cd2afd31727e23d4e5172107b4de9e2af0e34127ce5d819c09163f0c8a4ec2e93413d324f9ea44f2fd5e0e6008c832c8c815a279571fb3967f64770bf7a124d382af5829fb7ce2d4c14c8989b49e8568c3f4b024c52d3794d0dd6735eb2427eb5a63010f481ef3d819979d8c6921a708e2843ee43ece1abce3ef62c658e834a17370ed391f2a7fde9fa8655282e653478c331c23cfba5c831c2aef4be07364411a498212a54202f86c1357423160e36cad0b1cd7f24f3629272565c7889eb0fecc0b628da37d6fc5e8fd7a1a9295d2e84240356d83cf88ef0941f859035ed2e60c59734799c7f4c4460bd27e5fab4ad910d9cf56f60d003ef6ec10a1ebee3bc3904c7e4489a20fffe3909e95291ad2f0e744a8dfa6f54935b3dd545c9e1871c32b0f1048c0bad787564f1f43d62d2a37dc47a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
