<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75355083e05ba770c10a563b5add85fc2d3f3caa762921404f31b74494e11fc20bc9e5a1bf9295d5610c4c73a6b2371cbc837a9d9989cf29b8dbe5600a10516a251d69248de67158534cebd259db24604101a2a5b420185e81dfc2ed5fd34d4a9e8543f2a0ba3555a9ab7f93a04570c068ff71869b0fc50461457f0f742f77a7d5c9e7fafa80cdd2889093778a73e257fa542a070745fbbff7d84ffc9e83ec8d55e8a04d4a26980340b227b1da6dab414a48a17f06b0d4b91853e3614709aadf5cccd168cac1aa12f1d8fd6908e7a257f80bc2a57d1a264122b8b52b3a24ecc9b1d80d320f0ae2ff8c6285b2130ed16733ea27b5a3478e71c64c74f0f2a92685fc5cde28a80bf80c67271da86f4b1434c4d164b9534fb78c69bc74edab489a1769fb54c87b179ab6b90b9a3de30ddaa26df3967cdd7cb86f6ad353938f2299cecf06d864fb132ea41e1b4d30c112445e426740848e385e9358dbb81bf1ec2a71f5167ee8756cddc0d5c5d880c77c4c3ec548e259aa04870c69a6e18caa2f5de7ec35137b1d96dea175295ab2eaf308f6a99dd8b8163bc92c2d96ae60cd41750283b7fb81e2deb33e175900a11828f490706b273dede482ece5d93b1c5ba775fb8453e2a8b849ae6d0b8b008ca15bbf08edd6e3b36d9a381a03f82bf9e1a44651f0a0e4b59fb252d6b3559f3cf7d8de3bc5de3dd26f7ed653e3724500464f18ad6bd88580311a26d754e17976fdbd947d7e8afa6ec329e962915faf845f07a94900809b88214e3d52b8360f0d4705074c5b1feee0528228c2dfce14563f4dae63c0b6839a16d94bc1cdf46c3383c6155166672702f761d0bfaa1817b66ff65b584019077398dbbd507065b611d2123822a9c8d62affe4a07e05ec3d39f209e661adea148a7bb59cd2eab416057df7fb44e43b9066fe27fa55837dd0d293ae827bd95a380466301fc6c2cb23c90817d3f5e803bf5567dd3886a619c40699d7865deafeceb069b95a300b3b0f386938240e8fd93f7ad5b169f44da566a7beb814c61d5d4646d8972d9fc075a17b406b3115d77d8d086966fa1bf372bc030510e49ea1d66ade06dab4047f1f50a0480b1b6675dcec57ca79337e4226751a2a685bfe48afc2638f964de3ee5c6e0d75223027cabee3677c568e0aa8fcc8935c128de4ca70a1a328743ee96d63a4523e9445734b9cc4ef67d9b81280618d875e39b407ee80a02eadb600a238912bdc8b60c7d849facecba960b3386986af41fc6416b325968264ef4b00bf6bc69d1bfe3504155584b702b21b9a6a3a0e2a87d23dad22f1faa75b74d2db23d71c812d61d3a530cdbae0b693a14f9b8d61ad6e5428718e9177c2a1f9961cadd20baa2a2c2bbcc37bf8fac62b601997ad8585db3d116b3827959c343f1a85a265a7c5376b5ff156d80fecdb83bbc3111a88309ed0183270224f40a0b51299023d935b9855bd2870f9cfbfce3dd1c1daabae8fe7fa2d9b71faa2f27530a7716e10fa7d96f75f00a262e5a0d036e0e012a685cbd46a64e16e421f522b0860f1eec4484bd663339c0c30ff1a5c6c16a24660ac7f7af1272ede9e326cc08d6baa74df9d6413191d100ec4f6cf7f2060d31e9c6ed6848d000c696007a72f1e462d908a96f6c579a1b67570335b51fe1a14236f3de277752bf9446c7463f2de5d5268433f1b4501be7c9746cc9ae0f7cd1e369c803c2679a24a89de1ef6a15164a107b4eeaa94948f7ee4b25add4890f350d3227c89a43cc9ff8f2bb2a60a9b08957a664f400677c6bc0a97e84ef8990fd50fa0efab018574ec47351c580fff35893044b69f9d73e8579bde6eb783dcd6373f276609bc05176da6ebf52b2d9f64438ad5e898b74aafdd2217f0c43c94910d053f6ad52077ba700182041dc31ae2f220dcf6bb6f22424317067a864ed7275e3ba9ded3e2bee3a2c457a39391c415b951043f3bda13f38d41fd38ebfdc47ee40471d4b9f4a3aeeea7b78e83bd079d5b6fda33c46c051b414b55f14945be13ff44cffdd93dc8a0b568e8a0bf8b14aaa4592e66899affa14decf603085965e18a4db1a7d9e980263ce21867d3249d276744624680fad4962dd3ba2179d482226f4d89bdf527f6fd0716c1d522ee20a50464bdc4693046f8b4a1ddf09dfeead397b5502602335127dd5fb387a957f3de840c134a373f690290611b668e242f60a17a937032fe46d52f58272f661da7884ffcd70b88db95a66653ba232762e4d8a41ea48976f83af530bb954fc6f6c4223d8359ac5a25a8896db926ae5cbd564b82e35d33da58fc88bb7fe473c3b95bea8302b522924cc591f544c3fd0464b08750f7236a91d585a4ce694b7dd7f33a9c29138a7aadf9df9cb34343f3db92fc08edb6903cba6bb6484c5dbe2616549fc3239680f8e8c907f021fb92e8fd2fdd3f927ecba0ceefa913ffebe93a0bd016645f8f1784ebfb2f37d2f46c56d1518064cb80aa9668a33fc690e81cd170b26911650078d3570e9637922a74a19fcb68c84fb289767ab9e9af8ae612eea8c246c01ddcc383b3959b01ad33c1baf370db19e6032095df01962a7d3561d6255e70d29723c4ce1f5dc26f7267e3f1625fb3cbfa28dac5166ed9bceb53d466bbd994949c11a370deb67d429a0b61a679a4273d0744082b83e73795921fb4759a72afc818d85a09a782a722dccb5a42f9edd53f52b68a8492b312820cdcf58da9002b4744d96754a02d65519a208a7da15c450811f1927b31b4b89d5069022246354847a998a7daa43c6185a6b234f5d4b619da07563a9db746d6952f30280f3df0c5cbc104a4c296bdb2932ee096e5f7b4aabe8c7893986b576c48190e85de670711efca1ff86c4e0e28c9e44be2e7081785c6589975b4732f26fc58c9aa7ee8876e268f4fac42360fe18ecc9343ee912340b582a98be6ec6997016fa62f62a397e1f53f8ce87daba34107fc87ac375abc6b8cbc030fca2d9dc321f7e8b6c2502dd29e95b6f7d8ba9f6e89f7b3d5ac1281fb2d3f389343411079e5929dd853dcc94c98ec6127a90d7c82070be1b553d17cf8a17f2dcd358428b32af1b67c2f4c3313a593104da18e959760c93c9d0235766c2e0c84069995f5bae49a8f75fabfd65052c3fc6209fb100ac71d1cfaf6d79923ff6671139445699ba0c84c5c60e896379f1557a7dc31ba56b75905133e5d7364b0f1745ee3767b5db3fa84c5e5eac089d5dda60a0dbb9de96ace7a637b51d04fed6f25b0a0a229d147f6b74c3d9788ee7b32782f73325b8b4074ef4d22350650fbcb647cd2c6573973529f67b5947149c55845bba5c9809adb2fd4f9df267610ce2971d20535e2520a7952cb86200305a600ed008e81aaf1f992e3ce191078e800304995f8d32246205636dfc9124fa2ff25f4bb401488e86915cbc23fe8cf8a84c612caf7e5f44c3aaa784108ed1a83ea8bb7324eeec7bdd32a152dc2ded6092f03ecfd7489ee323448a02005705f7080ec8f86ff4143db26020ce70d9977b4d4b4d3485c4e46a1cbc4d53f0d87fab779fd28ab7422c5385a455627012b91ae3ca43c9978e8610a1b8ca6db2de11e05c2ed8756f5011bf24108c4e44ded5bfb713c8f44cc8479d552a7044a311cb1824751e99d565712ff05d0f607f0a42165d925a1901ec8d403d73c13cfac6b9b749e0c0f86ce499a51100c606d57a90517a452fb04f9fc56ca9e3c28bc719d289e64078df35ff302db92fc230199c12cde3abd36aa2dd789ca6fc18f2b9cb8b3328cc4e03db67f9b9c0a179d9cda27792e4ed8846b413c62199db3baf8284b99ead94bc36dea0b2f649a37e08173862c6fa8f066a76a7b3d7265682f7a2b4f6a3ed7dffc0b90c857cb6e4aef2df961f7e0202565283881d75c566ca6549cfdf911d577a06f7042a25601ecf8f8ade5ab628ea3971334fd950ffda4eaf48ee66866471316fbd77d2f40c0bea4f6c811be243f3d1792661f662a6b4b154dce35838c5130de391b65383958c7a234be386ca5d267d44b8e45cce59fa2778bf9e5a278ca322209afd52aef0c3e94a9845d14f02aa2b649fbdc62c0806468f815f0feb2e9cc298b346f8e4290174121133c719ac174bbc71d7e48dc212768bb77f324c9e9768b071b3e253f12a89e3eb5f3625f1670160dab004b42dbdf3eaf321dbdb2a3e0926b0c81b0b8434a8fa288e58b8f6abcc1103f3d69797a76fae43a0402d37efaebc242e89011ba562b7523b36af0e55b7a3c400c8e3a1eaa8b0b2e811826a47fdbbc9783649327d383476dc56cbb2a46cc0de9ca3caea05435247d20f375f384e625590cb061bbf39a7b6605dd0343c7966c0d051fd4d7528e517e4537ac3d91a309dc8f502cff1285ca7a38e59d7b0c8101b06c507b70d1aad03b668adf18a0029851dcc3bd29deb72cea4b5b01c0ce3ded8ee3fe46d51441ef2a95c28f1392c2269e6ec4540152b9636f552b968831aeb8d46468b06e80bd2fa96e88cc4f7d6eb6fc5cbef08ac19ef91f107a9d534869f877ed703d8176004f470c50ab2f7752223c585f0beacf52a4726592d224bf7234fb5f41848af646f3583d3c766fc23bc80bdfb9f54971ebc1b3556550b3b7d8eef02776080942050c6e610e50ad703875816586d9f4079573958fbc6a860990c73140336d4952bd59a243976e91416704e63b799d3cda46b3d5bdcece25a4af2bdd87805b829a769549ba69d7cb8b7454a887331e5567d7126729afc58dc64b00387c3391a505b94a166a9eac1aec50e5082ff17b489beb1a7201e864cd1c6609a13b1d3fae213484828e4fe9a7f5dc4977e262bad593e43e26f66aa3676e7e6c10676f6e13e9535ea10dff9c6294c444ef1a9fc8026dcb50846d2236827b17014c21e8d5655184f6d706648f4b33432abdc442f7da4ad1eb9cf5a8dce8d0dcd9adcbadac0130c38c3120c48fc9f68eb9a70dd57c3ea142302e4d4d84b2918bdf1fbb20297efaca90713bd23aaa09733e8b56ba47696671f462dc2a579cae01c135c6b4dc86704c34ad689c468d445bffce39ae30b40e85beab0bc414dc3a696d360a888c5bc74c55451deae4f7fc843b38d991078691c206a498cf9a6e25e55f284f14771fd6df8d863ae033b68182e2732ce11559c462eb5fceaccd754f5736926deffa52d9c41af84c63a816eedee9e0f6d524c3cc8f504efc65aa7c063772530251bf5d191b4ea4b1356dfc465474bd981955d0d6e4edacc11e3a4429279d9ed400c1e58b4e0a94a1ca8f672f9268eded36127828111b19a964431246323b1595f5538bc0f2bcb4ce8efde2a63778cc292c2249ca3335794e5d6391d50c4faf9e2b5372f168e20039ae553f01a43ab7be54d813a8809857317572275a8ba02cb6a525641fd9e01e578d8525dfc04ef6d502b1a4fc67ddf3bcf9850a8b94daf0db8f7ccaace809cb23b9d2f08e55a1bd44854b1f1a49ebaaec4556519ca9c3f0d0cba22531b8293de1e58d2e4a21206c6733e7266b27642587f0ad83923892e4291350c83671612d1184c26695b06d7f9974b38a9efe6c32c3fba11f931111c03ef30f6378faaee2121e1f7cab06ad5d85894d26c0745e7508ccab2c34455bdf00f6c67a6c00a63044ab8edfad22b36652338519cd96befb789fb8bf6771bc45f5dfa953092582adf2f3a6ed618e83303c0645be3d8227e02d95c29333eb9699697636d9559ecf6c13d04183f0f0c6d160807d00ddc9739f5b736d92bdfe3e45fb3edcb0ee3125c33f1240f70c1e96fd55c08a72413f2a2c357a2b02c6897d7f2075400c096de1e7d8d925e01b0bdac0161dd3722d187221832a73703520b1160f9a93f20c8716a57964ffdd1bc8e087cfcc8d74d8ba1721b4c634513f577af4892f2ff5c217df2f8bf2d10ca40dc8d90b1b36ce1e2036d3283d1984cb51668a52e0910596abece099103145865e7bf57429e2219fa883ab6828191a0f2447787fe2b3bec014ed6e3d79b424684cafe7c05a4a4432d17d918f4fbf4e04a99994a1c565e7dc9b746c03a5c691a98c08d437bdb1701d55b345aaa4b46c30d6f0f2ba0ef96f5a57b906600658ab81e90b649e294598a5d08cd4f4346847d76ba779847e7b159c9d3ab2557ed0caaa45a609e0268d85f41276d5f7d78f30a727e00b8c5658734bf2319775146236632d049fdd9348f7c73f23c7f4ef62267d794cee7ce344865c97342bb8ba8abd877f07ef5d060436448b0fb90218b880d76ce0d707fcb2ab90a9a770352d308842b1966061c26f01336a22a07958c9ee0f166f0949e933628e41031d2345058db63d72aa0f675426b9d094e20c279cf0a62a3a7aa83de976a3a885d1db0f83844b89974f8a74ebb6df9557da37dcf6aa4f01de90340024662b090444e67a3bc1e7c6b3ac26a0ba2eff579e98321671c33c5b9e2cfc822d1e86247f846d7fef2d7bfcf7d78b9bece6fbeeba71f522fcf8331abab5a7cf85d1df87a21e71cd26f2315faf1153c52a08546d8dd6c022189feebda025d81341cf03b3b2a073692285a8c1ac558b24277a6d40c3d287a07e4fd1388e407de0a25f24383d09e5a6f0a5fb6bad5664112a97882e2dc5d31da947a19b663230315ea28e7c26b8107fe00b4bde69612f562f1dfcc7962a2283b76a6854281cc476aac7b8b34c7455e51538759d0d60f8b34f1471dfcbc50d39aacf9425cb8bf6b67d53dcee13df6ddf32a4258987099d9a83f1f0c7b40e440b038db7f9f6089c493f4bb4f79469306b4b0990b7332881e9f0cd3abd6f47f879fbadb571e2e9c2438f5debcb7b4063ddb290fed1c09f99ac0f4246c656f3af2ac914d0b8bf78bb72ca3fcb522ff989a38d3aace968ac76e3eb90acce4dcc3a8b82439f42c8bb3f4bfeaf692e5d5b0024faf3b798685a94993b04f74a42bbe7b27669bb80bb3b2181e80944220be4a0f58a385f7bfeb42cbd650a5eb317ccdc47ff196d4544dfb3a5381593da90412b4a3f8779fd2d1be277b127be0e594ea8464cfa578292f590be34a04cb0de14b584ddc9a03dd8e4734761abf9772325094cfa656af2b005b60af3b4bce4f72ba67e9e09f54416fa22fe6f05842cadabc0249a3d1a9a6d7905b0f25ec46100df6b87ab35cacf7fe305d6dfc007e79a7b7b1f498c98ebb9009ba687d5cf6879fce70e425b6e8fd1878d8766fd6c5c2b8729a4dfdb182b0012610ab50884305246e2a2b55ecefab1baff29c343a31cb10c78d8357ede440dad151f2342435972a4c0bc17fba244daf0a836c90acef5fe388d2947d9f75d4c31b6f4831b2df91124a97e0c4b17af675cd2f7582eb6c765cb6f04a7483bdb8fca023e3abb511a0939990c018b700b5c61597a1221c05f7eb6b9189797b3ce25145c1c6651547d1f692ad626d2fd39916e3ace2bc6d3c12d868a4cd8e3dc43c484f641b4c7d5d95d79a9475553b044725dc5416b9416f9f7817a397b6e64524d3e0eb870488bee509a9c51257357271c5108ebce1e5e23aafe3b3cd9e96b445d0b800350408e99c624474d31c53861c220c93c240b3f5149cf66aee266ae60c45fc14b2459df951df7c571bfbf5dc4d9775215fcccf42dda62345a278b73b30a140dea6d174e1526ff9476c944f0cf1cc7c63178efb8a21e65a6deebb3761b2a271dc1af5388275bb7c064b961e833e111ca390e38f25763618aff6e0497e075e8cbe7a851f453a59ad905a9980bb3bac7a1709f11a81c1af2017d123bc1ba2162996bb35e238b2f20529af12a30597874dd37b74696a63c9d909a2169914ac707e51b2724c9de0ab37408746f10a73f13bfe932d73adadfdf8193e8da2d52f78a414cfa04d698c66066f667e2ff673bb526fb3584229c4d5dd96cdd96f36da6a47a641ccf43cf92eb1666d362215343ef46a85d23f13937a36c07cfed88f62b36959ec4120b7e10151272a1a7c463a27cedbdff7b6bd3a43a43f8c1994cf07b78e470d37ee7badcd3eb9100a71fc916fac5e748f481865f68360fd428d61c0caa8657790033200290d9cc1d7c6fc53d8aabddff235eff1efb254cb46137bcc96ae4eaef43f7a47124048221f17e8fa7c040026a78c9e1c329b1d5e3261443d0da5bfa8734d97ff34c106668ba2fec49f0947cc6f1a295d72caa1f43935806fce05b7ca21cb1ab7d26f69c85c158e5ab855680d4900c138fb7df011d3171676cfc39bdcbf5cf41c425d2567a3cd378444f5f5b1584bf987a0724f33515ce215a6cf1e4ad8ef1bdf0fdb01a99da463e77484ff6422f53f3e745f5564b191b0e13a3a2e6a3bd444d4b3cfe156a7d56b6458e04927307a1e98833e416c367c6841d55f4274de8550698db5e886212ff3517765cdf09027c9d957052c94ff808695220eb7c0e877b3aa610db06bb108629de5e8b52ff44ba05eab5644129533063e37b10d4041960597a60b94e241cb001d408e265f50e66a7b286cfc8e6e71d8e3524182f133fd065b888beb7d77ea56bdcf929482011961af9bfd987b6c183c9e36d3adca957380c373cba01653b18f7d4602b566a5ec70027f0166da84472068f6d6e54bf04ba061f94ed7039c4733cd323c402d98b7f39a950fdd2fe67f12d33d1fcb090e9f520703747583118789af01f200464f166823116f72ea85316ba4d8b6532227b92eecb4e8e12ee53f83b9629dc44cc1a3b21f940803b5943b7726a9d15b2829715a669a0d653184e137451d83b36fcc0c2853735997ca548812090f83deaa906c1279039f5e072505374fce5dae9c17686b6467ec2ffbdf72ac5e78578698d4e90629f5c78981969766df81206165938155656f30b04c0e4b47a7434b1220aede4d6981cd18b5529ddbc5b52eabe809f142ceaef813f8f83e980fe6b6e8010ba455d88074551fa81e46cb98733d5cef9cca396bef88466040f35436f52850fca9fce4233c4654c2062dd14e68a1b337b976567c1de7a5c9ba710039f1d11c3c3c1d6a70b03a348c91d0c879d166bbb7f7ed21622aab4393788fb95c349b8dc33deef436abf01f8e406b2def4cbea5059fac18b5dd80fbeddbff9276f70b63486b5afbbe5b3e9e26b2e12c0df072ce3b2141e52addee68907844a985093f5e0dab043cf693dfa1f9b97c7b42c79d51095be6fa77c0c03daa7dbda1e899551ca7519d1340f5c454da300bf43cd121279872d94646246632887aa4be325e7435416ee6a2436c2597ead267dc42df95ba8eb62db6f4035ea8c76675152d1d6e30649f994cd8dc52a3f5674e1670117546d3da18c8731b0983886fb19030a419e5ec0e83da5101b4425be5726e21ee4d4a01ab8d4890123771239a80d3e89b8d24d894ce71b8144a5b78bc040824c23d279c98f0dc69441c14032991455e4c4509e8b41fd7751384ae355a8027bbfc7fc9874859bbe427ead32eedb0e79a632a249a16abc8eb84b6eb98bb2ed0210a14eb4a2c3ed7a794e71d3c1a86e8ab4526367da0ebb30b81079d295fbdb509ab887f089ca43b55319d6de32fcc5d163e2aabb8be21f38459dd24fa7b1129c539ae21ec4c36a25c3506069715a474745fd363383a4ffd8608181209756021e5b3d3d2849a879fde174aaf3dba18bf7e37e228928a168ca0cfde6795c57118d33628e9ce9e192fed3ab3f7afb93feaae45ce698207cdbac32061669f671974fe61e39ed4fce438e587a6a20d7f9e8cad9c6600ab790de3d44ddd5b17feea6134c9abc49ab501d9145d87c3fcd9a3c24abed2fceb239271618f7f48303ed4506c0360c90f4f1a82b0a508a9ec6cc44f03bae136a42576f7cb4facb9efc4e67cbcbc660ea2880d6895675e871de2b55525b4061d63f9b134d84feb3565637ab87ac10f442f7902f9226ec94791147bfe93b12a5740743bd7f24108c4def9fc0aa5829b2fd0283c86ca8e22da2ca19058bf1fd7c536a631001d5031224367bf2e111c96e67a196702d9103c509644d0c34dec9be2321bd1f9d27f5af39261855bc5d0170111e73095e21bab6ec9b1636d07f33ce8def3035beab92156939da1f2477c60c8829a2e377d1790d47b529d8cc84e7ee000d4b6c28a9cfa11f800a8ef75007c13c83426106bb19fb86251b45e5cc5110331c9f826a8a3bcfb03bf0167139fb48504927a21005261668df4f8863216f949ce078497e3084e43fd42d9608aefe4cb864d4995a6ed9905bdb33dd0c70b64869e98b2db66d5237983c65926d9e26e738d0aa8c70bdb155d0dcac0894320e6d60d87b4a1663c46b584a63246863def3dbaf62b9c9ce3586327d4902853ec6173c39f77989c5a368b1844dee5c15d11544ba1a3472f3b0475c1554206122cb8f877e561a487d3784f038367e69b7dfcf486f2abc0094d3e65db573b2d5544b5f4876c0fdb6511feddf51ad7b0886768dccba88853f1b915644845f18839ced655821db8517f7973ec99f22d04e827b873b3c984d2f7f5a2ae8c6206e164b2d64440c86a684507ec9374647fd48aa9cb937fbdf84d5dd0d4107ee6bf5ad4a68f628697d2eff15e2c08696f040e45ce6b2a00ef90122ab04019ba594930f3f188ea5400d201e6dbb58aa1db0965d4f573d7c1e359505c04e5a3bd3a0c2da57056240e6d09ab14ea816c61193ea9d4df9a487d5d39ecc246e17ebde12ccff92184fc31f1dd596fb0a92efbe3f8a62fd1292fc3c67f82354e16330a6ec27d220f979dbbd09d0f1d11fe8d9bc10d6674a2b69827a702a3a9c842dbfbccd1b868a3afc17130d6870d9246b6d03b9ea45aed0345ce4f74ceaa00769f02e0ff4f23d69caa3ffde96ee5bab1f6fc43b367d83cadce125299a060a1e29db0e179eb8a7419be5aaa8fe0721845c68157280a3b23c7c7b67321b6ba9e7de8de11b69b52cef514e3f16845b714e5b72081f692e91f52b381c8acae90195a554fe1ab74a9cd0a3c205c18f474b5caac94a90bc05c1716abdf4dfa3e7e1bcac2a8b4a0ec46dc27d3361dec1dffe1cda427eb4c7717295e287538b812b7afca9ad0c68b8cdcc87001592a1e123360d83e6b9388e5e11ef03532cd6d8f999e3ee740e99a0a17bd80a63e72ff6471b0505dce3c620d5106206fa21b4edc7b84df60520993b590c529ecbd241c74efda86f6fe2acad9e4ca416531b3766b8cd5204ce2c9ae0236a1af9438edc80cf6591a21e6ea967ec3b67621853c0eb6427b0ae37cb32bf036ae7934351fe502b7f0151ac2996774f3f3c6c476922c4fe7c595a1deceda06f2bb3d4e8c2c526a2514c248f24651c4d3a56e424ed2a1964b2cd8834e4fcaeb8562c474cf2e491d547bb0a63f2cebdfb7c3a8d358a53c6ce5ef32b1f725532d46f66a3a3fa5724ea7bae6893e571d6b2dde7c0a61337716b216db23bd6ed9f63cf9fed7fdb421f29458ae00f91baecbbd486f3089ede95bbea3698a140803ff46b3cdccd491456174264dd5214ad34278e55c43455c69ace12067fe44e009667e545e3e4fefcb29f9fb277d159221dc207a5bd87ea15394da614b29c32aba9ee0f3da1b3c03a66cfa1d86b32121352a5d34db89c60b1856bf76ff67723d8816261377eadf588382f25a358262257caab3e65bb4c0b6c68f2b36ba77369f5898de52683ff02e0a4e56041d87409b4a69f4dd8c15a62f47f1ba95fd8015fce04e1571bb0b39becd9aea890bd32ab13855be5027e3fa1bb1ff70874cdb2bf6cc87ae00231fa2c585a9876955e47284e9c470f1d333643a541a8b1e8bfe20ade850e85be50b2df125a9444067d20c3ebef5c8d7e596b6b55c85e9d8554576654a7264436f117358bf8193c487174168b88c68394a287e4ec904ee9faccdc121949816f823c45f5e4cc02b751d80186d7dadb5304fe02cc8a8068568cad680d32cdff03c646552e7bf9fd94cefb8304aedce17c5664dc1a00e662d1afe94e7cf6f725f0f144395735ce7e3a8a664eb14e171975af1abea49face1a1e81d7ca5660fd85a03e883f9256adea70c80137174a1c93a6cef7f7e45d734d1470fa6146ea767e5b874c69b89c0d3a94d7a445e699a4e15ed6128f709b6af560ccec0eaf55faadc87a4457c83114f615edf2bbc0cfea8fe2fe40f5fb4b710e52a89aad355eb42f23128d16ffa3f524119388dd72883302778062e8fa49b4841838c6a34266dc92bbd027a6e5f8c3e1f00f76e49c0a540d03bd41c877b7311ec969e36836467948394f8c03a73b5400bf167222c5196b09e9f63b1e474b758d089899cd65013afcc57b1af287703f19527554a1d45719697fc4f33e412ed21f5ae18790c325bfb29024ca9eb95fb35191e29c7a4536a4f99de9ceeaaaf32e64e382e06be2c410dd1e0b87053251d5c30a9d91bfb73d41a12ae625e618f131804582222673d9a4ca540a935ecf1bcf01f1c2f6c28b2bf6966e946e54aa372186aaac24b27e545ee641de9b3a73b9700c5a9c103cc6637390ff8c73f4b0f9fd4c389828c483b661b53d556df87e2be936f80055cfe727eb005c1ed2c745ca437d402037b9eec1677a50f69c07f8ff8c87f0fea293bcd84b8588b90f8e74a35e06bc66a34f6b81299f93eed3a4b9037329ea3bcfb4d60920a42fc528820362bc80af9e6a3ec4a4b03bab06c8f4ec570b8afd7fb4472f58a04224ceaba1dfd283bd32fb36ed729187d8fdd807b968936de8c6f95861af4e58324aeb0df330a8899111bd566892e1d5c6c71ced34db2ab4ced9139979417239670f3f3c84db12c09a30680a708827b877c5b009712b86b20cb8ac9b1083165fc3326bb4f66ec1263d95587c5d0a977dd9ee279ccea2bdf4a71e8acb512321b9592426e68ff755bc173619996c56941fad240560953115cbae118604382eb4a760c5107b4677eed87f1a05f7e98c6f974d31ff61f564435fc1f5cc6d47796f79e20a30d6dc80dc951c96b8ced1d4c802151b6a43a21f3527086b29c18ef68e273238fb794867e638fee4a80df79ec5e49990668f8c6ffa41bf29bcbf130c57f1bab97e6b690083c924159dd45b52d7ae98e183cf2e7d9d2d7962897316ea2cc90267e9e25592ab8c2de17a3fb9f861c67bb9a49e0243ca94bcb1e4e86cc84151907e28a088e54338c0c6a12c814d11b3f5576a85ec66d50563dc6aebd4943289869905def35d9f4cf335ddfe007542bf18fb3f7d76567251abbad5dbae76409d79c33fda8afd25eb9f9feeda2c4131c543ddc2aef6bce96ade27f64f1b726de78c1263b1563ccfd44ba52174b8bc842c7c2977d9a99d0ef79f57b56fca79b616e0a5f7bf17f8d5e47ef33c9d4c34b88372513be74f19b3ef2f53990046f13cdc21ea2c305e736adf1a6188721b343f797b4aa80213a814a6060a9ad8008e34b809aa99d5fe306e2c7db38901a388fc62e6b2cf3ba55a5cb6fcbbaa02affba1ce20defe866148e8ae762ad06117588631965e46887bc5e10ed5fafbb061ed9aae2e481886e994990dc054ff923f1571020cbfe075b8cb13c5747c3f4691b1ab5e5cca5a029ed7f26f11eafacd200e5c4ef845011f270bc9ebd34f9e29fb7500e4224e0a63adbc0a9088a3665b6f2871d6d70b8fd7ca92f63fd6a270b04a0e3946332b64db811754335cd3334c3c4431a6a107aae915cd9bf410674bb35841fe52ae2808287efe0f70b28069f33dcd4405e11c4f385d73f278c0cb5a1d748b47c1983cfc3bd6b3ac563a6db628acb24afe7644235175bd9fd57bd71a7b1151cbf3eeb1cfe3ea046ff2261592c4249809d4f7b38e7b462d29498c13c0d94f784294593028e9404c04dc9b3e557e4413b275bc305c0e9db0838b4d19294d9a919eef2e64ca7d1f7486c62d99e0de8bbc0d6f5b326868e10681597b4b58e9f79f3c3eb01a1f5d70551a17bcf052e209fcf5fefec67ef6e9759f5fe12b4c3f675761f9a79b9133341ff780693a58e760f3cb5befe4b7e61300ae5644798a623579bbf27de9ccd68103a40ae5d06eb17daed3818af2fb3527cba0815c4898500ac0200fc4ebff3b8ce0baab0307e465a9f76b0484f3aa09037e421368f5997a9f193dfe6a967762ceb447601b364b6375ada23086fbff594b806690a96be471b9e99bc002b3a17ac38eb611c96173304a86c5460f72ed34a24fa6ce7879f4bffa567079ee3909216d728b0f1f3518792c3fb2daf0f0ba4d0f4a8c3029113920ae723a22f64214d6205b2840ed788c321c59fb98bf525f8e8e51c7ed68f3799d5dbde108e4b9f07f61630a7af48faa58eb87e4c86dd6c01f1fa164100127a8330a050cfe6822e0dcfb7c7f6295245b665e124e4bcd0941a701bb297934a9a7c0fc93af6b1e3b610e49c5aaced46a36d3722595ea93c6744e934bbc154072f4ef89db4785570d8cafc79dc9647d7693224fba68ec3d043b00ee13e72c099cba469337faa354623d58af55561202fc40f8aff0835c8088c9500d6b21ced09956c4ec9391e8ff3153e3e1f5e78a669a58eb493c8841699f16a825d4d2008af5f1c69619f6f2150ed1ffc20313e172c08748e4af013dd013ce51f5a7afbed9342ad1946d19a6702d4f008af65c58abe555ec4f98917c99a6c214fdd3fe027d25eb26e8e18142d5009c97feafc9f68ead0dd24fbee761eb207e78f863acea0938c6b6cb0ebc359ceda38487c4c1a1f77c752a7582fd42b389c088316e3dc80775d54cf896188655eb6009faaccbaebd048942cb1cc1d23d450b5c2d2c69d388d01e5a78af1195e64435c75eff18cca704b2ee2d07d150d51c1caac50c1071ca89bb4c7028a422c7294ffddc8690c8b052e1fceb271627dc54a59a9e629b6653ade21043888b9aafc51c5fafadfb8047fe51f73896ba582a294b1495f55a9c0da4702064c6712e16883abc738ba6de587087dafc588914cc90a8ad378fd2174cf344d974aebf26a6a084de2d392de111a4325780c1848a9fc5949a62f4782a878b63df51283e19d053f5ffe164c42cc601c44ed598678ab57a02df783bf4d85da5cdd345b0b6e69f7b4ae0665a098dcd00835689d6d23894a4e0158641c8760009c848245ac6e5313c0badb602efd1a7879e705fbd3e1b28282c85b925c4f0fc3ae01152df1315c5e3bd613c537b39e5200c4ee8a8acbedf990a7cfcdb2acf227823ab3602e9102ab7ca30001629b57afc669b670bb75d2351fec1202a07cdcfdc7508eed7526be4e23d8a9bcdd0dd010fdd8cc0bda63942312faa42938139b5cbdd5ddb539f4235554eee33a572db287545a44b16ba706fd88000ab862fae60964a88146291bf5acf50cbaa4b80309eb84f59195b34b93b1b1033e9442405837b41abef97a4c37d6f5303ea694f6663366070ad0de1576602e60072ea6f59094ec310ca0babde136b773878a7b2dce1b11b0cdb3daed52904a5ff7c57a85219ac5ccd399f0b7bfc2e353da58d5514a7392add4ab34671a0c9dec0c2136bd3ff0174c53a306805fa3ab402f715f8e2c5877495d4ede4f87d095b1283a410a3bc554100e0afb89f0f909b7b6cea23c550f46b97ff605467875a91cedf91ee88bd18d35c7f297f4a916b1fd6aa87f0a87c3e37e53852565f527ce10b7ecb89a20ffbd35c275c2e1639d653d68404e0367227c8461cb622b7bcbb85690a7c088b8c2763fb16c3e5bd18ecb4dcfe02348cc8cad13f25128d657028ab6d5d44fc727ff02e1cbe924e136b6da74a8d3237e9e33235b1e92b48187525832180648b9cc8331d64f8e7c0ab9441297f08ca848dcda237cf37c2101f20bd6736ab8d5a08d9e206ba99a64fd449c0fb581e37740e5c4021a6459cc632ad0186d045e34e0e79f15174f6393238ffa5488c7b741e5f4946b82a675a7183c4ffe23f478289ffe2fa4af87b9b9af6c1267bceaf4abb474c39c9e42778a763389432bb13720e95d7a1eb6982ca98b48da8df08752f9c2b37c654524bc93c6594d628cb2dd0bf42b7315def58aecde4f4337337b5e5e7f0def518f19e878f35ed144b9f8abe0a25efc76ff175f12961b1190de6f76a3aeff685e8bb9982ec23bdbde75af799993d6b40f61f7c08dd009863f4deb093fe77bf2069d11e37bb02602dff2c530773854134578ee1ffaecd356d319be88c13888c27b09924d89e0298915cbaddd595e73f6efba85a533fbcd0e84d4a257a753147a8bde7824f372242d0e6867bee21a33ae7e77f75f50501962f929ac3257e77ead73d99703a84390f28c5d67a12cc188fa65d24ed77082068fafcedc4bd7bbe1d62f0f8f623aa15d39e6ae137c5c64844047bf869d1f8d4015c34b683fe9c4af4f02431bebfc6aaf15ba72372ae945fba2c3c5699d01f89b97cc2aaebdf1faca92eb435a0811531c7b9c545ecf664d0c243e51c99c863aa9a6d2a6a9a0065dfb4823d209853a1e2c325b082bc31272bced2433a03d5c90c849de541236575b697ddfc77a1705424fae3909e4afdf82d58cd9eaa33c6eaa2e085384c5f7547fd8b5ad241500e0a80f7d843e12b777e14ee7993fd3e674389fc0018401a5835352ce7eff8f7ea94d2b315c274898322af9c8362038401cb2466e6d15fcaf519374b3085a2103afbb4cdf6661d7d0704847f61fa9bb83443324a448d07515adacefdcda8b458fe45dcb2750447b4039564ee39847cc2ee3756097dab697a77de8e60e932e735ec8ae382a8f72a1bb3f9276c873724674d332709d8f508003ab33c4361844a361fabdcc229dc4f8ee3bd89895d79b001271514e487039e0439c788a18cbe90373fdd71482e8849ee97d0d200d100987dc0f8af1bbe9137c56da835e94eb6613440dfc64bb6464434b87dedd0e1e8d82f4f4546979be20a5ea83f19a51ee64577f04f028f9c824faafd9b05c081222dbbd2946f8cb01b9a82d615c43111738cb0a4c6db4738681629083eb7023e77973d99580c697700f0b87994229850f00f5ed1c4efe64ff91d35b7ce95a983768bda4407e6ecb7b246e3971e3b5ff2a2d9fca64c2c1f40830402986682ee1f4f10b4b02057a6fff3973c9e00c683028ac1896000b69fd02a25abd33927c680b43a16c3658ba6297f97e0187e055a7059adcbfff4f35aa8234874d364ea504dd81c3be3ad59fd1bd1f108843e416992032c1d9d2de25840963fc7d70f6a17bfe72097065e9ed131326ea1d7283e873f1d5f6feb61029ee07f8d44f0ae1dfe5024a707117ac973856c78d51a26ee71b53a2a4c30fc65c8100904ba0e913b5f5f9ecc61e21730babbe433154a10452136948c6a9590fed4fcf135a4147cf4a9c45f7870ea3398f5537bc4ecace44ca6e4bd35f5ea0f363412efc47391fe4a38596c8d6a6a0fbd9fbd3512ab1aa2e78953012a8dcf89f0e846efed75fa2d4ccbb7e7e118c8fe94eefea05c67d6ed6a04d9558b0020b5aba0e275c9ca48c29acc52608672ce27cfa1c844e83891ebe80c0f0ea52f284f3189d141a6cbbc0851f2323c1bb0e3e2de11f7ed039de837fe53129fca8b8899e17129c4da3a3378dd579a11f809bb1eddc75d19464ad4d9697b849d5ce45761033cb621bd236f4d39369fac39356da205c2e5cd7978a3c742371bde31518bbdeac57d01dde4962741457d35d4e4089e03348f99de8211a61fed178346a9901b9e0a8d8beeb544753439b0796b5e90064701b7cbc8e7e8233e2255596a33f9ff321a1333481aa53f4677328dd9076b94a0a22b24ac89a6cc522e613ff8c5f03840f3e9dc3694a3144ac98539429baf33e8158e964db79d9cbe0fa7a7b6f235e4b99024425438a2fb4a7df2e0f0c76eec243b6ca56a37f823f184ea60fcfc1c9256d5d41bb5b39fbdff571639da03a6d0646a0bb66f306cff9179f243487b7b632b00bb2faf8ce7f2020536b022b50773df526c1cc7eb0098f576387d42c2105fdf7b212c8fed7ead697cd1e23bd075b6116c656813ad5b1c732a1839b6e87f23cabb27b2ca644e311c7e98d0b2b20db5b3025d5b2ea6a5122e4788df2806b25b3886ef6da686f2b2766ea84cfbc63ef504a0cc16b9608ed4d172ca61ef5c23b767526b6dd52557a8e41ca4a3ef91071c9ff88055b8fad462cbaa9313f7e3691286486f35b7d0a8699","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
