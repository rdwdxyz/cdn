<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42c3cd6cd05d5eee343cb32f912a0c97961016eeebdf1d4934a441c05fb73d909b531dc07e66a4345f1e5c6b737d4821c48ac3d6c725b8a15ff19e09b3cd77db6f9a53037193ad36b06e518e1c5631a569938ef67fb6e2cefd9d101188c4885282ea79aa1d7016dbfadc0e6cb7aa82ad2a17f0b74e94b957ad321da7c8f41ca5aab93d0181141dab8f82bab5b26d9534b6b21e431be329d921f26bc37ab653a01a88f6bd64126d67fae5241ac7e95ec5839e661f8fd7d8489f07c297ea12068a4461b2cae79e332d9eb2e1cf44c3f106e6fc5b5b871f3b45de34087905cae7f541da83b793fd0466e71b1621c439db2b9e03782c02142efcb6fef8f9c2b863f45d2ef9441ad904f0d7a4e0e606578c317f5ccda41bd5583a95eab673fc59dc29cfaed4a95da1ca7012922364058e48a84a1e78f0fd71f16bf1e2a256168c425d4ecae4dbb227954ccce590c55a165e00b23ddad7045c8628f0ff46656acde4775e7a2794e575a40d85b995a768f3874d8f1a966c3fef6df40ce271e6ddd6579021b3df44cba7ee91712cc0f14eb1154c8114cd58eab38cb1050f35be61af908c40f3b04441dece19995cebd674db02b2de3a191f3abf25f59d5a12937378fc88f39a2ef1786bf18d5f60ca1e724d730733207a9f8b729075797321f97398d7735235d501d0cba101965cac50357124be1d72c677321a507c506abd56b1c84c73fb2a5ab16172c91d6a4db72dc6bbc5fb3c865c68c3b4c44e4e74aba8ffe5285f37fbacdcb77bcd5b0eb69403eada474a02479e4b55ab156f3fd9b6bf62b5a63f7dcf40e0c5602fbfdf48f1b838df3c2b481b2cc3a7428515347cf1df9f570ad1671f4d168e967284c5e9f5417f5b02222b77329325471ba7a07aca508f76901d6d41b39cd244076dd640cab1f5e831c127dc9961b0c512ac0b9e20cedcbb4824f54e5d2b5d3a41b1ebfc7f7839f7564648bac2433539d3da1807e35d9ffca83875bc138c4b0ebd17e602aad02571749dcc299089858e522e740a8a255896a77b09a9e9885859d72d425d4f8460ce4973e544a2f1b9b2047cd3f9e77cacfbe166193e7ca5b1e94c616beed12893e226c142b582efe256a65f602051b66d689d50402dfe8ecff5465dec9ff3b8fddddbad610ce9f09004d5cfcf52cc71bddb1e12a0aafc945d4fa37a2f6f0f1a06a572522960767cdd83afd0518a0ca25eda0be88580ed8df11b83dae99d0cd7cac704204db287028eefc30c0adf577a791e90d6c493e4024a039565232c0cc6ab78b3c74c8df9c0da41672d15630ed6673d4527c56a3cd032e462006a91dea2b65af5a416332340ca24dd93d57689143ce375851809d9351698dbabdceae036eeecfc3e6df429a6a59d574096d260c75c202b7a9b428a602c871cfccba3beb714a23ee43d6fe9e00e5ba4bfb361f3cc0f637b2d45ffb7c409c574796422387f45132cf6fd1a87507c0ed52f197dda8fb6529be34620bf73d9b6e18af3e905fcda92c5f283a66edd81d28e81a62d43b031353c2b04741568c9a814d6eda1d69c122e09bae50687335850021805a09dc0f8cc6a2241cf1e2f8cada8b39001108e9dc02096bed7af04a75a4c8b4bff71458e6f890f823ff7ec93a2657b3c2528e0f754c3a2f305c073e55280fa781030ab79b2f7ab0a018bba58df4f32dc53706183339409e635a3dfb505a84186138854cef9355edb5fb070996ca5ded7cdbe969c0f4085bee960f1391767a2e6354df6bd4f3d1e93663b4f923959171add5f9677a0aee923ba7d1cd642ed01adb4ca6b31b8c427b29466d4774fc340bd401b25249a9a33e73949b6a68c6e8c288c49a6b62d746e9a5201fa56e9ddaf5e27ce0c0c65f8f5dadd04a5d3f5f9af4a8db659ce952fc7337125abf90f68f384f7166f6bea09e9ed37d8fc4e088d04abecb653366af64eff3554891deb11da25be72f13a33de0ea2388d6f3213d8f29013add09a819cd0dd0c84088580d27fb0194d12a3aac6355cbb20cc7ee36ce6720e68cbdebb40ab55cbda134d61103b993b0505af978f64b764aa58a5239f9f2a801979834365a4a196ca23283b5f66bd984e5a9a974b106760ac9d9583e09eed12531b8eb336ec439087db26a5c7aa011f23016094576ce8e7e0f41b4e6c04aca9ccd2641935721c65dbaf00eb2e21de12b05ff50dba29e8d7b033bac3c44efc71caaa7f4713102671b85af7c50fe6db9f5331409c7a2927930ab9af81917bc79629c18690159f482d70823d9a60afb10f948ac86cb2e1d607eb9a4dc0792b910ccfac660b47f1d0a15d453554ddb27dfe06b29f4c5dbd1d301b748bd813ab4c4f20780bc49e1f07f85e9bdf27d76d80561aba8494160340b185c8cf4eacbf4a593050c5b5a8ef3fcc05cf701de8475b353c4ae6e88b1864d746be9be22682c2f56a5e378d780a98e0f31402678534a5c064f104dd282379689b710d740a12c69e3e5d1f6e66b5e355c5b16cd7ac98a1691256afd96560fbf4705613766c2e00df1e4459e70d9165ad7ee73db59d14f62a3904af9de0b5ae3db741679285e8387c64fee800df046ce9d641fe19ba6308ccf49a58d1fde7f0bff19490520245a51b31d720188509b742091484a0bdf556e9668dca169340e07ed4f5f74e9a8a78f5b96649fe10b8ff2e4fc3c2d216704f2ba86a7c37b6854b98e316033afc4b32813ceac56c766501631e2eb5f8d5807403116919b8110e2b303c20e535a9ccd7dbdde0391c361d09e93698ca8943fb1ccbab5ee92a06d8942f9ddca6bf14051def55e950bd06c8af06e84f56d025504da82b69929982f41ad13ceb56a72bc80e76727a0e346e4eb3dba2f27a91926e8c32dc7d6283f7ccd6e48aa5d85f0dbc0ad1b446d73912d29e2a60b22d4ce58d27185b37b649588b969cbb4abee00d988ee95d9f5977d1f7be9f7330fdf285a64607a041d1902ed4934fa410203b77fc9eb72a1d1aa4539be7b8dfd235066dac2ffc5eb8a9ba5d898e4f019ba3e28c527139d46f94fff8663d77e2e0019be6d64cef1b3e455c3d7cf4b7023ced464143400aeeb292783e9127a345e184ed58fbffe02f95babddaa3efa02bc92b8c61add91e1203ba984daedc0d8c22477bac936d29b4d94df8789ec6537018bacf64117f32f30c99d9154d3692b8730cb90dede73cfe66ab8a2c1ca7e74ba077c64a11eb98325feebe10f4d6117cce46966b80cc9f562c309dc8e53f981e90dd14185a2f74f2ee4cbe61d6af78524170eb11557f48339e6a6e968c8db2899df1418268ae79b6542e7d9544a11d50be1e2b16fbc05e189247474d6145f8176707069b944266ab152afa0e8152b405c8504fb58b6682176aa406d50da966dc28a3c59bfbee8925a6ff25a6a8a41e82909ee5040d8c431908af54dc3e062bfeaa9f8e42ac4a7f157bb6b75d884a1aa6bcc4f6488436866cdb4a472f077ce3fd7e304c0e62696ed0dfdb66612afccad6b88d7d8fc224fed51b6ef04f6f90902d91c4a1fadc49c5a36a4ff7e133f40f92b1dcf3f1333c5391592d7c53a5d8ecbdf2ce490ea4e4dfd89583d4e1bbbb445f0d9a5cd2b1596a212dedcdcb52f8831f671cdc9b22df5840dac8d1ee40995ace1d78527959809316cdd8fa2fcefb2848c6124a922c0a4076a96eff3df2145b8796d49488a0c90d8311d349cd0ce02c811f28dfe0b2b44d3493712c100bf0bf615be2c657f13e828c14c5936df66dce8c1ae4dfc8f286d31413e8161faaa0d872bd2114789bd59bd850ac597e3eedbfc32d4bed38ada9437ef22b007da050d16979d940920cf959149ef510c0e299f6fc377c3877ea052cd98be07dad82156a667b57d536517ea0d22f12738cf93a0e2d651fd5d3a886c75f6384dcc743805a6f9abad616e30d9a803c6e64c0e20a0a591c7f51569c0bfb2158b30d36ebbeeba30bc7bd983a5093e379f2ed20763bcd8e4f59c9a05b994a884d9f71a12d32cc6b6f63229f8eb72740cf461b27b329227545e467fa5c505e63d140ef357d130660ff1f0ca2dabee9d1dbbe27fd06aa59c74091752a79a41e3e6d622cadf323e1f4611950848eed0b782a1208d50429426ec2ff768641390ac4acc8d9f6575127d91a04284c2c4462a26f731e0d44ed6c46c8b05c4e7b862e313cef932920d4da4e2b9ece3b3043a19ab9ce8be68fd45c7abd4c5146cecacc37b77f0398b10a02471fe23dfb0c6e458d81b52c27c40a40f0f6fab06ff7820455fca4ad170a2c5e26d420284f1037c23071da6163f188a5d87ea9545a89c5a96a8a79fce2918fa624cd42649df8001278eebe42f6a8c5cbd06ef1ca1fe38d64ee2edc84b224473f68d6c944b420991379064dd2c57cf78b9a518bec01051c4be3448f9ccd6a2106e6eab52d043edfbb2e673f06b848a986f1a6309df9f322aee6a8b14fd60ee0fed8a760b5ebfeaa02aa77ccf8e8709418bea27b147224145e72b885d83606dc227159d6b956485c6451c7361fbc5a779243bac037da5be9e8b7bccb2f421a26e3d2791b0d97064e9ece138d65ce0afcc344998fd283843332d1b507f6e18bf2c4b48996aedbe74d6482d7a6107288a72659e0f019376a4df80bd9a2329a2e13655974a620556fc961abc5d5100126123c874b4467e54688a52d58e73f2e99c81664f5fd006842994cf346dd657b80c258a044a10e405ffb697f5906a2baecb5f9bcd50f77dc968d6163867b6c0909d490c0fe0ed0c8b4c6376a2ff8f77b1449ae1fae8439a4568d332a2e7c5aca047c069e6c202ad2d08871bdcd74744818e535c852f331681db4052f5f138888f85ef8cd4dc3de73c1f248273b4e9c295eb660b21976f09c022f1cc3d3ef1945a56fa20d7ef910b6866e792da8fc1a0303ba6f6ccdff495c5d70c3cf3f521bd1b59ae2716ca7127c784eb1ced49a1ba3e09f5ee7439cab367c7bc5b63074be00711756db580acea167107256ca7dc76b86233168143d37438a49e84d00e41719841fcc96256acdef616c9b9fc7f47641fb1fcbfcc57263bf6b62be96b9bb212061b383d81512eba4732adada9b2fb439e109a8bd88e98b83d77fe6e3ceb16b7d732e7d69beca48b2afa091ac0c0d84418b2fe0ef42ce4df9ad623e6a762f9960fd425d7a2701023acd7a3df477ba4f3e43e4751e6282cd550475547b7bd3cacaf53e49c377abb3d8e5c1cf94ab1feabe6fb5cea2ba7c31bf3cc50a53525bcaef538da6faac14ccca1c393363b541116d84f45456c5144afca4facd29b0be80c3bd96164eb098cf2e5b914b12387ea0ae78b194c91f319b73e3728823603d069f3cdd9dbc078ecc949b53fd81020c410807793db7c408920b20dc23cd6e039821cdfce3f97a782c6fcc1ca8a7a1fe545b6abf0fe47f7d8c58ff46593ef6680295925f602d18f6d07a5938e6f02fb7bb36b9b57c3be46f3b360b6bf380030e2749c431afa4351ea582978ce102f16d26be82928e5664dc6d0cc2ad86b49b8812ee62b507d179404eb9c5ed5272dfe39dd2f9b18624a5ea57e044b73e68c55d2628ef7e5bc60449652bd20d794dd9fac0350570414bb337e89f21af7802ceed93762f8eb7b6ae98f605e526330185315043f8b7d02fccd7f646c62ebe48572c1b303fec63905f56437b4fa39cc9e33f10f4ca26aca71bba3a68dcd8dc1c6bba82e336fcf5f40d513c9a038f4e8c42a9500cd4debe1ea16565327b9b660b14a818882e84774687f4529534d24e1fc5e64bf64abd33b40eec66d3c03c31716c2e9df4e4d1fbce8491b08dde87b5dfffad3dfb683641c88119768037acfb31e58f50948feb51c349adb6d3dc7f0cb5f9287edd9e4e885619aa9d05699f7b95ace0e6ead3ec9be0004dffcd8466c9e1b622218d6e7489fc8d7264d7e8894aabe2abc0e4f4cf5fea159846c16370f0c2f0039d1c28d58bcc6aace58f2e0b6b9cb331245e22c987a741e93b826194f54330bfd2a9efa1ef92cd8f94b52adb7bb0b52b81d8cbc7ed8a3686f0c275ed7f14561c7df21ba6f9f83031467b8cc8da878cd235f64776d3212a39a580443a2ff738a2ecf9c5fda0df38bff674efe02e3dd8a5e9a1ef52dcd65f3935269bd42c775d4358f2800efa7533783cd3b8972755e0769ef9eb8ad58d005065c32f1b28083b4e6f96fcda450267e05feaa3355d2c94787613ee76505fd6f31b6ff9c8266bc3d9fdfc4e0d41efc601f51e402db3207154c0b8cd4eed25226b476c171da54e7208f0f3b90ee79b7968aa5f35e54156e2b5e0da41650639e6c6a164501e652acb2de13e5de06b77069f65a75c8cf91b7af57dc7793a93a31eae8cd5f8d55979d779922d8db315cb14db4b7df3e95dacf1cebd67e83686383299e69db71a4b5ac1bf15f1f22c7fec42ad0aad1b61cdb6adc030cce1bc30042a0b507defb3937c0610e3b817d4caacf909f1404a54be167bdd3450efc43b9d418c572355e9c3850e667909e36a13c10bb8b1bdb087075a3e55b833c3e5b0eea1b96de67c71ee3465931c241872f34e3377fb97708c05602efb3b412715c655684f864f9efed6fa411a84011ea57cc63792904768d07be030469874afee3c3f6a3933ce445b39693fd4fe00c482fcab09f25aee92f88afb81b03a5568f6fe2b1810f2432f7fa1538a132993d15ea6df262aae2e40be7b962a064aaf352a9c92e03a14fbae251740b2cb129946ae012a431fd61e3ed4c3023c987c2163cbda4b21636a382f17c6a637c84fc06490de21d26ab20b8db37e5c64104dca1356f1d154f124912f428e09a31ce3096626b666180f950d6db8c6fcd91d18c96838a1511c8cbeb63c16e54b95cf0abb736c5f4bdda162221a98fc50371c55724e9e025d510d8de2ec602a7c947b15eabbdb8f7b55ca49adcd05ede65b011cfba4463262b4967931665eb7dca7dd040573ff58e10b188eb510b68deb67849ab770b5e428a160b223e89a74839a772e04d973e5bd69b9b8f41ee3a6fac88d5c53d18ddc62ee54227f55b57933c198feb8600ab1af1d07ca7cd418ee32f7a54b1b34deefa822aa2b5dec57b189eb2d7c17d4d022ee95c7283691051117749c757739bb00dc24cc37142074f5fdd9fcd06a27a062336a152dc6a3b6d2144197af84ffd9efe446d6d9f3f1166943e7b8c23fc990a457982210ec6c697c338070482b1e76b0cbce5135ee6f835f3601f89b7c9f27ef3122f8085627fc7705cb939e4cd8a98396872d619f12ef308a6d6110d6f6ec19b92fa5fd402dd1727b38292b513f3eb083415cf539c5d13fb0f50716df181134724e0241d7da4841223159d901cb1abbdf19b48053e939e8780ac791d34cb1f20403a341b4fab24f4c2cdc24736d0054b478c1d9aa560d10b10ea55606273e7c86e02fa9a14a9d3492ff4d5a6c0059445d54f1d371ce1b990e7491431e96ea008e7241fd26d7a317c98a75aa2f1a975f89119b7f598c196e49cb322c9c407d81ccd7bb8edd820b848c822e05ecbbc417c0474cf0f1cb88cc48c330db44ab77b2dcffd19dfe038658f482820ecbbfc662f10df42b1838749a11987b34314cb02616e5c827929777403f4bc3e1ba8e55d7667865bdd30983265a41e5a455b6e52274b2bc7a38425898151899feb45c7d7b34aa5c6fe95714eb754b4b25b98370bb6f8e0eadbc7c215dd0e02f6c6c2f263dac51c2dc030fa3d965053132bf3d8d924e6cc85e017fde5924e1bb83478ae2b9b1e6f60dce3950403948d4a0ff2872d92210b218ce0f749876871f8365c09932d05eac53cce1a21a613d36412b7ea63fca9f7691e28fafe73bdcf595aa426a74210b6bd9d5173bf91bf79b0ac20b3d80f123afe11e7290aabb601cd96e2a5c2b57dae901b4812f5a6593332b85bf5e677be060435ac7d0ef7fa37cfb2e58f646bb9df8050ee845a3341c7fdeea3e788720b58210fb2768cfa2ebd78cc050abf6e65192a743b7c2d15d2177fd3b174cd087d2fc830ca37ba666556710e4f2cb98c592f01c72babae584772faafc21f8803f04ea1293bc77be88a046c1b398092742c4a10efa2ed078829fb3eff7a3cc35012f186606b355b826befb25eed5e9189048a66b648b38c787632a10a9f685fc6631d5046798fb0126f0ed4afcfc8cdcdd363b56faadde88e90fc7fdcc478524cd144949561b5c8d8afc203921485bb1d612f671f9486b80c530e850dd863d6171ae11250f448846c8d0106d9ffafdc848bee591ff59e2e58afca7cb349f53856073baa68cc7e62ed52f3a4b36d5a3f0e7f52718dd88ee0da89fadc7df56f9e425434350be4d16e1e4adab6e54a4b0398b6b468f7341e3540576df22eab94f8403f25fc8eab5e68dfe39d43be2f268c7cab9c01ec999ab7b26a36b126bb41a0de0e7c781e19be1f828dbeeaaff800e584d7c049e27cc08c1f742bfd986e16fd84da67d13e7c7d4250bfb3254f829e9825c449476aec84c095ec23f9ec8c287a961af4170797c3b19c476a05c3bc98554393548e096a37ba6186b896338ae09a8a426e026b0b6da61c9db964e414b65b1f5eb565e410c664d232cbbc1c7db3b525044bb4ea7ffb737f143a9f94fe0f4882131a90719b26e8abaf60f20463ebe537ac574e3742a3b3ed24dcc12ccd5521f6f0609de231be0720ecb3e2702a50dd992387f45187ca92500eccbb8db51553f5d3bba717fd22b668142e3ac7e9fbf0c38852d513d1ad656df1769eff03a31d9b3e92de29d4e53cf1972bfb682fbd9bdaee1e090a355f3c12bca42c1042f628e804ddd79c37a93cb3a5ea130830f9a714e795b7d9f5efec93271d8caae981d53d303dc76e68cbe4bdce4df05c7187ca7ea6d2a9586771aa765a08dfea669b6a98e2635146a3f92428abd02dd54b59a24237b2384994697afffb37f178019f116ec4bca5e8fba5d599cdbeb66535fd88bda7c216e469f3335c067bf84881fc532d6e9ef110e0ec25118e37f57b88eb42c1429cc9cda0bdeb59ebe1fcba7c6ffc5c33a3543bfd0ce9196613ef6f760cdd3a20dbe29b50c8c2b17fbc00e90ac723b594eb6085cfbeee77c0de46b5331e1b719fc71b60ba4bcb564d96c96715cd17392a92d1691f5261036210fffa5c588e01ddea82560af1f4bee82da1ee5250c095920cecd617e006d47f3649660b163bee3028b5d572dc442b116f2206929bfce68b49a05a62924ad3d495c3b442a478bf596ee3d5869519a4bde1bf7e350dfb9adbc258ad33e28d7c7dce481a513511fec245b86f5a31245ea4daecc837f6118816ed5e9cb39cab6b35a724b05a378f79aa3643597d78ba927577af0321a34ef8fea96494ae87a34f2d409c5556f9d562550d164c7e204fd785164246f1b6aa992fc3f30283679a4b6d01e09d3c579f724598b38b6320029a5def576a7f906b452386a0962f98966cb86bc61096c9e01c0bc5c4b618268beb92db5d78a3c65952c8a8523af21620b58e14a7d50b6dc7c2868101b7cf6f9a97c2f90a63bd402f8d74e13d39aff3bef49073d484d816a57cbbf6e770b9e05b36ff3ff4c1812f3b863f2f907f3192b6ac5e3b9064d1b4b8f076d242bcd8fbc3dde892cb3f615a8adc7ba8d2d3994fcbf0188557901c061ec4d88285609ac362ec53125f5a33d2791b5ec5c82bcac3aa50bd2bd348a3556e7d2ecf508f8f55d7a80b91f317b479dcc844deece7d3cdfa43d8c914916a50df255387dcfddbf11c1a6657259bdc2baa7b90e232e53960aa786bcd614e187ab3948854c32addb2e3decb22f4412e2444e7b124d256df07531cb0f767dbf03629ed5bdb8ac8a9fa11de238f10fd8fbe7c601059f060819ad0a5a6eee0cebc6b4bc49554039c61cd45cf29834e58a0ca655fc2c5711058ea78e5ca465015711f677d12720c418601945b4d19256b2507d98473da290b57aa3aae84bce1c77ea01e04327f3eff958d0cbc332af70e1f1ab3aff7f8515c0c204ff136347872b824f8942e2d772aa758df8bdc6bd55febbe32e3cb2135c144ee7ecce49a11d56ce83ebb8b3db6c741328f84090be08c95dbc7a60bb3e9ad6e2521c12ecf02c316cc8664f89fc28eaaa67bf7837557d7f7b317caf9c91919fbeba1eced317cebcf8bc956169e00a318ba6b3603dd7b54e9c73e602a8653bb9341cfe2f3ea5658be0f1c6322637e923c29224c1783007c36c514f2aacebd0784fa3b8a601d66a9cf423f0a46cccc993dadc7d3d2e289eb9b268672c75be50279bc5f4afeb31814376913325b083bd9af31e2d288bce460640a6b4b6da99266864279a0838f0df3b27f35903118b4257a34b01c2bbe1ad40de69ce6bc04276c9f492716dff77419a553ad98124e917fe04231be40f391a650de645f018bfee98ef9795cb45e48888a36e67f694a186b48eaa76dde771de77c66990fb857e1ae453791e37ba2bb541fa59739863f26482b433f67ab7955caa69218ac772421136188ee6d33acdade34553bbec290a072bc7667ed8016fdf5e64986da8757a7eac108bf2ca05cb4f8e85f914ff05319abfbde5888197db4ae6badca005e01c9f63f6b890701edc6ccad78efcd9b721d210b926696ed751e01a9fe97b00885f8bd1c50297ff7b55c0d46912cf0bc5a96f4e15d54fb8291bf98d388cb019f97443604963bce9c2c32d8d7d6b849c5c63be90ea664ba8034db77011275f4fab72d7c1045291c064d2b3c53bd0691afcefd1e36199a8538ce085483c579f7e1400867bbff51fef6a089478a883ac51c4dec3065fce0b0f9853c6dd65f272d344ac8a0d80d61365b1c7b6ac7c70576763b1edd302fb449388599ad95b23bbe5229b23cb547d9c4ef99c5d34ad80ebc05c3cdef86fd20ed51aa8332b227f4e565493592654ebb3cdc5d37112c77744b69f9098d91b3564aa6a88481f1486398f0dcd9fee44b5d19d76a5a95c6a3299e854431f12ca683ae33aa7018877300242118a1584413a213931c88bc3fd84cfe7f40d759f22908ad1d2aebbd4b211e26f1f1a423f8ed904c70ef9642962712a049bd4550f1bf11797172307e1a2fe911493dfaff35dfe66f9cc806777bbdb093552458198fd39404a75e8a362df7b3fc55136bd4c1e4d3c8fdc246028eb8241e6e9428a7de8cbc7a1aebc78dfa559e162f723fd9adf7c26dcc07a6068389b8744f51c636d5b77f0165fbf217c981b344700f38459dd5a39263e26cda36a4b1aa75da6ace756c837898571eec869b975787dba96e661f51bfc829e4887bcb09187769632e4baa37df9e5fdc63a13db2e5591a04818aa94c4924cf2057b8701f636c7eb1459ca790e5149b40ca9ea2fd4e4fad1941778b3f9476bdd85bf1787aad06288ae228f2f8e56f9cee6e52d95181261d5cd8c866bb1e44e5642a217fc261ab4994c5e0e6fd37b65fcc0679f2a33d497bffaf3a3947ca5500722e90b17cd952a2ed28e19c1196bb0c1d616c69b79dce041c226f143f5a3eebcc1da6d66113d9994a75424f224191fea0e2aa2c78fbc5bbe6baff9942e4ff7424d95f11cc3f4323faf19ca5992cfe0abc94f3ed80d71b5e017c0bc5823abccf88eddd8be4f0e35f4d0052dfb649099961b9ccd9c3923797337212bd409e53ebd036acc9fbc53696faac50b6067f18f0152fb2ecc9731b46d72ef203f54e195e7b01e6f1a8656c1afc64c64bb7bebd7a41ac98b5be1aa85da26bf9771395f2ad8cc92d0e52f11acf73443f40a34dfcaa52a2bb400804f5683fad6dfd2d137251194aa333d1db021c18bc3424b97010086bb379ded99d650e0c20f5d803d63c12378dbdbb2123defb0720ffb551b408f5be31a97a861c2fa07da0d191c223c484c9d8f06a07001534ee4ce6a8b4f3d11f71327ca529425d71134cfb826dbeb8367db0997f93686b5cfc34e81665e84f7a6c001c8de907052706569c9a6267e8c8f36cd5cd53dae1b7008f801b7170f8c4d5a75fef9626aa4a68bc1685f972d454bd8822d36cc751f677af4b140787100776ac051cfb2004f2d615d30d048a40391db6c759248bf5651b233f6606ff63fb2fa6c515ec28843de4cedac69be5fa929cb8c35ab94bee0e54536835a2fb4f41f8d00805ffb1bdc098fd3779c4cfd03091ed048b6b337aab2a15ac5f830332985212d6387cc119163178788e0a1d4c39d4208a1d4fe6b2061f9d9059e38efc16921636d5cb5f2ecb8a1ca3a4884160ee4f715af32a092589e869629a95bcd74fa6904b483f7336b5f8ead7b465ac95d5dc625e655dcd520978308c12a28af11655bd3a89fe1f4417142d8db806e17424f88657d435b8c43377992a5ef463c593f532ae170bc91221844e763277872e5a121bed9f8060e311a057870f9d6dec752ae29352a89efdb4628a1b6a23e7ff0a7add1d73cc424a4c59d0ba359fbd95b173a9607a246bf56e07346e378ba13f222bf0c358d1cbb0583def8311667d786ec92d89896bef64653db60684f195262841b35fd40ddc8ab6c8f0017ce040d7a51e69ea8fc1b1006b3019b1255ea60c6e3ba08dffaeda5244ae4e4553c5b2e3de786f27a7af3adcf4b0c32526e0d65e15b679f5a4f4717dbf3cfe6c0fc6463d9f4f68373df2022c22729be23ddc3b5f868961d9c5538b4efea7dedee26a0e50a0bccb9e7d1eaa5ea8270e257d23d030fa026177b43a4f36dc4195727688744abcac1b7cd70ed7b23202437c70757114904079d3d467fe0e13315efdd2bb59b69447be5436f3496e592b43cd9038ffbdf0c87f3b88043ace7bf49917dec75b3a8f258fe12c10c81e2656774f51ed9516a8b5b8f2e882c6c86f5be690313305f355451154ef59bb58297aa503fa3dbd0d61f104c0d10ac890a378e5de36c3756c537180b094da9d05d12c47ea928af78011ef3896e08d2b0fdd84fe659604e74566f09751660373eda992621a981a5fae15c5a26da031bd379970387989ad6b8202b11e93c2b84314dd03292218346b68e8035624d62ebf8ec8d10667604558d86964d2d6dfd0298c307e0ac542ed8822782f7ffc6178ee419295a977bdee09f3cd0444c12348d3ea092a55739313cd8f2606108fd57114170fffcd0e8672bfe38edbcd8919649e498e1eb35e613dcd8501633b56ab503ced05234925fb59d6ed6c302681673c97ad2c444ff967d113067b3a025533f7e13fa83c46679c58db8bf9bc12f0ee720cfad44e920630680ad5abfeb1289f032a4a27e73edcd5c3c8ef90eed4ee8fcc30a24abb0c11b2044ec244482cdcdbbeef17267dae1abea30f7f852f1e4f767d772a15c04fab3db42df8fb32f65621ecd09342e42aab582716b588559faaa0144a43362f9d550b23fdbf3de47724c0301af577cc5310643c07888f311a67c9b85d071ebb5eade936a513512fc29ad966de45cb264ea8464dc136ba0e9eb1c83d16b40b238405ff51a7c385772829ea6ce1e1a75ed7e62db59d730933afa453fea70189b6389634012c209ad2313591966c7b4f5a8e9c42ca0cc84ab74836a4b2a6bdad1171d8557b9f23fdf6c73539c6562a4a53621f708d2b3f8aab300f0010f67e97f58a0c6579a44df6ca7c6085f1c7b52c7c2ce6c2580faad43edf2b8e81168a29d4e9bdfdaec4d0526224988dbb04fe103a766acfb1916f301fd6f5e9ba23f6bb19d39df78a9fb02c648530c2d76281ae77de4b1510dfbbc9baf537e8ae7d53e49b20c7a891b3e8fbdeab9d3bc88d2f9d5640abfd032cfaa3654b0f52d6194d62614f306fa8d6bebf0b4f1804bd549019646da3f8a4a4c91b52ddcfa6fe62e50bd0580121d9464d53ef1eec8abe6cf2e7f4ba6abcc4e0b4182d4bb42a4c87015b4bb49aa7515decc3233e548d5ad6b1167fb05388f3f7503e72e37c213ac75bbc7045de3e21af0a5c5efa843379f8efd7eaadfec65a25d52d695c5b948a8d7ab59980da3492b5cfbdc8aa476e36893853c806a6626a00186cd41d1281227c0cfda7927466619c8bc9c4e9f051f8c8aa0c999c1d56d6a4d2c4439fcdc06e5da4d2c763e9dc6eaeefdf4905cc12ff13c6a437b1dbe8b46cb713a01214b48751cb6ca329a861b86688ada8b40744c2175bc74bdb2b575efeeaef422a6e7b7b781fff8cfe9d882eb33af4fa7892f7a8f1d3e680b9f721ee96f27e1777eba3446ddd01bb0831d905407c21a994b0f3b43c09f26758b860b3ca5fc13453566dc5f23a537818f2ba5ab927cadb6aac1ced6ba366fc5f35c1404884c2f6e5d38bfdbad3304d0f8b4691ead3070f55dbde54ff7054db93f0a3fb646371970b38abf28c018dfdffcf7e4b937814d5cea84bba7d753a727650a83e20d91a3b7c66657bb46a3ecd84cc9c6eae3493604df186b4bc3e3c5ce0f1af997ac1842ea67a1236b860081b82e2bca167989f8deec7eab3ebe56df8d978e67541fdde0ef91bffe2dd70048b4b048c2c2a30f136bd43546907aa87c0a829ac62dc907c9b2359fe0f5c6787bf51da2ab9a0cbb7e355d9f78854a0124209106c42ba89f5d758ddb1bdc269c80fb6bc627ea35714a98273d55724527cc28423abef607699d706b6f3ef790fd15754e62d82b82980b5217362b4cb8bf6dc9bac272a420aa580ac55ec5f239a0307f1989cf01736825b8abc6e7060998fe5bd26b331ee5a149b1e0a5e9464c67377253f2aa45518a898e3b3205c7ecae6592b69df25054f7fef0baf0f57f201eef2f8f4c55dddd359812a3277f54155d779ad8df7fd5b447134fb20716b3fa5f11cf4aa5456fff1615e73c5c542c0066248df0d995332aa25e0288af1f06730781fc82f3437d117aeec98c0c815d977de3b13ae8aa6e0acc8ebca4f8af771b96f01785dc93fb82848b704e9a40ec2806cd7fdad954dc4829f8ac08a6189bba8a3767e3a1e209b391ad0c330af4c4ea1979535ca20d68c720e3ca39af9eb01861174884584822f6c1052be1a08b749e492c62a37f41e77654de2718248b0d60eda918d419cc434245d9fff149b97c7caa18408f2667aca2de8a4ffb41cee8fc15dabd0f55eeefebabee92581373c90bfd14b83808c890512460f392e2265314c1daa37a4f97babdd169e0a1f0f20f394ee5d165c0c763a824b68aae608c4548a5bd2c78e2b01c7b1e022c7cbb6b2155dbbecfc735cad0ab4f5dc03517f4c589d0b2a611e047cd68c9e1643ce9786c376689c2f39ba7791197fdad822aa87e8f209ed1802faa1673aaf5c03f7e04e2cae91009f1c445edd83e3929bb0427bcf3415ec09a38a71953bcb66379f4aa00a2f3ad4b4121cfd6a691785efae28d475191360ceef9404e27a2eac924a70821083a3418a4e7c1e1cfa6162d03fb22458683c73a1112416ab57056077b9c20836c0f36d38cb959d4738c03e127a6004457edc4c6e15bd5931cdd8942169b9c2ec587712742dffd8b5b17f85d472481f9e522c41708b2450bbe83e4110b385a1515302ac5fb9d5698ae85feeca596b92ef1541e9fddd0178b194f2c4a0501cb8b2dd1bf21def60853ab64b71deb2020313aae217df18b41fe19916a858b1bf908e59e68b859da3aaaa54cfb1d3596c8c4ed73ad8eb5f1aad569f1228347cf0c08681108abe255de2ac9fb7cfe9947df72c503cd44424e1741c359ea5ce98c4b7fb60935736f0cae413542e4b5f7db300f48108c9f0ebe965dc7130475145542938dd593429e832eb9a433437cdc209dcb94458202df98f341199cec748073bb3817c869f12f2abc8f2c6bcb5f68aa8bb531df1c1b7eada4c79ba5812f70c7b8f59d320269cacc813938bc886a7e33fa4c5f8cf51cc80f49f1aaa6420c5cc3932f0b57de2e53ba8a475ca73216330b3e2d2a68deb90b980b983b943113eb9a7dfb0b0b1e886f1276bd13ac27ec87e86f38ab792933ef1a119544549dddcbae0d1562ece1d56706822545dece0c76803bba65acfaa71bda4ecc90918a8fd1a72cf29f9fd3d3b7132b6cb3ccc31c80ebe25d2481a2d4a1bbe6e76391fcb72a44c0e0a4ad5e6e442339352ef35572284423874d38e0e95eac386615460ac172bb20badc8481b43931bf07f159d9f99b38bff8251e628b6b0b0e596978d544c80e41eda2a3472bf40ded4f24f2e7ca6430bc33215fc8834af9c2493e2de906d8d20357baceb3e8deb9308b8bd70d676f65b9b4bee9df224bf9fec706008ac0ab0a3b07b207d8294144b24db6121d17167ccfa509e931dc749e7dc97a33dce39b3afc1ea5be86bb6e3112d0cb53e7c471058e3d9c0d308fad3e5f32f484ca2a88e2a59d361de8c948aabd88fde55a52d2c717b5aa2b9dc027d27373043d424a81497d4fd9e61de12de2094af872111181531d86f8d367d7b66b6a01cc8365ba2470558a0cfc4116552823cd3584f4bd40f7f5f43f11d53fb2c81bc362e81cced6ee8d967a2e2961e30feced47803a093a451ce537c5fb10e226f10761c56d51cbedb3342b40b341d30d08e099c62de3460d57370c86d0b08ee91fcdf48851ec87f5e2a62ad0db2eb4d08c8231af30b1bf454f213a2ed80b241e5e30ebbab87de218266f63fb3f2d656fde2b823983368fddbe67d8f669cdd547bc2c12b5a0f7260009a38c3dc63f46b54e67102a6f8caa926a1ba3082a5a37744cb0a066605058f80d4d6f0f6d36a7c86b4f2f32dd25f150e79badb40b6c2b320c6d1c24ddbb0d057a943b086cbb1ced63b54ddc8a4f869dbbad2f6ebf0dbf136d667b28193c1a8d08125b5ac79eeea168c4eb7dcd7ffb81446639f2efbf1524767e04dd351feff41779659728b6bd72956b4884e01b270d3414320aa8897e143917bd70bdbb18de52f7f23eea13d69b7bbd39e21cf0ede86440aa07dea4fe22491ede7ab9defbb7ffb6a65a280a9c91579b623af3c7979a0366d75340a1421d274a3c3b7b669a5878fa56f3d20ca0eca092dc4a8f0c04e321fb9a4e3dd0b8eec09df9fec1ea55b2ad53aa8a54d326b9603c8b1060164ed5fd2d3e25a068231c948c447e899543d4cf3a666d267f4ffb14032c92a4d247540806cef6cdb9320d859cfafd2ff163e4df7ec2a426e42e21eceac01f4da2425ebc54d0f17f6d02ec9dace676908e6648654207f015958c50062d434f52cae4d975973ddf3bdace6bb890c712c69fe244a0a775dbed94976f1e986c5ea11d2a48b56c163c9027e5e728f470bfaa5b1569e54878c3bedff0f9dccd9cde9d3e347d480f493a3849dbbdad385422b15e7ba30b8111b2d4f8135ccc05aa421f5dc46880fb454ce85e4a5f5a81705884c7af929b53830f5470c7835c1e42bbff820d53994e1f9cda5b3788326899229c5cc316f3730aad6836d0f3b5d1bddd697537018a1d8a99cdb4d303001d37d9e500ac2d6bceb1bc9c6c5ffc59c78319f8352ccf0c49ce71f201dec57386b59d36c1ff446e67cd6a99c2d39ec7c63a05842d75f91ee650d5e5e6657115d71c38190e0d0dedba945563610ce47a8b6d4ed22a392e0c677aff9c270a4ea87a10116cb33a708d8d0d0229c076c4958ec96f847944e78688807e456ed139be1e4525282cabdb3c79d7e6c21f50a17cdd0b915600a834e46cbc83252cb8e5e4898a3c2a111e2678e18079590e61f67dcd7cb908b1b76e25a568cd2448d63a05342ffd079122e6ab744b9eac0a338935616c81988d89f9a0a1ffc094c5f699d2a6f8ae6c3c9815e26cfe22fbbcd5c1d4975cb56821086139d9d9845a411564ab97351b804942ab357be36c4b05a4245d3bf034f816c7f14e55b102a622dda5592edeccf4622eab5a7685471dda77730275f25d6a8988acb4068a8cd6efb828ca63d3258e409f8a171ed2ff1fc2ccf02c46fabea585586cad13fda9ea815bdcbc10b1c7f6edad14adfa6fe0d6e6e03417fa6d0f096145435cf8f72c768f617cde162a68ec995192a37bca80566cfa221879d271cf28aaa02969ba131b81e868a4f5228b61762b889081f9cced5fb864bb511d20445b9ced5067596eeebafb32e1ebff9f67fdb1d4409b28785a79de54609214f88d8e6d41b9e347239d486aa9ce6843fa9604ae05135686bac7617fa072ec2f32bc44a68fdfd6dca0779ccb447051bbad8f5552a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
