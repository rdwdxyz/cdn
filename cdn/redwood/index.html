<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88b2c7a83da4690b155c9d0eb853832e3e959f7e6ef2eb67fb7f5facf8526a991c94a01bcd4f9edb65ea3f94b6a6b6966c619317ba089c35d1e1025eefca08ab19905277d7929eab4090049086e190f356c121ab4873da470085a193d98f880bb73242f740984caa376aec5e54523cc7a7219af418248d1758808b38a68f4b242d47133d33c8b1f9874942f989f651f7ba00394702f5767b9d8088df369b6bac91943008fd7e5c4b9b3228fd3097a4381d7a52f56916aa0754cf9ab6323ff0a12c7b2be8cb9622ae6cf4dadde251a80f3eb9de327c752857d9186d67e292e4c29aa013ba10b8bd45ebb16265cfc7898ea465fd7ba522ea0319ece2a90b039c18783a3d3beb8cfebf05a7db9e51eabe2361579162f04e501e7d8541adc307baed0b7d0fee51bf43aacb8c9c4910a0cb6573c6667041920621ba473fe1205b84d2a8348b7055231c938f6d0e4005f4a408f2524371b0ec928086dc760db2f8d6e902a1df4fadd7b2c1a43b823d41c1418ee816b33a48c52000fc67bf2e4a4eb2eea8a89d0b0f637aafeaf4c39e0676828a6419b42bd6083057c99f9ba50bd4898efccbbb809163b121d3d197564ae30bf9f5cd1cd3861a8625639a4d58284565076366d75eaea38ed2cdaa93aa68203296ea9f7fb0d4065c6b05c1d80812c34717946406acf84936883eba5310b5dd08450edf223bfc5b6817a2aae19f8fef4533798db10aec89121d81ae62487df9f4b3d8bcc6296b32646eb4119dbb21e3f3fdca69298d19bac94974781f3b3f73b28eeb0c28572b916cf7717c9733236f2b75117017502bc50c719ebf1cc62fde238795c877fda69ea1ceb621f18fd0d770408bce010a455f7512d30d6d4a587d071569e6e258997f1f4742fab29352d99de8d0c20b52d8e35151f5edfdb9c63af351b682c67aa8b5b1f362ec707c7ec2b644f3196932763a21ac03659cd27fc67b116efc3c1b9bca35186a658bd0e53f1dc9cbf6d5f6e44c21c8ecddbb4a20b30d214221aa8de9a884c958a15447c88fc5a95eee5183121e65e8d72546f584e1172af21ce651da1d5d1a115b71ea8e2262b6bfa1a83fe3ad9eac6add596f416c71c4ba13bc7e4b2f5058b63e84bebe312c578d82b7999fffafee1c414f27e4f043636c34ef5a2c5d39ffb8ec90a66989441d667407efdc58d9f1ac88dcc09ca13e08338c2640a30e4bf58d557b2e7163f806ea898f0e8750e656be92b261641b218283c33e4eb93e5d6df64ae777b219c27c619c112988efae2ef964a2836fcbdd2bcf3d12110c732da0c2f2ada0e8fc72531adc5ccd7f2ba4ebb91846eb1a23afdfc342845bad1fadcfb03f24da327724e1d193624f4da544037d821e9a533c559fd87189c5eaecd96a63d2620b021dfec51dcd57940b4854e39ac53f0cd13d833817b7ec5f831de0c738e0dcd2e0f09e02f300f656cacc6a34f174b2ddc22451d5c5baf20120de8ca37d8fb643722d1457b35efe110f174bdc762be56767382891e8225142764cefecdd0fc59698cc06afa232b85dd7242bb28723df9edcaf9677d5e1e1a4e5c2d88cac3ace6f349bf0ed1f4408a34f6c172cbfa7ab8fb5f50da0d54cf1fcae45ee2bb1f521184c502e608ba2f0abef8d54787ee317553e55d2becdcdce355b7eeede9e9c8751606c000101e1fd097407411cbc5ec2ef0127733a4603339f549e5cf2db95c61873e620e210443b6be0506b6b1d724eeed5e74f4f2ee86226adbff5835ad7034d69103abe8853e17ff5fba3d9ee7de2a24e1886db36a904ccbcaec049b8341bfbde360c9a4b831157290533edb6b03223279dbae5d8efc1815f48f0b1b3250a771b4212ba01ba7916e8c482d9d260d02ddad7225d377d382c3f9e4ce7360ab4546bc6bb14fbd9c72a10638396784e1cab764d141dd34ee4070688c237a3242f67e7700e4a249f04715e0fe89443b2469785e66df4bc3198ff05c41abd3fd30cb32af9b76283ac82e73f4dbffb2dc0f3f1d7cfcad4423a5ebe1f10079a9e49412ce846408c5c074b142392f0bde24735d17f3cc44e5ccbc68368805bc98593c5ef02a4b38d7f36686ee13167159c46145915724c562cdec3dca23762224d4e4c50755f9b67282472f1fb2b4bb8307e51f2626da289f76e068e586963c4a1d65e3304248cdf8547e55d4c1789785c10b0129f80805cb2391f241dd01fd2440fb3ecc6678cb5cad962424b0a5c6fe5f979a6c0b97ec3b8be2256ed41325fbf5f8ea68d9a237a9b7174c6d5aaa5078afd31c7a1fdb0ed030c0787fbc3325ef2781f76a2498c266932651584d0ecea2330d1645b496127489a90d9442e8ae1f6b0fe9e41dd2d33a66018540b57ca0cedf653c51527a74faebda77728eb8106d7dfa8c0de1b71f0916fb6cd01de12a7152a549700f377d054305bc7944ecbcf67e639afe2b3541e8bf0e85634345997ba99e20fd5681d042f1669e7ce1f45d3ba1fb2626317484b42951018dcc8eed175388805f8d6a4805f40156a2253db263e1337161ee2349a20843971926f51868fe3d3790cc7bafa1bcb22cec323ef99ef2eb2ca38313fd3438118a102d8bfa379266f8570f29d72ef142c09c048a93d197d881db49e03815aefd841a945af06ad2cb0a092bba4f92e9779f112fa408f6ddb3644e7b2f130b3f9871acdcdb3f07b857fd1be13868913397601358fafdddc376d0ee5db7c151dfd8a1b5fd3a46eb67bb2319fc4688da2d8268de417414cce01ea0d99fee8bf6667bb8e4b7c840456e939b631990f7540fde9ab713bad8daea8ce9791d8ff6ca786cd30f70daa592614ccd1ee8edefdf75970eb2a7e356d7303897799a469abb5fccfc34d7b41a54758c12c08e3825563119bffe86512876be98c728ec8bfca60f04c6d16274a66d66ea7767b1773e27332a4717461f72ff5547304b30331106f2d38e158ab9f6667796d2131f75cf8682488abe8412dcd437d60446ffd95e7ce2b91d04f7e2e725a3f06af2d6f23043652f647cd8d8d52f74e66391a1632b2ca25600ed0f031692d163d52368ddd18b27927d2d491d151bfc6ab20529db31445f4ad8f7834e8d12716dfebb2e9937d5d893e2dd664ffee0f659c1c86dee0506b968243553e2b3cee7dfb3709e7f5a3332f3f69a2cde8af9236927e8d17a2b0c18fb82a1153618e596e96b12ca181f4c51ab5a099d605d2393787d63f8b2b56b140ddf2d7966ed1d44e36d7b0ccb36215dc576c6c46d532ac025387893f2bf1f32f86e0f34d9d1b2d1d90b53116038f17c4d57d1645fa4fc10f4c5831a10cb5a12ed8a0cf0b93187c98658f3b015eaac2cd262b5fe82b5c54e3aa0231fd4de57458a775c7f433ede04fb48ec1ebf2eba6c20c24d389a38641d495798940ca9f61169f630d7f2266b7e0aba3cdd09f6d34f58de97d40071f8f995fbf2a2364b640b0940d2b7ea70ca551455d71cec98714a4975bccbc2f300db59d854b70083928d2359c16e83546bdff323112d54aa166175f989282d23a8e20b907bcf1bed6dd61e0d899382355bbc345b78323c64b2e946da5b3d18cf341f1c7ca266e41ba2b707063c2e8ce708c83a8d08da6036edd6b59ce6d6fc3fda223a04b080238f09f5e2597d73c7078361fbce90e05cd8f341dc91953779ab381c13f59c57e3c4957247dd805e5eb1b9da6e20cc459ac1441a1940f0e6650f27a8786730daab324227e30ddc8e8360e47459b7307cfc1d6fba0d62700a66c6d3c7b8ab124943b96dd9a8e8ace3907705a680e2b1b13263264199cf0de250db1be5f2a03c51de863199c5d4de4d3ac2b77b211ce29638a96ddb2be87eb053fa7759ef9cecd0ea722aa61f44c95366685a75d405e91a42917cd321a8374150f31a0a36f4560d3ab6529bf5709fc8e8fc0b813a62cdde6911f5f36769833f7e6913fcff6c0545b63958f982a3ea77bddfcb654d625e61825428566fdda32e89348427e95157bc01ab422118b054b5a59b4b9b3dd48c6325764138a5eb33e50cc2ca6ba3bebc37ed7b05139d33fd3fb50e2da75158f52e163b5b306336b0fd3e3ccb92261f5719476e3ddbedba948f70d574d7e6e049af0e9c9597c354bb9e80456fe07531c2ad5f65311740653c421ccc36ec560c7ccfb6986562aa0c05350328f9a87beeb3131a100c580450c23f557d410bbb464f931ecf118b28209c350e03fde6d282ae00205403008fd9435b32d8cd2bc05fdb3202774ca122621bb252450eaab2b6767328535414b1cfb59b6ea9464227295f785940a8d90fce2e0805a4ef8e8a208569190c4cc388d9611ce7ad7087f6822253bca5f5671fd98c1cd40fe9aa4cc28e49b85cfe333a9e48dd1702dad3b439a84a709c76cfd6f34b38e521fba20b4e07a7e4111070314b661876070e98a9eba88a43a998795880363ca91c78bbb7ce5ac39671d694c4005ca5e64e88a83f3a78e1f8a9879bb6966b5513e3cbc7d46fd21e9e16317e02bc9273b6d9e957214c8d67b533627b601fc9b2a89bcdd52b83a8ec7ae8e8a9c07c57f946b771209c3ebeeae16e3b2db8bb00048afc5cd5643e57c2181989a7d08c7284a3b9917357ada79a66a4d22605d321c13d05cc54c333d6449f683f46d943096103127dfacb71d163a6ae3e7e5ec02bcbc8540d8452d7cbe0a947ae975a9b49aab057b2e65a0136970574f1633700fee8aa05c348ed7dd5460c27643c9a763adfefda5f5710f88f6d6583b58c70f78ba3e1232f483c10c0832e3a28af15d0eb180db987ec1e91cd97e15364f0c0b0d9a1290bb155f59ac23efb7fa74caa61ca7b7c2554dc8b40b4f25a270bd831cb0b8fae480bc9207b868f826b91e47a904e89fd63c4e817e72cf3968b4b3a6ed8866054a1dc83a00019b63860e73d12c74f40a020f4eeb30a146caeb2959659a189dce805b42790ad5189b0d2ad223fcfa6deaecdb2fcc62142b2900370f56a359a93e58ed27831344a63139fb9beb4ffe9bbc4db5dfdf8a85febd92c57e7ea7c6b767506e62a33619ccc36f31da4d9194d334a5c651cc65ba6bea3ece33d61a3dae881894e271cefbc30ba761a909ee35379802bed78c73fb7b9f625d19e89b7cca1986c8ae62f345e0792607d2d528681254b6dbdf1fbc6a58945d9e9b304dc05e8b010be2578cc8d2fdc7756990caeff477794bcc283a8af7f84855a1524e04f587a6637d5827c7da070eb6545e6d45071e7d9a01bbca68c1ac3c40e5454793e6d8c78ba6f008bd5a76d2dee55fe1654102db1c68063124ffb5e55db6c2f38f6083ea88484a164e1dff11b457c87b425275ddaf07e97fdbdf8e023500f4fedf868109bbfc39a3413d89ecf3731c4d04b072c340a29ae963519f2c598815c2fc9897811502cff8949130ddd4fb8eaea2e0fbdaa3e5c526e5935807dbdb451f9f7622c61616bec3642316a1ee4d0741c88827314a8f9eafa37f6d859e03c3f9da1bba822453c717767aa6250824f80b8c919b04e70e2e95b8356b7bed91510e5f3e7796ca8e3fbb57201c8f6d4b23cca1c38a40bf5f86badb39ee4673f15868cebf3486f151b794246e360bd2eade3122b01df4bb0fec552bfb3d79ec45b3ac1c7e9da7f1edc1d29be593e45d1f4410a1746faa441bb3cc92e8e72fa87b77ff36e149c3d94178d331a5964650747484ad63fcb4f18d4d1204e0a3afc5a12aa4175f9a388a42799d828935fb214e811ec8e2e28053e242550f6c0580f73657002a56969058e649be453ab2e0074536617d65f9da406bdcb20f03d2e392922b0123448160e0f680ee8b1f6198280b2c1175826c4d71fc1ced42b171dd3401e8470d6ddeaaa8898462bb23219115b95e59535429a32433e15b58857e9dc0312dfe84723fdd8de940c6660e7d068cacf73406f7d4640d342accadeb7dbb4481c56a29dda88deecfe91dfb7a82f47a5f3759f6693498bf2eefd8eb5b3dac1a7f15ef95fa9556725f0790193031c756db8c02c4da3db21754b5ef1029f000ceadae3508e742fc0d05ad41c7de78608793aa5aa5828860d01ea587747eac789d1613b6faba32cc20c63d7bd195388bb0848074d3af2caba3865e0fc308d91a0f926c9320c11d93578c51d7385038aff719837bf2791fbdb29a71a0a6073ef9a50c4a6439585e1b50d994efae6910eede171835284c2e5aa9098ec41b92996a6525a0adaff081ccbd9d459311d0b1afed0c1e9eb0dbb8bf8b70c8131f0a1d41b564515cb6e01464ba5624e274e715e8461296100a2cb33a52c8b40366403c9c6b426a4c612310c113d0ab3b6da319957a5eae97751d2331412fc5863498436186fdec1d0419d391c9fcfcaf272b39ea0c440303f6177ed4c262b418c04c7aa3f41864be8aa306b8ec51fd6d35250b2b0c24f188416a16d9b780c252f810289a4fd3349fa3b9bd38aff783000872b5f0975f43928a0f4a5b54d1981adde1dd8c5bf0234e0495c870f5e5bd8a0252f2bffcfebf096b7fc2db1ed94cd9b6fbe0a158936330194ae72b695e614ba22bec97c411fe0bd1d30ce86f1e216ce35ca9502b79bb8d4a2982898045f7e476a26016afa86ec8b9eee159f4ae5eff99de3086e7346f12e7078692bebd4a58efa3911729f9b548c0b1e559cb58985025121140544c82f2e99872a6fe5623c85c6496ef32af2d1ea1735f1ff00416068cc10f3b18f6e7d50201949f08ccf2cc8b062a9db2516e272854495d987bf547ddf7d3164832252f4ed93548691c5b603f822d5fb406d468e5f7f48916e846209f2be2529f8f86c6d21f7be2bcf639e6ef5fca9fb01b84a3916c60795c8dd43bfba11859dfc8642c398a7563108a0787181cb295a6789383045b71b983eac188e4565dfac444443858586f1a68de0d9f1144715777327c537e4138ed08c21b477018c15db6e7a9f5b4fd402eb2d802434891b7d54abfe795eb01007eecf3444b3ba8e5ffe526c0bb56611692cb984b3e2ae55cf97374dd725b16123a904ef6529cca31f3edfa67923d30fbbf55d3133d6b6d2849e522a8f8343a20ba7143058524d0f23f46289621b84e676896882f9a32758fc20cae7f9db7698bce366c0da1ba8729591fa86326e4783a7ed8eb1e72ae73f4bab1527b1abde08b52f52f92a1ad4b47671c658f793db63f77ed646a2fb229af09277a595bb2f57598fac88785d5566e1532a214c83aa200f2f675cbd1c6412a220f0794abf851f2d3650a47c479ce93a1209dc4aeb6093d623f17cde5debd7a7991e24a91ecec99aa59a5d0c0368a8ce9ba729856da5dd337bf8a99457116a0b6dd0ca2285daae7b5b1e742dca66f6311e0e40c44bb0ee4bb09d63f7d70bbe2fc06727b877f08a5409a211381fe0603c615a595a610df868707446b3779809b4f4c8d9c74f34ede8e0ac3c8c787671fdde6ca9533f68768838554a8ad69a5b152dde437476746e9d5052eef64afaf5c2c9b29af241478f51ffc14c3be2d91675d1953394bf572e3f83cb8170e70e8cdfb0d743553639a4fffce81466f13d85b46b6b3d3c906d33faaccf6ed4f7d67b9081a8c8a22bc6a7e7c53b5a70e56849dd83b5603513c401af8d201f0256456d1ba11f5e3e58074a7117964abe1078670eee5df5e5d7661189083cbc7615bc129372ffefdfd6139c8e0a94e7d0f40b3a2aec64c46089d19b5031f894517ec2a14dcf5bcba44ee551533e921cccd07555403d5de1bbe90e0f940c22bf2dbb92f1f82b5721950b4516aa65f6f8d37cdd5ded1e381c06e3e34160b58d48e4cea09c1ef785a18956f9e9a02bcb26902314536ce443fd50c07742c970f91e89338c0f986158cad7631003c094a6b2e8b9351fa8ab590ce9ae51623708324999e3d08cb3c7fd64122b37e88eff91e47d467c86915e8fa2ea84d4e85042f7ac4ffd8b44f35494adea305cf726513b478a053affdb2a43e775e8a366ee80885e616a3fdcc946d2389a3764bff13a3d0960f3d86ae0b416143f8d57df8b4ed854327b6ae8a914b4b0ab25370bdbe8bb97a42efe74ec7ee594842855e16f8f945763f7650e5f7999d9cb358c84f56b7c545bcab1de8985311d9cc308c8ea07b2a59b42116bd66dadb0ef90b93fa6ef9e60971c8e3f1cd42c6528a79f9b0a8f6e3b7cd945db29174a21928d55392e36b5d3ab9c2bd636baa9cfc45b3aaa1f52beb963f9c5f7bc062f42b1f799ea89e7ab7d8f8cf8255c4b7b8dcab6e7fa0c180f03c9c0c6c9f827c01a3c7dc46796006718ae32212bb9afcd737e018ce255816c56bf1d13f940e5edc97b3648120626ca36554786398052aa80d7bff74255e702c163eb5142411cce50c3c114bcf0f1692ff75204d9371af4fbaa08ba99b18f1dcc27521d1b3fa06faa8c7f25f34e94e8072a9d15869a0546a4024da8550683ca29f55b0579eff190e0121fc20cb87dfdeed991f388d00bebf81429367d43548272c7fb8152dd153ed7d80a717920e75804f8e33c00523b296ffe888aedbf4796ec1e983e160a32c411552156e0f11a16c1e87a01cfc104e62ccee51e75ae5988881faaa843eb9908f48561bb51f342898d162ddf669942deaa786594769203039f4281c8968abdc354d0badb167370cfaea4a047f4a1c63b28df5f8530bef3893e6885746908799b37de51d94054c2d0f88c881f7c797b5eebfe74ed3320333bc12473493401608f7b9df0fcf31c9183fc721713293f54f5fcdb4f14c65499455b7945175e640db553540af979e87c944f5678181296568241c69383c1b0b791b24618af907cc37c1ea558d8b6a26503e2a8b615d2d35392d1f675fe30cdd3ba020fc611c77d49ec9d9ccbd07c78e6b6f104e3f0237380535bc1d519d8e533f91cd1661303eea521328c849a7e6707001e3b8beae4ac32bf974093ba8cb4f020a98f539082bf7248af68bc94b2aba57a373632ac0ed9052bbf4159ec668ecc8b463f7e977e92bc6d9b367e0e02f1d31e38f1801c91e1c318d4f45f23330dd250a6cf162e6de660e563e894b8c339ab6ba8c66ae3e5cedd9ca1e4b46e7f8d8faf07d705ff320c485b63298d52de868498acdf818cdc1896719de49cb27eea2430b0ffe295d17e839ce8ce58c346a53a56562e0bdd7fb5cd55792fe528effd15ab9a17639c138669434548abd6d828ac32665d8f1926ba0d3b027ed71280b16f27e6bf1339f1f1370da57db02b74a719ca9108860f8cdbc85b4623c8b0eb8a722b606398a05a41b22a264b8e6152c982a474d04d151ccfd51102cbdb5e05f8e5683e1707a47c2ca393c22dc32bf8a0a191a06fbd6b71168424fc13ad062f853eec2c2803dbc4559f70bdaf347393f0f222c0a0c2fb65d0d35a2e5ecf735c627d55e0ccaf0702a290b56d987f66968e8391064497c83835afbe9ae4b7c620ae80d4e8c6f9c7cbb42e79c74fa97cb92defa06b4fc948a17ba1eec6adef0a86def1c85c48180631ce0ae4f03b32c5901e40b67adfb588ee29ce658f2af2bc6a4b481bc0da286cf0489ea5629f65956da8c0f7f77dfd83223a2c50ee8e814ce6e427929e370f63cce9716390a411c04b580615e9ca4aa634735468ed2366e2ae748595b12711c4ed3b75ebf20b61ae9dbd569651d0b555f557bdfda0eb39e24f37405e0bbcce2c8b58b6f226c96da8a8623852b5ee7ca1da5804aa0f184be7ac21524fd53cf1f70aab5e35c03bef185771008c4565704e773cf389df2ec673465d4a2c32e10a9198bb8f62bdaba9687ce70f4c1da9b55e3af043a2dfc37014fa73a86bbc4b3840301e8d143de9c7fd1940dc1805452f0d1629aed997060ff1a86a7df0ddbc43f8290545198c432182a8af224a5492b9030f710599b75c57a3dd29f06b74bdfab84ea370d2149b644bbc019733bc41cf04d702a4975b9c0644362cf193ac5bc50fb784f9b241c850715330745fecef1ff85cdb518cec3ee8cc9b0cfe61a12f860f6b696ed8cb7f3c34f8d2e143cdfa673bd7f91f6945316add3402e2847e4ffbd330ae147bf9c097104b1fa5f63737f3844fdcb785c752a01a23c8b4a1856de21d50bed5442faa5f8f7914275cb278f98880dbf3c96f5e3de566f980b0a4f471e01bd366f07587609d862019bc7e0be5964e2f1322f2392c552b0ed8a15f429230be5c6da43e84e82e0545b0d820a96a6610dc4af203ca58773b31f99b51d800b5a6e202af765e3729aaac9760dec1d16c65b75d3dd43f8b795217db8b9ee6c6922f7763866ff9c81399c7a6458ec1f551d0e70e7c155f69711e3fc6ef806733f9b4be3820c8aa4cf25269e79aeaabb88a9a54c805f4e6edb2cd48fd2c374a642239d4eaca6cc104cfcdfe29023715f0ddc3c885a1dbc9b145e084af3c0993403b29c72e68626c0b0e72e121f9d0d3d321bf7f9885e4ae5a9c16f443d7351b8463f3455a0682275fed7dc2e2acd2beb246d3df59ff6654e6b608d3c43d2e709439c97bac24a62c20c229704fc403f7fbc0bfc391553e0c59f1111b01b1caa5f23567393cfb6dbea046dff807a278bd38e30887e5346a0e15b40a7fb9449709bd3af26fcab12bb3b0c5381397718bca85e54383b66a7847e02cece375ae62e460544eb3d690ed4423e58fde94fcf49c9e82d86361ded075c03c6c8cb9e126148c17983810adb78246ede7468b0957b2159493e1f576e94e039c7794a9c15ab81d88e28d4fb527bfb2b7a9a755aeb68ae5cb76ffc40aabaa28721d6cf834da1bbe99ff8505ffcdaf38973aca18e8a8b2d3f838aede0ba1ca49a2014f1994f91558f8b1946fb19838fbddedbb1de4c7dee61c1a17451ac02ce31bac3bf7a782712a3ff1b1be00feb7fcbb03fb77543dde8edf482774a8224738b297c840e170f045ca0ae67c33e19f863a6c3ae413c8e584ac4993f607e6d18d51e7a9783331681426f5007a3c59c0dbeaa02548228e439305bd38b618f46a071b9bce210ea5b2fd6e8fabb2317dd1be726a7811fe833d98017921e378a57d69b5bec0336798eec3f4177fac22c3b3c00e115a65a3fb9fbf43dfac8b32bf568386537208a6c5ee6e58d3f29f7be75b582645e47c73727af9eb618eca3a656aad70b77ea69667c309014104952417002e59c07f6e4c14be981b1a4ee502a1729876f91c04d570625ccba7a1b02409d75e1d20a7d774a59ae6d7f999e61990db18bd63750d69b0de01172498ceb03afcb0de2fb6c4cd4e8985c8b39377138fe1f35495e07b2c2a5f4ca0c5c5db73701c959a09c12f2144a9a9260c36dda5c5518495f9fd8c179038c49ec583806f0a959d9b722d6d6b56f3ea246c8afa735b14ba5002001a63b08495960bc712c07fc1f8d1022c1d4187a8a4200976db0c76d89bec3f31ea5b0772f9024db333c34368c63dc7c4b1f5fada1389b1bfcc6e06bbf74d8f0a62e82f0e1258c202b8c7605633dd46879ce43af5b37fd0d3585f27d48b6bf3b225c75cedabf1ce650db527a1da5e0568e9d13b75aceb23a9e50df1eb8bd67a37f05c2b326c0312bdbdb2b36fa5ad25469dd926d455635d4308969dd62254b6728b1b4fa8fed70f243510b63fefdf4e5f2a64eaddfc8ee489dfdee74771549ee7fd788a9ca238507829f263ead6d1cbf1d557a3a0991d5c8363bcb2c14c612e896b29bea4ee7dae0cf1910140be47be64a6942fd783d6d14a98fbb4dae84d98c78d4492e2ed03e57b235e477234b6835f63cbc768e987f8c012d76ce0fc9bfd4e82f0cee8955fe9ad90dbc0caa3cdaaee046061513f9433bfb3fd450d04c5ff704b7ba02f50e8b47dd005fab870cc5903f73fecb26bbf1d69b50693f5d135a8a4e314ef137811e3c0bf4b00071f698f5f1d8cc85ca19519ebd03f188914c72418d9aedac6445d79b400d9c4f6b9edab71ea07b28155e78f9fdea44d12368d29236c955022cc1d5882503b207e38afb57c65bffd2c7894ba82d2674c473912d4000b2a964af2782ab5ee16d40508bd730ff61d802f39c3b1a099202ab41b27833bb9f65bd877843651aef0b08c51920935b003360646f5f95ed40f0051b021c9bf364e603e8b2c9325e0d7bd4b325ea46e181437da5ab836dee5fccb3ffe96b9d83866e319f9641a090ec46cbbf5985de796d9e8ad72e4abdebc6b6e403e63e4cf962d3196f348ee1a1dd0023ac4e021eb30a333d1aff1a00d173269a245f48808e8bddcdfe7396814c2d3b3715c5ae104d8439c3bdb55babf31fa7a51a527742897267c43d05e00ceaa8e99e707463106b7607ec6b7cd83c47c7b96411e4b96092df4e4df8526d7620de5b43da7af60e40b6a58c3848a7fd991589a108d551f6783c81e1177f276015a3c69c771e2f7b41425982758f5d230863414f07cb3343e6571ec8237ea80ce53b4cfd8af93d4896d1c43427b6a5ec758a7f2c1758cd9e56219e0ca1245fe2ceba4523dcbdbde61e2562950bb5621b00e14bec8d9d01a8a602a29834154533bf36acbacacfc05f70568d5fad151310d4f79faabd467505d45720967d9f909afc669491fad9b23e8e1d7f6f0ec933761e8b06bb734d565606579c3b2e371694e8447688975eaf4c24520a44b2c97bca3f48af775c95a36a6966ee850e0ba8becd1a24d2d3ae95ff25126d55b95104db63ffc1238bb2bc76d80ca40423bf56f04ea0c107894a9c9157d4712e9ec549060f5fe76326a0ba9bc316538f5a3c7ebbf556811949becda96ce2708fa10ca525814c76a0ea7075a765529a0f1991a3ab481dd0195421a9d31c0cf14cd5de5ad85e2514ac660a32d2c725c333915b25371ff2d979dfc359ee58b35b48ac3866083832378388873a8e3eb8d8961358bfdaad8b080943fc0aecc1e749e0943ef7a77be8599733e9f60e65a66a8cae15064004531615a95c7d1b61a6b306a225f4e80b18f3f7dd5a77921efd94e96b7bc609d613afb83df7dc31b3ed934aeb3e6c9e1e370ed358a3404be5c7ec6e85225f6f5418b69de9e3b210a6259c0bb224cf5c0d4c6d763f52c168d59faa9f8eecbca4e94b5ae8ee3f5978b2e8a19d0650451fd315bed9b9d19b6afb1880fa8b3099bfd3d2c13408f05f603174118679f81ca4707cab1c50738b059719efa6357cd5dacd4af4e77f87580e88ba9c315ffc72a3a31357cfe9bc8b6005c5116c10e8c1a26d172faab090c965a275fd9ccbc87edb18bce110322bf71af00b3023874148f9522a171b7ae4d72c4f3b0c53e15978be2f0b7ab349979cfe2c987e81f10e6414a4431b7f96c97b8f178b60f799da9cd5fbf5c37e3664967ac3b25364e4d2a18f99001c1f25b4435cb04510ba74061a532055076e4770d5e29a0746a63cf3e2aa4e6be9e0027d261260526d975a2739b1485e37c13d0a7ea4914ad6f6db49bb460feb0dae10311c711b0877883950dab2a1f1daf94d3401a14ee9e0e6d66a2a4debc89d45253822c0873a41de92d46bee18361f1827df351524d949f27fb17d7c511b042f1c654831f4e1dbbbaa2d018db17d2413bf01ef1c80c0394c4d403b908712f54fa80fa653008693a454062852ce85204aac7983a9bc39f11670fd2002b4f7419077d55636a097b808ef0728cb5fd74c92145ce1401ae6ab0e8caf0347032362275bc5041fe3505de0f443217dc26ffe00dcde6a1dd4807d82a2ad7eb7b205e5dec301d8fe0503e3094f2a64f91c496079724987c698a15722170dd73c13c39d81ca1f109cca5709a3c9a96c3ba6e8915bb6d5301273fea3ca8b24793c4e5f8a4867184aa5761cd39d7cdebd60f92e2489d8bf0148705a6430d4e349e249ba44904f0d67f3b95ad1472f0d946713d9d4a685a5e964aaddf7203f84174f556973fa28c9a3a3e33a02b6fb804b5756cf6608a5858c26b3e40debbd57d6326f6cf1d5a21f543d4d484b021c5aa8032145f2ea0db0abe9a185ca110b3e8d20efbe5244fe73b6d44367ead1253dee4582cb6b26a592821b5fee9328983080ee5ac4867ec1aedd006639618786a75458730b5949be38c8c17c7892486b44eaa6b8f7100ab963cb1fad35a082451186c368fe278a0e7ecf81e5da0fd0380c41f7b02bae91d6cbd9bf4d0d3226676a3109b1d41750afc7901ce268c47966854b7d89b232a2e5d9f922dc23e3b52cdb1e01366fbd212e1dcfe24703ecdc6d25db58552e14047aa0dc16702a8b5b23d56e59282cbbd7f31f963093fcf6d5f39263ca0eb9192f62edde8f3136c5a27b63d5808bc0b4a27932cd4cf2331c9e0ae9f967302be246fdc9a804007c0c87cab06ddd17d91295909d0eeca55bf09242821520b97e928c32f093aedd8e670d8c42d3b764b0c40835b47f0bfa662a73dacc59586b3957ee03240a9a76f54a40dfa850b0d118de3a0c918b8225ea59c185a70497cc88be09902286ecdae4d086e010278167b890d2de4daf2d9b1d4e17c471e36149a2ce7ef7c99e507c179a2546e42bad3561ee28ee793fe3d969f6f8820a8eb0f6c388b39decf5fb5ae9581edb79b745be71ebca3846f32f6e0009fc1b358c239ab9cdde214fc5f88c4de99b4a4dcd805c73dd3c9ce17636448f3d235b86d1911e38aad910efe83511a30f2a563058cb2dea799780f7df53d023b25043c611ff611d284960c5f16516482071954bc27995b3ef54248ae2ac5744019b48f7d7f5bca1f3eee9c33cd97f680afac951585b656ece71dc8ef189f2a93d371755633337d03216fdc9fe8b9826f39daf75d8b970c2f8a139fb16f92a4992dc885aff2c46a0c621b95175b790e41c2ca680eb77b506c4f43fc5bacc7668e42c1ea792245100fd0673e615d35fd115d54f2ed16e9fecab074ff5fd8092f0e80d00a87aa3b702703a797e35fbf7c70bb9eee569bc0fb5e3c719443412c1e143bbdee8ca0564a22c4f8771636d1a23ba8052de62b2e46d2d1f72782a3e8e37ebc53bfe49c17e4cb60cfee64d605e0b30b8a4efe221394ef31d1a94604a4a5417f1b7b922dad4c99fdf5246ef6f0d61e7d6ae69b12cf3c155696c2a894ad2dac9af5cca08290e829f19c6bbbb896a856bdf15c6b48561aa3864de693b95a04c62698a5745bbb0b6dfd7a483ac0ebf8bf90ead4cef2f13f689005337d7da5d14c2e70d03cd9ed8c0f7e6751a2fc34ee911ef4ce23813ac6f187d618458932c33ab1ee313c89876f3078a7e1aded0eacdb2efcb534ea117263b914f980f4664f730a7a7dbd876c341bbcf758b3e6473311168247eb87b679f325bab63163da844e6fb0214ca0d30a6e5bc53db69f1fcc2aea7b5aa2b5aaeb534a5f047636729e281143ebe4d194b4b09d36dc44351cc637cb5b1c8ebf9d23ab0776a6dada68171b840e4c9f8a6973d7839be319f899f65ff072e279d843a11995ec1bef2d3ae851129a9233e8b0d219c96ddc3db54d5d55091c6f6a2f122ae3259f8b411c539e30c8339a70776c382dad11e7e798d43739150433021d6604b9b293ed0f66469033f946cf57a46192510c4a2869f0f5e34e794a5e4b506624aaa6f87d73b49b257ba6b589a58c97ebff59e32b0d8c7d5fb7dcabf209a20be282e166e57533344e2a803ed86fce9abd2e64505fac1784dcf3f2d7a071ffa8611d43b6fc56791c9d3caa9bc39bbf514e35ebfd8aaf888c1fcb34962f6fc4f4bfed90f7154c7c3d94567ec1fb777dccfdc1a5c7c2faaea58ed8e12e39a9d665311127505638bf33d3bd1eff6affdb3b7d432f9c0808648cc56105fba78cb55f70f50f9866ed13ec325ee51e442889790230d46144c23b8204eed8d2b995fac44c36a26c2c70019b71c8e328f03eb7cfee6b306bb768460751d8975fd04710321586752bd05bba64b7e738049b31b8c8e32092998c789b4191de21afe8241fdd12e2b14c8b814999deb26dbd5706a17024c31fc9847a46870a47d1c1aa39c0247f0a603b1fbf93fa3ab6ec2b54dc1187503571cf07fab67c7d474a7971aa47b0c9f43079ccc36d11431025342bb1266ea3e0e5972d0908ca8dd66bd101d4fb77ab67ef41e1d38e28ae9d6da7541d5375a60f6c8134a394bf56498e3cfe8ff711811d898554247366759eddc084a461fbaffb049e7d901ed3eef8e6187323fce4c6f63cf0527e0a01806b3118ef3bb943494ac0ef375c9d780009c752a60df558cb877bb63d0a160a53b4b7ce0b459d0a77ebfda2b3d03371a43f8be40d394ef986e9ba8c8221d0247240fe63910469a831c9ff82ecd0c79276fda54c04e435edc16d91c8af9a8f5b806a2e1b5beb21d7b4380a2e47f91c77bfdb668d995547c116ba60150f1d426580b3fb56243b8d09643c77002157b81556e5362bf71321295384d2fd0973fa261454f9ee49670f33f49ebb9595301584f2d21f77a882815241cf1a530556e69757eea31db67308ed9c963ec5dfc369a87f52e25c0fb81ab1620f09acfa0b14bed6d442ab6185d7e8fff0a5aba043705dbc105c86fddedecda3d7e5db327e9feb5de836dc91167bdaf3fb18e05daba80ba9cdfb0fb24cf3fdd568df95ba20b7162b96ad052f3a2916a2770cd5c2a4c4d1790eb9244b4fe331e8bc14405a4467ce9adb6d933fb9b7ba69edc8d7d08638106008723738e601783c094918baa3803bdbc21fdcba729fd07826e6bb2dfe0925dfb7c3387e25e7b62bc158ddbee614cba7dff8cf5f60b6ed6927d6228650c7529baeee7673a1d305d0ec54b6de2ef8968f2e612790f8a0e5194bb9448c71f5b63695c33cc2cb781c33da01fc048415fa2e242ecb7c84fe5f2cd8ce5e56dcb8e14b5c4353f8ac80dfbdd94e9530d0b3c5da0a2829b8782cb798eb21799a9de353593f7fddf1870619ed26af3484f1d578d7684d766a838a287d6bbdd7483e10a8020f64a91258b3084c4aabaf154735b50d681905768c9072d722fd25e4b125b2c9944e3140123eb8d2033e3ee57963db2d14d82123b9aec71889ca623bca101b5e742150cb9350ebd5830ef399b1f7d1841eae81779a84f613a7c144d6aad303314d3bddb888090e315991ea2ed127caa40728a674f9fddffbf1262c8d84edbac9d07bca59ff49aab9f2c6d71f5d04f392db1b8f81304f7cb3842072b16b71cf71f69d05511641f4f6e588aca56aa8de656ed2a20b9301fd4eac3f7924e6ca4159a0f46710ac0c307db86c00521f6abacc7cea86f7bb6bc5b6049bc7b2b56d2520a57590b4c866616758eeaf1618f757ad2176d92baba4451ec3c900d014583b5e0cb11fadd9ea904ce0126a7dd46facd0038980fea22a904cf89386156b0e94e0303162e85ab1151108604c653a45ad2cbaaa4bfb14c39c738febeb70c274723ee60b7c144e3e1d94b2cc6aa9195871a9c9fe60732bdcc6a636de4cf6cee5833aef8199912c533a1188bf2b7a70930a2ec3c8c8b7d465bf2a777db3ec056b7f3e5e06bfc473cf46a3068258f3662529223bf642e937d2eaa422126f1d806c6ddd24ccf171720ae5f583a71a67965f1839103f89611f1977487b9f7596a61099c543535db220c209bb9cd727ded954e5cdf553b3eacb3083da5100879d0047590e91d861f760ae30729ab7bd86a6d69299f9ae325f438a2659a37fd423492b858bf08d52b5c5efbc95c08a124138c0f1906f4ef07e2fa22678c7be0cf7258e5716c4ebdf9353c401154fd5a24d77b785e9cc1e90e2ccb7bac3e479077a4b1fe43df243ca03738f4ba1480ffe517b54ca19d6864cdbb6eedf9442070a921bd5796897bf1920a4d1612c18323e2d067ce001b6b6b1b157fb5eb74c0212a16449386e94cc611e289d27dbe176903c6544d1a93209a3a1c71c20d7dce2f760ec7bc46bd82dcf094cfca72be53316d4cb5bcb7827ee546937cf6f81d5c67e435b3e20504a80721e1e0954d849c3e73b7b486ccd10f85e59bc5246b7535a63c22c310b94f72de5c9ec55a258cdb122d7ae430a05710d8d44bbddfc956e59c50f94c1f3031f86936ec54cd8084e9a2134f0408f59a4523b9a4849a31aa3d379f631eeb802a371bfe82b605f11425d11a78be9e72573903593f0d2c79ddedd103e77007646f379ea7fddc382017a521492457e7f7eca8278931a76170e9efd4ff29f884c2dc17da7738925fd54a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
