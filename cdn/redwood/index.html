<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c92a409d7f79005b59a2be29fd4b94d837d4e17e41cda3e17b7975d8f35a5f8fe5fa2e675e3dddba80fc622931a016f6e58330b8e4354110e8a177859855accfa6096fa01b4458c90999841541c8fcf8e1413fe33e6a6c8125af4cd625669034d241b19a89433236ad94b3193819448c05aeddca0c067d298fc229c5b8cc8eed19f2fcb5c69920974ef4b8ddcdb8607e5e5852e7967f13a64409293c5bb86edc2f19487f89ec3e4bb4f26795376045f2f9e186341c9d3f34416665103358767e1eddf67eec9f5a42d979c5198e91383bd9ed261d1badcc39909dede6e863d990a3bfe7049ec73f7b228a57b8b0a4aca863842c2c111b8863e4354d76220aa9c84a1d602e686b74e3435ad5ab5f1b43b7ac07d215e78bf6c58babf42fecddc5a219882ba2b92af98ec7ad47a4273d6ad33762a7467ab4b529f2926aa3d0b412d82252d356839bae8f5ce6826d93b74eb7da5212c22962e07f7cc39494f919495e089eb6797514bbf416da36393a544df90dd609e17f931af6581b1084b0d47ae0f05cf103361f4e0de75f7d789fec081714639c1563bb1a8eb2e3daad9bb22e13f7708c14919e457444be673ef9b876e72e68e237d44c95ccfd38af47a4f288c8e43153d8c645126dbbabb6a02d87223f8d1084b5f97db6677871e227adb32c38ac75650f591f1741dd98f9e9ad49d685265c5f03025460c302fad3650ac176b436f8d37e23288cacf929e33218567cf9c06eff5ab2bcdaf43a4a47897a5618e16032eeb3e16a6481cd7b696215ba9f88a816514d1ccfbb3c322668469868836a78875c61d78c248bbae475d7ff4d2fc8d4c89afcaece47a7c4b868972f00bce936760156b5959bba0082d832e1889533a2cb27a61b246a775a4b19b0980b74312698034f538557d9ac5d43c0fc98bb28a9fe06fba6b0f65c900e77f9f847be5ae567cda61715d613637f5657b90f8074a49d9793c63de0426183ca26036b52cf59e4001ee46dcc0e9f63545ec557ce14c8b087108602c8f3b33576695f8ef25434acf37b49d3fc3825c40135ece440bbcc8d8fda61656273630baf72d0a33ac411c839ef73a10265002fa9f8a81e625ff6bf450bc2fcd96eb05e944f65eabc8839a89598ea6ade84954845413e757c7a1055ea685ea0b7174295b23d9cee3e2997d18d3ce4b0740c641a375283f70dbf51ecba94737c68276c3c5ded1ed4f0fa3fee9a5cdabfa0d6dbcc785232b9932afb2fdf6c49c7c252eec89b3d63fe1a04c5e28cf09713d75e413a320b11fe770be617623b6cf826b33dbfdd35c5b24b9d879ab6ca16ebe944b847f6af4951d07211ea2f4c33e7e06da1050a2565826f25a16ce95f5dd1b885e66fd2cf758602815e733ee1e50e2298e3f25b2568051e43fa1e06b34e6e074bc81a4c307366a6e229b8714fc3228aa62f4081687b6228375209be1f4a85b0d5872c261b42861d6b092485c10403508114b5ed64b66f8d292a8b352b1bc2d1f896d6e3eb256fa138c4a1292c4ce45e09bebd01e83878e2e973ab9577a9f66c0be1f9a7e07c7c60268b892efbbd09583747bb3af09e2ed896b3b42e476d9e3991ae24c9948d8dd27f33a59c2f9e244a63e91726e297db8ecff245fd68e76beecae97d684d333a505022aa49cafe9b394536770555eaea00cb78f58c39fef9f5315cc15a4ea4ff4c3d9f4dee93914edcb8369f11a4698038c853a3dfefb110b9c054670f8774b8b06f54b63d3cde34f99aa8cdb3f1f231209006b79d2c47f46113973ff02490ba415f380ef5cefde67f1c3072d9c7be52ef2edfab334beca4d9e5d624455b8694adfb9410d9d09849f00453908ad0fdb946988616c6b51a9c28bfaa974dc9b7dc10ad2fe28623d7d5317e2c9be6a71a512fa005830d9b9463cd10a11bd9479a8efc53ae85f12cb05c4d337257fc93957e943286be4df73b19f9179175adf9428cfbab96bd12f34d4d3a1a50e322347b8deec57aa28157520cc843069ebaf07d3729ff02d1d1d9d0dad459aaeb466e5bfb5be97bd502cc312d680b6debfb95812754f468e653342ea38360fd7f7e57d780feaab91d2d9587d7a985e7a3ca56bdc7ee66a8cb0328a41462b443db5d9539ab15865b5282b6e5a22747f82fe4e6b20d26004c7081cc7a8761de5ea9613da8b108b11d6180844c499f3eed1e8887f181a079583b5d61eea7b3c69a564c08617d876633efcf587f4df16ab962d4ccb2a5c0c396cf21bdfef0f48ed2b77d8a9e041dd69fad87ff12b4ad05ee876be9f9dc2628609d51d6fb0251ca5397af309f99b0a95aa05ca7cea4749a8dfb5e97a737ad0cbd5dba9eb2f5fa7fb33de51dd967564a675da1f60de15faba3b7f7cb45f65f5afe8420a8de29ecefdf6a8f01bead72e79266cfb418c9921768b4f9ef85c8f750938ef34aafa1feaae2c73291071fa46e5cb774c89efacf76c96271531ba97b9835198979828facb9913d1cb24b9462a6895362e4f1b782b6a2ffe157b261842974d3bec809391d5409234cef454635ce849da186f42e65f76368912bbe3fe8f9c0097cbe96fbb557bbf72a5b2d64ddab87efb4da63e0ca8cba25f987d037666ef217595976aebe3f7dc4a7730238bee612ae5a6c0aa170a248d32f7dae6cd4b208e19b6e9a4fa79b507088181265a46d02ae5e3dd2797489ab121805ed7d533c12699ff808016c96d50abe5a379f57ee259d78422ca6f3112a10a2b1e80a8d594027171da3911d84c152275b877fbe8d5ec74ce55c5d16b7be9959b239c023c977e8e58089c168c750965577acc4ff26b919e59671b2fdd4d941894d7fb54482ec11c6ddbe8f7423fe8b6e1c525871e08a0127a923c7646ed5f512cd6f6bdbf7a03ac6c0d71ecd8307b8135220c2089bf49c8a652a39f360c5f868fda52a8d1fd78d53e6a1fe06cd78fa055c1c064bc543cdf94004514fd358811f3df5b4aff0c882ec9d1fc535e1a18193e51a6a6dbc62e0c2c6074da8b1fcf782453c02e401b7fad455bb02d01c7f9eec5f63108fe4dee028c812cedf3307249424d6682c4ae9a993cb9053ee8967c701337668a23e513df86905d4f31b602911944fad3dadbfb5702d592ec73ae92c7b202696465f5dea7a5a84107a1d538937e280774f7ab739c3a1454f2ba12a71a5c099a2e0c6c6271101a62999c7f59a983f7f082b2d933286512807cddc5c15776ef8e089243e65d32ae663c9b7ac7ba42108933e765e183196b874387db82d78bc44e49c5e595e95d1469e3a444dfd46ab951f1fdd5c076b260fc5838f2e4c091b084883db3e79fc89156acb31949b25dcfacf32a1e6f6f1d420d334a0516fee64284b49b5086eaac4de53682444a990c7ced66e45fefe0c992234f3956ff7dc33bfb9943d0cc969e9075e5b4e4cb8a62dde63a9ed15a001594910b5d2800f7cfc36cf8cef89e3bb3d7c25891ad510284a81e2d0007f3984c52306a8d3bf3866ee0ef0e3e00daafbcda29965511b4596db133bed9f89fdc472e7d9d0fc58fa64d24d5d1ae020b418c3f7eff992c0f79e715c17f19a867b71417ea7614d8a59638869bd2e3e45cc24e1842df90caef1f7bcd68e1631ef75004656f3abb8aea42c90df83cdfa6aa3ad6c7d1dba1b0c823f6b8e39fd85c0ffa753a9c472d53d189e86a9d0eb99ecd9056523f1255ba21a5d4b576a4798bd1f77b862331c150825f09efe8ed3e44e27978744d3794eb5909fb89f50bf4764d91691692c5f2122483bcdfbef8e5debe7d0bb5a6367f2569d8ba9fe17711aa5edc06e8492811789e8ea2e25ec36ad524c37d9f79d7ee541835d8a80622762d245418bed3db41a3c4cadf1a65490f8dcbf4b672a5d460c949791d2b3f70b668ad25ab00431a96ecd95824ed36dc1127c6c7aafa150180142204d41f2e639eceea068d71e2984a12b45edcbaa376ad6f025d698900f90484ded59d4aae749a4e10e0fd0187183fca8ebc42fcc94d67a513626aef26d96a0ab42939f67e8a68bb00a51c6df9759192f006453cd53d07c0f8f1123b6cba84c3d5bf789e88c9dcc8b1ffd462cd1af57825e4e517cdcbd9111cce70fe1281f24bc4d54f0ad98ec30c4d2921900d084018c4ca58f32c0c6b55518b49332a78346f04b1a7cdc0fbe7ffc75d7414806986cfff2a832ba2b4c96dce43c65e5c12f09b7a68b79794d3637c4b8db36ffbad1d53fc2c563593efe8b4705c304b1ef531e42e71e5ada75775ab43500355b19b91894fd6a126dd04ab2424ece091118d8ff128b8dd63a9b5cf0893a0aaabb921852f22725fb405bb9ed0d2cbb1f6b977e6e765d1ec7bd187ef2dae3d35d43179f1a1416989f98d671689e1744fe48f4f737223cd3e02fe5e930f8a5a745684fdf3094a08aa92783f2d654ce687703a7c1178e3407842c5378e9e5f4ae17e20b8f4c98968018229a8fd9cefe6ab1a3cd316d1cb779d81b0cd7bef199c168583793cfcb590a7b504d901a7f609aeec4079a3ff867cffa31c7e62d584466c5be82b50975786a9758705ac971efc84b31650697486a493b72c67f52ab7aa0fe194385957b092ccc83ab0d440017d04bd8024dc3536891aa565a2167a7cc078543ba41776855945d0bb9c7e671b52ccc31db704219c3a437c86dceff96afbd4f869035bb9c701048a2053b9b8b03e68a0dd0421b146143a074fb790f40964c21f6e0c42cd8e6bdeaacf607ed3d6eb6eb89a8a8f59d900e7a41b59f2165150cc392d0917982322e3beb5fb011ea3c40bec2695e63e655a53936464f9ce37ae6331ead09b16ee5a75c7071faa556ec38dc730a4ae73e22daafa48ae205d90ab192ec98410ef91b0b922ac068181867ed864aaa69620dbc91f5e0c82c13a28bd6ceb4f3dbead3c6ec30b83cdfd4f6f175a99012c68fa667a86bd77ce69b16674f493ce0379e8d2e5faa351e0f22b545751f4ec021e11ccf9014214fcea5e0071dba3f073d1d39db19f4f85cd5029eb5cbc2980d0ca97d2e1ca8db85609de608459275959af8d13520165edc268baa232539abe766af832db76c3b8420ea876337cbe266f4b407bc67ba7870d277dbc06eb0d1c1743e8faefec707af548d36d9c1e34a96b3046589bc6f8cd1b9b7c7d287d72f990579ad5e075fe68435f2f12206f748ea4c1ad762ae6739b2672b36c2c2288820a662b30c9006f1bd6a49cf539a8a335ec3f11d88e47379535b25dae4d1086f9b7b4922f75d03e92e9a3f8ae93ec7b495d16113d57556616cbddd929486986a7b6ddb7eba40cb148f73a36374206dda6670c49dc9a99b326309c28329cbd396448c82fc27ac49707dceb05f0bff5e6700e9beea21c9cbc9c6ee9133b097d173a6d95a4426ec0f7b1e8f4d2399ac1f16978d305cadc2cd3f056bf5b464542a112cb68110648b4d2ff10bc55c39e180dda5804ee77ce22036075fd5e28c948b944321f9a1171506b186c4510137911d7ceda1bd49443c31feda03569c4d8fdf9f479eba0ae9d2f2a78064c174df277f438b8d72ff16f78ad1840f44069dc9ae9307e4a1e87debd82b5f61c02ad78f760d28c78228b568dc8e58a8f1644c927740a446d3752d192e741542a927863ed83be99d3d7a01b91bc70fa2a46070d17bac18be81237627d96ed3661db1721c836f18d44e5ce6fa3c3fdbe4c1a42fa9f37a8790c5e2fa6307727a8563b190154d1efd7bbcb3f22bdf46ae322b4cdf8c40933c7215bbcc93607d710079437eca486dc8c5adbc5f7ba1e857acc870124230037eeda11a1ae0d1df3114c8c4f937d46d3d92f271b0b6ed3757517e5eb684ba1a62cb1015876e5c76f86ad01f836d6b0dcbe9ef2372b65d42d645e95b3b457d9d34614f2c933f1a7a65ef99452e7bfc43614066ec82556dfe8af9b3c73c6f837cd275d26f6f2c0e2f1540d55d3968012c9a482dbaf8ab0ac270eeb27161cea5e9280ba4b34a2c5abf52087413ede6d5ee6fb414532130feb10dd21b46672a59790b43011f51113ceed340d4b68e41cfdd6f400928dd8017552ca796703b47cf1d43575daa921555440ca5fecfab2095f2d574b30b83743ff2caaa8cb99f035d9850bc7c043919c22c185237e590b148f7e1c5cb8387969f0140200b95739d68f22a1c9f0f05d649f8a07c3033f03870390b295dcb8f239faa237b224b5f4397be0e982961a0f6b3c47cbf740713755306072b44c9611302f9aae47efac603f49a271c687dece6713702d3571915aac21c2bcd8b48285a4c1e13da4f1071d31a92090daf23c5089f49530254c5b34ccd59d6a034f051ddb3caced5b4f006e9614f64c3c20b400c297de80213b47c28bad064e226bf6de6b36fa940ae1b4d5b5e38e447edc45a4eb4803ea71ff92828b095a2f7d194fb09427d86eda32e76d40c5bf9d60e45e0067d4909315341d6a8e2933bba91ca60579014ab8def0b0f3d991ffe3095f37e57561674d86fdcb14cb9ad1bac6a3892c4e279ae5cca0deea6fdae6983bf37880a74a540a620fc7744acb4de3471cd5444b129879a19a5bec998185f07a62a49bd0846495255e2193482c59b7e29f54a4d9f35cb1e7d212cc8960aa283875da19c2fa604688c1071caa05be6e4c94f0c87ddf8f0941eb8e43f7c873583548fd54a11c962b652e024d4381369cbf32c096a914360cd14e91e1935ca21d736bbcc5d86074d2aaf213a8d205112572ad9aaad79c101bc262e9bd19a096872298c2e8ce2f2c9ad834632f0572de830f6550b4568bea48d62d3265ec1e07a3497c80239fd738afb5f929f69099fe7002b1173c9b6173bac6d861dd96635f66f93f93954dd1e43a6bbf6b31d0b6a3742ead1ce255c072b14917811ae5f54e930572116754bf30031131c31ff611ce13024989050bdfc32c18ab0fa5017af422cd58713e287f6b077e9a3a979753e5fd1824dc1c822e29f945e5d00d5582570c91b3b5b26decc77fb98e4a3bc9f4867457f37533ae24f7fd2bfed91528af03ff134efe17dde7995cf65918503b8107a95f9beb20cb15ddb9593a50d09586f10b1e08940b69458155c242a553b268b61d26fed251a8efac788dc738cd83520308692b5b2ec935a989bfa7f817c2d5b64e9e912f981c890b490ea4adce48697e2286db4b07069fbeed65ce5441d50e8cd7c417eba5c4eca91a47e5b66e34be0f6060e3029c3578ec8904e463cbca68e168e860d829b64b465d1784376957e14012a4e96fc5923f641ec5c4fd15ef8d1bea5714739adf1c9d088fe82d559b97ab50b9bac6816af105179836b0c14abec53b9dda9afce992e4017fa3d21d025d5a992a891861667e517e13d65d545b66b1d058983b3814512de903168dd93f01759947d14ba5285474e2720afd683df038a4527587262e6f53275a254dbce577e2333bf58be92769aa8e227ea5686f044b4d9777913e91a8597014c9c43f6d76ab3a063445e2cee1ed8a756db793c05f625f8d0e93240aeba8882598a888bc77cbbc6f88a25edf1ab6392d5e81012144ba6e115aeb77ac060fa34ca58ac0cdf96e7c4cbe74b80c081ca300d200cb7f822dfce85aebcdf7ca024d6d6c59ea569463da4cf4c433f744a348641d8fa39deb462a69d3a50d844cb3722bfbdf0f0f68f3b5fe011e4c716a2300a16e2e244268e57cc4b69f54f1cb2ea4e0070889750f1c6a489b5e03c0d51ccaac937a20512edde3e4141fc11122c458a12ffb6f0d790923a09fb55cb729a8a682a6d8da71af3fb95ec47ed1c68e5c17dc0122f9b0bf9ca06c0a8f6d2b1bcea4e2c7a0c409f094a34aca8196f376f9792f76a25d7a6e285bbd28a427ef48fd9531003d4525e373517f8f762b21fdede92169632bad79026680fe64382929e8241d630803a21f1fbb39e150bb4444b24e5e5e00fab6a94405df3c642b0e2c338ea39fe016bdc0324794db93f8e3ad157572becc1e619bc351256841c04a3018ab1f1cee3693cceff6d80aea63d5aa834251d63776a26dfbeec2fe8ec90ddd3fee9de2a07788bfe60d6c99aca074f15290709ba9c34185007c1acacad2a25bfc661eedb6a06c1f716e523622e7bda029ec65f4477ea9fd7064b552dbe2b64b37f2597648f0e8a9a6ef2fcca5ea2d32fad4ae19935a3f3a9ea59ee8724b3af0b8adcd427e7b583be6e30909a3ff13f15eb788e612184f345b71c351a4b7e8a07ea65ff9abd2d392c1e209b677e2cd2a862f5d2bede6d18dc01510acc653f5ddd638a084129651988580d21538fb610cbcbdbb41fbcba153a6c3060e953d4efb815a317aa19db71203df011dd9d5f0cb194da224faf75f153db1201877def143ca7c117b20134043142500770bfd861abb95a7ed809290e3cc59e6cfbc86d4631b87038adee2a02cb01e844edfb28f04b26c40c49e856da1c7ef9e43955edfc17c13bf9643d306c32f9fbafeed1c3bf1b3c556b4f55648f3b1f42c6545be01f09fe6368ed94c80fdd91bf05304fcdd5285fc1c02e72321c4563c46afdeb18bc2c7c506a4d095ca9fd976e194ff4c7b20215b954d4937d80bcbfad75eaf86c1de28f7f6cf1a832bfff721e55f44ba50e0c29452ad9a9bbf25f615ac890769f1816f95bdff162d3ff122e1d8902e41a9bd22ce17129903f674c39e73e048d417792576edd34c0f20c4cf527be5a86c9bfcb1b0a4821d99ae46849019a898025866bc7e2b91a4b73e6bc1b03ae35897c134ba0225a5521c0a047e670543a23f21d79a3a3f1a8aaf0ef985b6b7d029e811af6dbade52741ccc33f902764a3528054caa4fd3aaf2206b5a717c2b2d8f5af82360d8d7cb3c91222d5fd68d5e8a83b9f1da639bbba25c7c4065dc6c9eece30ffe2a06a79bf77d91b6d2f74be4f531ea795cd1748e9041be02de9c1591fe16458562a11d12f78a94a32c31e097f9197ee759acab6c337354f15a67394b1b9ffbfddf6a20b64a2a0f7888037e82e37c99c37ae7f5db315f88e39fd7ea389158fc5b4e53b41b78f826597f1f9696614047555f8c3aefbaaee2e419e464a90f88f70367cd7e885fbb6c873b09677dd9557f3b11737eb8a5e51bd64865ea7514963ff60981814299b94a83edec5daa49033e4c2eeb6f5538c8de644b819f089248b87959c9e554e109aaf0b68692ff38e8d6ef6965b8506a200475f12049241687b5667c40d3cc68f0ece0e039e2d7b42aed1c9cffc42bfac906258e441832b2f97079b1fa38142c7041543499b779f5b33177f2d96ed16e011f0e7aaf52918ddc559ba971964466b199ac241e8c0c8700f7a35daa0834a686c090b21b7e73353e8496e54b38c3e0abb15fc036d30b71c465846e0fd21c57b3af4e59c74d1f97bf230ca8569655a44414e31fe629e1eb1333b3f29463b1a3912114da8c626eb9d0627cec99c77e35fba6d7dbd689c3f143de49d5927d9852c619a676e848a5fec40500a39898373c73dd924ff44d06b01b6386b12ea12bce42fb639b3c30244d9f265e5ab1786c8c54f6725396dff4764dbb1ebdd130246c922dd7e6e247156078a51bb0cf07ed76cfaca67c0025345f43ce9c08d7903566f2fac35cbdea2bd6927daa4069ed2b57100444a3ce4e09fe352b52d255a7ec7f0e4c7ed065b106cacacbbb4cddbbf4b2ebd580c826ecee6d8b6191d6428a0929fd9a2fb57fc8655ae12559b845a1d76e11896c06a91463f016e8743099a012b4961a9a0c1ba5664e22cbd0fb75c1b761023e7ac588f8521449e185347cfabc8326999620464db8009fb090850e0eff5965972282dbd909a80ceffb24b7d43ced32d7d2b8d090ede4443a59628601a7887fc43af8e714d0c2ed336dc287c57c13d24ce4d212aee65bb07c6ba13bf9cc102869a7891b631314c36bd6bf9c3397a3bef686c6c4faa6ddb133941ba14664aa12fac6a61f3bef6badbfff4792483d97e5a5fa045b5af9346c31892bb8fce1aeaf4246fdb6e754d9eadf5f9e93f91531df8b3f35b22a50e56e7425e70acdbce6ab65e669a1da56fd9d389bef649ed8a479a99a7ad9b7ccc63b0fccea79666c68015f4178ff045e1403c0807b7dc25a70bf3bb07be99009fb0f15fc77487b4b42b97ed6f32cf03e5dc48f6add27f5abc79d3072ba6c804b58be213056c7b0557f8f628d603edda405774a7526ecd4e0d4bd8e9e9b4d1b4bc458e09b8d32e7abd2ade819c041f46b1c6f1f622cba8694ddc75313f4e519e7f764f0f1a7462439a259a2c12b2490a584897e473d37af8d1ab5fc7c8a4a491db608f1a57243985266f237cf4f5f49163e8d5d10140a4b0392d360b5c8ebcc0f91d7f78f93d5c029493285b085a0bcf17dc34680c67a9eca8fd655facd2e1b71de100ee2a4a3e1fe81b7b76c7f34317ac4dc0424ab081d68df1891762888af2683c2068a9887b196ac35028cd834ea24e6fccbee2fed69367911dde18406bf9fb6a912a1a7b835c7723e333ddd436fcb7c9d56a300977974b58fcef046f50d95252ea228bf31a629e157f7b3af781a6ecba87234f6106e3c12ca73e4fdeeab4216b96549353b3da8c3dc487eb1a85366f4cfcb5fa481d99f7da88a6bfcb1705b88d478486aaa67f18b89f7b6e96cd4a74312433ea827a48b21d52453ffc4f5de8bd45bfa18f024472dcef7b2d60c71c62a279048c9e8c821d56b5782f79048ccc13174d8510245d84e81383affd796d2dd687c621f0dce207ae7f74ec4baef3a5b7ef1b5a6052cc5122125a34a73c26b8efc1890b7deb972089da035a56cded1bdab641af584b1d946e5687dfd079303bf40dd644daf23de4ba82ce7e3094b154536131a22c77180c4fd7dcaf345b1314f186ad33e21446ae9f060e25635241d74cb2bab33759f9ca4b907e67a16669effd32db62180b8f776609e453e53eb38b01e2ef058577cc9531429b0517225a458e2290c27df2c05cfeda9bc18a2adade1a88e061f08c29dc61cdbc9710548c3876aead1abe9378d6ede243aa50726685459487f85bb903a2ffabffac4fe038d73acac2f382f2d8779c9819a55e84c09fb8d319ae15c778fa08b6da03a84627655e656a08df5d69aa1dde210b286e78d9e027dfdb40f9e33d1e7299eb0f3618dbec1de184f938e48f4b486e055165ecfc30a9569c516c3a7fb8d4b05a07820beca6156e6d2427106f3a7f487ec92bd81f2f44a65ae626979d9c20e583000e59fce0930c6ca604afd9e6cb8937af1c60c80b26a3f08577d8f57378d4a9aa0d6d640803166cc4382496136cda645b7130c8c0a8f8f71af0ee273f6cb4b0da914a054fa75ccc8c1855b8a9273ea1f4e9187ccd6ae97b38dd3110c00340d316bd3323ca890b312731a36a3213b9574db9cd15fb04a03541a7e40b5d1715ca3ca816fc695dd88a6b845865093b54975ba2da7c51b7bc8f309eaa669a9b0a506fdca3eecad709043bd9413a2ab19f8e104a1df91f70ad16d25f87b501078751ce2d35f0df88201687069482cdd310b34e983bc0081daf2490237d18dd35b9dd88450b8883ddb92e145201f708d939186aac1ded503657d6b28efffc75232c628dc09fdb45a151927132919ec8e170df9097b4efa1b2ab8a173f6c0c965eb15eda358f9b7ebd89aad462a8afac2910aa63b8675d4b8a4272673bb12447e64be74a9e4eb26372b4ce7c57182e786c894d7e50ecb51efb79e68bbfeb46466c9e227f438bfdd0e4111b6d9bd9192f5c8ef4012a9b6681a40dfc6b6189aa4deb02d14d428cde1f87f3f69613f92fd2bc4460e4e4c32bd66834022492617d9695c6e98279279504e963250c2a9a440aa9bcfab9013d50668a633fee3eef4519732ec809a4509d1957f01ff6caee6084960cf3cb842a378454d2df39e4e739071ae74ede81a3177a59a5a873673647f486a919d6cd800aee91a56264b558a427b50af4e2e662eb4eff0250c8e6326346b8b1f9b1b3419187284a89965d22c01b142302df3dd20ee71c34361aad1f2cf496e4971cacc89cb438ce5b338594a69eb810003cf22c4c1f122497e36a5b6289705db2742fde2523a29edc9b08612a2dacca4f26b2f57b4c7a5ca997d3bebf93da554d9ef85c8eeb1f94f4bae83a96b5955ee9de010821c5447a63e0315cd63152d500c77544f851d869998d2451b2956baf4ee5f33eb27df24134361a480d3786573eea06d76214eee8bac45353f21b0a63cd9b52ce71b9edb080cd3f8fb626131aee9a953e96576fab907659f6cd8c8a0d2ed42a898bbf884ce32bfef735e89a9c54084899510d1b71e3d0965489ae666f02b4642aeb164ce2fe8c8c797f8fcfd71704c244a46f8c2b1208ac2081eefb17cdf7dc893975c2a42448c780c7e9fac7dc36a5d4576dfc799996486edc6e999c01f841793ee6c2cd37a96eecd268022bccf83b9c3c5498b36b0f4b9fda62c7e9e2d280ec4382afc0ee699897a9083423b916cfe3182538a467d1e96f49962da7b9fe5a878fb1e88f1ab7ec17a1d6bbd810ec7a6edc1c11d80b5fabb1a3412cc8b4931bff32461adf013ec7142891bcd65b8e319bb14058d2534b3f0ddd5e5121a34065bb4cf22fadb0b8c6137576cee7f51e5e5ab4ad46334c196fc96c2e162dad19782832af708d9223d05e75b10b502375cf5c134b4ca708afa6d1e5b9f82c6661f61722bbf0576952e8a7a98c4dfe1857965eef176f6661b830e833f906f2be67860018f7f9e0e687f2d62fe6704064a8cf6cabafad5ffdf4a40141636f2fbcad85df228f80483d5102664f52a5f0671115bf705ef05efe73e57f2eca6b2fbdf4fb6a8923efd43acdf72f10877b18ed1ecea8c094837f35469b869b994f82bf0f3c49a2c664b0a9864b5c40666c59b15e565e645b000dd08ca9fab12941be769661154887fe19009b76b2ec2feab7a9ba2d0356ccfb3f9b25366b9a28790210bd97f74cb888a15482073abfe46c26d62490e83ad6a18f8dabbb7792a9937b1139490a83966706e7bfc0bc85bac95e44115d66fde6d99fb41b1c7c82f7c9d90d41cad0d38e895ef434f00ec4c69b2cf88f205f01a2d11a4a23acf716ed83f6863908485113268b3390b905646e85dbe73463375e1fa18a16ab3f5f60113286ab10c5ca2ce080bfc0e609c15b4e0411a3d156fe2e953eab3542ac00a618bb4c51a18b66ce22ac0510ada374f65b79041f8716438bb561174404c6a35ac4751596ce9ced82b317d36f5eef98ae6fa007d9d2ffba6a7db88640703b5a5a6dc73f5b3665a03c7cc34f677e4483fd25e7fb268e166f45a019a080fac18c9bd00d61d5281afd103786e76b92f11056466afd616d4799d608accacaefea478d8560e93677289262465b69f3c24983d0430101e634b944e95e0c4100c18f34a301e0d1f4508f0a4b9b55dabfd6f95908336d12befee3a65a2d019ec1ce122bffd4ae8883b5c3d56b7b02a509bab0bdf7be022e34351374bc604730beaa1800ffe92cca59ddd120a887a6a9de2aaf50509babd1a07049f4f09272e2b9828a4be6cdeeee54c9c741350517f417bb0255909b7b612959f6d6f45d03bb14556cf04fe8372d53414834aad7ab2d79968ca4bcb57a10924b2bdebc03a7fdb3033e43b74756b8a37eaae84b7cf1f48543a41a24175555ec6193bd594edd5258e8ebd1445a647c01ddf7e6e11a9d11a31f78b6ed3ff3f354e732290673082d66af370e28f4b1402dbb3b905df5b8626dcfa3b7f59bc54a662f808efea2e33abedb99f40c47462c77df6cbf5fb0cc17b12de2c914adfa7d9698c8615849ac9d8800881e57ffb185c6997e5e549e088457be85d052abbe1827399e59b151a0d40fefa71f632d7e23302e7ab73f5c980b8b1c6818bfa3104a5f2685bc02c35c4a52f95ef5761bd0a456c538345fdfcaf387349e2cb3fff7ce922759ec36362301ce59047dbd3e14f51544e90f7c9344a62eef077708109a02c3a1051c6b41213fb140e09b0e305b1b46208abe976f6b26de9366b3c929c49f385029933f98d8aa574712c16ef5c4475654192ff501b24a7ee200bb0c274340872a779fed8e3e887ce9183896f703b82a59b561335c49b44bea1234e7d3ee3c26f7b425773fe3daf3cdbe61bd6e776fe17301a5d18ca550fbb9014b2cb582e907e97e9a7af20594e26e900d041e06c510738aa611cdb692a38b4cdd6f0ad6a06e8ce32cc67d5c869611c5002418dbd3b9a868592310039ee03704ff94045ea84ad8451278bd3dd348337f65b8853baad529cdbd68c70068ac55c31cdd947054395621c84bfd8a8b3695992d9a1bee8d55a8ada45481af24f5c24561d94c5256b804e1bfc0233177fc9c49917e6652b6152b6a224659feea23e1e1c8fb98da37411c6c6890ea812f051cbb5759d166cf540d5be9bf1a4be9ac9b9bf18b9c428104e5b49043b547eb9766a3daf541b394312d116d330dbc06dcbd1fa36ba5d3efc035aafdbbf019fbaf93fa8586a26f25562d6f3cc21e61e7ee5903e66598498419d18c23804618480b0955f2b9f89427f79d06632301124533d45a02b8b71fd7688d55dec4e18004e4203e225a84c88d33d2baf40c0ba0e1e343205b45f52bc0400e19f7b198e22105db9f706a58853c313bcc08517899cf4cacdbc75a9b47913d5ba5a31267b65db39321d286724b97410fb0045ff370a9a5e25393f50fdca658ff12928bd63376594299f6738b48fb0d369cd2f726495a6f0e77f8bf81fa6091a70f1524b27f6e66ec712248d403f5e14a03fddaacc01428f5c044082dee2d430cf830f42ca2c20fd415e1adb73df2bbd779edf41412fc6b4c9ff5f72fc2f9b0f3bb079d4f3bfe9838535f0eecb8c0ccde931133d56212ef3dcea9004b9d3c69a3c133dec915122820987a97ce30dd9642e6714a31b647ad285b360f857330c90850571723c3406f664e73c21c589a0d353568b28c655a576161364acc103b91997e07e4488d0f21824957658b77979b72316c71ece691071acf889a3a38fabfb3aa29c36305170a80476b05bc821b7806d1413d1bc9a18f8c78b4fe2d98de9f039f43b75ddcbd54befb98c434916367f940a311caefa77820f427b39d67760d8a1abec865b3d638bc5992be9b0d9534d1812e5de2b6c968f2767c7db946a221a197c94a4b65a37ffcbec3e809a5cecae845b4732e095cae354a650b2a75328d0744cead294944f912e4e877597384812d1c4d847f79df09e0908fcae1f7a931cf60d408949831cc9580dfd692ca007e276b1a94634c907f3926f56146927a7333178db60b67c214e315969c62e1266106b6882861b217fd927b888a65b63ab8b327953c596d7a9211ba99ac9b66cde8bbca5f60a9c2f151784fb313a642113ce3b7e7ecbe70b9350ddb15b457ce0f620b30ca3b10bca4efa8e7903ac631f7d9cfb6a7fb04539fcf76dd364b11c4f494ae12af8b624945b190bf3c92f141c2cf73a3c378e8c5973ec4103525f65fc942417727a31dd43bbaa01a472176f0dc07451f1d051e8fe081797f054c314e8e0c20b221debfa80f4230e3ba5e7d1581deabe6643e8a8d91a1fc4f140ee00f3fbb8aac2b404fd1027452d07a6cc84ac765838219c638c0bc70d2eb1274b874c57d7e5e9dcdbe02264b89e80f7e3c03c7b2b4bdfbfc89942dae45c2e298810e61621aaabd710839aa2b06dca93e86313d1d2485a2ed096523e7baf75c8bec1f8dc98e0979b0db3db4354c5f42e73dd4239025c06995b0256d0076d418d1898672e009a67995dfbfc24054b8583f20047b503c9e37e77a8ced8c39206ebd165579d0f5a95146255c61a0e09ef3e95e063cc93a6d0d1808eac7b6280511fbfceaaae87671d68a7d9bf06f28e4e12fb4b899643209977fdb91726eb5505f78bdd3c62f2ba6295fde33700832ea3152b041d2b4cace8b3974361ca6862f7eee707749818a5e1948519e59bb5c5bf7c9af7eafb60a6d4c1d80f1731758f90543ef0c8f1fa78407380922c5d946c36dd51f77171603fb483b7956496282bfd3eed31ef773287efdcf9fadb11bd7e0a656b37a8dc299ea57d5b00a1f910f87d52199bee5a9040bc6b2deb9fa5294f289e8d8ddf2d6baeae1f01d779e9eea0601e1f73923d45451eac8b05959bbf52b4cc8fb412fa20c9560a2ed39735f77fbb45b3c6b907bf72f680d2a7e92cc0fc746f24643f8d6e58c6cc0b47097ff55277f47524fe7904dea799745d817d65b8d7d072c4a3da70569a3a900c36b9383a4c1a4f2aeb69ae346c8343d9a43f7719f886f43c7cb129df3deca6e396ac4fc8312725370c586b5b97d054927b46bd6584fbcd5d5d08ea62dddb7f59231d8133b25f4b64dafcc5b60a8fdc38101c32d9e65fd192a126bad488691dc3119bf1b0ba310ca7a58b5d15c331c9c019a1abd2c1fdbd09836795a17c8d6cef483cdf4a7b2b1cc0438da6a15cc4b87273c48cb99d1a7773b6db2fc04cc83cd7ce9b7faffc3d86595c9c872628e1dcb9318d8e0ac692ea535247f49431b40b5c44ef1a98dbd0c67b753b20ae3b3529d0d6fe5137148ab55ef39d599272a6155f60a3dd64e9fbcc30848e599b152974ff11d771ff29c2769bb774a627aab31ff581c802afb332deb1371a5db5a7fc1dbed0f13430901de2d1d225f0c6a4ae119d2afb2bc6b65681790d46548c3f018fa481eef7a67593147383fcc3e5c1425e458f3e6ffe13064c68d834ed0930238dc0bd93e256a709ca2bf613306f576a3375a930b01c7faa557062896f9b3377bddd9ee71ea6ed8b067e785e9b99739231ad8f6058b71cba8ea078165a23aee87c52a816ccdd151702838f23c71d6ffe95d026164d01cbfe7412223c2d4a4b57e12bbcbd5ad2c947ccef49898b1501f225638c0b585f99e55dedc229a106430cc52ee23b4e1cba550056060a2fa032ee82814323071dca60f810893a921ca8854f46a9d7a921a845ff8ed01e68a388c2e82622096feb730db0efa337884d5eb284ca92c0d8506432622c78a4d808f2263bc7eb5a60d28248f11baa8e6092700a759d976c174ba6b177c4473fdb95c9bed9d10a33081c1d0459f1f0c0540fc6e79acc1fa5f4b5f87d3f85635d7a7cfffa4e3fd11b98f6bfda23f0282c3cbe9e4442fc8ec22e0de1ae5ea6ea4a7ddbc6e8dc4440e755fb42cbc261b7247465ac22703054152292dfec5f7891fef2afbdeed0f809ec78287d112b4369a68a927734a2e1f5c409a2e2932b6a12601369f51231ad8188f5f20ef122a2187438a529f2cbd6f14c86d9b15fe4e3e8e371d20cde0944d75d8b4be75a707a46dedf11e690b7794edf2ae2ea85770814fceed1ab6aca9aaadaf959cdb93db50ba9fd838e96120a433cf2d77f3ee9ba84da0bc5541476dbb52afb0db01ad5ab650c3da6e61327d371c61c816f3dc14867b24f04f9e9c403b9c891cfe9f42a7b5bff4fc23a49b0dc4748a026331fd70da4c74ef2e3d1b3a5559b4efd9b65b3f692f77f3bc2ff941a33e0eaad9d8ca6815cb8d4bbb3989ecdfd995a404efa4e68fcf1b0cfc3ac63397dec14c08b6934cb361531de1669a9c15ab6acfbd2144aa0bb1a9ab4bdb9cefa2a6ea8eb9e3ba55ca185f707378be6089dd913e92db3a9208157c78a4b58662b8f224e4e2b6122462e1287e3f32bfee45fc50e1d908dda6757bf5b3d26b0b2655150d81d6fc39de346e04a5e75cfb902ef79924db583f0c3c33d0c363fd42e17a8851a2c2e1d2a1d9d820b764f63f09e2c6b44e151dc6a58c0fddd0f6d3c6238cd0917121a04ef9dbf23b45727ad818428a9ff4427c1ac59b65c28ecfa5c86bd8557e574a15bf6902f94da6dc2352379be2f802c2f874c9a6f5f7c67c86d041e7d8d1a1e0c7a5355a732b8376cf922290590823bf62ae85b5e19c881ef023502f0915be94ea2b8fe3ecb694d1020dacdce4d88c66662e94339cdd2fedd557039d490b3e3245c7fac462f1e65946fd79fc80a45aae51f9a60664efa5b4ccea9a2c4881887d9dccb8ec37be79b89b1d052c59f8219b2028d7f1e680e5f6db08f1f6a4734a5d581baaf5a9f5365a39a0906c3b6aaa8b2d3bf0e3428f8cee37805b11f4bd92bdea30e0857e6c8ce0d63e18218afe8f03f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
