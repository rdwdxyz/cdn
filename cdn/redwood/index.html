<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5b4dad5da7d705cb0dee0b2a5bb738c2a0e8e225af0c02686e1fd6060beced75eb64ea5dc1a0272b1544457debe28605be68a7be814996b2a10e9ef880ca899b66caa62b9ff2bf67d278a9e2b59bda1f7afae23538e49f2fa9caebdbf505032e32d47328fa351e7a7f2e07915614dac97494f74d04151196c6abbadd1ae8f5304e2e95b53e2ed4822b91c5ca21ac91917f77656b80e7832dd5c12912e0d59f86509d40efbe574384e8e43a4e1be2d2f0a894b40c3bfb54e16354ce5785fb6a2ae42b9db7f88ed35d6520aea10878dbca7ad1987d0444a81216eabaf7680867456fefbcf3e803b374e0b5aabbb760b8eb98d5d908f8ac0b8e9a3798b8cce1765dbf613b838e303e352023831ad3f57ade38ee203cb3fd931af8110c08842cb57451b4de64311844a98bad82c085a5e721868c47385ec1daabddcd8709b53bf92ddddacf06e12bf3dc47cf17e664ce8ad1fa698b3317ba06b45ed9da8bf906574e58b2c27249374936bf54f3f198810e5d02b0dadef92dbd9c656cd62a6957f0f29c87a0649a00134ed6dd25686c54a92b33ad6360e498f0aefeceb740660b8efae7b4ac2b21928f721e690aabaf5766a472288c3a87b5e9f7a72cd28846ad71abb1a1d061f95ad938cd7ed948d25571de065c5097052f5e6185be30ab980d2aa7f834d50325e717ce881603a8d8daf2bab6d7d88cfc72f5cbb10b3964f9d1d855cb30c5097ffcb9d2e11e361f72feaa9fe1d51ee444c1108251de14c5c4d088c8a4a56f16e6c3b0e0bd7095918f672101523b7b415494280549983f85978e74e22e68ef93a65f937a8274142e70370d6e57bae3f391e115531227263c99eb6105280a323aafd37acb1c8eb0924de71abf438381a130c822dc4558fdc9867b7fb4d0ffdfc594061f67712102e6a62c791355ac82f3ee1f24eaf06f4ee5c669097bde1b11fb3f3f6be6ca110551f342793f5dc6540b1def670b520e90bd5dd857f7e9c8063a3c0c3048e8b0dca6bd7ec0e6acf880d9541c26b4ce4363d1769f918b8c483c3458269ba4248c79ca8042f1b26ef1dc63e2623d6971c758ca5291d552fd5abdbe439439fd50473940334301eae8e26613abb6761ba31bdce32e1ac938e9e8d34418211f8da4385d073a7d285ad75ed4b4b0a58e0a77bd9c5f94003b111585b731ec826b2dfc31d1f2cd9818320da98e41a0406d3493aba07e8bdd14f9bc416d7e01ae76aa11d493bd56603a77977d7aaeb2bcea15b7afc6429f3830b54bcc9b752c76af67eadfacccf46ae0dad5651133dd3245b9d9f818551b9a44216b8683b0a84ad8252640ebc23b7338d157532616bb9f0bc2c26bcfb6285c242c335a826fc3997baefe1d22ae5d8591454e4d7ea95b611df58fb0bcb2cd70f261b6f1e96237492c450567cab558e454a2521f1bd4717b56f8b76f59fead5783f1c9f4a56abfea04efc1379cc0723741e0d24c28da314a21cf22d87d7d6d77f7c3288a1dd566c36b249e5364477940f460948e37162b6bd71c89eb27de07be14ce2a506deb80bacb210492bf266f203b3e1a2d4bb93377fd5ee5c752ba18801c3a4d8224910b7982f109091c7e0dda4debe23412a47ef5f1618d64a194d0a263307beab0b5d724708c5e20a912e73db69bfc7ae87c11d6f7d6f9c01194b68f58eccf5a5bf804114b8912247fb039e03dfe2094a65b9f8ffbb3ccab3ceb70a3b49a8f39385b2bc599654f660bfc6e6c161d8ee649e68bbf037497eb1aa40433c692403c5ce0cbc3ffd39e35c63acae9ff10ed35f0a6603f677cd1b0760e0dcb94ed102c48f704d3569f5e45c5917ca9996a0c00405f559c2fc190ec50832f28e0e3a853fdcfe40936858ea234ab13ecee5a259d0da23b255147a521d26b4a4e57fc9d0be00f763514ddd4981804537c345affbd983ff653fc6fe7c471c00c83aef1b92ebe28d2d398fef9e549bb1344d97c34129d8412c410347bf91188d91b9934b1a6a8c13a198f5fe2232547bcbd4f76781dbe28887a177e95fc740be1e9142d1952cae8f8135f21d8992352c8867ae504dc4bf022ff69b9e8863c7183ce94c91aaf3e104ee76ea46a6dafe618ce85d5b1e08d9fd9309b7c668fb04967820ddbac7c501d6d9376326772d2f30afb048c7613ca1f9ef18c76a25ddbf3ed70431b8b338b316ea51e2b70fb54d7d09f6aae128f5d96467b795549b41fd9209b40560f78824dd3b29a74cd26fcfbbba2895f59fd345d5f9b2574515882bac2dd9841e10de95ffebe43e6bf63b0364ed50eca02c6d791b1e20f1a00e66a371d1889ee7e595fa883b6d4b99c0f992ca14e39fb4250ea85572897762e561b6536b6fb390fd5bcad5b8b382b604830e2d8f4fd03194da8d6c7908227f07cffd58c900782a9d81cb9daaae2e07cebeb1e9d3a604ceb469395c1d39045c67dcf18b421df89c73342b136e51681c22d018b46402f2a088c8dfa4f7a3480afbbc927fd927f9428eb290001d73677895cbb79e5243408349943fe2ac743966992cbeffbcfdfb91118b4f162d95e91f6b6482868cf8191d187ef2af87d7239240ddebd0f03caed7d0c78f8dc1155a327942185c6a19f6ebd9e8d242deab5eda8f843b29032cb412939eab7ab9c8ea3b20be7df321d7997a4cd61cd875baca9d957b0ac10568770a5ffdfad7d4bb8c5dee94bd9e181943285d0df9bcefdaeb98216f6badcb0b61603a1b4efa6092a1c0aca02f04f4139881630323a8ea1068f3c2216f535fe7aa3aea36b341711a3b1038e4580fe492c9e39a58e5c6fe31db0f0384fd97de34e2ed649713d05f97b7f0d6dae1a84cbeb5031c94fc98e35700e6213d6ab2e8242c6d3e075fb1788ff6159055352817b59c0a15d10bc54e9b960451905e26c866f18a9d5287e7da14de7f73a86b9981376d8085b02479f90aa19501224c73d22d8bf5b8995e0266339e05b1b1797f40e0f9409b64e6435ac65c45217326782e14f36bf65365eda5e8cb947e653c583676b0ed3e9002ae600f68c359134f72e0574bbd39ffd1334462579d8aeabe76b4bdb437ddaf6b4e75152896d2076277b11088fa7b89df2bc7296380012685eb02272c28a4ac69f62fb79c2400ef7577cd244cd7262464c3663b3dd29f88e32ea47e9f224be3f3a7af2236d5758b9f4ba92235c4442e557c41522948c9f9e492144971e98c75f0bd1a1027355cffb91baf1a7eabadd756adf9a2befbfb40abe4f40d64f7bfdfbc65d59c83e2b2982c71a750fa688868e01f92a57e5b59d83d2b18ac72d1884575454ea1b2c82651c104765838288179766d0574dee139d403227c7527a2c1761013635b88095107446c6e67503c086d6e18a9586ed9153ae8266ede8bf2acb580a6d45b60dd3ea66ade7db4a9f7067d4460077b373c17d0f8589bf46e1634d7e80bebc8b401ed822646f1e09cf0aed104649c35a18e6a52d8c27e20067216762aa26ca4a38692d67cc62747d99f0e95630016e7f2572906c0c00e17c0e6a119a8ffcfe1e039beada91ed1993f5f66e06ece8cb490ef14826d4320eee7afbdec5bc3d20e66909610978eaa3f67db5b8ec513350c20fecd5788b8c7ebf8a34b8348545cb0374759be88e7e3c5c64038c2152d2b86ff5c08f9d58e2fd04c6f91d8ac0a9b27311ff8a030e4272cf73365c7ac05b6e468ab27a757997f399e4dbc60034c4b4f97de1257f152336d2bb6c4aa1ad01c0cf0a843bf730e80da4a5d2eb6d2fcbfc510adea901c30969287062288efea93153ec63245975fc5fd9df5e5fec56629756edb3e9e3a19dbc165627e9abf5c0d020908ddcb611717eed7ca1fb6a384a4cb4017ff5641c67f749a0bbd75d8a343017e2c776975979d61e6aea65af50f7916f0fe01af96ef440c8ea1cf19a1d69dc59e437b510ece076938dccaadc5bbe3f59034b90997dd282b4e1900bc37bbd1ca4c08871ac25e9939c78efb8c8df395626733b1b48f1f0e09645fb366a4e7ab670667fdcc00ed00d60485436679dd8bbe04c8446f38928f8184fe17808a35ceca6fb54dea8a650d3d31c6c47b72bbc930b195dba023a5c4474df99597af67dc535fc57934695b0bf9558d7f6f37bc61eee7ad0355754d178b9a676e55ded957df0790f91f83b3e66e77a5877cda38342b11c60d0f14bb463fbe8e87808fe045011eab4e0656f293a06e9727dbf559a5ab28382b440e4ab16b241c30082085e4e20d75bf6cf054591d24e7cb264f69d4a14c8fa5fe248c9d4bdbb8e866e64560addea12de4a3b3ea4faceef190b3d033f1d139002207048df13e001fec50b2e6a923194dfb773e4f7b5ff839eb5ac39e3bbaffd01381236173d9fa31bcaee932868b14d781a72da14cfa88cb24aa5d3ea3c9075cb3fb0d323e1b6ddf71c39c1069754dfb759bc0cbe0958392d2468dd89ee37d09e6172a03706c2bcc457bf9e531c032c924c1a59066b26dc410cc159a1f93cff9de45c7529ea965482928da41eb908fe8ab44994d9a93fd2c7c40126e9e32133edac13e0fa1e2df20ce0a798981e943cb03b1a0c4f52376f99b4ccd7e2efeb485b7e4155e159c36f128851d893797bb097123b4f75eeb3476541357ac69fa3ec0eab1064a95b21c19638d4e8c07443f6db81cf4838fa2dfed7f57fbdaa9729fe999f5321c32f2d0a2cba1327695bb76c59a0cbe646b065534699de5e0af5a5ebabef8eb8292ef842d28c1578e347399ffda3e22773d107ad4f3afad497df95e65eeace7ad8ce47c12806d1a39a205de3e75157fc55762d6a94d64f75f76bb0d01f226fb9078e2089f8ff267d33380458126753899d94a835205cc9b604b92e5ec1e09a119888a43b17ea4fd283470f725e783618c38ea83f855c592e9e50c6ae042e1c43095c2eb94f2f9be9e4bee6c8862810e4a36a1d93a032136c3eb09152c36f8deba63159ddf25edcdfd5320bdbb846295ebd4e05c6b6323f15d4a3498e3561b943ebf5745a53d69f039bf665891f925fbde007399be64abf6c8d5c45af3b5978dc13e6e7067be9fef113e159057f5a3f755849754e02eeaad81305b986ebfaf6da2e3c9f583148e716d81f50b87eeed69e70df9714a5a4be73b4eac4a2463be9686f99b45ba477bf99fa76230b18bcefaaf26c555e1c8d5ac02bec478fd6a99ec825d8b446216c9036978fbf8f18bdc6f47afd4fd04a59c1fd93ce8765ea31d517c36d10868d314a5aecbcd71a9b9b1d7ee203269596d6be7df017f689ab606b710a8e4e627e35c855542bf7f47c21cf39845f570d52dedc7dd5fbde6ad5452539bff0bbc358bb722c9f7189318579f14824c0b4882b4531ddc77d3b11fcbf26725813f8385fd7c48f443e498ca7bbdcd8dfbe64f929793f9cbd11b09da8ec1b0464dba8e9e28f820d9c10bbf3ebf7e1966afc6c1d40adceea015b224e8c5ec8dd645657c98d10155e7306377ffee1012d95581eb755fd346f83955230c083eda3e850da6794c2b91bc4c2a414b7b4f762b4d22795a6d72e35961e6b31f2dd3b86b7f43fd4402fd44920dff5799e691535d4136fa3a0ead38611fc1eaab33577df7c808c9cfb4512085a917ecd06126a409a17a5327a5f83600a64e511a04e175906aa311bdf67a5cfcc5ddc7d9b38ed491ad2936c5321f40320a5f3e9eb8c7a6e408f88a5ad7dc898b9a5fdcc746bf06efe1fc1b9f9953ed2c2e481796e0bdaf524ac7282443c37c36c961cfef2734ae04e5adbd865acb85c48792033a5d9cb39b64fcc91e25f9ff53e25f8ec36e555cf2c7579801685e04080c14311c77229c3fd6aa22119e3ab92f67b111da98e0e6f7211f1eba3b8f47319a5614c27e530bd99a88d4e64bfebc1426f436bc04939eeef694b8de26d39d7e8dd38293fc2370dc50553be1d82f7ee514e945ddb11c772201505c849e85fd8fcbbcbd78820fd9d67b19bb4944db4f021fb88d2c92f20ef1d9018e160675ff36e8b67916f81707e4d67e5bb956223e370fe51f0c68a7e0b187edc12bf16c8055a959a853cd81acc26186eb05312e5297a1109f73c0235d4e9416369cf8d4e9b2ec5ed5d05525591aad63ddd0cb46d05ff1d6147638fc269c8c081cd95e31120b238975b2b69bcaf7056aa2f51a3f51e1d7f59204b3167740088f64d3e4d0fa1a1ead0358bbb7caf82a0f793247fd86720bb00ca60be7c33b794c174ee9e5e8bf8a0e40e58fa69f686fe0c1ee5057087f66f0064e9af38ad4552ed61dadf816ff6fe5988b1313775f69e1b74705f2291dff31ba23231984600af66935817a54497f0b5e73d105a88ff4108bce37fea120da66b483a687d81363c4809458e9bc98479ebeebdceb356b6f08ed005b116bda8114926ad819480b3a59f28b6f1aa7f789abeafa9066db4f2bbac072d9d1e4e85e0010642ed952637d221f6313f2dc40828d62fcc7ea15521d019577c3973ce46d864aa3d156ce49f12893fcd35010b6d61f87d011acd5cf173935fe52c21e41d7042f447abf87331046c5b37524d20e71d26117cd338a6a26dc6d6d8a3dc69a1ef4bc97f4fd2f6f9d3fbb9ecab04fae4a39cf2a11745dcff12fb8bf30bc877e3a8e2f0748c4db048ba247122c43a5b553788d67dbb3bfc142e08fecc99fcc9079ca0d2e3d66f2a92f069378f85f2be8ec905bc00af5e55ef9af2cc9da073b26fe57cec45472bb7f89fd8c5c7a1f514f399c5e57b26fa94fc9811925f581add31fa3d6a1d1af929fdabef46eccc07d0ec88f10ebc9b0623ea4a2f8fcc1f8ffc714398fa530dcf2dfd1eea0877bb0240af3bdaa47c86fd5257074df7792454ea0568d01bdff8fa340614d32ccc71a8f3833f45429f3702bd1fec7f9388c2cc001583b2d2c09b9925fff510e00f5516f576fbedb7822b80987f0b167729cb858672e6fc21fbb0987e85f8dc6f00739defa8e1694c40a92fb6c941b6777d8c65702a2f7c2064673061677da9e761c740ac8631c641a23d22a3a8022a73aeb87572029cb6760bda9659fe36176fbcd44f83569ab4672d289ae2bfc371a53a93f491ab6b9df350de68eae8fee910553792b7b2a42d56e7a756921997a246e44276dcaab4e6afc49c3d18abee2bf531b0a32288102a2381f062cd1af5611583480852e05286d0ca3cf4979a3ea4971957858259c0402395ba501cea1b2efc75a18f5cc6d3b7652b6378ca8e6cadb62c592fe4c2420fe958d6dc9f042b742ff902267e706ebbc91ed991e46cfb396b583c7af742827004cf2edb97c17df887f8537c0462a473b8a8fde2a4f404f9290484658bbf626f7ddb17332ef847e79311056e4f2605087f297be808d33651a41377bb0a2a7b97bb3e3b53ab59cfd2b68f9cdad1ceff64f4a04a1926e6b496f38989e3ea272f9415d7f362efb54469e242f33e324347ad80e1934434ed453b397fc9ee5a7a31c0dca414db31e8340aa95baa439e51f099aef5253ff4bd05cadff8e2b3070fad836f08ffba77449bbb4a517ae366a5c34db5f25135095eb445cbd0c57fca540080c83a09c0b449bfe51ed130ff4cf45c33b761a12fc72ec621aeaae2ea9bef2d3b9defc3499ff51aab9938dd63d4a4e7674ec9bf4b7810d0174cc2a77f4f77801754965406004dc248c7fcdee171969dcd3efa4c16dda327ed555c9541b936129b4310aa46ace8d4857bf89fca3ee3cdd5c91d286cb04cc313ad4bccac4a37fcf7d5bbe4c8bfe05d7baecb04868187a8e62dd61602770c0085affde312c780f5ac204624a3dfe835aec4de7bff4df20b1c3410c3b30734eee15276c19702f6fd13dc4ee72555a5deb47562354200f651f7596091e2c2c82a7188e1eefd84d0ee12c0f1aa98e07df68f166e4b95709c353a041d45cd1850e639f8f33e667ed561a14bdb924d5b6ddd8383f0d9aa5e4bd622fc5f189e8339adbf9e1f776a3b9f078ef10e0013cfae554ecb666a300acdf96877ca69346090b7955d1d387809b8b0f60396c78236be93b6d6173bf827a39f76585c9efbb35b6a6487afb619e319773724e04de69dbc099b191f6b1eee0d2544a9dc7e15826ce65588a979062baccd7d573f1202e2fea32caa52ebf1e5310a8298f37c0afb8b667c21969b6c2e78e3be50853e730d60354f93f10b9136229d48afa3e4f416627b892cbdad976838a3bd3e2753b6fdbf08f737a5f530607b1e37e6c40fcd5e4f1898288dbd02c1f559d5e62e115b47b9e386130802e8ca3653f07461a6fd6ce3ed67f1a1c675e7f1b04fe9b0e00672ed8a110b96aa7b96c248ef1780d196c4808c6ddad0e1ba485e1e0825f714291278bceafae7f31b0399ed00d8ea4ba4fb2f12ba9c12d4fd697a2b35b132e28bfdd7271c3f66135c650d352cf86016e3d297819095bd681c3a0ecc381592247f9d5a9f41ceea988cf832978f4f69d38ea0b2becda340335df93cd8db27d03d9e1ff45aab6b027c33c48afb19901f209dad8a202b2acd535794f8314f276f9c6f0da88df8118f5be829c2fac9821f0873f339534c19f1dd3e1b3070821f0124d9b65290ffa74248043ed0e5a68671779cd0f7caf5502e60278f574fd7763e797037ed25f49b5419fddcbb66848a0ad7c4919947a04db313f573d8910b9af02f08a524290762d1226fc298c1a20f38d279cb3e5c7aa9386066fd22c0d451bc33889483ad178e512df1996a8dbaf45add6c37e08fde55ad433a3d258cafff3424764bfe37ff24224075123653e8b4e3b9b3b8b5f6a7c1476696cf4e8536b03a503dffed321ed2f916ceb0aaad9c08c002396142e8c504c36de2a100aa5ac13c3cd8931b4d5327e7064da80e99b5cfa0fca558fd7cab130c0c0cab69344cc5b75c8c50a0e2db4c319ee6204e1324a676db5293f5f2cefaaeaa9e5ab1824fabc8fbce6b3a039f7c21f427e862c007867ff4eacb706a492807a2e49875f23f0073bef0e0b9c5db6eca8407151525809c0fa36af8b9332d6c32d9b8fa708edfd917d8d047de9a032026b4e97788cdb06d9548cc4fe2f42590150c1dbedffc8ac44110c4f1cd53c24318b091ea05a6639ca613ccdf16920aa83f2248503e2ba431d802a402f580b266d7a1cb459676097e2ad5e5773d6496b40a2bf16bf152e55dcb364bee7d108ae173d85eccaccabae431cd62905b4dd9ad4e74af745150df75d531a0c09b8b86ced82ed10819f5c5c12a2f7e4288cfd104ebc231ae42088d70c70dd2e19e205f221fcfcb4d48c2697ed0737b9d00b39952d2883129cb5fd079ca2775ec69987f1ab210b413be40a1c127445b951e2d8cd732ed4a599e277227c4b72ec8cb822c7f0fa683b07cd5eb3d09c201a55e63c76e5c20b9433ac2ac43c16334e368c07521d11c8db344fb8bda6d6e6d461b86223672f5d32ab0b3701abd95050a04d8336292020005ab69864b0a697d36763b29965dbddfb7788043906eba8588eda4e39a06c27b20a6c0087281e40ac6cf7b40f61fc89838d579229d8b25e79dfcf3fd9c52ebac0f8af2d9e504dd3bb45decb876f296f89c418039c4b1126daf9d1e8f1a85da364f83847fc08267b8c6fbbc5847ca8b503cf1d85de90b0bdf9d80bcbc9054968d016947339f2308898bba4acbf5f3181a71e1d5087372db47a9f64b2eb0b105f24efb4a2024b44e4db3406269f3eacce98aae402b709a340ca2443196ce7e405caf70c9127761b3157f61094e7f8376d3b48aa7433da7cd25ce575f89229256ba88d49320c0fe4f8adca7179bc75f095b0e235deb5cc7b343ed781efb290852d6baa0249123dc51b9f46dc11eb336e00fac7c5d612a6d37649e2bd7c3980267e76c1c522e7672ae72815130645a80fee6754dc4dc534f32a6ab6d433c645f6362032414f04e4650c088bb5b511cd90801420776cfa4b5a63324d95d1c2ee1de627125ef57dfa4d4c728676d318d89d9eeb806014964b6909361ead2187c2555f58a85c91cda7ef21a6576855412e26027002980bff90cec8d5f35ab26ceffb39ea5474f6848e16c82f2ea1dc820e834ff85f1127445d0437778ece097281b5fc84a30356cec86717eb33481d1770d38154d0843f87ccf593b263760cbcc1c761ea206267218522ed6b2d1d2f5d7bbf9e56213b91cf93e2b50a2c82d776490244072a6ea6e91fef85e2f5b6cd6b88ebc9508ffaf27f8069d278e8b2798bc0956ac1d5761d47a81ae9426a3e6fda9072d6285b2310a96cf6c01c6d90660c0e204e3a11e71877930c99ae1127a4a7a64ebcac5202faf8c30f020edcb02e5d188b12634ccd0ceec5d986a72eb9e5c992173b8fc06c16ce91e73cbeb039eaeff0b4ba041b4b80a2883b9a0171014b1444e3ae76ca37b97be6bfc8bf7d48b14b5ab020555291d4b84cf34bdc1f5a6adda619c4dd0ff15c475ab5d79ed111de3686230cd762610e964152e66dac0cab756b9057c8adcb199a7ee4ef9edf358010f0120d3066a58f8d633a374c29b7d88cfd7e8a1bd16ff993f21ff3070c1dad75f5552afd662e5664cca106ad7fe1ea491650597af3527e03ad860ac80f06b6430de5f736d46b5fec9140be3983af45ae2e4cf07218644315d5f2016a33e89554bf94e41eb548f917e3cdd84465fe6e82f1c392b62a5b40d6c4c8566f9776b0f9bfaab503166343e2b98e9477109116ed188a7f49734750fbb147bdd7728b3d1449121b69fd75630fff2d7f8e249d02705755be18d7a3127496af4fcc6c6393ce44711390fc8e3cff21c4121e508e52310ca5e6e80ec5476672f175481e018c8db5c4418fdbd5a8d0f9048a8220fa43a3a030700ca826e9b42d3e2641bde09170bb98883ead86ef19bca0c8a2327a95d45d231753019008eb42dd57cea1db52e64fa5e3217ef4602fc366fcebc3bb9c754d283fb83cb3b07d852a6d5e164eec8cc116115d6e46f949b6cd240e0170e7024b4ce4c8adf7c58d9598cea704300de4390442eadec1ddbad5e8be3d477442326a370ea4e4be946d4b5abde4dedc48908a02f8ff50eec6a4fa271c2bddbea58fbdff9862544fec2121d23cf22daae10662850218b67dcac8ee06876532e1eabd82b003883b27cf6c47b7abf7d303eb0f1bb43f9cfff994c3ceffba253898b678ef4da3ea7d102f39878de180c8477dc2876192a05bbc1d67ced2d20baae34152eb4b0a20cf75cbbe5574c239e7fd4be998d3ff500260b8c26255c0e80d75798279087be7a3092f16894419e686c7d07222e232408d78f775cd394b33d1a8c3b5c347e6b6ccadd34955a9bd4edeea02ccc00f00ee5ced6f166b1d52d968ce8b60dc767fe561841e7115b310cbe83acdc05c3485b35202846c609e13b0ee8698d6151ceddd193daedf871c60dd84d8c78c1c3b3037ba56a09028d3cd3e3913087a0d62cd18cfe62e8457ccd1fa2767225bfb9d4ede85d6e41ad6655c09463f07d08f95c5399dd5a771836534ea7a92c57da21c066836ebd9cb6012c3bcafebc1b2d0f64d9da3b557238231dda6a49cfe4781a66cfec6e62d4a93b35faf712d076f3364b3e19367ac1a4e1f6022ad6fb236a0470680d6a95a763e2ed166daabae511a1e69f0c94c83d98d9018ac368c73870a34ed0ad29fbebf4999e0dce10f6eebf54e6ee8090a54dfd60d893143e118496dd94462220fbf150b3f52ecfd984757c61944dcc528764a9a7f0ee57be5a71fe3e918689a3189ba235a8c555c6584e4409b39e292b3dac478c409574085a72921807c8186c2ae3bb64e5e2cc00a76a5d376d59197bf2b908903c43120e4f583163023590790c84b7dbb17929eff5486082d0d80e190999422aee26cf0d377afeb7d6e4e58c22df7f2027081d3fd6b9adb752f3d5f3bae3c2a888501ac2c480393215fdea6b7e5b6444807c5a5365f6016dd700bade104f08258b38fd3beaa489cbb2d559a790068fe3cc0337be92da0186a8a4df1047018fe819c9880eff08faa088516b036a29768299669d2984f7fdb4b91c7ed4df48e469635021b9e2e74d62abdae5c247e8350d1254ec54cfa482dbd19f217d15c44de1b8c62982a8d3734d2575863f9582eb8f07c1d7611159e7ec01bf3e06d9f6380ad51aabf7146b05723457c196dcc9969c4ca981042e0007af61e53a9259d2e3db9032a1839f387e4276336e5475a303df01b3aa94e27d8cbfb55b8e4ce0cfd767ee84e77869b8b553329efc15c781fd5d9937524a81ff7ba1ff331ad57c265bbdbd42d331e39b50ec09c9e81e6c6251fb01026a8e18b043653e551686be729fb60e1939b6a477321876e9ffa434b7e7b2d9d3518a78b2c14b09e2765b2abe7ed4598a197828951efbc8ffc5ad9af762bda19ec8db37376c60327df28e0b6a11ed3dfce9a94bb4ef6f47ce69a6638881119c2f98f2ff42a063b61023a5592208d65f26888cf54f4294967b4e03d94513f38b29e34d4556d773212c8ca2d1de45cacbfe9740d787d3c36d31edc9acb18f6e699130dc7fbd4f23ab2bbcef7e2140371311089c96ea7cd01fc6a1e430d0bf1f74fd4a600e58ac393c7308a973964b5e6ef1a82fbafe57c13d6a8e71abcb8bac152dabbd76133f45a8e160820594ff97034a95ae0a701de3be7f9eb4ad10d86e3f7f3b116e7664959c5e4a1328961254edfca38ed6b896039c8169f5a9637f20d97d45715b805e55f9972e7ef07bccd570648902bdddc19ffe50eaa4b605a39e42c68068839355d32f7b5998762600d52970578e8f53dea17121f55ae418d2e7a31b56e8de52d3dba59d4ffc9bd323824d616ed4c43faf06f7e7a6d6728b3293d6dfd69a73e90a4f60d6a375a3604501d936e86da6df5bb49782dbcb3e603c6c3b2a4092f69fb2ce75b1e58ced1d078974fe487bcaa58258e7105a0767dac5475e6bde65ababa3001e84eae6aa9788d6264c260350e0555ac693dc21e627b42a2ba7afd9955b05b019cbecf622a2721ae5b171d0e4af745832cb4f29dfb9788773cacd4532497598b05d4a4f4d46bbcb5e409061cf13f70f5241f41033a4afd7617534dc53a7779cb4080cb5993a5c32bbdcdcf54cafb23ad957f563c27dcee778548ce0e91b3ff1f0c8d9f19b93f13a4821688db876ff1dbad232ca6f38efb94335a5d951d6e7ee769c4a446fca8f9311a9ba3ed0740bd01998b6681e3a9bdb1bf6bb7992b23257e0e21f04a8f0227c5220597e6f5e20177bf484c0ae7560c3abe13b92db6b0c03b3b42237e6731e253856e30ff84a17321dbe874236e0b3718b2ab77707c8cf8f7a56395ae4bb2b699d7eaeec7a8f8aa508a4a56dd7a869dff11306ac559e97c6f54e03f60c8c307cb64d4b775e3abe75871b774768151f70a965f7caba9047feb4b25f00aa05f11f2b7d248323d34d11e1e9e9901d54dfd7c71de2ad1f8ec727203f5ee2168f5e3cdb95b67728df9d26aedd9f0fcca6e56f55a07780cb159604a93a605cdb9a1d41a38a0ab31f9b7c9790f0c41f70fcb8e869fe7b2fa6ea971129463ac8fdb064a5f3684ce2f1e44a5bae0ed509b7b6b2a9cf61f421403fb0b4999f2188f336a6d663e03f2585c6fa7707a402bbe07eeede17a459e9bf29f608bd6d2445ac9a2a73bd0edc98094961bed7120640196f8a65089a14445ab2f22fa172a3127509cedb317b14844ea578d04fd10920bed3706152224cc0690ee1c9cf96dfbafcfbb55eb9becb7aa7602b2da2703bef78f833fa0596c166ca7f030d11b9fcceeb53c8898809b1fc7c1deeee8bcc06d78a692d9ff38e2e0f86ebd12417e8120e71cab049e606dfb192a9031d56017231ac5a8205032644f813ad014007384514218da5b14af95b06954e72193ea26e0c63e94be49e486751daee4e52080fe4c107a75e98eeb558eb2503f6a6eef2c366ac253765ad27f97e198803b25f4b812622bc2c69afce3557e15ede9833e8a6f3c3cb722146769fbd14004e0eaf81d8dcdd8a2bf6248a625adf35fcde7fe939a6d7c4bf661f8331e62a900c2834b286e63f8dc68a566c3a7e20288a0705b591faf07636c817bb7300fe12a3c55f54a038034e8161e6c594ffff5605ed9d13cdd9a4dc5c841d5335f441bf156a8afb57d314219f4c7e05c434cda943c7bddf60c6df67519a1c69273c11f9db698e379737fba69a0482cf98163c2e014530e042f30df01538cce026e704ac2bde22cae4c190f556b1bb6637080949115d51255f1f37a29aa24cb9a2d8bed3f01d8e97cb1c03213388c7a897914aa2a1ca32b6431863988f080fc701719d69beaef363d028129e4fa50a50268dad8b741427b81a668a6d0d9f2de9a61ae78df2354e0b73e2f12fd708819638bb41d76acec07850c36404de05f3e83375ce8502c5e7e4c9587d8f2b075356a4984179323417e7a9e5347d1c7dd9f339539fc015e27ee01c7161846b27c4bbf7ce6e15b13339129ae8473cb61566388c93d39b83bdae02d90ef4d79fbdaa0c7a40dd0a7b90403fd929701ceef78cf1173e31bc3f925bbdaede573d56f479ec7f323e8ce04ba38e301af13bccad37584eb609609a8ea17f763f92d871538f6e8139646d95d1c3b2387c2f1f798ea807b4da7cbdf210bd2564539002edf1eb23fc44ba2281804a49d77ee7f18aa36f33c2691bdbaa16420b994ae2866cc136def6bcfab33da71f786c6f997a9b0fdd527d7ea6a8823e7006bd9aa5832be46bfa64775d9cf6f3fb6b0cbe268d4dc4e46b05a21c45cde7e7f47e5b89ba53ded91ea23fc5805600872b85cd1b9d769f6fde1801e53e711dc2f019674e053dbc3180d6fede17f06d684b36abc711803dcfaae2e33995c7953cce7fe17afb828e51c260e5977c29a20440d2352b50f3398b2a9c1f8f565e7f5fab7fc20211a6870c7a3c32cce88b3aa9a211293f9104470ebc16a382bf811414be7c243a0f450e9909a3e91ed92c6f6589ef0b716e630ba855add3102341a9df10ad0770d9eb2dc365e4366f3a1c04e7d736ecd246c4eb145b7e74bfb82f5fc300d511b4892f6d0d9c1d6f359daf5f5481cfb45db52d46962b9b69fa142e4ebae532db4282e71865cd974d5297230b0b3fa7a132ee2eb78e4aa43f57b12d68ba36ea3aea1f30eb8e2c7738be63fee1b50a7b0718ee77dc7b53d41f9f455795930151d28975d0d1e84301a7cd33373b866fc58000b7af0b63043add1770dc6c84fbf9f7cab1bc2b8fb781b2352f87f8810ffdba900c918855507a840787feeb32089f353bd9ddbaa0205ea455751781444075eaaef4efd1d75356b030bf7655a8cdcdc1b0820746cf257b328d033b7c3a0fef535f57074d4a409eb2aaf352e516fa6dd60295043b1e62f6ec2561652aed96a9e0e73b9a0a1f904e697faf51a9615f2349135aa2238b4f19698c7cc8022f3381836e8ab85627cbe9692796a18eb14c46cd28fdc5ba95798604c4319f7e65eb0b4f9342fb9731c7deeac5aa43a26e2ba2c6c83e905664b1c98e429decaae163812560e47576a51e43a4e10a1789d2e3693b066aa0d03af7061a59dc89a7374c4ae5ef5a634b3825f5ef8450393e408d21a27bfac93bd885ce81491c9fba6a07a2b4fdc4799b65d556209685cfa7e456aa50fe2d885eb67cee8a1818c2871eb115d1da511460b2e045d881a05df81b7f635d51ce249bb0b83cabede90a22bcc99e938280935cf72ef20d4d81570cb222cb1a178189b6a0a2e2be6386a03efd0fdf121f98e46257c790c0cabd6556104f4e3b6c34651a91275e9b37587b677fbf1f694bfff483ed98adc7c71b42c7855ae380c4bfaa8d25e0433117c350203313f48c08eb739758b9dc444b49ed1a2abeaaf353805cebe5a462b2a57cea5e7d86cffc77b718ef6297b69afa6b8a37ff1b9b42772924d0a352119ef23e3311651abb10e34b1af496a1879ce1859bb9d8b57b7b4f9cba8d6ceead1ba20a6d06dcf264c64830c986cec5994ad1653cf5ac9379a3a277c1cda462feb639eb741af6950e090ad3169659c75a7bbb39a4b4e7b9d86081c12b71f69890073cf1310b58754d5581782975dd3bd384dc7bf9298b8050c510c8b89dd7890c39071370d7c70a5de6f405f7c279a716880d6fa3601eff58a42a98543b037d61cc64943bf93f2c4f7f626f3153763081ed37a674ff438c55b978711fae348157e3b4915f14999347d84c9da415bc3fdab87f558bbb48819b656a07c74fd2e015b1c41b78eb3c8c5b64a4439b1186f8557e99b583a3ad3828a0e4bb01b5c5d2671da595a8f0a5e772ce510e7440315c2f37e585b4b12b792c4d6fc784491eabfa12a34b23fe9081b8079afd96295eba5e9973f512ae0c22d8f4df56faf37d25b6db7b70cfa83df3e603e694708e23ac3bd5f64033fbb9048b0a4992ae89f23fb7647cf643486ff16c646bb55c8e515c8c518ad3fe13cbc64fb77b702289e2ee40b1b5deae84595d7a5fb1c60618eac54bb03d0412db702f73538bca9777becd4854d2f3434bb6732c76ac878a3b24f39a02fde9274218e345605f3d3ae4f448fb1b4cee35529dbf18f1bbbeb10c56a50841480e53091693178087d3b856a43e90a83bd82254d42bdbcf1c9297efc73a913209b4ded28d6873dccacd27ae57741bddac1cf31664f3338e7452524b5f8f9e5ce339b55233cbb75bac9b3be5add6dca483ab88a5727244be101ae6ee30aaf81aa1387f5326ca9d1902ad16b33f987f59ed50ba0ed43be4fc2daf5f8a7231c8c83a533a93a52db20daf6b5923a7d2f340b9d875cafe3412039b08c81d6da25e96721937271e7a1afb7bfba222d2b024648516343931cc73721a61078006fd21475426ef5e10c5745e91772630644738103791ae40bcf19a61985d9e142e2d83c31e907909c70d61f07ef3bb24e7b67e556a8a8c102230187a912b14b8df1c0a7e9b43fc7609548a7f360275dd01c59b02560a9984792353246a7ca0ee9147e8cc14f0901fe8e827cd3861de945b24178057447c740fd9600de8c30d38be73ee48b07a459da3e151fef00aad04761daea198552588cf44e494caa23a00d6aa9a7d0c33214c9682944b4529a93b268240244d0f2d0f119493b786d8220032c6e7f13ad11704ad9184ddebf8c0bb95d3e13751312567c2ce36d8b1a1432c89139101a183b4b2d0279491ce52af353f6545f13b76bc431236628f3897b6cea276c5c3faa6a3a9323520e635d07843cec0e20e2802c76af3c307e36fa80785b9e465c8c4db1c31d916e81a11eb7e11cd778dc4b835d03061c78899d5c2787729ce1f4ef173b637e9f6d32dd542d6a1d5b241f131aa761c62e8ff1c79ecdd74e33e3c5d3211d7810f4ed5e78ba12c9fe8f0dad2e1ccaf14b4042cfed939a88eff70b27dacdd76b4d3e776c8f77a56cb22c8ef11ce80fe36f979b35e41a91bfe3c0c18f4c9abf836ef6476e6d7d76033118fef702c6fd8c7e4ff8801b065b04514b3678148b0fcc0f4abfb41437e0620b1fa77a2de5111730371e80c9836fddebc6e17b5f744204d86152331278acd087b5a5e960d882868b03b66ec615085b76a4b345a8d9a1c6cb4c600bd365c409efbe28f7c709efbd7ec322043e087142d6bf79e09ba2d735581af540f3e3740312ca730b0fde556267ba49f37ef27be3577c3e37e27cb08ac601eab45f4d75287001e0c6c744a69c4312d76dbd12143326e4e66e6d2f014ac580fb1d66cd5ef4535c8d706ce92467af2b07ad3be6629b88fe36a3dde283a393087f52d922a9c9a1ba18307df7c55ae430a15cbf5a7f83932539dfb73f98bf5b3cf31b6ceeb5e3a4d21150dc5e6a69de5b92f69214d23bf38a9274a9336b6cb4fc58637f2a475e14eebf533431a08ad232edbc269da34d2d1f89f5849013dd957ac77728f5bd610ac16df1a17c66a9116e0c3f1c5daa6bb95b2901e9cdd8305dbc1b051c903df9c057a996360b781e647742244ec2ee52cda51287b1d219fc3ba0570bf174627ca6271dadb6e841bff9f1b04a457f9c8e7e26e4cba6d9789def7a6f2c925330129d538eb9c1cd12e85ad572294424292337a97a1a8ef40ab7f5996af7ce3a2d7b16eec42bb0f03dd48a65544969afc439d5663c06a3e528dad521f34f8f4f41c6d9cc25f5abc5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
