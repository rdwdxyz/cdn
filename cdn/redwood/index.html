<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"944ccc35aa3ef487652c82958475ebb5aa626d6a54a48fe559fbb629041853dd5b08e9b9f8ad686e975c80d97cb53d23dc3ad426b16e71214bfb0e4ff48d8a5c7f7a8e86d830c1664ac83c99d0608fc5e2136c7e3df481404635cb8a64272000d59af65dff6119c89e75d8ac38b3148c0eb737b263a5cbdc3808d4b4756909b25fe4e7e44ba79a85f2805b742e3995f1d70d8fb2736bca07580c697fc18228751b611aeac7589b1bce0ef0d4b31cac6d27e28b2fbbf4988b7d9dcad24736bce73850bb4f18e9e1264ea8e6ae6275fc86424399f143ab20a03761065f631a42b7de6ae0f776b49c4463d9c9dedda3a9c7b08f41deeb1fcb850aeef55bb4c1170febc72e2dbcc205416df8422057a459b3d2b37231031d6c8ee50b212861d6070db385251a777b92d25e9db355cafa34b55ce6e9d7e151b6f7a7396bc745ff2beabfc7a83e690652e04936049f023231f6b645a342694e762be44edcc77c4a225ae70e551aecbd78506ae66d268a9110464f49eabca9b3629956becdd4734d351bbad9e26c8bbebb512bd11ecbf5c1844ee41072d71e1ffaee581a071edb648f0ccd533450de6eb86a3b1b83aeca826fae954f8c237eba7b23f4a1debb3599ec0ef89a6ee9a4fd0dea3753fb54a203c0f4d30c8479dc93f514015908318b5b1ded59bd8f5decfd6232fe3b8a86611621bcc3b27bdadcf7badc959acca838131dafe27f63ea201dd2550f82233bbe6f2481a8ca4a76dd902dd84f7b121bec22ec926034b3a83f8ff04a55ccd35f6ce6e4f19615890e9c45e2e2c74834587e15e6d97f3074f89e0d9bd16824a983e36d78c4f771cc93e4801aec4ce79ce2b08dcadedeb5c1b892ba083a1b2b78e2ef5df2a568757916ed1c8c6f10d71ab1992f4fcf404aa45aaed0a23b6cb869fe4527d3cd3f11465ee84b1bd97011c3455f79c4b3190cdc4ff5aeccf6a81e1adba5ba6f44af515b4cfe735861795980f095768da43549061699fa768c8f263a99b0ecb76b70c683631a0ce7365a31438e35cc301de9fd87e4dfdff9ebdd2519d7ae0b3a3f47e6e7efd1ba97b4dcd64c6fac94e6d6474cb435a637a7dd368b96a8ef8718fd58e4b94b62d0d01599a3d77152142b527d9203265454fcf009a95ba6424d272e91dc96ef21350002713d2d9ea8699eb502f05ef3708fc6924a811e404ca548781b47ea82cf5e7b48a1cda5073339b0645bad6d9c63fef1f08026b7de60d835b61df07b0e1035dcc8b6d5b1ddeaf62103f09375781802716c204345dac872dac24e4b2daa9620566d57f1cccef4480442129da2879d275ddb56ecce348ba81025543f3319134e6e77fb704b55939df484e784c8997d1770860dc4bc7580db5efcb470b4422831a4a3684ace69fcadd0871dcb6e046eb8607c4786d7e11e6ef5076b92370f51789f4a2eed5fd609ebab2bbdf3da66b818c3522d515ec07a2ad8cf4b7c592e2c81670cc8e07eb77299dfd0d235e0a8990d7a3b403a7a6da8e2f95846db252ef83777181a2314e71a61543e9481a2b59bff94807deef6fd7750cc03ae93a98b1389bab1505b834ff0d3f2f15e662477a0b875297eccfc4736263d2c2d6ca5cad7c360e4d901ae7ebff75e4b186451a7c0264c49789d47f95e9969a8f34bdd87ed1f4b7098b25a8fbb7756309598e4e05927df62b2aef1ae93d84bec2885bea20bf1ab40bb5ae1747f857f02895e9925ca0a7d53113c9f01a552087ce52d6f2858684d12d0121a716bfa2afa9cb5a1a0d691769f948eab5f472bcb378ad92a57c38720e89629c26a4ba897a1d4dd99dc619ac7593ff26c7da1d78064f16a06ffa0883e6a53a1756a8736c7d599071bc30229d89a7000f150d5dc12bbde743bd2223f9e6368cad377c4665521d7b3ae5eb412f6f200eef43cd89036cf80391ba07473413a6113a1caec3bceccc2f33dac474b8c5955239584db9cf663745aa0fcfb296c17aa9bc633a7e77f73eb5c29fe9644aa77fe98d605fd13dcc4edeac16df5ab2cf90488c2129d6c22835b94719fa416fb00f263434afa1885ce3dbd50cb70cd0da2ed9668f4c4278460dd8f0e815abf9a7588f471be2f1ea2e50c7446233e539614672398b7512a235260f351ac35459ead1ca857f03367cb5f3872c70c1be80277cba68e131893a24ec7df084203b3ca31dc80ffcf2fb202903d3d8541c0ab45676c7fbc3f8359551644634f343fe1728ec016b08db289a597c9042016064be6fff7a25e2d52c72b24ebc4676c9c9359dba3728fd79306e4ed5c481e3428c0bcfdd0461192f29b9629f4a3a1ff398746bdccef6b8df389df1a34f397cb9f4549bdc09981d7af25b57db7cc40d38387b4828407749c8c6f0dde5855c511e0398d1babcd5e37b62c65de93e4a1fc1397ab6957012ebccbce872ec4985f6bd7abeb735bfff4debf97ff4ce0434c6c57b53646fc2e94f95d071fd85928fb99f3d47ca0a554c9014ba067cd0941511b54857301ad41d50dfb8923460bfe348ad5c10f7098157c7e5f178feed6fa6a1db1d0ee4b9f55172d27838aec30f867cfe47f318ce94deeaebc4efa0fe3f57c5c15122a277f58ec21b0d026a13c01f0cfb86b12abbc20bb4482987a975014621a79af301e5fc8dbbf3cb4143fce2d88b8916afd5ee40855257063dba8be6408099be301566cde5770c12dff2150c27faf5b6dce8ed97b2351f9338c6c1eb6958d09ab711ee3f11742b57de4d5381a0c488082687f942a80ce8f2445c9d7856c536c59dcfae653cd551176269f8736ae47b4f4a8f8bafeb02271fc3825c76de9312f5ca29abdd5681440ba2abfaaed54020eae18216a5a5c4cf506896691f7ef6d9ad63a0656cbcb9d077b9e528f3a4a3dbffbc4396fa9fa7badc67c558ee2f922009734e1be87471537d217e0acf8e6514faf0cdab37b10b18f198619924fdea5a99c8d8359ad4efb6d28cbc4ac9d00e9a78b826d4691e1d8ebf54969f09f4534521c17633731a0a3cb3e1a8b8c689dcf15e589797d4ddbdbea969b934725c298576a80154b16f4f3cbf4e8a48de0e24ee684c3765837c97a2187cbe0cb265165f619da7ba1b23c600ecfdd30a6861cc13e9abb66ccfd0a293603783fcd3dda2bbcb4da8c62e5b87ba756e668717e5cfcd59ea77926cc54fc93ce68aaf3efa683b26ba3d729038e479f460002d09a056edf25308f58d38886362975494d04f5f0caf90c2c6c8ae0d10837ea93077ad797a42227dbe3930b9ae0d6001b489801b8eb045be191240489cc2f129191688badbae3c5608b1094a020a97a1eaaece59d38515c5e2c2e913dd96a3fb652753fee67fdbe62905f4b0278305b068b4dc6b77f2203eef9249f3ed8676040485180df51189b8f972ee5e0a51a7abda76edb8168896c543020ed72550070136704265f949be8803ebcc16105e1773674c803802a765be237d04b343c354856a0df97528dee133e1bb2644a55d57a6b0511d9d8d15683f11f823a5182083737c82359cf3fcb88425c7204cbe62fed14e87327288d1a1184bfb8ee0652e1e6124a683686398b952dc888688f59f416fd4d0d3ebd726f0404c4650c31ac11fbb441086e3194f8343e6c28fc5046bdb08e825809744cd827edf5923fc6bef42f4a925124e917d50988885210b1e961c71f0fe7049137e165866c280e9a2aec9f89d6a029169cf344e278f2586f044cc70aaadbf362b6b7fb6a8f00d726463228d02c47a48526c9f367645e12d284f63c775e37c482bd7922420c445480a006dd34a17ec4a9d91ca9048d0f0a1a1b9b2aa6808dc685e1b60b7737092d395e990aeeb805a0e8e0b6b301e79b7ff681a1e325a223d1ecc409b633513baacb491a6ef2380b36b226d7e4f3613b0e0cfa842cde1c8acf2c1070b737e43e1888d869bee94f157b68f9d701e95929b07c25cbecbde085b2e164c4b873543daad34c37706a47da2c7ad027128bf6ebd42dddf52aaf89a5246847528ddfd9e515241976a7c1126a50e5a1e2225dc661ebe9323ab5ee71a3c98ebc89e273b97b96db894dcc74ff1dfb37c59c1b3bf9ea360dca1f947da333b4291a3f719ce811be82db9aad266cf0ddf3dbb29978573e19e968ec7cb474d1dfdfd5851646b4f1388c2d1a2596bd055cdbfe94abf5383855ec2eb9ccc41ac5bdf2ad669702d95370641950873a7599f18fde5c257bf3f995f712839338a34ae288c814edc7244db7c89daef4686b5931cc6892d194ba55facce4d08ba37b29370f1727e8616188ca0f9d79703819a4074c351653628d1499e705d6b366b17fe53cb65e8b69d6cc2ed69564166c7397673af1493347cb7d0aa16361a4f0bb5bdd354f445193f0d64a90d44640c629fecb37088db73c0e66cfbf928137ee7c1ebfd8784bf9bd7e5339b90dc4bbf0435b34b610b2e8776aeadce82dce2347ab1f0d5653f23fc911e58adfd03cf9ba0ffe41e754e38e4d2116320516d9ba008243922d47289566b46121f2e21521fa8cf2b6337a7e1470303a31fdada21b9a3393b94db034a913cb52c7d162762979391f88b5feb3c699d70166101b59f30a2e9ee3ce27f04d912693ece355b135c5cb64446a18b1eb8580f9ec8c245c488ee0393bd3456b4960e869c8714045950526f12df5cf820887626a9e5039db5540249648e7324a35302498749cabd81224b75b9a4d98e22fe1cdab37f2864c88f5241f3ff86cd2f44bd98d3099a0c25bce3486c12946048202edc352c6a8f427693ddfeed801ddf0b06d5d135925e4364088b0151e0e517bc03b3f53c796fc5747033e390000f6d1856c26f49f75da1cc6b9c13787fc086bc9f56d49c3c2cade7c835995837a33c5eecfbb35a5dbc062ace009e026a43ffb9bdccbb2ba6465d27b83b9849ec350944f43254019a3da4f927f842fd9accf147adcdbfda9b259bede5c5d6b3892bdeff4d98ca033cb88abd0bd8bcfb0c2759ba80e973e921a628a0b58a1e19a8d82cc3e0968c5a43cacb99a7858fd516d8582c88c2d88b0a46ecae75f40bd79193e6a430b668a26d1e831cba3ab99b79b977cc0f2cfae037de5e79ef7c9ca15b24d7df3fb6e6331b63229e74dcc1264b732dd0e6b405c3721f46c21e29b60188f518f2b05553a8f55863c836f3ea6bd5402ce393110d4728368add16aac8957cb033f3a799b29ba17d7aa95bbba6c88a88b6be1f96ad23adacb5fde0ed9e317f3e63ad4f6b84c97939d40b59e3d18aefa84bfe7415cdee79599375e470ee8f17c39892fe1e9e27fff50bcf34d88358a30a87ede95496154fddef661e25d5a2e0fba16f4dc1aa6b19ad3567ea2e7f77d4ebb59d8d109b176b391a5b35d5b757226538481fddfc546734dbcb8310572b27b8dc1bd493e8b8109a221908b85316c70be4edc27addfdb0d5139896dedefb9dd568d0c1fcdd467fbeb142b518a1ef722946cbdbc86adf51fbea41b453b1de7b1fd46e757a9a8dc417f17bb295eea0a9ee66bca96b8e07acb3daf0979b5bde47fb6e2468388e84a0931e9631bb2871aa92926cc73119c89c20af24cda872228b3d7b1d9d2817899c90a980667bdbac98ecf6711ef3a52fd2afab5bebfe145504723163207bf58463f7afd6197a7c4e386a1496278164f1ad4603c497546bbf089be7290f5fc462ca16eca42b0a454cbca21d827694419bb4f590f637c9aa3bef2754ea851d7b259f1adfba1326f31a041f578c36eff5b31da05b2651eb3a6e9196c8347d0ff4cbe701382875e99ba79e5261b69ba0fceb2a1357aa40e230f9592cd39e9377ab40053d70f1a914e5ca855367497d631ecac57f986dc0c62cf89343bdeb9b1599f77a90e2eff6751ebde76f3ee1ffc0f02282b9fa2588d3612cb562f3a1b917c8c4d44c9820379e608b8940b876314124317d8ad2c1ca85402df652f7dba3ee77ba4812c64ff5c97d15b34c26a9ea2ad1508bbb29ff49be29473c0fdb646e819fdfd8184d6bc0fabd0d7f1a89809dac88e656eb2ad90d4ee6a0f82332031d33d7bc7c5bf6c1b8578bb6947ad7cc5f1e7ac5ad9e7ace7ed9ce68adf659b720bab22f5e87cbf24d0dccaa14487e2427853de73e22b5863bb5b046c0ffbfdf1356a8f9246fb916ebfcc99d00c35adbe411972856a3658b1bf74944c45ab55cd2bbf2eb578293cf1a46b642d602e03ebdcb384be9648f10db85dbe8e917877fc86ed4f618579a7d8a6c4dca59fb4af2f9091b41b18ecaa92a068b4a3d6288b0bf37eaf6881f4c7532b315b6eab9b788600293380d6bab1fa5cfd28311e04b3fdaa78de1eedc550eb1274ba982fe27df35c04a448a532879e3aa86d3d7557942f46c19a69781e44f073f9932391514cff162b34fdb01ca03f7eb2a255c999e120f8752ddc71f9a3dbe88d101edc8a3a25d1cb70163b3ba866ade0663c25847bd790806d036bed797a1435786e15882154b68c13391785e53bdf41ae59073901ccb36052dbee5ecdc18a041d14bf8588bbd0095edb8a2be810e3599367494c61016f8b1c135b4a6b2655f5fcd14f6e29a5c49eafa98c77fd1a52d46aa25756bdd8eb404a81b7b950d413acd351b59095f9083f216c1d863fcc7aa05b4913b898152cc8f31ec54782677273f5dc1be8a476cba02e229b3d0b7cf4a4b827b01fee0cdb1cd8860dfaf49f0767bf76cd2b175b79fed552e92568b3456eb23ea54f62c6f37e4f29bbc4d72ce738d148fe14ce503818fc307deef61d0e5866408c56f157a02cd1061e4e810e75fac6e8f669d5e05e45440e1431f68e2a8c73b44c0c9b4010dd4adad9f84f5d9e38571d81d7192179a9e836e29bbeaea31d2e1f87e7adb8fa152b392df58ffc2f0da3bad347de0b8b7d26faaecd14d6ea9747bb1c271eced0c451bbb73b7cb1c8e91897b7d865103f2772817fd9c316a03dd9495616d98ed5d5f11d586fb6d45e385cc2c2705891a73016f8239cf1ed18bd5f21fc62ad62ecb69d82c46a2b9624db0d90c9732b8705c9a12198685f39939df46af2ec2c7f889f6e1ace17890d5ade2a014a6d3f3f4b1a3d8396d71ea3303fab5a3784b177ae1f8107bd027b6d8345884d590708127435558bf6f29de1c9f587f1b32a25f6360b71441b66847270e46e85ff24ea9e9f62c6932fd26e5e8a590b9c75985cef3269862c7554737e2fb355c559be555e5b21f8f42422af4a8ce6e43c3193efdd72f2e74e65c9aea85b44390a98d1828c4935bc7608b1a4a848f8b424bde05b2e37568a58d556b9d559ba111b9ce4b2e2c9b72b7a0cbcedc0643a65fe25b37727479ccc266b7ebe81f7ca154dabb91d25f35995953851fb906eba8e763f223fba23a5cfb761047bdf571e631d7600576bdd2f4ace36eec5af15af729b448f14cda32ad5faa9225822c9db3ff76efbeddf0c26cb46eae9e4fa4ed7ee69c471be698c12dc056a3ca332e3fa12240c209cc6d0bf39d89140ad745582e4d410f3d7b063e32a87ddd91f08f34491765d3e8d6e9848d87d94ae0c4ebb80cd85c4ca879b4a84aefa67747e52ebde057350caadb18e477f1731984717b071ecb277d2550bb9afac32936ea5509083332a73a85b0705f50d82d33d854b365ada36b8c5af7a9e0c5d703e8736cecbddf88291b6dc8310d7493d8c390fd0d022d1dd515350a5f1addd2c31e82a4a6efd396cb9c8131eabbf68a0f8ca0de71bf9f4ecfa40a06e69a26b65fe753abd3969bdbc5a2bd4568490f4ecf5815beab44a05c6e3476cac2de98f8ec34bb6a44c32bef0245b8d7854a48ca49b7d0deb564c72c3305c91d7cd587a890b08d3632646a2e9ce90605063401ffa3abed96e4a1830821cccf88279f4b449dd04803e0b4ed33cfbb43cd3a2b10b724dca9f9adc1748b244b28b602c624cf3fe3a257f17f4b276418a6b8b306112b8f184bab503182a7e35d3d7c4c6bcbe96c1d949bd4a80f6b0f2e9eb7da6e74f3a69ee9ad3fcde4c3aae588a178d25bff63c473c62a131f7d830b33529fa4d1f8091bd4e78830410286d809766851cdbebb3cc910b89da9197457be40750d9845951bd8e2da272c66bb21aae5c11f5aebc422a56dd80c5e5b4882f0a50e52aa8f7c9473c685c8bc8150cb3c1e9a96da9bf1690867ef4f06c9cb3787fdcd9e58bf45d1e3202cf27fec1553e86bbe0c3eb8a22605c5a18865c93bccb642c8f3c05aafd28655ece650d5a643b6c693d2bdd1db5d23cee6780318172d95094c2f24233efd229e2474afc282e5cacbfdb600a5969e29ff33f496666b6c78f75ee29000a159f2e0d7e6a9255623252b0e79cf078483256386db39c88b8cee8aadaae565717c83ef7be27449241393b5410ec54a03e10dd939eaa2e6c42a1ce9c52a97ea7a7e42187a7351ea33056b4e09b6532a4b9f7559a113ce2db96efd97fc7ca23e16fe51e211456a482254699c8c355bc43c11c0821c5c3d4d23c36bc304ed56458f578dcbe11263d20e08309c96663ce5e98dcba2b1601c45150eb89e2c02ffe7f4aa26e6b22edf1e862d040cf9fab65f7d48d1b785e811f2c36c8ef48be522fbda8620578ad1f1d423ceb14d9b352111536615de09408f1c2e4e425551b8eef405791ebe4a4c01b17790dda897b4bcf6f3fec00d5fe89d3c9e08380968b6afaa2878c7a356ff03377155ed3099d35bd01e78032f3684ef7915cbd85d0a3c99e306d20a10de932ed43376bc4f8ba13f316994105bf01d41ad04f87025932f4409786a617668369c7e208ee1ec4b7ee1c36b9d3052361355a541decf40efa77c36efd45a35c2b33b72ca949071b8fd520911a2189199f23712c41c7a1a0374319e6fcd9cf881cf769451b6b918112dfb0356f51d3d7c1b98400d32716a52dffc22fe991e85e51f4543e7df0abf628d8174dee158462bff8291b43233dad2ed0787b66f80ea2c18415ba7edd459d60e6e169d0e6b4d210627c9d96ff1b66a2b852c9cc4e62d6b1081c0a317a72a13b98de89e588b958aca680d8ff54d1287534493eb7dc4820f021222b33d56e7f9be6ad265c150e4a41d58943fb298f66b40f35207b19cbe16f5e515d7cc3e02368d5335058a5d67e6cb16859180749f90c2d80417f335de99bc49a5d2a04953b418217ec03d3611ba883df8c329deae84220816c79d79791acdbe28830a8e3e8ea1e68d2f944e97f327bfeb1f4f9244398c66f02de4f240e9185874a296d29ab4d47219203468f1b8e705a6ca284b450bdac616bfe0d1211c23266df40273a488e4ae345dbfff7d9387cd70f3c4c11facd070c6f6f37d54280b93f1fa93e6a7d3bb356fa7468a960cf6f49dd8c6559e40e7b1c34ddd53a39b3a32c5acbf0c06e1a0b08870f5c91add65d6df489d9024c2027a321a8464f02718e88bba8570d7176eb11dbb8809253cb5ec30eadccf625ba92d70eb620bbd35b31996773f9d04f64edcf9afa1a2ebbfa4bb81b2099c5055289a01aeef3b8f49f38fc1a09dde8f935b00a7fd2dd792e571df2d53e3f4fb367e7e49938ca8de74f9f5ab5cdab80a56de792291f5818cd6406f3379e0b57dbe8b1005d2ba6e98a6b9ef9c9ce95bbd7c1f5945f1c06421a6e69e4faf10318d3237e7df2a8d55813762d414cb9df5b2a5b50957d9c9a11a33ea525f51a44575c7f8c83e751da2c8172dc9c6c289d561717bf484008e3691d5833d80aa64e4e5506153b3aa718a3dab164676efa95583e81dba16c5f54250d0b15ca596a1d2b7d994bec109ae598cfa9b357c703c2b90ad277eb5a7b0e405ec3c3f41b29649991357558d174bea0906ff1207c5afcd0cbc9078ae96d345c2f9b7a535e23bb50912f9a08b02211067fadf107739cdc2e6383beda55c8c1b53f1a67f2b9cc20dd9877918beb529d1942bd49283b0704d6d2cc55a2c6bf8dab7fb1e9ba94b554813c42d83c254f6a72a7420783df723b09c95aa37d0c03ab38946f7e0276fc0e6e22353911cbc9baf3f42e611aa405a5d8290f74a167359ce6d25e6bea919c5523761dbeae13aa7be3e05c63ded916ba9268e4bc9fcdc47cb977d3500ac342f34f5829de757b46866104f19b6b879e122f9f0b5f3bc77621cfec67e942e3b6bd9f47251b0a5a70658c613ef900758d49797bc6c4c34be3f1ca25fa3018bc70f54fb312ce4c52442d58fa2a46918a4efcbc4ce31bcd5a92a0ad3e1d6ce203830cb31036c277fcc4f8a87a36ba6d935309eca96db29c2867abdedd4b02f571c6480b7e8f2bc492d26c500875f760d73bb651edde5a3b63d749f2814559371216239dca3ab33657323232951bfdf921b80097af083bb6d84cb85abd204629c199d3c753904724f3b653ac8770ed3425eafa322d06d6f41bdec3b40aa3c829dcbca4931537f85d1775835ecb8f014812769288c0421803294a2241a6be4396d9f6425154dee379cc3bb177af60a7d748da92e83f7efb10c3e7bdd9e99a6e43b470e9f1408677dbefff16ac6b64f25b710dbf3387275884143c03913826fd0614f030bd104d42b7a237a66c32d89f55cc81f8b5bebefb22d4bad853919d34df4d3901da0147e5d77a2bdb34d0b3ff6ff925f3988b4422f38e03adb4dc0af0ed898d6ec25188ef60eadbac2aeecd19ee9964f6c1bbfb416074fc5e02e956f27570a63ff31e5f90ca483253f461061cf64f93dc46690865361d52c135d9b769a50c1ccd627316051986f2c657d7b38ff4bb50060af54f73edd59708ac59d3acf9a68e891fc915e3b4f6e933926e36a9a95e9f4411074731098f08eafa5693b506a7cb9a4996ebf7e7ee7e53334032b8ae5c57e0f59a15cbb9a460328361dced4debeaefe41cef5065a9931d4c04b58ad58d3dc76bd6e67a28053961e50d926bca31fd481bd9b9283c1b5e104612602b32f4689b8a0363347bebda5cfab59c20e936b370d410d07881129cdf755f314f8d28f5269d54d2b97fc34b112241f49a8464b91df184a75359833302d73955031d2262adf71a4caac443cb7706eb1ed36bc7d9e1e1dfeb57f951984e08ae5791bbac7330335f4bd6276b88375507e49a18e7ab16d832ec7ec093e6a63d600faf993f053d1e96b81975b68e602e9d38aa280ad8d74389ae400bd8b33156fa86227e878244372365e9a62a62813648356a680c94fa3233e80a0aaf15ecc8f0f295a5b30ae1c377120d63b9ddf98ef30fa9bf56002ce1441c4375d529036fdeac20111c5771071ce652e7c87e4f4bfe9483b6d0efc98237a95864407018b525ee143f9b8b1c22e9f1b1a1e10e0e3af646cba78f71af3d8537445a31a70fe504c60e5b4fc30c569f8420d5df3873b6bd70897c2d76de651c3729a4e38509dfef5a9f07b636a15a0369921d2cef323db1facceb56e8cd564b4b6563c22f2586c4e3929fe5128b7f725b148764d7503d6ee2f9e1cc973a8bd16ac0c3c5c07b50904347b42ecb74a489d28f66f54ea49aeeb6d72331307a352fa4ff7107f31f67189c7a8ac7090fbf74495b2fa04d14e8762bd46d095e699fb861f6b9125d60b55df40e0b2cf49c00d012800174caf9ed44dbdcaa18c8319a9323ea2e8b1d384be665da74eddcf1a1286789dfd138bf34f6ba8edbf95d75a1b0f3a8d616d62a2815c00eec3c53ad42267afd3862c9170b62abcca6e6f776dbc46d06fa000c6ba43d38bbf56c7cca55ff25a489e8128fac06727df78880770b0da7469f392b5dc0e196c4f15a4a7bc4c137b791a2b419ea6e9e2679ffd1e0004de78d973791b1c8217aeb15964f975d9bf91b4b0cc406b2df0c1fd4b6e35379583fe13caf7698f10fda043771955ebc4ab47c43e802427339e5a03ac536af10733e9576b745361da6340f45bdcd2bc7ed401dbff3f6e14680837c1635bbb223f80e23cbed051d12977ce4538a96c986140f6d3fd8daccc2ee5cd9138401bb3c48d9667aef8f1334f5a1de3425aa0154485bfa6075a393e55296eb521e4ffe1977042b545fe4cc31a1bbdaff4d66a3e32e284e0be56c1fc85999bcf1345d358d13fbcea912cabf9fc2f4382401730fc03eecd87c11d42128a1df7a8b6e759b1ebcc5498cd3043b69b2e4a42ee495ce651b4b6ce71e7f56da40659f1455dccd5c365be5c2a4c8e1290362cd4caef4b955d829de7ee1a88bcb0cc7fac5f184dc9bb32b89c0c5a1f7ce23bd5aa5eb048ef35ddf665bdd701edd844e100a7157e5d39c7f995bd3310e356e68841f846f2577e9a21309ae9f7f89d0e97501eef49d104b1183109cdcba6321bd63f537d1b762826c60593b4b7ddf73d566bb12d28a964efd2e4d714e8572dde871901fc16487163b9921e803761ec0abf859cb66186d494edfbf03a73ef6af3b93f185d1e93c89aa3db9e031f73655c07cf3da2e6474d317f8ee8a6ea8d6f0dc8af8ab12ef7c6ae61512bb9846d57f066c14873237c444d2de02ed090f9964748f0af21ae2cca7676d6552ebd257e759ad1f86ff6413e7710649bc32b03fbdc04c4479c49e189488edc2674b3d96cb6676f2a213b6917d05b0749eaef2fefc8e7a53fca1c4bc6db894067b1cd5633c5cdb97f5dbf2e3f7a8ad6f828dcfc883f0e4f024cf8f7ee62c68788b92581c7a0f4e8f32771fab0ae852d8835272068412ffb4239e703804bf0a935a2ce0a559f16ac967ea4fda8e95a14e1f4fedd7cabcbbd436490a78c45cccb93eb36abcc7936b944bed6460ccf6a6ae184cb9422ce5f5600ff1a4f994ade5f5a181276cfc0ee8a94b0258dd63bd7746f7c2358d5d05237e710c16441f196a88b5c9f7ebded36fd3ecd2d9f07f1bc1e34f450bc28bec037c1aa6bf2993fcb30e4c30669389c5cefd6e2df5b71a9dcd8d68cf080bb44a479dcd5f26702a8c7061dbf29357120a2e4f69178b8924957ecdbfa57317567dfb62fca4c079c3d577dc37837f83d36f2288f075b017e47219b8d6a5e0707321c193204692e99ac09c07ca69e95e3f07a6b430fb596c2c8978352a92f46dbbf7a5eef6b53352c58d9ca74927b3869a0f62a2306384799fc4c5acf76587f9e8ee2cf1fe5d7001942a3364d686fa86e4e92c49348a03fe36158b046078d37629cb1a58900cbfcde6987bc2ea22e84a9c027c8fc9ab897bb970288fa349b86151a181bda595b10b26dad775e40d0c79b2b0e996c9c51538858fea216f206b2eaeec4e50fd232ee2e4bc4c8f91fe28c0bb9fe2acc01f50c5fa76297d6011a5d3926a5409391cac19f88628dc0f767c02d3676b62b05bd3ebf1cf7405bc0c45d523faed63b68472593858c00674d1351e4cd6849258303fee7e8055539f28580a8bb999fe378798c66929888fe1c9f02964c2409a823536a299e891893dcc69fd44b4388a97f0f518d4c2b71af30e6262d3b46063ecbcdc1ac418354146fc878330293740acace843a5c445a92f25e7a2efb7018f3d0e91eb494f2f0250d28370d0e5982b08d2e4b5d508b3ba398d3129806b5ce0337f54a6b8ff18577d2e8b095044b0a8ea0a146bcfa2fe4007f52a79abb16ec900581c118265fefe00ea87fbc526dd5a4387cceb180efa89651c0f3233faed724618d2735522a46f856801be8882df5982d66066cbc4e9ec0dbc97f1aa0ee9728dc4d18d5d53134fe6c2f249c59a797b389ecbb6c9c94aabf5a415a1b4e0f2a37d8b8de95daa2efceadabb660f83695a9ccf0ae8b0cb1171a26bcc3f519e5e7c487a785ed2198cae24dc3549af9325184088df297735a8b10a813b355a9952268aab691286f90998c5f6e314ae937a546a71df24b4a9a25cff2031b8525ffaafaee21e683eb3b3de8042f2df6a8b4b8add8ec501fa254e62fe3e45a5c17f73a04617164acf65c37c881c68a016d02a102a9e9e125a5b09a11886c0c1eb009b777f43f8dfe6621b653a3c5d76c43451354d3d60569376333f8e76933fce00c256092bdb26e22f81a6dd2c607438fff2b499498d9a1f782d6732bbdbc21c82723c61fdcc6e1be2a1656151fc0205015e0fa64b89584aac447b63fe3633484a285903ccd1fe3cb0ac402951610593ebf2ea96747f8aa5369ca38ed189e5e6617492422550eb7a965279f6f10dc8726e2e6fd5b980a717c245e2f0d14703025a7cb53ad32fa5323932d8ca02b5e15d4dec1d4c6910ea438db816549532af5c63dd0517b5cc611040af19a8a218ce5aef0deaf096a0fa7f8b5f041c2d7ad3484e18939a8b59e5bcaef0a0de1767c32c7d81667762fef2f1e57ceb83b731e610cfe4e8a08e41c1d6436c7418058dfb14561f99b84d6fe23c00d4fe1cf55ae52917998ea5b01cce7ceaa4c3e9ff2506ab79e1efb4772f268e8e82634b82ce62032991a4fb9eadd46a6b00bcdaa6aa28dbb2a2e77c728376d3766957e0ef65cfbc70481aa0208097441eedc04166634f2c252f7fe719597117f8fcc39c623c3ca8cc60b3f4e3a0ebfc280209f144900dc9654679d774dfd6239c086fafb4e6d078efb20971343ee52712ba6680046a4fa6fd364f3950aa45b8ab3453653d96d0695fa3dbb3e0dadcfbe79d06a3612384afd51af1954e4a7ae44a95ecb50dae4c6161caa7278dcd008216a1afe9d9c94c13038187855f892d69a1845f36bbf1363fb69b078c2927c6f3119d0b1b7015bed5b6839bb8f3d01c5f200a34824eec00d481c386828965b752c1f1e8ccf900c6e21c90aedead12fe0beb0c308caba256ffd62c842035b5c323f76642f4acd5744fe94899be0c47ba2fe1121b9a754595490bc97057493831087736fa96583a802e7b10f3623b2280a12d07a2438f424bf57723e5d8e32f8180dae6f573c2934810c7d2780123b5f093e3a96201228b4e8baf3822a8b624938163a4add8ed4b54b5f92bbcca84cca5c5e2cfe27b8fd62a103ea45a4af0be3742c8f6767576e942ed282970993c4225c8f45d54cae8480a6067cc99e014ff5e6fe8d45f7222c47f8d3ec414ec9c575001c4ec4b1af7b41339ae3c4a058f10ee8b713d0172de79ed7317d5d0807a3c7c7b5bc5b24126f765eb309b2c878101dacc52c3eff3cf5f77fff5dfdfb74bd8fc9f4ebadd0b6035eeb8c7bbad78045b9c6134f7149314310f3618b3028924fc3601540570f016a41b4e5b1980840131855a41cb9826b895a0b9e25a750cbdebbddd5494ab35890b6ac4101c5bf220373eef5bd5f9093fa049d40e53bfcbf7706e862e5f6b1dcf0512e13d339bc38ef9c70de32f6ad7636573e9b578b32e487aafc279c55b4ba999fb1276f43e64c5fd8ce45b4ce1458c322f03cf5ad7762aba7715804c5a1eab58bfa3cc97eda57ff81a3c2038ad0ab5d92bdd81bf5c814332b10eba8191026d6f0859f4a2c0c9b62d0bae007cc4c36e82459d24c5a7c30e08cc2b9e8daca9cdba25096f6bc14fde58656995507f3f7df41cbad446ddebf5f7dc8df7b1c714728c8b9f52c5bb14f667d9daa88bced07c15bf94d720c4c29f679e943b819b3c893ea71911c27489e04db5ed893abee64cfefe4c654c92d25e20caa9b6a7167eac3a7025374bf5032fd07938433afe345927ad91bb45fefc4d7d7732eee5d75b78d808c510f1ed27212c984fb3d0e74e2ca6822446bfeda3deb2f7654e73572b2358413b57a8df82160009bc8b264099f4eb36164ad7108fc6f2bb9aae9dbebc0db99f35b3aff2e4f193079c4af265193231283ecd472ae13002c3c5b56e252d8a7ec341efc1b9b5f77847e85be627fe524912c7ea57aa49d787d7900cf45e0cebbcbc5cc6ce1b5795e2603bb49700790e8e6b9d656c12fe651c9a5148ecb6bc1badc122f7c3fadf88e22bdb0333e8a7a57ff5425691ab04a2489e1920fc93238f9ac9fb321a5cdf2177131683619b8899a8fe794ad991bd3ce46f50cddbcdb53afc3c2d38fa56d6f410184b85eafe54153830494e2df2556e926dbcd89e771823023d0c8b5fc4612266fa1389965a9d7b9c3f27387a59807b222a9064f71a5c7a2247587ef6cc3419f2ba3aea88f389f6d072deebae8cc08a543092bd98ee66dd19f26b196c8d4fbf0e8e8cefdfabaaa7d9feb851076f873b7598ae0bb9e5ed22745dfe1d9b3d8909e95746e16b28df6c4e943e0e2108fd3d9ec48570d93caf1de836fcc9b0514b8f3f67073a6efd4c003ade6183f4243206dd579673d6c2c0b39e9866441d9b16dbe80d545cd153b1e8eeba18154187bb25c83ab1339dee1b5b0f3b3237768258c6e6abe47c67265452a061974286854867e1160e5b611b7a48a3ef006f1495e6c136aa12f10cfccc43198531f05a6eec5e181841d2df0d6ff9a081cbd32d5690ddac67a6f5058554bd0fe300f0c2ba581029535dc4fb53d4ed82adeb53805f30f6b7ec3bc4212723c072d44a97f48bbcaa0f11d1725f7dcdeb060f1f344ea4346d3ff43150dc7f5cc29b8f6e054e161353e85d7815828630e01f22913818a3d1434f9e7cc1bd53379391b7fbed9538b4c9bb57f46666404035b07c33e17edae81ed3c2fd8f54356b2e9203a3e3a94da10bf0cf23f105f0c3f6c7cf465e8d44f5c8e32131da1730eaa2c715798e4a21080ee097696aec1907d669d71f1ea48e4a4631afad98c35bb5867aa3d37d158b9592579da2d59a0b50f3dbb44f32960ef303c8433b502841557a4ad9637b6965bc5d9a9e0cf7d50245b918c938e60e47f84e0ebf73dce74732d914d0f583faae026c938946448ad5acf118b79f9aabe5372214c0088bab29e113701a6e4138396b78534b4751712d7b940731dfc26f93b3cfac1000e6eb779f7319e956121082710b3ee6554a084fb31642944cc6d18152de06d5f42d1580c76e48a4534211f8415ebdc2fc758f6afbc560c0801119fd2fef7d4da87aa96b5dbd62258abe8f48446a20585f2a787ce182ea17fa895e634fe73ccd7c58986bb4f1e6251c5cdb8c203b7d8e7b5dbca7e40f05ecc5f045eb3f6dd1d6fc79d1ddf78dad44f876d3de96625d61fb0d456f0141d2fa4ed343592c8e276197411302faa91d3b131140a4a98681b11906c1d44bf501ce8cc3c6412b82e0f7e89a498601fb3e8cdc1442162e67e1f5945978add52a4d5a9dd42be2142dc9052f54aa295d63ad686db339069e42cd75141b039fa1a1f13982a9647804f13fd7defd08351e4774be428643a46647b6c10a5168c3a72dfb49f46fc2a77a285faecf73e3a2a845a35b432135a0c76f5c4cde468fe9482a1c432465b68515a3581bb0ff2b64dd745c6606cb4b2cae13c17949072a4b18d64c76cc6ab9652fefe4daedde3883a553db96535c97da472a4521cf9f702c616649213cdaa5722df95abaae52b2e9b511b6cf2f648ed93774ffd2865988ce532ec048de90cf26f33f98698cde72488f2310842a98c7b7df6759664b3551297d34dbfbae0efc75a2a567e48aeffece49b801cae9fabfbd7cab3ea515a015ba48bfdb07308db3e9d4d6dbb91909e9d0ec8540a31b046e9dc7a9ee16b9eeccea16520ede5e628c0d4894033744e9db3af4b41f66246ae1769e813e181e979772ad4cd5e27d6074bdbc0f556078a7ee922dec1c8981df016e90d8ad9719ca1b3db23d175e6233025fdaf352eb524154f213ea529a214a19c220f38b4c5c6082d0b566f5bfb436b7af6097abe7bb40e56d7ff411ff7b6be8c0529f13e07b6bf2b313f703aebb0284411d4b20ee8b28593051cfe2a7185a422ee5aded0e718e7529a1a76e62ddf86db582e23f58f9f87ef59039f457c4819277f2ff1fe6ade34effdc4c7fabd81432ce55ddf80a97069b7711d451ee3dabd451cd13bd13a8d246bdcb29d31a9f8919371a6bea13b4746def7ea7fd860841d0369b9920dd6e96676d0d199e44a9b327ba39966c1cc3767b95e4f0647f5db4e164dd1079a0294cc34d5ee909e5bf3bb3e017215cc79610137980a0fe0244fc577fe7e9428c7da4faf086b50cf61a35702dbc83e251d20943035324fbcc82a86431b2902f1979b9ecd5dae9a8aa16eff59ebd9cc023ee5a8999b88b9a585e2bd686d09f32dd8650e0a4d3943a3851f604bec7c7a1986a158aa0dd962e2eae44429b90a21061dcd682c6ec1f41ddd7f670b512b6b72163435bae0e393495a01fc39bdecdf8707220ade652bfa5ee4b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
