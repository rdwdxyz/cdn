<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"522e14697323895ed7e652cc726d695c636813d914e5e31fc332ef1a7dcd4a287fbba108e9e1e460b156d1c3a128bbc5ebf77b933f25e3397ab6212dc571d0f11db5eb45220fe51ce35d0337a25ec7222c353c255980ea67ed9ba4b13c09466f6cf4d6966baca44a4ed207f0d1ef220cc7f3a2a5af14371b9f903c6fe62b462a236a00ce5b9670fb7be8cb74faddfc9d9178fe6a24c00cc23150fb9e8eb6b88aec2be115d7d49f6a59a2ec2fc7b5f0413704e33b381e06b906d276b699de6b352f4b6210ee635214d304c8dd8935f868f1af12c979d9846a8daf1b0ba3aa0339300311c7fe6dbe01eb49ac1e899f81a3084812f5550a097860b1f19a3cea5f4e845d9d8dbc1ac5f1219978bb66d6995820a8cb7c58c390925bd1f35f917614cb7a05acf1db14898d1fea346f27b90207488cb78cc260124f5d5449e935908294dc2bd09f94f6eb1f56cb500314a2ebe2afe5acf3968d87c526673ed90d5d0d6cb9c5e78d5f5c5a242ab27b471e85efe9b15dd4aa195e912903b05e35b0838a46cc222ad02b758157130ab2167bd7f21c3cc01b59382341afc4d7091fe6999da9cc9084218627c5baecf13628c62d205ce8de2c1e3824fe39934cc29aea56d8957a725b6d9e96c8b384269d5fe76895d501f9feb0720ac4eeacc2b45cdc2c4ca69d963629bd73d6679266375ef15c10d141eaa3730cc66835123208f4333a4ee23b45f116e5aae55fb117de8ec875bc98df9a2c979ac0c8511a5dbf418b09436d989ab99879710af4e34a5a04e9554af1b2b862f755cea05a244cd1a598571d7fed0f1435726db1afc67cb38748007d20d740b9ba30689d3623a381022a9f8879faf38dccab165eb20850f3c49096e96c398f3b4aad5836045e299b24456fbb3be1176711475f639ad2945d4041a76766bd4c745aa87377fd54143e1768f26c8ffc0918559d48a69003a7bdaf12018e71a92d2d7eb3577a6d8e6ce136db6c9a4cdea45a2f3f128b829c2369e8def8fac800e390ffce1e5c5b3cf751d3e4fce1cb0e73878e672d70186459de97a1705f6fbf29b86de1eed1c2a52afa410ed6505542f6fa0bc77e894b57425db18c407ad471404d8e55268b04a44c05653aac736d9d2d27c8ec183aa5b1594790d5856df0493589403686decaecf4cc855c740d18ffda7e73defcba23aeaed1b2259063b95c937b664c473842f2d9342dbb72d7944eb13f6751d05cb76fc504e87a2dab5d46bd9cd62a8767acbbc2b8109d36f643547b6b762f493f6f008991c32df1b161d569740116698633097e3883494566027ef11091610c9329a0e0935d59054b866912679d591f8fc933a893eae9a554552d57ba0bc2d92d4fad5ad0b3efd39fd3b92069e0418807d1095769e4d9887e6a6b763df45b926df9b2f4d5dee1033717d09c236b73f74fed587f5c23966b205542f3e71062d96dc5b4eab90c34fac07e04eba43b49f2af1cc5db0070416c443339554e029a2f9955298ee2b6b5f523f66f0441516d5e68a06fce46c93f9a3b15b60a521c4f3dd5940c4ba1e7003a09af2949b65b6fadfa25bab71988860055aa048b01f72d8bb1bf3ecc7168ea9d3bce87d2b98a9effd5a8ec048ccdc9d8f0e80192568225f8e3362f3453b4d0d4a329394d3197eb00136366bf6375d454d6f710bd6ad00f10624d2174488e31b2a8ae7ea91b9e5dd935ef08117bc96fc29e442d217fe3c5bf6c7d3a5e2f84d4e79ec2ee4025ae7f38d1ab400d61ebd0c1cf2424707c8084a3355409056532e3b63c3aea611812422b7334537cd3fecccefb5854215c929d088dfd30c6c44ca082cafd93d889f8e58661035bdf76e9f2c84fb2b51483b1c9ee3305874c4f0d2de8324940a3105502c883426518f35235e14fa371a012372c2ae246feaceecb79e5d2184fa7ae945fb04007fd7eed685bdf67158a2032cbcb3ecea9490a06924e753172c275fb57ffe78cd5f2f258e7575ac23e7e6bee0822e84bdee80c6736d7dbb894d1f3affe5fcc3d0f2e4e9681e316fb75ccc8aefbc5fc58a2a5382164afcb523a30671c1f2b9e7dca0143014708af9ece9131dce4b1af258b2b7c6e3f7e0671f0eb59a4435c314c4de56352a0253a2cc7618a24deabf1bba200e7f9125053ed430887add82f9b77db2ef627501b9f90e662111833a3831697c3218ac8103040c475bbf5b72e40f5e4ca87e8061b61acb142ea08bb7dd29cd6690e8a9ad1998e2981fa8fcd0675b7cc5aee28343cbdbadf64e2ac236dda077bca1a9d692e6788b50c77b10a4bd0a55f2e27503c84d91c51036de738ea322737ec91f6235d907f504ace512f36c8ffa0a022f4b9ee91820f581a2bbdf68374a3963952ad11d2e759bc1fab52fade33305954b52e250f37a3f5b59d9d88b7213885497929a75cae68c05e7dee75c09c486180b6f79e95e9942cf81080704266303f78764af5ad07fd4dd626fba14ee81905508bfb1a1ca9636cde73b6c867b51ea278e4a71036ca8833f3cdf606d097f8cc894b9078e371ad28eac76753addafae4cda42834654bd1bc917a101a398ce1913b76461896c9b85f7cc686755c6dd2e6e2ecdb7d55a58136f112a48024336eebce4893c9a2ca8aeee57d15cc6151e4d3b883f4b5d330360bc33278fa5e1958f14076070e8024130379c1dede4892fec01844ce538fe4d05d02e4cf49ee2f84253cdda9fe8db3d6be26ab716f8b5ccece512a252980e55c7e5a5ae3079e73d521f08b45f5f169d8569f4d2f146708dc983a22085d66ae8d9c7867bf1abe8767c4bce77dbc55fadca4f06770b687aa9f65fe5f58c3dc7a628b0593dca076cd16c4329d0df9039f4f7248d995fdff986d4bb51f99fcc7badfad76b9aa538fc9e2933a126403f4ce64cc4d17c8f9acf9d62fc48a4ce728f65a25af9ec5a1187db635a97d7ecd9269d94f130506c5893bc10531a484af01df75fb0cfecce55c384f460bb01ec95eebc2ff3a0abf40a612bd74c7bfe71ea1b6c13c869290bba0af0e5bf6cc13c27346f201503cb5007f2feae66950dfd89d4e1ca7f1cd80e8016e8dc0209d143d341d28393253e2a5eb6d63f35e7fbc976b13b3468d418830982741ab16b3ea2ee7b7732c9bdaed072b4112debe0485e8dc7cf7421b6e3caf29bb2681722f18b9b981e8e338c5bcb5f58861e3ec28a7ceb1b47a206d13d9f23ce97390a22314bc9908cdb4517ed9a0ce38c842a1fd3a314cb334c7964688378ff2aeb88952d940c9e8efa0913645aeb292180c03be32931d1494ff970342528ee4b6fd66ff9610ac499ae14a43d5716d3b17c7664bd2ee8808e07c39acc14ec18a46e87b3fece5f26da28d477c95a403d35ee83b883b21f69c82c17d8adfddd5c57b39093c1d5c61200120f2532182cec72c34ec2c25dada35613f220f047cb619a685f6b06409c84474ed44c0f280f91831c7b0ba03682c3e0676ce9eee792511948913a7718fa06b9668ff40ec1ecebdac8b0bb669924981ea89684f0dd9b55fabd6f04a75aeff36edb78f627b52d35ad8c18cb6b162ddb45117d4810e869db93f3f27098d43a39d94dcb5cc9fa79793634c3ce390c6381954465b66bd72b2b0ae5f72d4e4f9e376bdd4e1afd6792426e49df37f3d8e813c138bad2565c37d2964984a02a271df3f99e1a8ad791c1363699b5e11697a0276707315ca7e5c8778c943599e4050bbdd1f0e8481b24fc51583716dbe14b44f04d376853e1578f7a4bd743656e6bd74cc88ddd43e05c787635fe52bf8eef309412d8730820389c0faadfaa0924226df858fe2193526651087de2b89c8dc947adc6d60eb8d874b1eec9d8bf087aae5e75229e060dc45802e85e898e5a0a8352c0fe18fff543d087eacf7b79586e9f590847cab80ef02091c959886cdfafa95d7aa1942f79501e4a0fb661ca2784565413b56ddac4755177688c3c827a8853c8d1b7b69bdbf6bf5874cde592f3baf5c7b66716e1fa5d4964e274aa64b3acfdefb71b35b9603d383a56427202042411e77a72717dbcf1118c929926a05f94a9b5de0f713c9231f6a756e7f0336ea9451faa5d0d2f44722e5412a11d961ec6b95130a5f7470b30d05e2a3aa421aa9ee6b4c5e036e1a2c8b576647dce2d0c1557fc55dc33f71fc016465b75e46c2bb2779c7ff0e580797dd7299c406c57fa441f843aeece2c7a8f3ba0054a2b258491d145bffcbea2499da4b34e189cb31df0808c411261bb30c09134c9234eaa02b01432ae80f2319bfb4392780883368b27d41cd663ebd4565140a6a3403c7c2b9afcef15a13ea256f86db52156e15dc173a92eb3094bc26f0d68a1d38ca23318c825de2659c9bffc4167aa8eda2baddd156c6ab4895a8aeb71c3bf276450d89ea53017827b613ef851925f65d9fc07b4062981ceb4972ff156cb6880abe0a19e3a16243d3c2a520e66b5cfe2306ad2d9265b41f9fb38f0ceead0e890d3e7db8a5942501bccaf9259e63fd2f73aaf35a7270f24c2e602000995f4d03c711256d33da35a457672949b0d1619313a346ad92519c449bbec803991b250140c39fadff5d65ccac1bf8e1da42ff73695b05ca490daa2cb414693ccd36f08c271c0480bc0779e9bfba46e3f31bee094bea52ef5b6ed8bcb945c42ec420efa67bd747800f6ff5c6f9973532259f4e0838ebfc0c8f0b6f0585a663ec9a3149f58f9133280b758e1b44a82965b4a966e210bea1e923ed257dbd068b84559cc0d3fe22cb7548047cedd85aa252a5a113dcba612189ad87c58ac1405fdc5375363cd3edc9c56d6626f241a3c3ba5dd8c73127305c049a4b51b9057c84869e0c1a6110402365846185209a7e608045426eedb202d4702f4cf4cdaecfc30431cc2bfb5b623901fa119e955ef68a1d095d34c29e6b72e3e09e0ab57786654c2f508da9ba019328154ac3f4d5aec933a9d0fc3d9957bf76f098b42afe3dc1a1874198012bc83aa4450951a4f9a2bedcc8874b0046301a1378cf943a33e773eb3d57bad9f7e4ea1dec021a4db57eac322b89713b4384dfcb8091ee3f36eb12a221842bdd0e5f9dad90f77df5a97444318e63633d9f3960d69345cf5ea6c489510434da3f5304489195d06b338ca61a7a9196119040187f6503a8f5a73cf4ed17603ab0540b03b5530f309aa1eaf26aecb9e04666324da5626a63c8659c66a8cf52f47291861e74249f292ad8fdfdfdd6d4f7c65e31d56eff31d2289906722cc4946922a885d5f09252de9443edf51a523f88455dfeca8b5388300aa8f893462f451dd31d2e3b247eafd0088b4280a922cd316a083ad400bb33bb6ceb07f4d3f33a27cbe00f212bc0054f31398323de384bd7e0de77be15425c5d2c1055717f2563cb7ef098d931b9b72ec2aa4ce02ec1aeb4a1d5c279eaf9d8bbb60e038c6b38cff164f9dcd6a326784d4ec2ff0a3261a4f6373baee3f20f0abdd2183ffd0807db75d7ff691bda4752507a3dd21868d6ed209726d8d07120af141c543cf052ba54fcf8b54da09e4cac00993d498929b220b413a8b190c1ec76365284447587f8f4d50c227a367dafd5b5f29f4d03f2bc42a63ef7ce6854b986cea5a69cf92860fa8f20c77e77ae98e6b78879af6d1ad95ead4cd931cb39170bf813d8a86d1a51d233b42d488770513d9adc838e371293e206f130acf633f174391fd5cf04e62a7f46b4100d8443bea8189d124c5b79b85bf418a1fefe71ed97ada62b32ed212ca01eb11636e2999fd41d6a8db57af924d31486d9decb594909f4d19d37fab644cdb85163b7e8b94357c1fd5fcb1fc039bf240b7737c89fff9c488a5b153f3bdeb1aacdfbe55f458442ae323769f5cd78c48f85c927d7c2b043b2e1fc06b109222f2d55bbcb70ed3011824ee1f34411386db52d6ae2c4ca32fe3ffe7d1d172fa3105f9108bb4c05f4c264295443b8d60a3ca8605b5f03d55b68c7183c302ece97a2f1385e880b6af02245fefc9abfc7ebbc496656497eb5da237fad0b966a34ad199736b1f5cb36c1f29b458e5367245e35cec21af13e5f1953de65ea271d4ba946c21bfc0a06f72f8fc2d4beca6ec1bb65de2df9c96d45c56a08a9347325e93bb10c3962e928c8232c659143e6b731f6a180bb84d291a5d59a729d9daa730ad98a0fea05aae641deb340996214f998918731f56dabfd8b9071eb18f9376f806230efb061ab0ddfa4c7abd257afbdf8f11bd857176881739052fd619bc54683fe363f21006e462ade41cf8b3b55a3c27450a8e4521ed029f7db94ca34bd8d36f958a6a5ef4c83b4220040b2647e2bd562c06003b4732544f669950afce7aa37b44365459c93c6c60b47481935cc42a1a1566b7cbe30cd8d6dbc50e58486972616f13f67f63df2f228478cd1b47e8183e750b9170ffe1c66fed6c4ab7066112c303377b78f67e7b2b03b8fcf17845bdb64d2f7d7945ca2d08d2ef772491879303ee82137d04aa6f50189943588806d32c3f97e4f58d7b98e5ccd082e3df4547838b25c71ffa315ebdb948d0513c3bc5ad73b601fc14f69c4f8cde60a2a5f575cf5bd78822cd370c90d84405f386db6a08f31e60abcf0c95cc9bfb8779f43c37b34e692181a5f9d8d92a5ee5736f65ddb56290046a26728ad4fb9e07fff4d234c41958ca7e0a780de03676345251162778c63452587d482ef35b3148c1e0d583cf470b765ed32375e152f78b3896807d242f6254598cc8b72f85b4d321fe7f7443099bbd968255752f6eee63797d2caf887c55d2cd07f8af8c72eb9aca20fcb483fc77963a58351167710d22c1a90cd0eef64a3df07d78953b51712245bc903d9ec9f130e46e4b213ffee1b031e24e6353246bdd3d01e86d850a3e3474a4b14fd63514917d047c2635b035022ba2c08ae83b2c99026aa1148df448f49771bb52ab79c7227ab05aa5bb4ecf6925b770498749c70fe7880f488625406cf8fd554b9e78a2039c25057efe5df227aa874aab2834c9a3622f71c4200d3fa874e71728984a2fe4e580c1ca6056c705567b4d5b676a1457e1ab5338f4c39b2448479b27a1aa489bd9c6a4eedce4b82fde34c0e4661eb52ae05de67988267c1744eda06dfb6991f7fe3cb4816ed765154778ac81e541a7e70fc5364e56a4438c1c9c0170b14a40b215d37446fdca080690ca791dc3a0a9e44c7e51aa4ba713cab386b0358663f63867a4684c7200e287649645d5ef6b6aa97de494d6946b7e9fd817cf9e80373163361c5c355fee9e7332b8079d7d1533a96179cc5f745b5287cb19c85000ca7726fa97868962999301de84f1ce52c4938e6478c61e5a5cad68f5b9681687c7e486531a56fc7ba5cf142725da5e93a893bfc0b46bc0d0579846295083bf6bc2be8801d16c27b18e5b0dc3602c880bf10ff8f588bdafe421073c2904aa0f07c1147c4220e861a044db7586fcdbd7d3256b1252674304bb9e3f2c79f3bf9f09c5b0b037d9e5cc9423ee94319a21f7bbe5789bc444194860362446317c755f5c49fd0f351e28dbdb384fc348525c044d9a5e87a6ebb5dcc67fd021063565d9e5c5da62d7862365abb0946dfb76be8ce0e9626ba40b10b658a606bab607c7673e77adda6188ac7bc2ba9ab5d71e64c1ecbce7784f23829a7666f5ab103ad994647d23a9ebfcc3b25c009307315a655a7b282204523bedab337c13bfd192bd1628c0f61db17f1b32f044f422eab7ce56bab37328f3d5dd45562f42d57bb21d3d382b9d93ec340c4a327647fee1d15ca914202d6ec86238d8470bcaa4297aa6578e2d5626845bfb992bd91ae4f24aa79cd981edddcec8bdd796bb55a18f653657673adacd25d5c406f01f96a4609b12fd1c74e8877d90cc6f1bad3d8a3ba1884308c90f508c065876b3edbb7cd64641a2a97e7d68ff5e70ac3ad00e4f7dd2ac9ab4465c386ffc6e1a12170c844c69d9b5da93507fb6bb0ff815d5e56cc4fb98990654f3d0611f362e3fe72efb4422b8ce72e47e320bea510758e5a27b942c1f377f6d3d2282236715843eb51d1544cba072a46e2f277cdcfc69530a284a0d59b257d774b45490983bf5e5c1d6c37522ba4a620ea033fa4b70d978459d815e6b9fe13cfedd80b1692557853b8ce1796a048d28befd683910a366441983b4d057ec8d6d3baf7ba5d27ad4cee0f7d35d52523710155ce9feeb9d198199aee7b3cdf6b6bda03d527dfbb00ef1ef6095ff8ec4416cab4e9c6d9f68c07e2b3eab7ec6f9d0dc1a33736de7e942012cd6a404ce0a75c66bbcc72d3f48c419bf71a20a82c591fa7ca2f7a88372517ed028e7287fc610735b241985facf1596f9fa487459bfddcd7bcd1819092961a1c4c1af6ac9ec7004268e60a059c2328dc135a809185b4fa8435c3bafd63a5ba9f702531eccb9dfb4b41670778ae176fe22ce494ae72b9293b29a0b5d222eb4a07fa1194ba06c1fa23589d4bccf6a0f6d5d24b760b6a87ecf98791595efae7af14187cf233fe409c9b0e731cbfbf5fce5c5e7442fca19910c72ef33a66245b101f5ba55848592da2699782b397cda6f9e8afe20e5e17047958762d8bb4201872948323bf8260f691cb658c37f56e068cfbf1b6604d823e5be3dc49ba92dd396de9e52e6314e6f927144051ada9c60fd7c11a43fddc32cced9e5f5950f945091b1c3e29929401827527e4140d989a4aa050391e7feb6d5a5daf14fe30af9291d968af887a92d6a073356ac0697cac3f08a5872838c4b5a12b1f986d928dc2e4369768105feb4be37ea2dd2b952b710646c38b659412c3e300ed46a5b95eca7f4f11e594186e0cbc69163d81993110b6df29551559b0946b3655990d23129316937c681865232f80fe731b456d1d06f18b2dee5b09111da47059959475b47e143c98f4845b3c808d36727432363d6eecaa059ba69197eccd9011ffac1220ac1ed5472761543c4c12ef3eba2a052207ad70ceeac6ff76e6d8fc555c32226b90ac08a07def76f986a604a0e65a399d296f52632303caa4bb61b63d1227e64a11a94e41d540feea5c610c1786ad8f57de2f43af5540214fde7ee977e1c30e2b1c124bf7c9d9ce33e892fe6e8dbf40e9f7e2109110b9ce1e9fcefb0f3cddedfdf8c407fc20e207aa8bfc1b4358133204311451141b14d0b3c6ed1f5a8222258635e38ff386330a6487147c5289c4fdeb833ef9505ceece58da2dfea2905034b778b292255143d79cb16671305a7b801f84adcefc7e0806f53b7733f4bcf44a19076a35065136c70ee6fe8ab9cdea9ce823ddaf1b0ff484e04d9cfc22801402789c0b10f5aa2e150144741da360d005dad9139e34e99e9f2fbbb58e7e6d490b6761a673fc856931177e39d78191b9323d004e3f897ad91197dc0b4f6c2b559bc307ef8ad63adca5f5dee9ff32660a1102491303cf5048a9f6f18a51d015099197a1f32b13987020af5db4d5890d456d560b1f443f61d73f9da2ea150bd2710db60f0f8a461549a5452748c950cc1f3fa8db7af6db462a07640840b1f5dce114e634ebd94e1e77d27cf70f5029041dbb7ae41396027f7909783e7acd833cb50e984cfd795a6e967a1e9a09433b9a861643d5de5cd465722eb13440646e3e2d5c0e7647dcd22386354bf18850dfc4f278657197da2e99a87ec9db2fc7718983bc4676392d32d886772d29deb8c6247726d9c0e9b68c59bd72b1ded330ec5b8acd8a4129f85db47c647b270112ca113f74bc6b6ae9b4f7f9b1e1527d4ac50a366c40eb5f1ce8d110c1fb76c868ea67fe3f592e1a76c78aa543072bc73bba910aaaa70cfba289ccabca9f9c0e2fca49686ebcebe8bbc208958032fd80f95ff83d53fa9e01ccba470d186a333f594dc4e3ee3f65118bb992ed0a24a9219b7e969cb9a385659528d5c0c0807ece7ad16cc9189d79a9d77cc281624af260597f75f01add3826b4f62455613303b77572c1fd36c6f91a3e53186cf3229e8e7361be408b3fc051743705eba1c20933e6b98e64eeb2c773066b3c81b49a96c19305947499d1a7348bd0c37bbf4db6fdfdf6e98ea0781db151ed36a0484486d150a7a76d9503bf2d6fb3d85694c19a261b29a6df9c6ce6efbd9b2a0720b183d9b2f74982d8136500107f99ef3f647128ed8d4759abe9b8923be8364228ae69d14bbc185f2e93b241da4009abbd21c6f98f030e29cae775b38f7aa995fc5ade9de3999642c5a1cb125fbc7b74ac650d0e0d1ed7831d2174d130bae652ce69d131685b891ca59c76045cacdf985f07c54b0e76e72856e97a3954fe349114a1d8edd4fdf919a6abd164ba008c3cfd1fb78d1eef02a4397ed7820e3c6d6994022a8d6fa277677ee559310d26cafe1311d1cd5f985d6673415395a0bfcabb21f58f0c731e0b81736bc36f312d1a372514a49605135b4d4d8a990124a2050e8ef2b83342fdddc46fd8cd2000a001c01bc74b1622e72e92a6dd737d18d6117067c0e9da9e59da0eda5ec08ee8ee6297a6e55b3b2379eaa46358faea10a539fe02327e317005498aab812dc1bae13dd671d4192935292f4733c6e2b725ac1ed5a7fb7b51eab0f78316792857f41dcf39b766f17551ea5e2ebf44e5ec0de0fa60d9a1ac8af65f3c2465ddf97e3326ae898276fdb0fdf86dad68c98c884c9daa4f4e33a512ab4d265b7d325f15a2fb272b07ae9f34ad172a3e1bb23561fbc5d4c19b537fdc2d6a6211b437a1eeb99b006674eddf11667607f1bca5aef3b091ad1c5d9b8c8280a7419e356ba76d77b82fa0f9a6a7f3e6f9b0fac8c9fa99797aa5c3fe8024e2213a51563cc337472b091e787eb9e5aef3dfdb47320b784aa85f91b0907721ebaf4601d7fb9fa115456b8bc36f7fdecc5c7ad41d56c7c366c361fa232948b0dcd39f2db4c407aa3bac0c7c14700feec5ece685804f4753947aabf4276d072df0d57c3fd97958341274e59362088873dbead49248905b1208d74de5d5238ac9f93ec9b1de1f6325d853a0cb65c33094b513bfde03ccb3156f2a9ad9d045dea2172183de968b9891e9b29b45b33d734bf8cb58aaf4a033155e713edf174f1418f41ea4e03f265e595ef984c6f139de6e617e575c6c731c39567c1fee60884dc3458d6aefca96a38a5ae9e825588e38327e8da9fcf2ba0ed21bd8251ba1fa64955023b0f293ea85562051a347ed7f4e25a5abd19ba67dfac085aa3f6b8c0ce9e8434c01903a52e1efba990b762d5f3d11243c5b3c9eb5c3dd60561dc23083067a3b5a753e8a108354016991bddece6ebbb48e039c71c97be46a40dfaf7cae3d56167692c6e555d0b6886361eda793d187d894d7f82483c82741b6852a32306c3876983678889a90d11cd5e66393382788bbbdca4a458d0815459456b9e80054c9aa5aaa6792324a41c09dce9cdce29c22f5fd068e9cd5445d5f49f1af1d7f36f76d36c096e05257f23c118ca61bc5630d385007327621d507477206c6a946f1d473fbafa203ae2f975a14a6ebcae244d2cb431bd72256cdf313de9e68d16ac9ab4f878fcb77bc1ddfe7f17079b1c7a632ff489bdab17be090a4cc8cbcda961903158e1e58300bd9cac2c371f5c09177b16cccb0fce73dbcf459edef0ebf150dfc606da7aa304463877ae04aac073d1866edd0249b0686dd9be68103913b0cf66ecead37a12b272008c5f081c27fc2a012bd78ee4c30cd49880e68f932fb0eadcac53f005560cabf868b002b2b81b000071149daa5f4ecfc7955f88d8967b56d18cd01b68d3734e319aecd3226cdb01f03cce103cef2ff29ab9d19ad23b5b811e0284ac73baca4943227fa3539167471211ee0b5003166b73be8e71ebcb9575f3b253a57b418f03337515a9bec8c27d9e37f376f3f06fa0c3bce54e543c2dfb9b80c45738b07ae14b18f5faf956924dfe90de37123500191436f12f1ff4afbd7ed7f19ff40482877f8dc5356a58bc24966164d70370ea49a76e54ac7edb2b6d53a99d4e0a9a6e8297c73512a3875642d9e84979298c45fd1148cd8fa4f96bfddc25073c103b9e8ef25c025f2b7d2b19a5d53b88ead704cb4700f6af8de6d825911d3b61e76b96ddcc5528457b4d15d9e4ba3d8d760ebd8fef926c8f0f76d1089c5916254b1c248a05541bb5fb46de3c040b2beedd0f6d293387d9929a5e1823af92cdb16e394bca084eb1ae1bec1416542c51345fe011ec0eba6a0fa92f9c659adfd210d0ea92e6b061dc1acf7d01fe8391d8fd397ce6dfc2709bcb0b147048916c6c1826c36e220eb3711242323d759dd229a00e1cf89406d03e6f926e1b2669db6cc0b306727e6d8fab82752cbcf85b3188d7fe40e801078d7f58eb7eea634f02942beb9f9173ac46fbcd6feee251883020c47017f54d7b16a84e9f82bab2cb585f60ba403a3c333bee2eb6837ac2bf68e60b28585e03bd69f4852bc45db74bc0dea22cfa9731de5c73c4db9c69371cc3fa3afbf31c790ba613add48c20294ab56a41af1427bdd831459cc2275e0f8e64441dbe60e9c94066f8e7c297009188073688fd71fa5f7f985a54b0a510b35c9f9f3ddc7b26e58fd3db928f6b852fbb4a9402d7081682020ece52db7edc79b16e7209aaed39d353054a170675d61b04a74232f4eaae6ab3b8c06739274f4d55e3c2ac82e42b694063af65a73c03b6364df59568dd421791658cb1999bb8114b50a77c68c6fb30eb63c9540af8b627cede41ce39f1444715e94059b316f24f280100d25dad02a97e7aa26e469c7040acb328d5d77a47cbd044a7215eb821c2443d4671c628bc3f2b481560760418098dbc0125c58d92e2fbd602eef4609e5a038187ec7513feb58b71508848b6812b1b36a7be8a15bf6066a7c58233035ecb35bad4ae28b80ae209c5c96d4d19a2558e006d603ba3eaa4ffde45d58329c21233287ed3ff3f639627e2e0d73e6d5db228eac86d4fdc5c6e79d735370893d399612d342ed5e796d7368cadd084d5f4da94bc54f9e1694e4dc2656011f5c3d3c26de79d161acb7fca36b7dae1407edaf2d2ec90572ae4efecca1656dfdc2ba93f07eff1d819e345c67e48001f944fd46d68c322bd3b230f1058a61bca23ceadf05278794e5d9a07fbf8ab67e55e164b7a9d2709e596ff4b0f752285351534ad7c08904a4bff37336eede19f5afe408491adeddc03be44b6bbd1874ad826a7e3e99d94798dfdc0fa743303f4b80ccdb4aa59f2b5a2a352318f8b462a4dcfc0741b65b35f2f8aa8534b9f03c1a7da75eb00e7848aa7a60f09bd2ea8552f658cb3b02212c4808ab42c1042639e7fa0bf270986ccbb7bd8027675c14b7180caba6c6d14cb71437937668450032b09073da5174df783af70897cac8bde7097d03139aa5c17a4f64dd952a30de27d52f667f325db162602f18bb4e2fecb35bcb9cb243d8a28db5eee4dc7813d75ed75fcb2e2eb536fa76e1ae47eb9922227417c35c638f8b6b9b6b07ab0c2c54c447083e3eb0abdc959d438ad2446e283f7e3aaefa21d1613321b3db9e77371b8bd36a73cf19aa47e43ac869599a4f9eec1885df26ecbaf2f7e73107b02c8d248d6ca9250c1c7445730c4750f9402a78d14fb3db31afe04e9bda783feacac24a046dc4bc775c852c480c552ad2e6fdd8fb174a9e89a8d9ec212716e1700a413cfa80240a5859942b7fbfb0956f7d0c1dd97f4682b6973a3c55c9d86d10ed8f86c71b1b841e44f5d32f78d67acfaf83c9602bb8929a5c44dfcf10a4d8bfb46b9e2df4a3d25cae8ae6b7570802cebf1df1dfbeb1761cb123e135c96f124306985897992ebb2406741e1be4895d0a6b3ede9ca1bbd75ff98251e5f335c316a5bc4821522bce0e44b38641341dfc4c80d55e1af6c74077f71ce751da9ea6900695c2d2ea00dcb29a7673a69907eaf37fb9bb84a8cadfbc448f2ae03ed9d9fb0057c179691b16bf75c0cd1f1732fb0c381845fec1397ee83bff4f15ecdc7f3b92cee85adeb3ae40b58cc41ccbe3e1d59b0893eff11dd8101aa6f1b9c2c3a30ee8275a8bc837e9d20a0a8e76072511f7c1f7695f12d40d1f724fc58a2151a3bab2b8539005cb8621d880cf26d5ede71b80fae4669bf52b48d3335c4f43e5348594aed2364bc50356cf582e9a4ca13cad8ce33176a24074a706a4bed07187e7f82b42ea202373aa9920542f158315760ed9c044743bb5104d771b631a04060f41b2f77d85cfee63820686967c580f677baa3246925ac1c0035f67d0de34e37fa10e527e7d85280580bea5fa37bf6d23a94aca4b27ecc5efb3ac7d0c2d9132f7a6e922bdf426952395b726030ebafa34166c2f6e33c260640327cfb3089d900d77062502e6043d2d2643c8f40c3131733498d530965820aeb589b3412f1a19586fe6403e7680fce9615038ccb0b92ac72162df379f3ba7f03a05fef0108b753c1a994ca112f80e5486acd6e97fa7db04bf1c4dc6a0260acbacdcf3f884e767c997ccc8fb356097d6511d9b9df893458dee4cc53fe3ee593ea21e2f2fc1f2b703548ef2e90661e2a8d4cec918ff2e18a7580c191bb601ec049722f7cabf0174fa1ca4a88e4929c3365ca8673bab978e1f04778d38518ab4e4b7accd23d5d6e32feb0788d8fa7366c5d8ff0c8de4fc1c80529e7b9724ae2a5e6da2d7c359e0c46c64d387a463e78ac6b94861cd905689148b70efae2353de33b603c32434a1fa79e8d76092412d66e8cb28939064d3cd608421369041f1f324b0966bb308932b29369682a67510a89407984578e918d52258a122931aa713c4aae3eff849e6371fb7c81b91b86d02fd84a77d34dc4941355df48666bb1e3db2ef6298cd1bbe475a1713e09343ce5092ddb077a09e862bdebd208771cdfc562f69dce5e8a90413a87abb5a1e6e9bfd745a5f91880000648dd40255b8c70ad502f38dc75206cf51b2d059ec3eb5754eee80b3f6c4f02019082ccacdab8b9a6b3d1f5a108b9289a62fa44ebd2ba3f7dbd83024ba71467c1115608adaf66a299e475261a2cef952cad175e8c83ae09a7b1b02406d808c093a0a7aca150a5c4814fd56404399d9f383f7d4d6c915d4c6306e17a3ca46744eb9d7307b85a3bcccd904e54dab021d006d4f158b9b7c85cbb2ea4eb37009e587a2a9d467ab5ceb079b3929994dd028deeebc9290bf6643aa94ff9204b118a4ab7076ab372dbbf237d331f72eb554732aee9b6f617168a1f5ad05aa04b0513df183394170e9b41a47c70e0261cca21aaca647c2cbea6462f28769083ade73e831fedffb194e75fedc8ea4cb9d7989c8a46f85d71d9147906bafe4d3950ed48fb50c69bd2a084f3f29b4779b8d6983982d07322c04bb458437b2c585e885aa4ed6ad1d51d3ee3b9c43cd1687cff1587dea0fbbf41bb9726c1c4a7c69cfcf8d5a7a3edd7f1e999c0941aa9c7aa407600f4645c6bed81efd0fa921e64f850f15ccd600f03bf8faeb68e5ac1e9a8049830b17889907df3d6e0bbc254ff660dc4772417bad827d0af5fbe43443b3ddc95f628e4dfac167b2455d5b2affdc9354145bc5f6aacf86e88010ccc3933630e69c438deb3af208068fab739ab62baed6e7acdc9b8cce284378f18061d1c99f2616dbfb4ccf676cbf8716acb3f66b5be18e2a01be1a7d073dddb48eb06099f4955800372141212de3792543b76dabf779abde740622f007d89131dceee1161c313665d4394897991205d8aa64b986342370cbb6c7503880fe111ec7ec77a0972b6b4f573848652713dfbedc7d2ecd4397f675c9c2ccf34db2a8cba8923703f5b53edb9d75d2a4f41a852f64aa9c9a9f4125798fd34c8af79c0bf17d265485cc5067a7fb5acf09a3487280fbd228a970797b8e55720d069ad5fe9b46b6e2c2749cb6451c5e64ca88e84a8383bca7a1094d69a969704c8fb90a80a874f45b6333069f0bc655f528905fbeaf092dd03724d14a81a3bd093ea5dfdb7ba6f1614eafb4424ded62d338818b076f2f46cb4d7bf7fd37a81cf41dbf8f6c5471a7d5ca88728c8c0df338d2909cc9d3dbba0c4131dbc982370c44eb86de8df3f7c908d950b22fb391467c3a7aea911d895222a0a91f02db37514f8c4cb04e80c65d2938da7c016746e77b176292b20ff1d06a14d740fbdce6bbd16d204f6f603142d0b45c3b7ef324c2e83d34b074f3f10bb3b140068040ce003bc30238c03c4787a3d73ef49886448ce79b7b2cd80e74322abf96dc5d33877de1df7c5c47aa7528c67ab0f9618464968457b395856fead634d370d1496970eaf585a9fcedc58daf7fbfd1204ef3beab47a260b7d4f6c110e48626531aa8e358812a84d19371b8e86dcc3aff613ca2ff2937633b3ddbc35cdccf172fb81caef66df4126187ecf23fe0e128be371cff6a509c3a3e53f7911ade2ddce2d4cad1b7dd113a753daa937c16d32f8b5ef2c31d6a037dee60a0ecb855ef90925884fd8c6eda1de7afe03ede0786b42dd5c972cc92d7f2690a8d8de72b471061a32bb58f04afececdc1797d2b1c4b96f25ba59ac6d22675e2210a7f9f14b91862b3f30966ff1f9187c8a64a9afd260588e0b92e94f9e6be876a14524226a4b1293cb86d3b101d294a2b447b5fa1aa562e48e4c9c045a3ef61601278aa2c3ebe1ec22f477ed73729a8225efc6cf0d202b14f83025e4c9d8446ff101be2b397e86d97a9699766df597f52d000ea55aca1dd538c03b1f91895d9310183cf1a690b83cba4220e7ee7bab217bddb3273d3f5232e4a878e488208b0eaca3f5f8d0e1f45d12fc8baade95d6cd33ea548f16a7758c2a2dd587951e117100b43e1ca967cde49d766675690972a0ba224d7030001faee9164a7dfc06c99915f25b8b8b67af8587d2e9358b8ad84d235d428a65a773ab8881783b5d9bb6486a2dd813458e1172a956446ff0a5825be6e5dd679c1f1aa7e7f8076f840d3ad52c8d0c6018af9de519635fd99b7a6b3965e59295b49464fc209b838626676a9377258fd945afc75ed2aad01511c8b88fd40eb1f1e9146a93f0d06ce2cdac478d6400f131dab772a2d04a2f03a41716c6be85d2496b9989bac0a14d6cafab9ef481ab961be4131daed54e719f804191145f4cb995ad7754a50e48553ab96185773b5edaf1b107d563a4bc245e53899f803e4faae630bdd03b012b577e4e02a15bfbbf3f62ca0f913b4e268d6d498ec5489c3bb24cd29136a3e386802621573e21c0c94f9c2dcbd16559506f62ac5b7a6148a5ce083e904728c4d2346fd6b017f71dfa4c79ed46dceb7a454a2beea3d8d25a2948222da16791e6584e2900271e1b855ecef24d12c9950ae1f62fc55f9b2568731869947031a10538d20e7b5219fe729c698a93950bc17404009c507de19b50c97de13f58a57e8926284e8c6ef31f5c999fe627a0c23f8a2503702d97cb1d474306c645692b960f82e6cbd0fe5668c8cd2b82915af9528cca325bceccddbdbf6c8071bf3ff09d830ca1543fd944d95c401dd75db8da05c7c98b59f6c533b25e5e38a586e82777d953d51ff9689f07d8654c449687d502038e29d87106fadc1ebaceb0d2c9c6dad819f1b5603d2f1e824d49201be769e7b21afb60e4bdf82b8ececb1eafe8bd559bc5523d20361815cf49fa23a9216ed889b73f201812974b1e334aa49a3602025ec3dd4f68320cd9e6e7e8d00c9552390f350583fe7a8c8e318d56bb4cf2bf3d5af3ae31ad4abac7c5d5256be7abcaae0824e4203e26e5f3935f299c2e05dab00a1f2f8c486c0000c95f4a00423e01d0449aa94b4cfeaabb81ce5dd28fe850796f864a8d4d0e3dc28fa7cfbf78c8d73e3cb4e445a1365b3838a49cb14607c2e6c43f383da595317f0c7a7c078d898c515b9603b61a87b8050b1a53a3d6e1c349679283508c6d67070c2bfe69e2599c39ba0a6fbbe24f904007343ad62cbbf97d107b2a18185f6ad69009334e98920c84fb36d219293556a6deea3c06716aa8a2c1f4670adf3fc10774fc67e6f08bdfc42c9213ff5580e8ace4c0e9a75c3245a711fedbfc431254e4869a55b338bc5cb086003c554359792b8a24fa2ff0f553ad24ae049581bd0a4255a104de17ad19fcdfedb7059ca122e1f7f7fc98a57678d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
