<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1f7274d8fadbcbfc867f583a96aaf1d061730a77f4feffac36b0dbe542bb01c529a3ba4a88bfbf6a49aa6f7ea38b0c809b09fc4afd643ac9d17fe6658edd6fb78edbc2b8150aaffb059e7b20b7b633f87606d997427d7de2b819ecf533b51a38c529105a761af709031e170438fb0b99da10eccae86f9730ea8ab606365f6aa28a7dc751b962a6071e77ebff5b065a347ae09605dad549c1683c47372e886d091a303c57c06a262d8d29f14a380ed08bc298c14ae8b93234c8aae88b5f7a501c86ad5074578e11e59b5f3f6216f24409dbfc67d8e75f8da3c784d4caf0045a0d5f46adba1ba1084107635553ae2e99eb88dddc5cc137358a41f6de69315b73d5abddc0c859a6acd2b59958d7fa9ae3cfd345fe4c99752a762353a857c12d658d55a04b2632dc7e6777424da02acef1fe8b856342dbf23e6dca3600c91ad478f95ebaed485e448d6baca137275f7a205536add4b83383e47491a26fafef091a186d3a9436d6c02a1dd3c7d9ec6bac8f081c93f5730b910ee519f300b52e6b36afa69c70d3c5949a4e77fae769ffb585e8142077ef47076c110ca0f3a9300721c49c70abdee8c2dbc08c7341a678a6953d511dc3a318354b51c9dfae3a5e8fcc2118c1c80014f3b94cdf1d2c4a2542917189765ad29f58ae422b780e5761cc2b171eaee1a3098bb8bd343df401e989ccc1c7e24f44181151a78bd613f6fd61a739cdd4b35046fd334747cc9dffe7532822593f63c3b558aadd5c8636eace1e40d901ee598ab56c57fec2a2d84bdb066ac510d141a97a0da54d82db40a5cd856faaf638eb673b8eef433213f03398be07087d0beacc3ddcb33ca0bd583e68a8a0a3ae3ca9c97087b13384cf7d214e6500d9991b235953031c1bc28887546fd74e30e2fa85317b4fa19707a3de4d193a28e2d78876bcb18d81e9a2c89ebece5932ce1a92a1fc097a08f09ae19feca83afd5ac4a22afb9d8e970f5c6a098231b001fdf98a0688a27640b545b3e39e2ed9f062a0afee5d2a8803d356706bab859675eaab8b1f9b4b47e9edfc29d5dde51a38dfab85731cbb602cfba912f8fc5d458c126cd7aac2f7e2ee1bf8059933b0cf1a4fe6d7708828132294e81f86e17d3e7bef7eb2828975812709daa50701a5e305d5b8f3b3688401c832431d84b3d37d263d0244c8a99a85d68ee9e5754cc12612e05c421e70619906fc1b5554bada302d0801cfcd22ca736134f598b4604b3e3c654f7cce06755efb4a3302689e7c59919768f54221e376008ec2160c2e6e75a24143242afb30df83bfacb34e882a3a13e1ed4dcf812a5be50ef40dab753c8b4cd7ecc4393aab0a03c3870602668034e39cd38638ad5d47269038b77e20bb3e97e421c9d738653dae8f57a7088961bb3ba2aa5d96ae191871cb695178489cc4b10d4002c6445524ff4dc1cd19b090f370c967a4fe649e9a2dbdeec16eba983a8e22715734c200c1800f45415802d7d8017720bf91a729fcf6034d18ef8bd03b42662bc965c7790bcd8f12daabe148d3c1ec1b6927d30476f981b983446387e887f45e7a3eeabe60c7587b2759e00fe3f96ead0e1a0b9576aaaff81352ff8313f9cae0136b6f5c15c1743cbe23ec7078b8f74f2a24a4c7ce796286a3a16801335dbda45910fcf537f63fab00cddfe13a559122cb95a2fb6fff333ce0654b67517d63e53c52b6458613fb75760a076eec4ef3990400f4b0cdb00b25300ac9fd27ecd9e4da70a1c41f812c66e9691bdf88d8e7b8a52e58b89ad887f4b1fabde96b916e263832d37e12e64637e00f415bd468f7a49a50a82e12f3e62a83b0adf9f923085e0a19c6b21a3c52656fa1e0eb5752e29ebb1fdb104a9608b5bd6c4a9452c1648d5345cac2fb3431e823394b42be1d3b46e25297a9417f5f66f0fb26e9830914dbb1f8bb7e6c8caac04707f16525812c632c05f486a971edb7ac08a7e9b6200a2fb20168abe38ddfdfaf51ed72e2170862f06475ff48f718137452ddfae8e6088250d24729ad4568bbe286c7ed0fa4733d8da001c80185ac6716347412ad1c32146b842210017a427e13c15cab640da376d200bff8cb2d9a2f4d3657f842f48a996de3f0640fa61df5be6eee8f036d6211c9ef5d28f8aea632fd663d8d698a55b69d00de2c753a73369d1b6fbd7580eb90aee5ef187d4ede41ce701d77b75781e99f086878ba500288d2fecdb0e20eea4ae676a30405f52d14d20ff47552f917a3b466992a15ff22d0fb30ac5a39c5dca0cbc27e78f71b0cd1778dbb8c26e80786e0fc597bc91b7827083ee3cc0a8e82696443748a1262e81dfdcfb03650c238bd8374d3bc70c846304a7876fcc08794b15cdeabd02e8484b796c52feb4f9ee41a929c97921ff93d42627f7b712845cddbcbc9898a6bf02ebc2aecc8dd9fb29b5633839a499148956ed39d478b67aa6206440722d77b10a25f65c6c18805e9cfc764378fd04a31857d118a8b694010e35cfbd4c9e560720d94cf9e69494764be01ab7a06a3a6f24e6b073bacaad6d2baa8cc07d2606341fe9c908c194f701584ce9eaae96f533ab404844737b79f80d4ce76aa098934a31533a60e3c625e1397ae24b380026e6dc0288bda3c2a7cae2a7d441e285c4e13aa917d05b5421925186d61d2770f6d7eb209234378e28efaf42b4a779c9b7d83764f3e53a66bfaf501656759a46ae4dcafd40050813264cc8116cb010bc05237c4dab01b709ac9304d2421a60ccac7a88a8903cfb0b43245b8d35e4082274222b66ec29607cfb7e9e49fe756e47c792c738c6188c961707ef56a375933ff73cd042add23b4fda96e0778d1df65e6970daac7994729471774b75ac23f56eff3a679bfecef6d7a05fa3969c7691954b9bc5070f4f1a1b2376678f5bf511186a481b8bdc152c2c9f4f8b16f7651615dc52fc9a7b9564847823de22434049a2907f2a18c3c32001bb662e1385dfe7ed3c44177980eadd80cba160d2ca23398015109814ad0759673bd0f406af66eccaa8da83318dd90948d3667f0424f84cf0dbe7dc23f9761e6324cc219a365849891805aeea5a0046f07e2590ab9aeb7653adb30057481df90e3a344e46c2e78f99540d125f25d18656ed630fbc2e2ebcfc8e4284beae581f7ad1c8ef032789d62480cf97d7ee8aa3ce43873ab4bf4fc300a7d4bfad2b529b8efba2aa6ba0969c1b23ecb49e1c33297b7b8747ac302670c93037a48a33ffaa3a31dfa82a935fa4bc87d0f89bbd7df7c10dfb4e0ae91437a0a856057e6fef2700c84eb54adf0183b6634871d350bca72a965936fea57d666a11fb88bd14e994feda469a463f8e1a049313e879953b245ace1b65170e6ccecd6434937813550318cd07542f7fa94fadb92d99f1719522d45b49370fb3464d17736481714a992b8d6e496423e4140b951bee092e520e6cb59cc9e9c204612271e7feb149e90408fb58ecf0db26aadca758bf11041d3f9fee429e4405e8812ad39befb812e1fe32c4a6d0af739d6ca577211968e59106173db12fa29c764b43f200c3a6d11beeb19499e16937424a27b70b6ab7aad185910b43cf8c04250aded07d878dc78c49debaeb7588f9bd527d22068fa52f5ebd6b9df0f5728ec828f7961ee8de19520827e9614e2957912172dcedee23331a046b4e7d9764b67058b28e142681626fdfc3c43e559948f88ed285de67eaa1e380f10f82a1fc20490cb6d6d21aaba4e9b4f05db89df1182b89bc01d3d4b57d2a84c5dd45535040f927f7988fd57fd085324991de009068f2a08cacde9b942c30b5c4c67e6bddefec8493cd20045b2aa6b90cb69eb53b56dbe8318657cf838671108773052aa28df2c295483eaaeb628c5c129a27575ad2ae232e69032617130d3fe1631fac4d54ad77153e849ee7d75b2ffe7c187b8ad92ea3899143c755265b62c1533992a2dd84f5833a6b4f83e0981b5e2e87feee5c2d23efd70c5f243f32885c75a73088a47b1aeb986ede6785c80f39d60d5ad94c9245b82f0a13590e941befad177e444c53571f6f766ee06e092bc2186c48fd24c102d50bcc6b97b04015bf74bb09e2c27c8f283090ac9fe3d54db9a6804a391d8a4558d343d2ed21e46b09f23b8e825d23925ae53114544e57395fda7fcbd4ac5c8ffcc6e4daa2673b1beca5d12135d0a3ee9831bf60fc44f6c0533cc6baf167683216110bd301fe453d9e1e93f6d00b1edfd7fceb8ef86d2bc40164808651807d866b742ef70726fb7a1f531a87412ed843842eec6226798866e6cac6c47fd71165d85a399cf63c5d79dc4bbab91d720827267296f195c77009b8bba760e8795287dd7dd32c16e0d198456347d867ca7b3b29aaf64e38748a5f6fbbb141905ec1e080c930efe6820b117ac46c21b40688ba836708ceb54e7ef39299359db3b74239809a170b6f30f90b07da675c3bfdc6bc18e31de8d221c4eae5da9fb16d49b0a67ff15211de4f07baad2a77a0c3f356ed78f6e615c322e6306aa175cb8d90fd6c02aadd20b227ca981b5c6ae2322ed14cbecc200b0c9c5125b362517d00b9a3f8c159c937c432a4ee22c6decd0945d7c3995ac3764285a50ff9c33f56edf9aaf47782c0bdfcf3b1931005da210f455d2fb05d78fcc063730bd5be956c12d007b496cd2207fe00af97086a28a02f235b4467ed9d31501809cc4ff6b70bce72a5bc9580477185ab0c4c7e328b2e3e683acb219248f89fc7932a1ab5a4dae410544842b1a808f85559d6a15e01bf458db1ccdb65956ec94729a6069b6885e6d0846d29d235ef04760fd9ac0286c0f80f1fb338e7595e251e79bc51811e1aef83a8a7853493ea9854dc1107989ddcd12c1eb3bec6cc45e37bbc1bbaf43772ba1f26d80c4e07f3ecd5704921f65d3ce32f387bb3e913947fe3e22c08cfbe03846f8007bb60d0e6673f97b06c7541629fa70b24760212b59122701395500a98b36ee0a545f8a4b5c3cdae14c540b8c02cc92b69b045709464634a8883218468c9fd39df580f888461931b5df73f4c42120e2af78bef1e2894cd9f9eb969ec5ea2e92cc3d010906855fbb1a40ddd110c6b27c4e3b2d55e4a6ab3696be6e7851f053cefea4b5098fb473009c604fde8a07a6da6fe3dbab45c6e4e2206fcf06508b64e30136cfe4ce4eb10e1a9c568111e80f3e40f3f0c767b9e5fde7c8cc38dfad2ff215fc52abeb1ef1ee97ea78ff48cd6614135e0e518d03cc08821a29b3a44ac07f93b692733bc66122eaf683373bdfc213349e257fb88c881d2c200a6e89195692dc2fa2a760aab0fa85f7955645ef73e3c54bdb1b9eef1ce92c229bcf0a04fd74a49b760891c4b9e331a0a65ab447b6c8911ceb1e519ba9a4311942be9ed46070f59d72948c88beb18e9d6f572f9070a0e87267d3aa1f9df6a17cfccdb151497094fac3d68f606e539a56f7eddcca3e0c88fffec9a2c1b53bc22f50ca2119138a3a47c9413c83439f87e30dab428ff1aa19e13d99c8f2944b24aadbf7ed3ccf434d996c28e2d5367c41babb128831201e3d44139af89904ebcd7b0e25e7c43fce08879b543a4e50747260c8d23b1f18c6af6f210d44d19d189ea37199e07339d507ecbbaca3e5e85c79987055c4c73269f488ee9c9d906bc2477547bd8568af5dd3da4bdee3da0f982bfa7606a1fef35c43bf6aae92d2a8ddd204c1ab3e1fb1266614776d22cfb18d22c4f9b186098928f6711413329326c9a470c9cb10d5576c26a662a92f595314c06f4a56ef4e22bc94f36b0010dac73de8d6408adf7990931acd879bebe28318007096f86de7bc8ab1289266e4068fed7172ef23103846c91c1f1854e0c5ece0696021678f795a9f6f93145e656a7a19436ff204d9140db7d04fa70fdd1b06b107adbb9cf5c8f7f7f78bc63f0f17503a0f70e1d744098848646a46cc008dba74a7ce8dd9de4b5b7bde3c3ca3e5edf524c360da8f7c6960f7bf13729f9c32aced21d0d62ef5a05db5db2cbe15e413618a6b9cd65ed7d933a4833b55828d1922c2d4f718d3ffc32baa25f7901ae03b28a87231218bb3aa7387b3bce5c7a74726b5224fff70de80e96f41988eb1d5074d89b1e83603f791701f243c5126f14744cfe9106441e610df25b5083aedfdacb5cc377e2c372bbf0dad228cac9123974954596b81a8a1e1cf2be34eb1898944d64cacbdc2a7fa1b829bb8c100cbb516d25234b62ad116b2d6e72835d74706fdaabe3d7504544e36443cae624e5b5feccb7ca6e94b2414d3ad426c99d1a0ab8f2f47c6b9f331cc1308f61612002add8018f4eeb3d8ac0d6e083c238280d31c06a6dd2aa2c67ec1828cf04b32ca5a74a41184be9196d76942b64b7397b01d10ff4792532237e62c8a29ecd26730c6874c95759bf90e5ce9a7f9abcaf78501a722ca0ceaa0bbd677440a72a24e3097970deb0f9015251f72c6a944747d7ea7885a0595796086cf818a1927c7d7261eec20dcbcf1ce679cde6a43fa95ebf5bf5c3931b9d6d92cc0feae6bba500a54529c666623d60374d22aa13d7024b89a67f5a6ba5049064dcef8d1966ed37ccb24b6e382bdac60d0291d0067a3da5ff7eb32e8823440c58baa2d36e678b1299f63ea9f33cc00621ef47578c6294b37289b1eb4ac81fe88e2d4d4dd4af91e5d5d4355f4bad4af3d1081e932092cdfe98d90e4216f5bb67c9190d572978ba6907b96d9aac15290aca629071246135b1146a33c2c4f14cb801431bf4986b82d83c1875080972ea8c339266aaee73ce28ab1ac7780437abbe699581656153425f8bd0b1eb9c2c322a0be570516996035a87088566234be386af13359bfa5f29083440a49878c4355b5808c1c17358833c86d9e82c8f1f2d58ed38669c3dee39dcd0250f221b37d01166a8412d655f429efd414e04bc4f04872ff7e0d833f5c68066b84c06ee07fc5c0459d37156dc1ea9f35037da782ba96677ebad7fa46b6b8a748e1c2baafbda40e9cc829e4a72ecd597e57414f0318c3caa70106dbe20c7ebd51b2d238e9c632da419dcf23776af2d52af6bd85791bc5b3f0c65a6112f9b09ac057752d23028eda68844b4abb9aa41ace9495d6e6983c64f6d582911df8a178fd09382337300ca609ea4634f9d7eae6eeee4af7c32d9d2caa1952ebec81f6c4c7dfc053a4340893ae078c64a7b465b43258e1e9f01200e4b5d86116665df8b367c1e086f40919a076b12b16959204ebb32a6a5230e614cce2c761f1e5fd6b591a3469c203531a800c75f08d9aa3cd639d931a76be7ecce47477bca2b4b69fbe65fd1ce3392270b3cd37ffa46086ece9e513412d8985e87a1721bb9513cc294554159ce8cfdbf6d7b13fa1d2221315c3ae6b513b490bf55d56f4d95125e4721a91737495cb0f6353bdeab5465da718d4868a52527861e4dff00cdb36e62b7b06041af1de4151f4170098b11ee67b85535de6dde7c27f74242351e0cdbc487667c001520625aeff692b8a3e98c182bfe7d46d51ae83ace08e00d4789861a41ea6ed1c6f0bd34e9af4764954b38feaa16184b1bf9e74d2255d43f380d6f9154a092ff5e22a2fc8a00ae6bdf297ec32bae98888e4326908c0fb72f881f2f69173fb1c693fb008abbb92142bc4cc026a7e348960345663029075fe4b74a0316760f8c0068a52bf06df48dde6220b0f3cee619f270f5700a2b3a086f8ffe1cae06e26658c74e8a5b9cdc64b5ed72e67eb851faccd2fc20b163afd911fb6d2ccd00de48117104e21d0ea56e2fe4d51d7766ee36a8eeed39e741a3083f450cb209a98a45f64175b6ef8187e3881c5a1b9105f8fd03b46aafede79f65950017d5d650d99df6c5315c10acc6f18a5fa083f24b4421b8e7194158cd247fa6b3624e16dae14f47ec0b2eebc0400f58f0fc18fcea121f90b1301af0ae73fc2beca1aa9d6b7a58b5956aef2cedeaa942287343c0933955bd01b8fd7a42fe9014f8161f06e1ef95443b13072d51f5a414f185547f49f828bf302b6d86d2051335ba12909bfcab800cb34aac2243683acad1395acf996384fa0e5258f2510653a9aa4280fbd66bf95e68c4b679409ebf8031127f22b0ec6d146aa907b9fde7a2fab705894c976fe17903e711fc5525e94e7cb03e5dd49eecdfc5ba1f4a9c531c1e682862e32dff8c297d43bf101e528eee5c02d4124da1719e094b2a88da36988b069b4f869f0709f0efaad855a537c0d050e575d588f211a1817127ce34cc2110546dcc2386ef419cd6de8d221136b66484d08a46e36bd8b6ad4737971c41dc4729fa9f049deffc75aa313ba7016077bc6a63c4a9153fa4d53cf4b2615e6014f8b9eedfa5dab59c1850206eb550cd068ebe08276a1114ff23e8c0e249e1896eca410f7d3d81fc900bf1f1a2a1e244bcafbb759aa3c1e79887e02346b7c04d65b513bb8516b355d9ab27a0d6dd94a8344096585f2669bc4d66598b67d4e802077699b7b4e027762d005dfb9c5f271e9d595d931752816446cc45d92fc7fc69258cc67fde43db91086d4e57cd18bd63e2d85c249889c860bce9350f453f9cce7bf94187f654d74458b81d27654f143e11d8559943f5db621af038f4c984e6bbcc37b353d98f9600c8a74107f2fa4be58ebe18fa3a6dcaf6f58c846baf5cf51465bc1f524e2de083863793c4a57b49172ab015de2e73c87f0fb83e6a68ed32056c9a1765d65cf9dd3a6962917137f877a05f517a5bef272ea6df0cf9f40e5d7c80fb6999c1dc35274953b45b470a72b7179c16986530a6536ab5a67940c6ec1489a1f2251c3fa2fcfffea4b0dad69fb5ee2a9017841ed0b92d1e149271d58cc8c5a4298601bf454c96b86015f35a6ec586986cd2c61f4a9582da085ddf8978da0bb863808e15923795f909cfe82e00e6c615efc35bea26e1a30c54f25a720b31be438297ad62c5a0b5c54d4bcc60769ac3c8c92828ca2bf9ec00dc0765f935203366d97cee431ae122f410617e8bb015a30a2e8db1e74c44a229f3709fe1c391801d2872dd0a7e9aad9e26782d477ef900d0d96294f46a0f12727a42d49df0825c19d241ae79ee54b0dfbc9675352eb13ff6f0a6776760be472020cd24e82225993ecdc9c30502fae47a13d076fde5f2b9b6b0c4a39441d25f5a1850993163f3a87e84ce48be3ca9e847be99937f98e681644f6be38d2aab9a6e6ad8353f927368c5cab4e932bb60c6a524c52142d528ebb9008eb5fd51caf18fab7888105bca218f68bdfa271ff3a8be75caaaed87056c29b56f0970f5e3a9e6462246cbf80ef8e854d4b2b6c8b3d76e156703200a86e34cbbd742d73a55033620b26362529696d7306abccfffcd551b560a1faace5ec94a24bd0724e7547da2778a4221943cc5edc730f691983af38ed6423113ad87a539f6b3eb362c4a0ef668fc5ca4655d2b3faed5a1c30ae5f16e432e1435bc6ee26f8207e20d505c4e799944be2635101e1bd3fd2c45a7a6b8a6fb11b6e26149896dcca788118229b5431bebb3870084f245308470118aae75ab3c4da3161f7669081dead611f9eacef399497915aba12d74fafe193bc3981a71ac010a4c3e5fe6460d24f6a6a31bc157ffc46d174d153ed663a13f90ff68c475cdc14af9fd0bdffda0fd89f5c63661416c7388822e165dec0487dda99bdd074a97aeb7b2b69d6cbed5592adc3c992aefa7c056d0a3b194e7f0dc0562db697794912a4d9c2261597142c502ec0b2a28e086f66504949aac4c5764ea38fb9f08fc8b142ac5010b904a70c4b594c2b25513dee21b93aa12bebb31c965f276e8805df69ae61aa470138aa028ef46a350e37b0470d24db4ccedc9d85c6763cf839d9812344a43c78ff4a5f44c7fc7236b133c04261d38cb1d09e5abd323022216925ea7258f59576824ed35652f046c01e6fffb065d158d80c6d7d894c1efbe4963fcb74bc57c5e216591d38985e519a9e0b8cb3fc47646e7e62c103d27d2b86f39eb5a1dbbcbb4e5e9f8b02d5ffe38dc7d9a284b8d8bd4f6b4f96f20586156018c69a3592527e396fab4569fd9f7372a8378ac485aa3e0fb146408cd03ea6fa4d92b9d2473c3c8d4fd1d6fa8b2a6c13007953d7efdfbcf776f3ae61792666d80cc67e5f5893fd76479a3219c33b97dae3d669d5162d7fc68a906bb8c793356b146fae12b7643e918737eb9e0fe9a787a0141a7b7c3a54c147f64150b42390f68b9ad79e6160128145e7c5c0d22ab1143466a5b0f2f6e425158b6f58bdd3680a58df4c7cbf7a6d1a08394c3305f02396fad4beb368bfa521fab5c84a55d05dd97ff7c17bf225ed2b081e15c57ecee59c334e77afa542dc38632d7b5286281d97d71d4103270217b8ee13e8af3f158fcb699ed6eea4c88bdeb717de57b471aa79951af33ac21df8e6bf92ed74296ed775c8850191f3bcee1cd0d657b23995090cdcd21e0f33ad32e7eb073a402f096eb4dfd8126699183748eb94077418fcebc93b88f9705523c5c2b82161815a6c9cafb03f7a23226884a00e997a1610334e800248c579d50d8e7a8dc5e55e43c4f302b8df93c6956e3d3719462ad912b93582a713fd346814924e55064825ec30e0b3fc18a7b6fb5e47923c7aa111be46948f436954cbedeaf822a58857c851b33fae0ad052cf2fcbeb9f8b7a89f249af2b947b76533f60ca13185437aa2626a9cb573850d739dd86d339a32d274d389712c16357081d7e27ac12664ae61b37c1b0b841088eb42f22b918f02207e607f8f03091b6ab38dbb02697b1242fa6cb5b4c219e9be2cf37787c0b0b0a8b61ed4b630fa7696b851d5d21e18be9267b64396a083dc2dd0e396835e48e875857d5419b8a62b863b8cf00307856d123aad4eb7a2dc35f7a89122c15daa77ed71655a384607629f4acb9db11d000e66d855d8bea553351b2c715e6e6cf1f301ea173bbe3c6bf3332ffff49e7de228eb4b7d57e989a0f0cc16a86b07e6623ce390f6f31970416fc9daeda27b1b2ba4bff883ddfb92ed8c20666bc79c856e3061cf5fec61db00877e40807db24d82c31214e04063d8bdbe68d821a1cee8170a62fcca9981e20fd4b578d81e8e58ca0408611f86d9746bc9101db122dd1bcef70c2b0bffd475344bbf5b83a3fbea1618540f845aa062635ceb60bf5a19b0eb2ceae682a0d030f6b1b6b0bcdf35803f182096b80142c4cf8f93118d87e284d397f5dd08d25e1ebad82d52599fab4973c1ee31a685073268add284bf5ae3a7c21899e2ee7b0ac678b5d56020fb4a1bfdd7dfdf93e1b4c4417df4cab409e7074d9043b9310168b5c1906555373598148f64af1a23c90ad69e408e31f615dde7927283a302894d86ad36d3204610cd140fcb879df8acdd52dd83bf523126687c43ee116b7a4bdb0d32ad6457aafc4375d9f0086b1a42b31fbddfaf7570d9a9c77e6cea3d09c895d5cfb0bc3d904e77ffda764ca721de778afcd26d63ddeb687f89acc8183d4075745c1e33dc75dc2229a21251a537b5d69f800b09db81767101c6d515ade4efc5e384b9cca668c9fbba7ba353a173c87d95e5d9a66f45e206f3b9f3f249aed2658c7b2d30204d7613ac7056ef4b538aac170a959831e6a3c1cbdce811c6fdbb3accdef7da99a57b11c26c07b8f280f2ce07e09ea827f6000d57f8f7b7df4546bff45fc698e1f1d107bca2d776432e09a40cb16c7d4b6f258b32fd2107643b4dc1c66c0289fadee956319da79dd770ece2971ddf3e02584fd3bd3261780e2d3f497e386b992e024127d1a1f2d7a38c7ba9abddda10edf813b52a48404a1ebb1d29595863849c39a694251c84837f54d0110e0619b3657402c032dd407a58c5ffd3a239ed52e64b1dbb85361b2a728ceb5025241bc9ed1b1910a4d52ac29e2cd97e9bab8051f8c4a6c3dc8f05bd6d530a6e5e8cce8cf477fded7f8482ffe5260e3e16c9447a5d127df1b096c3084b9054528ebb6ecfa3c01fbdc2aa81329ebb867f49c21b40ebe2c0fb60d47121138ba2f3f946a4073bbf9279df898290539c34a1bb8b124436f2af31e1e76530dcd9ac3408a9acaa4663349373b09b7faff8b53164f09f3a421b89436936e4e9d26d2af223aeea2a006c67c6cd8c809713513784d7ce91e751007dd1d2c5183fdaf565063d5ae86b49d34f93d6c062029a8ce919432f9aba1c02e9bc0c0b8e58210a9fe5df961dcaea7de021f38556ae6ec03c81c62e03cde377e86aab16e56ad410fdbee3460b3dffcc8669ef5d5d19949a48ff2eddaaae2d124dc05c7da5329d7aaa0b4ee6b7f33ee2588ee5a64b8117f5c2396d7424de9acd33cb0eb047467d00e84501d20044816da892a18aad1fc43a562dbe210ef1509f32087dc01c2c7c62738ea33c13ccc96e75a4f1b0b92afd2bb53468c8dad59bd7d8f59c4c3ce96de67269ed457d913d025639a4b3daa8589f32686ed9186d85eceefa58cf157489c464ece67609e443246c1871d32161542045d3e10e0b5a1c0fa666a0f2fb94d59e14617909ce82de203b0c4eb153ef60f12df796b9ef02328203b1f310891e0238b9be57b04aa87982e6f13a5a055d8cf8fab29b3fae5f121116d54e6cdbb9fd26de7bbc6eb2cd197be33e64919dca752c40f9b2b680753ace70681847fa67b4b023051338dae2efeacafafd3efc563a9b31b1203313e00548f1036c34b9a48817ba0f4791b43b69aa91eba0ea7084b38bad4f58472e9dc83d36e380982a6a833b1d5d477af815bb9efd0da129d59ff1e84f93e5127b5e37f90caef5ba0bd7f0d6ce0afe2f513b9a15e102d808c6a41b199bff571e442fb5dc9e27e3ffb3a4a80aa68436c7ef70cc4adecf58d79c3820d7400533771f7a023513b1c6b2ce4baef557181bde6ec20651a712437420260fab8e8469a010085284e324d9d250740a6973b8c0503260e176cf7a29bcec71d030f2711bd58d13c941b4b5352f8f173cd3dc1c1da931f73620d8a9ac4fd3ef7528885bad25d01291f42b5ac61235d0652acfe1dbac856f0eeeaf22eed1184886f16567697e32fd397ae2927c6ebaf370370f86560f1e0d831d4d3bd32223847c4f4fc939bf3d02a5c971bdb5bd878f94ba3abcb7119a3aa197cc72e174b0411750ed6358759e52fde19f7296830676a8336c1e028eda5ef2857d946d15e29d5adeb0ac9b26824aac2a43e3b30a6ba3f7a41ccdec61f0733f9467c1f4d1268bb2cdd62d1a0a79d6dc41e859aea6b935abe984d077d8ff2324c44c5bb027d9018b44012ebf6595cf8331ca4a1c51c4c4f7525cdef2f5e2691118a2584b639a45a2d276a3f230812633af5ab4855496f6aca59b69f42806f26d411712e704d1ccb44426b896568fb98f80540fb8f6ca9c361faf08ed0f2fd1a58107f7cade0273867ddd7a6518df181f2acc1bbe5957cd99f27ff6844430b804f3c3965521820bbd956be1a8b2583a20b4157f9cebbc5a15d54bffcf88fba794f861b85563e60e84320f277a084d102d994e595cb99299d6d22f1af54d93463454ac361c28693828c87d18e42426404653ff2727500ff52ab31a0d639fce60b7a08298de92151d7bde68950f8ba86415c3bb86aa63dba520dd8afc268c4c740eb3bc9ad1c15e3fc59d3e2ec0edf1dfdd3a35b77a6cbcca720f627ac40e531d575bf78dac741a7d93ba8985724f4b4f8da337a4de79d7ab3ee6fb30f5bc8c4d99fd5fd75b38c3b3e3cf104b722e5e2546b911b0812d0200dd7b9167a007b0024e9c7fc6004e94ec24a9877e77ac15e3f4ad0061751639d1ef0b9bff6d92a00d77d1c14d8f31b2ddca514ab3091234f9ff7e08c26d6a7f791de0a1e877ee878b0e9ad9e95d1b960144755ea8940464627b12e9f344b326e123f837683675936095e6a01d3265455f83684a21d5e04d53a45276f2dba8935903a113e8b371220d38c273477b536d795770c00a5b1056ada1db02edb59fced239882ece2f1b2b1f94fb818af8a83597588cb2326e00501855bd082f2c8865b5d507cade656ce035cecedd224c8308aa7ccdd7e1598e94e893a15866db08e8a831fc1d8fe15ced1e84f3f494692a670d1be10d815d60538fdf0cf57b7ec5422aa2ad099fec62c8a96871369a3b60d67dcb4725da2354fff5341d103680c16f60c1623392b3af52e2464134afce8641488fcae0f76bc10c984a1f886291eee35eb439664b2a3acc6c6c9a1cb5135cc4aab4e7c3f99812dcfd16ff133ddbc2090bcf558428f21639fd68e552d074dce2011c80b87c76549972c757f0a6a274d21026a53cec8927e687f9c18550ac6eea5fa101dc01af09d29e26e03a702972c810a929fedabe85ddc3875f397013b7f5176058b9fdadb086c8a91ab40f3fdfd2420cdaa01817ede19fcb6b976aba87e407f12086d1c8f3a9a69d20aa8e17c531fa29eb65c519d78637d5d7bdaef096b3fc4379d2a99fce83c4431e8339f5ef01e072ea0aad2f35758103ff7774d09191e6cf79ce6c973a1cea6e00754a1e3042d96a5c9df1c5edbae93e6941356fec05e27065d7c4946b05f9f75e94b7e2f2a34c15cf9129edf774663fd8644587620b3ed7a57d172ad7f9b2f87601a56a64248da2c6e75ba5e13331e150c7f61c5ca32fa147b987c8f953fb3bd6a7d4915dbf2485648c35e2de717735f7980d45db9785fdfea63002c62cb04e526bd55cd9175c62b314851f4e93a34b3fbcbbcab5df9c80117c7ffaaaec9b6bbb8632c60837ebcff7bb9c86050a1c680f6f4f0ac48b74a2fca9f997724ad3df46cd67d8899e88feb6c35da782ab747af2a275c45228d10bb658f4adaa2c4022f487172be8245a9dac4147d50e8b22b8bfec4a36741173fece55435f6f640640c4743bc282fec8c15e9b68e01465e3da765d01442c57c96e5b60c4fff9b9a3bcc4651381fc045361c09d6b5f7a4db87bd7e518a00a0f68e2a05b5b8bc90da2f9cdee011ed0a7e431449e6c5efcb4b55c2cde401111a907e922469b8fe1c842925d8906874099789714cf5db2d5d017a6a3ee6840f1a5e00f27c9e0ac7dcbd1565c92ffe6c6fca0ea4a54ecd1d913a273cca8b945a4d88d35240e2e92e0abd1a5ebd099e7dcffb58e3621d8436b87d4bacf307702420f41cc36573b95fd67bcb871f639b9f80fcbda1b23ffa53b8aad838793769e9a8cb433b8629c7243b23841c6bfaa20a6577575ca7f1cdff11c97caf4a0aa467ea0648624cdb3ee4bf079eee8913364e266bbcbd1bc7430806edf2960594612997c9098c23c602e8600c18d3de6985db57b090ab92c5a9ac53a7082a02c3b311979a46997b868969a70fd62b3dc93aec76e4b84705b5948a6b211e76180cd3db15976639db49e552ad275eeb8f1acc9512767e693d3a6c2025b402aebd0806821866ac4490f8bdedfa4fb95b69d902dcabb0f8b381d73d03dc21e269eb91af76002d26ffae126507182144a80e95bb91d214bbd96f7907a0f84308a381e2055b4099aa074a9040fccbd6da86c230667abae262ff9ea827d6b72551c3d4653ddc6ef1229a739e09ca66250372551a9ceed6cd084ef869c3abd066a0e1b82d0ac862fbb372937197726729df825675ee9a12cd9b7a94594787ef637f0f75a068cea0f503136d2043c670c2d66b8be5cfd88f3eb57af8f936c032ed1ed9d47f96f9d085d0bddc449fe36f69cbf8471bded5a90ca7b7d22c521b061efa0c43c6f713b0987ee2afa6fd6860a40bc65a3802bd9ef9c89ace400ce0902f26c4245247c2c61871b63e9ab7908867094cd8d23369ada70fd0100956c406595ba0f629796334b6a9910b26fec93baf1ccd3ded0d02542c1d4d9c82843156eb6de385f5d806f4e8a65d253be6679c95b9dc995e495307454c57cdeeea039cd350bd2f351205cd5c4a9414ba17ac65b735acb10dfa922055749accdb14aa40dcf12ec99859a59ff06cff5cbd5208d87ecaddb592009336bd93f6b5d59a117203ac1c56870a3bcb0eee7b569acbfdfaafcef1ed6ba9754403b00f6587e57f6eac3024439805a03c0258d78f7445dedec009aeafc369c077509a127dac59f1b2f457c1e65881ab9e4271a49c02f304cbec6be8fdffbf1d1274e47e2e968f1eec3ab6911509000a63e52baa37bbc9d1513586916f675894de07c5ec27d010614c51538d21264ead5c468a7add06fb147517b58b55650b36302a6586c0a04194405029364f043b69b5430fdc0dbb64cfc428ebbfbbac1516b7c20b45659d0a42ef3efe25fe17058e7b9927230e0a3036c5423eddea363f26affecc5569d038095d0204af1d84a45478919c1af9c458418495057fb445f73614a277ceb2d5dc98dac5cf924a2c5f84d1c0fffca43eaed5bd2ae05685afeb5be1f2f6242113a03f3b1186b9659f62a910498e5018377b1dc4fd346dc4ad3a992913aa5e1f5e6763e4a4baf93105f2b54b949b32057e97b28f38d3cb729fe50cfd1dcc5df591c4582eda9f74768c9d1abffb9deed76b5028cd3ef5e9b089e500d64be326df338d0e3f1493d2688ecae16e60611edea1b289358ac0a261f413181af18bc38c366d12e7a728500bb683380830fb85df9fb475ef6167926ec45c1d802671909fa613f91c57d97710df84a43e3808b74b385f887af62cb800f86595c958dc795f0c5d8c21e4f5d7f55beada3e3bcdf7af8903659f5e2ef839d56b7bb78d12003569497e7c053ae3de044e645b79e5b215735a125c0eeac9e684de6f590e6303f237a17e1fb716c4c5dc3079ed2ec96faeb72801d0023013d5cf0a0af809cfc8c8220ee1b9360f42736aad274c41877b89d0e100f0a1cd139334693798cccdb9530077a4b784cba5b82e23bb24dc247389c8929ada1e18b84f0959ad50f79685f9491756f3848fc14229c11095e3a750063f80873f3e401714a61fb92e08796fd6b4d81d8e6d63f4503cad834516ee9ff421545f7889876bfbbf09304a4d2eea23868ce72ecc7da94c3fe02fcd47d2242c4a71608b76c55bea5e2bf65d86ffd4dfb178f53861e0d351db09d33719251700088e80aa44b6c585cdcfc9c4c45ebb56096f24efd569320d788f27a123243c2c915ed2071fa92563aaabaea8d176af85eade292c94e20bf86b84234e41cd53b595e0ddfc80c1ab69cd47d9f2e4e6683ad7bb7444fc6cc2fb97adfbf53c9e0ca74bb64f327bc44abdf9c3a79dbf6c8064111358cbfab53d85495e2cd2cbce63ef4f36e2357b03051e046172329f0df42ac2a290bef42466d589229e850e234aed600962d0c683bb9349c1122b71a0b6c47da92a9362050384bff85f73b75de8f3288324e830d7421dbe6fd2d1940e34faf3089c37330eabaf36ccb5da871c5ea4b6e4407b5fadae3f6719fec8af67152118874d0f78dbfe9c36c7f777515b1059fa5eaae7839395ee28b763c1e3c0b4a244a9236c5a89c4012b8f45ec353505b551006fe24388b5c26e0cc33748dc2993d83e0621f97377f83364fa09fbb0feb43d1d241e66df111e3496510722e04157ead7a2bce065a2e2b5f6d25350280b7da06ea6f26df35b43aecaaa076e7a8c9e30c1b9f52cea2369da2cfa73140a7fdb0f2910642ef6aee1ccf17b8797e383d047a63be39d00eee8928cfccda336d7d59d9405e9d7c41a929fd7215c021b03b49e48b8e64c76f1cac6701ff059dfb5ff83a8ccf0fc92e924f1ad4aa5b773153150191d9e1259d46172fca4ac97456d7a51a98b548cb067412ce29489ddee0c0a4cce34224388070e6c05ff30c57e9c53d31ad0883623d102023a1dced6515d0039703989eed57875ac2ee74f58b8af91aebf8067113bd709a28793cd6f089d33c0393cc59f22aa26f1f7749764c943c5bebe856b5a811df9f0742209e5cbf0d108f8cc90ca7cb13ef8f356d700c679a1b40b05349cf6ee698d30fe731550be901585a08db4361c637f01d6a7bf485809304472578b9d54f9eb5062d5ca9e4c9128f49ad3aa8a1430d04faf78be32ca753ed102f718ba03a1891f589f7733b557f8c6d90720c44395854b2cf4964037435f4b8c2f2f3bbaf27a69b56873cc8fbbc09d83c35fa97564b8515b772864fee656a8754ed60cb70754dbac6664a77e55f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
