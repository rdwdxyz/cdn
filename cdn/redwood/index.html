<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"122ba160a2db040611a4bb824601b0d0806a414c2ddb19625e80803b9085673aa69e46fc801dbcf2a5af524c8767781cf266dd81b4b5b317a9f32f7b2e231c550280fc34b6609a1c22b812264dcada2629b212d8685d82460b3e521a3c1f7b170c78d1a21604bf37302b5c6407cc4934dfe1be360aeeeb5585a06523147ca129dc1554943e26835f1387c850b1fd476ea7f62e950ab8549a65e2c64b5f95f4dcc6d99dc646c831a775833e5b7b191b7f13f77f1178c1fff371ec2d96367878c9ea0cfc4cba8db42a81d720ae8c2ebd9fc33eb88fe203ee8725175d67e85528a16218eec81a62e6e0419c6f8b09ae30619c7e8786d554bcdeb400dc7f5eb646389c4354e5100eb38f1ee4465b4db8e3677f31fa65df068b2add896ec8e450ac554bdb191e136a192c7231edfb378e77e8d32637c619986694d7bb9def281a6120500bb0dde32ab1b984248e9a94c263ea8bf0c3c9a9c19d3a5daeddc80c11b09bc4151dfa67ce98d2d8e25b1e140add6346c9c3e7510315725512baea88d3ced83bd1ad914bae51c34a82ee9450f95c0d36317afe77264434621de6a47fb50c1712ad4540f5259c1b23d149c9bfbc0b393c341f6a5a07d537825988021159df24410ed30cc31540f3c8e85c576514bdf363b6ab4063a770c72c83796bf2a9109c88a13775c89dbc69bf2086e137e160f2db98e4f438dfc88addcad8f59f7767f690a1c8f38e765b76c2596edb151a37d564bdffc1d863bd14c0b45c801df0440f1e424f1a5009acca5f6f9403d9221aa8c82a57e3162d17817b653a7d8858e0ae95bb2b35aab596fc46e5055fc3944ce6500bad4d8a58f14c5b7b1d20e3c42c5ae84ee051582a14b5f19ab3f6e32ca6584b80bb887ce20c3e930dff8d20f6a7e243c52eb279231495142a4eefe9391baf5875811e2151cad996303cb21ae006b73e463de57ffd7042718cfbe4a238fda62477f3b1c5997d13febc278f225e80a3523c3b2ddfb8f32fc7a53db7518478fd90bb9f47e6f54fbc06623cdca074d523f945182c3195cbe25d275975be2ab832c982a87dc4ba29fc76982abbe1028ec71bf55579bbae2607f6ae47e4ab0116bfb64bb4ab4b577b3683b0bc897e27c507d6be1944197007a9ae267bc109454c1308b4c1eb637d265d8ddcfd7dc369ef841949519d53ea537e55a184516909db0a295a74cda7ca994ca683beb55c82b538c98694b43fcbce3bf501a0aaf8c6eb008533b14d9d8a24090a6e1a5bc2228f1828770248e7c3fce8acd023d51cf4989a4ef9328dacba1a3fea7f56afa591964fc79d11945a52c086063679c20305ffef2d95501e0c2b3896d4e0d54b2a89906729318ef159477f4d87309292858a994abeb6df1a6461234baa28e2dd1affe017c6653db4306a290dcf5505e37889160b6643104fa5c7c527980bab91ecf365cdd299a380060fd018bf3fe9c16d000251b5072eed3c4f39f284d7a41d3ddfd8fb989ab4e51a8607b81b88dd02fbb5922adc5823b3fc7ed82c94d35eb5261f7e4cc36b3c35bca5267b1e113fc866859c611218b842def09bd5a46c799ad940ddf533979e9808914b30d5cd2fd7795ba61d17e425ada480cbd06949ac4a816a108e1e0d6505f1380dfcc261ed50f86107cf58db7c265e49fa5dc784a7ab743ca17f67ce4be28fc1701e80fbf6ec7981df9f8bc8a0ff8e5f7b849181a126cd3660cb21bf9ffca075b3fe5783da6119243e6e927ceb30082adee067dc464bed20de906579c3212edc12d5dc98fa0314a6d7ee51e3ce0839a06de351a97248605566c266c8bede0a102e2598e38d109a9c1c81a3c599cff364065a12b4df53947f9e084c40f89fbbf0b92193cc30247e18fb5986c0e47d88bff195c8f8c92b39c247cb6d2f3dbb6be6a949d30448d7668648f6dcae5cbda29df70dc429b3ef0b0228d2a0bc65c5075edd34ad8f6103c875cc62c1fccec1e389c3fb63ce2f2ed1ceb507c07175088a04e041f8e2d1482d22dfeee28f65a722feb6ac8af13e8102a318d1ab6d03642b384e49d9cda00aced9c0f4f577fb97876dd4e3664b1dbef49891d60d5bddfe82641ddaaaefac145b0adcfee1695d662e7c5735f6ecbc8a4c1d83c9d7f53ba794c4715201f04b01c32e32a91e213cd5c77b81c1a8bb1fb30ad0742b07fb6ac3f656b9fec8a5023c69467b34931e98f1236b8893a2157eda78664eaebd3b206f1860ec3abc1d82bf8c0e4778822376a920443ddf92211613dd75a441c58f368c0401966c0fabed53ce23634961a44eee60703dca16a76373500a7054642fa675713223ec830ad72f353f5e997f152fd9a67b81d1bcde4ca52e63b2480c701c85014b19b0068f7de5b78de0c8f919c50d38c3c15d21908f808c4b579bf985dbcabbd837c263fb83590a7c761216e77a391d469540be85b40f1879d781b7a1093a471c3a7cabb95986da08d2fbb5b943fff41c04e135134c7cd4290d52302d5f045e5b0b1034eb6ce5201ce593bdcfa9d026e55b06d905b0ef4ae9836cafdb907e0df2b3c2922759346363d4cd4ea0686e81ee769a12556eed41c858ecdc23837bed8facb96aaf8d098ac482bef1f9870abbf102ad42264b85a7d1d1543548fa655d7786d84fa7f4d94de0b2bb43ae9fbd66c28ac96526980190f661ce3fb1f636b07584e2ed5f2bae925d95760ff9639ebff2232f068ac6c8b329d8cad52abaf4ec2cc156e8fa2fa271feb3b0744f78a14d76a38db1626092f56bb6ff064dcdad5de2ba7196d359fc30d88a48003279be9436c059dcb5c1ab88d1c8ecbe6f8c142dd548251686916dc07e6d3591d293d3529d0dc71fe3d7f43ecf60e19015e53eb2846e2e7a1fdaf5d5ed3214d1145d44c2e289c32657bacdd9e3d4467eefc83526ef74954cbeac399af0987d4736f89165112cc3a488ff0f5e01e8664d7d785cf4421b0039e97e1e8fa1f180bf9aade726e7bc1f462aa3e56f804141c20f1f7b23ae829ab2f32ac00dd781bc8296c29a019455ab13da957d883b148b0b653423a6623692e5597aa4120c299215223b4931e7fdef4806b7a97c1861effe28f5495672cbc74e2048e76f99ae842ef20f7b0592fde2fce50f8122aba3117ef639176997f98f4bd480cd1dbf3da86ad044794749135ef59cf60a3ecb68d65f00562540bf17707e39338983bb3c9e23bf3769c5c3372cc434a978f92a1c7221a645a1ebc2400a238b61bc5298d81d395b2be491dcc14889761f5aa1f91c9df4cd99e52da0edbac156b2dda33160e854096172e3a5cdc166004992133a3f0a837782fa293a21f70ca3dea351df0c5b6fd45fbfddaf1d4ef452dab1202721a84ed9092c774f40cec08d194302fb1bff0e7172004bdb0828b966f42d79b82502f9b7c4c5afa10f13a2caca0162a3d9f1edbd249224de197c85b956c8a46cb494a78f01722f97dd85b2ad32d6e2c5ae28f7dc2d3e279d1ac9d3638797bde7e4c2fd1b68a2a7ac733c490959b5a7032fec297cc42d7efa23bd246f37eadc8bf052c9eb7e913202ba72f4eefa5a4f6b9a8ab14eb4ed6294cd6ed3645f24573d5835b9b106f4b0a88cf2e1bb447dec4f58bc848af3e29333bd1758a963b25b7585918363992ab79a4ea90de051ce4c2b58a3c83389bd83d57a82b3eafc34864859ce903ba91dd5b0cd7548a0e9e47859ca3ac30e7f4e45de2eb53f77f2893ff77dcba534c69d9e9a37bfe891ced8170549b9920874a278b1213262c15beebfce5fb51a1d4f35b458dcd70386b5c337579c3272500708dfb96a5fea146973003c6e2a63bcf5277a44d7b04ccd39605d99b5f2ced662c5fce2d190aa4a6029b88b994b34b0e651ec0b90d76303a93f6d1a566feeee84e39f437e115666aafb372b87ef75f3b6d8ec6169c5ab820743a26ca7f382c2b86f3178f20c615a81500476649c81c29b6fa63c64bc8fcac0f53b41a85a763f256bcbee3bb6ec5984a1108de433017753fb5e7462e30a0e5d8299739faf408f7d686659dd8bd11e100cf84b4d8ead5305f90acbbd3838d40d94e499be9bb1506bc74249ee53db7fbeeb95b9116c4c5e23a253039a6d953672a65cc49f53e141094778deb654e6b2f61fd91826314d27048cb57b76daa8a08d67db77dc2c6b0e870e169620d86922d49d825b647e81621f2956c52376c1b5016bddddfd3420d62641b8f1c64acccb1447e5933377d08bf40a3e77d932ee179dee5782f78bd63bc9428d41fb3f0fcd6302f7744bdaab90a0b62e01f41ec25cf7e2b7cd46e6a0ebb586609287fbf7d8ef8b89f397fad0a6062fe631d8d827a03b866f181c82bc058bbcdc3b365b206cf8a8dae004a5ea242e67b1e3c6743d09d31d43b144ae15e50c9cdf5dbd38ad88e72a0760963ffa042a5dbe50b654d74fe7856d57c3b5ccaa105f9b60b6eef09aff6295493157927201a6ac36b48215ead79b5c0402e376f818fdfe0094092661523cacdd1a6e718fe3d379a15d3648cdc2ee53e6f2a68551ea2014d8fcfad4a1e4afc2a96e2a501aebb116cea0dfe8022e6640b231c36decc8ec86eca038ef98b5b7ca3fbd4d758552c81619ef9ce5bf6ae29f5267c05a7717abbc68950d8a693fcde3a7227bde01c96e0999949194660807841b3d6ffadd70350e99a6caabbc24c41acecc24be30b294cd6fdd6f8becf6041bb4fc8ba3523c8096823e1185b720cf2d22791820273f34493115ec5ac7864d6d15ff77ed931cdfff10e6422827cbfae3e667a23a0fc8f08d8c29e8d3ec8d104d8c4c5575fe7766f702fb3488b9ae1147f48ded4e651fbba29c5aa70b68ea9c370a363b2be298ed7e32f8c9e246beb2b630cddd881cafc959c7a10f5f858d7e16e4da6633b864facd0e39f58fb59653d1e82b31a116c123216fc47b6e1f19cf3449a162f87f95d52d61d52ed0b1e09dc6020e73ea283a5eea181903bb31de7575dc6768cb08db24c7a3ea909e051b5566d0f2ec85657035cb7e89e35a00cad7b386ec95fd86609020e07038ceef5c08f15da80ae560bbee67451b56072650aa4d0d090b2054577cb9791ab3fcf7e7536be1e0c3f81b66ce9213f1738f44ae2e1a4da4f080f22f4f42b27f7875ed87e46a8f78fd7b98d99cd1d25035d1a38ecd65d47b81b79363ac2b0947b63c45d754c53ea9826e4af8fedcd802d3f05c16b9d2bad4cf306fa2cfcd2e6ef1ff0b2aee7beb8300ac1145d0ecc334adeef619256c28f2d632598f5ec9b34b393757ce087e28705d41666d0b1d5fa624bbc9058412b465cff84ac5eadc6a5cfc96cbf0bcaba88ee8fdfa6a471030ee5efd6f475d96f81644d1d5ac5f28c26f77965a012a1aae53bce5195dc81e9bf61289fc60c84129314df1c1e7c1952aa67e7519f3db299793d5611f5e384c74643443909f2a57dd8f9b7f9ee83b79a9edf669ae6400aaeeec0c1bf8c43385ab6aba0bfeae72d87dd6ed0545413d2945dfffdd8c56f3bf1b32bedddfdfa24a7eb8e5307db429f70e68dc80d007bce5a164201ed1ebcb67038d6c5f4c2fe053f1d54989ea1c7e7d403a24adcf6839264ea3a03905d910791e42cdf429ba03be93d3344eae7ed4d160f5d5246a74873e9455a08443794cea1bd201710ebc0361355be780366b4dfe5fdeddd6638c8a0b7c9f3382b27db6561a3902916d1cc1fba41f449f283836b659b41c5adf01aa46162bd3c3b50e7ef112c1bef4df4c5d418dcf811d0ba2b31c8ea572ada8567b6712c1b2599d9450b57fa19fe6ba7ea32f0530296f3bca4195b436ee9cbf259788a14f8ca023ff820c695686e6456f8e5c4f22b6f2908b61e0972f0b8816e9928faee1411c06830811a7454225acd051ce4a2e81c8dc76b221de14e2256fe112ede5e95393f06e6b7ddd30dae2837d7bc4d206bd39c337543d332759eb14201c489d878ae0d1ed7ed813f31c5fdfd85b893666bbfa7fb842643b6feaf0f62493d86e8007fd335f31bc7d4f0a1fb77b2608ad2058c86a5d6d9e35303aa3da1138d799949678903d1e9de41146556aa536e085db24b747bb7806a9f93cf2d6eb0db7b9616410f4b343266f4d2b89987a9cbab09a335ff22477a1db2f2fd0afb67a76185e7eec97ecbcad2fc3778df2627175a8087963613b2b4a6cb37a05aae3dbd7838990dee87b3d7972ab20568f710aab57698473f324085060dfc0e66ffa00b3ad3e702edb2cb6f941bb2f68b5411f36d5430460aea7af2949f936da8b49846e7821f2eed6a582063c77ca71731dee8b2df45eb65a115fe687d14373caec9a9d1d3632a3b0002fbafa576effae1f5427c6f07267ce28f50bcca1a931afca7de07c089d463333b3830498dd21b412b21a1bb905f14e01cee6f69c98b3feff8f331a40db69b86678a28f5fa022ff6fa4f5ec58c562b349317cacb54f5732e515ac7d531183c8ed252dbaaf217ff894d94df256344a7e4cc65d95905896de62d9eee00417c380b2b241f29edbd609bb39f9391a83c4f164d8f0f9a8096f2dcea1ce6dc89c5482c1f476ffc1ff978c8712ca08856ca43ec87e81538677f12d350badcf7c46482bb696165160632b2f3b0f300fb3e420361efb30966ca4875e4d6870873c4ad81bbc0826a972daa7b8e006ee8f87af34f941c119370504f1c3b4b9cf44eb66842234749963101f5f7e187afcdfa4ecaa1e7d2354ff25d9fa1cc1ff87cf0e614b22389b4c514956a70bebe42bc477aab8dba477be9e1fedbc5a79abe9d692d399a9b1eb3af32b569d98714fbd716d358f3bf791d6090fbd3545726d1b33ec32176d64dfc4f9dab6d8d4cc2f23afd0e78d02a71859c820e0eea010573d9ea2066fa21d7d4d3b37b17bc2de5ec757a7af9cf77773c122ad05a8974d88a40bb3ecc4e398eb090ebacd4479ad8da2fe95072910b057dddd41b602a5f9b381dd31cddf41bbaadbe2d5593157b0b06a18136bd0bd4e122436e924dd7f78a7311b7e76eea99948ab4880f872df4854e709939779ce85eed0223eb76ecb6951730268b443322cb51856463d87921a6089a96b588a26b69bf52f347d0fc7c138262f1efff4ecfe823dd808651985d96d7e481772104a3fb66e4fec32251fadfe7f08fcc94fcf565c99a000bf64111d45e30368ecfd94a2f1d0c6f1199a57ec8f74e4f8d1c0fdc93c5efa14de430338fb08ae828e5124218086cca1f4318ec281ee237118dd0dfcb07bcff875609ce79e1b8c3945d3da3d816dbcb1aeef3c785615f9582b4b448b17b061424608c33cbcd6a783ff929e32e73e2df3e637ea6cfd3c476e172e6866ab656b0ddaccf7fe465e729f59f331edd66257970a6d1bcfbeca934f3e9eabba57cc9455b66ea9138d7cf2a1239d7fdfa2b6331c7bbddf2ec795e3628d4482b0d2b3e7d5fe16595055dab0aa44263d8ed31d6f23b86ec4b45ac32c85424acc5864cb31aa9e5ed58be6abd06be0cb737584b799513f5368aa154a79a9ba9238b9a31b3b1ba7bb1b4ca901503e1a7c38445cc4f5bcb6fe197e138a9066c6192de77548006937ca534f0cde19fa9832c660e3e030df9b554d3eb92a0e50bba41d567f22d607d8456e0945ab5fb7f29846963746543c57c37de4f1e46283d43ad4fa871fa04eeaa731d0b6f17179f6d59697831d95d69e02ead3cbf998bc3ed3239ec4d6a4743955df420d562b9810f418f85620bba7c09e14f052791f48c0452f0cdc6b2c2b3cb28df9763ac8173e07249a0426f1ef2d5050e26738cb2f75dd57b542fa419440b970fea74f09046ca4d72ed6fc1ba12dc1bef2d540bb980c9bfd7c754f7b638498bc261e57b12b34da2abfcb8e3e9f858962444e43d9d64e2f6f433e706166b8a84616ee512e4d3693a362c226b07c67ee1282614e5c72b312511fa57e049ff3644aacf26c6ef5acf990aee1fb8120b4e447c9e0d25ee87b857e154e4c6d81546933ea3cbbab75e32a7ac4a4da9bc4f7a8b5dca959c18f6d2b2ddf1f3968e177e253196c8b33b1191bf10f5882e6d7e346bbc384cfa50fff2f39e952952f5ea79e4fadae5254b111df64a733456b7fe02a585ada28f0727211916175cc10bb65501619d82dc6b8e0bffbf7e4764f8135210219e8c026a872887f60d705e201218dabf38344731936266350ecd39ef67922084dffa8953ee2e31ef31b6cc3d19e5b7be5528c73d126b08b0c98e21b70f06fa5c038de7db432b50c2a7d80b871d6be93ecfede39dfb4af5b481561a77b9e892ec291a8510376de0ab264aeca18fb63e9676f859edb7391d57fb726bb59dad464190cc9d11051abeb07b8974b5007c39fd4a2c218f17a1cca428410317061e37fbe918d5247c798b78cecb6d217c491d6738653d7962f4d693665b4e83c1d7f90b73dd3146eaccde44b8c45549ec74b634e7d371e74540b59b506281c83b3f1fb262984186624274ee4c43f2bcce79f073f81ea87bc74eaf55549ce958d992e31b5f6b1fd4c325269d2b8f6f79fd5cca7bfb575a0f6ab490b219fe5144d6b60aada2bcd502c07c5e16dbd57a3a3459637dafc09fe388d960ee3b406738cacde24f4615cf47770c27b8d713786fc6e183c903f7d73001b4a3187aa51294b1b862b8b635d8a3c50c28c07a80c5bf07ca53ed1699f76067f814369f6104338123a1643e7b7543a486d0afefe7e5fb6eef7145285b69c62f4b4202e796d5386975f253dabf45e62d11d9fbef0a3cffd40f4ae928c8cf19004c1c7058ca6501adb3454b2b1a2b7c5ccbd2437806ab278cec30c2bde72d9b07ce738b528772f66dd4c240ecd800553abe190a9d89175167eacfa919b3a086562042fd9851ffb8ac0fc1324bf683b98e9b3574a71ba4d6b55347c4bfc75ff347268e9711523b3771f7d7dfd44e319fd63c22e0ec3e37251c0cea355c84f8a189feeabef06ffba44527ba26b1ed5c62b683f99b1af8a4d96e3847f5e9865c5a4685a6250ae7feb307dd16bc4d7efa83e4eda8fa979697cc7558933d44980c0c4d917b5a5629d49648c1dfa84be8357f4ec6b0e90b441791dc32cdb7d22f1441a120b1710cc5ffaa2e97fccee16db8bb0bc588be5c229e231bcae1087b2cfa5d3ac181d17e1610d1b1ea6cd0559a950bcd654ad45fa9897098d894d1487ecdc7f4711c4fa050e2d086f79deb4a89bb68ab561a37ea3571e40e1d371705c22c409a038b486c1a39a7d33a41d69cafafdd12c5d8ba784add66285fc418001f36a0bfbb47e1515a334299517491154c891802ba1f17ad22219769459bf0e803337461bd482dec2ee98c459b33b3039a4856262f25416e0bb9eb7be1de12af8aa777c63051be078c204c9fce389c2e4941e2865fca046aac29b9a2d97506d2eb8f439caaea01dfa28af4d8177ddb65aee7683ceafe77fde7cb8246d733519e0e5cec77f242d7ea1f4985fbc4dd2d622315de93a5f686b091ffe3acefcebc4a6801b16ef54888ae369d7e20aa217d26702e69a4dd4ab7eaeabc2cf13e6340b668ba12c7c4582dd07c4b9bb9bee611ba978901705342c8dd2b1204f3e2364a33ef4643a08e0660fa5f952cc07ae05efc3f2b3f05d41d77b03c20d143403c0894c73099a557d47647468389822e8b2d196a70fbcfb7b1f1b123b0acb2ea8cc0e6567e64172820c9ad77cc8f0f3d5b20675dbabc272613d9478c0a2142f45e1f0e9e8536d359c6770183a7ad35f8f2be0f9de370dbd0de54d8dbb59b0ede98ea198510cd23afc4a3290b0fd5b9be9b45362a6880bf5cf087a1e0ed388cbf7d32acf4ea97fb6bec2414845603bad3ac5a67cc6f82606c8f7323c8d6f5b4593ba27d3b414502a4e37214f5091a545c947b3220a124184656a723911feaf0374a0e9c7708dd9945e79cb209d6dd9773b0954659ee1db51bc3579941fbee7b95c5b4b114d090aa22e9df8e2af20451aaa13bccbeb046fb8e5360cdea8b04565748932757108c5778f590138e36deddefb32eb5fd69eaa85952fbb63f22b6fc9b250f7c646f0dacc4bc6ea9ff556d6f264c45c15e89711d1bbb9460758b46e29c45fdad4883c523307b577a66027b7af3730691f4d285afd32571c4671ce4eaa9c100a3ce80a0cc2bdb744e66185455f5cdec4cf184977f85d7d918ea9bac1ac51adfb5eb6128733aa9c0efe5915fa6b410fb2811ed2e9065cddb0cd5f43a7bffd68cc9be13b132b3421bc3728a8c3e47e8c2d50b51d9789f21580d168241bb3607a060afb6978de8cda0770913a79e1a3fd684a19e59274538f3c28d51cb727fc16f4b51ea10d8533ae4bd0e9c0eb5f164ac86c5371dec6c9c4a9a18285ae27a2ce25df1dc04e9063737ed5444ef41dc26cbf63e5c3d07c6ff6e1a4c3580e427c16c0c943b8e43eb2af3f37aab926a3de10d30be9b17b74ef3a80f5b29be401b305449c98d317497a3a7aa38ec1beb4b0caa34815867112d11affa7200b5803ab517249dffb0d1246c46979a4e9a1cc599887929a17f6d334b52519c9c73a3f2593b61f095d092df06acc924280984c888a45f2df60b2ea1841e30e87fff06935c99e632448908bf24a22de4a485ed00b1e42da7373f24930bf9ebe5ad5c68455a15a9cff4d3d9205f6a70270451ad27ff72c4da50e49b7e87a96bc311f19976247007e293e4d4975e89e328b6e58268eb5644e22434f27c94fcc3b46d9403b0dd1b227a2f159154d2178e5da4574b96ee61cfcbc2c24dd83fefb5a8bff9220ef288a054fa3aee7a1bcbea7bafd13e9952442857cfd23c93d6e1a6a7cffa44f40bca1b784f56f65d94aaff5b940bab106302116bf688901b0e6d871a9f5b710e7094f18e1e7bfcbfc582c8eb118b37a5cbea15cc69cfe9e2d5ef2d910899e5ef1fe809a2c773a4852ad6b6d563a491e54280b314a953e76fd48ba05eb5b8c954f121ecdd990886ff7dc903d466efbaf53f11a375ed20c967e832b47f8747e1e92148eb97b1b09dc7215509482b49f3df7cbff55516537bbbb4e35fee1a9a45997bbb255fcd1e96aa55578de289bb5948aa8bbb4f1c66a4f2792ac90feb8b2e1a6bb559b82310c85368eac084dc09745fc2faaeb9db9130bf90945c4de78f95a6d7d4121542ec52f039834725c8602c6f69643bb7c39a68b8b30decb4ac097be68387cba68b59076015ad476cfe5a5ecd2b63db333fa387db8761e441281b5617a8cca2f8bc6ebdb3c0f97905d3b8d06d555cc8771df6f72ec8c68f6e2540251192e43c0ea7bd45ca2e401857c509a7fec5935fa59062d74bdc5ea8a4d12fbb151a4b9bfd4fe65728b493083113b4931c241fd23ae957aa1f7582b037cd6dbd63bf3795b61d901a5b8b0a821b2e2b641cd3d4f30e28f6ba236c28683393988cbdf5257e7be24606fb678a7b89f582428dfd49aeafbb0ff161e726234af6a341d89d88c3c804f205cd4de34fc2b1afbf477973275bd9460cb91db7ee336eaab346d4effb227974433a9a0f6dbf8272ca056dfe2915c5fafe4dca926d0771c58c60dd3160c3c0b64b700c3fda36128495fb818c23baf67f6c3c96609e9e5036de9a9fd28c4b309b34540569c4e590af723954cc8d4964e88d5d298bb22f7ebd9aa33177b605ee174ed10b38e16c304732362f9fe0c3f76f451f34ec9f7c33020972308372508a132e4a5b2094bfd29a8ca1bfba929ee037c251cb49534225133107951bbd43c59c76db030b1a36bc078e42267b8b7c66c14cb838ffe4119643c1272f85eef6612cae3430c2ee9b0b4f0e01ebb04da8c45438972b488a45acfd0387089ece39d50910d70ada594e11c2620e2afa1d5fe832a84a43076e804eb27d4d9c80f483c4c11d7061764acc6433979992d404f72458d061bb52d7c30b3a5b74e960f634fcd914c7f9c96a91da3a9509bdc6aa54d08e8081b5a6d12a9289919cc549b866872deb6f78271fff20bb06d87831779e323196c928bb0dee2660c580e3a4e093c5f1ce57ac9cf62c7a3e73f74d9f49f5c87aa2dc0432cbba99893e2db240786d73f4ee70320e96e115c6aae8b41e81f86051e654bb666dbe0e2df74dbfd2bbfcd49be0cd19813f46efb9da1ec8c0c8ba7e4f2874b5a92180dfdf82fde3fc1d24b45c39ae89b7c8d386f42cc805e3bd96097a3f397e9fd153d85aa38534cfb6f8e5124a8ffaf0e93449b4a32551e226f8cdfe9c3ec63a8b176d40007db6f49711f9058a04c85bfa05dd5491b14a4aedeee9140ae5c4b35aedd24627340b70d02ad7de580ed8a24fda002b555b9c8b9879aa1c24443da25b2ab4073be825643df561ab42124c22f546e8a37bb3d128f8e61dda4d03b4fda5c59c578acbe54f26d81b934d2943742e34924fa3c83b34f3cf895040a084fc1a5ad95087c1da108cfab1d8f162b7095fb3c2825c3aed2b497ab8fcc4a0480b989214216048ef44d88931a7b1578c09c260c3b7fd691476311432e313b8abb3408561714dbb2cc2e2c594d58d3543d266133b6357862b5f2526145107695bd78a8ae9507221f04e32f6e35483bc6d749dc35fd42ce100ae919fdb1b45aa1c27fb843b46945db9809c7ec4acc649a9ae52e682b14e848a0b0e420ea96b81a7aa97ab464d119d59f7cfcfb8eadc3769780d2fe20f4c748d1b0382e7a24ce4e718933742baa0be64b50aa7c03e2100f9b455f55dbb6909bc06812997110b2f7991b8c7db940abe4c63df370ecb4a726cf8cbe1bc643a9d46b236d707095779e98f8ca928b7b0546a2dfd829c6be317caf908a62f78b476083b9d27f8aec6a08ef51ccafd379c19b86d74093109a1c21ce72453ca7ff5fb14759966ea18ebd761daaa7029b40e8d0c9b53aa0f278435e3471abb247844e490ca824cc1e95abc32fe37bcb5082782cced02419f49e563a761f34102f2afc9e8e7f53bb248293b10f62c4365e61ede1de97ae52d8379bd188e3197c2aa66eff45c11e9323ae774faeb53f2cf9ffb917c1bd113f4d792327b8d6a0e8af2a2250c94e334b1d5d35e2d80f06ca7be10d783f28f0c4e4373a95e0a156ae71b7a3ed99eb1515c7394b4954c437452da600553afc2f2700fca099b4c2acaee23814a74d7f3a3c2d01c3ad8e296acd39f171d8717ce9ee8e11d0a376d4ab35f38d1f1301f78273de10c4f2d464a0c3da3f1edfb1ee52b44c1778542641f5a687e75c3d9c0b9a5d21b517b8539cadd72b643a4430ecab7d9f6b1502fc04f0518b579864355063723234c5ad2cbb954857f7bed9ebebc73e3c541330d557458074a54e8fc071f3426a5a310e32bd5d15a5fd0876c895075f1f82edf065925e518e364dcdee15c7961a2a2630956af34d1f268dafa67e37e1e0666ed7c344a60a8d43db0a363492fe670999a2b93808f53b3ddc2853db5e0272ef1c3d652783b667e3aa7beee1e4482976e087d3dc8880dbce303a66d09d82239dd38370c6487ea532afc185de07444f1a9cd4878d7d05eb49df47001ed62eddccbc1a99aa5dd3f5fa2538f9b730651bd17465136c8409c5b3d0b3c0eb0fb7a767d5c1aca2bfb1856b55519878cd9f272603f6d42ce6430a2f49d801f46842bd0af6e735392fbd8ca60f7824588adea9dbde0171f59cb9a5bc99c8af43253afc03b3d5f691cccaf2c2999383fbd9b7ac39bd0408e46cbe77d54072b701430a1b7719fe999e0957db50e9652a11fa373823df7a7acf36c33de9637a8cf82f809556a727b40231efd8261a3e0c7d2cfbceb64d0ba0fa87bec7df9b04a5d9e7761892b04379ce1efb166a1afdb5c53af7c32a5153fd7960457d0294542c7f064db35bf046ac78090b863d9cdfa9ab0971ade46c5a03d892e68a25a2af5a9554e226cd55f3da04c95382d1ab1f0f76029c58fab275e2ec728339a05b614c6f3dc0ccf62bc40043d91be873bb725d162c1c60a08c629b3d01ca1f26e9989fb6195e4acf198045e854cbc066d4db4a8d6fe239d7cb3623c14e22c46a5c17dbc60076b21758827ed5749bbae8fb965f03bb3a887b0ea0b087b78a9fb5471e8b8617ebd9eb4b92c12d43db46093b8d0d211be29b0cd2f7d90f4942c1b1641878b174b7d7960e58f090f8f7296d9d49f517e74e5455a9d2b9fe2aa2fb115688aec8af51682948ed014a94346c3d087c7a3f6c0cb3ed06f2697188a7e7a68a1e0d9677fe927ac1a05326a9b6688a735e864af167881ed2a9383940fc323e1a230bda10d8e4756eb64c0ce8517f8b0a71c0baa6d6dc7262ba5c4cf58976c856ab74ab27703042552f03bbda49916afa6550242b61b90056a561d6eea401d2e8202b67628b24c4476fc2d200cbd57af5195587bbd489ea388f4e5066ec5a05601cea1590e70a0e9cbd7dce5a73ff3c8bc3fb8f03b86216c847ead885a0e85ab910642072cd80697b2fdf6fc315fd9b64803f270b796116529f6fd0471bf2c55eb0848c8478a74316cd140cc09ddab6dfc9066520c94081d0b5e691cef5fce878fc04f7b923e22ba154a9d9701ccd7e592b86d2e3da166a68d3953ce54d410ee8dd96fcd1e8ad4811ce45c45e833ab30ee5b09fdd32b7a09823e13197c6afad34b9fd5924981bdc21e23a55d8fce530ec24b646136beb9cc219c797c59d5f8e2c7fbd1df8ea26c722ce826c697bf69e2a731e3ec541eb5e098bad008fb09bd0c0a0a5bc93287a65987f89f23d233ee51a4c3b4fb1fa71644241f8ea28d120fa1875f4babae350bbdf04dc33279380e8e093fa84717edac41f12c32a752470436ae02b25daa6add4ce1405ac732e879115a159b9e6b0b35fe6085372a99646901816bc365a3772a6416b767761f290f4d269bc837c440f42f75cc7d1b938aa464a3e73dd752b922902f39b04e7f81c4686c617b1eaa7b38e39193cf80008b7f757ded4e0af63242c9d2a8f95b2d9d6a9d069a0812567c6ec7873b9b49d0f64cc1b7968482d5d1716d7ad5c757553bf830564aea717a9deefa647c11d47c0ad0dc6592088a134f10e9195e8cd139d5a5271d4d9ac88ca08f2410bc1513ffc8741fa2e23a0f3031c07e78b6d83a1f47f2f83c2fa5d8ae37106f5123d60df7879e8212a40c4df24aa8c83d32429053716e5032f8d6abbf56fdf6fced0a2196df83dd5646d32079fef37866ac52bbdee9f27e27d9ebf29aaff6a4ab929d93b2eda2068a1e98254305c8cea866fcf556be32315","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
