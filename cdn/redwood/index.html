<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6209a86c9a8b967441cb76f5df87bc4f9f90edc63c2508b503cf9cdc0a9c65ebe4e391cb36d68967cb837e607f94355df1f2bd35382c3b6d815a0176ec5e7c45961fbcae10cb41d47b22856b0cdad27791227f26fa3c958ef04f26ebdd2dd8140e9cea2ea83ae8694e02af3747618e9e7bd13c909e2e03548b03961a28ac83d5549c9fe25d4bc0311475cde59a07ed5b03332efad22a8702f2275d0c83f813edf168fe4eab8ead9800e1361b81aae92a77402e01a189b882d582bed187ac659ad559c601ca76abe727453201370d370cb45b23d839885d1a97dc5f5b8b7ef95a59ab06ae0fdb0ef798dde568b6aac7c3aca43cd4430c8b15577704b77759009b6eb8789937fc55931b34d7e8c0285d7ae37ec60a0c99354cb107f1485b5b2cb0493f5de2ae9a3d42733008b607e8bca8ed5d12ad31209b8a6c5ab7226944fbf1447a31b28d3ab4911dde472c9a27cff6592fda5b65ce56ac4714ab34673945562317044f2b0acc783abe5c6ffba7292d21c15462d66ab41e578266e22ad032a21e9de2c00e59c38f31c4fe9219a51d7f7361d631835217384b6a5b3904daeaf020b52ef04df7a2815e68408c57d50cd480a48cb52d305bb89f342815cbc3144f8f52c2815bd87ead9a50dd38a5ff098b99697abced25780228302a9c3794ac5d698cc63a8ae2a113e56ea41498e4d600d534bee1583da47ba2c42d789bba1c53cd9607d87f9410647a60e1068e0db3f096c239e9d5826e9d7e5f024c7b6f3b08748bde5ccf922022138e2fbd4bc9222a450c90b98fabe8cce77628a9e27030cce1d0e8bbdc486641d369d6f8daffd750f126acd61c975c677cb44b06024afb5bc426d432e2a3dfdc2396205cac350050ccc5f24fd20a632653bbef1c423028ebc4720b531842e8294ae4fe6e8e57362121a1e68e917613780d1699c041f3905bfd1641e7e96c85f3ea41355ef7a23cb303d77762364e82034a280eb52f9a7cf4b5b378941fccd0cfa4be0781f6ff2893766379d7e3543e87fa674c16e738df8dc127d64f3a848ae05950a1ae099ff1aa3b0b7f904721518d28ddc58c569f6d8c741f887a1031bd1ace2004f2653f80c4d6581239c27ddcb4c18582c0a97917151151128a8c1bd5bb736288931863ddca3e641924d5a677761a7ddb685d946cd36817220ad0b064c3d1d48faa9b0055825fb3bb071d307dbc185622bb5cd63b49905d2a8b929a76f8cf0304949f613347312afe5614c0ee5de48d51b5fb8e29625ec0ea4602a38b10380f81653e929d12f8139db23b7fc18c16a244b67486a069bef781f11ef04920c8a6cf2c6213179fe04c0735845f2b35122a5c19f69a4119d55b0328059011452d56021c32b8494c693434e04aca22c79d59bf231486cd7cd4eff2a629037a3ce856522b2b4166e2417c0d613197701b9ecaf133886802be78bd9dd7ecdc759519e5ee0821e66b5e7631b7e63784fe5efd0a01114d4698d785437db3b98bb6a7ca33bce4926f6cf971cb4c9fb3dc19d5d16e26f172e41104c72f56727b9871bf2745d691fddb9384821e7db97b923cc9288dfb210a666b57589a210c67db14743d80dc487b76cca00205614099eccd859890b5aa3b329c72bd1226954270e6b18fd8653b85e81c4dde46ab1b3fea2e2f0cd71bba21b65f3badc720f6a7ae9bd3b564aa6201457d89018a4ecae0d0853c2581dfbbb433b2be055a33226722416b27dbce808ede120ea81de9b647171d421a5733fef417b95bad2b8b1048abf3daff16f93d25901a97baaaae615a3972aa24a3e70b397e6e9a551cc2eba8572852fac6630e0bdc72054e8053b04b0d4b0f9d172152565b7c8a0d79dd56e5f77536e594bbfcf238989426db2e155f22e9452ea8b669422a3d3463cb24acd417f5a31f280db33ba2bded271b8319e95ed7482d7d5e3b42ea5c6d5618269a91a47b5c209e710672f0709f37926a0d9426a976053bcff5835115b76099a723875a1cc4992f09e65d2da48e9f6005046a18890cde470c37cb9b7ff736b30d95e7c1a26d2bebcd23e749efd66a8eb7afcc23510de13ec64727c30d3f8c1d3c61a939457c00e0db898cedffcc95ad02abc06dc16d956d4ad09fa1e5a1f6d80acdb6391de19df58efb3983e42aa3aea89694a80e616fbfe5a85de7a875d885360d434a723e29b0ec72fe3f4aa0945afcab0d99fc30aba97feb02a64e1d4f483665b459a1b5edab2006398b41c9e472225fe1c21ab8ed7eafdc2772bb278d5c82cf6b3c48c33a02dc482e68967d53a4c86b5f5929b175c0379587368b1773300585e09f0ee5444ebbf768bf2198c137c6d513daeaf54708efb3df1af252234c8e999c548360f8388d755c572714563d4027ffbe1f27889f180800b9c2c8d4996826cf14a43795492f9a23adb596c0cf5ac0a56d4329b101262f0b56374aa04b9e29b0a38f302719c018fbf08e1eef57fdbbb6834ae9fea894be69246831348c82785385899b3ed57767476444e97a7c4dd037ff7f9b5f500bdc110b22fd67ff9f7f4a57be1bbc10cbf292ab2ee2f2eefe9423fa27c484cc00fbdbf29bf21c7a66903cdd50ed9021da0d871a838c0d444a3f5424aadea936de5fc1be975ce1b8948357261646a8ff6d91ffe4b791127a6d23895352180883c156b1f21a8631a69dd714b4e94994f9ca29ddea54edffe12517493ba6d78dc7b2702d33e60f01c527b0e0caaba9f182a32f6dabbd8917765a812d7facefff58e8218b46b71591dd17f8751c6de13687db85edf0d4b1ca510297137a56b2d9e87e17c385209dc626ff444469640128a32edb01a28e118ec714ce6eb3173e875bbdfb5be30a441067e4a6dc9327849e811c0f830c57506fb00d56ff4dbe29fe75458c379bd895a5dae20dcfdfba2f486f3c7c8797587807cde195b090d96cea7cf486099390dd581dc2b01b34ea6fae832b5a85b8a2abd0bb03157e24a2cd5371731f9313c17a9177f0abf7845b22267dcb9e95b9fca69304b5e6ef35d06dac30adc565fe3bd0627bf9f634ed0931110b56ba926adac1ed93689637f4870cc0d54ec340f810ce2dee988523f12adba733ed4f952e76918733a89ba46b779142bc491df5f4c76fe71ea16502fe1df374b5ac017ba1d09a2e08dc3750282791d00f9791f6bfb7423cce2c9879b1576f3695f097dcb40bb9295fd0a241db7020f73817b0716906b8730ac86efe2a261116fc0d7f7fc757a041fd71ddf9f12d05e1141b696ba730fb4969aeb3bfa6c13e9cb3105df5034de439c22ed045bde60862cbc2e9a92e2e1b135f4f0c08e42899455bd165ab0ebc6fea10178cabd59199ef6ff13ede12754ec19bc770cf5231d81e8bbb5c0fd5ef8e4b4223efbe45810be43ec523f15ab32f1a6588a1cd23f309885e6f334e40cc1e9a4561e1da46f5007c5853afb8ea0dae953d1c65c8b41fd32aed75ce71fadbc80c26e1faf947051bf69a0b5ed5ba5b202f74984cbeb3d01dd307959b40cd20f5553d1b4d46a7b9cfc2ddf09e8198150a585e11d58746e2b1fdc13de0148f57277419e31a7162be865e233c3f4df9851f15867ac4997dafe43b8d21fe91454dd2f7010b521d0f703bee56d8ce8330156f1c1cd9d3660051b466d244b3b791c375eb57dc512dd166dbe2aad15cff9bb96b5bfb0a87052185ee839e9158298287ff6fb92f5d64afd3c5cda549bb7c9617fdcfac7cebbb1742c39f702a6cd8a855d930c3e82e0a859269a57f206b3f126d8699c937926f6ad9a5ab48b60f589242cfd8a9cb53de8bb64b4157f7f43973949e4224dc1c4805b3a6873922b37cf01647b8a13eb56f73715cbb51df9754e9a68391f0ec87bbb7178bc6c6050872059873839b886228e3bee78fac3ced793c9cb4836d95091b2d5ddf7d4bcd51e1600132f983bcdfce2aba3c710dcde74b6415374cb2f5d8039ff18bca1fa07eb76f65b9187fdfead7cbac4abedc10989e625fa34db859f9745520b49c7d67335a465561593a3945870c9cc315dd85b98e7021acc1498c638cdc14d1f0f5240ae00ddf32330c5dd244ef0ab0e486a88f527f74b8f81bf16b38ca18f680076141b1a3064165856568fa723dd04a0907a5fb44be00d82daf656e5a6495eb1ed5ab03c1ceedb1ec1415530408de3f7ec2599c8f2ab42b31427cf9122e593579f4b26ddefae57a72d21fc7004cb32fd47023a6a0828bfb11cc5d37a51d4747d6dc28718a89706ff423ebd50a3dc1c997aa0cc3222520d061105112ba2733cbd31d5c5c24e9e538f1bd6006df9b60c4e4b8961763079ae466ffcaa9fe8a735cafebfae1930b6fd33bc3b2bc2a64656d6b10d9648565c1e79df5b29e8a9b8eb4cb30e9bb7f91ff5cff5ae73dcde95fc0a2c68a9b1d39542f948f34c440bd3e0d7d16ed354dff23be59ab599c5f32835446e561a6c24b05d61d3803e698cfe85c8727cd84908166d055f674cd4e16cc9d483a389e2adac3ec4e662b32da4c1d87f378fee785e8ebc49be522766e3313a0487018a6fe896bbe755982c080fac215c126573e4b44fe109da710a4014f7e0bea23450e203602209e1c3fcb39863c097d3ba0d90de779bbb50b2920829f1be6d11d1930f968036e9578c190fb39aa1080b289eab258396a97729f5d487c0354eea7b9f70a837f155ef155b02e3e82e98863554dbc78c436cb84b487ba58a9621fd48c835a0f21917e36f404badda169c0ba2dc4154bd99d2a8d56271754f5a844528af898cba2216357005041b89aa8e332d9913a41fbb29c358ada16fc95b8b6e54b7d01ce9597330ab01d41424f99018bda3bd244adda3e7f4dd86a51a154de4e25c134e3efff4e2389aa8d54e8c5b9b22f5dba2f8886165ea2ca0e85fe6dae1291ba523aec3157e7740657cb8dd1a6c7d8a11b8029f671aa578809bf6a2507ba570cf82f1742d1aeae3a01f25909cdc3e2dbebb791a8a9e17ebe9cde726b76c488624de7ba567498d7dd98d5dc0e6fa2276efffe02f43a07af725e736d7d23c33f924ed749dce568df20fa254723504ec46c6b975199a03a1d80415eb509c4a0b83132c5444dcc52266ca91e3cf4aaec4bcd74a2c13fe64d3c19c24aeaac882e6e1cb5b27f5885b20c79742db1024db16e3c393c7e3fc485e6b69dfc8e90963cd5fe32518ca330589ebfb081d837d4c87bab65465f1df2323d2d075332cec704616a8305defdadd9c89bdaebb6d3641c2488a7104dc1a9c8d04187c0623d6bba8110d65be761fbc6334a204f43e8eb0b751157ec7c6089d8dbc6792cd7f3a29fd2e96cbc3804dccc1102cb24d472c7c8d54039028c15c6b3632f44060e8cd5a1ffa8484a059de8b03a74731410ba925830db4e4e5c5ec642dce25df981b14f03ed700235d065dc19773deb7dba107a1d5ed7cc1fd36d64059916978f9bb6a0e7643f9f0d818cc164f1c7f24e3f9caf729f6aa0dd0ca17421d5cffc33e409b456941f1b01966cf5cc65226634d8a36e351ac17807427db91bc538997b2a21902b2ae633fb53924e8ce6cef190588e6e05cf98ea369c75c6b75f4be2299a1920adaf867c967242290b3fd4021f6b689ee8a09a6c5d5a3d458239112f24732833114a7948845320339a12aee42c73cc8647eccf7fa69828f413473a001aaa2609843e060c43ca88c43b3bbd1ffbfe07f8bb9675387cef9e0cfa685233b9df0c2128107f649f77ab8627edb670fa6c2d9a0e7bd2f20dd585548953548953290a86ed67951ca11c65dca031cfecbb93eb29f959f67a9b30381ad7a97524ce86ce5dd402e7f4f16e97cd22cd40ccad55bf5b5c8a69172928ffaa41d885c6ca596c600b742675e82b3c2df079800f682a62d82db40c1aae90aeec3701e1e569be0e422a3ef1af0829f43b44fa2389d2c695cc00afe59ca19ac80ce52afc39c7eaa1da07325e7f716f9f553a1bc48f044232449a61915960d70d73ee8ae4587649051d603139883b3c90b093fbd857d17219f6e0ec93f210895deffef0d6f0233051a058fad881575bff5ad62fbe8b19c65397fd55ae0bcea8e9d0165946df95dce3e50e9c8818fbca71022510b4d1c7ea7fd7b177458d0223ee2f4cca480955a82a0583f07bb9bb4f05fc6bcb4eae8df4f7e5dd4f3beafb4d42f45321fceb27a6193d8601c2faecb77c5737ac477e6b3091670b833a7d507b13182b2fa7ac24eec4063cb5e576e13260886bfd335e16d746fe85d33c0970eaa231b7e8967f62a4135b8d7043462ae7cd49aef3d6f8ed454ddba491605ab04efd8c2cba6b629697b848e4b2070b857c5a2150246c186284dc470310b46f3a9c5243ab5a87aa7082ac76f06e72290a4a527f32b00f47b7b710e303ba4ee72de0576418a29ce11d02423cce3258cfa9a433aa5e525c24d2bbe2acbe1b95caeb1a3ad3435103b4e48f1aa48648ad830781196e9f3fc1c232eeb908a0ecbb6fa502d198faebaecf2d5e094eb3df8116833b5a07101893e4d8aa7cdb6a67a28570e0da4868622f3ac7ed0d8117696143d65122c2ce60ed73936bfba31d0aff156d3a5d731970396a566ef4a86fe64ffbcef949e3bea9832fbebc28ae985498436d9c7e03cbff052ec238e095dac37c621a7dd5056dd94a9fec9792794a6797476adb8cbe9a2e0502fbc3c0838133a140b6acc9dededc449074fd83191afd1d5511828b23166211eada5a0caf64dcaf31b4c12105d0f4d8ed6dde638199ba36e67def057c44a2c3d206620bf12af644d0a3f6d71c726eadc16e894e18de10caf16c00979c84c0dcec07c2f4eb590946e3051ae144fc3ef8c8edf3a55e0a52401edb8b159b082ab57941bb6a6f967c43827f07e5c340854b4ddadc98f7cd719d317925128ba55714ee42df93ccf1ebef59b21aeb7a45385dcf7f100161a35405260c627ee74bc64aab0fba99579a0ab2cd28c84f469b80402193bae968b44801fc1ad0505743a9c1c8c8176b688b419c7b2d2080bec0ab8c89cfd26495ed960b9a3be08245de91d81497f3f91628d96a4dbaefff72c557e117427c8d3f723e021243a4efbb820fc87df9015a20cf01013634ce2d034da45bbb6ed3e6104b0f8e063e8855731f1e3fdcbda30162c37d6af71eb13e47ce3f356b8aeb800f434e2fa2475345273f7a64d959aed68bc28b6c9d5aee89565895a13aeb65327f318c4f403fa092cf9e57e6a3f4de3af9f4064fa70178c8f4bad5fcf8715950ef3e28d40bbfaa8579336886787148121d29a53f83abb473eb17dcedce4d9b238647f1f82546dc2ea8d86fef51fa2987d20efbdd9e256661ac9e1067b397254dc30b3f93ba7f88e585de741332995eba30d26a39f07d81f43d721c44bef9e50800602f6e9907c7a61c6ac8e2064cc2c36d4ba0255ca57fdd471e488c09fe1dc9bbc7d4cb20c6cb0f59db54947c89d514c2ace20598f898a6789885a8c78aa869a67594daac15cafb7caa7024e58cb0b3da137b63b64a0d7aeb6881c5cfb23283e6cebe70c1d105680611cc7cacef0f568547fa91c6797b29de73c6292f56b76c02427eb80c9af15f8aaa34867bf7a3b88be210cacd6be36eba17be79902a527f3e4fd928a9d2fe09a7f8f66c6194e827b50f9404a173ead26e5c906cca9e5e36d41cf8d912c164d1621a857af2fd44d444b48b063224b26ba5b317017c375897195ade6a9aa6432735db09120076ee55c849a5736230b106969384753b389a225ad605002ee342b1648eebb184ed07e02c281e4eecb69eb7282da8d170a29f82f9685a6f527c6826ed9fca2580c3e4d1999c1db4eb77c0da82cb3ca20e9edc784d1fe353044bf9e5c33c2137da79e4ed70a4a57235be6de30abc493b5a9f4365f46061ea66692d49585e0b9cb88717f5b038a26e9bc5d328ca2eee6c9da27d113c69a2975da4075563fc6bcc01e625d363ff4961a7f4d7c084b2e158f20e6d0f84b8dc58f385ef95b5ef4618b346d825d5802e6acd36446927d14f8ac8ebeceb039dc74dab693aabc28b826167bcbf118cb3e1ad16f3566d0e80ab03ee6837fb167957b98d1132c581bac4991d4e273930e5292a378e10fb98466db5f5f1cd65ed6e102866bb8bf548b34c2d4ae807334d48a6d21f34e73e09f06fc0863d1f00ed5b1e2641ea31335099b0b8d0da51c86c7fc075840d8ea05c4e86f6b2ca8340b0123138cab4da484ff07484b33a8f0e6de8c0c7e7aabe9577aba21ab2de36401d93bacbca8618e2dc312a7f8a95902a388829ad3b6e4c1aa9d82a524cd65399e88ef6afe51138d5ca117eaa0eea57871f667c3d0b638153bea1bceacdcc5061f7fa9e5634112cc322139989a292f8450aaf3fb6071ba3a8229fe91a4f82d31e9794ffc136d4862511843646d5d56e07780e12ce4d344ec87f6d3804fa0434e2e6c44baac0857593488c287098580b117da1ba5c8a92c060d7979302cec134d20f487b4554be4ddc0a40779e39164307fb920a9b0ae73b1b2b79bd9faa963a977ae97e4415c8956fc4e85baff74cb8119efc38aa4cc1de460a1f03f8b576169f0da42cf9d8e959212d65f740b9dbdfbbac0d20fc63b8b44089a1c26fca4736c0a83d2082fe24376d7a9ea2e37f1852d964954553873da9059944b0f10fc2fb345092776fca44c0a660b6f1be6e35b8f9d6d12e6b73308dd21a42ed5e9e0a508ba8f7a1163d33d4be4143ae427f949ba37dd48f31eea4173df533b374942da9e65bef615401bc0da1d6e3b78475c3fd38b0fbea79fe363fb995ab7b397addcf8fbf0a15a0c784f5c6faee735ea383d5bd46cd4ff18af893096bdb27dae2d1f4b2d5f48e56f49508a18a0fc1e272d809406780f22e071187fe224bcb8205c5d27b25ebc9053065243491bed21dd44f46d0694d29289c39b7d6759d89f37f4d4e090967355e9753d19e30a78d688554445b8d0ea1f36af6dbe60c7038a62128bbf64197b33b2d0a6c47a6b14ce7d836fe71748d91660f2c251db27e810abc53151a0965431fac1b5ea56e67ba24f5cef966bd892d0917b86fdbeb8338c08b3905bd36923d30de848250692578521b04dc592fa6893dbf7e824d550193a3152d17c2c2118b15be2508a0fbb15c6c9c126f970d02d0bb585042120ace3ff6b8f768ff3907ae016234d10b4eef9ce7725450417a1c1c12db29509110afbcb572c82bc20a7f47637622cea08d0df9d1f6dd6b0799d5ff90f8b85903826d799b6ce60f9af5d5f1345b8a8b7603e94e1bc055e29e7627bd50df61671c397a23c0a470e5bd6ee9b34953b00191c1e1921a6818b8a87a4bc4722c8b7d576f50a6aec2e8a79aa2688b0906518e46f51ce3a10cbdaf2e8abfb4b66a2d4bd642a9241ecd48d816dc115c8efc18f2f9669b93dd93a0328efe6439e140ea34fe3b6035689894fa61f7f43b11778e192b94831aa06de48c2b12609e3a7fbd240d1f87d11b2a497863d6c01c8b0b76df1d3dbbd8ece74410fc536c60875c442f54614be2eb74b47e6cbbf65e7cc8c53261d125b6d15aa886a382e8f2eb6a691b05200e7196d56ee4d5c23fdbd6354660a815aaf32d94f9c8d1d8af1944af8c155b20e1d17f20958d041cbb2265b43d465a23d5bec9f3e859180bd0109cc9e03dbe8413d6f742bf0defbfa821008c0df80cb042c0b7431ef0b4f74bca7ec22de8bbd6759d33708b06cfecae0c3d7f0f89e26b7347bfbbe296d97efccb91cb05ea77d0980131650ead81f3c15e483aab8cad1c3d95af3e21c5f79a9f19cb7bfd6b6978cc84a0a2b3dfacc41e760b095da890b1f78030c83886ddadf441756348de4af1decb2cb1d3695afe684306ebc331f38a8882e3683c8e524e0a7ea7a8ad8385b67715709e056b372a5808c1b0a012038e9d7d4bfb9610e9ae620af024b81650edcdb6daacec7564256bdfb076110deb77ea4ec15da8da76e904fe0dbb4d42d8afe02816d9ffe38cb00ea65ca819a95a88d2f8449d025a397b575a163b11e9b02cda2f09c39c289dfb8c4cccf4799938b1e8d13a757377384a29658f1c4dc89c114d3e0c1b122c92a1858298a3ae093cf3be5dcfd9e96981e242c0f5aabb4c6089c2f3ff49726a60bdb8980dce101a394108a0baee3c89e1f637917e5dfad56644b5269e42ca6cf0809d42b8a9522b9b7b8a06cca1626f72fbadc667d9752b932e5170c4fd09f65640a8a2d6de5eaeb0cc5355a101abae0d35de8be5385016645814545dd9732795a2a04965e58941dadd974a6cf819872f82b8614e5f33b8883f7ac9eac0503caf9d1e8499b6198956b585b20ecf89916c8fb128f4a602d196e61af00df81aa4a1887944aa4a6b37d857051b2e0983a5d152c0120d27589537cf251c2b2671e92fa14e97143aa1fbc7fb97632305acb8e33392a9a9311ffae1b7a9fce0501020d36eb7e7fc2e5fe675a73b19d5d3179846bea1da685321cab203d92210de40e7bd840aee808350eb2abb8d027db150c36b149a7e7d34fa7297834f11a02d83a95a014b22ae1ed6bdb0b305ceb7b1b15216ab0029b45888f91df103ea14adc94ef0007b7459aeec4a37c2d172063be4bfe64612c292d230b15d4019175f01e21b0121b737266276fed1889fe1371990ac3747cb2f997f3797ead3ce9a14a37229d3a3fb1273ccea3d91bd3d9a50e495d0af9b436c13c21d73630c9eb5beccbc5e7bfe577b18be2d515b3af08071f3658a559e114ab2453685adfefa986b01bd82e3c930d050561303c207e030ef2b79636a2360c8ac0e268bee67d2a12189ba0b74eb18a9b51aa860ffb6bbc2909532c6bb2a5999a558626e52386ff9d0dfa9a98ca3493ab4dbca9de7001640429f48ff911acd73c10c7b8e8f6d0cd3bd91b835bb1c21e72c5b7dec17ba500ee853fc27cae1a6767fe347f33481a260bd72a5493d1736e610eecdd810bf2f6c34923ca3f577a2159379652080e87e34f8b429e3c6c0a73b6a2d4394aa664eee189a790b2019cf54cf469cd984f585fd856167fcdb0e0a9735e2df9458dd5140302cd6384a462e4a965e684e77af390efb26d43f133ecf62c9ec0c9196d7034cea4b7431e87f2874cdfc669a7e734b0769130d2f95f8860ee06ad78fec41aa64ba4b8146a484bcd3f653e5cc8d16cc94bd09caf72493a9280ad47c60e749dc3c3e2f8c5d54ffdd94adde23598156a12dd676f6e8c5a4b63945689532d2938bce40ba3845fed9e67ab5c98794e27e8b0c8f779d367137935edae7369ccb250f78bf4d1ff405b1ed4ba1649831d59f9ee70e9ce50737a0043298c04dcb56094e607f6c8d2ecbd9c6f0579f5185668c26c6df69b020123ddc2aca2facb83364954c53ba90fe413af5fac12bf96eb6563ddd7b27cd58427808b4c7ba34f3e768e2c5c0c1bc0926abdcfb580b631e1420f7b5883fd9280b681c645a245b099bf8b49c1aeb7accc7925405d651831eaf721e32ca89f84e93e0b54ff05429428e3c0088ba0ac1faa687e7cd139fe37b7dd2b264ef50a56089636e4c2ec32c34062e82fb18a2160ba31573529a5be4614e398915315bea7005c10ca0c0892f20913909b0f87fc134790a150bb69628de5b8e2c495d952ea2b1927e611267b2550c0c874e09e57a9d17ec43c757ffc791514aaf4418a04c2b17334d9d511ae5a3d9be02031d0c03176ae8ded48c9c5dc5be42d77af22be21f8a847c64f9336413fef9d564b32832d6a8d9e4baca03121410c59bdc49d8701fb7a9cddf48fe4789d91ba24701a25881824605212fe0ac4b9215ff73e9d69909fc666ce839f3ff7d92881a2ca25097c1691e49783ad5e9243f5d71a682d6be40b7bb4ac12205cce7deca6beeab14150bf2b832b930dfc28a9e1c4d2e2ba78e1e1c18b09b74083e91ad73c813b15c68772ae67821596a60e6d85e0b872aae2d653dad41886973a00c0bdd6d5ef4626f33454d947f66f76daec271ff7cf345636e2bdfe330aec8c934f6f3c57457500feb35fd786dbb8f90ac68cff34bc6cb5990d36a18005dad4609d04b50662a0565586faa66493b21919abb29774a2b2381f334ab88a156c2518769a3fccbbdff5d4b4469acb92e6765cea5761e43d414e440aefff86158301e15700835c972e789fc84c55cdba7ce4107a25ed69c8c3578e389d709fb06dbd14bb06e42d63fee4e96e48fdfd03d00c58791da310beeb3f797018e28421798c5f323abb2680f092c3175cedac5fd2822b96d1f5f0a4b57e3f1ece7a25d5f19df65bdf8ecd017b966d3bede0c8a3a9bc56e139ec936c917ded44ddefdff344570ab5fef6c29a958e5d461b24b6aa580d41c5fe9e9a4d3e7031aac2441f911e5fd9779ca7c8c4b4b3991313179e9de5fd4a8d0986d63e9a05a3492e8653bad34c14293fd5b610a5f8963757d2bd7bf929d3cd7330fd088805b9907fd5525cbc17653804377053848e046d0eb7456cfb7f288c4907596ae613b8842eee28f708c9f5c5709c48b19ad833d65b36a74af600509631cc053c7d18d81e9c48cdce4d72996b7e9b13519ce6bfa91b40c3f4739fb60fc0846270bb22cfe630dc57f388abbff3328f3aed46322a6197636a38543df01ebb0191ca687b997dba3abc28d10359c5041ec9849fc35eb2f53fb5a42d6a1050ced2e7926203a766540a9f5dd32e3f05a86da8c01d9714c10bbb12ac8984703f59ec577fd1ef50fd5bab16b9478bd74a3be1e57ea667b0bf7c34234694c7d7554d0912a581844a2f157aedb04ec0e64abcdc5042ecbba38688deea53becda4f6397292a222b6f9d75ba7e61ff1e81655ec78636fb1ee3f884e4fb047c358ae8cf533427bf0e0440d2eb95ed6d242b7ad39a43e2fd855df190e27f43bf3a482240479e0b1ce4bc601e412723a75c1689bef9f28c774f2fe31503122a159c64ea0d77a0d4a47dc267d520b16a522c1ddc03af723840ad6198a93d27ace109fe678db5e93a969be4f04039265d1bf281d2c625711d14ec1d3fd7e8a026380920eaa1bd1318c79a13c78d85bea80986c9d3dcf1397e277c2b1485bf45e579f3335d96f30159998a1e902a5865a5e0ab87d53b09221c2a9350bb41305236e954816fc2a2e95f1657f5b9a05fa731a440834bac800561a91f5b50a7f745eb7b356b4017a8ddcd75b286770ba285424056ebd2e60d53bba9b32d7878de7086f4d26d761346422fd94ed827417bf581f4874518320ddc3a8d0ad60dc26ba2fd9b02283799ca7bc979f9c2a04e01c976d24184e5a04e517c7b45d76db6acfe90b12139ccab00362cfd181a63ea781906b2e95b0b328522b69cf058ae2d016732141e87da659f0ba48a79af72624805a7aa6a5613b3863cf9d993c3b7a1738b5c604a60d06a96b12f58cfcf70aff3e22a1402cf0a8dd5cd0802a86a2f6971afccc336222823037f816c313e0a14afd59ca003192c2f29f8dd1b3c50584c7423433309ec3e6fa12edcfc825c26f431652cee8593a2e1f7f8a0621d392b88754e6c50e258989e4834b44a78c70c1ec5473aefd905818498e148a1b1b8a8d8a462fa51fe51501ee3847d20fad29bcea8cf502d8be9018256cac0e8b44b48630d9bb7eab0b5a29fc63e326259a776870a76759b4fdf0d5f0fd93b180e8405595d697b6ecf683868659341f344097463f38212d0e48161796b350bbb70fdb6ef08f0bbbf2a31e45c222f9c70c48ff43ff0beb7a59e2cb8f34c9ca6676a68a2b8b6ee238c44f5b1b479fac59f5c5641aaa46d58554e25f90740b03405fb0f8bdace497ec4db25d1646107c89f8c40e5b8d16aac78d4cc6a46b03b747b19c781de5ecf4d69daa79afccdb2794241179a61e9a53cfdf964252d495f2db6c1594b337705a5d7cf1648e25bbaf32d1f8d94cb9040e583cdc0567342ea74113ac25419f0cc8d32631a4ef1fa0e30f35cdc02d429c6140ca166b1afa71c3a667527f939e9d26eb57b65be95a8e994fd7c1142210ab070e54666717edc7f325b8477ec7c48686522a39dd69a829f195ba81f565fb83073fbd5c29435a8ce43a118682c60ff0436fef1cdb542b9b13b366068da2baa1804a0072922bdd3aabf2c0fb4a70d70b764972bfed4ba809fc2ca2de56dc7bc86cdbc3abb87f8e01b6c97cb729fab2d07167b54d0e625d84edaf78941e4345cd9c96ae82dd8cd497bdeedbf4e208ff2b101748b0b2ef786267479cb09971d665607a24358b82790f567b10171f8efae7a9059be084495ddf35bf1daeef26979e4c1b2b84e07ecfe3fdae487339ea58fcef4f799dacb7232566d274b1c3b36db760a0562fcdecc56cc17c1b465b24ffd1cf64b94d8df52de2264c056b2f885a39b1360d7a5e9f4f468bf060763b18a065ca61bf64c3495d6f1dff39a89dff4e999683f3062306c5e1953a637f3047ee217ff195920a34f20fa5b5c73996553946316f13186b07eed06333e3d636098cee4308346e58e5471a768d26992ed61a370b432ca6501388bacdb93a1c0c9477eb3d6763b1a9c19ffeaa9310435c59f4849adb614c286c9907dd7c66afe2af6a619ed98257ca5ca8e55895b9c37b836c7bde0f2aa456ec9f5b7890c4ff3f053bd99a2b8163205c92611c33667115082e9cbad30464a6e505297e0d2a9099557dd52e645a10f516d3788c9bda4677d27f84df7edf02a82d1b656fcb027ab2fbd6301cea6bb0d1202c52e8706e315c4f08f48d56aacf5603d697cabd9de2bba1493069154c42801662b6644c45907b227ace9e2b7a694c46e7362d7f3624d88b259139d43903c65d0df0e891fa73c8a5179b934c037eca258a53d0d95f3ba7163177b1f98935616c0e949d3f3f08d6795070b998996051c26bb0df71a06aa68bcdd2f23255e0ee780e299bf6afd0b9a34ae1d6c1751f9aba5175d6d401168a713dd6b27c8ce166bb9844ebba07cbf4ddc5e7c6c78374b5513e8bd9a90f1db2986198a487d6363762590b7d694b727a843c31b2452962efb197d29d7e6b184e72322853fc3a4b8c9d6c520a7f3968d1a35bcfc11b269ab54f9caef3cc88607ad54eaa5dc11ed7f86711893ec0125119b8e83670989f40fc22598ce5e3375aabcb92a8d71fb169fcbda5b1dd7cff1be4a43acc33ec0eb0c3234dc673ec9c4e08f524c47c3d6631175b25e9198ca12c80eac65d659ba2f74ceec7a08ce60a7781346c1e8dd9cbd46788f1968ba35c1892e7cd079bd7a0311a0c0f43c0d823a98d6e66d6535294b46da9d1eaa2bdd868426d251b1f0197bdb8994c04f5bc15c1766c0b287fdbd4526c590c69d7d76ddea2a1237bbbc237f8f54c3f62b7fb6f858b2876521c6740366bf6f040c250554bc1f74456ff2060a4a4a9b79afc64fe785f7a4196b77dd50d46ebbf52c2e7705055f9a1a88270e6832ce05a304f0887cae2ae7a93b0a2e85762ba0424199bf70b9fe31e1ed60f8eba8e853e22e1ac2b33dedf93ea427993a7f5ea51585d2101db912365d8f5a4dfa1464e2c1a209a5698a5b2bc46056feeb60f722ab488aea12f18bddd93bbc4a11e1336c587d8c91f31714045fb277db643bdc2435bbed2a8eaf82f400e3783d2605968586dbf21e5e56538e39f520de2764470a88087cb2c3ab73073d41bb688424f5775e9ca5de3582046b83567437b80ef8a8d4cf62640677e274d25dbcae1e69b89bb1d81a091b20655be87e8ad8b173c6e8daf664164f7fad38e2e2dd5f6b41b665ea9c2d572629999027c0ba8fea49258c37b56057b1b9501ed5d314ab30fe9e981298840d6ac083063d83f9ffa5a804793be72fab0d978839310fe78f8cd211ac150d11b3879092e522d0b4b3d921ecdedd22deedd7e3ee4de6afe86e9b6d4cb65662c79acfb104f36a71bf4edb449bb697587d541abb2922e42247f1026504cda1ab1409ba72e4da5dcb71ee12b7e391888037a6e5d8d7178c474328ee68b170432a46c2961babfc84a87b63a9b860e5796b8e77e08b21e23e87c184c750f0ed07c3643a4853b2fa39f90c88c11968c96a7b14b0db92d920e60ea243c39a41dd6a3951b321d9aa2553d32a23c99ae9330bd30bf110af760326e9c6551106cbb6d188f1feb63881611553ce5e88639861a26ac5109b77a0239dde6f905dbdfa7036afab0a95701a523b92108f42ea09a1c4888ca24aa0fb801fd0189d61f9982477bfab1e8f23e2c4d839c84510b8f557b43a4e09a438c3c63f648d9cfb09368cab48ea47a7fcd853d699bdf66800c6bf9db4f21b70b313da68ba3bfb3b2c0f168346b9c607875bb2f1a898f387b9f0503770f5581714e081ea633661915df1872ec2ee3c924317996c6c51e39a2c18e618895d25bfc720765e7e38a133f98e2cd309063ab21e84f17853665d248f7f076761ce70b5fbdbca6913920489030703cafe22fd3308378ec34638105222e8875774760752b946858317dbbe27caf148813dd5a2f398ef751613c5f3a6f5c66ec95665a009af0a5a5be606e2735b6e9716801e6d90edf888eeeaf12f1171c372a107dda777979e31fe2b60acca9c567272084669372e1cd905ba7f6b27101dbb29149c375dfd4beae9141e92e73ca1a3a347689b1636ece2a762e2934607ff30be6ac44650424f8477b16e9e4e3f1e890d88477cb4862d51ab5ff51084a69f5e086494f29b8286bf3bc31192f0798e8f91d353a2602a89834917818ea4091eb84e04856b6add245a7f76c32d77fc3326dea4b57892d3e7d67e5cd8a77772ad23a49dab4daf955971ebeaf80870d94369a94166ef752bbdba7d326fb41dbeca411b3bdca678e22d3817d958e22b835cbe21f844dca85fe397726e09b278ffac353457d7fba62439a2f109b821dc76cc91c02c356092ae6cbd169fddae1927e3172ed2d4c1a0aea7edac083e2ca97f14886206cc8a48cc0714581e75597ba5c44d654019af7da870eb1190cdd260f35af406de1929735622e33ea4dade9558d6fbb1e3e93478619716aea5af604e4e09531a2d8b9b4566327465c635a29d12332fa20f84764c3357f7b1ee26cddda0cdb8ec4070fe64156407f55bcd2a120f8568b78d035d898194e5d5899d652f9a9da0f4041e23e0f8eda96ef44a95254a18d0f0b18532b8bedff03c20ab6712a7ad387463481fd022e38972201152469fefb97013c85654c8046bfae37261a32f3215fe8c86f914922bf589029a8e4da13806a4c821fce79287a8f3594ff0ab9b3d4e188078a33f8b52e6754af307504c494b01ca11b4563e7b4123d61e7c3ef88f4e39d85ce66e45da16eee57a31696f9d06db4c8e4b15ade48af84ed9e1ffdd40b61efb4fb6f5bd9859c7ceca26d0533f6c364982b648a08b44fa8fc80db0abbe55a7c847fbde5ac4da355881512372ae09fee8ea7e0cb8ab93d516588e69e64e55f3f7313c2036c2c29e401582119c3243289f4b6b1cc259d07bafa36ad4fea1cc323370f30e6caaefc315272d191e989ce8210d251970fa073e9dd1a31c3677cedf5307de5eeeea50b381751a03451ce6e3bbffe66023a4c2e4d61b6e10f22925b26e79ae90acfc07d35cedbc4ebd734b1a3a1133af9464e16808e6b7512ea261d17ed64152870d73de2fc5c004f07617fedf97177dee2b8e2f65ffc82aa15f8d261e6bb3aab41569c9a4f62cea980166c7c14d53d28a0dddf4be99e8dc55e55c1707d7cfc449827770df3189e7c3666efd2001a416ec732e9e00c5588257481fb645094ae0235f0b8d9ed361ab8c0724f369e88eb1bb22d2e1d7bc2476082a1a459f50656e94c6e69c8e8fc1df00edda43772e97de2bc5630b6c9f1cbe5d8a77e75606b2607e58b4ac024e1b8e4299e7488fc6d9f87d354a84927c58f9a2e579c5c12fb4ec2f5ae8a12cb71ba33c59945ea70a1041d8f5f9e545e3236f20d67e7f760207b5f71d1fe3671b12a2ca761a219de1c549cbe4553860c2a9e76e1847c82aedbedc75cab005406b216bf11bfbd121e424c6e49888b3acd1a226abaccf7dabed505249c237b1cfe7c78cc7aeac26cf9dd84a8baa2508748c67060e6c7b9904be86e254ad116afc5b38628f41d0ba863ecd6c37d8a7f264a6b81594ceffa5c094f9789e5cdf83b5132cdabb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
