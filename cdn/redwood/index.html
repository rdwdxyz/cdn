<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a4cb94c4734177467a8d9390a4b2589d0d4d0bf7dbe1c55a808d544924115bc1659b691877919302db84d44d5312f04d94ac67ef8746c4ada6f0855c9dcd086ce6401f0e8d8e78b48b2d9f71ba59adb0b95e12f50486da999a7fef0e408442b6e7cb909edcf346a7371b7f9e3aec1ad0a87d86a5769e7b5d926fac93d53d8563b35c8db68843bc825be955ef13a996555838370de18084572b10cee7644f8e39acb5a903a7275d86be7fcba5ceb327676db419324463a4d4c9e22bb79d34c137ddaf33fa0eddf2f9bf504c0490b28a80ce6154c2cf450091ad36e33b0d922ea8783b6a331fee6a8d94779eeb6692ce34b0c4c484115cb27b14893ceaae4d630f2c119a3e4a1ea908b20980383b5f05a7c4cb68e30bf9d52c04117001a2228d375a98140ea28ffef0ceba83a11320dbd158066c48c0fb2f6d050bb6d28796bd7065b15280b5f66ab47dbc0ba58137734b64ddb4ae2637ec1f4d2f8b6b02e688a17947dc907c01c27b3ccdfee0d7e86c1c24ca0483dafb93d9f2c95f0f0fdee34b01ff9c4653806968168ede32f5d8593eb6af203b07d60645db51fa0d404d7099c370541a4e846a4a42c82f96c115d6877a412c151cbd4fcbfb8ebd992a9f7de94c7fe868d3389ebc94248758b3cbe7e4ceaa81f7ca47c65e9b0749c6d66f8101fb5fcfecfb69209e6b9d97f587dc71e348112e56641e89a918e5ad6cd3f574d37e5824f08298aaf4678d06017f04cda01802c49f642c03a78fd69d8e04ad1f7fe94b82fa684f6a0f6ad013e860ca644294bdbdf0e56aa956b8d3f11a695b133395221f27566f525d55534b2f870f314128f8a971e5f8799e7e5468466d8a1ab05293aa58dfa68643ee0b684136bd4f6ce4d1ea645ad640d44bd9217198d3f3050b056dd95285b22b4f7cb4a3f7bba0c43c065d38bba4548abdd0fd82ff71d6cfb4e2fccb795d998a7d39d1b4be48c0126da50e1e0a4efa0700c7b284d85981e41b4856c563769fb2e4e6552ad3714fb4ac227ceab58c13b75588e4c35d1f218a5d95d2c0e0358987897dac385d1e947b73f6311bec6d371af7aabe9657d0e9bcf988e352480023dd1e21f8821a372bbb26825b7246d01729950bd81b4f89fc70e327ff80fcc400855ea6bf0958aed70cf3a416a94492acd89e95abb93019769a22f617fe71b1e9f3a1c223c37bc5c45dad50d1bda5b4582a076029ed85d0bada40af01dd2fd383d1510c1c8681be8a44f0b602ec51a5fe7e6402eb1cd6fd523817824bb6db7e3c794fa65d0a78c20c6483fb1006a29c44dc101fcdfecfec553b24cc96a05891a8bf9f9b53171d25fe1966a3b1686cec8f22ca0f3ebda0e7725bafd49ec88359be7e7b56101cf5f1b82a9307d2fbfa5b1dea0be0f4551bb14ef5a4cc8601bf2953994995ae45ab83329f71cdcce9cf9dd864802b361f4260d73514380abedaa12b839eec3af361715fc4325f30735b96e7dbc03ffbfad7246342631a30a1705b9b20158c7c89cca5e9b28b09ea203c7798ef70e54f2a9cbcba1d25f71aa84ffa4b742ea5a26f7fa87517fe8fc7c4a4c894d5a16f816101aa7134d9cbdcc6c468ebb0b1a72528b8d43b63a804a09a247293daf53cb3062b492a240841681332cf22ac846223cb07e31375ab9db44be4656c5e37afad778168433488bb0f6486d3dee066e499796cf484ed5b4d9212751c18dfb51ad53885a8b5a91ce33eeaeb21fa7d22653eec5c686f875c9054b75648c30b66da895a7ba06d033f4b447dbbd354c21791c42d45fcc56cd505a4262b9afb2ed289e0ad888bc301adaac87c97fd4d0add3f75ae6e092ba338387283e98d91079599883d0425024c2e214dddd281f56e0c7d04163a244bfc541051d883f44126c2f0ea15d8557a377def0dde2def10f0956b64995d939a471cef2d43da794af7f06b5fabcae9908e397bf5c2c07586e4434840f94dbf1a20de186677ce3440434b86f71786e1038a6863acb1089a44571c0411c356ede0f6c6f6057065d76f063a6e73f5cb7c65e0280e86d45f3a40b1c4a888527d7be90f24416cc8e2cfea647dc6125d903c5001d528cad9ad001646705be7e45a655395e1f10637a19040e984c12fba347a376e325ac87fe8647b63813ba9d0932af8f68604124663e16a35f880c015071ef4deb1a12cb5cea5bd49a8fafffe138975bd855e0c1479f525a719284b369efc594ca062d11812b49121537823b0943d2e6e37449c6563469c538990bc1e38618fd5dd4db806a05284ef56a3a720f3e1d4d8d5542f799e9056f3035be576adf9ff5e9a3f04c6adf398e93ea75578d23fe155525b28c55e4a00650865a2bc62106d515515db45d6891b542608b05884d8bf6871dc01d2d898734e290c6384e53da126aae9a845b2c5ed09b1c5e3e830f828ea564c1c18ddcac61507aced8b89c5a2b860c61259bba10d903b5aaac1fb5830a9bd9e916a7993a8ae2cf6783b3fc8ecc4406a0d801ca7bb6c69a8031e12a6c553407715cdd872d3575741d9e8ea5a43e12c2ddab5d266d0d61a15af79d0db7d58c6e629cef19dcb06f456cca0603560e881e54b1e1be8b3ea36293fab6752162b16f9ed381dc89779f10e0a6349f801dff75a6dc110d99095bbf86038a781c922941ff47fb09311a88904b7dc12d1b3897936d81ce184477f9a297e3fa73672fe356a42b6f03a7282503c106b5b1eaa2831ec0fbd4db2116d5cfbfca52e9d8d67a035c2c6d65a285dfe6e8856da55bbea5369fe4e4fdb02d81c00f12f2e7207645e2267c8ab44c31fec97cb26966ecf4999b53f298190cf2b4285be450732b9a03631697ebad170651b5597fc8b2316298795cdd9e89fe01e846ef4e0ff6c020d2d8b2022afaf4d31088da02e99c13d1810ef549599930a3dc221900a80a4f38f1e3803847b2743161a9f1eab5924d952f6d88e45fbee933b442da9587ad80db7ab2dce23de408f5791b329ef6584890f0492fa048b4ae0993e796d5e138aab7ac8eeb2eceb500c160088c05eb0add2d454c2e874dcc0046653e709bda44e76b0a5b3d894ac13c361c442f424657bbaba0ade45781e4310691704b8cccda2af1328523927739e910d4164af04e537d109375e8a5f6a597ffc7dd1861ff71502c81564a2f24386e666247a9c530a3cc798905c0bca6946d0ea47bd40de52a81eea347c28f8e78ee0e5f44459205fc3c3fd50608d8ca65ba6b5b5ccf6c5ddea55e0055181108e5af0107dccbce3397805ab1b092726eb2e1d4b3e0ed069113711613cb80cd50c0c9e17ba51b53e17b65b0b25f888c50fc434694f40b84175265f30a8db76f58d9ed7be46916f878f5f23a5509cc9ef306868a2849d764ee8134e0ca1a41434a48e60d8aecb689bc3c01f55431ee08abdd80ae3c1c0c43447d60349ccce27bbaa6c84f859ee14a88eec69382d4d67a3c0b767be2b92bfa74665ede4e2d82cb033e1ea0a5c07632fb2b52b481a6d2638b558acd4594cd0db2379f17b0517c6178e124c9eb86639f3c5799c75d7ba8c17ad8bda63358f7e3b9b06c38f5a77be1c7124c58a0d599af4f9a8c51ea60367284a102a909bd3fe0d05f688c6d8192fd1ec471a45e2a90d7854539c47220b648386ea7a188e2cf95d52488b05d96961699356993ed87f0e8bffcb541e4cf7c98584919fe9a3022205505d0316b57dd86b7bab8b5bdebaa07259a68ca9bfb63915165f7cfbf92bdb4d41bfe63ce34a22cc8d88d837ab8f1c026ea34bfc2abfa26f825be51029bb73169d17c8153731d1280d5d0268e4dd5cf4be38a405ea3ea285c1b0db2b73b1f96d80fcc69cb7f08a5ace599e72a2257c1651976010408c78bf88285dcb18bc6f79f000e8c485e62381a0f596dad5da7def8f342745ed4b269bff32a6ffebc55fdc01b5176108f2ee161d642cf98ad690a3b7835ca5bd1386ba6f8516a9712c7d2bd85f940ca9127fd12a4748a2d35a548c03a9dbe0e977555a64398947de0891c022746c3bd0859704d598282cb1b5fdba18e63324807654f0eddb6c3550df21812c0861e72d7b86d20c7595fc6fbf39185967b3be1aa884d486a116a75d375d7a39b7b0e5201f70a5173b0fca21d6c7073b7028d61610efea1fb626110401983d22f8794a925ad79078139c1beedb67607ca33fc9356beef4f76ad55b7870c3fd050af73bcb22fbb7cbdca1368a16b63f51823d2fc24782d116872388fbd19e07fccb6cacd41ed9915948a22d3b07a683a8f726da0211dc85c45d8922291b23ec1081f45dca5edfcb930b9c92792f69f2ebb4b2225a56346052d76e9177a7f45bcaae4f8f77a2582f65268f4292fc53e07f82d4d225567af51bbde6939a1efedba953f4290d6db4b0b1fc642932192bad94226cffad011df5881f0c1d5132f66dd8321adba4cfd9c9973507e8752d1d36ecb78f4355883de1ff7435023a8124e4da3affacf6b02602dd2533f6294597a62ee90a14abc9a36fe965ebcfac481a19de481d6fbc4ec0b5f72aa91db0059b3d337883274ef82fbd7b735c18d6a53c2cf0f901a8d68d515c4c32ee5648c3c306430e09d32d3eef2d80df0e9b728175a16d37aa0252c1ab122466b7865c28fae5f08aaa46335e29e1eb61c5beafeb4560cddbf1b70b615401e82d6d0cc4088369644d8911af072a69648d80ccc30e6712148a1cb7ca34f0f08561329211e69ceb05eebfb4cdc4d3206b39dac7c99cadeba8564a51181b6b4e8b5b14467115b6b7d686287b43be22b078a48d19b4bd3a7b1130eda46406d6a161106024e2cb41298bc7a120d1fe302d73b6fb0d3ddfe9815f2533c295789ffa710f6580fa963fd0c6335192cff73ec69099fea7d7d295a1eb1ba52a8bf161d5e76ef11aee36183d6b1b580b7241ad3eae1d49671844805cf6e03faacf9138a9a5f4810542f3b5b0c432f86a11a160a978eaedc8dc8a84999f23a57a322fe3785255243a9f791284214116755dd33e81aa16c3d248746ce8c4473cdcf5316a01bf1eada33cf5430c1f8d523a9df868e0645e4d122fb7758a8c851b53328bd50bc1a4d371882fe23c06fb27fad85cac57273139bf9e80ff837954728b14d7717ed6b06b83bc6948101c560d40908cd658c06dc061f048d5be58921ca8afba45db115efa5f01b264695a3568e107d2c4e8b6c4bcf178314544b473205b25049b378f4a5467e12ef86ef725bf951dd39135e4d6e3fff7132212e0e3071ffe0bad7e3592a1a82b9b2d86ad8dd2ce7150ab7fcf5098012a23cb9486bd78958decbc343d15ab9d476d4846db7b0146832bb1e8db09e9f2d921f659f2b2c18d015467826467b8aad94c235837b88ce5993cad4d98b412c6f9bf13d4351a7ef486b8d233d482b5a86efc8d1d7ca4db8af57e142cfb1e8d2cdefa9c4c01a52b033b1bbfc69066bd245ff119992ad4cbfeea7028bd5756f79dae4785f45038082954cdb8de28b514456c70a7f91eaa958637cb28c6ab7ea96c37fdc139c50aedc752c6a63c19db61d74dbc82b686282233405edfff4ef255a55cc0d1b65f8960ffaed0e4f60e05065c163a3ad3fefa1ceaea66e7a3d1f4ad55e5f1df9cbbbfb6e645648b94c4bdae13889647e7065724875e7ca7a06eeefc7bbf9bd0e973d6ee47f0269b19b0ad51f73af59c2f3cfc2bfa9f23dc057adc22ee370af306acc46e49ee8935945e2da2847b002387e2eaa3c2ed25eedcbbd720125e3a19632c5b33c1e9aa8c4aae315d405985f4d4ecb95b9c823c8fa320661a679e4ee17bdf8ad4a6d985c6b22d07545e83cf8ecd289c2d1fe7b8618828f27104f232b8564e9bc3992d3d07178a79d0b7d6a05f38067b720d66064ca08c093568a6282f417810735792273e9021706661c37b09aac788314f8e5d12be320a7712551ffba11e5fb97032b3583aad0bc6893486753f1f2cc56a05c6271c747090e8c244f8a553f7b73ded190c650fd645e3d50be50b5906f771f0e70d076c4b5b03bcf7d1f7350f7f616f25bd686ab97a6053c44e1b19e3449eac0fa6e5fdc285cf2e5f452d548e6ecf358d4a01fc54e32eecaec498b8f50af7c6ff56a81179ec5e8950a702617fa21649b858d799d316b8263d09404c562de672b24cb8db3baf39c70640f10ef1d1d63cb26eaa8486a81df524bd08874105cc8e4a50b2734ac51c5ca4856eaef787804fc11a6729faeb451883e9776e6cf911982b9c465f217a1dc9edbf386a8efedf4950f35f69b8e96f1a0beb98b1ce5d71a7e37dd48687eb6df1e655153d10e3433c1386114494450822e724c5a896d00215ba6d44aaf262d6fc453a5f41b13d7258f1d00d2eb24e5199a15ecb8870f2993e37d776ec45007033ce5099106776324dd48386de8b135b8bee24c750803497798fef1596392b243e0f035189a45b32f037e75a4bd5d26f9f22cad523a63ddd2f5a02315294d78ab64191394fbc4a2f10dafc792cda05f7f7cd270c1afe074af74ed3697f3cbc2fb225ea009c9bbae364980fe5e986a5b4e77c9759f8d3e09158eb2888d3625d58753f7f1f4c99a5a5ef0c4a9e7778c5ab9bebd36b5719902c88502458129463c0d878941cee36e282e94bfd9856f8f8428d908a888611c905786b5f9d8ce33808523abbc5e3c0ecd394c23875e4f65557cd5d3d6ed7049563dd2b2be4674e723c09cfde4b5bfef4195c987ec244d0d9113022003181f6e5518ac1232b55c99f28ad868a91d99b3728c806690577559e28788252c3abdde5fda64f47c36f930112092e806475470351e7778889e7512c20a6a1683f5c79b50708e13348008e3bee6d9c99428d929945b453f061b3a2bc4663454e5f72ed4b032f359141dc6cf09784b76e19dc5bbb9c45859c3c75b60dc688d40016833a00e7455fd28d8757e7934e5e8472c8080401ea27943bb6e76cb1f963120712240743a5ecd6e5a918adaacb154a7ccaf351dde2380b5e28ee10985915f6a820a18215b011c7bb4c68af9d8e3f5ed86e1e20017ae317ddbef4b9064949a28e6842a882dc816d9c0aec94c1a013915fc107bb45735cd5852230a6bf84268ffc5cf07a43a56a0fd023dd7c04eec790e9a034319f6f6239a1feede2b0805cad8e9d61a1f806db844946d3031ea4f93a238a55eb0e42982c1149fb7f4d0f3db5fe20d4f1cfa67bb2524a7fbde0af62ea680c21d40de5c406df303511f29e22c8f7e80466a02cbaa977902a1bc8dcbc7937e5fb20e264cf141e5e9aa8e27a61a9b3cfc9e57377cfe4fc5b82b629615600aa4e1c48ca1db0fb18eb5c61897b48871deeb2f961709e0deacc841d468c345714598c05b42da1eda793124fe2333f854bac9739abd7af51a41cd1467859599034bd6c9cc09568e37d7cd5e4d3a28f9045a52388ee9209ce760104a3712276609fed4981a41b67d1927172a0e619938e0f6e7b5470bc0586e4e800f8c6b6ae40ea39b7da91f62fa49f1ecba40b0b540ee7867a6066ebf0172366810c7cdebfbfce350e7516f0aa8137c7ad15374a76545bc446725810bf81cea017178305c748d2a59efbf7557a976b2793d706f9b4e1a8a520b93523d89cf535e95781ce809cb660472c4f85195c5720298e0da779a5783f2b95fb367da81c21432263bc0f59409cc94ef1edcf94564117c394158a810a0ef27533acbbbf8b170d22ca6145fa060a63e0d1d3ce79701209711989c2b36491e772ea3397380afbb9e494f3ea56ed1f30acdd90da31887573f87f9a648247c08c4d8a9e8235e5e47549717cb4efc03945e6254c555d97da5765de771af30e59d852213f75cb6cdb082b464789b9bad9dd8f5dfe3ff94503464d15018e892c8eecf1c27656d24cf6a7a829b1a83d0a85d878f8166b842d258b0b303ec6ccbcf483bee3892a8de010007c44e9f5edd02082416e857d67d3869b42f123cb749e28b94f234f4ee31c952171c2f3e9afc3acd2f7271f1d118c5aae629d979c9feff53090ee330cc6710c5e2f4b65d6a51a5ad374ded189c1fd81cf4f91b16e58085858190fefdfd89e7bab6707a59291338b2da9591a80997f6241aed1032d1f21a76eb59ca3de134eafe8d0e24119df71f4ef6ed4f1ba1a51fed5db3ab2ce1bfa31f59a51fdd8476437bb3d73899f1da1ff966ea75d2186fd3a8c9d25e94f1574027bc14de4de46bad6ced85d1c32915da88d28557162a7e36ad451a8e117fbe1d61565559ef413e26c317b2ce2b8e9d6dfdaff56cf0e6b6415ea7f4e744c6ab0f06d3398ab5c8f5ffda70595f4c4f5e3d30d187806eab4064ed0648de5606c76d83efd0cfab3683e94f34019a122fbc5f8ebac4965fd70eed22fda3fffd41b958853d56a567ac7ce72f36114365ed379b97284442ecbd047e0415e2e491dd58e051348df78bd8f9d8be4b0f014006e46297441e1b008c824f4a192789db70e3251f3a309f89c9cdec773feda6a933d518b31e540b87e4c6049e06758b097390aa5a3135f533ce4910bb6747b472760d6b746ac367249036123d18651cd7935c81862303c26f93edf6b0171719ef1f001d295e37f1ee1503a6807e5f110ef5131d9cd695c91bdfdc43b48ae722ac05c19a6e2f89df5e533a3e961ed7c25a7488c48339c9507f57a8f0ba2ef314fcd29c511aec13dcd54225708e881f7a691c379287f303bee4c64177143913d4307cecea7a6de0db6693a119dab241b31056df9c80470bd1f0201f42ae243d454cfd6d96eb302acbc61d92c113e719ef5a0f88559224678c81702f4d663edf0370b8d3df20dd66a1e8de4bd9ef78b5eea48889aff8beefbc77bd93c0b94269cd37a6ce01aa0ded00b5452ec10d7e5c9327449c7c3fbe5a316026d0fbb00806e14f2afb2975a7798ee60bd3dbfe5b0a9ef747530837a1d02fb2f5083d112d9a7a181cd44eba6abed1ab1eb50e4edecc4fd9cd496af2d29e77d448fd66329dec3fc12e202ff133172555443bbbae8f019a867187d8541b8f3cd32781115cd0f4e9c51bbea1d1888c9aa5d81c33b469fb7f1777f9feeaf6d4a7b6e042f7c33ab552719e9102348a4adebd5f39481f7da5a312892cb1ba84d330ee4c52344d9006c8501b04e7f80a583d657ba6577cda96c6425b587184ba982a25b95b295cd34531d023ae17f89a7c4fa60248a88b6d977530e68d4346cba12480aa4dd897aae011cae9dac8ac4603613edb9a33e4cc3ede61593f87a8cd08e32286ef21a5f617315dcf5ccdcede6485ee4be2eb40db2d1b4dd70bf3ee0b6d80f3d72adb6d21957ed25247095da9e0f5d91d1b468d807dd635f47b271f476bd89905e345585ef36eef21ca7c5f53133ef1565b8bfda7a837e286f81dc911596434955f739ca3fb6b2aa85f13f49a15d144ce9f96d4cd7b4b5838cd53b9821dfe6be5ad06efadec0dcdb583d4a8c8245fff1a024f49d54e7c1beb355ef740e1f0df22e1f2c513b4399bb1ade56c709438e3a8aadba6e9d134dbdbf3d38fce2e7c4e887d256a57f8551d2d6b9eaad954b0c0f430a1e2e0cfe7f860a06f967d516eb1ec329dc187c2f400fd1db4b7311d5a03c31c510fc26d622445c6752ab23cf0de57eb4ba5b22c65c8697aaf3cf282c1e9053b6e64f7ed7cc723dd1309da5753a482ded938b6d9ae8dd47df99cce7f15218e5ee22068efa016078e57d52a5970a618bdccccf326be645d6b6f52d156eed4f3eb7ca3805d45720a7844dc658112eaaf35c3990458737282091caec5ea6289656f0b34400cf7423d4e9df85cf01da7c4539eb8cc592af3f5ca3ed5e6d91bd92cb62df279ef7ca0c8b0b30a2ea822a7d7efdb4768e178120932d0c5d221ba0422bb97b668cc24edf388a724bc63f92e82831e1a946331de7a3374c134ab57bf5f6bc129a0fc33ec04fb368e3e71cd46a1aa8411968d939af86d364d49e755075389f8d304ff120417fb9b66cf589aad71e333a5a92b0cb468d09700ed07fdfd8964d5447b19d131c7c176108cfd8af438e672bdca4087e40e082b530097bc75a094a3144d00944e86ad24bd53df0115014457abd65b83824e90cfe522cffe774cfd4a47bf3a5dcf74b5677ca6afb837a0a510891e7a534ba6a9c26406ac773518a108854d62c66b61bfbcb39b2bccc19c225e7ad379fb438cc52dfe9ee751103437615743fdb44f63c12e51c57fe2739fed1951a7536c92a8f33928f8f75e895ce18c43acc01317e6aae6848fa68ca1dd3830e4d1c9e73f6ff58096ab4cfeb92c75afbdfb975b03a32f088f8e15836139f31c41859243f78c53647a6b3a07fcb0339049e97c96ac4121de67686364ada76873b9e127f00253c4e0a40291d98b6a1111adc3b7d99db09aa3cf9bbac3c9b5fe8ed38093bbbd1582f2310a9293cb8cd68f4af2b5e66a69b34d2b2153e1e8c9381ab710e31e68a4adb1dfa582446e5f695e56c9d735885bc2f1130765959fddfcaf117be632950f7bd75a8f020421d02096553192ecb5bf171d867feeddc90bccd2266f86317ab3a4971105e5dba7b78b77080c20aec45655d914d6597900160ad8800b16042629090308b5d2f68a35a0ad7f13023b55f083cfb67b84cf4cf1d361c9f4e951e144428f6b992fde8fbe08781013a9f5c03102c5905b3992903a8684f0114ce647abae0b18dd1df87ba3639e4476d054e5a6ae7db4e1b89ed33715d008b5caece751ceb2cf4d876d22f4943ea6525764b7e56844707bdac6398eaa2fc1374938dbd62dbd6611ba7b3e7eb58773f3ba713950c088cd6464acbf40bd625d21355a1593b436776d7ee2ff1f5ffe66620bebf1f04461ef78f57c039ff551d9f28e674a2a30b618e756668931b1a1566233420aec4137fd9a9b31e1f0513e38689812e62dfa53d6d80151ec1a0ac57fca25434e70887cdacde9c96276fcd13376c328a03ba7ec883e3ce8157f4f3150b34a23d27719129ffcce18c7f3c8877c87e0e5d739bbb79171686d3b000498461af7ac8ce3813e82df33e5d190dbc111c63f6a95dea401b8be62b480f3c5f6ab96066046cd226a0a1e27b58a40aad700d6f18b27142e8e66bab1927bf99d54edb10d514ab50b53086931a67461af9400986267bdf7aefd9129a211abdd5b295bf0100ffe8284073da0172be6be962b42d0f2803fb8b50ef50e139aea5c56000dbc260c2d52f2625d0805fc0f9b43f2a18783aae3b70c33da3051150284b0142b3ea6a3d562a97bcbd3e85ff24446934ff62dab65c9c8bc55c10c74ae31cdd0acd5a9b1316e3a644496b2067cff798bbc6691742149a11f23a0036bb4befcfa349d4f3fd1b13621765a4397f3f2e4764e5a84a0d85800ed73ed1306ad0e7aea9ae1d690424acfd317be6845d34fd47eb6bbb660068618457e216bb94c7d11587883ce3c081b98b5c000fc0b941ff6df53e224a7043e494d08c61ea37f2160c1310a54c667d6e5e6338af277f879e0f0f1cd93158f96bd46d6d7c955e44db8a97ed7456dc1a6e13c351fef7f3eb907a6f9a38ef97d12749c7949c6b60013b8b341a607ee7685d516b651dc8f49aafd2bac2831af20189ea89c6ba6cc2294c47006519d1a32039fe8a6633a610366e94b1c0582f1d719dc3efec56e9fb375e719c52bd059564fc8cff4d1901aafd723106a82cd1442c669336b250ab065cd889bf0a13ec5741e5e97f16494457675559d0b674d607ca55d000a63cfeec9961be52be0cef304f5e8de524105ae9357e35722bc89ef3244f0d7753bdfb1f993962d7efae9b54358dd61a21d9f1746cea27d5164309a5d87265cb83e2879356705f229ab347f0e1b8348ca74d9ff20ce872e36c26dbe36f1054aa40e739f2a1ba8834e8cd5ca45fe8c378c4aa6cb4d63f72d3a31ec91beacc02c00b5f284a170ade4f268b66d6c1d2e0ca03e6458bd784a8f65a039dd9065343068d52d1861e8530a30628edad08ca178aacf49311fa951d5750f0b6e456068b1b9cb25a5b319551effe1be72ce9393c08a301b14335c8bb535f1d4e9918f3b207f29012dbbaa189bfc362d3a4f0c7d6f3694b593e24321537241fc9b19dd2387837da0b1d6dbe460d49a4c90fc63d300df987384f4b5ff082966b79216cd9775257593edc71e6d496c39dcd6bda2e2318dfded7d04543649c7f1a5226e056c120325656235c772b9dda34530cd0b667b3856e850044ebe1099341ca5c3b0f5307eb1e2166ce1fea7441f9b60136bbad21f4d1d90c03a5b6a49854b1029fb22ff5e1720862be7b3dd8e356b92e95b7d5126d248bce2ae9f6e0099c6e9edc26e3d2eb0b372a0bcc7b0e3ca499cfe16f0930bf683d83c5b89779e412e5a1bcb1dbe93b6d018df530f2e3402c5f22072be9df2374655a74220c3cce8ed605066ba06682afc84ac476784a82c7d8bc730a645698226bb983f9358fa98b07bd08eda96f8c6dc4676196b99f4b888b2317eac1477c95aa4cecc7577c1ce4d78c8dfcb8dc62bf7b9b67d4b934831be3dcdb8e8e7ae66a213d6e81acc479753d5cf40fc8ab1439918c443ee7e22b5a5b4b54af98b439dda58a070e7d7784c4213cc1bca477126f3f8fd1a0661f86c433390a8fd612ba5c7a8b82f342aa9d797bc287b9c33406bcfbe0177a7caf53bf31bb910c60929a1c3048ee6e4ae65c3e31e8bd32431beb2ca97bf838b93f0065c6852990187f0c43f3930c56ec9da39ba02c8c140700c85f5d6f5c2be073434d76ec628b913f511111a970972622b83c88f7c678153f73f7b937db2cace457811d83056cb07e47e8ad7888562eef15612e56cf054ffe6e5170b16500a88add29b6f9d7f3504c3410ae4da2afdc004eb623bd12bfdeaaa1d4a46e8e8199743dae5bf826ae14db37feb5307083294a81b133363b2cb181f3df10390d5606753676c880b526976d244566994ea6af889885dc4df541d5e074c984478fdd890ea55ac47dd8347b0cb0c9674ec4455421967e17a49dd5c50fcc75398949dc065e666a9f56813e4ad15937d0cc76ffbeb64e1bb13fe20e10f991fafabd7c3c5b6b37d37f6547c899d4baeb7a69344bc1aeb1419c949371947e9ee739b8bfb32750bbbf32b6ef0ac5009c78d3b6264cbac760f057c0ff52fc3069e25be99ffe68f4813150aee5575ad1ba07944a2976ee065d57082c5310b48c09b945584bc9ea71dc7b7099a5f84bf95ea5de5dfa3beed0c6915f17a4f76dce3c22ad9f1013ffe4d2d26fbb5d33c84edc9b918969b83c32127fe6487558a5a61d7846b6379cb89f743f5ac0bb86abe02847a59e34d1219315599fe6865ab7b96c84209ee2d7b7b4c853c4c2c0f2a66ce707afa1a4527ed30bc01646cd82c2a8359e413875a3a99efef4b08bf345d01c4e9ae67c6f56ed31e4d9efa4e8541fba884be7ab54176420ad5de1a46708e4a1bce6384e4c68fe13844b210b2806c27f013f1c114997c10a222fd424a13a1d4ee80158fd289e48d3d53bce8374e1b80a92342bd840537e183e996d47c2f9f8a49bb05e80cdd02b2398e983af8762c18ad9fb5803eab5625416d97db33e9ac1696fbfcb08b00547ad85e75fed136aa3767ee30626bd32c9f433133280d41836c7316768d8e198292f47d0a94e036f9e714ff7e9b68a0ce0fc9a98df0a0eaed122cc233d31dd04b741a7683fac12d8508d6fa6119da936f00e17996c1ae22c8e28da0b9af3138ac02c2b316ada8b2dcf124054577af2782d7f5ee389199d5a5725892fa0f4a056435199eeefca8a322d1ece999dc07a30f9ce50ca8bea75dcced56fe14d75e6ef88fa52850c42e51de8d20ab19c6f36417afd6db33a7e474edd678904b67f97bc0e2f57a40d5721de601588c1ab45fa77d3de61536d2381156acce053b4fdc222c0d136d673e9a3d2911d9575b6a14f4ba10315607324008bd9030e3e06b9d625df67487a63cfd4343d953f1372ad446603319159e0edfe1e5ef00eaa16aa11cb84d42ff7d7a5c683a180aa3a2756c623bd5e090962c4b03969e414454a4f98c01832f3cfacedccf27e8c23cbe1a0e8067a3ee1e7a6a1ebb2f455bd146fb3046e3956779fa64dfee630280565d315eedf33b6babfb231f30c4e85fb6189c0937384b3f37fb55630614bd7e754e48270f249118e71983b57349c71d718905e64a6526be0941d90d8b627d14e0f5dc7e5c415e1ac44f40d098de1184f57550b80a723fa82bb3addbe8bd4c0da2681bd33a009cba1be59d01cb7463b7a1b78a69136aa014b32141c30f71296cf64c3c993d9ab7f44140a4be5a75170c5d5626a5fb629c1e762151869b5e96f54c6fff4737a4cc55daa4314681b956ad75ea6061cd4f2bd9eb1bad39827e35da08ea11a8849084c612cac008ae586ef37945fc72cc320b44533f26f34f1c8aab62621d9d1679bbebf16a34fd93ed803b9375e28db265a633e32048cbd96b17d648094b784b0b0c9937ef19a0a2e27eb3c095e23640ea9ea5bb8b5530b27b1d1ccb38255c9327341c9f88383b41b5eed85d1fe636c4bccb1af4d54ce6f375773681ddf7e110104356b0f446c4407b9d90416300097ba2f3016454b7ab63663082564b788f5d3cb69c17bc58eafaa5b1578e59a3c9fc541a31f01fcad3383395926a22ee30a08f48a066d47aaee0ae257c5e26840e66aeefbc0f4db39fe3e08d05a432ba01bb00a6da9be59fbfd2c3d17d1b26f9f86efdda589282831d6faa05ab8be71ec68b9ad4f4535c9146b584c78061ee303c1f926364d74761abfa69dd240d0a33ebbdccd71716b6269b83f3991063cfbfbbd08b429cfe50d78e640784a79b6a2f368797bf2a453bd04c635a23b65645ba3738e6508a66201e5985651f55beafb71de2eabb0fe88e9fa617100a0797979637afa41f731b180b2ff81f3b0cfe9b88dee6763b1e73ae22b8dcf15507025c843f3a5a939cc46df786996ebb6a9c81587c63e288c1314cbec993e31df3133e3178e10863c879571692ff7f66f0f2f168b0d0d26b36e7e8776d9d25b0a5081ee7f5d283ae756bd3fb2a57ab220c6da4cb9403d7e220b0daea8bfae45920a627d8e4016165d51f98dda21aed44d3bbc169d2a4374400f0ea4cd29e8330ea9fd24070722a018f80a5258db2952eec28801f018ae457eb19c056b4411ee228c6791989f63a262bdf9e7a3596ff26bda09b2aad907e139e95040117239da021cd668c0801cdb0e413f6831b4ca6aca87d302e278810534fa13928da4d88f89a13f65c4fd2c4431104b63109505f3d49625b76380d188be6a40de66f3774b557efab0a712e68b4c0630c8cfcc92a1f05481b6cdb0053886dd39ae255b4875f76ee7a9766f8bfd3f0a945e85608e29bdbd97f555326c51bd2c1fe5da740be0b3b334f774a09b71bbcc0a3efc9dd193fbbbddc35090187d04f14537d4bf947f3d6aa4ade097d18d233db376a1c04dc66f0d3490b65f92a06be2adfd2221e98241cfded93063e8827c3a4b135ba18815e909297df2fa387173e155249ac207f332e8df8d5d856cc8bf929554a0645e49cc482e724ddc5c56d26e496ecdd508df3c9f03f60a6b509a3dea6bcea55868fe943c015bf020e7edad7c05b22d7d5faacd663c4f2294e0ac42d98ac721a03e7c319c6d53357f0dac12c9a9f76208b997e75bb0eac39380dea0a97984421179136403005917ae28983e651ca7b11c31dc2ea72fa1e22f40f6c290ba0a50c87240e6eb8c2810ffbe96090763ba0db69a669e37031d49b4a13ee41af6f5e6b2319266d72252fa202b27e4657552ee4992d6e22f949ac556e43a38b41dab9ce936f5017431b254c93d4a2d97cccbfe5871054e3b00d08bffca352bb118a29464ce83cb3501793e4b1f93b232328df1f4ace7f8402ad969c87ef645cd51deea207cb21dbf9de08413aecf41cbb0b80d6ad9c10ca964c1b117008c4310edd403c2aace5df9f15098a77484a5cd6ebadca6f292844a745184f561f0e786173b054d83acfdcc54e0c05a4326bd8b0e27397a47238b55460eccb376df85f74082fa1b722e46f5029ec6adfa63892d0507acd85924d5cfc3ecde78031811dd717664c340dd39e22ec115fdbc290c8bd5fd6e19f64ccf7799d181726a338795c626f160a3034aa7461fa203b8b01cbe0cd9caa555d5a1a0101c90ef3beee47c32715edd77a04b8373a99ae25c9fa320206f32238e1b0ee832a820a0bd4217a70b07e698133430116242c034c90e9ee7985760aedf24c2a417e4e1536030c7c65005c3993db6b25944d0a15ef8dffb2cff92fa9c9edca8e79e6579b97d0da9e507154177412538ee278c257e2ae44dee13d959bef07c83d45e0585ec37e20f7d79bb8c96c07a7a600f700010b87278dc18924d337d54c8cad577044eedc3a26b639c077617bc30a58c75a762494fc9dc5f2735ba18c064cdba0bbdcc56e68c556b01d3a2953292925d6acfc1f99228480d028f33c4dabc72cad8d7ce5fec4641e93625e90990223f2f45077c3eaec6c56085f374e8b1c03662a7e08dcc6c49f8656e8c66f0a1270562a10e79f7e9f3622d7b05ac9f6eeebc375c765f75861a5219fe2c519012c2cf1b08c6d2734d175ffb894929b5280a676fad19ba2769e085ef79afa66d270edaa33586320f7243b5e1a9598df4130cfac8511c781072af8bebb642bff266403eb025bc83e7271d8d76ab4ecb64afff4764ead98fca9ef3318f27afad5c44c7645ee01f8f09ad632fb7b1d7f1ab0e0b1eb56318136e89ed2557bc7b49afc8fd7e391b5e5c63f422961986227374a9c6ddaee4faf748e16c25eb91bb4316e397aa5b68824d634149798dd933738e16afd624804024ce6b07a19d807676a097c521f8538a8fabc9467b77b1f4b2e70758ebf2ee16eda7cc699629160ca7f179906fcf3bf66ffd213f5131d7a4454599d09328d7122a8c1ba3ce89702351d3de3318337b179da046be350eaa9389953b4c526a5793cd5b55c76cce96bfc8e8ec2ce6cc3352c9a0de4e88ef5f647d23801838c80aaf777dc5729fd5cc4647a5929ef2beefd03cd64cdada589a062d61d15ce4d54da19996cfa07431eeef87273fbe7beec56f3da81754c3f78debcaf6f1d6c3c3e801b0ed7ae81cc8be4cd0ba57bc6d7fb72a16ef23e4450e069e97e0e146bf80b6b5a25abdb2bbe79ecaf6b245249266970fb01cf983f327611a5fe21c0dcc6c246df0724cf78d6e4579b502c82ba58cae3f3962acde8740925012dd5cdb86daae5511581cecd4cce3035ac5d184b2da50c20752f78ca949d4d75a3665f33ec7d6d239d3c3bfe9d22131c57fb7ec9fc3b08cd101da5eedc6adaf878df64d4071738d63a2881b218bd5446398631e08d74e7d25124f5ed50c96f38c955082ffaec329facca7a7db82e845385652ab17029af17ae45a4a304e8a1d152f8e1d5d30e490270ecf69fcfe1e42fab616ed7be58b20f429e8c5c503fe823e2d3392bcab8fb58a04a324483ffc0aeb42e8221f02e8cd251a013713f1bf103a4c89de7fdb991e146b7e66fff6dd5fa20850e5656bfe660c334d8a3e5ee872ef3cbc6f865069b636e4cb9f01cde6b9da27aeb0ca090e4989882899c6ead41705fb44eb3ffcac394cf4535d3985e1b5fc2d21dcbd33dc223f396bd47464279f1eb10d51f719e0e175d6b4e4f97319c1c161e1d5d8c6cb8e2b98bd8c66e6a5388640be6e8817ff19a9cbd080331227d06654d74e7f72bf38ced641d208dece5455bf6937fd5fc8da3fde1499bdf1a4fffb8d2d6b99580a4d4e44c80809946229583057dc102f06ac80c9cc2366a53e6343d9300ff53a6b40b3f717e29a885d800a6725e40afa66b1e39e3e9bbcf3c9f8277aa423c6bf792a005919687eac7fa628ebd0f26ef3ecdbb0d9be4870444ba1b2089b659cd73a2c50fd34374a9f95c2ecf481a11d8437abbf0751bc3b1a935beb0899562497cbbb4f96005a995a978c8b796bf380affe38a26246d4e98724e0b198aeeee7024887a2aec4de2cc2f9b8f45780468ac7ebd5de8340008e7defff28797991f837400f2b63d3f12f391672d26e42e8d1590d9143f5cd4035fde34a2f710574b21954e4d8a0a76519d5c2a5cff4bb1ee392a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
