<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a820850b47aa4c9005348242c7a2bc488fb75b1f388cd49b33521f1bb14cee298e5699de2e51dfdb9fbf4ec5cfe7968ff94ad90d9dbcd87d05fd42d28b25e2786c948a6ae6a6cfb81065ff4e899bbce483108215c8bf8cef69b8f8ac5263dc06787c887a1448fa8b2afea04e19a801dc044d462b59c5fb3c7390da49ffae072b5637b89541f18c060560c3621df031c811731419aaa6ff2e94fbfa886b26e6bc5d9696683729ba95e9d1e6838d8a8e942179e085d0bcccf79d10e3b475c5c76adb66fbf93b7b0b2005ca3897f41f7ad491c6781a6109d126f0d240b5ff6c5e42d3ee9cf4d896781280d04a740a6d511552c239ae0083fc8b70681f9ff7025f20cf1a7b82c1d64ad775c5abbbc501dc949aeb98099ed1f3e9b62b6cf97bd7d8abe7101f27a5bf5e78160a56ab9c658ee486bf895f2cd41a8396f5b9307832362059c1d24f79f6236f94c658ad4a9c3c3751b9ac13f6e3086d76ca42750ea79825950443efd12c0e60f9649db5d690515270c140fd6cb98b53400ab9618376f163f8c39aa10cc20620066ec90d064431925e0c52b4d3c9319b4996bc8ccfbbc8af00ff31c32774016621ad7a500a16a798c1cefc72a3712f7ac6d0b4f2098424aa4130a128db3518d298398b3dcf5f536cdbe88f6dac1d8c61ec55580e6868d4dbefa19b4390788000c5f9bead00d7d8b716d1126af70e80b31eadad7cc2a7f509d4f685d1cef364473e11e41ca5f3ca63ceee5ab7e9eb14e026457311de06e9fd4bb30fac87b95b6838a3e60d20f5a337a654d9de50ae95a4342fe4189d4f99d02c236f481537dd562db1a10cfaa1e3346500f57f69dff2332b3c1d1d5140a0d936c129bbb7ff0806a949eb18d40437bc9dcda269f6bc9c9c75b3a9b1bbd7485bc512ed559aa0271deb0691ad3ca8e1ef46969134ae0b3f46fca75f2170294346e57e831cf5fea99e944d4884df799dfac81b94d1bde3d32260b269b22f5e9d5d3715470827a84a2ec4c98ba32a529ce14170821ddeee9268b400008236e61ef9444db9c21648e5709ca85f8738af6c5fa8425591fdbc5a2c349538d80dc51f10c150dc71212a2d7a44635f0407912e15b620a0177d1e4579c894813ab918451bd1133b366fad180df85b13feea86933f35421e2f8cd9f8d6fe1397af67f05bdb4bb1afc39b20c2448bde6d54ed3e633ef0bb2c77ce9b9d5aaaf72a74a258a333d2ada251cb48c735f0595dfa96ccf39f6be05837c96d0921d36d29a8ac146398cf2c4003daf4a42f31f78892394601203b94fea13582ebb0b8accbb590605593bb260e75f39b3fdd02df29c9da46985baea4821eb1eec8cc2a182af991c254d3abd03c00b7bd4cc01685a83de24ad2c4c2ccbf875a224baefc78193cfe07cfb11311ab3c85bcb8fe1bee64c32cb7330a4ba4f3fa9c68cf1f8b7cee6f86b04ed933096fd4806a2742c7ef1093a00bc6cfb479d298b9fedd974f38e73a6372b3c7fe347503180b5df48a206a955dbaf4b71be9526533636f078a210c32b914aa1b072fac14db83f0b3ac92acc690528806f18a4f3bf608e9b86b0889e23ebe36a4fea7a516d573bbb9659d72167b5d0ddd88945f0d49f93fc81a5fa9076e5e52885faf3b6d9682b918412ff2ab5ad9e368c4c69989e9c297af38f41a72a29e016424070fb104fdfb79f40bda55e67d78e04b14e9759740240ab7fd89b3d285347f3c3d1a2d66710e2fde73851e038b40371ae355d55dbc8d75f4a4e18f5561fd90655d0183c12aa49b60b30d68f9a37a31b113b6c8ea2ab8406c0e4e4cb2555173cef0569e78cf8c715fbb589cfe4d0262d4881be9ed9c9f3ecfcb58bb85c9af4d6fbf3feb001ff48bc3fd75bc320bd88c82c5c0d1fac15d0a8ca2c20e9455d68c6a982841049f1420ed4128eaf87eba1a6488fbd3b23a3ecc2147795ac7993a58598340a2f547ddb78c460d382cb5e09ad5c17061159c8390ae816a41b5f0d8cb5a7b637f2647ce103229418c2fd8dc9daa0a8586e67a27b5dc184b7caa714399a9af9460bf93629a3fc0d3cb93794759fdf4a3f360de48996d67e51c887d9720251026f5644ca53f9dca6d9fe5d47b9416da19ad0a0dcdcf60171eb75a6ae77e09a1f9fb024f94e3eefd1a7524f66c448337db4de0d1bab96c4be13d415d235747c4664d5d59cc265a6fcebb008377a6309ca16155b80d2e0ed2265a7c9a19a472d5310ef26e5ed7792e16d82c90a82892cf7404a31fd32fdd5fb6792f1e24643b6d24b1796d019e776a6bd33cc54db706d4945433b5e68254cab541e295a5776dab7045b336e8aef1cee170a51409267166f449d06ba0ba7e2bf2a1481251cfa2771fc05f619a2aee045a700ad967848065e861ea30ee1710d0558d40ee13e2a9b39f1a0235a01f283a70b439b43d7ee9d5a00a6d6130c6059ae6775ca728d1f1f275ce41f4c147ec0fde4e7f70b903131f624f5c39e0c7bc803e9d213cbd3df2f192c170b60005a8a09425c26443bd7efc02c78e932438c63cebe25121e54007ee5f919432ebabd4981567161264f6e9e32e9f8d3f86cff66791868da79b47d23456a81540eed41f3db966b85c08fb966e723eba7c1a9b0c49e91b4e165e4339c9f3221f7d1b5bab016fc16ea71d086e62a0f063a7a60d89cca4c3ec32b96c428056894ee3e1c04ac19a271c8a96a80d20bf16247392aa07c739fc37f2d75107f5020434e7d6d6bc07a0349437baba7c9c21fd343fa4a992718cfcaf8e792595cf9a3ebaea2353a6a82f23e66ff77b428ee5335ce53a6a18708805794559382724eb16d4a5d078392693d919ff6b908ef78dd429f314790753c020d09746369b6ef30b6b8372bb76b51ac33a7da46016295c788e7cadd08e32aa8aab5948cfcd7765e07b7bee2dc0a86724d6383967e75e96a54cfb7bf4f900cc244ad8e37014a28d560fa825ba0a8400aafcf53d477670c17d119af9c6e4613dbf65d988f29a1ee95728443e56565f14ab378c13d3477e149eb94ff99bcc73ae2e7ca6fe568c080212ea586e1d59223955c1b24fdd9312966f1d802bdfee44e5e05a79ce5dd240e598885b54379f5252eb100b6947301ae5c520b8074fe3324026f4f82b4ec7f805614bd298aca6b2f79613135727b43fc3bbf4dd807ebab17bad7dbe4f53f6e4ecc94561479eda4075266d3e798a1b0318db2a6b0150a0a5de23a7c74b3169a93066aeca4441ce4edbf92945ea7b940ec4da7514d2e9fdb4e6063c3eafec3f382b66e84aa754cfeb34aee0937c337ef446933b91a4bcd519097c4fa131d7472b4fe7819d7a4beee9db1a844a4e4a649e99b467ad3f253e42ce76d6f9b86a9eefa0d8562ab8640f4f5134bef79b07ee91cb1791a13db494be886847d886ee408ecd2fd2073965b448d9e6625ec393a917d4acba8774070eea6cea5d5d6cb764001ccacb87b4d760131257712909a1d4cb3d16593b62d05253bfb03348aa6f807beb2c076c2cd29d0c25afc191a67bfb351d6ca5fd0dcb7410d3da809773cff7f80a7331bfd80b0e0ae9168e81d156c0dc164fe5cb09c73c289439c57b1646c1839505567a755d7e4f39d28a451d6558996fb05a376d6bba774aaa8fa56ee643092ca31c955cb34d9a3c10b0faf63c8ed8da597defdf6c038cfc29f17384511522ed5c085ea379839c657c1f61a30f01129714950727182de5f60bb5d9e6cacd33030589db8696764ddc3ecc3df74f31e7afb4ba9e72501c83a32a5c70535480b4e586a90ef81d9a2d3701400ce25230a1bc06749e6db10d5304517f16c388f0159de6c928800eaf8f34d1f5c108cde6af1e790c971e8770f32f06a0094f54063df9376d74c876dfb28b38604cb0e25bc9f8fec2cb69fed7e8c21a12b8c87d35c72455e7069ca418af8cbd9fa17746903a951119bf87488cfdc3ef4c9e5f711dba6615994c151ec1d96b7ea76c721c3b02b489c5d6b20fe8772804d7d60402331edbfab5b1dcf5cecc5e994caff92ccf1370ebc5705dcbf53c71fc79ae043af492bedfe9fa03ca39228af1850d4a825b9552f35ea8299948db439d4daecbde643506714805fb810471acf0adef3a7d4afcf82d9ac63cd85ebec04144c8d8f83fa548a7148fc4cc0533f6ab62b5faf8725a412bdaf43b8bc98446253f600b909d61c9b8c2d898c4bbd94ca3f664b32799cff1cb2bd52356ca3957df8ca40bb28cba595bee3a10e2385684802271949395d754ae2dfdae3ef0023f6ee6ffc0ac743c9050a3b3f94b6ca486145dc4633230d159019adc28f46591e8678625e674e08acd89c3d979bd3f9f7774b3885a826f38117bd853bbaf41d18243481e8d87ce7a04d09ee5d3eb1007c69fa0f42ffdaee70d01aeba22b0391969668ccf2c1a9245bc62e2c4f15fa550823d4fe6c255eba5dfa6f1fc23af4d11327564fedeb5ec1a26d1bbec83c966185ffc5d20633a6b107677f374952817665f15861ab606f186738b23ca469ad0e2c25654a9d1f162acd3578b3f134214ee95f5370a226dee2ad2fe6f8b8c166917118f03b4d0ae5e754661fa737148952a0eaaf6ee1bfe21516327b3f11b53202c0af1301009c6fdd691b3692d7a6060ce9e0fb7eeeb97550fb5ac0bf46053dc5de796d3c1a23d87edf965a249c11569cd57f11a5efe9e34b7f333d77e1c1e51f1ccf9987e5cbcf5fe9c9ae9220acf6125044af71e8ef8a8a3883d38f80a045dd5c47ca1da75de1be0d08d03c05554b495463b6087bfebc049e78170537108b8d957e7415a903d993e3042b61f5e1886ae262e9c9370b9cf3c8cea192020b46e4345a9f46a8b97eee4b08c0686d699f5bc57fede7d05858f304c42109d2865f03d0259339ea49da46a67616d1ed8a31148f33540a2d4b448584349005c03c9a510c3c0c6224d58ad868127186f2b4462515885c720f2ac5761f08c398f9bb011a181c11a5c73775bef940dca47a04718cb12b3e7067f64481a15d8b3cfbf17427c8675052c91c255911974a54142cc5db04a8c87ef747b3cc1f1d0d3adb7989f4d40a24647755e5cb6323a3f424b81036bce571fa01fdaab5300a31c949b317fac77d6f0f1069f7ae8c962bd131c6ad98f8379e8b21f3f75a9ae6e1dbad310d03b2c672959793598b1e1d0f4a5e9c87e7a9ff63cec37f6a747ffad42a0f9dc2c0cc3a2a392a0b1225a19818199d16f301c87719615a336a07deccce1b3b8f1952456d93b9d24b417c875d119088636b1694555d96a795e2fefb2669794d7a764fb5e9e6def8188ffcfeb458dcc6438b1293a0737eeccc76d7b6252536373233c95793027b5e88e85c618931e1d80594df9cf499c3d353ae6ba5514c2acd56514b28c3e875e9700c24771c3022f4a0dc097e83d1823b01fd2cd573d1ff2db6f52eef5c6e68f1ee239e90bc470b0ec7f0bf9654daf018dba0e211e95f2aa97f73b85188ff2bde484e679895e942f6f164b8ee0d22a2465f87467dd720d36c735d3bd176a99eb6f28716e29bf592d70882dcb9ccebd8ae52e1648ca6d36d128433be6b321addbc78de7a353ab3acfb5c1fe292de83a3ac82a4ccda2ebcd64da2a2cea7753a3cc6d1c77d3891d93602aad7bb71e9f111b214a1bead575646185c4d859d9a7368ae5d571ac181fe12224362f2cf826e46006c007aa9547caa71895ad00d0427f1b95447850538c4aaa1e5994b96fa401e777fcb4cdd34d60d48021a3456443c64a4a8df6cad077aeef59b92496cdaa2ec831d1a9fdb2e7b9a7b96ccae984722ad33979f7bb011f1b93c30e4d8ff8b3d349374988e2847a99387e708535992253fd10ca9add37cb10ca2183d297e8ec81d38d3bd7837c92709490d27bde2593eb8747fd477f7be6372695bf73a200412082b7f06a485f783576b0dc10944376051fddadbed26a8aeeb75405a345fc79cc2af491bff84af966d891afb24fbfafaa160f19fa24682433cd3f0723383872dde7898ffe61e71b0aa6baf58f7fd0d1ab2e129f4da9fa124609c45405d8d3747be36f48edb39f01ee70316630154f6cb804b56bb82b41e5abe1257b06856f562806be72cecc522ee3fb7cfc7b3588b8b6f015505d3e3e7ee61ca5307cd5b40819c48ecfa0428103119f79f3eea39e5ebe052a9f93a6cf212e9b1e72ab17c8b76f8b4d0d90e8100a4893ff915effb36663283a558a4a443022edabc983595f4252218e418d428afd0d2a6bbbb1bc5476d4535c39fde93029b31c8631100f4f9398964cc4c1c833e71c0b9cd33e36956c14adbc2f46d8ef27f3248f910b75badeea4e48c15ecc69598a1fb42fa3ae709c093dfd61f484605d9aa2a9b8b584df16116e9a5ad7f02f0b0d3ca693fca949f02a1dd5c52e05ca196b3b9fffab576573a14fd3f35e38d546b1af50daf3d4a3bb69985755a82914c37bd04cd6eb619a392ff6afab1e85f3054594e160df8f031a35d456c3198b9485eb59e160fb1618340c76469872f60ff2ca902b5e1cc01eb41694cea443bdc13c8f112b2150e9913e33bf546a7ffe0f3f1eb72d06115f24fa315736d118e4f489d21ee70f993cb7024c76e6ebc425e2a843d24f15a24faf8918c60320279bbbc6ce1e4e0ecc6acc4441c0913ad2732dff433a83e0cb929b6588f402bb136a05958f79d7d3c155f682dbb7257714f455b84986218732501c09b4831050bfdca73cd0312b0e90e1cc4af743df2757fc51a26b1894c28909488c2d579d404b0f5c1c4eac77f774ad5d5c37c990ebb1c56c62c5e26011e6d999ca3ceb4da91c4901526db05c6b47f54cdfa7d5253b2128981f96104fce70601d3e1a1c231dd095ba6c8e24f8676b701662ae27533c312acd7ffc25e3bdedf797c1f83e1b404b4a5766347f97f9395867f1a2ff095cde252288230f029c9cba315dffb311ca72c0e7a09a3f726d73b240f940506d31fb802c6dcb7e5a6de0bb28a6dafd4ecd56ddc252213b300871d95f876473798a3445495aa009741f64da7b6a4f9be428fb20f9a58ff65a4f772f20c000fae3526ce27463fcdeff14a6fc3810a23f2cd88227f7ab633957e7ea3b733ab4ceddbb904e6c48e4700ca9b98570535d7f6ed41e0e04a384857947f7dc869ea77f1fe726b9d4f9620695ddb07326b5a6a837fb1194317a41c8e55dbea79cfc156cfa2461d95e3f3a33a66643817cfc50fd6ce78ce70e5163a1d14a4dfcc23fe97531f2028c7d9a9aecde247c4e2d1db28cf8ea60ab7299f1db4e34f1eb1839476c0c2df07df8a9404f22a6a2355a8e91355b0f02803fcfb25fcf54bed122c954f6392a974019b1fe758cb1cdb1087838cd436266f36891c0266acd89d4fc4c15bf6b2b71fb8908dbf0ee029330004c0ab3d8e5d7983c92b7f4fc562a421d8d53d05cb4fa5f2d6252ede148d0f6d3d2d148fd2584dcd94861934559344a0190770d094e422573c741f09d73c8fa581f3da36f53748d9b98009f49820b01c264a891cfb83696cc36ec9018105682c9e88555316214d7242a40c55b4baed51749f1acbd6bfc740d4bdb1d1e1ac247130d030d473f8cf65b8e3ecf264eca87f9a52dce5eab4628b3f50f71a72ebc39207203f5ed8f56f817ca3cd99663d45811be5c8ad93d6c75e0a4bf11df1409ef051f3ee641d5331935d0aac20e1a1137b5669a1b0b93daa0e5523af59c4fe90fcf95433cc6439c2abb503f1e6eda0b23a68acb790c1a701e26fb93774608658dea3361261c19e9653a8553d7d94ce9ba5cff5bf69ea8a022b623afe71ff381a3834fd62fcf4da591f5163df63717fa4c48760accd58cd2666baeb60ed3f4d29b2d193283a6823a57b00b28be49ea40caa8db2a1ac334c8372574dd0b27c9f84aa57def5a5577bdec0c0260fdddaf9a3b3345d3b767ad8e0d7272940b25b3ea5f232dc32c119d7896675cb247341214629347c165bd3a10662a33eb98ce7c9a378cd35edfcb667b67f18f7c8d82d12e1e7debd4b6ce032ce6b4078698ab7b9f86615136e82018b1c901f8f6fef0391f693bbcedabf6e0cc01d6a9a478a4978ed7ee328b05e8075d8692167bd0f8312f0b95ca30851914e4684b6a1e7e2181f886636cc06bfc7b1d209eaefcc2289bf0e7e02c882b019e4334b12c602fcb8f9b25acd837009947fbe0af1bb59b2f3852aaca4842bf7700c97cbad08a08aab012a293ef06159b6e885672b0045837a9a2f05e5b22b8fcded9ae9712b2ebfb67b33f352ad07cf033540da213185b3621298422ffc266e65caa4b00a5cdc229d3f48de3da8a68de546150b4c249d130bf372225cd4e561bdfc3c59886cc56916fb9fe00e9257c441c4ac754225d5aca1233b4dd60490df97a08a3910a12ee80102cf220cb1039d05cf167bbed9f8e7459d8361f7a0227324569dd8e2c6292fa8e94d9290cc65e9bc21dd640f26fbbfb2a2cab9d30c16e98379fcfeb441911a08d7f08dafb8212476972f0b20ddb5a896c30d12395f99f3c6478644a12804ee6a2bb42ba728b40714d6063a6c4c8958739f6d6faea2cf8a31aeb515336fd4c8d17b5a4ae00977b46b93d44b68f8554feb15f16877155be35a36a11c79cbbd282bbb678231172564a596e0e72c6a1fcf6af683ed4211b8842ba16908737302328a27a0d51b6b84868df70b51d7a578699b1c1c2a9fc8088815c26df92738457dfe1637e9701d06c9fcf39276e085e8e1acfa3152ab73dab08737305a630abacf900650464cc7d5848c1875d9ef563c1deb148138da24cd134f992651f61d7cd173752512ac4a8799c302255ae5cf231e7c9aa2c500f1590a4ff61e72e6ba86cea8d8e5e75e571d23b1b79865478c7e3f93da75a4d83fa23e29590861c07744cdd9d9a3172ce050ac4c263fb1da41702dd2df0e75bafec1abba81228f6649ec3135d9d7b820020f79dc6a59b7435e2d7b3cc84a19232765a19961b07ae78b9477f2f2b51b0283422aa1b44f4e9d8e97eb0250de89710676a944253bd23eb714215d6fe4a1216c20ed0f4cd7bc4f440a8dcd806b94d118ec0a24d1c6a0fb177579fd4512f8df752c2164e82d6b8d1d4cecd0c38f1be5492799431e577b65fad74f1c93d9a8063ba778dfea43f1ba40c82f4bc734ee2f93834ee363f2775aa8ae94d7d0a38f41bdb9196de5a51d7bfd09de1511f972a96592d19b1f4a13304ada0248228dbe5a2f5720a1f14986330e105e340f4ecba52b6f4dc6e3f467542c43ef194c4a120f07c65d67fac9fd5cbbac7a6c52adb008eb51d23e381dd534e39b180f98f378b6289df190e38e8947c56bfc7f4073baaa23ea2e55c1b341a1b88083339307668665b67c145f812e7487fc2cc9c9eaa19aa5065e6b8a49f01b7efa50df146bf22164c98190c3fd1d7d2956f4ecafeafa6a654c46643c1d1eb2975ec4eed4a83d7dc5fbf7f60794e0f5e2f716066545df434857cc7c04df3c6298df26f7b7eecb36b059cb4fbfa85631cd6e64e22d1428cfba0597e10a8cb314ac9d849854632cdb3d18892a8b0df40e4bccf6ff6896ef004f79e726e033e92764be316c3792aa69fd5e6c650c40c25de8f43e983e583e7b37fa15cc2179d4f7b7dfc35fdd2a9c55422a90ba5da93eb1549f1964b034ce462c71e0cf7f3d3ab8fb3b6177a6f28c29e82a0a504969f779f50e54c4b245504fbf3d5b6bf6023d1ea0d7fb11847f549ca61144ac07e327033706627c85626dd6e2457276be2db0c66efd296e36dc19162372a8dd645d86b8d6ea3bed38f90ee52bd1ece4c5486c3a0dcd1da14f39ef4bcf71e0a99bf65c7b17c6c051ac0b5ae33669525221fa31bc1ef9861fbd567002644234bc5ea261bb01cee8f11c309858f908b6fa7fb4f0df4aa9afff75ae013ea57b8a12884ad8246574b2c8af5fbabf940a586307c73769f449209d1b975228bbfd5b033972431101bc84a3edb7bdadd6ce6af94fc5d607afbe2872ddb224360c36ab953ab60ad776b7b97961e768333002c1b7e03cbf3ba09d3b53e7d6a0e2f5d43332904de5d5f275c5bc3dc6f6154c60331a9e5c1c50f05ee8a10f8eef5d93c7c6c6a9c9140349025af1f7bf7031c5728874231252677ed508efd840aaa46e566a4ed8484fd90bd47251140aad013433047a29d6c1eb1e10e6581597654b9bab4592abe3a4859a34816165ac816f97242727d432771fd2a2e0ac873d2a13b1c47ddff47fa1e4172ac0f84f3780c5c8a4715ef0e93bda690d9cafb85eb2987c62e19edb102b2e9c2f287169b4ade2b06f4675e5b31c2423118dcfde72f188d18f8d3e4b293c1505db5b0ce4226a6eb1d7969f2796a28efb6c2cab6686c217b7499fec5e015584394f45330f03d94fd56bbd2378f3e813f864654b252c09704e71e6f11dce90ae5c02f2af33d886e70908a05c3d0dbfffc40ebfba854d8b06f51f30550eea1910f26e41f811eda81cdbda8b85b627483212382c04078fa048dd107e5e29150ac733add2b79068b912a43b1b234648f01e658fe5d34cd074115371ba81fdf9a86bea83d83f018b27d296225ac3dbd62af443dbed81abc3cf48c7f30e420671fb1eabe244d826d74314e627958db588e294740c86127eaf2affd638291eb88199f1146cee5e39ff54bcd312b8098e12254669c96b151330a4a7f049ce9502a9fd371e9295e3f9743ca0c8f034f9e21eadc0a93f68e1dd77056eab1b4f0bdc3cb24f3de3aeac587b28fae37a0c7d3c0d8654f3867580417de27038b0c52467b6bbf8a5ab498b2387ffeb6b16118c850a335c35fbde8139fd6b5afa256adc60809cb1717e95e949ad2cc583007599767166e401c48a684d65bdb85b4857da01c25b6e12d56193a3b3633a474e4f0229037d1ee5da7b7c633210c6afdaa3c6409fd61bebef23f36c7e950ac603508b936cc0abfb94aac975c5fca7f41b850581326f3c38c6473359bcae2cd49888e7c67e9ae73cd317f0c988d23dc1e39db4579fb0b56280d055a8890558fbb1dcdc7789f0fc57769ad5cc805dd43da5d861a1a442ec6048af701c24af7e8b4489036b5cd9505ea918b8898efe99231272feb4983f04f0cc16c1d46f5ef3f7b3af2fb69128270f967be058dca771e288b5fc43fca5de9b565ceea0b7ccea3a2eef8835de4e3da089cc25efc62c06552e23d301e8b028b8a5cf69ca02ec1790667b79ab1e27f9a0b1b16f4363630207bb534177f7c2c16df98e348c163b2ab645baa66cc622d3f4bc6fbd799bac03ce4d8022a06e84cf04b845ca5b974505c6799838084d932fe08751e5953f8d3dcf1ee21e7e9458df1f330ce8be2486ff47bc79eabc56df7070f49b198c2fee00ce45684219662a926ab8cdf23b474bc1ec52bb532e70bc6e461f359e7301fb4511718257b901dc55bf080820d3c190a2926029e28ff24f5430cd492b0e50430c1754a3f9e99a327c706c3c21c53e9e4e093c059217a66bd18929c65253dcd84f4943c06f5def33f29828ada5cb42a27150ef93e138ce58641e1764108300db193eab0a1f280bb6defea8313bedbede8f1701fa5e25a531bba4f52129e32c2f7afd5a62d6b07d7d2959fc0d359fce591290c502ecaf15b1db9fde864b93aabd69ebe74216d0431b68ec299d3359490fcffca88c6088be36dbd29344b7f05bc65837e8821885dd09930ae9e5d11eae282708849b871196608f1d9febe01e35407d1093009e40647f3c1ba731fe5dd3e57a25a4358874ceca0931d8c0839c662430c06d478a09bfc79a70b39d9ab7d84f66ac00c662a329bd151401c07d9b4fc531b44c817f7f0d623a08e7de322ab8b6f76ab1fd10d6e32c90bc4570fa11191a5660b241695da86e22536aaa9202b50500da959f22d8c2d2f557d65ee3528541585bbbabdbdc6d66620171a4c22851399132474ca0952c3e66c833edd8d1671c9045da1124abd4d7b2d4cf89a28a77741f295a2843d614a43b3602a8cb09fc9a20a1af30fb1d4478f3291d35b9b56cb06b932b2e337e0e06c3c637cfe3b8c598d2393b9bfaa1273f68b460516f01fca1b7e849fd91bfa58322b13b1a197d4e6f6eebdbdf645fdd3a1547f605b07fb961b68bd90038876f1bbb0ee06cbc03fc5c95ea0cac51b353edd7ca5a2d350077c36fd378e06dbea3d73b156727e0377d0f73850d21b7eec4a1177b3c84e7c7626f3baf123eb4d4ead8ce439cfff304c9bdac5b6c9c0570d4a68b794fb8ba929ffc6d0e3b2ba50a22495a0c3a74297d4283cacaeebb38624cc5323f1f0416250c7af938114e35e173fd620e96b2530b063a39b1720e8c1cfb0fef1242134390f3d68ccabccf5f17e29a5b0f6145aa7107ddfce35346c300605859e7d0a909f9b6641b5e25a749ca2b97c123c2e9dd253f16c8d61f98b52514b9abbeac7bd4c01a794bd87b4fa30a8d0b7ed9bd5718b58a1147a4e2c09d37ca8a00487c6328cce862d89817fa7e7fcf48716f6de62b10571f0a86dfc2962646dd62d00049e3caaa3d0380bad04455bf1d55bb848801a7991654692cabb9d9ff4c6e034c984913f4797e9eddf5cf5edbbd727e6272d50305c7620029147e18bb11296aa538b97e9a592538a68255879a05ed35f50056001236b0b0a28f4bd2be9a772e8afef708f8ff5a47f3dcbf78f59bef93e6bffb8db9b7ac8dae172fb7446bb9aac5884d919d2c1a5444ab0805b5e2340239d60ed32579a5790a30a8c54b48a8d3b63521e867ed094f32cba109bc918e17caeb970b2f87b90bedb65f882ec2b948bbc5fc53ed2502e4b429533fe8ffc716952bd56cb1bc4cff3d3d9cc42a174a908ef3c4d51dede0f6e1f5ca63ee067ab7f91790e86352c3f260d49e2d36a7098d42e65ee2ee5a0739ba6cc3cf9080db0b43ca901ccaab81bd1ba12f7efce851f31c97dedbdc6ed143e7d011d13bc09df6d3516a9261edd962f80108387f13892f7a7970d1e2e46ce60515b5562acedd13d5fdbda0f5ee9d2447cdcf969444f174f74c7d5c73f0bc15104ad1960fcddf2968eb4555e4be349eaa988d12b1a057b12f17cd94285cda1cdfc2aa05cda20956e21f7c5f1e1ca39dcecf043238f9f953b6bff7a337a6989a96e4bbaf8faa22e82a7f3f4970f81f984245243e21e0212ddd89458e61132cd00186a548a07bb6ee06e5334494fabdf822532c6a0b7c5c12a1084ebd1f3f99d60cb45a24fb874e74260832a24dec6118be0c0c2eafc598a2746716b38a99c48aa76de853ec0e67fe2ef4d456cae2801c95e865ef4519ec4f6efd4f466cd7e429f9b68c918a6f59f4e6f81e44b3e4089d1b5597b6a5de8be5c71362beb628143dcb3c45655aa43eff37e8fe90337e462c0753c58f8ba5bad1f359209878d24ec6c57d035d565496c89365742f91ad818023aa26bc50b5cd04b2fb5e7e9d2cacd3c241e13ece95fddc9617c1a7b28e8996982ff760bf075ee48a4469b9466fa28d797da6739ba8c8a94969abc4c6d2ed9483ad0afdfd24e3f59e5afa7d62a701025a2e4a196a1305c4386464d817f3599b558fc48a33f6dda793be40509a2074886515fdacd36bde44a2893a718bc3f3aed1e02fa0539b0e83fe2a786ba4d15c94139ebcf6890ba0241737e0b22aa0735b6f3c751a3b5f9e905f091d8fcb4dd5fa0897ea7b311b88e32121f2420a18037e7ab6d513cb92cb5f9d02586ab70aacd2ce4a9a06fbf7d8400e2b183f7b0b01e829898ea3f4fe836c94e8583b7e1b34f90e356159e1463c5c75f81c211cd42ae85b489c3d47bcf5003421481841c6d46bc02d618b65bd45377ba8ef1a9c9b8f020631d05c502a8fd98703315db4db54f99a3cb2388fcdaf1708bb54d261498a691df3294f49447ecffe12d13e3b51f0c5b70851e1460303ab526c1dcaa51d1c584c4a584cacb967b6e822e8c7f6fa27e5488b191fd20b1ce945c3d5fa7750b36840e3fbd9cb7aac927f6c07c80783fbaf8d06c5e9a884491afbdf1f6ff55d71317ba242f8365e28408aca66464eee6e321fd72451e2116cf24aee4077b735f83966cef4fc518e2e2c1cb9d347bba25105f4545149b9c08e6347102b2056d356a7b5fc225291f718e9cde64f2c99e80c4993e83e96b762643b6dcb5c2baefb7cabd4c531154f00f67a7eed20b2dcfb6e0d318d37b10be682fca456f1680874ec8af5bb3ac3ca2a0e8e968df607620bc74ed2ecfd1f1b6d3176f054e9fdbbd180c0ac3c20fa0919740339bc6de674ccc769efeea0379fd3a8846ce419b50959b027ab61979d09f53637f6d38b5567aaad4aea2239cc8b4c2be1acd8c4f886c85cdf92b061cefd5edd9b41ff05af9bddee3393d74d4498ff7c3d285c9f121dcbb2f2a27ca3d37aa702e113bd92e736e62c2e4204ddf5cc12207fad5ae4776e9c07087128f96f84f6f12280fb9d7b71c4a67928eaef21ef6a5db4093b8f6cc967b457b594e5a75f6e903798566edce5157f47e796f8300089198c5b4608f5c53668e375975f2c7364190f6c902431b0f4014bb324a85582cd843ee81b9045e01361ea79c1993bfb0903fdaa0b8d49765e6e6dec90722af6429724d106ff711b34824bfa276945213d20a83f7d23d5cfe9faa61ad33a2ffc75e35259fe6bad1ec894fef4431e42fe895c2ca080e192b261d7c8ccec956b43f2e5f0da4fcb90a780e662e030fcec1b541937782653c1b99637e1a382ae10bd3d80a086b5535ca5d336446f2f727275b780751ce699b1b7b5e631cf308cee24cf902379974a33361bba69ca8f428be2269604c80fad5ddd0b182990c19a452cbf0fc27832797653f89c969d159fbf4d199cdc5f73dda9fb0b7876d4141629c61dac00aa4cd8fcb4f481d45df5655804d81969e8d21aee14ca4e544e82a8d0c2952cc63447d5791d8fda42e72bea3563bf209711e3a886549bb15e6e252762aabb42878a4482f23b81f96963dbacc91b0b6f4a778a9c020df7c147e189407cdbaecc063c339d10b7cb2d7660cacf70932aed864163898f3e6222e6591eb113e2dc404444daaffa1dd0fad333f99dba0469f874ab8651954cfcbe089bc6e4d99036fab137db582195e40b1c374be6710079512ebca3fde8e5f39bfce34b839527af118f727c4306a0e0beaa6ee05a53f03f17373f2927ea463dc466141f02f43e4303b137f3afa9abdfdd2a5d93c2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
