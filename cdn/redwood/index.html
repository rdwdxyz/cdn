<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d998b87839b958929499645cd74e2de4f36c6012ce13343e125cfadb8c10688e536bd9a6e846cfd7388059cd39e2df208264dcedfec1c191473806204e9875d409a470d28f2520dc9a366e55b158c1ffdefdbc898e32535ab3ca0607700f95a3947bb55e888ab4fbd11f10f8ea0a88cbbda8edfa25f308745387fde72cb97961478ba34b6542738d8c2b839dea1977c1c81bd64b13a6c5ef4c05df325d7d47752a08f42909d71d7a46b8619b600f4275f49c789ca2a60a627b67fda30336bf9ca458a9353ce1a4fae19dd5b9b695fac2eb02418a86f6ddffae7e7cf1cf74079c638db9d568888506b9307ccde65d3b287980d78dabb3faca6f84c38bf9365f27161eadb493053a50860592b40ca940bcd108e9feb7c7997f7a191997a9136b98e7ba47506729fbe772cec219f4477c82a4a4eda72a2a37066180c42752147060f309b79c0e08a257409063312ff1ab40fdef4f8ed43340b4d3bec0f1cb9bd1484bc61cd707ede5380de8d56dbe7d706191179f3942adf767beeda74acbbde233b41f761b578f6b6a1cf53293a8837236511c4384f205ac6daf3b4483bdeb0c3168fa5d1768c397fbe520f365a30f95428d3e4549c6aa34cf3a85621dc41af1df19f1c88937c8d6a022479efc7a2108e5402db36d1863600660f11ccc9d08139c6fa7ecbdfb14ecdbe6eef27b81ab483bf93a04c2f27643a8a4106a8fd3d7d023fe2dd32bbcb6dba89858dddaf12ade3fd21ac3d32c8ec86a124a74e34340fb41c7eaa38cb3668e09d1fb2420997a85f7ec9ec59b4566e1b9ee18a2d614ba6f2d0a5baa299fb6a2f4f0a3bd61415aae6acad61b85465924a750a3ff5a3d7f5510f757bdb8afc2d83888c97d0505a7c9434b2a6b8da737e02a80df9e3d497e3c0fd8d4a38aa643730d373c8675959be8064764356cec1474bc2b7d76232f9dd4e20e04f0d02da4ca54579d404521295db410b96923407fb24410adc1fc1221e10bb13caffa730bbf279f91acf050eb5d278ffc32c389c900e6125a78926045e8708e5f2a8b66537819352b1761014861c2b73be07704db65bbf5cdf1dae4af530df3cff6bbaab43ad9c633d2d86d45140cc049f5cd828394f69fffb01260ff0ac410acaa58f3599bcfc9e8b6cecffaddba4e0a3a766f8ed0cf226e1399898258d62b9a4eb2b61d693cdad0dce69f7fb875cc3669bea7f899736f234c27534c5020bf0db427913d6aa75244bc1448396aa29b1a3c8841b88f372943e82043d9843d96edb2d9fcda5148c7669d6211bc2dd2f39bf45031561a9f26c29a5ea217de5472fbfc562bc1bd0bb60dec1a61d956bad43efa98827bb8f3e7650f9f692eda03d2b45a0eb815a560621b7e79e139b36ed94b3dc40ba9640d0c44f5b649306657d3e2e8675be00057dfb28e925228139da22704136196ecf94ce276cb97e29bf7b6b0910e1104449f5ee540075ee0edfb99701606e407f7ff216314115288325bca112c24578cd3096517dcaac7594b292629a0400dd378aceca09bad674ff35fd6fc3541f87e09e3b7ebed57e344cb844ec2465fe29fcf7f2b9cd17ce3985d3ca697f0be51b4c267410a2156fe4361f9a42424fd3d4174bb75f4a672ab97e58c0ad5b0d7bb5268f9eac7a313b276a5445675788703530b24096332bca939531f5a6e1ef9c3e2dd9aa45b1774f3a1d3c277f3f80ae967eab65d22eb06bcb2b00712a646742d31e2dae72c375ca9a6d7d7653a8d3f6a79dbe5981e75d07d2675e5e223969c909014566c0b3a11c9d1fff47bd8c1656b29bc167bff1b9413ae2155543da57a77d4e7b1ddbdc7eeb253891020825baf0113a9faad4d5d208fbb57b361c95ae91bd1bacd00d1c8f7fbcfeded724bcf753c12b286e443280decf52e52ef58252273518c82a897edbb881a57cb81b3d23bb7bf94e066903d7231e58fc93c1b0483111527882e6ca504500b7be11e48d65dc785b2bc59ff4acf5cf33d8dfc447f33358e014c661421d16ed0d13a5b5b62a6cf1533005405edc42fa66cdee3841910a9657e37ea3ea3870f02d175688dc27c819d0599e8e267b9e82dd5430726a6bdf297f2e3527cec367cc95cf8a7fc7b5204efa9691eb06f63f0b44a617fc2ffc669d312929cf27553cd1d82b99d7ec72dd2c1e2199971f9b8127c67b49c6a8bc14378f76a6bde2d3f0c003ab0994ffdb806e34385ca489dab6412c585625daedba136657625e40efd4a66efc10962ebaacd41d0369bacbb5e950cc4d820254cb6ef7312ccb6dac099c0c70036e324c6475988d437adcaca0a6b6f72e1cb62e8af422cf8f8a33b8c7192ed6370a1ed746cc06cc9c56353a09351344fc676c06672d27949fa8e1274db80ad49d798da7a4a4b51ef151c00af2f60f4ef9412cc98fd4ce95d08ebeeef91d344acfa1b260194679d3501188912b4d6c0eb7dc81fee726f721d6c8f1cb7931f33a21e6ba065cb87b188845baf952698bbdaa16803739343dfd2b5f0f1a370174ec45b1b6b700513e0cbdcbdb29b00e900f47486bd5d074526f6dfe0dc23866b08b57189f72da2430044cc391b404273c838bc7422cc3a35164368a3804f61a0add4e2cc6c1bc505cbae4549b111871d582b941690837e8977635daf2cf76c89af05dd8e3a4e300a6e6e9a38e948004434b38e28888e75339addf8addecf7aa608c463622cae6cbf38607de998ab65fdeec9cfff415f17a9a83be6f627851ef1b723264faaedb4bdc3edeba6c18b7f9d8f872c88a61e9d6f2d71fe493304e57e208bdb88002f81d550194e2f77127e98136b58b25aee20e682adeef01440fadfcde8a0b311f0d9883944761928a137ef60d75ee1c682583e67dc488c8b3e0385afd61ae170012eed75963ffc97b5dc11d0a4739f0895df3908012cf1d75a6da14ccaf14409eed30de573ebf9db4bfb2245d333298ceb9c0998c7a042986bedd3e87213fee37ef0609c5c5e8c7706a6429933ae2f3b990ea66376c24f9b2c905ac6a069aa3b84817178751b2e0aba8fb6b729e0eebdfb3575254a6a36532295dfd71c4884f725daa76697d81b5e098e4a1bba0d3a8f79c01ffd31850b49daea2e4866041e6ed8c3c3dcd33ecb60b0115cb8563ceafc0c9c82986892b10df3ffa686369cdec847a11a19f84add29f47bb2880a1d66e8215af4732f535225592a013650483aa1b031f1a76ced431fce00494f63639c55372a3b30137033bce7dfcf0d8a1057a48a16d747292ca29772830eb87ef99d2f9e026bc3a3766eaafec4ffba1a1caecca1120a3e366e25f2fe4397ab89d518bc92f7ddbb5bebe4fdf8f82a3735da4fff1375fbabb0f1eb79bc8fdde88c697dd68d11766f47433a93e1ba84f39a6a83ce196cc155d06463be0f3c964f86ba887999a0bfeeff97bc4e65b4a14bbae07d25d0c20ed30fc856799bd0962a2d59ab8d803524e2205081ce9dfff18ab7040608a3ca3e291d3a8e363113c85d2faf8d879ed2720f7bd2ac372f795175bfe85faeab0579b27efda97d22340c5b08a2750cffceb3ca8a248b5d291580244c5033f66c686d5ac1bc63e1836e5a6c63a9d92e7b800d4e24f74138e71020b3aaac0d5d84db4c2b00f371cf34f8b1264904a6ffc9383ae136074a014a47b587ea6508060f6475eb3bd1ea970d2a31e23c61ecdf4ab544e3d8b689758025386021bac26fc557a1ffff8160bbfc5277541faeefdbd41d24d8a88ec194225a296b8a5cc6115094793ebb262ee98155a8e12db4b52459d86bbcc317bb75624ac510598e77405028cd2bd0528dcb7f29f4caf5fd557f0ce4387a42978b11bfaa49e7eb0c4d9b210373ff6de7fc26e9aca2d3d7742457f1734504a696313fa578fd537e79234ecd301b1f5226bddde2df51595e0dcbd29b77b2512b6b2b054ab96d01d6ef343512b42908ea4cd1d880998b1681330e3b853fc57313112eff30147bfd4471524d55b05a67d4ae15a3ca54a7cc7ee0e4f8f4d77c334d1f46f22c973d5a05625ac9bb5598d5681f56f025d9a9a863020770ff20bcdd7a7c16363f181c219ffd38e731b88ba6cb3ceaa847677c2d98bb41806dd80ea373ed87e1df3a707f4709df7363c9d991acb36416882b100bd7356fb3d4c46170125fb18a9c8c4de601e75c3f4276940a7c6b5559f6ec770c25c08f7c931861dffd83820e507460e0956a9c81b37f7ae62feba5624e2e5feea2f8d2fb220f760875af5f8285aaeed8721cb89ffbaa7879c312e899ab40fe9fac5b917e5fd1a17bef0037192f5d34da5cf83289ab2378e8aa03836b9946c26f6b09796542d80b6b076bf8383a03f276a56e199bd63c8e9a42066c9316452f98c44f6d7b0af0b7523e0f5444cffac3cc77b0c44072aefba297b7e6b09c5b68773b36f0d931feb86873f088b6ca0286cb4cc6b21cffa362d74e464b6d69333117b62f037f49a88cced7966c3363918e616afe430b041ff376d293322c21af18ce490f9465cf9972e08eb53fe607487f058c665d6e3bbb5d32b24f3ed6c3ab3dcbecaf1450db45b6b6fd115cc6101e8111bc0958481e1056682307f6fc61ba56889b95bfa7bf8c00061a0424e9b9d1fff7a8280dea802c8819c8c5c8478b7d405c145a60e1936a5da5b6e8ace23f5958967916a04bf1a0e4c2cc81ba368065e639a0fe6b1cdfc0c9cba81d7d12dc07c5d035843588d76c3cb3ae9f81711cf3b38d0ffe33e32b081a5e8f472930b7c03fbf9a66e98af838ec55e24d767eb47b7cac1a67fb2c44d5dfcb5c5a4674aa1f3fa6d540e88bdf5c6c8c70c9d89f74863cdb33f16dcb1b9c2be40cbd5d0d90bac67272b929276a4ce086c1c4136f0de504e4bac156e16866cca712f8567c3a14a99878b848fdf327b275dcfd45db091a23a8827ad0935821cef2585c7dac329d3d3f575ff8caa644cfbaf929617be956c4b355831f3fdea080ede24c8c0a90480a04f6a0b7095dfd1939e2274a24c0118bcc58757bbca4398a98bec048d544522f995925a4e5d4d1a2845610c7f61e58edad0c90135f94f0a6bb8eb848033896b5b5ae93dd633db92b22ecec6bb25676b6275048debb4a1f95549193965ed0954894a2783f2cc43c228c716c0f7c13cb2735aafc10681bfd56b6fb05bf2320b20a5df05bacff77f969eee67057a1b78b3fcb2c52d182b99b811af15262a049f6e88a4390e5d1503bf8b7f05237ed0c87b2aa8e7e715ed54047309cb92d9d04bb4a521e8f8732bba8c2c585a922462443b3ff504928be9ef3d06768e49d4d151dddf24d9400f301128fbb3e57f3b6d0eddc5672f4c478ca3ced606e71390b53fb9b33b0d8637869d0a098aa48d6cdbda285f6a8fd049f3ddd393cfc1051dd3819b87e026b748e5ba90c6f20f4b3000f04b8fa4d0f5a2396cb63dcc477080f28d1dbdd67d76c49ba59920b89ee483fef7d886eca979ba201fc27de2e014bc739cf26a18151a5289ab5ef5bdb3512d2cdd8900e571b745cdd84596d34e2df324017b9d33283b16a6db84a6194968531f76c10f216bfd3effc17e343b0aa98c4198f3ecaa8d120c5f98c69cd0dd36e5865bb2608190ef82611c204bc2c2fe75dde7082ad54e749cb14aef9d470d9cae99e122ec2457fc83b0234a08a74f91af3059f7b6e73cdfbb9440f900205efb2da327321e346019866177361e67f4f4ce3bd1615007da41d42cbb1f1e747ececc2f63f67fa8325989467ea40bf349add645e1393f5b65df5bc944ef23fdcc7aea34c5bbf96258e634993eaab0f0ebd71393312ac711b3439405aae680af7d91fc7d6f8b0dc3ba673ebaefe8879b3622288f0d3164250db2f07cf06f17e9c28fea06a54e8aedf3822553cbc329534bc7f94b4bf4c2851bfba5c5ff2b5e26f565f4f0ed579df35db9c793c690233829908d9fba0552d56c81ac767144d3992612e92aabb6bbd8b04f72044d7dfc41cbc4a6e8a708f0b55183baf69be97ae27398b159bfd07b2e400057adc3a571e1fea35bd420d5ccf6bfaa2396eeb5c26e65963024c4430fe5a2c07309daa0e3b6ddff87841467ea92d9a986da0e331ec29b4aaaffc57bdf930446dd57255e01a980efe077bb3acf8455938ade4d8de6534f5f3db0883e4a2ecdb1009569df5689f9ab9b9fcf5600264a90522303829492339b3905f09d204a2bc4b8a7d6f447e481b7595d85f7ed064f998707f66ec9d924257a0c344c4fb7732ad5cf8df238c951499293fbedb27f4b57b7128b1f019d75642b771f862c6256bd2cd5460ddf6da9b12be4cad6a5d14dab1fc47ee8bfb22ccc1e2a7b606d44bb08acd0e782acf4b304216f19db1adf10994d49ff31116d6259182051316446bd35cd4e991b020d9e9f43cbb6410344f1eb24c74abafc3542603f0cf9ead0b49dff7f000d1f405546f35700e6fbef86771002b3a6831ed12e95f5f4e907a5d2e9547d46e38a3e6030436dc7111f141ddc89d337f9636b665c77f6807627193cb8d7e58907c1c50ee68187952d6ba2bd9635939a46c7429b47d0d54d4dbffa399509573a954473fed28ec29797f63bbb6368a8001ee8b21ab2b5840f72bfef8b500a31d9538ebef70bddefb75ca8c4ada95818ff3de16ad9c145308268c9513e5062300367a443a62feb1f99e16e1063dfa88e7ff03d7a05f25164fab0ac7687801462a021b92af5b609bd931b885e46168d31bfacddd78cd88f0560929fcb4868d21fec237724ebf13f5964bdf74bd673ed6c046b3b332adfbff2007f62fb49f351a3c5ea34f6fa9bde70a0bcf5f766cb19ffc57fda1d74da3d563660864aa1a8dc70739cafbcdefe774ad598e5dad1987816f172bc5dc4dbf74895f6739727e17ade77071dc4410ed229d3ccc28b6ff509dd31d9248e78873355e1fe9ecb4b92a04ed798e1c65efec063c782df97feeb2416932413257510a56005c06d7e49b4fb25d7adc42c51d6070efb06b509611eef2757cd9e790af812be3efefe376c171a0ac68dfc8663a023477dbe083f6ec5d0feea6573de560363ecd66f3fd4954991bbe0ef7bf4d861ede0903a82de4ed9a101521803b9e7edee111ef9c3d80b4e5477dc81f798a82f9ef5a972f9cdef137544b300cdf78b870ee4b283267314ed7b305adacedd91b6c168ccf5bdac1e85afadec3af7010b160c79a2018a987f4df5532e87920a90b1a47fbc137da27746a0de9c80e56d6a11c418e7bca903e0721e2ce1c19a03da0f86770fd89873caa8d43f3edde9434063949a58c65a298d1dc5f0aa719a8322f85527b498105efb0c335d4ae5f939f5ed4008864baa86fb42940220519e7968aa02f03be59f2ae2b08dddb5d6a2b400b119135d067713bffbbf3beecab978633bb1a330027e62d55398dde4b3b2f6a081132770c14c3e13b19c5393f8f73b1edf92c5157b4471faa102c299450e1fd4e0e55ccaef3d79dbcbecaebe1f640ca125225bd6a1f38b2aa5fcf95c782ec295ab2ecce63e4aaa097fca748fee898c727bd0bc1db69c16ba871b5d360e0b7db8a04e75b556e907942686e0bee50e52344d3ce58a9df3152de4fe23d6e85bebe2f0d3100d56f4710107bbdb53ac779443947255e5233dc086114c0f1dbc503b6eb8c0eba5f3538da9a08b50d078a371b07b3dbefec864a2064cd9dd358a4b3d8428e65d39f1c33856be0c76cadacc99f52235ea47ccc1d14b0b3676b12307f0df4e1d0ef13ac919406cdf83c26e166c873ffd115c614b0c1a413deae98e199a3a069e2f039adeb2bda8ff0609321d9f895781d6f0725abff2e5e5e1f5135212adb2625e0d7285f5cd0aaef7809a72d52f4f2ba69a8b2dcc8e79766ddafec6ed807c1c267c28fd7b5e0fd545ae097e35e5e9bd81438aa4840f7584228518acf78031c52fd0d672c674a42eda3fc7ff2060f9ed5447602dde929660e324328dbd50445832f1e2298aa368ed7343777b244b6bfb73d180fec616c27c99570108ba06ed9ab45ebe9aa180923ba85a7ee04105c41ac96ef6d0f32b5b23dea332e1a69a2f56874401d247d106c1ca8a4dd4bfe1b3a8093093eef1863b801f12ce75a1dc4365f97a783cb95bc866a8103a02a63b8efd4c47174144c606ddc3d1ae01c056dc761e63f053b2a76cd4789168fe0acd88b907b19ee20eb5ad946e9bc36c3c583bc32571d7f5cc926bab25c579dab9bc955ce019dd641a8ace6e4771ee468b772fdab3f0b4174ca4a9833fef18b6272aaf213fb07714cd9f0c19f9267b9f09f87ea542db62b886d49b2d48fc72f5255ed929d76854622c506b2c03ea5f7ed827901fd43fbf3f99f696c374ca82015c85241c6ae9f28185639e101bdf2d00a9932697360e251dc0a8c16cddc69519daa524fd1b006cc898a1576038b4fe1bc670f81f0666adf03491fcf57d6a6f321d1ddf108fbc59a6cbb5c99d4d94b53396ee5a5aa1705569c343a2c0aa80835874d2b06ded7c2bca5465ea5cb1d49bafd17d3ce942e2e16095e36189f04496156b3bb3955f05c692cb9f22f499375b703a620e5f2c27e28310039b517af23af44510da830f378386a69b5964260be4a995450cc205dfa6130dca90dd43969d35298dc8b74b4f77332dc6e2510d5967854a6c77a1c5ba23752427ee67b2b57a33398902aeaab4754648fe99954241db80438c7ba6083c9b98c89a56c8704dd9fecb41e2c33a7d920bad188186dd89e7a3528176590ea0219c389e127e43a303b849a2803b137ae3327c9edf71155d6bc64d9dc9a27ee51541f96728a08cab8a48361622ca9dbf6505ab59980df15b818372b5a8557480e483820b2e85119f68c9e8e3e6ef3c4936f15ace48726d914a5b05e222bf6579e93f5b211d82e0b0187c563fb1804b57c3ba08dee41f64c441b3041bb78d5356547e537571f3f5212346b7c080bf7b8e6442df29da463bac868e49409b2fbd8b92ba6da4fef97629ce6ffebfb406d6cd0847257cf68634c707200c0c5b9da43e5c0318353d1c82d5f28e744efc31a0b98d1f1a407220a2903388df2e3a4c3708b28d2d950cee491ad0cc4ae9bb6a381f1b62374ba66844eb62aa06fddf2c601167307d2b19d3a46b33da0529cbc090e4147a29274752ac0635a00ad5fe0577434d7d485ef65ae39975709d7bc22cb82cda07472859fd9a72588f27d30e9830ec346a365975fa48a2ec7ad73957a03433ca02e6a3749193dc09e218d2d9bda63f77aff84a107c1a19338c231458bdfa0050e93e494c3c2bcb25a81f31973e9c45d3e13ab4e7d3766397f3bdf87487e6b0217dea15dcd1a2c24853b05e5eae901c9da22cfd433061ca372c2a122dfb73d1a0d76f3b37e508a53404c8b10eb84601c61730fac8ce54f3f50b39678d7e46228b07eb135af9f6e6fb4df31c7361e45eb8760ef80f1dd981be8beb060fa538653a4dbed93c00ec9de0d4ab9c5120f12845289b684ec0a96a07a387054ddbf0bd2fe133f696493fa1d5f9121d6c0266707deaa9e262457f4ce441a2dc06edecbf74bfeb8bb1ca78ade13768a0a8929df9ffa617a81aca137560b38f51da3dfdb9bb7eb328e413dd42c53f11f85b8b83d931704e1d6d5d8796f66f12295a44c7fd88df774d46e4628a57bf2fb4b065234f46ca0367f2676fbcd478fae6f43708cd418a9a98606aa2d5a3e094a305e3c52f5611ce29a20d314a65e2937af4585691ae4e3daf92eff4d321e1db97a9ccb0d9c4fad6b52ebf56b83d8787cae053f26b09c543aef4efb884d295ca14da57c50a437d035f9937c559780e8f8493c881bf3b5d598681f2c940730546ec142a29e23a895c6af85a7b289a14a9a617323e4e9b07daf96585d97b6961791fa03bda04e3055482b214c7ddd20343e88e28c5e756b471b3c908de2ee43e4d282a66c16a6e96481187232fd6a7d5325a37fcd7d3eaf52aa4c7f7e6bf7084714d330241900416ef8ea41055f8193ebd0a4dd931c6bb2b485fe5e4872f43d2227d02f62c076d1ce70bb2d3b75987bd8824c5dfae9f2fb6ab634e01fc328d1ea6b544d4c321796d678bd38afb02c9949126a3839414202da19ff5b605c240cfa45e2fbcdcdaec4bdc51d338cb3951cedf1d84103ab22278d752ee9c0010897513b066a3ad3fc767faddf17a2bdf9a821e17c06a290c2894fb7414236a0c63a904ae23a35d3bba346b5d450397bc8186e343212faaadb5b768e1b756c86f21483d73dbe01738e302b8ea095b0435a4acff15b4e9e5ac454ece3ddb4923287229c914302e1973aef33762ca2a47e4c1c93e08e89a038d562bb7a6a33bc1cc8befb39c22570927c69d976c884bf346c930bf291427be665902d61c03b3a4fdb30f3dfac748c813a3f34fcd124a2e4887fd40af943df8e8e4827ada841c85b4b84b722978130b2d4fc9cd276e89845df5f8b11fa553dbd7d4f89d6c22656d490b6360d74ba921e2533d81cdca0db366c59779888e8601800cedb898edee72482b0eaa35f09befc548bb581db90dc95d31ef82185ac40638679acb15e9e07b9b7717b5d5f75020cb984aed0db1c810f74cd346c0c9fda37fcedf589ae9c5246cdbffdd1e0ca8150b9bcc7d0073b2e4308086761cc8848b4a50e68412131852514c5c0fa50787f300ee39936c8467d8afe00a50dfef8ac1efa5f4332a0716c0d1dde55c9df6d3562d359fe88e7c8ed244519e40a8b50830f96eea0691cabc40f645bd49c14b6319f32c1546ef272b84438a6d6083050184b59d4afbc83e02dbe2d4d9e3f88ec8f2e49ce5d9fb77d7d127e195b3e9f6470803be52db04999fb74eba0e9418421cc91b7845d4c7c82acb8e6a68a1a23456e37a6ffbd2533067e5f3d0256799307ae6da5024d2773521997f949f385b4d60a27d277bcd974e50980abe8589cc6722c07d11c77583bfc7598a21398eafd7d5bb4ab1b3ffc572edf732d5c4db650a68e24320506b767e46afa3ae09884dde2816c52836f71653b18e83f92143ff9226d7e9ca26e43df99045d2b57d9d0ba1a0f6d32acd6d9f80a3b9e2e7bdcfc078354b98ee9953c23d92247907127d816763a761a4db47f812aaeb37ab72a79b28efac09c4dec08ceab8e5e1351cde24f85bcfb23ceea2153ed56b7b6043afe388cc4982f7519a9b86c4af15b9da3114c53ea3070aa0b5867aa0662cf7d1f09c302be127c98d59454a69a4c5855b6dc7371fd96f860c84b53340bec4a0cb26cb845692183db2ff42ed1e58eb73577247bc73124e4d7df436e5d8e61c0b92d4a7bc309ba5bd22d32cf198b2556af3b792a643d8dcf9cef774b33a51e230a0f56580c4f2cfe555d8c37f2abeb3db78b8f29b19882f7204c5f7edbe65ae573c43479b6b9c8b2a4d7fa94a32d8a126db3b5e281a41c2fb3682ab8e3e753396233aee72da96db7ae9a80c2508f22dccd28ec7dff7d878a33d14b5ef41a436c00c22a92b61587af2a750b3e6f6b63eda238a691562c183564b0af46d5c2a59b50a1548c89c3b205f061c1b5d124df5c13feb9755c0e118420f35919ef6f80ed8ab4f13fc8b453718f33cf0e6e2fb4d20dea363e4f7f4806222302ec462e8d07d7d993be9c8ebd159c6e29bf03df7c0676b4123e253dc79b8b519008c384b3aae4224aa8e2acce53a8576c5fd3a7dedc1489f6961910dc1400cc2ed6ce9ecf8e62834179fa59a25a41e6c5bd33fd50268347e863fc38ab2cdbc4fb1a43af1d8d940d8846386cf54ecb33e84fcb62ff5c40c019cdcfae65027591ddb518b6007f7fcc2157da96a6fd75a12cc0140bc1ea5cd4f61d5d216d6e7e85c2c0bb2d46f35be9858cafb28789eee961b991ab263b8e555255f036d60526168b15a930a08d0c0373469daf5a8886197db15a6db1f079816294a5ef1147bd6a566402c09772e0087b88d377bd04a954dd58273b3ed95b03af375d272bfddae736ed11a3efc091171735d303230ee1232515ef76b62b6524db0d2a8b7f193766ced55fb1e1a2565b59b8fb0a96dff54275986ccef14e22e1dac8a84844e04d6847c587a6608dcecf067932813d1d6f7bd459456b7f3aa5f6cb48b9aaa169be7a57cfdda4dbd5eb67296226c124e96b4c2a18f80bf58a5ca2b1cc58096e5a2c382fbc6e004c839891b98c6786570355f8b5815f3e97aee5016fac3c244272480e2d39282de314afb82bcec18c97dc704c27c9772227be036e7514da8ac07b74f6e71481512542947cc8fef0a38ece99bbfe855a5f39ba259bdb3693f5c6cb84302294c5412e54aa08919698f4344d86dbeb01951bc79ae749799b4c942502f784b9c83b2146aa8b4f419118eca785e63bf985e3972c9cd3f62901156eecae23aba235c4c57c1f04df6fc791e198e7c644fa28d7bb46b2cd8ced5dba9396353bc640c7650252f93589c91fbe1b2b18f5a6983b7ccd99a44de04e9f2df5fbf9846d102d0d8739248654866ba46a28aeca84afab377e4cfd5e9eeda907c7be15b718c98d584dd67ee00d94b41fe43435621bab9dcde9e1611f83647d35d5e028bb34ba6a26bc5c69a25ad875d6e5286619d2edea366cd56c9b106cf26bab3f941774a6a7777a22499603db6ff187fd0a92ba318e24dac116f632376c8c08cca513a93192d5cdd4fb56ba91e13779afdb44a3740d4ad4670b2798b76aee06fe660bbb1a3254cfd55d800de765a29675d2bf20fb019f2d54ebd07c6fd8d843df862b8cbd19b8edb2523112f1a0c61bcf0adb0b8cc9b5654182191df0831a84fcd71f98fe715a7e40fe06800f5ed95ed8b5fa14a0a2edee91d182befe5c7bd2ae085440b2aa51427a7abd154d78f67a2493b3ebc834c3acc4ab2444e1dbada10290649e3b8b5757123af9950dcfd53e6a71b4107030474b5ad88abed09a3a82b3b5f26eba6a6d735f7d2fa7296f806f436b3b496b828fd94b684660c558c5a0212bbb284d920b3436a73f74497f59e37cf54321ec88f8c5a509bd868d96a032e1f346858b29f407124bee07b79b0506b5c67e7f6fb3b4dd53358432fdfefa55c7151dad5e52d5eafd398d3acc8a79fc7866e6f4908122c528d6a5ce7cb6841941c54f270db9c337248cb3a996dda4ca415de01720a6f9ac1844364d2066c2ac48ab516132a3d74d0112f723ea253bea4e4a1fe447481632120571a4e50fec0e233ebb5832541cd214ab0edbf996b447a93f7bdce8749e64ed3b440e01570f8646369144434c2b8b794623b33aa7145126d6aba578fed8499d6578cf1aabafe9cb7eb6a933e919989910d6eadc9dac3b93e62dc8477e97e70e5bf8bd8bfd2aa893140428f8becf4dfad44e98c7252dabb23bd238c3816f2bb6873ab91ba143762470140255f91f3982b3aa15df282f3d9ef4e12f15d01931d261cc4c6439559421210b8c7c60afa690bc56087fc55044ff16b2dcf266b8a1276a2c7604309ad7bec06bb1fecf287dd82f47053615c2a02557084e83dbd75f6a4ae3f9a3413d28ef7ebfcda6b85ca28bd75313d2324a08bd4c6daa65c6e0b03fe57a12798f60330c77aca84cc1f8e2b83809cd92e5243353cf86de72d30e077946e2d8d1af7208634a910b2a2ee4edb906b6af6c6648a3026786b1b1b509b2e55c35cfd51db7e659fc74203d4cc670b70866e5ee786d44a8d3e1fd8203c2bf6a0c7d638fc5249b6267e540c3b05580ac4e626ecfd51896ee73c18f1db2d298ccef68d2afe990a35ce623e6bc929ae6c6f2daadb13fe60403f05e5e1f401a74c578660782edc3e28407dc433ab633ead9b02591759dbcf050e7e5f3ae940198f8cc5caf93eafabb34dbb45e7933337227ff48ccdc5b62fc003c742f8ea5c978e399fadaae0fd5c1401a50a96dff140865bfca011db149468af3bc91f91bf1c49c351102753b12781c6560741c4d0a21b6c14abe3a9efdd3b65ae66b18863e558156bb48b087c34869ddac31445baa10e5bace0e47410d2e98f2201f337c842cd9514478192fe7218ce1dc685ccb0f8c3c082ad33054522106507d9f8a681657b31f7aac8c34861373b613c01ab921d886ba92583f980e308d29c9803fdacfd131529d3624598f95cdf037e378467108c8a112679ab58cd57cfa5c9d3d3167ebb5c11e661fac2d63a50e9c3be095df730042092b1ca21dfa5aeae889fa7a62dc593347bb8b433339ead22c784e52ec8ee85b0d66ce5ac03fde7a13c962f4fd353faeb5fbeedbf3c7e239a0e07d4afa4b02f2120db5f06c36982f76bb33443cf2451bb85e20292243e3683e93fa0a3279c2324aaf8ce44c1b31e2770fcad95846298535f03182a2efc90d1fda37061729ad88ef3af4de872b9c2f2ce057a90140df83fcce7d700600c8413346f9d408b3eff7c52b9af36efc0b5e9a4cee73bcbff70cadcf3b65a10ff5197027e246759863b7d8af3bc41a76608ccae0e6ef8017cfa5cfae9b07551954ae5b4ff64e34417447d73b57a65b772d7d6cdf121837953eda482edefda77d59c11d5c9479526ef6abb20e80bc8c32d1b091edc6c210ad26a0c223abdb0c9cf2555453681f237832ac8a5e17a0643de53e2d57074e2e41f8e8b1f4a94db7bb862bcba1a05e774491f05933d57f3098bfb006d221f4020c3c841e72a523d60779dea7d649da44b02b63ab5868bed0559f754a73f2330e8fa1aa7ef92b3b332cd1ee40f7bf0efa13dc97b2ff46f5bfe840dc23023e7fb51a65f730d75f05a9fa09db1a71f137cfefea2c01fa6afe86870a2398a3980b2a893d76966081f2ebee5d7bee24b4e5dfa92eac43b56d788e5481e9828bd56e9536822ab0f3914171a5fb8121418e220f738752896d1dc04112fd793aa39434d47209602c3459bf7dc0dd1592a32c1877e11922e9670afcb34af141a860c066ca98fd0d96c7e428f51f17f5e4ecba12f9d80ea5d1d1f640752a696d011b3c887273192466b7725602b00fb2c7c0dae9793efc708c4a69258c8bac340cc3e2a3f65a1546ad6ab688e025b2ce5329bb2f1c66944fff77e884af39c122e9edb4fd034901c8881d78d24c7f4c288383f3cf8a879ec3f797021a3210c1208b58b7d184fb6d6bd4db176e45189045c34c29c118a94244b1e3c27685acb1d4bad87b4756404729b1e416a6c2b5905f275b50e4d94aef3b4396628c431317346832eeb92c25240e96879afcd1696418b826d93f5782f3282b15c226faecaa0be4c7325dfcf62fed22d432b240fe3e9b7b709fe7997d87659fe06027861a9ac7dcc78af91cbebd4ae5fbbd094d79bbdfd673f081133730b16b1ba348d76b348636a96a51795fe57acbb8e42f9df51e328593f79f086a78c10a7dfc3d7fc6d42ba2f5d72461a7159fa55da763c08909c735a13a67b883aca60708c031808c6e7f333bbd074dfde5479d40edbe22356fd9da271804b8ebfbcd7666cd9dff92d38f3a98e47e3a0d78665aa4c7a4119e3334ac361712542871ef161b918fd07176aff3ca3df39a4b4a785757ece7d90a8a2bc2cdf7ec3cf337bac58fa37f133b3ef8aff558a325337974cc0d6da64ea53fe181a665f274c9bf755bb82fab56b23a5395103279e9b60d646c45144e6dbb2f6e2a184ba2ded3ca0679e2ad173c14c6dbfbe59f39ea1e0053c6e3fdd93d0f3d2b2a9dedb69dfea0020d497ff5f6e98b33856bbb00173c0c25430c87ba7f2a3ffa761558d14950d767d3db8b5c8fa38c5fabe056b55595fefdb9e6d032d3873fcf1da53c406f6a7fdd14065334346f7f7b44fc9cb56a93bd9eed6ce2fe43a37cce77b55627edd7291923930c9256a7854a0a8c2ea78a1eab8820666fc0454924bafd9e3200ebccd38222e38fa53fb6d3e8855271a9b41afbdacb33ac16bf29469a103b7ca5ef30ada81ccec4c3f68a39b1e9906f9d0bb6e7543323b104aff55b57cadf62b484ac047e76b84029cc77bfc8de80242d6c15d97ca8ecdfc310b2a1670a7bca450303b97d001309ce29862c09d6c05b327bd9ebb75ede31d8e00023448e6327330c531d15041a25ff09dd8c9b88594665ade3a7d0ce1c70bde46d14168f0acdd76d092bae266b7d7eee7f7e2edc6a0ac0cb3a03ab2cf60cbe940e91e7e86a1930515ce6a7a8b88aa3e16078f2d1f00bdbb397eb7d6bba4dbdc1f3357663ef51790bb99dc81bb8484f8fe4024c0d7b71b7fd250253b1b81b5981611e22ccb2d2afe08007ab8d62a6abde550ee1e1778f102fd77a1f563a6801375f07f0335d3b76f9bf4a8d7ce588c5a4c6578af4f88bc319093702ac4e6afea07734ba03c564d020a3452f6c1c22dbca3d2cad648c3251594682b522b5cfaa4627da54f34784c66c452e16963f7ed0a5e0448659bedf13b59e62d4dc948d78a580de438b547fda8a6dd20920699278e4fa48bca961c6f96c531aa78f525674f11ba61c258f44ba5b42368b9a9ec1df7b7de24e200319030c884ea3542e68ba39b9233bb4aa3d6594ef4f2083728f33f8206425efca80c40973e01ff259550e46ebc024dcd3491298a36173f7a3db341854ca8ab715668ca0513f8f067a024b2cf5416728196c06b50df6eef4cd9fbf28f29c28f91202ae37c25ec11bc84365b67ce27b9a985f35fa51485101c0d9511c66da3924f4952673b90ecbd812d8da19420f1bd51947f93493f8ce77b432539386091b63c74308ca2a808407f77e4c9aa6d60ad316c866afa6dc5bae8dbd32fcddbad234b6006985467fe43d61e1687ef2d9edfe17a2d4fb7c2afeb51a094d8edf6b79bb4aaaddf994eca62e06f855d1ee5fc61d0544a5c89b23c8f25341fe6fd52e705bcd23fcf165499e448b0174f963218a5b934ee4a476f804fae10f1d650464bede1ed91f4f4aa0bf08382119175e98d6d8c3a127723c9007cdd721553868766dfde69f05067bbafe97491c393b4dcea403031bbc3930b4f76571ab6c144edb360a79aeaa20b42e08227b7c24c15dd64360fe41555add4ac97be2f4bd89cc3cb0838385a8612be802f122e5c6e15eb1175d86c18ff79d03096b11e0affee9e6371f8256903c62cc37ba0c287bc52f20e4165b1c0ac440e4ca8031f220479200afe11541cf1ea1ecf4b25906d00e92d664c73f7b8ca424608e92e8a43b9a41314eac4383f3d33cd34494396718fe1de53b80cadc327226ab6ac11fa477cd994a4319ec3a989e604a1f4b18abeed09aa2bd1bcd3a8f566f26e30e96cc377238c26d752a86a55be17305b37d2bb96122bee6cd8f0a517625ff03200c4d6fa27c9be92d54a57a78a7a0160862c7ed69b2af731e2d6fc0da5b432d2caeec9571bd0d93c0117c24a980e5e4d2e2e020b097da3de86ae6dd2f4a4039f47d90127e82756c93e8d9d146c3b6f7f5513326b80ad074805914b9aed9252058be7dddfd0ed2c83c9e895841c8787afc142b059a293f79d1126d046b4bd3929979261e2f0fecafdabf198f45bdcf8d3133ac8041adbadd30e5a2818552e7a489e22dc8516407f64d9586327f37507a5ffd537d2c6ebbf5ac3ef0c91287ab44fe98f47f9cdd400e3fc7147c47530839e8393b786a713a2dab0cafdc3fd982c765f7e35ceeff9036bb9597e28dda4c66570106f03c0a12ceddcf0e806fa9dab3c25682ea9a411810f90e4c4bd488bdb4bc6b3c00cda5eb2d3640a37a9d22975eea7fba289269ece1a8477eee1a3d3b3ca894393116123f2799b3fd5ccfd26f244f686d0fc5599f62e19b6ecae02857c956cf7e32ab0b25a28043767b636f6c4ec2816e0318f07d4df5842fad81c84140f2253a84b3e6433714a5bed48d82b577ceb8c92c7d609b1d2a4babfb8f560713f15259d0ddd7324dd5eb86c10088d62d4e9c0a84695b5b0eb10f228a05f372fc109e4f3b8bbe6609ca3e30169330b3ab3e44027e9a48203bfa4d7a8647d26b378359794ed3b85c00d9d400d39b3abe2d2b2fb30831a580f18da723c2d409d55376603c9cd2958c562dfff80eef13c08b00d6407da14e68b22654627123703e1b82d5caccc642d8ea4261ac8d7acd76b02361381e1f1d0cb37d7d3b2c115e31cddab23c8ad225cb98309f4bbf3c377bc41f97a0d1cb00c8421d4d3e1de05d914cdfce97e3fb11802d67b703ad749a1c13ca8baf6f940db6f2c4397df1e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
