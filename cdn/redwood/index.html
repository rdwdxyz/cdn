<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95d4fcca090ebdbd8a005a8a5e82a5f231486975642c0fd6cf2ccc5b0030cddfd8a9991aae82dc684f4bd7ecfc75b29a07b9773c1c1f4524a0720193ca976494a50fc3f6edc4d7d89c9a150b823634a9d2f8247cc2078ba5042f94d3de6d60f9fd31d4b83a8ae938d9dfe482a70067c8a5325b81a2ec2116a369437ded63533e666f107a973beb320043d6eb83a866c7632429a4000f8092a451af3f15c7a99c201eb80b3bbcda1fcb6f3076fa68020e772be8046cceff100acc324e7d23b0c50dd08fa4618aae5c240454d90ab8d59a84c6275ce35b9b36df69378087211f71847a77ccbf3c0885fd81b872386d38e821a4cd2e5701b80e23bdd72963d18da9267cc9a47163a4c15b8b0f49aaee4de85fe5a54d0689a0a60b41b1e5525222a2809f899ecd3dd55ff00a2c73e86c218cef4d072dfe29d245119ce76c82f5ae15021a268adbe14bfaabb69666ee6cf09a53116280c6305811ddacecfe118c6796cee1054699b20585365c35a716e52532d4a8d4983243fb3bf7d5f023a3be724aac926e7b85f703a00379d56ec7d257f1d9b6d0627c47ed7090dfaa6701fb673874e23edc6b67e32eb7a01aba7f6b2e42b2986f209d2522090aa5f0112cc1804a634e7235b9db3f829e62446e42a88a25a247440b16cbb58ad6fc4d57680bf67cd10672b7d26e8fe08db7d8c3bfe990114e4acb09217cdb9caa4d0b63fea912114863055d6c94a16758addaf14a53da4ff0eade43e409484531ff7401f30bbe9b214f06c0d0ff45cbaeaa503c8bc86dea1cf80975509b7aee64a18efc59f254b5bbdc0079e5367eec848eaa09ddfbb4c716e6a03a19e52ed16da91359eae267d74f4983ab1782e25d857515ec581165c43048240ba7f08fb5408f52fe4b780dccb4f984621dd69ded8e84d286f4534b201d31601a2b5560f76aff8e0aeef1912c84584b6d84754676d57c72492c25954a392ee7408adae37426d4b447352dbb8e6d5fe5ac429acee6b99aeb791bd2db928ca23c0dece7634913d9ca2726ba292265f2c642a941ef46f305368acf33c10408933dade5ce7dc893e5be4875a67228ea56f8feba5289f660834d8ce9d1ad9a3e12a3b937f14ac5058a02219632e3c601a781f10c42230bd7e0ca309a0e4e555b721d11ff424ee17747a1fafb409812359f70c4131feef0d74156a066eb563ebaac2f1784ea8976dd1e516c3d06cb1b5f8435938faefdd22d627c1edeaa2dedc5fb2a272624be94c529f70fd2cd25b0b5b33f3d3ace8c41d645915fef53c74bc0bac5ec4550322e56bddae8dea7822ca6c403f32b69a733c3b3e4c2e2ae51abb707b9d54f5b812789f3a9918bcf7d239e6674e717ba2caa38ffb6020657ea42c715ef9f6174aea21a7ddb9dfde9ccce78fc242d824f0ac34f9da215affb9ad9859eac40b968c51d6d18552c84b6b13ab77925e2dbc73bd690f10e902fa1206066a6eee4ed2cb103ff4b61d906fcaeeb5f8211ee8a099e7c9872668da0b6206466fedbf0faf1ea0c66ff36fd66027b696feaf0f8f22d3c7f2e467e24268c4c1ce45097b6284b08bfa973c792848273e72bf4db21ea655a1d202155b4c2d699df833c5f16befa2f7b5f9cfa6e2a576312b5a6998d08717e1194ff711afd8f39c580995ba0fb49c7d3197c87e983398db06dc9fa7304e753aacf08a50d62fb409f5433ab82003e93a0d7c5fe5cd3311bda0c32193b1cab9e65414610f5cfe034e5e5610b8a2e45490445298469b3b361191e4a952b783f4c5ef5cec1ed993dd6a70a932214d1f1461e67392316083edd2b124f119f8e85a4467d063a10a4f6c0299f383856a0d082d2a2259ba77c76d4b36a9386f0d81ec0aea521d04120a9c82763f52df420acef6365acba81337ef1d723b88fa3694d229a1980a845a3dbe6542b3969c8083f69faa8f4ca176cca4d3cb11f55c9915a6c13f1ae85ddd3e304230510825f91bfb11753a56f70871f0a23e2fdce6a8a64688f4e419a57faa045ac841fc9fc034263181fb5f57ddbcc0483e5f458ae99b6d4c5485d9a92104ad2dcdd317cdb145465862f29df233010407247fa47f1f1aa8750ae779060968662891975d17450ec1d4ee8833bb88d464e9fe46d3fe3142edacf207cd994376bc1193961df753917c6ea8840afe9a55485ba34b87da5372a722b46c5a63c503550ea717c6fc352db91a523be7b6ad19b046b1b89829e6f6c2f22a1c555e510aad5d467bfcca2679cc04312fef887410a819f6ec5376312a6976ad661d81187a0283aa9bad705b152309d2655a48de7e243986d23b57410bd767290c8a6a1959b0cd78eb3b506d7dd7cf90a767823da0b0ede553171005542562ac6222099708d536961b5a102b93e13f419c8224e3dcd90c4b1c08f8929eb6609b8c1a04633beb19372c29738d4736fa38c1308ea9ab2879df664598be98ac6e889b2f3241ea9bd297574ab0f5737e765b2a3c0450fc0c1f53e3da8fcf4ad74209c2d49fd46dd66780ab636235f68cb6d6e9ee616452fade8475d45422aea5a95442f64d0111c425a885982b24937a42bc88073b22c38854679dff85ce59c05a68ff26d5990122c318bf6eb97e4b4871ff1634fc9eb90b33982aeed203c220d153912d04676cce06f9cc1230818630afbeac4955e7bc6dffded95d80f5c6f9306008d4bf5016cac62601812899cd732357d86c1c20743479085ffb50c0ad063b071e31df2e35a562a6b3f02d41a933a029cdc5117bef1a5b320488038cccf490ba3178f93e32e3311ac174fedf4618112bf98039554a042056e6fadcaea2de858449572e786872d4757e83e71e470da23fe116b686cd77268987dde5fc30f8946cfa4fa8eeb6597c0fc25d726ee259cd39c8ae48ea4cdbe23fe612186fd28653d790192f84d64c42cbe84df8691b5f53e568e4ad0c1e45fd41c0c51e529ce6543235f10ef06c2d207288fdaf7e1314389547cfbfb343f167f668ed8263151861691068f515bd969d1f36f27bcbb2301512958a6a49f9672e51e8359e381e96df53670c4fac76e1ca6e463fc85747879cc5339b3edc3c2a98492d9e7b958a07f9a134f788243f279b589fa85e82825cd63eb10309556166f192ed60c15604c91835efa0599a87052d9698b1bb95add6bea594f63f8301bcbe9e11af4220b8b24ce1f6529b2f5e9b8e619ecaeacada66d2694d00062506c9141b2f4b93b1e31d511844a4e407ea22e16711ca7859279ff929d3f0c6a09effbddf4a3e749a7b5d3969d2a1a969502c7365dd4e77c7b6dfa4bec8a5e49f8d64206ea8323fc4dc61892c594e172d17fcdfd0bf74f54b283955cd796377a85a32ced7bb34517dc829220fd2748c6860e45fb7178d92b29fa5b5e6208475190b1893a3b7dce8807a54c43d2db9e76fa2dfb03b01844ef570b198ded94f9817afcf11417d4531d720523e6e91649dc009b71e2b5524c2721b6621eae7bc25f72e2999899457e7a33e6c44d3ab954f7e4fa0bdd1620265f6821418db069e3cfb15c2d091235c04f268625d00f58fac2a13a199c6de4c19d0a33a0e3253b2206b508a57aa2a591c0340eef4b198ada996d925e946536e20e618ac1b76d3c39a8cd5a2463db8c38b102bda84af03e7af2da73d47439abcff592d4b8d65df1c85837c990307a250be34eaa48c328fa54a20d711dc146b15f32c89d05ee6c8fed5264d3947ff64ccb386c148e9afb3c2819e98b5d58c70184dbde878007c1df39cf68f103d978d7c0f77552cb2a8f26acd7460972f882362f68ee105390480194223ec04ba692f31461eb7eb14e081c8681b1f99f797928078e13228f6da9306cc5263ce969dac3441a6aa716558416fd5dab51e150ae3fedf01dfe832fc906533d98836edaa1ba4748faab0ecb7d18ed0245accd76f20ded9e3f9185571333c1e268612f822274c7e83073df7ba2495cad0527f8c82ea57d354769bd289668a3ec6243bad171d0c0b694e1ede5b2d9de377b58b02d5160e1965296aac3e6c5aa918425727df0b5563edf8e2db9be42df4b527fa3d477718c2e3031996ae504ba3c7c5cf419f265052c640a4cf56c30d793d041d8f54d7626ca7baf2e494aeff07ed148ac13ca2cafb6797a210db220491322ca63ef35c6994810709cd915d9b1c03cfe69e23620424d6eab29c1e1c953d10f4d221cf4575e36f0a4f80b1806565a0cdec1720e974e46f9ae1a4b676f4c047aed456976594aa64aa76c353895453691789d0c4b1103f991f480d7c0927f5f3e2edbddf015fc24b527d4eb3ce0643340cae926206c17078bd0b77bfb55b389feb0b325aadf2837f4047a1fb3972cf81cce7876a64657b53fd2362bd0016817a0c22f50309dd3d807cbf3d882ac50ae771965f081237ea491ccd3e9f05d071844479d2cb8cd36b1755ee74fc693ef560c367a49aeb12f56cdb01ae61c359316996c7c85b4a56a15b3eb9a126d9c7f24508041ff40d6125262f64ccc87037012a0c99b1e0bf51f417c597a36ec5927b9dd3303daaba84d233bdeef4eefd31f910f883a7c18c5ac5dc93477271e17becfb1b6060bcba98e98589ed14936e58657600d11d5f0ec8117e4fb607af9346f4cce3a4db2610de6dac4a897188eed128e450c9e6693a39e8cbad43de8e2618e0ad13cb5017e58ea0ed4c46550e7ec9af616b3ee8951c02cd65d73d32b0828d86f1f8621a4ab4fe92c5fa307ad78086cd5948f30864e1b04b7e063e0f4bd05e9273a3d1ce096089a2785910916f9bd90aba9703c63318907cee34a0572c77d05ae4ea642867d35f8d31d7b977aa80cf90ace3ad6e571c7dfb5ed57294f1169f1691c02a4f25201169c164d1d463ee3ab30987a8de76b89c1b9da0dcc113d7acfa6d15d793e443f9a6380b138c6549674e31a140241e7d98e4cc68728ff360da410f0e345c46126b1a2a5cfd1d1d702093b088ebc177a4c2f559feeabf7a66f5a4e9c5835ef2bf94e9cb7eeea61a62e98daadb4a426873a515aac0b5b4253acc97df8ed14c32c510cf23333e6087d965cce0301f69d5534af44e551c9bb967d9da9e90f9e033f31d3e309739308874baeb34597d22de53ea3196c22badfe497375aac6df9936e8e4e2adac8002c3e909412998378c02d37df6fbbd763a102e8036e7504c5ce9e7352aa1c3d25e68dcb37344cfea11647c54e1ecfac59b4b134d01e79cafcd25a919b08e0d1be01ae00cddfb4f9904d3922dab07fe05cab048e2848cd9e47b802473127e1cc4c81eb0866d591d5e70f98290aef5c31d4b225f5602c70a95e474b7530b5e7223540f8be14469ce31b72d94b3e2b63c2ebefd6013477ec83b66372eb3ede0d99ebea1f500e3d18160571a37c7e2974cc1b4c6f7c16a6e815bb164f727c96f0dd515b0e19a4687d85673dc4fbfb7c5e4f20c64da7353b7574db9bce618da8ccec068ed5dce9a4ce0710a389519f998e487088bfb79c5d414169dee6d65cce38677ddd679ba2df3d0e57ac090a1100034bcf23e0dcf90dab1b95eda0e3a79a9927679dfaf4279d9af219749e94fd0c367d56740a7860f7b927acb5875c6ae06feff187bb7403694f5a0be94655e90c446d7d93139c2a178e9c0a24269387a834779fecfc25dab53b12e211d0fb534a13be1f4038a052804da3a8d5f1ed5a971c3ebe3bf3ac0a1f438726b80e3ed272770a0edc576464c4af61d35d601336cbe5ace3ecae4df01cb0bb1d1a12a24eb273decaa79ddd3e689894f5b3f35d0d198fe3cadd8eb71ec40cbf249dfde40f4ee31e5722e07d4e3f350850d8f2a339e22edbe9c38db8e039219d59ac1b091b9cc8ea49a3d9faab36dbc4ea06a30ce21bab2bd39f92e91d72a7867714a31cfadf2fe9f640b38e0f5242e29f88718ee6dc17f02ae3ca2360ed2b71bf150dc722f06da0448a52b9d3a5c045fbe05da171128b0e45f5fb2b19bdf5e5346a90fb4ef2d07965ba2ba13b21bc7bd1235d27529b64543208aa1a09fc166407c53ea9d09bec0861be71e5627885ea447df71ba45e1c4c542f3af2a3a2f1c66159edc527c252ffe1feaca73fe42f13e9256bba8eb120c2c645e05250b4b953a7bfa760b3d5fdb2318def997d252fb1738cdba333739ccc9ff769f30ad13aae2d01f300676ccfbfe2537717a94682d457d5f460929428ceae4bce4ebb0c71e2849199df9aebb2eb8334f76014f87c1eb63a52eb85eb099792c3fde50d71833aa4a2540bdd9166904f4c44c04a776252dc3a15ade3be163c8e6eda593d61981bd18ad29efc5f08ebdfd91554bfa242e28f92822d892a91e73bfd6691751d3c02e6075ff856c7ec6e234c647f824093b6dfb8a35324863b661bd61156b81eb077c7202ab1b59e9f7b26b43a9e6835c200de6b7cab14e1a53f8cf99b2451f85f54f45a39f7c36af5db909a8a45bcc390cbaca46192f56cd1ac785b779597d8be3c9b78683bc746ba1615defe575277ba536cd6c4007fc431e2c6564a0e4a167974d97f16416841234b8a5f246762272acdbf80436f5ac80a170f05d78414d1da5bd6a120eab50cb95281eff8843ba7059d90fb06d2abbb440635314e423e7b29baddd5ad6946e0f2d13a5e5c34169279b443e831c4c18afa027b9b3ce22038291666b32c2c5f4201211859c70b422d776d5016e3163f532717f501269710a810e3e2439744226365cafe63408a60c8c738081daa3c996362252fe326244413d3c2249feb0bc370c2515d5c34b810c7ddbf3c5941159526d9410933093503c1eb0d0d0bd15341aabe1297a91e9192a00f67eaaacb04b458b521369575ff1ab564f081258706d902a1733e11f5448f8933b263a2935df764108e80cda8c62ca45c2870a33cc958079cc5e37597b2dedd482604ef78f3e2ca73e00a76fd9feb979f6059e6e9cb02b74e686a325fa185d866953641c3c6f2623f342258d67adf25c296a90d997021bb7141d6d13def8080a95f6cf73a0600da809f8e6765b217f2b3c525959e486709e951ce6b762141e8295066070b0b698fe7a4603ea6da387c093f7d8738032b943c1c1d107f24b4e0ef268f36808f3e83433de2fcb82c778a51f27d7f6b70c3a2974120515ab4f3a495597fd3af768eb4e04405211ec2988b6b6634100782df74b9efaacb42b733d7e4f4c8837004b3323c25bf25583adc0743dbca0a82830a2b690f6e9ed55c1bedaec5d50e21707f86388af9d95e8f993ce5bcb346962b14e82a9573b16060787b1260a0ff98bf9fd8103cdb9169743a1aa7dcbf9c3d837bab989bb00c447339ed7daa8706330f5216738518c027490f841f102b3880235fdbb2865fd50cbf74a47f1edcced8114bdcbaaf0ac7f8ea87de02076e96395928db1b2cb0c6257ed051572bcd31fce6663a5b88a4ddeb317bc6baa0f99cad3005d96a4eb335ddbf52fc406e7ebb99cb487c68eafb87a1d0407b1f3dbd2adda81f98635eaa9938c5d13d368cc24ee741e0cf0a3b392027e44495f83328f97069afc6759cfce4efe3ece77c4554bddc5e64635858555f25e1f977b2bce738ee2c7deea4cd1981409c96b55b1366ba804f161b890d0275e2c25a871175deeec8ca9e05f5f8e6bc1277211a96ced7495a7e644f489ac682376b021c0ddc5124222bd97b7cc34f28d783d0b91d337be9ddeab1423706217807e911bad7f8849d169b0bc9849beb79627cf1a5378ad4f1d51ef1d1a68aec7b1082a8d3f31e28e2002ac3c69e3be63efad7b044a2dd241553797d1c3f9224be6218438d2ee177796722da7be5440ddeee892339ace8be1626a4379a2296726075296bc452571c2a197ac396ca661a61832666bec842d92f9d60faf02630fcc6651de04d1b1c2fbe18aa9f799cfb31b9ed25e1e1e2eab16918ca25262218da2c75fdd716c0f3d7c2c88bdb31427fcf1523061e1419128367a355da45eae8668e8613bcb46291f9dcc3a615f743efb1286bacafe490257056f64a133619334ff6dba945210da546c4710a103dfd969a8e8d42c8b3c297a19dbb3d7a9de451b9bbb3a553329cdd1e4ee500d86633532bae9b20e4d5060e97e712d436ee06b0eeda9240f8bc65be6ce6f2818884acab3634011897eaccfbad66811f2d3bedc54cc5ae5715e204ea2832395a71895dc4335cd753c41b58e00eaa7d80f787e963d49673936c76d38d9d62de2125317514d8987f9f578d1024ffb2e80ff9d9ad0848cec9ba6597d75c7e72bc66846fa5a03f794b52a6b9dd43c78adad0f3e061cbaf2ad20aa5567224892961fe1a6f54c49f865753985443085e3a4b7c54e116d9a3972ba3a5db15784b5c079a1c0c0db076f8f92ba7097bc813a24db826c76a6cca2819ffb101e5eb009b37beea58c973ed7e6a7bee84e964c97bdb34bdb393e5a1ee1fdab5da4e193bdda2c97af541d15c06ef98ff34ddbc4e6fd02e09873ef269e67cce56f5f17f29056d30f1a9f30bd7bb9ccebc9d957b545e3cbf2a2eafd7ef2bc989441196ed597ac838e795866878082b42b4ee2c63ee3aa53691dd73cfeb3131ed32e40e8508882f019c96a6c69fa78c8f6a4f63bd09bea557f08fd6de495c035ff221541b8b6e3f66272b059d20cf2e0e3fec24e5b58965390c258f1ef27e1fa954e7bacb2796fe0ab765f71e912b915dc88dcc9ec70dc3157dc295c706db38de5c8b03339c1e9e2085dc821d948ce3ee68ff9046efa3c02c250c7adce654ad6523c2de3b882a9b307782a9f699d8ae027b83a8d701b04a5bf6e77a79211d8720ee8ae3f8f8a75f31fe84deb199437d3480a2a79d02e16777b428c06eb5d89f656b21644afd5ca69c2734bb1f1e76f05f4b0c1bb1e4dd6202e38b6ba2504bf72dd20766cc8748db3ac09c3e052308f51c3653d45700d5bf9b653e827fe73528706a4a52dedb4b1db3fd274b45791d280a2326cdd3056e0c847c9fad4c891f1a6fa17e74c91c5b055fdffc33604eadb97b0ff5744fadb1ee58c5713c8d3a65bf19b3239b6b025f6b2a1fca3cb67baca59b72b9df86899f2647fd3d54117dd1b0db519ee7dc2b481c44795deeba7949588343fb81419bfa1c6931122140d4f2dbc464ef00224bd16500d8b7c4c3df2c286a9248be5dc1c6964c5441a28f1ac76efbd4c1976db333b6b49b1d5c8423b80e114dd08a3bc0854bd5bb05760a9c20435855e0bb0ce4b468380b2334d6f7bc3f861740294583d12765e4b77b83e0ac4cd0d00c35211ee2311fa30cde588a1bdac33a26b1c959e4c8d0c308f25fffc850b72c7a5c79637a4cc3610da7992544a6c59cf93d7b2672f5ff36b611ba7dcb21e099bce3f44cb15fdf1c7c8f3e831007af1c8bac3d5a029b4ab2a45bfd5bb00b31c9bb5cb5b3a50591ffb0a7d6e2ee232200339350d4616280bab79df91850977c038b87b963439a38f39d49ee72fe519663ab4091211d0527b1d8cfe21d0e082ee9c678fbef33ffeb43d40e831af410708b43f00dbda6e45126ccaa080ab4827f8821180eacb7c65725d2bba32923666eb501ee8cdd7b8be7332d9bc23e58bab9b3c2a908e837da448eda18453c5e7cc74f7a5d75da24efeebba3d864fb2bbde26af59c2b9c328428db0ca9dad973e3b241ca2f9497d48bf9d1af2fd7c310e9664d975306a7fd0b5927364cace811604f7da441d8bcaf1aed4108fed971582c0edf77887a81017f6f7f1c921a7b2ffa9968b7d868a70b5126aa3a2180b3303c168137b64f685aab94747d8f8b2eeea54ddabcccc1f1c31e0d353f3dc8f9e8acd04421886048056e1963799938016c54d893a8a9b312cf27420b09d7290bd904ca19431deea49394ee3e84457a41ebd16bb85a40a0dfb9716ec72bac811127b5c8f4eaca74f83ec19ac10031b08f20e3b470f2f17e6e9c4cafcf180e32e870d1d8bf5a237aa39a7afd0fc05efde39b0c9c40be398a787151136cdcebd09ec5d7fd6ba2089d7cbd7c1cddffa88293b0d4b479c6075c712bf3ef51dea515eebe48d4be52f12fed42139e4155e48c97c8d4e6a6e311dbd3e5b94b946838bb44ef2b89ca994b3dab26b1e923c3fea02357f2854b27b42ce2264125395f0480690c76c4db536b581981cfa4226f48ac299283a70eb2731d87daba0b276a272be729c1f5cb9a24984408edb4af6c779a2294d3205596b465f5c4c9e5cb8b8b3747ddab9eb19e7dcf646f9b9d77fa45eb9a793a2b645b4c80063eef15785cc5ea760f7fe14356471c345e86eca468548b35ce8aafa9e257d8dda191863ddef610dac1312fdc553a184fc8b29d7d785b281f2edb50957ef22f4ff8063746c88bea6a31cec4a09c3f969c7c571e0b64d70090d54a98038f7b1afc4789dbabe45b6b249f97d85234d9ed4450382cd42592eb9218928b48bfddd83df215c778011ee4ba3418aee1b32a7ec4715115c50f518758a298cdb2bd8eba4b66a946315180437458608264aa9baaeccbadc1af9aa6f3b4b450a2098eba27eb28ee59c8c2115bd816c7131341f5f00ef9c82dbd0061bb8c52121cce85400cb91af4397f77cdf0df802269a9af82d9ce2e74ece8351e8d680748782329f31ed1d13f75c413c2a1ce9f6f359c7fb97908f063bd308a8deb12be953df1a5b380065aea15b60ae272abc228386a66ab9834922d88ab26754b70f9b56e2f3bf1523f901e12e5ee94b124fe8cab44922c9ae18d78ddd6e7f069cb5f37790375ec5790f7eaf601f2548810cf03207a4b9b5781911863e6a3bc0daa8cd6ba7d504f721a950f23e6b84a57a62b52d52bb9993ef6bb210708fd62ddc9bb437cf6166ee43bd5075be37c4bf8d8f29152cf433ad7d1e6baee9c8b51c1cbeb26bf1f44453ecb5661352ba9c45fad82e70b7918b8ab9310ef7765e19873f6ae2488cc057885d278b1265a08296f83b2a432da94a3ed5218e9bc698295eb92161e235b5bd288755bdaf06027d149ffca3512bd5d4d456c78646a1bb4835d2d9192098a4b813c65d725244fbbd7464d63f04987d39ccca474a22f228f3c74d06eedf62bdcdebc32e638563c5fd699eec7d902f364725282d405b971a5a1778c124d92b62491aed0404bbb19daa8631c64aa6bb8019fa8182bad4c37007360432d2f69f93dd5d37217d7325da687d310421f15019683c8a19b3ea132bbe9e55f15937dc48e56b548bf258287718e741df8f652e87a39573e2d71b5a9dbd702a0aadf3e33ad90d7b96174acf1010997fa60aaeaa0839783b090a37785a16b0d368983fdf6416b4a314705a4829346474470fa73668318fc8a69231a5079ac0e5666c9b6348417d1dd9c093c3542969219760eaafef14cf22664c7d8c455907041e09778cb8e87f4a6bfa70222cdfecb55d9a3a3788911fdb627f294c9b24fee62978732abbb68eaa46f5775083ee15851d199b51527650b1a6b7439bcb0a4b4a4f1352099a0f6fc83b153f77b5bc65000f8c5bd9f91317f40efad23c5a5b97b67db7d3f87cd4909fe7bf7600c951fdbe9c593d8a3a57ffe6c8ea0f5e6a37c272fbcafe314e031f24dc2ee244bfbdf73c8622c6d7c353ba82b79331e1301cc7292d8914e34fc3c29785331508883ed2eaa9ee71182e96b418d0272027347b4ea2e77cf2c2847b3bbb428295a738d075977a3cb66c9bdf8ac3c3fa298ffc5eebaced0e2cae70b43250712c4c3760c891823280a087452ee7445a3644662a9253cc079b6eba972517c6d96a5d8aecb35533df34fbdb9be55c7d35b9c395253553062155dc681debb64ba582df36b2a396b8f3cbbd82ba7988af7f9a30783aba461902678bdfbcac89b1ba43682f8c00a6eb82a376658772d9981fb896f82206e2a69230ca5a8d05b6eeff7751b0df802adb9d505f751dda9be035a0d5c2e05a2a723ba323bd12a6193b1495aab69604e90c1e3a6aabf458d7d4c98165b9d88c2b5c09503d03f51aee04b9e1abab95ef06b52166817c1869f77d881347f0051616469974b73f86665f9b21571fbdbbaf9870e053f85ad6e7c9dc962c7eceefa719bc9001a7694c066b689d0c383506455a68b86111962e9e2ec1d6f832fcab9959a31fce9271836a9d0a6d9bb883b00c99256e131da958eff00e9bab0f6547560ecc362aff296613f1072edde2a62f92c2c96d30436d837e3393b38fe63eedc8fac9d93b4b0f0073988ccf488ad782c9026c120cebe2b5e9f64bc95999d7c21b7412773e890d96ee6ef4cbe44fc6c55b708982e3bc13492ee1f8ff4fe606138c676d5459843d74ed32129c30922d87be11489685109af27807e469e439fdf5570afd5a6c6dc2783dd9c3dfee0b573ed04e1d54f31d882b1ee43b92dd8b06308da3a35bdfe041ce04c02f1f31b6dce78a79f79c3f951f75d73a4031d0ccd5e5a5be2b014d61449156545e57c233ba83a5be8ca88a91798922aee60c6df2a5bb4a3e0b870c96901c0dbcbee996b8118185f7b594f33db51b3a36caf0e55e585975f60c88e043c1844c52c8f8f8aece55833416f6b5e00c037afdb2a0e83108b0f12c0131dabf4ef62aab07beb65922a61e481da3ba86bcc476ba596352431785a2ff0e30b455ddb1e5b275826cb1358d5dc3ba40e68d6b7efed856bdb20e0328a1e6a5adbcf7abf5eee38c707e32973ab20c81ba852a146f44d6ffdc741d7eb6523896989e1cb6c5c37ff3c88f62eb04efcfbb3c6c6573c3cafd98429a606d0e322b9ddb5bbbe6de16e72ba4aec3b67af2295b44c04810da539cdc7b1d00d4a805ac3e08f992292eabb14f4f8c98ce45c74968f8d80d1bd1b65c7b8915d6628be90210bc4d6716da7673f7071aeedcd2d8d243ae87e9fec376491af6147f58f5c7cd623db28dc69d734a38fe9946fcfbb889707c1f3687c5a4398a07598d4695b04beb8c94a4317be5a626c77b332c0b2caf872fc86d59d9f3467d1e92b51aacdf3db3248a2a1ebe5cdd7e40ade3643f833de3eb7c610713a7ce94db593b1d06a930c06a47f37f476eee6174d557debee3cf195eff55d6b4f095304befc2b5b24830e81e48eb83af20eb8ac56c5636a390860098591b97958f78c4e801c89cecc6d83b32a322d9669e2e88f6138ef689896bef89e45c69d35261f714d98d859872e9f7f242938d2b391341e9d12967ea0904a3eae5b09d8ea6a089a97cbd2743511e01aee7b9a435e3860f7c156dc72ff0292daffb7bc836880ea940ec71887fb35a85ab596dc1a86191c347cff2e6a5a5677b66a40bbe76add0bb70cc50c9b8d871c8862d0570ea1efaf1cd833d5a4cfcb3a260e225d2bb3e9e89e978a9e96b27c5c1c1e5ae922e25cf665690ff90212dd19bc326f773199ff25d1a793cfde8f7fe10e7cf30b1a49183ecd60cc6c5ef74164a54c47da6ec1350c56b0dc2f70babc790c2d25b797f4e41b2ec1b4c4eb9e3a1dc0d737cabefa93f634c89277cdfcf3601bc7d0a009d8907862fd1555ef1f1fe4becb6a9fe8c294d56ef908d51d658675751e370f7dcb70f43779fc033b49a8b9ef7ef0c1a081740a38ebadf72d9e4dc62a79ed43f7afdd1d813d381a66be7e901e9df8aa5b981c658ed6a450404d90601330b0ba258fd06c57771fe3608d1f29e36fd5e522626a743dc66df7f0f0949c57a4a1f04977fef17b165ea936f2f1c6261127a3c5fefc268acb9433204c5b0a2f4031f5142aed7f31b9546312faa2803ac5bd13ffbbd4af6d190f5870dd05ab2bca6f66c7a13beabcac10b478332422cf38016309c717a721bc64c7b4371292e55a17352a2964f63cbcc80bd99967998acfbd8586f32954c2472379e721f45934b4c195a48bb352cf55ecefa6fcdfd992937856855048442331f0f0371f39225490640df86043dc1e48af5f675a49d6d62d5f0b8dd0c3f211fbe57950408f50bfbc3c2cb2e8d53ca3f2a8869fb3b886005371548834b66bc21b3c302139c3fc661fd28f16cf1f0ba8de8a292d7ed5ad20032ec764acc26a88e04988bc9c9807f6709442a08baa939ad2a32e8ffe2104636ae52421bb33a852e442e5b7b090bbb06885535935744c200e2e3ac778e008a734df529c6b101f83e2753d1b2919b38ba4d70fd0cab81405a947c4683a8e8769017ac333c873af06728c30c3e0badd7f47ae3df006b658181cc89a7f438a94179f1496c5675b6101b222ccfd3933ea1ae79db553c366509fbcfcbf97a3e10ad13b9961e28dcba47790cc449aa047d38020cd133bf6240454fd8b505cacd39ca295f762cc9ec24f7b506e1b4b4354672f28261b42048bbf5100ce9d74e74feaabeee44bb1be3ed274c625a5c42c35189c4f0e4e8443c52c0cdc5d3604aff87672562d274899e9812810d59cb18f8aff1968cccbd5d7f76cd357769a583575103c44daeb46d6c3277fa8992013649cfe900c9959ccde4e6452bedf974231b3899c538793938c082fb4bd041020fea4f01aa4219a59784da048172750db00d4689958b08762d3d71854d1b917ad68eee8262d3adc6aeb4f5419baa97988b5492f4061979c62bbe6c145cb9eef1aef1e256eb45875191a35bf85140e27851425e58800910af1ba6edf385198b278c55148cb4f4ca484fd9f2f844204c3bacc67e3e5218c158ae1231431b2c2a060efe0228a4250d46e4a284858089d4f3c54d899a50e2f99fcbe163a36ba122be609c6493fa47b94c78ffb53e6a2bad5bf71f08870e82f6437c27a27cd5a45cb5074979c2da4dc2df602fe5acf15a0d21cc38e00fafd8019818a494c538180aa3c7db7916ecacd7ed812f7cc0264fc060617dff80902759c42790652e14208382df12455bd2274f87bce8560172fc778dd84b916484364c10296545377fff81c84704a16d2596b007c5a6f4ee6dca790262ef6d3dd858800f9591b9a23afd112d07bd4db3c2479feffb1e243dd855266c402549c976748558ef560eb302e135fe17b918a20d5954846f04f7be285a10fb65d547c0c6bc30a11ac4bafd5fb9e338452930fc05621983b0c842f276f246d3c1f33cb46b9d10ba0f43b0eebd25d41cb11052e7521a5b014b69f19db66c6f3c2bbb127f5c551c16b05318035e7738cf15afb6f703f22f4f2af1b4d2930cd4cde207c1a547669e0fdce085202d5cfb43ad5b164f0af96939ff57ae491518b93e16608d99700f7010a3cd6d3875bd3040d5819c7381c7243e51430753425c4378872ccb89432b994f845e52e4fe5cb6a7381e1329d3620353f9ac9abff826ccbe1f372ff10aae0b2ced42d20653030af39977df9fa157404b2e929f4be885a7edd7be0c4ebaabccf4c7a854ac7c67ce94908702149e4e2612a81d4887a839004e5a3123f8cb4588d70349d142660bd4082f8604eb89967a5ddd4a1a4b09a283965b4fbd2e14d96ac5aad46ca293322b2032d46ad5d41374555b728e8ed3fa71690fa604aa801a2a23bec982b9859f6988183903cfbaebbc011ef15ef228a05c05512bc51abf54a732979d810d377ad559e4a5d9bdc1a8f7b6e2028a44f65c07d1593e9a3081cdd46e66bc9319e2698d329af789f150c7f51d761d630128da6441090a5594dbe63034bef3035f1535071b11d129690ed2532ac0063e1ddce276c1df36c6572a3c0af78d52abf820dde8c9ac0daca9d8ce8e93d914e0ce52036a0e5a114a48bc9311f2bae185b62ed04d222821eeffea0beccab32e091244657e9cdabbd46c6cf8dd054241ab7334dec43ec52f29c0120ebd1e14901eff87b69879ad9e18a89240aee867e9f129d9973788206b77c46ef6504bb738dc3bfc92a83952aee7d6fca9101998b99c50780fa0dc0b85348c4c54a4286b18c5a62e8f2efa91f8b2021869e949b9db47c84afb62e846d51750d75331a73f2df0d580cf0afd881775c31db6ed144705c3fd3a5e4bceafee7902f8b6d4192248f9e1eb7e5407219fa25c11fa3415ca45910e4c920368f4123d3145db21eef5a77e949298347aab92a07ca0f5f31ba8a99a3233257aece1bd4b7b0c8c022c4a96bee243d1714dc966b1740b62984943c8c64de6ea6899723b4999fe92fe159c5816a73fc6337a4d250911b9154448fb2cabc319042969667ba9068393a818af6588efcaa0c38e1eb38855ff4a7e555eabbf370f7550a3628309485befa5aeeb146accbbcc0735af9c8bbf065bfbf30b80ec819552ec1f58511900f11ac78e642bc460e8468c6fb9203dff522af8bc3c66cf7793666ab809a9337e16b716f19f023d3eb3be1adf17220cab476241446f25f2bd4714ec5b1b34613f0a980af99e73f5fa5c7936722ba166fe7d23c8c2f35cb0becdb6f77c7df7511c893845e58650354503a3edcfd9e2828cb7710b75e8e3cddc659b8967eabc0810acc068221a4c4a75e9bd4f643e64370535ba34324cdfe4fa959a938c001bb5fe8f983a58878a18a9571a719f5e440e2cc55b0e83b66c7d1043e62979f5c0bee148993cd83c4367144d9532940cea6ebbf0f2b185b07058540afddf5e2f17b0428c531a1ceeb7ed84331d79d7a0104d3603a28ec3377acb9dcf631305e25c4b3ca7a432cc0be52d02ddaf5a022f397c908db5a1eed2302eaf076c486a9712a64313d21e1d72dc8ee2708e717ffc5f85a04f04bd1753bfb22c3953b9039090bd4fb7acc7115f8d3223495da97a64ee0409210014058e9db0b0b81be8cc52346bfa34ce162409ef1b7969f0e29bfa28f638ca68fb2301a767daff778aa95a3827e9fc6fbf728fd96acba5cefa42259f2eebb929b4b00f87028cc0620c72cb54f8886513e0366ad87666db92b865e39b799e38eecf5264275067a38593a6f447bbb7872845a306440df7946181defc6adfb93297ea5a8c1593efa2f6c9c9c192ce22b355d3d882911f23978484aafcd0084f188f790db98ead934d7242f7e6f530a6e704116442c169421ab56d8b32a8f45e82f7c03a2462ea22bada17d540f7175ba7856184033a4f3df423e2d9c7038a76b5a009fcb977890b54002a356e9fcb0b16051aa45e61b10d90d89720b25b7ea9e8f1239aa2b8f27b42090f154fe7784376b22373910ec8bba8e61e15e8468f05dca3a96bcac18b59842f52ed445cf17d68141ff3b7b4c8a8c4888e0da84344b51f22eb9b25890ad78e77e0b4884b086ecb5eed94ad7cde45eecd2ac7f40bfa1d4184685e5af06c103285ca9adee7e321656861325c74b47d2dc60f8745a0c39a2cc0fbaa19cb165552e07bed287a9b56ccdee0f382134fe5253f4ed009b2c0daad205a74007c1d6852da98a9e9bd334b5a143343e285545c2fe6247781805b0140a3ce0149c52e70b9d19acdff7eb1e958393a9e66be51198cf98147a28ff2e8314fcaef039949096f359ddf8240e05b297f1d86a4d9da22238e2fbb90f806f70aa138e3951542205239f8e1e700efd1c415661aa2de31aae8e051e6181a0a17c50535a22c9630be7601e44861b5f3d0668043f1602cd356ab0304c68a5a78375850a7b343aba33654de316fcbdef0b3d89ecaf5e60b98b24a34f076ad0ee6c6ddc69820f216e7228755b4f7c92cc5f1b2da2650a8ac8d152f26e44e6c767870382845b4494da4d6ac41079baee138fd1e713b9fdc149d68bb768584f8e1de036330bb33b1e1ed4cbcf9e97aa0c6706abed2bd92ef2269bd3745bdbf8e38c0df15e2c889c75ad42e24580c5a850e97d9b2aaf471d6479a4cf20ef8db572d23e9b8d12905154dba532d6b20113a4dd13be97f70fc154e9ff20360450e1e8da2f4d5f571498f1d189c30563deae771d6d0392663ab2b0862587ab3cdc54c276962e411de9534177db16a4ec8285a7fe9a8e8a908c6eb62661e769ffc94a80c68bf6438fea8e1dae535c22fb74f34a9f13abf3987ffe2b315ff1d103e02419b15217c39c3a7079bc4388c7bf4b1ee53de9a1cd372833a9b0f9e049db0eca72477fef04360c5d02e03be94e7b470fee52da71d83c152923b3e467451760c358269db5aeaf6e18fc89064f063ddab783065c322e611e3fee4ca6e5b49db3be8bed48c1d964f0c566b04eb1684bc54610bf7948f3e3d9593a17d7f569c9ca14db793d4db9c6eaac228e7e85069346f10f85e12555596d15477566bc04","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
