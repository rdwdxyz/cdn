<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"857915d40721695319eecaed9256e67166818aec406be23b5bdc4afc948529e2154dc0d555c10f6c73f3f4031d54185452922b2dfcd0d77cb82d9df3673129d016aa2b72e807acd3caa91022b6d8c8cbca7752ca4cda7848644b21b81f901f858991d35d69ec6a93931f8c577e5fed41d62efac09262f903ee4b75d22e161163819462ad3f9e3c3bf8a4c1c583e4fc82c1f9d13a5d92ee84b117c36d8f693ba34977e5068895a28939881530a17bf0bc7b94f6c4c5f087c88b166aa23f600b0c8a9db84ec6903c102fa828c71a5fc0a46734d3719e946aa33c3c9e62cf5b7865fc86b5e0d0f17f935e8d3377e2d6ad2e45b62b14fe3bb18c5e13cf329f2bdc6a5415fc375bc834b7ab4465d1e7a9898eedcf3814c4f971630cf81bbeab08478e1b778baf419712b20a54810d8ac229e84bdd4f019dd062375a582c7b01c8452b3e4ab03dc89e20231fee4bfd3d6df2bcef70d97e4e3184044b9d223e47f09d2a0be77bb695f303553926aed0146dfc7df8ecf7f56fef69b4f148c9ef26038a30f28410aef36b17d1df35f704b4cdeea8e0a7c51043e1fcb77ac480d1fb32c0cf209e14657affb6156f31cec8a9a7a93cce6cc25f0f8229b151a3043a9a617e484bf33d69f2169f9c555d5bebadd49c36018ae9e008455d98efe5a5df46ee2519ddb65e4dad5ba3c14f26c98bcf66b7054ef14e733f15050a6b2557fe584b3445bc4ed4e9b3d3bcbb0bc0ef6d7f252fe6d76d952df0b46e27c180d721106efd4da33f230811a4bc9a367437d5d23058f13fd5edd2e37b67fbd32eee664ee5f2bcedb4b4c87ba759f8eb19193ab3e6721e1bb1e54e195f3818054acafb4b91cf55cf360a2c2df729cf30af0546c622516e4c9ce5442fc1d35116e7c1da684c23236589876da00e8c1998566f923c1dd27e584b03084f09aa6e1beb1962220db146392bfa990336cbdd2bbc5770169390e578905998a0b327a4201a8558a71c347f5f472a79b2ee04bb3e919a2606ecc3ff0ff88cc3dbf7c7d0706d4abc11b46787ae032950011a8464b4fd01a7b0d645d277b7adc6bbd0a1c443bb7e5614e950d4d1db7a3ab6e719ba168d4ece9541722205392c80d61b0af2d5b86220e7936c27016ab68f0fb02dcb08786e82b593834e22e7d752722c2cb05616dca418442989d4f848aeddaf2b175159a5798fd87ad15a10af290386b4c292a12d8e6b1842d96078caf16960da81e05a3e5f4546bd7e3fddb7d0986548eea441ee49e84ba1906d827416c8b2b8997c8ff5d17f4c7b4a833968b10458046bdeb069303ac617669ade0ef837e50b529dd59aa43f23bcdbb1ba397b2c377103d047e4b5734f9dc8e500a8048fce76e1ee2ee813931c6a87ea77ef42c73a6335af094baf7b48ef3b6d1311a0495690f26ed2e9cc3b985f5bf629c9f5f6af4c54d32f213ac034530587d010ab4005e1e6eaa099eb7a2174efe68ed4dc497977e9565accce62c692e71175975d0141e3cec05bcab56a5aba9298473781ab7cf17ad0c477bdc7eb744c7330db947543e0026d5706a7ee688742d0aad7275cfff8780434005dcaf763d7a06a249e0690b6efd1e6fb52bdb5de769bb5c4733a0d1a1097ad5e38376e08d5391e4ab505c713ec7bfb7d05fd9a171d025eb9ed60d04429441f7de89550706da36fe4dfe0c2cba03fdc25aae5691582455f5a042f13c5865985e523fccac8df930b023b503bb4021dbdf1824d7c56b8be998e7b1505d6fa5598868850673ce61abb02c4613f79ac2cf101880dd0fb2e30bafbb6ceed6a7e798697447c0077a5192bbde98b71812d7a0efc112064d2a40fdbf3df3a8c80d45133e9b15f41ef573a9af842ef6f5dc097e4f0163206becbcbe694d7c16cac979be2ed3dfa6ca34c8497f41d2f1ab1a8da6796e02e743e5b79500d01bd256c5b2ad0777e7cb0954e790ef7124a256d5d3e3b2603ca7983c8035d33da65cd5f710d4817053a5a5593f38e00948740797a4fd3ac29d65c74a7c4038ea74ec5daf7b4f93d402293b64af3a969ddc13bd34699308bacb68d25e3aa979089257dd1c6421aa196944c8644b7b4acc139ca615701796ab79774abcbac371dea6883b1f885d6518125cde85574f6e7655d3993f606ce958f3652ecf4d8d2090fe62b4707e47cadf02f63263103d80287aac9557c7fb44b99a0637497a7b27fb14a2742155b2fcb273025052cac35f3c1c01599bb666d66620c212ceda7f7c60add4d269cc5b974cbe776468cab1fae6b67f464c3acf0799d477587ce92dc9b6fb7884e380b587ae990cba4db54dd2c411a304192b625d5942de8c34f669b529fcb89852fde655be7ed43ed7b18fe17fd7c21b8a1b0b58c364babf6ef2275430337d673f26a2f81bc5524fd6b0c1e213fed626d74518aa42d1069a258dbbb753311ed6a57de43153410d92325804f0dcc8c373cdc3733ab010a1bbe14f678650954c287e52484b0a4fa79f29b321b37f765cc61c8e3020c5e41db0df1788d1577339b805e91b6dc47a47605f2782880e19ae9e240c862a08e28b5eb9664ca0df38d7dcb9aedc61fe594ed7d5ee8e53ca5f14e8961d1e086841eedf777c10589e20bdf69695cf59679cca21e5ab1ee78871f632d4874a141913f2eb22e466b8140fa06e1e241a24af7a8c240934bf140827cefd17ec87399ddbdfcf1ec62bc68af7dbebf120f18571113926ecf6bb7b7e66aabb29eb7298b7b12e137e84b668dcf95fe52a8ba546f8d7f4ccb407648140208cb4b341749a543004c49f6c67f45bdf72a25e8226120e6b27772d64155862e0a321ea8e16c6fa9807cc2e4261fe1d6de8b2434ccac8a7ebdb64e9dd9b5e778948b69882f130228e6e72718009797a48d34194dc63c4f2f205eccf5853ff34089546024c575f8e2985036cb1fbd622f02030831a6d8ff340427d5ded479306a0e3f76405ad665998ccc8cfbfe209f7eb28643055fa515362fe4300045f24f0ff9d6dc1d45975e27d6a227e04a70a15fe86bb7bc12405220b84d1acd7e88a7872c2f1bdbeb346515ecdf9a5a0b663829ff222588add970a4ddf7c1d38e558b4c96587ff798445ef40d08f1c1a5efd69bbb700e7e5bb5af876d4bf08c0948125b47805fc754c0244e701fde87f592c4f0379cc4d8983a5e0271191f17954c6b942a47e3890d02c25bc916944c4506862a917448f03ee2caee1f56c2982ed452ba7956a26abbf1030586a6251f526be23600789e52b334731fab31acd13df5e7f16374437d2f9b958fda2633ec9a7747a1e1d2bd006127f2d8e9a70ec757ff12331688341dca33e0a961ada10050dfef0f153054d740776fc25ff6ac4d5f960d9a3317f9e4c65a90dc46b7f894c29969209ae0e11c0e5e2c234ad3ab0576a07e8e98878d084ab270f0fcdcaf4f86f536d95d84f2b3305a34222b7880cdf973e2200a601f91d968124bb641509586179c45469a9aab6e188941e2237dd7cf82945a45b2e7b419e4b04b74eb565d41487719dd06102fa6c16fdfaf9b808f4172b3b8e938b2ebb8d178be488f4347bdb61e04751f5a6bf627f58020b02da60189c8fe52bf93a1e7f392649e2409391ac88aa350cbf6434bbd9a5d46927e6b0d861fc2821810de731058629caf353fa04fc57c448e5307caebc69bda29e4e7d19bb9940ff0af1af98355704d71c0fbec6ee131947a43efcff190c86f610336184f0f121c9698b7ce74636e9006d70d613e11b019dfb79d7298dd00073fc344c6faf3cb83dd16d9aa6aacacd447d1d9f97cc302cd7786377ebe4632e9f1bb7544fbb3671eb69ac49e90dd0205e51f4c67b80b2997a019a5cefb36bef6b39330cabfe1fac4823e081cc4c6fa6059f91eb764b85979a799a19eed5cf79424959ddb6314c87cd6822b9b0f49f2283b77a2df1ce92df0d334a09384f3079910f3cb487e46b82a7987bc280cf198b2ce370bb7614a300cbf35d18640ad9f761b09f316a3a25d6ce1f5a9d95c328163a9a8349b09c5a413d39b190d10cdc16becf05db5c6bad5586d19fcc6d78a26a912c682267847fbfbcf3b466e250b870ebd5527a1e99e5127a9bf7af0a28045a90d8222b7d692d60db9b61dd605db07280a00ca1114235455f1f88192df92a42b3a544f1b8c83f52c6c84f1fc12bab3ad7d52cbf730fbc09c513579139ea587710bde9c5bc92749283f8575649f2779b03df60959cffbdbbd42ada7c539b74bf15308936b4b6b3451a942be929f48653ff787cdb1f1670fe84fe3fcafb33b6469a43d5732a2af769195133d7ebf1d15b4505eb75f045c8c206b215a285e8aaf09c3ac2f2bebfa8e2550e909f2634ca43d72b8150cadfcdcfc50b1bbabb8850d70c612dedd27802ea3a15b413330325d355015c10aed71a68b47c494a77b1390eea240291d4a90c1d9f2866775c8b31ca8faee288f7aa97bb7065acfe606e12a474356c7f1dea95b97f1a2016e3368832361924ced31b8b8e68c20c9fdf7465c86b0f5e62982d898b43d4d0ebe846ae3e14569b51fc333b9b08b9411dae3065f3aadcc78a848b92680121c8e3443b1119179ddd256653780434dffeedf4957c7784077dee53865b4c7fb04d61e909729797ca5ec6df7cb115043e242200b13bf7175f4ceef291f95aee11554ff8f008fcb3842071ae560e7313a4bf659538403b1daba9ef38b67fad9c3f81c7f5ae3e7a711f2543a28f5498d1c4445fdeeb2f813c2f2e617e83596f5a77dc120843a76f9cd62adfa5ea6fbe76a753734406433b37901c011a13202e1899656f6249eb8a10c68f92bd661d26d38f08a2d9a0b1aea8e25a756cf9777caab4582e7abc1dbf8f07c46bda959e8bcde08245d57995a10712f5a124c2b58b5df22a49ce9030e8b3843da3464ab7254c056536270f9804ddffb0bca2a081d879e15a9d5d2043a2c7b3f183d17dce9e3dd38227b18c9d99459e66d3a408e85c731e6dbdc2d02c362f019c57d01c366f55551b6edd20ea2bdd34dec520e384fc52dee130b53fd48385ffbfac9643683784a6abdf9a6fc165c7f05bba1615af98dac530d1e5a1dafb30c678712e58c2d1d30b50ef24da2e8a4ce77d47538afc7e6ffd6b5f23fab9c58b04434430bbe05d8eef2746a5d984d4be21912112b71323733ddfc7dac5b936644d86d5e23ed04fcb8b93d02bea6003a29213b5ff4fbd858020762d99dbb8c4772d30b0fb371f83004f1e5045bb082b8bcb67741aa721de810ed3e87da9e1248f01dd66d95241d65d7ba034706302e0226ecabc708cad743fffb3ab902b37fbfde81aa62fbe28338ff56ea9d5fba2c7e3a1172e3f148ae036f239e6c7ed85d433746127afd8874453b1d7dc9e2eff8cd5fcb4253f12d7f497e267531af225d4826d764dac6b667cdb9e121240c9e71375de97611ded115c9b5eb85608428ead1c64af9447eb557de78782d12266a897bb8ed9662d9eec3476de7feff460a1b8e57fe8bf12b80149c468cdda97606ef370e43be902d1188b1766271a2e4ca7617a699f3cb043d294ddc8e50df664a9927bdf490de069207b0c614f142a86a7b325b1802634be451032f791f469abdab916cab0c461eca6a90878acb69ee49ad1a09b62b50730c75a06b3bfdbea3e533cd46a49fb45a1df690cbf093d19244f94bcc8b053409c9bd7d8e6bdf310b462b977f11cd5b483b523d26dcd6301414177e3512bd9092995de37b58e40215d9a0103624dbf2f0652fb90d2452b3d857640b67e6fcc18262eb34b3f18cb7a3224b2c57605d8c612f83da4dad28d4f45169a04e30445717f755c08ce1bbde526cd6248230f36145e4e7b8a6e35fbeccd41355cdcab0003ffa4143345724373f071a7f79caefc64a5d0ef11e3a07ba1917a79b541203b3210e90a7f14d61a3e40c358f9df66d8d47b35493bedeb33f170ddb3c015c6f7e9815e5b9c76c1870412394fb40de04638d94242f3a8756dda0761c0e8cea766b97915c9c47dafff182696a86512476f9d17dc99811f44311267950e608fdb77622a5c1c0c0a6d27039dc701b1997dd5ef8fe1375971b81f6a9d45fded99f9ebefff5baf3836a6841563ed31e27655996a98fcb5e87a9ad0a49b455a2492fbdaf1b6beb67b5549437d4fbd1665047642a5c4615343dac15d171757835dcbc28be8be27ca2c0d12f318ada94eab2d24d224dc8c86ff01d1f21c7da4ec85fa21c33a1b676bb5c73328582de534be592425892e1ff80718f98c449c255385c7855a4fe18ebbebcddd43fd82b60d7ad37d15e7e6723e24c36efdf481ddd4676c4b3ad77e147d8a89caee471305f7d211319aff153eb2e5447bb15c1bec808a68500802cd8a05aa5c419d508cddae246f1b56376e5119388749b679776dd91b5a4fa345ebb790deb615e55f70a6bfd0a23d46ed4c8fb8ae57b5d54e7a56689086efa04fc06efa66b4cf79f5779305dd679f2b177c1a947ccba2959981e588fa50f2ee64cbeba647aaadd206a59990a3d3443875c4ac5d0af8c16f2bb85adc7b12579905698a7fbdeaf1255c57e2adb3159dba55f2daf3c9bd6f2be0b48f2090e98d7d6cbebaf67123df5d4a688246b5982748efb9ef78e201bd59db8c2d19f37f10d2a4a78169aacc7bd9daed87e21d9848e4bc4fb4c9658743c43a9a8dac1cee1a3830e1ad40bb8c05662932bb8af62f747b5da8fc0bc19515bed4ef260d67b0d189df68d89f8e81506c87efb663ffbf7d264043c225b3141d19af4c6a478fcbfa8435f9f0df637616aeadda6bb560c8ac1a8c228595e9fc1d22ec98393e98e1766ca5957dc6a4640eaf7282c13ba1424fdffc02799e007bca9da3d3e87c8708371bc2d9f876cb0ee54b718b7a259a7ce868e1cd0b5aea54b8be0bb6f0ea06da507ddc8271909f642db8e945c66f7591f43e26a3288e64ce7b2fa162d41af3dcec588a6f6d833ee50e17d0383fc059449bff0834404a298baaa27f919bc726f3fad5990dfc95b493e3a57478bb866ea44dcb2e04f048ba00794c7de7d41901d8d125478fa6bf31b6bb84b40fc7f96b45a729655689e5a0e643cf80ef6870255e781972370cae33c95a42d80cae2009be639863cf4840c1ee1a22efb4c011a127cc71b6f4c730730bf598dc1ab22b31f9a3116caf8799633957f3ffed0a8ab8b524c4881ec7316fc5f44a2f540f7f8ce6da6e3839fc3806efd9f31d70809b65879d9360ae1e83fc2ecb3a3400417f2ffadaead75553b8091e93877ab356c0a922950c3d005bdecf250534ffcad118e5a17a528dace55093d480bd01f18e520ad0efa2334321ec9ae081ae53f26731a9938a61e470d8e0276824cbaf7f6f043a2e512b42afd2dca20376d5dc78221e6af9ffe905d2fdfc07641e270ca6982ecf5265a1c5aeb93112e5649f2a88fd9f35690c3c4ad4148d767b1f071ddb0b4ffecc2a507f99ebb2f99d66d30264ded3fa9c5796a081abc42c56329ae33730b7170487812ae1a54573657f627cdfd1a9b0a84173b97c5805ee24c05e422e19847cd74ec719317f5ef439e2b145ddaf8963767b68fd092254d4831727c81a2f8bd9eac0a70b53e8fd7eab84d3118e99fd71e1caba830bdfcfe99855e54d61ea50357820b22771b2c57a1cceaec36b6f90cf8d56397da0e621d5fed0fce3df300c0877dad3a47ceaaf45f00da6cb6cea0463eb766ff00e602985f1446e3e5940ae6b440c4782d17bd05d74492c7db96d132981bbf233950642345480307f7186dd95f4a4efb5f9ca1506955d7c105bd31a6c59820f8255cd2bafceb83d471fd46f96ab46e72d9b00cb7ba2f8ff9fe8d2a84b8ccef7070c6b3aa13488869f6fc838850a52963f414df4af887d3b717ea768115117fca3f872cc61cf9f4228767243aad05e63ac67f694d9235180b1222d6d3d81227ddf4d9b86391179e0be5780aafdb4b4f02b475d5defc44b0643efd1b808602eeae022e82199d86456536cfd9f44e171d70f69ad8c28a17567be3ce54d9da93f6dd758750b299cfb2a7e0a148e155a82ab6add8fef4ad3377d9e9aab225ad67c25b4dd9c8d99cb56fc4536bed99a1ba6ed583cbf8c35ebfdab51acf37bd7954bd3921708c58e63daf6ef159e57f2c712e0d88fa6f54d0ca61583588f9d16a9234f4363c6ad57a49d6697faea80225bcee27e03002f9899ecdac9f792fb5209d0dac119ab2643bee2e969c431dae1ad3bcba658bfb8f2ed3d719dd70e52ee02dd5e5c89749feabca78084b05667785ecafa3fc0959d2487e062c6071bdf424d581550c5e4a7e7248642fd5958b034d4f48d3a659ea0f6532eca328f7cddc169db269ec2f85b5ceb7ca07bda4e3736bd553402e09b73d7dfbcd2303a02ec98735beff189c610fe94c75dc6f76afb0a8d67a18db44e49fa9ecd1682a9f4acc23d2ec8b6bde71eba23370bcf675a2afab72f96394f56d40ee22d930ca0ff91f610d98b4ff1714319a032196985dd8678ef77821effa5192b0e351e8bec0471507b27e973577937c9856bd1825be9a3086a942d93cd3bd53046fff81899ae4221511c7b18d02df3bf65e8c49feed8c19260678cd05fbc7df4d43b9e4ab23f272a0987d2764101d1cfb3c03b56a2129bc27dca8bf781d1c94a6cbf2dca9f4ad1c533ed33867b8710181b2fdc2173c5343ad370f54b0c9d7a269a9176630fe28f26d3997aaa400def7e7343897e95edaf8c3f5a0a61510270304ac350f9d1adadf22544a0cfdc2d266ae5715c47800d76acdac195438dabdde15c1c00067182a6c723cf70ff77eace2f50624d20723c61c21542b66a595183d7029932aa668be94787aec60fa013d36373ea86ad99feb1b04559f0ee1a2da6a910223b5ed9cb1f59dec1206f1de5cf708a6f074911d31dc242b2cd16aa0fc8ee1eaa6433f1b784966afaa9810b4b38d10a23bc6d15ad0b33b6d4550335538bd2001485c7730fc6357421457b518303bc3994ffebafeea9bc4860a0ffc9d87265bf6b489d7e607aab7b90806e505c7094b42e8a2e404c26fd06648f12d6174a00193cb5e9282ad20b611286fcf07030cc54fac5d31c15c93d78c4667d96a7cefdae70f0a299214293f7a4edef60598aff02867155feae98e8a67ca3c8c9fdea590b2554ffa48b17742c759b746766f697d254360e6f6c39f2fe50db4dbf05c5d1a42c0513b7767d00e7e11ac5aa02773abac984ca00a83166dd4c01533acb9073213fa478c1c515f6a9722e32433146c61ad8e783d499dc107c722918b525fff188cb9c4daf2fed47fcf14f38247966f633a9ff27175719018e5af9b092015d3f122f322199039ee53e9deef84605cd6fcc0be58ce6cb7e9c97850302eaec8ee0600955e97c7dafdbf09d060ee44cf900c08f285b2ba1aefad3e4428f7b5b9dd0413d2e14961d67fa1fe393d300cc6e8958ed545af70ac605e38bf6563740310112a1b865f69db47cbf09f215dddd8c80bcccd6f19ca007c8207ce5bdb97f52f328ff8965e92916a43295a44d703f101625e9c298dd65a23ae8e84266b6d21ff417a3edccca81d11cf0133b1d44c32590540399862d9276a29de1d4396b78af54086686eb3e1303f6268452e468d08d4b6913f1127d18b399ba9efbd5a8c6386b470690454799d38030e5675191425d3afdb71cb1a8c772e67f87aa75db26b511478bdce76dab782af383fb098075ec68640e9401f07f0afac0de15141b17f9caeaeefad7b7254d45f709440262efd960f479241d068021e88cb53c103756f8c61e45b53faeeb8386f8ebf1a4dabe7f90f141b547c4eac805077ca040feed1e38bf9598c9294746f3d7c9265a5c208a65d0ed29a346e53bd5031594a78fd6af01c4c5ca85f3ff6c3294e141c3cc9c45dd8394e8e1821d60b6fe0bfb791b8becb572d3c56878cecc455f8ae9680169b185ca2101577979075561270c03105f9964be365b03c9bf10488c124e64ec0fc6f70ef086b79dbe5e6b0290fd2c4dc5bde9987864fdd42fc92ae585ed25b982afadad0ec5f0c869d9db1ba6875a7f29925790a8702c185305e0de7fbc53907cc2e78fddba8d7a9cd49475e4c1b90f69ef04215f1ea372d0516bb6b15ab3b1abf220876ca4612752cd84d957a2312f06f7767fc1a3963d81391509fc5c0b38cedc14b685384c7022574481c3d083cdc7d56ada013fc5566a03ba73bee820ec466dec7b4c71df11ccb700220891cb04eab6b1edd7930d94f93fa23bdcecbb4d99b06dbb7845b03c8abd3fe7e60db8175a5ff7a9e9c274549c8ce2f51e537e7f1389db20b00565e6cfeb0d872886afe48e2509eb89ff72437d27e630a70f2891515d98023f3a923c3438661eea33dfc124b9cfbff81b8fffe1d15d69ff736c65938193e9d76e0025c66c39d21268b7d7ec037c6e5ef858cb3449114edfcfd21d0274908be395648a4fc12c2dbe377e03902820c616511e7549f0989f71e8fdaf117cf34c501c1cf3909441b0cf8382b1edaff034956550a1dca0be806321039cb173f271d7abf06d5b15989c535cb5106be0186c390cfa1ffe9b61d20c3304bcd4ac5b7885e71258e23ca3fa2ed8eadabd41bee77e1dc09d6a6921feac0f811ec90bd3b1337d334af12337367a5a6aab9b0798ee43382731c772732fa0289f7e967418e4c62f24ca057c9de0c8de70925265d5b68dafee84073b0f7757915d8c6f4da1129e3d66bfbbe4b9b40b1ef8efbb2a4efd19b0eb5936c297b6d7f98751351252d1e96fbbd06f50f61143977faf9497a2b42d725a8e0811d0ba256efc16a4b8ffc037b30cd9c6e03d06f128342c3c7dc4e078d001902e15c1ecd09d6e9ec92d22fb3bc04b9f51926931f5f835846d88507bb18840ca72f592e26224831c8c0d40105183ae0392bf8f4414337e25e4adad934a3a7532576c37bbf7a6bce1ea39001916c1bf20768c42372dd51956abcc8fd0773b79cd8cdb249535fabc2b741d0634cc0905ce4020c31f8b74000a64a1350cfb9b489e3e3c8500e2938fbabeade12341e9f07ae26cb191969b94809137515653442c5e47bf636aa7955d97996a1cb8a8ef9efa75674bb5dbc05164291b54f6dacc5f253240bf765c7328cbbdd502b2691e4c779cafc6f0b4b60342ab11565179a4b9dc611b471be270d8022dff2d6d53d00aec3fd1b4e62ccc28ee6eba37efad455055cc05e8ea6863247182a542c415aa1834189a66ea9fd70722d3e6ee9d76a91d103978defd0292c0e9fea90eb7e7de122b7094fdd57dd193456c22dfa744733dc9638df8655aa9edcc377f74d5daae7b25a399c4e796785a0526392379183c38569549623acf2bd785a64b8b25822c92ef6789ef5569584fcf0a665b767665352aedb0814c3b07af0fe434cefd292a3b07b2a4bac66c72467f2008fde07e5dafa394bfc335ca12ac4266ccb47ccd8b357a00a80e261e13a453259ca1e82548e2836a421ad97328578d92acc3d74fa35ce33459d791185f5d32f5b0c107d241781d0127f0e8a88636e0e45d8777cdfac5f5f443682849b90eb8ac243ac9a6c20a582a2c9658579be185f4ce9be8b05ab47167bc12c7f05112fbf70b4bda06cf43c679cfe80881755e369d402a0972726100204293eabec79c10168f6a966a9316490df6e5ca8074138dd6b902f1f55207c3d6989987c102d8bd695a845064b203605b1ada42618dbc5042b0f4fb89009f8deac40e31f87383dd9647992645f6e45f480eccdb549f9cfa737f707b31d09c795cad272202d19612dca6a0b3b5c0fa7ebdef246b1684d930732e87fd9850b7767b814f8ef64b44c565e951a6bfa4de21922d8b7947bb1c33452397ed379e420d4aa1196fcd356f4c47e8b12fc358900f4775d87630e4185d7f2ff56c785002d40ddfc1850db744a1afca46d60515ce452df2f7d09bfdd5adcfa853fc452425bba66ad75b9836589e435bdde99490da31b14a0cbbc288462f6089e881d2110af36f4772be2706cb8fb989d538ca908088bd93bfedd953cdd9b07ac5c96ab9a79a7b7fa71d289112e4d47d67d659a00596f136d190ee97390b2e9964952f74eb284e4a8000afdf041631d6e2e889e299020ca8449fee05d956968f61d0e38644f13d9d1db462aab56c8c7293025e23276de010abeec4c6f93606f1a1bf7a72b0e9a698bef9c9fef74b50b9d7bcd3ae24f982be9c2fd2ab0ee3299fe669ae2aba83e677d06aa3dcb20074f4c3d1aea9b5b8342adbf46b22a095ccdcbca93c4f3508fed91e48e3f1a994b514e73b742a3ad02b527f6b8bb8a957da3572f7ec31db9bc896ddb70cc95ca22d11823d4b56c06c73e52c09c668117bfb9c70b9cba967e7874583831ccc76d35e986b66cd3cbf3e29cd0e937a7bffede544a647750ac3aed766645015d656c042997d43c3bbf299b66ee521244587497082a320320e1d98e537264effcdbb5a2d1c21c7576f44f31a8f3abf92c2fe1064eb17afac7775cf014f4dc5f4b65f3710210ba25a6b2293ddfe86c807634f636803b2b3e8aa4d58804d52c0f2825a4e716b53674e85dee685772ca7bfdc3c0e12205c6d387e80812aa8fc45bd2fe9b11c43b5cab815f5bb0805a9669ede3d4b08eeda83d97cea8eefeba450f7de1f4c9e5fa1c863a157e1ed704b1b9543df789175ae7179c0646cfab68d24b59335b062ae86a3e35706b166f027ec599952072f2129e41eb3e60ac0ee28081ee575c80a2d902f4d146aa12459fd32634f41d32704fa65b24a388c55ee0b23879141253ec5d9b84779196a869e42b1366aaea557e7289a93e216406af9b7d171d60a96249a316975e243b8acdea8ac4eff327664f23153286020f6a2956ed2c89895c5acd6541bd49852b4473f4c7389ad7c67e2339d250c0807ba7d6ad144eeb40b531f62d1ec33f9938f3eef4d677d06c3bd27ba15c7c7f891f5c77ecf21163cfe55656ad9899dbcbc74d05f9b49a9521d4857dff0fc732ee9772287503a1758ee127f48785f0ddad28c0e5d72065447977439fe04893f7bc124dfd9684ba0f32c515feabd957aaa8914c0ffd6497cfe128d185e0a2525dee7a1947d395c045fc46b7e7e1672a73b55cdd6bf45569d5f5b55b1b3ee983e3d01b297b3936abc7c21f77a9194eb3a8391065cbda74aec662a88e8e891e6600b8954ae51b48ef2086bdbbe8298f10dc74e8d8737c582f7445741324d7f9c763dbe63aceae1cad5fcef801c894916597fe75be996f7676edddc3443035449768eb06f0279073f3705dfc07afaeed388af0ec5d94d17e5ce9be3f62fcbc6c1d0e470c61a0be0d3ae0057d088ebf5d8295364cda215a5028ee5e6173968e37eea48fbe96d9e1f3a95b5b8b5ae662d3a0536d88c48c92e90c7a3c2359b19a0c904dd0ffd45de0350caf57d12360ddfefd4992c8721f7922b37bf436f41f203fb6660ecdb0e5c6827f937e1094375186c3e2457529e5f3a62cdf189e2e3df563a675b10c40762e7aee0be062c3a91124594eebd52967bca7cad6bf03ed4898fb53a87aa27dc4dc766b1fcf85f328b212201956416c1435780ce9a82b7f80ece11b11ec45e9a3d115552134642c7e3c7aa076beffde0338b6cd16f16fa9c3626b955c72fc9206574c1bb9e653e46e657fb2a968cd6b5504d30eaa428f33f99a5daee2158434d9f9d84c292462cd9023a5aed898eb7d409a765080843f80b046fbce3bac51b825960efabb680aba1c07309b08114aed6d6b93e6668882d6152249165ddfcbfeb7742975f0e661cdeca84f4709a91e56fe6623e89a1fe08f8ff8eabc27685b513848c5739246b80c57ed1eb21c53fb6dbbb954d37a403cb2bc897fa955f581a8e47cd87a72f2595c152e237de1eb896249ea0e7d24eef6a31b4685af0259171b5f9bae067f3254caae30e1655cd1f311a3e20ff514f3f946d3db6bc7c2f2036362a6442d576b34f9bad01640564a30a9c2b118b9efe2f55c56efede4231687899e947d00b98a977bb0afaf5b9d4646ce23e11a9543b2acdbd7f84255cdaaa1c68a168b396cff248e8a432b2794baf4a7e5dc80bfe75a1d44a87e6ee33326ba5ce70160fdfe91e75ffab6f16d7e49823abe3896a38c9f073d503ca43a3872ce8383fb5f2fe4160e785bb9d640b2fde4e368bb9b964399121f91712f3e26d8ec252169cbcf5f469a9d0b33128ed87a10fb670a2f34ad27497e3dfbf0ab03e0cc477458b7da2ec5bc11c1682b61bfd65cdeb63bd4e9e5efd06b926ea68876b1510462f3d6e0582226ee516dff561752b79350230f6f4e7a5a4ae91ac19a9afcf2e9a8cb5acba5ee99d25ce7d7726f60ef995a73b5dcc139a4e7a53888e2531b166b00aa0945df5215b4472da742100553dc99bd6b89c71a81ac4a54aa41a9e4e2480c6638b707c92232a4d5f5012f2c997fb46b0dd37ffe4c1ebccd42fa290b67ea82d268627543dca5120fdabdf9b53caa67e05ef18e356d003394dcedc4fb78c0036a381a7fbc12df927af8e670a521f53cff5ad303e82709829e44824a600d7e0b107f26161bc873211f0d86d40cb4195e258214c632ffb5615e471eb9f0e97fa7f443dec748116a79aa2e3550dd64ce0eec1507770e7077f4ee1f0f8941f473cfc47a5b5bee055753767467f46936e98f7a4b8c2da0a71475f6ed7ef26175f81dcfa17cd60459b77b79df4f95cc5dec0177ef27c514e5569383fb21275952d189d674d18ebd812cd3fe32e9b54c8aee0aa24f0401aa259f1cc35a70a3702f4a5c6bb02049f340e3d2b42393e5d37cc7d9a35ad23afe9c3f0481ca43251d881f24b7cc990f34a8ec4ccc916b00d1aa051f2e2b87eabd2e5b24eb37ca16f4abf310d74976b86ee9b123567e34e81aa7fb8fdf01a4b5e89fc8b83c94092e3ab4c52ce23788ac4b9a22732534a298483d1b64b10b52bf812721e12a5539f070213fb32cb03b9e9ff388a9f47b5546feb65e05aa01383c8edd34bdb5bc0adf8e736ed56ad8435f79901598e55d759731909774ced89d266b0b228d1066872a54553e3ae3e31dba6adcd2efe022c392b7df5377a18be4a4052ad4d9560023d49e859a7967493fc6d253c85d875ea29f700d84eb2945d492a6387f3e55b3f373e72691a839d2f83b53e07c9dea49bedcb90336a74b7d29e7c82a5db38872cd02704af2de5f2e8bb28d7f71f16d45f2ee281df1e6e7f74d5855952d55738593bc83b519515aa4e79e7faa7ead72d8031bc2230a6e627c862e08a011d8fe77226a9bf63aaa7fa6e7750a2210291f99208f952a192dee438c4b0614857a99b5082104136a5bef082b4b3a728aacabcf811e8fd6a82308f445fd19820c9b799cd6d343328f556cee9ca756155948dc85ad6fcc259ff87cef4456a8d945c4c58b7634cb147f6238e44086058ecb82d437160871e6adf7354a574be8ee695efa32a4a0a60c49c4e4b80cf1f6621979229697a7a73d361c653bc5db02dd18b5b263ea5d387b17041f04652b5e2ca294635678810f69f9d9cb85c3a52bff7cc930d571ea6314dd700d7da8cbe84735ee7599195231c5f238ca2d35aa40a93dc7b2efcb6586f42a896b7524243249bf7235db2de54a22a22632689e28e7938348a33c3566eb545f2a31ee9d22ca465f62b25da4ad427045f6808e5fce6f8c331a83d7c2df8cd3bc4377e224e0053cfdf26a3ab03afbb049a7c424746fc9947c94542cc6fca8ac2e1734ee2b76b2ad18725f78f09aaf3a07d9ab893946847fe92c5bab3982f8f647bd7b82b23c414978c3ef78175f1b47b726d479ec9f7d3d5cd61aa3e7a441f0b7d7739a1cb2abb781e35f6510dcfa48bf0aa9b38703f2c56dd08d0a9eeee13a682ac42f425c851e0d6d2f06d4a99ad801d848cc0803b5e6faca5cf6b47fcce478650af7f983e93793a72054104694629d8156f429784a5384db5677dc62fbc81f46c90f9800271d22909ab868d54a801873b74bef9d7e5add7a21a5e45d285619db859cc5ab4870399b6ae7fe80597b230c964a3f05a06403154f9a9e87e5a2a691b7f3d8068d2c7109b687871025a60cd399f9df35ba4c86b917f0a1ac49297afb9ea71d537742d7eef51979ba4ada85ddd20c4b94960765a5c1881f009ae2d5c2e64a058cfce29012765e822d03fe98b68bbb8dba3d089b9452ca70ea9b7b7a776a6828597d7e0a959a42a44140efa8844ea86bfa58b7775c7e9ebbb7370a73d03a9787856108a5d66c6b98185145a19f2d1ebe309af8d16e25cdb5220db96922c8cf33a7d368c92ef77f086ca5138109ae226d1d2c94935c94259f799dafe2b67f26d3c2cfbdf83c5d71fe489f6c7b8bd2828ec67e4ccda6e3fc26e7b99a638797518fc8ec6368a5318e4e2a71d1060c80e365ca9f155e6f168a335f998dd72ffe076c8fd081fd6a62fe5f4bc248fcd7e9220b89715ea2bc4cd3b997cd1c58de654bcb6d0324b3fc509c05d31869adf0bd816ef3de2a458e2c84fadd911bbc64822ea9ce87726a04049392a60cbde990f632900f3a8ebccca89e26bba33b84593f7d27f4f5466ab4e165af6eae868aa8ff46191f2a165dcc2e836d5563146b0a2a8e3f8941845873e2b8880f63048528428a9792762cf3f0905851c5abc896a592e5cd0ece95b70316ceaa42a1b72b91f544e70c8e1df8862674a3bffc120899f9db80b8fe2f9ff756cf5efc0adf188a52157e7a085632f9e50996ced6e704f46ee952785d964a7887938064a69888a8cbba94ecd9d6a43786e8a7c837d339b4f22d8888b872864d5b09ea914d454b9837bc71a0e79dff28ae4bfca4f3b0403f24853b6424e55f8fe63b4e980b6ad35a773514a477634a06d18eceec0597199974ceca2946170040f6d12914facccb73058ca1c43affb764ecad8c1f11e82e10ecc2efb119ad5232c2a5a8d8f2463ac74e20babcf9eeb47e8575b74901777541b7703c14cc11afb23cf47fdd41a5e84f965e0ce0b15ec50ab6058038be08c32b878915aaef169dcf416c2581cd3335a5ecc94e723f70077670148b1a84ac5aa0478b06b6374c2390a4d1d300c6214236f56268c1707fbe1a7611cc38ebd8fdaaa3445a53d87f01d93d414517c3715714d6b5f215b7e44215a335d02879444796e61cb5dc1748443e304ca9a865bd832dfe99efbb06fafc54367969d2cc49018ea642f2ab994eeaa959ac66f694a89b53c3c82ffe23718b0c166bfd48f4efbb8e644ef48b456863bf348e88b5a5f4bd430a171446158fcc509fb11216ec4f3d533f48bb7bfd3090808fffc9ff4cc372d6d36fd807bc98a920a78b7f43568999f0d7112e6064ec9402d0097cbc3b0a09738fa0272b2034bd164ab4d87b38206d910b24ef869a2d096f3d3364d10155d97a3d303bf509b7016076d84f05456d255d072028baa0377800e84fc47eefaf35e70c34818a0382a0f6f49228ff782a95e98df5824b4675f140fd5e688290d5e23616435d892d32ca81d335b2f74bfa569b94a6666738fe1737c06567411ae3cf19d599f8a39580161c77dd4699859cb0f3059647e5b2b693f4a3821b2a6484b8bd126bfbb0a25f3bf6f80277962ca09ab5ac4fcca5b2e3090092e439b181caaf868e4dab5b199ed6c85bbc2defd5b33f25a01f0a66633e7adc91ef9f072813f86c5e8287a4b75f31e543f9f5805131a5d367c2419d8ca36ef8f1be3344a20de8c8084b3f3182d3999ec7711d03c5e9f0405e00a5a194dcdb3010fa309909083311d0e31250bb616752473f5f825f5c748ee3b085018c775e7d84aebeeae508d440883387cd90b8b649c16b9ceb241ae16e350847e83c3965c4e3d6ce770230d451f73002a2fa7b33738ffbee52c1e5c7317128780ff24aba073bc134b125d29ce118969cde6ff2cfae475a15595b35da56c07e2f50e87580c2a130ab2752395cf3feb7f7080ffd45e0605db9f82b5afec95520d4d56e0abbf669336caf5091e46f7449cb0f8731c91bad1b814633b3113e2395f6963147daaccecdebbf88f66eca661bab7a073f9ab90a5d9971e94fd18942ecfdd1a4c8b15f793974b2b202d018e21404026cca1aa51e2cbf3704c00819d95bc2e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
