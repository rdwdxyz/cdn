<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b966f81d2f69d9a52fa3e1d8e42f7a31dcd31b2ba425deaaffccbd27e4732b8aa236fb458b4f492c6efdfde62e61ac1b7922f9224539bc0cc88b839b70c9ba1397ccbe2db0bd9478b6a6080a9ea9fa00ace05a6a5b7a1d06f0a74c6516f3958dad56919137bbfe6bcf1e4d71450c59a98749e4c3ff6272821e1a4eeed82e3ddbfcc9c03429f988ef34ef9beae692077a7a02876c75b5ac5fdf15a8edaf316117ce95e40990f51768b315a467b18bfb332b6e0e135e563922c7170c076277e73886276c53cb41d83c1c1e06ea5b88cf4cd8de0b27e17f29ec89e787ad91bd8e5001528934fa2d489758b16b12cf10338494aa488c10e0592a86d90f8c14098866bd6e753bac4d007b91dc5cfa0db63a051bedf5965fa34838edc0105d1e8c01f6b598c997f98af0065a66964e14407683cc32b26c7e191856316893a6a9f5231ebfd13a0cd00f14c9226ec6bc4cb5030ccda52072539873a4a6ccdf96b9b5e06854e361951e1ee149eb199efd7159cba9b0527ab83da80f20bbc20fe62feaf13c5e6020c7d780a8a237557c187d5b0fc0c7669bf3a6e82ab78bf03fd43ac161de489ef0ba52f3b07e092f5add8d52328c937f80eb15815b1a520a99262cf4b25d5730476af8f60d9a4056445842acccb17e1608ba0690daa63f5f3759e25ee85b6085b721037c7f0a585d9e429c2084cfdfdcef01ab126a6db2c7b00960751d7c8754313050f6249a930f746a9b11e5b991553aee70003b69cb1d452b5dbf036ee8eb1af79b2f8ecd919642bf862acc06eaf80594a26aa6a8fcc9fe99e7a6e2eecb20d1f00add07a87c68638aab6e9d7bdd4224beb7acf69338863382da467e071d27f8cdf3d4533bf1c657818e7f5325042af6c19cb2bf8e51498d993ac074da99b3ed225b8a35c2d8fdfcba5ad48c0bf5ac954c9f88a82c7ababa4d29f3fb0a58fe434a024c5bc54e02e625abba673d595e1b95818d12cd775848b88a7e84d7a26e1688ec10eb48257984e85f1bf0763167d0a06fc3c21cfa78433e4209ec69d4ca8b018a1b83fc26e200f0bc95e8768fca379f45ac40562d562c0a82d12a09534576893bdaab05f7b0aa2adb3caa40a2970a9395120fd14870ce3ec9d459f0dc45bbf91200cfe69f64a071954f46cc5864946f3e897a11d806d2da136e4e134f5e79e48b5be78cc370873b7ad1bf20317875fa7c08094507f49e93ddcf57d3a1327574971dc87e15a79a95067c2cb8b72e2239cb0b7925d8635def37cc55f2528015158d107ccce01545de80f606bef69034a3c5db8fc37df71e3aed40f7ac7381c27b69571d90076f52a64d215111e95b1ad2f84aa2bb1800e69f0d0bd4f7d3ebb2c37ba41c61f68dea37a6a2c1e395202550aef4e281090370cf11e583ea6a17b01d30c3b3300517c5a17ffbf9a8f89afcb090f4be746688c854512977683712d329158ebd6510b229b31b17244d638d06634e37c35bb7c47b7a2481ccbcfd53321d6001bf82538a249aa429340f1f68dd2fdde4742f9e9e8d94510fa7ee255b19b26b5e3add9fc751e4188473a4fed2e5e7fb6305f96d05c7031c9719bdb15f6d8d66d5bd113ecdd8a1a973ed83ec238c217d7444803aa5ffacb6fae81f27d69abb474e119ad69c338c418ee580a2cfcfdf430015e38cc489269dd28cc28508e45d61a440042802dc87a8fa6c3a65a60b3085fa828971eedb615a7bb6ad81f7f08b82342e39c089939c8d60299e9d95ca9c42b190c656f6eb69bb96ae5f319ce55a8e6f5572bc4657ace957eac56bcaf02e2136730e9c4940c55640319114a071de61eb5b06001027f939a132dd4e88271bc96ae9f1cf505e8510acad352f1ae427065f34f86011d9e7e2ab9017a8097e353170829e6763edd3ff5e7f30e0b17931bd0f773715ae27bd0276251f143da52f46d66baf62f8db369d7f1cc3c095b88d6460fead3665dcb280854689139814da6b07beff8943bf53a85719ca717843beec0002ae5004b1dbe976a873b35eb09aa78a1c6dcec2652f7f48362236b9cd0cb70cbe2e4617dedb8d0bfc62bd58088f007249979982a8f7645048adee5086330e54eb34531598dc25a6891d31760b152e19d51d6c0d0f129af896912c023c1addaea9d1402b2c93d999122f3331a2dbb2743108e57898b0d08b541ad9a6e4317602510098dd78fa9da37c130d73eabfea7d3dc3e0323f5d8d87caefc6c8ef9aa36037fac745b16f550e3385d3243d6298e89bb8c5bd1ba48a0c825e8ee730d8b1c8919ee56b7793401a6de8f9f62c1314116f8428ae754a951f8661188ef3cc559363bf3460bb643d3292a2adeaf55a5682b8a7fda429eebbc44c3ce3ac5b88c16411e66c1fc574abd135b8b5a375ebe317a6814f7a7a9650fdc3bdda3b10fc71f01b99a3c97d531c28b74346079bd8399c1aced4558cf8e5dc9caa518ca168f852f5bc5adffcaa2c29edcd2a5f8bbe8c36a7a915d4348d8432a4f951988878bea9df52cf59c740339a8e2bf6e901464e5a27b50da6c4c4245be1d6ed03290b4bfc38e317f1aa86b357e9b94032078d2420bcc43239cdc442f92763556594ac989e0737eee8f852030729e9611af68e016a6a20254be38865d44737f0a152b4c78893ee123521209e49575688c07d8c9a0ac5f6b7db37759a10b24d3b4448fbfe4d5b718d3dc95c85feb0a4d17b7132f7f2455921ff73d97629855b646a3626f0ff9f22ffdf18477ace0e42f847e568d85d2c08d6bbc351e26e544f2378f9ee9aa7bcada782c022a9846d0794bcea81792b721c17cecfcc71a6caf871e7ab4f9dd269363c5d25cb5736206ae395ff417e1a72091e520938ed3f7736345f3be1a9adf97e7603ca60774875c7b92f7172657a45fefef08fc08bd1bf2a3fab9c23a6285bcaf84f6a33cb23e033c0e112bd0e59ffcd25077a18aeb0ed86a0e56dd1defefbfff53196e840b30259b3db9791c78e95f176a0e8f8527fa9d704274c2618a9f26218dc13fd615fb73b7c414f30fd7fbbe1b218f084ccc162219653f03348037fc7501869fefab99ac70ef020df59063ff957b4c1d751aebfbefa5e1789716617d74565829c77e4ead9662e9aacd87172c55fcfbbf12853bb9f8d60a6b34604e058de97a09a0a4c57373b8a2773d2dc02e8257747a3372b93327e7d5385256e72f539a3ca48b054dc075a5ff2052d3d2000ee54a7cd754cfc6d0657ec244e1f9babb9575ca4e2dee4ea2a67d87add271618b12d9524f695ed9ca18856446e46c59c6805b0185b84a0ba0f944cf199fd76cdf572c587a479720a0385e83e36f08d08e0c8f86ab5680940fc4c72976df4d90e4db0fe66bd4e0368b9c326a900f7b81f15050e5238833cdb5a2418971e090a1c93eea79e11277a14f49a887d0eb6732752ecf8b03cfa7b5d9855796a463ee69551f674d47cbbdd5b6474d15864be054ad0c9b948e71257bbe1b66325dc5644637e2dd590043fd4690025cf1c8f60d3af0022a0d297fe571900f171f9ebc4aa948e57aea2f36047ed4ddd709f3fa447cd49107ed7bdefb003cb28c8ce01c408af17116487fcbca5b638fbef1fb2e95ea81c135b125671c6b0418dc8c48bf1c3f72ccbbf2b517540ec67d121bc61e5d6c6b03cae88b023241d0f985fc6437245f7e84c7c07b0ce6d661a426294e7a9a73d3251790770c0db0e1961dc2508a40dd5b2b1d14f72c6e1a0cf409a1267e087c579f8895c1a250da2b2064f2a9087744ef352dab9ab175877b7221d600b28fd98fb153b3232154fa52800e9e3648d5a88a538601441a979a0bf5e7b6da395a629cf3938e454aabd64cd9c2106253587b804e3c597b7b1264a23c458d10ba88990f09bd0de2be95d2396d429f6e8fb456fa66c621296f29ea56ebc53c467d3018811c563c81ebe1babadedcca3c3d43a891fa2c775794a46fb886bd8a496a4a16a1360ab56bb7518a390c9e408d7423105fab57c8e88b093d7e21b04f2f741caa86868ebd8de2d23732cebf27b0953b1c3ca84788f5c176d3509f4027b5c6ef7d67db6bab9ffbfdd854bdf4e3cd435192e0092156e611fb6ab7eb8d64766ebd7d0df88abdf0fbefb32c2e5d916d9d40d229bfccd6090b12525e2f34054e0f68debd043f3f8bba950b57b3a9d7d65beb7308c0d35fd8bcd9df83d56b12a68da1c8de2f9f4677571315078d69e1e74d785e65405eb7a685cfb2e319751cec3ef7e279c12110f504e47fec36c7965ade3a2fd553b424cb55df277a3c7a722acfa864ade9d02a1350fbf15c602aedecff906475c6d6a77c108a8b607653063cbbca040a0cd5a60993b5925d18ac67525d4fde87c79b63e150ca1689b124f3c93827498697f7891351f0d7e0ef5f750e3c4704ddcf6c2e6e07cebbb325f459d54b843d00236b0ff5fafbe526e75243b56c14ab46fd6ccf2025bb5228e7207c317e5e10abf7d92268405e98fd33031fba9d8534fc64c85680503d0aaa04d0e2754eb0fd09b5aaaa87eef1479f9f959101cb7715c6ccac65c98c6d944c74c9f734f6691d13d1f11cd3d0a4e125359be51a113ae205e9c6d706eae790755b4bad756ae6e9c74d0a6ccc998dbc611faaae20da4d1f8f7f5c2c86c30c4cfdf5671c750e20c94d1115868e5dfd4daf65c5e2baa622676a0427292206d6c9ed5a89f2ae469f1f77f4cf37d66d4f9f502a1d49a7df751b1c40dee40559288d72e7bc04f7cc4847a27401a059371cf7dd1b88a9da332eba9b1e797dbffb29b3e7383aaf62371acbdedf211e911b858740354e5001bd435625368baad9962dc4e12bc9a3bda6bfd66c47fed6ef601ef91c4b5adc2b1e02289f884b5dac2e3874792727574e5fe57f6a65ae0043ffc94396e6252a099cdfda9a30b1b0cd4e99ebebc1d036bc920b3a2b8d17e9a3bbe41f5338b260fecbd26937461af387df703d32c2f36f76f8e2dbf3bea8da2dedac61ef8ed45f7f46f87b338617ef9bc0c736d5685bfc529e034d190f6a14b5540aaf78d0d4cc2171bc794b65bf009e5af6741dd4e0bb5b8cbf442eb2e0e04fc1172f0e0ddbeba7f06a150ab342e8dc9a4912c3154c5f2dd8a9b4cb2bab3edafdc5a17bc85ea80e69cbbc3a5d5feff8d93da08482911f881d84180600db98d12020adf91b68de9601f1c097605bd75099228832dcdaa71ffa32bb6f2cba40bc193bd52c7d80f73fbf8dd8eae97bc283dd766ac726100a54080496daa8e3c55cc510c99c9e543bb2f40d1c104da00c51f8f9bab1228a665e2ab85c664676fef743cd1c61f0d9b687e93fb8f811dfcb53315a55a72e1b02b627a211725b28f65ddc8b372aec55e495e0dbb9f79309a4ef8b94e209fbe32308377e3e44ae806d705651bd5aa298e80068f4beb1c9040952c9392557f784e5287c3642c45fc372aa9087f6a130d4eaa47598b80b44156d6a2866c531cb447186c15982e4bae8017e12cf3f757fa96e5621dccc8999dd5006fb4a4785c47995dd1d979dc0d40dfcfb4f2584bd3fa517fd1e0c2a63f89ad4db781955b04c98f7a9aafef33908374ccc28d46f0b575a0a34c74a05924c7b6c1e5369776cf7e1c944fb02da4f5639b6b0e74cd10480652ceff417e8021bea69b8ca082fba48e86f758ce2403f645d81e144d697ac65792bb8fcfe4861dfad7a8a6dc3dc4881f64a1278d851fc5a9027a06322f74f67eeb39d43cf13d8f7cf13ba7514b882bcfc8ed63ed268bf68de28582e696f49070cec93accd5b9543ab829e22de5b5ac8733511bfa63c587af65f5a25310ece7cb3434b7c6272841f62b3d626289bc11e5c3235a3a36079f69d2e69a347466a8ce0db3b2c89cc6a55e501022b60ed6a7a735141c6c1277e9a20ae278a1920652547e8659afe3a72fb75a76d944b6174af2064b471e353c3174ae7b22a755b2cb3b9ea64886c0c4fe75b8c7d56be3f10d103ba5535978d6f2e90d92ee8182378f46f02dec4e5c30c6eea2310ff25edc16f6e5078339c33948239398e97ea6aff1b1d71858c082afeec34e911d83a3d342a5f9f16cd73d1293d4775a7349dc75757f2cc8d4d0f784279add9decf4481b2c88e3ceefa77fad2f2d72979d1be28e4e684742d5dab8fbee6fc373b42723771084cc0535dc1c711f23aefd9e498d015391e6489188e435985f1c528b967dbef21dbdf04b87143c756a4af813f16ec52d8dae5ee886e04424aecc267a5ec3442e97e194e9fcdfee56add03cddf78dc77a6252940b12bb3d9deb69b90f34120a6d02a98bd34a6a7acb9f072e3900966cc795219f61fe5a4f0135b1440574977b392d54d1511e5551a46c89ab8ce74ee74b70a32eb4b25d6518db3137c1ba0d2f9eea77338bc0a3f6fd91f6a6833edb5f590d3cd5dd61f0c584e81474617f41bcb91d6b989e3ba814d54fa006d4bc1f9d8bd3d2d841d0c0bcdf17f5a7e2b0aa9b9146dbbba6e666f65418d9729c80a3709cef5297d6f90dde3501b1bf4714a6fcc425fd8efe5e9a5660bd2aa817b0abbb53505efb76b5c1339e97b5440f1cf733ca1572f4026e790c96a626ed576d5ef655142822cd922837f2b48b13ca8bad0e259daea7e458e886122383dba347f168bd312cb9d5506c3d25c9c95c414680f568342947b5b480ec62750d1a68911545e9cecdc63a669ebc662bca2abb715ee302e02c64e64352f6eb343acb1be5535a3c118f9b89fb6457a9a49efc1a6fba3553a5e27f7bab6ab39b81e4d66e7ea42d9c0392eaad7d54eba64b1151addb951fb0381ea991515a58d0c16262a7f22af77a8ef6b8aa2bfae0a019b17802fd29e9a69556e98abb24e1b8d5238571466bac13e7263376c201dc4b5d8d39995692e22d3fabfe19e5901da011b2c6ca0e53d55f6d8edd1f437acd7d82a24648ce8a7a97c6818beadb9b4021abb925a0d843c25de5f4dee99cdb0dd7e49946d79eaff9d195dbda1a0a00d97ef61bcfc885a481cb4439fa05c38e748dd9d8612058ee5526f1d4468c4b5af56678a887e7242471cb667d6a6d5f213a3acd8a76616a7efd0cba568ae48de9490c59dc7a45011ef73e705cbe7bd6720180107b46a341a53923173429d893bb1df1d1a5cbe9d78d11b7710f90af7d9dd69f9a60dcedadf1dc2e5a0289730af6a33a3edca6c40cba0de76b0ca9ac6881421c627ea78b1063417b68a99fd402dad68002043535685e33c877341f51b5d2775fa0b2cd1385f4ee6550f6227a87b4780947e1c4d4b05346232e843aefebdacf38dab5e569d4b0d4d32b4ea9525dd9e8fd772494b398f93d5296700de72822d003b03648c27ec8d5979e61ca050fdeece5eefd397926c763b35230f797aca5e44201e2283736e0555127610c28163ac4ba41e0e96ca9080057394f9182db40f9173552354bce67e4dee20738586168e9da7e5c9fd820f5b34e131ea1ec774f4c7ded690ff79f7011915bfd1b1fdcce0bef225c1169b253bf6f704204e44a5a93627299f8d3cc4a30d7a5681ad4cb285e935e055e6a064fbfb826dcb038ab6aa1eb75b09e90a4ca56d72a6050209e9938b06d1b027fd15dc60d0fcf985c353e0ac45df72494de405c0c5b14548ce20dfa377b5090c2dff75f0f2dbe2f1cffd9ff3ed2f0f2bb752e23f48772f927d1d38c1fc7bf66a487b0291c7e167a3fcd18ed3e029dde0d82500a3cc6d20605e945e9b58d7b06fc40e4d62312bbc8b19eb51d57cdd804b884ae2ac649fe8d6f58fb2c41227624857cdb19022194b82fae9d25537946af4b57235f9a3fb114d4f9483a2414b1071e266df61e5967168088f482c919b9672a280500b8c636316c1618ae28ac073978d49c25e022936372b2dcf6ab8bc637acd544e00615c581d182c31c5d1d871c13466e4cda0173d38c3e58897bad03207ee8f971fac27eff032746c69a7671ad63ccdaecbf37b7f5de1f10ef1b10f594a82498150a28cb11e53e1dda801a712cd0cb9f3c37e59dcb0f130c0025aa8749035042a65884236565a1b0ebce871883353b14011d819710b6107ad051b85073fdff15e1163417c3daa2147b08d8a11c575e7f15c407ac417087c6aae9ea02bcd45693f5911d79974b448c1ad0ae779a2aa24e40b996078c9e0498a40d5a52392b3b921669ab709c4cd03925b71bb592328bdf27d847f04c38b5d1687f1e7519f4ed22abe5be517a60680cc00bbceb14a3de8aed5cbe20ab77f70498d545c94d4917dc11e21a11aff83d8d285936112461edfda524486c7a31caf0894fc670ae6d712c9a291e0f4fdac3bda5e0414bbfa27f1fd583e9770f979fa8bd3977ed3986f5ae6499e0f7825806cba2922d412aae917c05132d261881eb1c09ded25011e5d6e39970fce298c5c4dd54d8d85753506c13deb43245b3fbe38a56b1e00c907880e718eb16111d3f065aa244d40c9612310c1a941fb9146ccd26f1db9d2ee0b2fa8c1547464f8a7f2dbd742a4504fc7e305f83b1315b67210dbbe03bbadde1432f0601af75aefeb3da0fd776b5da493cb750c43a7db60e39c938690cd5057aae77a77c1066b3511993ed3991c4592bba9dc8814f2db914fa5417bb1c6686862c9d13c73be855243cb4c842f77a45f8d7e0df85e8efa4a95b960de7dcdeacf6c10a182a56f79f5eb7d5fe4f55994261f6dced83c01e93519d1d6e2341b32c34ce24348039371200fc4bc2f7d44149903f523e2119aee1c521bde422d36d88bd00b175070214fb77a28a713991032b82b27385c844bca042d55f52b0ec8090ec61ed18e9204858ce22fb536153b06630e51cc02f80a6b1ac4b1f5322f432b0e70f0361959ee3562547392add002776486b3b029e40def3377a522d309312a9b4f90cdd3b6eae47dc0c5167c3842f20784326622867ac5abe26da6363cdd8a35ffa81457aaf7bf2b5905912d81303f9eb17590ddf4ffc31af6bcd70dc14ef4dfb0124b55276e968a8f7765454639eb1a460c0b89b837daf25845d9e9dceb763d50e4f7cb61a70cb3c32ef64c80954a177fc68e6251e7f91170cdcf9612d365fb4310f6c113ccc3b76415bfbbbbd6cd39e4dda65821193b6e2648d653d9b033851148250f1735ced99feb357cbc844d33b6c625f08a602a6651f95566646d28dc529ef26ff4d2feb25abc0a3ba34aba4250eea5e86116962085fab67d9a9f32979101a4212c50d589dce639c8b64a0f10f2390997012d5e6883c33ad6b331097a08caf100280b635359daa797f082f38ca5580cbf330f8349381ec4afb619b8350bd130f3696fd366c6a59cab9454767b544ae7094a6c729716d285b3fdda4eba7843fc1bb617e5cd2f429252eb599979550e1504c1e223ae5a09b6a9555262894d0ce6d4cf7a4bc37870a0785e01f59113def0175d04df3bdffbace3dfda380428988c7e89dcc5827feba54792789df17c1bd331c00b54a5b975139256161fdaecdb4e08441e82f3d4cf2f8a00a72a096f7d63d04fb6de9fd9171d4e99fbd9647ea9ee3008b198373b29f1418a6f26dba02fc4d2407a494341c5e7c9f1d870ea759a26701c446105e89398756f85df248252a5e8a6fd1c9e4c88fa34390b62a971b71e3df4a22e044901077ac539b9a6cda15d6e69ab53aeaa977790087781fc289c5ce4c74d4111b0e1b128371c24a6d9a63d71e67ae05b360c031605fb2c8ab79785b5c0a04897e0063a2c36468e75e59a79a3303e3dd9d0166f1d8f603f0b1a6945a0b2eeea2deef7742a3d1bd36c9947be62d5dc89479adfeeea3b2ca016758d22c308c812487f64067e7a6ecf1005979730dff33732fa580625ecec003f38000eca578a83a7557a9d8903f75b0d61aa0629fac6ba3eda7f9d8ef807fa7dc962c4adea4ade258c350881b54c1d9f0a169b79736012def86d2722800ccc158bb1346f8a5fcd961c45dab9ea0be330e4797b3dc16f4b4f11b998f112b89b81f7e9fec39333035561aa41ead1f234d5bec125aadcd3ad3eb85e9eeeba9ab3d8efe7837cc37dd9855f2acf9104ad7f4edf96e47854330a74dca880415a9524d1b7702405b42b7d927e233c070afd65aae6cd2d61c574d4dc6b3af18acb54d97fd9df086a322bee3ad51e4d1c3f82d533a90aeee4d43e45dc0598cca94334a031b4148a51be12a43d7521a1bbaa628bb4bf2d9a31dcacdc6c552a980bfadb54e4a9d2537fd247234f3182bfae4d007ba6295482a7bace20c4388f03e81b0d51ae73acbedb3a364b5dbeaa07d32c97cc76cae031b71a440958aae694fec8c53af1f5bd9b35c276df76cb5a6a5dec0264ee8fe754ff335f98e448ed4cc88955c764856fb06c94eff79f78636945abb4c26aec120210c40c6f3c2d2c7e3be8f00ca83e668d94645cc682705ffaa20d1a75a15762512c188cb1aeffe37b2963aee6704f98006adba78d8ad02e66dfa8f3aa7cc2f4fe085cc8e88bb427d53de8d2f0a3b89f99cd4b7ad74b49f0d642793fc2f76ebf30281a7a7823861d09a69156dc5e6b6c7fa7ae7b9cde87c72146e26641ac2149d0282059608e18f9bd12db17cfad2cec358f1d7a1d8e42b22bad8c78dbaac1047959272cd8886f21fde89b136c0f2eaf6a96e5fcf4090b8e2e52a8026260d373bec484b3a394abfce87f9669e8ce22cb4a1a00a7c7f309db1d7e061dc3e59667a2c1cd0ba1992db512eb630384d85455b12fff1c4c648b5e68e4d74c305fe174dfdd62df416463c2e7cce3de10b75ac52b924e72df1c47d0627b3610833681c6c2ca57c1620521d1102c42fbd9ba1d14479caa53dd006f9d51e6871f9a3ca2a06b994ab34366d3f7ff88043348fe9e3f43d7e419c001b7d7cee52c392099a40d23da35916459847c740bd1575d77f7a4e32486a6e431c35b0808cd5d13dd090c71e437134388beb59e81b7d6cc819e5fc69cb0128972277fa9da1b4f1930ff74a5de4fa7fc97526e91603bc2a766ce3da84df2a9a24ed2f84f3daf0252337d9351d9b1996b9c005e26f403bc97e799282235a18d0d6576f7403d3c29acf9b9f8485778a58ba353152c9c45a39ecd91900652896574e4a1e9ec3d497418f62e26299f7ecc0fbb5b00645168dd0e938536c3ebc188e4c6d8a0fd44be8e940f696276738866c851763ec1dc941a5531f7b5771a2f9fe1fbabea216e4045c60bd5552646a8c26663b4e5ed3df28f0012b14762b712a8c16dc10129bfe1461f45d6eb87084ff3646f0a088b0c99d9fcf346b7d4454c8456fe8b57fad424e6124e6e9340519feba6a9a57a4da3db6285d3dffececca5f8ca4861d3d89dceb1ea8b18f3c87798cece808d71e4b923389337fe1c4eb0f82c77094614abc39dfcc25c5b21773b63e2c5442d9677f10598e94725d6f67cfc23f7dee79ca7edcf2bfa2dfa490b18743db0398708a2e52f9a615a6f03baa2ba20b989630d1c14a67b9b81fd97461f03a183387e02ab0d305bb8ff27afddfeabc1220644435123635c0d9403fdd14faba0195b9a8fb07699ad337533912417afd960370fcb5c86ae1128ad58cd78e64ac6f22daf4ab4ac6cccd0f3118a06ffe02cbddd0e772e4830a0eef3250ac860aaf8ab3731cfa90dcbdacd9946098871936acbf464f4633b28658d294e7eff08562ebd4da22d0713657074828ec1248e81f186f560491fc25bc593b4c8d397f8234c69d45d5363682deb69fec47754930682006f6fad8efe08859c3669cad70a5fc661ad26e184b81936bc1ff9bf85cfcc21b6d67f66a9a7261a4ceb6b30a90fdb6a227131de8751fd223893a59d02e03f5f21768aefd12927fae8b377ec795d74665f804ba93090649da47b66cdb6bde0f2608070abdd918924c241ede5dc8ce4e488c219154985d1228b4ec56ab0ee61d937495947634b702b873a80defce11632abf98818799644c49dc25c6e2d5278f53a7431dbbb969f83be0bedd967315e96f8eacb9a722bfbdcbcb386f6d979be33b629802c28113a8e0cbd7aa25fe3f6f3292b2acc6af2f768d80bd1ff072ae93a853e3f3932bd858771b1e885069b2c842e0219b2904e02b9d6235f0f3deb46e64630dc8d5a31b1fa54046a6bd9667a44a96be09e9c425857f1c04977335f77e54ba3b8655aea31e22d63796cf1e42cdd9be118962ed630df9b1b6f518114f5ea9222a4d4127aa831b8e449723310a4e84912e91a7455166545be1d0237038d4df6d654097281c0a1b223d414a733cee187018da00210ec035b2078f7cb32c67128f07faa13c7f2ea38fe8c1f4da3fa31cabcd299ae4f4333a4197faaff9c91dd32b7c811b1f0f7501f880ad48e96c5510009ad000106ac68cdcbc0951ceb8dfa9ea19f8961dfc96b9bd3fa8ed54c143d6c39da83856889e6a1abfa5893b0f5b24bb0645a7922c1f3e5c7a201076b339c4e3afbe660e8249fb7cfb0b0c0849c7359f97c2074b1c1b3c71ae45a7b69832d2d87184d2da3f40943a9537b8ec05b2aed318fd9585c201ef1e07ad56cff24ae3676724d047b5b5c1dda5d90e515c29a3bacafd6c954a8d02a29ce39aa7a8d6ea633f89823b7211a93c8ddd23e1dc94e63cb15bb6d60ca73365b43dbb7861bbadee2e9f978ffa3f823f2a0f04acac959e0782f2bfe74125749f96645e5f0bf8451350726cea5baa944cd08726bc2bb66509172b27e13a98d79974eb7bc0ea64d96f542b7f694cb380b253a5ed03d62217f6c6db3fec1e1036841d1bc549093f0c2f743725ad7f6eeed3b7998e84dc4a5c0dcf06de705f98dbf40d9ea70f3fe3f926ca3431997988479cda57c738e2ac8e6483c3268d45532823d32182d81a436a6b731a9209fcf27836040f52efe662cd142677b63fac7d9a9ddd2f7d1bad948272dc9500a60d2fe4f8efb95db3299d2300a97ce5ae97a85c1d496622827dff15ab0102de4e69bfe8d3dfef9bdddd2e86727dda64a1f8628c7b47fbcc1694b4645145e19151f8ee21b6e7c6c3d6abf9060879b7a3ee3430e088618e837828d4ded4da5636eff27f4b7c7d65fdb338e53584613266c4b0eba52b0aefb4786fdcfbec236af4775550ba901e8e1b66bf41a7808510054bdc8cf372d80c6532bd562ece1a0f92f678e330b08c18300ae4da309b84468a59ab3f9b8a5307b38876756d368d66203ecb53400e8fc0da9eb96bc396cac261f52bee3aa6cffc9b68ead73bb8c19044756d1a7dd99c7e42dad411addda9fa1616fdd6385cbc1b76a7474c1a3e8551bf79df64ef75049f38d9ac99783e8d31d86870150753cf9b72924dbf81c21002b1cd2e1d0a26b8ea5e1218104501ac2b1ba7f638e0144919debd272f788c9ca19b74674de3747247680c3b2236191776b1a9bf38f073ddb0fa99ff8634338cd74d159ab4480ad02d64c7f66b6b9c9adeae6c649b2ea488ccf35f56240ebd39a8d527d9f54705f79863096f1a4278e788e299222bb7dfb88c6a6b2d7c80187ac826f350e4598af8fdc7b2db7e4d3562023e27ed3405bfcdb43e4ef28ff916c91be540781c750438f9913ebf5224c50271fe72ab00482b7a3589695263fa51354fb3cbb87563752c711b8e9238faf69e5dcf3ade6def017c9c2be9e52e05fb3be33908b7c75a9e254f3219612615948fa92a3db58c6748f73b1c9cc789adf8c2c19812a15294aa2d72bb833e39e7e3980bb06d7e0247fe38b255b0a9a45128b1dc7717f53f88d4335ed7683fa8996081817d16996846c56d771222e1ed0c1493f45102d31252e068bdd53ffd4221e35e906e8baa66183205294f8a39710ce90c9ec40331a2c86d47a329d16a1a80e7a65f585473c62d0a057ae5b5ead1cab19c07117cb4ddaedcc7d124fdc5d3f28428d482c92373ea2ac443075ed55f0d5c5b075a5837376fa422350bf0396b03e82ecbf967fdda8fbe187106cd7ba02a0550992934dff69285701c1de904674f49b3e354bd2ddfc35aac98d3aba52d00455bce2b81e41cb192a5a2bf460a159868aea32c4eb93a93a1f911101cf79df2b477f9541bcae62a1e650f61f1a9f60349be1193dfe14f52bce737d990a8f6013f24f07580a325e4c71ab021974d8fc5ce22b3acd4a07da7cc4691d4bbb6b9a0d47c58a06a2f19a9e56de44554801be016746299197d00bf29e66ab64cb27909f28d4651e756e6c3d5d699ea5f16fb2437e91a91b4ede1112b978de76cb816c6a83ac5f62ac9bca612dc6e71d1328c8314097cd3b0c36739a5a9c21e9bd0c41e207be495ea8bf3b635bbd78e7d0f00e20b201ab5cbf4c6f982f65fa6ac527595fe11f7946e4a585f7a65fc18861772ec6441ebe812841ec764e508d8bd82aa6fe5e60fcefb27abef541f0c01c0936207add439e11222bc70911af25c4ea790b6517f68161b849b2f33551870c0e928d5e3857d865ce863cc8a484a325e2e667ed3433fa10e3a33acef922583600e94648250820a0d99d0daf1f2be856104c92ddbbd1677916d037d5ccd0e9de6480629094ad0b651415319d4db66deec9256270448a3571d82ac710de2111b500b8cf37e08149fd65f67f6362f06116e3cbf504e7eb7413f5ba90f15181db519dd84b78767f1bdd435a40eecb21ad576c483e54a068dce2ea7c9f1aa41548a5d7eb6ee8a1c7ab361c7c34900e7fe7e366a1a2c48240d9eff378c793bae58396cf6e0125926597abc29c61409ac20f4c0e58c13be336239ceec544adc5188f4c09af69433a943e602bb5b6a60d765fea643661141b92864e7a533185217fd9a7746f88b3cedb86b896956ff9923aa810d4526bc1d22531f47ff914ef7b0f522d7142c5a4aa1331421c0afaa52574a77245dee07aa01d9b7fea890d32715920ee2e8724417ab25fcb7ba1e728406f7867aa8a9e437613a2831c08f05f15412a0cf9ef0b482c929751b8c10d98387871df47f5dd9db6d3154f54031e97c474ae4b4c87f6ef4e0929cce491cfaa3ae25c4aee6d5bd434e74cc99548dff4990841f37a260afed9dcaf727dee2591da046a299e89ed34d30b841171473c47aef7aef99ff0b60fe7cca8526118a072bff1383f327a8a8a374a8a55e50a6b27d3124f6d7c2622c4e0f5c6a5040874c14bcc93536fa1466386c0abbf9081a9b4086c24a85d7b29e78c21a173450445e8fc01555693f16cbf0256325800ab56cba5f76cac1e1f744b0c61223a5db57a103d525e1a3721a33a496129e114a7f7655fed1e248f66888b6963aaad1c809ee684c06e665dd2752ae5e383b929d85fa7ef712997d4d471fa646556da553a3b611cf6196226a60be931cc3881345a38afd304f6e78b8207aab876cc628abadfc7bcab1df4022810d01ca5b779734ce5687324da841579fc8ca650bbef79964b098ecde3028ee388d0ebd634154ee634bef20b07115013f276c98f348bb163a892006241e5c2612f50b44cbce09e224e9c17eb335c8581f0c501cd620b0bbf18222250751a2f9a47fd4a02a8839f2a9631d9e1cd51ecb67fcbe2e166d3c7063329a499923285e114009bda5e7877e6e3026a3a28983dc971f395c3e9421d6f47c25a3121822108de275cc6e43fbfcbf0ae1da03f837389e49acb43763b2f66de35958700211c1462a3ad23a6c4f3e3b97d0215d3e4621a4e4aec94ed1764bcddba18af92a96597ca78c6b5e82a3a6af5e37e130054862cb642313ffba64930086a231ea5c7382e3abaed2d476a0a6e999714aaace5694bf03c6f34b3a85e03cd83ab847ec8018e587b618fc959f5e8c806cfae5a6672b6defc46e5caf2530a6474e7b5665e46400298456e4ee39acaecd7f7cac30b9273b634366d5a64e0afffb6e34a65a9a7e0cd7531049a4c8e973fcfeb856af23ffd074a4a2f53b3230480c4016f59daa7b297841d09791fbbb182f2bd4daab15ba29e1c906ed66fb7c9de46fd3cc3cf81d4a4f8f553ac3e75a4e6ff8baa25f1c5eb4188f91dca5d7e2883a1ad94442969c8e051ade368ba2f88b075bd8b6804b87b5af2a158f153a9cf1d8eb7cf273592ab9ed213b9b88f8c9fab9f148de2e88331df87cd0b8a57fee41d58b85015777baa411a914c13fe6622ea3ab55b3562ceb4c5c39f12826ae72c0147c55f0a65ca19ff4c95500edf39dfbeaddd8c5abe7b26b6adc71ab27d71931d9091afb433ff5b5394c9d7640aec68d56bae7234a65554b604e6fdb84f6771d3524888152f272f229f055b9587ee96aba44a7fadc9907cd485a0a37f017e9f89b9d3781a66feef17eb98a69dc48e80c468fc5d57d27e1e28253102d6288a5d3e3644c928af971167dccf1db570574ca1bcc72fcb3e98b7a26c2b2cd7d0cd564561abd9457e659b3d8eba39c79c5aa891c42b2a5b2819a592583e1cc93002adbdb410a978c94d8a930697f4cc4766044b0174f2014e72bcdbbc533e0454c640dc81cbbd336e5a2a02c9d2d6e7ab2e84c3b4963124b0b166d1bc87461a67ebc71d74cb2d5a24cfe4ede9f583177d7d4e92a999fea96c35967a3dae0590b3e4670b53b2b3aaef9b84f584e199d551af2e9f6fcda868e7cb84dbb6ab85de2528792c375db9659bf11e39d231a43b27ad3678606f52c5c2d436b81c7d01754df093d9211dece15febe4b14cf0974a02276572a8e7d7ece3db8134d73b506611a5906a55424b02432fc8e532143cd26cc6b0eae7948aee3d7104a5a10c72a21855fcb6b43c34fd40dd72faf96afabe3f79c0a10db9f49dcfcd86c9c3cef0903d66f8f6d61618b003b4a91c75125d84c7d26ac21c0adc1ae33e9b20e5e5ac28d0476219d9be2c8a077a26ce3993baffa751a5155e2f2323a566ca86faa908d2d9add962e81521e09468ee46843989145a03d5f8af8d9bf9d046ffaf44c4a6973450538e8dba9fff38a70aa3db470c0be0fc5a66b5a54ab96a1cc92bfb6e4536df1ac453428a4adc811cfcaa8155d4a63cb5e5f7ba6fc619649d2b525bcde342295d7bd1ecd6a3a078ec4b4bed479f2bc6aef8d83d7dc3ceee954781e475e8c882213c8a5d9dda106d150d1bfea2a6d311edb26873dfe8eb93569d5de6606670313cc4e1394a9d0788290d1e914d694cc4d73bada2ce5a6e6784d19eb11a8623b5cb4b279a4b66bce7e4ed1b591fd448591602c31ac3e1120d8f08bccead5275ed106611c58dcd2afce75ab0cf6443d61bcda79da60e7c659817e94a28e377dfe41adae62c2829a6c9e6c480f1b0eac4c417a3969224f2b474683d8c1395fa543e8c7dcd9cf250a3f9bd18e3b7747ebfdbef0bbc311d27ea97d8fda6792648af73c620121594ef8171c253f64aa9633c56cf5e46e1fe54f13d5ab9fdff19fcccf73c9a7fa0e3dddeb0bb8020291ae658ee7fcedce9e845f0b76de6a1cc37b6bfab2df102e09b6126a973f0b7391406ce6cbc136af48efdacbef4c3563b72b33d0f17ffe1b5f1e070a7bbd3d1b7361b097b3af68d1028cc509a1c802e80d358bfde524a77cfabbec010efff1b3abaef59b5500d9a7b20b5a0ad55a898d6c6c4d94cd9a7432abca94fa1a6ce1f0a6924ecc9486ea726df0086c5af459d30701c8261e325723952fda2a351273755a4ee82f3d1dddfed584df555aa86dbbec4e48bb1727dbec3eb470f4a6fa13ed8e0a46cf11ed59c479941ed41e279bff169a4ca622378a86f8db25b94f25414817a0638ae8334bb99d3db398d72388d311a42cbb2a6ce1c3170cfe49386cb5dad8e90cfb9b75aa8988f94d0c1b1a014a2ba08f105b54b21bd3e39d9ab924a5daa79c0507f4553e6d561d73cb25cecf5cc0b191f42d2710cd847307c957969924866bfe8ae3f950987947477abd6fea8d6a44a39b13cc131f3e91f8b9545d37c27d8bc05ad4f1d1b8aafb2987ac453619c05d3f6a2ec92c2a8f5d2b37ffe3e8cf6fe810e3a171bbb76a87dd427ccabec11a659ce228a039f3b80ecfcd5d453c0350633e1d9682ba1654368e1ac232d9b2c171d11f1ee5f62eb2f9feb238f1d09be49f344519a9973bb67cff644d5a3f2d218c461d8657cbc3015e20c140f702fc7bd5e9c981efe444346b616522b7c119fa419e8dd782fea02ce494851b6a18993462b657ece31e305f8d354e1c5c912246fe07bb32dea0016620295f14fa2946730026901b905eedcf545a88a123","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
