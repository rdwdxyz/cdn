<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ffc73d8a28ae9622c6af305c451615dc6322b325cdfc69020a8df5068813ab5bdb83af9a330bfdf5a7abfb22e76d1d19bb326ce797709ff51748c89e0b2a80f986e7b4bf9e3a26e1b78ee6199372493731b18f8d495434208097b51a981922c61a664049a1b5c9bc157ccecf1592278b47f40ea7408d86c18a4269b3819ce86ed1c1a9f7ad74f38ca79a9c05a53ba5c746263ab143a9e47b5d2bbca4354ce270a66f33f8550b756f4bbcec7e0af68b3aa9a905610c9536b18d7130b4873275510297f08e45a455806dddf5b9eb66e27c280708e73b57cd33f22507b6e921a0f8251c3e2abed7efdce154db79efa758923fd836e804981cec413afd9af3d3a0d1ebe88e7c77128a1f1103f15ae3e06ed3d30e1935b61a568fe2f4263e7cdfff3eb18ea4dcea23514019c6ed75c80889548c8585bb42c3173333c951f2b10ac01d708a558434629e436726b3d7cecfd3bac3231bdd618c6d1a71c28d309110a3fa32a6d7448fe42e80dabd6f68195dcf8e3553267e7da2e992f1c36aace51eda33d37dda267585ca5d3ce5072efc74d44073c2e61ab2c02dd6d671c1e2759b7676f35155cadb63f35dae6758b26b44bb39212589aed0690db0e8b5c0e3f51c9bcb46c5c5599ef3e192a966e8307457f99eac07751dd1655e91aa3190555a824d5d77fc521eda683970ea5b378addc1581715665f4d1d156049c0db5e9ef3a44b9eb74d000ceca914d967f78055c6ebb339c0d0dd623963641da51c3cbd92b632fd71da5ab6de782f61cf78058706dba43d00203e8551148f2e969f216e2206c5b229530dc36446695fdb6ef9f569bab13bdef9b165438ee5f103d72745c29e0a39debca52cbfe251c0ca22fc9fca2be245dcb279110fbd500a399d4924f1d9b63b2b91b3d256637d8a9821e6bafe2a3d71f756c19e44213fcdfd4ee88c1d170add826850d7e5debb5f4ca112881af6bdebd592a28a8db0e52a044f6a79082f53aa49e0b7771f630f8daf74391e1c57154cea54ef069e1ebc07762871758b0c9b182864d7e041afc509925752f7a485fac87db21acfca2b8297e7b2f871bf6e9924a28d5bf7a86bdfe15169de2c17e6bf9c6f85ec976db54571df528eea7446416f1fbc155d18431d1899742a880acfb747577d71441fea42211edbe82db35d9989511d8946149d5fbc641ff2d4b28d2ce076e78a751f5b21e6a0583d8580081f696c3ccc3cfa5e102193a4a1dad3e24354f57ab63a8af95382f40efd9f47ea256b5b5dc8441cf31c621d2afd82d8446d3dff1187cb5337fd81a65dcb7c1f81048392a14e1da5526c55d5f019fad1c378514eff49face8e1c2b2c57bf2560fd42f3795517c1bbf2c07643effff2f9a9f60be9f9a150783bd122e3ac1e8033070fd6c64464e87bc46e665ba669c866618045436614856269238e316e3cac5d6acf789ee47a9ed0e6d32a024522702df4b4bdd9173ca8a6f2cd01be9c74e6c0f87a3b6fe7cda9f9273f5e7af8f6658bc7502f39707aed06c008c13a72cb1d7aef2e526d2dec3ae0db3e70c6accbb74dc971deb766d287f5b9965178d9ebdcf2f70b60c8b1ea5172f528af7a547a96aff67b1a42d36cce0ba1a484cd1222e909d1691ddfef7e578afe59d970e64b3e2e929404b1c4d7c0a7cbaa4129945d468e9666741cf08ba8cc030fab00892d70636ca233d089da7956b800c6561457dca1a71e7e269b91665ca7dee49ff605def0ac1834b39bc9eec8f5ae0325ff9e0f8d92870d7e6365e9018c9082e6564083f71a92048531d8762c85497379d4e64725804b5ce396d665bab267e59a361c1ed94be98bbb01e86056e3d1ebfbfc9cae1e42f3cb2753706f46f42e8a4a3d2417c3387b5c4865477ea63c5105bc1c702179e4bdf397da3c9170b3b27041d36fd1b772d260092ef4955d0136271170ed87192bfc934c6f1af225486ad49210ae487183eaf0bc6e6c3253e5b75a98f9a910adc58800d478a6e9e0b2ce48eaa6d0dbd369184ba51146e23b03f84499fa1088959c495af96d8585ea6035d538e00310db03e05504c2e84f9c4285c45944461b87c1fb7a6f5e58de3305478f253dd5e15012203a7698446da2b0dc717484b0881c28c529bf3c4b25b59ba22d9956dca402301ca07ca729d312673f9c3853f77d151a2bdbd25ed2b006e7833d2c992abb48ea5dbc11abd2df3fd372a545440f16ff8c9d834702d2325092f0e4a7107e3349f05e1a96e37262eee2a0ea1bb74fef3c2050c56b5be37640c824087b1bcf24dd0ab8ac572a5c3ba593daea530ae41bc323b2f7f7b917d7700bb051dbcfe32458c0a9e9545dd3650a75771316519138cfd077b8c59d48707f9b7c11c553a996f9dbe97981b5780e8fbae067be77936e21a2ef0a707e82bcf9014120b75b3facca299c020aae7348b3bca5405577991e21e0a92db7aa0e1f1d1e9e4488658e892a0a55bd979d544dd2f3d1637892347290d05ecf09442e2129571ff8d59217c67ca8dbb2feae9fd4cda3642a33c6894d99ab986f0f314c24cb07f118bbac4be4ad2f6a32069f337c282d0e12d3ebc21fce3a1b5767f040bd75260afb99907403fed719013dfe9379e52c3c06756fb81322a4d208983dcd0a01bb0259412ce3343cf8e27cdc98fdc08effe8bc3a0d1a944f111770f6b71909b3602bf8e97bddb8104a60f15b3f99c1cf8ff7cd0c078302652527ee52c1d36bf8de77091b09ebe4ac27052723e8a8e96a30664242df79aa2babd4a39aed887481e620d74f664c34d83281b38dadd029ea13f9d5ac9fef0f599b3857cf82462672344c46be57fee69383243f393ee1626cad0b4e322283ebc0f6315cd7e6de589d1c46c52ab0b7c4179bb1bdc560b0ca1dceba6a29eb787aaf4aaad18f426777e2bdc766e797f23ffe723c8a8c1f4c313a50d84273bebe70040223a0dca8b7f380f350c285f927777091da88372191af44f7c410a686749886643b55c1df92bb43e4d4a9617ea718c6bad5dfadff0080a65883a194e6e0a185072e0201ca48282f009808206fdacdbca90391be574a0e892152d378d8e1928a8b836afa189c4731b117a2a47f957ea9c01bb41707db9defb184203b0086784bb031eef0655b852f7f4c660f1ac6a99af70c1b2eba22cb815dc2ba7f7ef71d3f7d731e3f7dbeac79291d73e2c17b8f6d8a8cf9d38e520ee61820933e1d60c7c8c27bd56eea152d645e9380e81e9ac2884c89b7aee108bedaf2e23527ca6b3ef779af7d14dad1fed8ef74b112720a7dcf30d78f191c5cec5566a2b495697475654dffa675f1fd973ea2470e549eee428a4dfa854179071225272bc08854323421c29afadafbd0569dc168f85818ce22e24b070035b09f5150bc93ad0c6edce12ff2a7c6dc02cef4e58ea13ccd971df5b50243f0b8589d2d97b07431bd2f67dc318cb3c5131cbd6896156d6dfc2f3e2a0d10d1a0ea1b26f8f48342008f6fb93b5ea3d1c8333c7da60e55f2c5cc3fcb64575f0fa6a34dd75b5a68e18a646b33f63800d4097a3a81e3fd8084eb5e3349e1ad688cc42af061805661a2acd18113b0f3b27e29f79965be9eb3581a82b3b678db65dbd0e23026f7abcd1806252bc28ee185ab0138e1ec9e2b16f1bd3cf83604ec6effe6e83dac5d1e9072cbd6a9632afeb60dfe31f163ea9087fb1b49c5a048dfdb8d0f2911ac0eab604a7704e019fc16f28b42026eeb87d726e0bcafbc34ea0930968dd41cbdf20fa00075dffa387e74d57e4c3d8fe9f3ff9db76b5c10b4967e60773ee287e8cfe78b9dec51d029e885ecf9f62c7a8557556d808ca9a3fa549c6d092c489c8b2a3c48605e60c3875dac8ab78a94986c38cc2516de48878d69a3c893b4c45f242c8deb285ef0431f8ce4b45861c34ed6eafc6610d6ebec9def0ad1cc643578ed6052f7d76baa9c22e813ca150501ed7a474142ec6b559a90fd66585235656a625e474bb1211c2e41a9501c9c4c18bf5cc407dda7f02ae45fe68ff466693e63481639da0bd87239c97d62416b85c4c0741ffadabc00cfe6f0334a409743fe3faa435e31ab790768aafccc5a5552455867e955f6181ff503f88dbe04b744d958e436888a92dd1cc4106a6b7be7e83dbed645ba045f0bc462ca25d9ae33230a71180740e3795e5da1b8f10eb09ad7a7b3ed23f9ad04cc59d932cbfe8d3778bb2269d573187930316da5bbc9eabbfb3a9077f93192222e062aafe798edb2808936fc107230099b312d73bdb91b75031a62d62433956201c7ab2ca79dff8158a8d739adc82e1efdb71c3239856cc5d1e0f98a3c396aee8a7be3453fd14a5974fb754e3f3ea5b3be6bb3b20debb101a225cff7f36603e42dc652ca6a59c5ab78109fbdfc8701e53c5ff863e145905dbb671ac132afdca01ccbb5be79cdb55b16d7d730c8dae6c7ccb5886617b987077efb3b665485048e211418c4a556b3ef3d05f05acb8afcb3ea75f3b11f43164354f293b6ad21289f5c261b5bebd25f95f1e4a295da5d12df15f8bd74602f7cca6812cc2c6b945b97bf6063b8dea0d20e2f8342e9ecc80732c5b00aa92f7c3c0f585604cf2ee034d2c8a3b9462bdbc67a3d09f8c5f5ce648b2a09c1e2094b112853cb17fcbdc6feea72bc96f38ae9ca335af758e533d7f3fe330ed6a36a21e6808b44bc64929e37a5563e26d6a94e70ebc082c0f1850267057dc113c77222e3ca128256a39d7585cff1f8a338fbf576874f152d82a4cff10ff101764fc1ece9e0b559445a0ba05bd166f2d244033929bea38178a22d512f5c86473878e500ec4aeacbffaceb84824062546a49c0096d1c84ef2fd82945fa4a12874c618e9f8ea08c1b849d03da8cccc0d64ee3de74bc9baf454778544bb584f7297a46f20e613f2b82124894ce8248c21a838d81e7757a79b4d8c5c3e912d219ca5bdbea362dc800d3c34db07ffa8179987553585bceaeec85e10c89eb6014e281455e9badd5994feffd95fb4946bfc199744a2d974b08cd960e274edd824b3a043412ebae318c1b7d430892dc5a6013630309ef7dd5d3f1dfdc94ad127296d8e22cfb11abe81b8343cc436c2a102238f192db75ecd9ff51edf3fa810d2366934ff6e9bccabe2865b97cb60b9e24fa24dc201dfcf4a0fd84055cb230fa53afd464841be4815b8754003883626176638134c8e35c4134c1a944e355b39eed65fe26857332908b20a5949d0ebe2820e9b2c08a5b88b6c1c0374735897421d030289a142071f2595ab2c0109ba20cb90a18e543ab7f07a88b40f33243381a58a06c102cb9b97e7a20afea209b03008020dc21be4a0cf5a01537a92cc8dbf34b3e3715b1edaa0084b55bd6ce6f3f85e972a8ecf4403ab272d67bea481956e464ab6568148ca3c7a2c94154c48cafa05ed9bcbcb272168906ef044f9f6d75d0f325e738501871ea647cae36dc63ee2fd94e906f544c9177bb7fda3eb927375e123bfbcc682ba4a5af24d6917a625c0da29a6ccbb13e39232a813782fbd38b0f6bd404a3f05565ee69e48645710dd724521d7b6bd17d3dd5d905e60d852f95732f95ca327137fb9825b77522ca4f540069c78e75848770d047bf4f037f588796eaff0c834e1e9ab4bc5c903341fa50b4b5888647caeda776dcf892013c353c09ec35043d03c4549c5f0de690e386092b4a9c29ade80b6be192acc455f5e22c7a9aa1c2252e10705eb4f3105d643d2d128a40a464b5271a8a784354b8cae00b1904051f3db410d408c548358120b758f8434442847b42149e88ced605545f72e6a570810be6f0c26272e5a5877356092c24a68f300e2feb01a487ec4e183d51152758e7a4f5d1e103a89e831cc1d0a9638aa3a6532e431a78bb60ce4da9bf6f6c36d70fd61c55f048406d9fe76e3b1b79fca77566df4362cfcd1144a88bbc1d649a0a061d9b679ef2d3aad726dbfe8703eaef2dbe6725df879deea4bc21486ceade695c6126a0267870c9d2744e03d6f15f1748e08c79a4770c6a961af78ff579343bd82a9a797ce7de9706ce5c04334d6732f04201c5218046bea1b67c536e0e4f4d3cf535c74a4fc83d45bdfa476928d7e1e82ea3ad2f8bcaf713dfc7256e21ad08241cdbb70fc49e1cc1676d49773bca9f893506b7f9934c3ef841d2e5060f5d73e424a4fee2d32f31d9f08707623ad8996187520c609b8ff54df676c553004e9796779602b9f18ef88923cd461597205f128ad46873a19a0edad7a1d149688d5480e12424ca99cf80df1b56002b36edaf50b8c1f52a06ac065eef18ef042a43eefb3f0a2eec23a2122213000ed563d3baf45050711e6a41220b1fc79704c9eaf04b5f95841d4cf1d81a963869266baf2413ad092c5c57014f80e1caa4a5ccdc98afea3ec958204f81d6a3e604373c05ece72edefd163a12eac52f76ae5291b173e7378270f08d07a1b49d0261725e83fd654b31b3c80bfc89b61c74f6c3c0ee9fe836c21882cd5b720748f3679d6bd58511efdf38340b23ec6659d5bcdb8dec4e2749b9d516afee1adc21f69819ea794567aa95d0d785dc2e6423ed29656dacc6778551755c6d82536910c4b48b01afe89b417eea666b2dab485fa114061aa64dfbc1bf8ab70dbe55d6e9bc355076b5a838285db9ec4818ef8097ffa5f3411b32f39087bcf28d6a98b90529264571fbd208b2c7e1ba3c5fd2bfaac9c3a7200d06f6ee0ee925bc27eeef09a2933f34fc447b32dbea575846368bdfb95e7f360b0d39ae3d573939d443e8f7ca1f8b52ba3193916528cb898e29212d7117e6cd66b60219de2ba92886329b2e04ddbbf130f19b630c7e0242e87b5024a53dfe73aac7636ba14dbdf74624ec92b5a42023d84e5b4c5f9c82663ffd03fb5cd8647c7eac4c50d907bdd6a50a986af3893d1fdd5843ec88885fa04ec39abeef87a7b3ea48c716192ce16dc14ae26e74c9cf00e53dbf0e711e05b4b98017e02dc6610ca4b8577eec9bd728925da988949c0a0764157bb450361895bd6466be60440fb8a73bbdacffc989a126319143f06fe6b9faa6dd0bb8b6ca8d8bacebd5760414e8686c540d4ed548ad0ed0d2001d01bbb5c19bd47323ccc0d68c924173effb035e291aa3f6937a6c3614cd92e6826ac2da4d6b8318c1052e706df82dc88b737eecac9ec218918d0c5507c35f242ef23771739d0cf57097eb97316f8f1a80dbb16a7b286f1aa00faa868a4999336e231f8b0de2f1721b60dd1bbe8d4f8d66eafe0f83cb29a335a8e7d838b879d3519ba2e5c1d93e6d207d639492db5e5e149f37c8f680326d1c0c33a466e42a0481198d7a08529b20c490523fc41dacf147566b444fa139423e4d649cf0b0c48c3b1c1995115edbc395ec963ae4c8d2fe966e5376dbd5496fd38db5f0f76d042293a0ad61300b5dd4de1d42ead87da72d0cbe1ab68578e884f4c44bbbbf57b906d7c1711486c2ad5700ca47bbfefb58841cd7db56c891eefdc8d577fadb16ead7f5337ce8d021acf63f8272d3e4f6757798ee85b92d165ff5c5203645265330c46fb5e76acdceaddef80ca99b6d1488fb6c99059710005aee7f9b71a1112b97473403fc16ca72137aa4fc76402b9e3a757b42e2572e16c799cb07c759ef4ccac8d124da7d91727f8fae89e6b835591d90841dd40e649aa47c99ff3c11e010b150f75e950a626874847633f8119136f3b13fe912dca5e3096bbcc7355821971e9e17a0900261bec5a749aaf658d227f8f49eb0aaa3d1aedd4fee3c2a011297f38544be3012f9c512087d9cf991fc2ee6a32e198d583e9a84dc9798d22e49ad504f086c5dc6ba4e9836d1141bd476e4eff6fdb8d1ba9a33ca70692d45fb98814dc08016e58a8916fb909dadea7685bec3f916fc37844cfafb89300a92e3d31fa015c8e955a0a78b981f9d297711cb1112d56f19fa0390e0b2d71c27ab02e40ff25202d25a4c4c1d999205a83a775a038ed41d9af56156fa136c1b8a5aaf8dd32eb3ee5f99c8f3b60522aa1511f00f4d5b939f450996bc3de17d8428d5f1106133d0ce0dbc6d6f2cba6a62b876abaed2c572538ea27422a7cb4ec9b1504c4057fb47e751c533aec907d6985531222b76f7e08f12b4812fe6e14c8ed212a712d8d888f6135faaac8c1a36c73c70204faf085f1172d4234d805e78576619cf44be3904dee521f2d45b23c390b18592f21155c3552fe248e95f3f5ba2267987789a7454037b95a64a1c24773c5ed65adfce4e13191a5242030037e761fb27002229f04d94b78bf810c6616f39e272f98a97ca1938919b1d92f45192c4e3bac18c75a0ce12c65cde93f326e210dd9a09164aa2691ebbad2f90a92b5b349bf0b03b36e39baa3e4f4348cccdfb986f17153323f135092a42c3c1e0961c0bdbc8d52b108384a1530ed76aafa383f98db8dfe60e80925bf39de0d98d3d366116b058a40fe287f3dea96b07baa4dec76df204a8f3c490e74afceb2e1f0f1d9ea259b7bfe60339ce30a1ac6d74adf3aea1c6299f28275e5c18bd082cc97bdc2fda960ae483ec8f1e7f633d150c074a078b4259598f77b86a429e72cb4a56df99881aa9ec2a3cd6741cc1993fa82de210a56fbafa590820388af4477e0ae76f238a2397f1a02a060551cf625e85f3d237d9341b0846ce80543c7ebbf7b9bc07a3607d5436984e3465442965a9acae46bdd0b8c444bf95f443241a3e298feebb4217c0ab91ce29a8db2a02f3dae9d796112d4ab1dd103f4f316fd10e6e7c57f230a0d1ae4e47b7909169f62bb40ffb6711a1caf0229315799204401b4eb1e108778a0331561c947d6b611d1633dc4f07edca3e825c677db821086c7bbd8b11a424b885ccee2543bdc55b3855470ca13274da29861aff8e9c0dab09cffbcc2733c32c673bae9d2e7a21bc4cdf91d6dc1221b6289b84ee42dfe0d22abfc61dbdefb2f0003bc7f9d3e5948df69de571bc1457632a7b4447a75b7d8e6b931850b3ceb325ff4fe6831f598f1d9f37631e1d94c451231504a1327390e70cdc583fa9b1a002e325cbcac5df0177f5fceb35df18140f4ed85b039cd748c10250c530940851c4db5239a95d74a278df92d80f1e9d989dac07940aa46513a87eb2b7edec052fa955c04d238a8623198cc836dba6384d06e508a4a1cc00c14e7aa5695dec41c4c9155de7b7648b8350215c08ff2f9604fd3538ef1403ba9f42a379eb9b1da92abcc4d83070d6502e9629eec04b796a99472a9f0fdb110e91cbe4f8cb9f3eb05752a09eab54c2674fc82d3c9c3a82cdd2a5fbb77e3387cba9fbb45a6cf6530d75d5aa2ad822e2d0829c91009189cc2ec7b3632b0e6424e5853d094b182de23b76ce49163de140953eaad49ef15334675b301c5ba57c2f7f99ffcda0b4e09d3792ccd470f14e3cb52f3065f0f49bcbcd614b1b22d0bbef1ea875114df0bdf1966f586decb839f1cc84d97f67c99fb079e2b8e08077b3beee26b040d9f82ff6ae467e56bd06c8884b494981bb765857c9f5b6731ae4dcd52c4f56e672c52c9f7920ff23dad5c0546fc090231fd2cc64ea0ee98e9571521f5f354465291bc9ed23a64c6c7c9414456d2320a6945dde0a413f7469b07b3c0097e98ba5a992a2f21b8af684ec20152f9269bfd4b7509c0afc6cffa7ccd0029c8a61e3cbc66c9c960ff4233c6c40cf9f8afdcc2cceb98902fb7e80dfd3c252169d10892e74c7ef56507b375e1f4ab6fffe4094c116953df6807db2ccb703f86ab7b0078580300ba228fa6fbd54264c3c63e0fcb3909bdeaee0d85d7c3c20eeb4e7dceac88d963ea1e7c472536298b57eb8dc2b3f0ec8589e742f1828f492d9c7d2ecf6e0b2466a58c292edabecb1edd4507f2c14d1d5500a997c2c035e81bc8f6168b6cbd0e84d7a3c9b9b2511469e50c4bfa326bb732882d28fb2d8463bb750acad09be151dbee24ee09869c2d559fc55d1eed17b2d15aac483febb6bc9740084fe41e821fc7e15cbf76b8b59147a488bcbcd56efb717b084a40af1a7549ecc001c4063f17d8e91169ea4177843b5bf37a7e3ce207a6860859ef6baac91b55edcb0ab3700dd2e9a182565b88417d49d0b653631c0e27b898e0cc2b5df458bceef26e057722d0c421680b41432b16ce64cade37feac9db00b4e5ea8ef1dcd0411bc0909625eaf4a4de87b45395d055c6374b57ef9104b8cb00cc9ccc164a8f6f4662022be78621008835f6e0f808b0b96b6a8bce264ead84989d257f6f929ba488edb71ceaf01f162bc42379c746670942938205c355b1cafed39bf50285bd5e2224830b9590fe7b8c1b12f3b66f5e0e72dbafaf37299d8ca36b0998532fc131daa47c8274009e10fa25ca88942d036053456d20c3c1b745a2c812bd3bc4e4c1bb75f33b5facd203cf7cf0f290f1c02472b0e50b85f2b9f9e3b61715a897706b722ebfcf7d157fb4337284be0ca32a846aa301fe43b44e00d6a26022de3cb00cd0b8ae8bdb9aad110e8e558f2a8cb87cfa2a9c77fd3b24bdf026f2309ac2cb4fb1f8af104a937aaa5f1adc1480e9a74b47af651271cc43ea8564bc32b9ff01872b8288135c9db101c33348aec8d813a067346076c6d82b96333532832902dbc49ccb8a0461bc7e6008325a2b61fe5fdff52f1fbc9b4713243ca02cb9704b21313d9c5699f24e6cdbc521ea5663c14e9f24ffefd899cd37528eedc6c0249a2ca6994ba5da4642f6a5c3e8465bf462ceb655907bed9617f380dd1e5d9b821d84f0178d1524ce6bdda42060a7d19754a1192571b102cdae61fad045f205c41ab38b119211c808e377fa471162e76f5e21d6936a5729537df110ab1d74f060c4b50d0ff0ae55dfe1ee26f74201c1c0fab48091e13b88115cb253d50f5f499584b0fa3192d1aa9ea5ac33cb854b81ed87dadf08e01f1e4da54ca6aa3cc6982f48bddf0e2c915ecadb25362b12b11acc1da0b967f653ac9d0cd88f279dcf1b6b36cacfe2be68032b4c9d722175974ed470a4157eabb6398d51e5b8bbc6c23891f68c978dd78f61ca91516f96ba21d594e6b374eaa45bf0bbe8f146ffed9556bae4c2a68003e708108d620b91f96948a5bebc17f5bcee6ef9e367708f9c676e3200c9dcaa780f171551bd5239355d879c779e5a4e11db32f79f3205a5ca028834d91222aaacee44c78aef90d7f3c7d14f20351f1f753b376bd04e7cc786906633bbea25f9e29790760a0788dbc094a216ed8fe04c70e59e3787d8263f797f5b85413c72b31044d7d5eb2b67b1b7f8bd343fe542e7b2ff3903696e00fc0370f44904958d75d0d0f25c0e2a364323533afa67167c71483a076067ad91a0ef0f774124ed35998ea93b423e2e801d09672b72e20aea799a7a2506788de80a15cfa87ebd9abcbd60cb2c8ee525701ab67e22cf1e5271ccf8e3c5f29d974a338f888bdd7fb51b44e9cd5c94a924c71020c52dd3df7722a64e753b683cb021eebc06803d4ea2b5388d9842414269bda73905a2005b112fddfa483dc779af3373536364d3d3852f58c4429f4e4a1baed6b0fac320c84192cb4c92893dca1eb6b13d1c83d6ba59eb9d4135694ee3973ab40c5bccc2c56daa7fcf0f1c9b5671b8782f63e6625934e065d1e06f21e707abdd9408938b11f87b6bf2c06699057517d917c285a9733f18b98c4f2c730d2327ecf846c43c703aa2461decc4250fbda624348eb278ac0a88d49cda8323075e394c28356f3349350c14dce6ca8cfca0c3370c54273bbc6ea5eea55a3b81ae39d9aff5dfe44221381877361428302c83bebd22908abe1991c4572dd02f7f1491146e37a81c6586d1098df5c1def6dc2355397f9b07e948a1aed2afd13b9735be8b6f0bc31c0e7aedc17a30e7ef71b90e596982a70d3c4a32869f8010642a82dce4926d6af46c2504cdb9e5eafcc87fb91de71b32f14c89542031afe6f3ef3734b1da003596876d20a45edd070dca90b15fb4cea211e420960aedcc3226dd37fe0f07afde87246ba09c73c967cee9fb66fb1e3094f995d39cf9244fbe439a55716a70e9614b5a80af6a5651fe3c3ccb1c87d2fa2b71a53f645fdf4a18bd83c2cb637862d217d14a2a2814dbf12cbe1fcfb7e27eb731cf53b36a1fb5387f35e16242ddd97e020438b301c489cb18b993452813ef691268580256f96bd01679c7dc0f2b0951e8790003001949644fa5bcf92c04e56aab86955eec68e3c04173270f1bcddc782a3f1bcc32418af35c65db732a8648cebea4a6467d8d8b3b333c7bcf5bf23dc9fe07c6e5371339ece9ea71182e7a7dd8b0f0c08459eb1333d48de542820c229389e94b26dfb890f3eb01c6f1a935686a0fa2baa566702aa591494605fba1ede9c40919eb3e998701a1e1086f981252245870d4ca566a2049b15c1899336a13e9906f834b6e7a95dfe61b539586365e175d59a4c106d54afc1c2b555ec355da4ad4bc3878fa9341a32466b47fc33d5c53d4261f7843f587545117b68edfd915ab7a21e5ba0d52a850a61d2aef4fa4f3649e7ff8890d155f895984d20c55580f63793c2e0ffdaf0a8ce24bff8eca50b01651b06635c30a0955612818b968728d8fcaa7eb01f8257976405deccb05dce80107976b36002bd13ea335ca1e04dfa742e57e75ed145081875849ec7048910dde023e25e57dc77ecd0dfed8a51c0ad41e06b4008bf767bba1f31958da9ea28ad1532722061ae49b22784f3cdcd0a325516538ab9401644df4d58c189fedf72b1079f6d0e1edadde971a21e31e70e3d9f9964b83460602ca64e47f85f0ccbccdc0b3762d0f3e436801563f505d1bf75c85293ee4a4b7b24fcc2a84f9050ad2e00b391d56424db8ccfd7e69c1cb749f01c7d0bf999835aae4c0ef88e99353f1f0eda160b006bf2b8464e1b65df15a96d8ca6738827ba44a56cde54f66454e553ef6bb1257232418c4371229fb1b38afb4aec44a9e80efeaf8b15d5cf647c56c1f96a74abf58e8bbf465f3f8052e61c3626be36f336efd813af727f804a370ba6817a514dc9cf19c7556cff44620771bde0f41f418e7661bc66b5a0f5a26aea7a0725c5c904b462753e65be2995b1f2883ceea38417c685bc1d676deeac5229b4d93e44aa5d9b0d44948bf57fdcc6548301d0cc4db691ca2cba7a0231fac252ff15b2ea98fca3538b584f8bcc01cc1d7488f9801856cefbc90fb41da28e794c4a22f2826bb0505212bd71f6f3cf3949fcf38059097e5f205329b8a8722e8148f28cefa07dc8bcae56e42d7a88a07b938d294732fc80b618d6849967797d541d51c0ecd75dc0c109f9281f3ba555c39cbf14ffe690cb0bdec161ab790277405fc91b9b5d3c70049883002407edc2b3673ac596682f4e5c2819a2c55e006664a4984b7f4dbae0d5307b890d20144574411fa7050183af039da16e026973e503785e8bb974f805cea9bc9bbbb1029994305f53b9ecffea5cb96ddce9105c6cb9787f1f8f59f3ecb79e60f16062a97da02b82fd1d4be662155e01978dcb0188bd779a94d03b100f95f8dd004c41599f3ece1b962ae016d9396f7c7d558f6555aebdbf307b9f8c4ee5b2499f230df350746d313177a12d76045dd32c9bd182db3f1a84f9def177daa9c0df5d036a0f59ec3ee360dbe68e109697c67c0ea36273fd74b737db1124e2ceeb3ad3caf7b7f1b092910459834e751179bc1b286f12f4db7a6720850f8963d300a1aa5648dab877c754ecba5db422ed7d4947b470c2e7dae661e21c673cab473fce7af196ab15af98cc7363828477e8f8c99a37aac99e001452566ca19df16e03748f04f0e9e40f5835f4d670707666ff784d7ed166b89098c74870f5914c4f149b65a9c30ad08ded9b49fc580758bf7be1f5b6ff8ee727cf0c8b791545ba9afb63f664da016f2191a3703f67e1711a5c0742861fdc8b20bce3d13f67cb98fd21b88fe8e376dd3ca341cf2842b453aa2333f90dc946e9462a0f4167cebae309b5b568d048577d1e7ec6a235aa02653c6a64e10773755c13581db8efeac4f9e5082756787df32a3fe8e8c7b738b75971a7edb245a27cd8b6a343adb0393ce4af9b2b2668498ca6ca4d1739397d4461757c29d9336be7d69a2622279102c4c9d89c3bd617fdd6adc537f73ea57389aaea3cee669af4d10755a9fd686097052f6a87ad41b1ff21e6e80a7e084ae1205596747f186614095c39d862136ab2cd44129bc061287563a3e80ec8a61501b09ecc277c6f4a0873cb73340ef074e4ebdec8aad7dbf19302174c1b93647c8572d03be855937557368b2c45199f537543ae5c070ea9d7f4f7c460fd7e0092e45edcd29c78b19643100dd7c27c7c0d6dfd1662065cdce72b44b9ba9aafdfd0a206d5c1f559cca279f8a4bba3913bde5746066764a550cb6be7e6d71e0377652bfa7db4819dfe275471b80cec6392b31756630a5dab6ce80694949671af78205239b674ea872f7c246ac721a398d46146385a070ba80dab60e0020fcd8570a12b4b646b92a6eed2d29f772bd0fc89fce5c2321abf7bb67128533aaf765ac3a2d898466d6fa77e55518c0c960a1e457cd5a02f90178c9cc821aaa7f8d379e0216678417ca6b002cdfd1498eb76eb543c12f8452d951e4bcbafa57a223ed2b62cd4fa3299fc57b58594934674d504038aaee9d6107322bfb6a0d5f24af6f6237237fb1d70075b52219299fc87843245aca4fa5cd581540b5f55f53d9470f817ec03479eacbb32d6e42ff7d4b6e5c9abd1c92738da8a22d1971db57cd87a0cc37f71af4c2a878b807f44a35dde10aaed5dc8cb27dc8ae882d0f090d8eaeaceeb5cec9cb46ed1e3ab717d91ef408972c576645c46ce45c7b28c243c0b5e48f3dd219530826c1d090a4821e80040b6a9aea792a50acfafb59e835fc14cbb70a9d3855059f67fa846fe3d14c85d4a5f9b17f3177cb779c9e405f877d774e11aee093b6cd57214e35740fa9df3efd37fb6b37c89543db81de16094f34b87041662d2dfc7c3c6b710098ea36a01cd4690e24aecf655d792e43a5c520f4b797ac1a802bb5c8ce0e9a0c8b0ed33954023b7d26e75675b0ae74b54eed080e42ad59c03842a6770a4a881e5dd8ca8dbb720d7e0294170f59337b3c4f961670a28fe730c825edf9821d1d5c30da00efd3bd89eef5236ebcf1636bb03fe3dac685e782111f746e5d6f6af","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
