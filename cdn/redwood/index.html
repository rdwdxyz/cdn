<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf0437843f4702cbd9f9b3629ac52d2d8812310bc16749906ad7d3f0b6656674eb24f5501ec9781901d5383a7a1f3e9107e051c23d76f141a5cc953b3f6e04508538d1c4546022ee8fdba333536764d24f765aee0f8343c826f5e0b02c73fba712fdb01cc907fc954563b46109f9e89fa3d5c4e7ee69e5bcecff0ab41b9cd370dce596a400f0fac1add956c30b4d6909dcaacbee0e5b1745bcea1356b306531536528699cd6e408e9341aa8615d90fc82bf33bbf93ae2979b214549bee265f1c89ecbd568c090dba9632ded93098c385472e3ad16d6176553cca8a05d24571f0a5475e87165d7674d9a17307a02d944a96dbd8a255a3dcfe4ee9ada77e89c4bb706182e0b958714bfeccd182648643a92067b59b1b4991aa48035b2df464184499990effe9772199507c91b0fd148555bb8c5cb56b301eb6b9c416fe40c583b5c379ea830a702475bc8bac877c48c36b4eaf84e276cae9aae7141763146ee5468f938f5bab8aa437810eb424f783d53ae673da6846277094109545d9956847c795e79a678c2f518669b154611b32b58620d96aa0dd3be12d1e611ef29d9479d959c859b5be0c4a2da75988e3a599a3b2417ff39edab5008b2753facba245a9e5c6c528b41dd7076e980ca1f3f6fc128ade0d6e9f7be78399d64d9f6257b9fd5f5bcf5aad389342bbbacca17b229458f47d3a5ea47ef38465dae055a45d0629c0043a68bedc3e079dfed369c9f0a80717c60c51eb1e8f8a9c728f612764692c95e6ecddb12d9bca261768b01276093d7b3d2fe250f923e2839a6ad01deb0920a75196d3e5688297e6dcb8807f131a36a521deb43741b4da0620d0cb5a7bbb7687b05568692fcbe0139798a0efdbfccb85106f9d33627838ee16e59c21ec6ec3ad49d6884d1ff2f445fff137dbd6e2b31c135b81bf44ae925ff5dab3f15791f51a78ce573f2332b06a4e095b5f9612bf579b17ec1ecb7b62221a774906b61cd741e9b67e58ba647be7a0b749b64c16802f4d6764f0083dbae614e476a5267283fffe1197042882b3731776bccd815f14e6779c351e050a5a1d256fc9dd9598b965dc27a4a047cf30980d801aad7eb3b68e3ef29c9339a14b75645887e51c5b00e40c9bd6abd63e5e7540e9c5ce3090b0f0d6cf6f82b2dde905be37b6368458d71e23f1922a8d3a131bb3beacf7aaf74b61346fab728bb425213edac80044285621fcab83aa1898bf80f39a55c3072dd806b3e43faf2021eb0b9971ea5f018c11d0a8602f1d8d4f8e1037fc61eed4caaa5582640c82ec175f1c8b4ecc564e0ae5f86727bfb1b655f301ab089f2e8377c69339ea8f0192c3d46d1114dfe8e6bc805375c39601e60418e957a9e20fc5e5c6048d8060d3690ddb51da44e07422269a280a81c8a38c61c34f0e28bd39e51c191a6ea3344336e0bc9ce6bdc2a97ad478c426047461fe51dd7a40d9d4e8cd8dcf03b9ec2da878da48977476f289bf01d518b44001720d674f30995235b7569a16102638167ceea7b1154f80bd7944b02ecd2d6e0b15c372546b223c0c3ca2f4eee97f3b6967fcdd27e93124d4e5fdea84fe2601f6082d4b2ab3dc46852c1a7b42476e2218ea96b8f7cc16b65bab922604dd675fb0babd3f53136faa4a7d1f90135f02d070a3046ec18a20c171f8c51178b8ce7289a326ea6e507e1e915f839c6b6402f04ce2fe38b26b8e2add2fc0888470f2b9e8d6cd9b909c9a12a46e195dc52152225fd4e8b1e616088b78632351c79dab4f3505ebaab9ec85725c19e1d42d5e22865c11af1db30f1bbc55545e783f13fd50bcdb70a409539de0e7d9e7f29e3cd38c15deefcc580acc120ab559d1caed8e22876803eb778cb94335efcdadf58457fa84a4ce6eff51c1e0a765e363bd10c13efd208e3f363e8051de0fe7c581d62122a3f0db4bb9a5aa7ceddf62c766cdfb901e80f94f8e5126774eed8d97a0a0c28da69a298b18186bf21ae80bda0a7298d23e6404aea13e0cabd9958fba10673af2a6bdd7780739fd71ffd8e2db6bbe55bc851d9d0bb3470c02add70e9b86156054fc6d7e00726db61610c84b8462c307cced851b987012aecbb65992b1566fbe9cb2923ecb11f0487ba2621cf47cc608d127bc64256af06c460f4d8b6bda4ce2ca0c19f192e92aec7c613dbb9d7309f8bba36a0f90db7c5c70dbd6378fda78ca516b043bfab38649d6d6be4c31b172004dec06e53d7b87d4270ecfc165bd71dad5d7fcd749ca82e7b98cf7b473486447125a0e61e036365d10bd68155c3425d28e42d77610965902f2d963071e4997e69bab06568728bd5f8a570ab9d5b26adfb6f05488953111a47caf89f805056df0fc18b14bede57d4d542a60bb69e94219fe0d9740cda5c9ff752d7a20b222e6b8e0779ed0b20cffa3b787efde0c399bbf92c04397d7ad0f2630245a25b898a65f6b914988eaf118f09a583f1cc55f40a3e92f26e329fe5c22ffe6439fc2f01d395ea4c9575ca2ed672619c0a698e48981aa4ded81be4007d6c00a7c7dced5f7ceefceabad72b1ec16975d54aadbff29002232b10a5ec80b04592c1237c95f5f2d6e06ef33825d8286e21ab927089e75a34813bd33fab0267cf3f6c1ae57be9f90b1528d1f70f66bb7cca9acffb83c74f1e9d8c61385014511719d0c2d6b735a4ebb1f48254540eb729a49587a41abbc5894253ef42326f92efa5d7b3df2110866abb84c737a41ee412e56dff384201df89889af5f0324b7b04aaca6ca01114eea56821fd3cd397c130259c50658b594eb3ef5100364b652e8946d08eeec1384290cfd7069ac8b4c5e504f890e08cd595b4b3cbd05e69652be4ae4b32f9883bf936ff5849e532e28bc61a8838da8ca4435f62418bcb2118ac79145f0a37e8695b96920fdab39afedc9fca7c673e82e0686197fcf6889f646dd0b0234aaf919dadaf989b8cf7137687196ca63d26bb4446e30717eba2262c10db077f7fad59a516b7326fcf143508d52dc155656d79383c8204ea55dd5aad99a94e31c9e513b159cedbc4ecfc9db8f660bc101106edba25dcc8c79ab8f6d34d6e5d3d15a53a6d8c4633d6dce194af25df06b27b3de857f6e2781fa2788338e49be66f83e3263963bd7d99aac63768034e0743d336c5f43460ec48829bf45d5833f682db5f8650f0901d92b7591855a62550fc3e8cd84e4f032f7d9da6577a4350eff3cc136de96eba197e26a7282271fd63cffe18435a842112598b622db200f30608017079f1d0fd2adb2dc71c50c5602dd0ce70c72a79aa153dc570de98f87394a567f9b1c4f6892e1d6a131ec00dd20b81f5a0bb90c0c32b991a3a1681a10132ff1adddfe6bbdb7c3f65a3d9adea093189bed60193fdb0be95f424423f4f055b69d17558ce07b962d9b71e77027803c889313ebb8c400f146bea1c55af4dc3ad2be99045bf23da4dd4ee53f03faa8032a7bb9131a5f5209e0013b2d60eeb65d5408eaa7eaed1f3981e5c6fb777ca036bdbebef905be343822910b476ac00bd552252f37f402db82f68c559d926f994c4943e3d02d6f7ef065b67dcbb1ed286c440c8adc1c4b653915bc19c1b64881cb093eff7363896bf024dbdaa0a16e824da94fa5a06857a0cfc13ce2e47ca15df806ea6ff8b5ffe339ef4c1d1f0abf2bbf762daae9dd78b5aa18ba507e7eb54222b35dd9ced7bb07c4f03e85b18faa3af10ca9a0c599748a7ddc8e104c5a040069ac906878b5b4931518dc78ceeb4a46c6737729c4b244a0385f8a375c094035e4a1df927f5e41bd7d9aa7426aa726723d4492290395ef03873749ad7f33e1445f7325c31486abc59fc859db941205c69de28eca2aa3e6a442fbb9cdfa14f2298aec7605ddf37cab4c80c80083f6fc151da528a6dd4dc52997df4962c6e98293ab7d11bb173e43b13c73684c489dde1ffedfdf3f59e52c3f5375f7371dd0f4100d94d5cab720c609358b02f6be969bdb6b726d0bf3f28a2cf40d2ef0f4a8ed1f76717e7d34075da6a5df993aebc9ac735264d86e791a60e5720bb7217c2a88161e352a95c34e688cf9ed3ec2d2ef30b0372d622ea9216e82d5d677e0ebdb6cee93d7f86cc585ce2c618ab944b4427e217d29cf68013ee4736e7c56eecffd1762bdbd4a24ba93cf3732079232866c5bb4703e474210866328a522771547a99a203088812e69a0f873563b482b31c01b085b32a5eb40cd509894f080d19205f406459e95144cae964fcd2618d09b1aff9fc922d5a089b09e5e6ae66f87e924d335d32a4dab9f89eecdc3c1243c9e082ddd96b6e77313c29f8cbb55f739f7cb005ea63ef296d849a8030f465f7967518a8626cf4b655f51c5a264163b21400e6bbe0ae43b9410b8f8e62baf69601c31f9dbb6558e14282b442d332362cb501ea25198b55482640c394ac36e02163e3f6c4cb8aa10489f0c8d82ca7318cada523bc8c1df2aa1c1f0bf8e3cfa5bfeed6ae7d2a2c73223442219235d3bebf801501d20547f37bf2c4b772d626e007784e47e220c75486207536f1d1cfc7d522704ef4af01239c2aea97f61c0d5e4765e62c541ea6c4189eac9622be7bcfe4d3a7fad52a6fc79e67fee44b42ed8503967d89e5175340e27e6ac151c523a03bc0349ba3b6a1925dd685596a717bf82ded6da62374e5cc02f2131efbdeb3b961b673e8ef9e1f48814c34cac645a8056de4135ab221e817e171b3f44fa7a4eb99bb8f6ea39a1acb5ad5e1cb617cb4a250c93f8c2b797ca84f3eae3777d668251df54ed1f7f5624b99cb44bb91beb531cb92c51382d4625e30e2ba2705396a7e32d4a3096bfce5921ee8e86824a54ad24d5ec027a8f7cc87f687201502459cea43c61eea1b6c7673b4042aa5fa0c14da4a5fe2615bc79a37cce53ea3b9fa7ba84569028bc610a72e1a317ad0ae5aca677e33a05c7ee0a24df6f47904cecced6da9c922161a3cd33f7e9c2f58c63c459c0dd0805cbd066ce1b926851a3e29c1024ed17653b93a6d895b6088aaa156674a24251b0119b71da8bd278c8ca77d1493a2f1b95f8a62eaf323c881a70df385557e0bd5a5b6e00c38d2d8e21ffb4da72f48036e708d2b4320d239094203befff2276453f1e04537384b8db62b907cddb0848cd12388266af5b25e875784cf92f9f084292bb11c8dc58ba59e5d4c59383da9dc70db40e78aeda336cfe1f5ebc8c65b5332927d92d32a6f88355f4357e4ce1e1d1da33c6f9a7809ed3bdc8740de420339a9ba87f927d756d44f8e744a2a9c00d7cc2fd61b26ae2c7636d0e3aac04bafa08bc2374dd0983db252a457843c185a45ce33aa04c21562690459b7dd5b372035bcd9b856f6edf098070ee80a04d8822fcc0b3c266a2165cca8b1070389414a32bc664efd19de442bf6185808c2a24e718af5e4c800072294c25de854a0d00cc1e6b62bf11c48d899deb3b93521e87e506dd7bde78d2f94f20424b754eb9315df52911a6aac20eea4ab83b8388e25b75862e31aba3f14b5d78e64332dd36a152a3f806e1611cf939afaa4c46670e5e84fd242332811d5c8a8c839d584193b789999224238aeac0abeffd20e033ad56d3cfe098777733b33f4c59f4bcec175380c399e616e3c062f413ab71ac8c5b488480f98e520e10811e7544962eaa512c94ecc158a9b7467366b0c143cfa9551fc9cf0b2b1df5696b2b72e155b96314eda45620a0dac00b50f442354d405d16da040b07cfb2394d54c89f4eb0439d95022a0cba527f353b475971b616ec3e729cc3c735309e8ec148d6274b2b46cb1d55df278c833ad0813ca2186e9ec14ace1bde4eb55c384957469f98fdf7c55310d9002f2bd54bbb96b4ff1ac46bf9d6bb6b028c47cb821da704a52879c89678003e2a0b53f9aa427bfecf94fcb5334037ab456dd350dfab1757fe7602a8848923648edfdfd7a3c244e5cf65db2085ee1715e60d7c56c02ad898f760968bfd21451f8af7d713d37e605c6a3f66b5075b3de71c66e7f5928c42dc4ae156a3d980eb3e1ea116cc7fda74a954c485055d100765f57ffe774829a90f1b6e5be34cfb3d6481f502df5b8ebb896adf343d72fbd435f518b86a1f4c795fe2340920e10fc13133ad6aefbd53489bbe5dc01f380fd4c7ce13ac703fcb285f314e47b05507db9a219d76a1af686758187a06b198d4cfc6a69adc86a468e0383c879daeaeb611dcefd937f75102ddc433fd39d697f3fc3f5bf232dc0e15597c30841be777f13827678c50eabf6c27e9893f6030b685becd705817317e38ab96919e6e654031afb80d9222b18c85f69cfef5aad4c1d3677a761f3fb11a005bf848e57c0654fe80d48b7367df03b67d62ac482339621d0c1792f44bf9f1f5e4fa332535beb68dc67e8cd02ee2e9945aee19a293d2604f4173d2215f5c2b3f25d3f8fc7eb8f598185c02d32ba26af0131fc5adcaa0b8fbb3772de1c2130bcfd59df02ec82d3ee5f7d60c9d4b061d2214061a904bfff38fdc8ff7f3721cdfc51d3e271c3a00538d707566f77cf209e1df19c12190da601cb3035049217431b205cf1414f9c960c56bd5a8ebd42428a46f4e4409aa9db62cd12eeba071ea508f681c958417b24609a254e9ef0162a35c7754738643c42522843f4ded7d337fb4f00f7edbd29e9851e2b9ff1001eb7317d475608d9a1f2328f4f34bc61f3c61b481efa763625646ce375b9cce1ecc2ee35cdf906e3919e9ffaa0daa696c09f5f2e600b81796d05e6c1f3bd3a58d05eeb5c071ffc2150132a8d3adf42ce9b9de52054d9b823bcb1dbcec44b763303957e41c3d791d28c9687c0006dadb8a7de99c7e0bd21cbd3abe8e2e5e5df57d59d2d19f6dca686ab3b3b353c2224b26e0710585255134dd134e7578379257172294a0449beef4aff68e4d0238de751416bcffba85fe8f6010d72174b30ca8629c9680b2b5bea52dea9201e0b7f2c8483041ba249382d45a2d0c29a9cbbd829d8239f4775d8fe01c4d89a2da1ff45cd0ff7d7e9e040e41b85f81f062e5fb408205d505edb78c5701d8dd461a6996b2fc82015d41718ccb0eb209b8657748b04441e96257602c35a7ec8a71f8a86a592ffa1c240b375bd6b8e896ea006cbab7df12200da29506fc76513dd2dcc9b0e1a4a571005cfc9df97a4965e375b51d3cec1742cc592bf3f30a0d48901eb2e77c1fa3b1f132a1e0dc78df82d84d45c7991216dc4e5d2cb6d975e1ba8fae51d5c57df9b83ec22533e3370505120ee087bc70e2dcd70113a60ff7b40f392698503c98d9a450129ae7c6e681a89b4dae733948a9ff4a18d1ddcbaa77244a24c53a9d5f060238823588e37b819867fe71ef87f12e886ddf90332be918a610c4d7c4c0de80064d8bb7051b69bc62055325d1bab0ca3b1538ae408a0b889f9d53df6d8ed914becb1e5e5e095106553ac5d0d2339cd202891704ee79f048803c2a8a7f5b87f9d9d0d22476f044f7a1686e1223bd842659a6e938997d8ef100adf22a7c6c204f63df2dd47b0573ec7fbef9b39c0343ed2560635f4e241e09a99057dd5ca3f6f731bdbc487ec121cb202dec14a58ae9a1326fd41dbe0084c0fa2531180771663324058c08e7e7ecba9aec1d60e6dc22394850e0037209a7172f1c1cbd850281a1177b33b93ea5fd4f2609b211b8b56d7acfec78712c965b40159f094260b395974a15cd54c843bbf13df96d91dad383f40434219e5d6c35e8e83da120d2b797a78073a5af7819d5efd510c26d877eb73e357aa4358404b33ba057bf31232b5f294932ef42ac2333500acf8e0280bb6fac97b6b7b9b63c2fa27324f9d84570a6fc4ed995a42c5cb47dfeb53b98c033e99d1c46cd3087491b7117b711bd2b331f3ab8f4158e4645a7ce86200f611e00af1d62f001dbcdaa053b525cc7a79bf92a69003dafe5c7125d236ad8ffed9070b29a3a013f464408186cd88b389c315a821fc446d4dd49af615c78b2b4420c4aeed17969dc77d57046fd8384916657333a91f9cd9135d97618db72fccbdc4a95d2678b217e7fa503d821c0fbf11bccbb4115ba61a35bc104bc63494600935f54dce4520791d78d524c5d58f9a97ab12bc20caa3095613676e4041f95d1fe8f3f3d521af895ad97da3460f42719a04f628ba6d40479873996ec8146b08c53209c52a917f53cfc484bd4cef3e912e0b8f3a9a9b8d749e62090eb1228c07a84ff35491dbc45fd0666aae1e643a2848be20438cc038a3b0d402aea04d2bf43728ddb6d27b58be43a18229761be524c84d03d44ffb2e8c9a542d37de598e312c8e0d18c3a0cbb027027a41d93f759ab2bc6ecd0e54dd4e920b01dcc72f81150eb4ab4eafe2ac2644408c16f4321755a9ba78ee0905f2041538dcf508c7513afa3d8e2a6648506022f8a04f20f7585ea43e163c1d0fc346850096dd893bf15c3b5078ad327f7553180729b10b1bf03c6818da01f2dd1f1b04518161a5328051319336365698e52c71b08d41ae8a954a30bb7a5c44087d65d1b12ff9789ffb9784e8e48ab9c0d0d893f13db01f58f6a83d573ea427f13970e79262d47aa85eaeb34f4240230276b95d7a10485a2911bafe2bf10d2710fc26dd1d953ea040d40ab15e7493d3ec6c1e2c39f3f724c19203eec7cff08f1edb54a448cf1cd672c88effdce89b0ff42aca5ce12942e49682c9f5839886855d10daf3b6e4633358603ffdc8ffc53e7d22f56016210633ea6083b5f69a98532a7852506a67415ef575e25458d8a3f966145bfc11a7aea4b203cd6f7053ad3122d45f291a53bf6f76b66fcddce9e93a83deb9144779c514d1f867601dabc2d17b380bdbb13fe070472a7f2f39776df5b334531be931d6947cc956cd46ef4ec181c2f5bf6e35e802218061d5eb71b6da41768d41ac49c48231f61a52aba7a49ec5eb580f22ec76ba73d6cc91229a2742d1088c14064feb81e0c0991264111b40c4a42cc3a98888ff27186a972a5834b8e017e12f63b21aefc9034474be4ef488927ca16251d63ff5bef414befa33d5a9e0297db8e129b4d18f90e3c8a4e6b6d82b6663b3cfe872ed8f5db3d82d99b4db98b74a294862e570e93f1a1dd68f5ddf02633ad82fbfe9d63919c9b9145d7ba9cfa5c7a195709dc29e9b92c2cdedbe173db01ba0e0a1201f1e420455632cb5e20c295e7ba2d18b9e37765daf80b03590ddc808e9cf2064c46184257f8da459f315df3f7e63f3535229077e6cfd77e9c6d2da7e4f2d334ba4a0409bac82f3dd80c65d01b1e4326580891b2a79021b40cc022c6baaae73dc10dffc07da4bd25d3dfd69e8c2778378bae074a8504922ea2331d13af073e795198e81a43552ef0ade89e28b39f02c6d198703256c4cbeafbc3dbd1e133b0e1e2239ffc6e553cc71c13961583551722e055bdee0d2e01d1531afea0d88cc2e1a338679bcd7834dbdee4fb1833700db1022b7fb24b93c85b8659efec662e9405c3aee62a62903746e097ed52b944a065148b6dda6f19366354375596b2904c8bf2c6d9da96fb4d280372e5d6f16baae3480866e07c60d24e6b90cd3280d879bdeb07109b6228900c85ffa54ed70fa741ca8a09dc071c6069a7bf75b9688201c2e533c10dd092af63e5b2a73d07dcdea76e1793accbe47bb913d1e4aefc94601e210b443ac2809d1d58c748f186d1ccdb84446eafc40ac69575007217d69346d30f91efc1138faf5b341ca39976e4d1d24e3812305e2ed8ca16189b5b8b2c1f26135dbb09a210af270a4fe48b2bc4d8d0d5bc6f14b0a3dc7968fd9612e84b20d36c7db3fad2f66e77cd0a7fc1ba1257611b845094e58da581bb53ce80bcd46bd5fb4c48ce1ac5405212059ce24d953f86d976588acd14d37a684878b2ab35985142ec2851b6712e32871346318cfaa97f3ccb83ba9aaddb4c6ba9e71c76f079e739c52edb02dd005d1308db433d45a77da60f41336e81b92484f8ed50104b81e45115a2ef24e832ef6cd74b2ef3ce3e699fb1b942599cf10ed7168626e4c45b39e7868e4199ca5a68d84f0266d8c44a9bf30cccb8fd7175e0e0e99f5c1a3db35dd49b1ccb999f8007eacf3e1cc7aca994e0d8aff5833137feb6f8bf8d7c7a79224f8d9b0f34f505b4e1b8df4840363f7cb50a604aa635dcfb2f23f03cdbee87dd76115d4632b68408c00bbafe8595f3dea31126b1fbc36349617d2f4c4fa0eab2d9bda4faba5b53045f44f9645860c936e58fe220ea337bd235ac88b697753efedea6ca46e93972b812ee9b02f5b8c28bd4834d07602667e55ba71a25ba503e6883cb4114255eb71deafa5385a4968f696ff370943670c00c750ab971608d4ed601d8c0ebfdf1e47f1cf6c1021995c366e1997cfedd0fe86911576cda5bddc48589e759f4a22b3c53f1a5a67eb4de15c9a697e61307acc35199920ffa68e1b5f0704a0b1704efb8c5f501cdaf9a8e0a6545c3104867712c4f4344b4858a94f6d993cf2370c35ed9bf96926ffd88ceb8626b7f70b67c93878fd96c20f931bcc4e5b90ca0c30893f4312552901152c895d5a813fdebc03e4c64b7634e7a73aa7ec0710ae198a9e682d1e7cf9d030b3067e867afa4d8e6468d48bf40b94213d6313db57f0257770af9a0625d5d3352965d2cd6e6b1a73f8fd31341ef6e2e1fd1375e350bd3928baed87d11e37055674de4270e8307c35861e9ff7afc5a669c71a63801f72213e0b8f04f42d450f2d54e4c5afe37f0d9e99a75fe0694b0cdde43aff2d14a4de372c3e8468c6f57a5a44ab7db0ebbc1d9eb01205e2ce18b97a30b7ad0b3a16ad967224ad92d3785384bfd1b92c7feadd6b1ad9d54eddebe9a13f599a18838e1288efa9984a7e4e09d8a95a0a336f23cea38511228ac4620a9b9b892e501fb5d3c8bea7e41ee97719dbd60e962001c78e866856bc4e62c439bfbdef4906aedfb67ef2a0cc83667ef3607de576012a584a453e11497c60c62971d0608c79f1de75f9bb3655edc5704964243b2867b5688e0398de5b3dd642f5a6d0b09aebf160b4234a358bcff774bdbeb3db2cdb0b4306e1afbcce87f68495b86b491e6758182462b7fa8354df10104da058298c7375fcacc41aa763d913633a779c243a69ce0da323b6c78efaed9ba8f87a5d46476bce4ff461bdb3b370158551a20f9bb0e44da3ad066c81ec9bc0af06e6f6927f6e2444462bd234f74b3bfcac06107c72a5cfef278c5eac1031048a7aa803942903858a21a07aa7d1026fc9e0870c137d34d3651e16f062a9b46ab32cbaa32b20e8c4e671cb82942c51f5626bb73f4d5f1cc821b7d8e41a328702aa0e7d960d7d5426846ceba7146107e21b300c6c860f1439f0bc7b13ce690b7be5707c8c40c425c210a807492ba189fd37abe8d0e58b9cb10e2b5d984478f399463ec791b6e46be692872e36b6139ddd2be86b7fde6d9b6a1a118982c49a4a62a17ce994079bd92345a232aba6bd5d5fcc2cfbcb8d0e7a6b6420cafa2c1c606f7341c9ce0c0214009aab9cea543799cf3129e20a87607f2ac93a8aaf8086609c7bacb421be2125e55c8c82b8daef6ffa230823840fec0ed665d15ce7f05e8f81075534fdb17689ade459368ab3b01e75a15852fe85dc8142f4765855a6e9edbce481d29744a6ad3a59a3b239d89dea93c53bee7576e901958f1f32a0927336f4df2d61b3c0687b75e0efaa35941dcbb99b27916eac02cdf1b3183a57da5ec2b72f84eb5079d0ecbf197735d2001b0a3aeae19f5d6222dbff30132b161935e05e0df3427439fb0692f4c18c9325e9f9a5c0cd31c5f4b180045d503db755714dc2328cc5b66b21d14ef8ad28440bcdce5bdca9c8e056aa534fe95323e10d8c2132cbf00b1efac8540a7067f4506326b20f4972cbd0be8bf0d8748be7a7ab984b46e22b52074f4fe44c182df88e27e0e0453e640718cc31bb03e5d113fdadfa843eef7c3c383b385931d53ef8c1ec92930767196195048cf1a0433c792888a981fc5e94847e82fe133df693e99dd4ade2225e8c3817555d12a6ff98d5086c225fa3079bf21db4fa66f21cc04f9db62c4c99f78af6142eb981f0bb734d7a155dd41690fd8676ccea586dcdb60029e65181b11a23683b9119aad27ce0d432329dc45896fcf0b9afc6f022011dd36a970175e03af9ec8d286f225afa008eea1af87e8e6ea4389b9c502658075583a0bd2a850048b671bf1f8e7a9f62b66e65b9ab9f4b8bb8d3dad283ca25a3f1394ac1750061e3ca472bc09989781482a5a4a23565fc53c411f0e02063600bc7b2f7456ae40f0c6db52199ed8d162bb51de8504771596da2725cc5866244067bd3b5adb6027d6a1bead7b49e3ae063eab3b1eb341dc792f811adcabb5ef4251de66af7b51054c730f06c52e8b58505d5a6c489911efec34f6bb1655eda17758eaab43f2a722655ff08891e16babcf629890605f8e582f7476a94d24340a4d35916d6052c2e5b6200ddf7c7822b7fa19999dc7ff4446093b460dbfd7f1ffb30046a2a7f5e0ab220903d4eec8947ce08186979e9a6c7a9a0ac4758483ae0cbefd75db796612a431f70d2bb37925da71b1728ae8b9a7152fcf17f5ea9a8f7f324f9625eeb543c2580b67b1f17ce0d6865b0fa7732e827c9e2f401e1e417c389f306ac575edf11eb22002a2ca468254e8c366f0ea67ad46d2b05367f4e229bfb2190891e3ba800fdbf960e2ebb4c97e8ad632325edf423aa20f1974d3e8ea3f0bb8e7a998d4e9f59aee37f509007be672bc4bb2febbe6099060ca73bf9678649d7ff019badb4a5c6522e99fce1ce25db3adb2322e94d7d94cacadc7fb92a5ca8e9cdf836e64fe60c6fe70ced058c4871837c89588c3a4e3eba9aa91f25613500bd74c252d045d5054b5b12ff826d3230f0c51d0216f46ab02a87f056738acfb88f2f9e6ca577fb0670ca160c812fa3a14ef768b38463c18a7fa7d352c26aae8a29879061f642de13bac1aff23e656618513dc1e172676672908f4511fec5098e08c6ec2a50cca57333b0752836d22d9b4bf9a81b4983a8eb7079b2defaf6347af7626fcd649bb556c68af96da9ed12fde744bb1832ff272754cc3ec4b545f2776834e03085d5501bc9bb28fdc14b88be4b2f8154635ecf08197f31930185f09d4a3a7c8979ef376581e1edb978566c1dd5aacee85b5950899a371ec231038deb7cbb3bb9822660507407297e622edc47bddc82c738ea166db90d0838f3beea5006ffd67ce9baa25bedb46d47311368a923f7934a6328ce81855e47e7ab12cc5813135f5ab010b0ce7f8c6f88429427518d03a177b48d4db8bff04f1298e38df26997895d356294ba9b1527b367cedc1c50c82c8c0e9abedd09754fc9c4e2f26e08e9e0490fbc63042b01e8d8f0023ec015a49e23862705e934fde3925c16e556183dec43dbae2ffe6f06822818f070b1cbed03ce47da617e12912210221a7c53f5c35e361b8227f9e9b024c513c24724a09ff5d504430e50730f3ee07c916cb9e79aaba617df20bacd251aae1d4b3cd3a9652a8f306958c5f29648ef7c850adb2147e027850cd079b53c86e54227312f12642c9e43987f2f5406d4f02bfcdef62dcbeb8d2d65f8e0b726049bf580130c08b4bc74041a24890813ed2b44be566b42f4ccb9a902e96dc5f4d352a10b5b2dca72eedf0d66b72486c7d3ed5f7c05af61317e36a7fd33fccdd970c4d932eed5b55c4c1b6e61f9989ce1ebafcd40cb04ee474d8a49d991ba3bfe446d852293362020d93f70adc3defd0a8a1e6250619b6f5df99e701102affe3f67f14e5f017c7fe069f4571dbd56603d74548669e85a6fb8888c31c316fa8d1c04a10d60da4e97d8cbe14d560bbff35c7358946d7099e4db64ff91665887b95150c3c6ce393c6766412d2b7c7dcb8a64db1cd695b1df9fa690b58542306498bdad977444538567db5d02db77b810fa86dc463fad6c42a7f8c77ced205176e38bf364856756ff293afc49eb90736595dfbb9f86da98407cf207e70aa2984eef7ae78d242781e4a0f6670e8d713c7f6056308d61c05a2489ec08eb07d26475f6b5d43a7dbb71c9e246ebbc1ab179b4c78d007ea87eb997bf6f516873ac1dcd9c4a71a717df242918b7d4f9b715f64c676dceac690b6ca41f9bf161844a38a8949f2785f3bcf7d1b471701290d35e62afa16c62efd64d4c4cca646cab11b76744e3eda61ff59d6b53e6e7a289eb619d0a555e822b50a1cdd88fb97dab94e31fd93d5159c257bb5a70ded3a9b95ca5bb1a4354fc4bd069a44f462ba381edd42bd1f678845ebc2d807c468b77fc52bdde308d5f64f91bf2667dfdd2be9f39bdd101b4cb0d3aa05ee25a1376d864e97b596580e352986919099b7bba841a61989dd2766c43d11fd8ba93f59c2a3dc41bd6b7c0118b58b2e90b985de61527e858ab8273a1771b4c77d3a3bf7f7eecfed86cdf9ea0ef1d2b64bd3089473e11ba0edffeed5c6bf7ebc8ed9d3194e157d79c61d6755ae963cb7699cc20b6347389b8656a38b63a72f2eed99f64c136cdfb05d66f0644ff5489babfee61f9b6fb7449292d13dbcb5efecd134d6722e614c1d1c3e74a5dce1d2cc10d9af5a7594c300cf38ab1d4c109ef3dd7b57c23d2a29e2cd4336d6356697cce83bf3ce76a0e11a6a05f7de7ff4232db83ba2dc380c3374bf0e57a513db315e7f065167e4fbd76b2d4308dec45cf4e8109891007d0f0a3dc13774d096b2b78abdb30dcc73c90e6c6cf7824a14520a122e902221b1171c195d1bdcbe7e564c642b6c8e8830755cba4fabf094bafbca01c8da75be41c3fb41c57dca460d81af62bf21ad4887fe20b92d943160e69836f97733d4055735f8214531a4046b36235c903500594932eac00c2e38ca12b79cee5db3a1c39a0ef30ac35811cd00c51b943d663694894772379d40948d8b5962867e98a4f0254e42c18ebcb40448d7de324cbf83bd6ff40c13dad3d79756ff7c6e2997e5891bbfa348bb09fa00233413e69519256406b0be02f60910424f372e7815ca75b0ba237e2114c65ca14358e223572918f0b56c4249ecf151a710d8b58fc6339fbc272b99bf073630e205454782fa0eeede039438db8cde883a6cfb6d117eb5ec779b104332d72297d6706930144bb61a77d3b91190beecad0868994edd449380a8b220008149a8fe09524ed305320c41328f81f9ef1d8376a6f0e208009e60edf4e41ba6d0a7309b230551ef43df1ab8d6cb9b506eec953ab0dad8e1bd68416ca87064d3011584690d21a9d60a4a25222f78063527c7ee7ae886c4aa63bf7552244c2d8f250014534c43b984f6ae9fd7939015d874f76f9d8b8cc32185e65181bd46e81b4409387ca1bd835b4426eaace5d023f889e3718ac84f08c63def9d33fe9c935058955621bfe41e3d11b2219e2ded656f53cf6e91ce5415b3933a2e8694b82798e8c2f86c33c436f3a7d704152d3857d65c78b2aa42eb5d4f86f4c025e1b67a9d1dc512b265674dc068f370c7d82fe9d6656bb97c0c520ca970789eefc50e6742bccafcbe96319356270a88ff016b44c28723e3b4f42e7aa48b776c9689a6df844f7ab0e4ca1a89efe0ffa64e7411cb6c660b62eb5f22ea96754e0ab22e490378c93daf88dfba84d32e2b860bdcd9e13fab62b698b316269a6dd2eda68082bd610b8cb43b7c09885a871039afd5353278ee76cdf0e4abfdaddcb6f8aa80a4bccf69e5f2128c13385f590a9507f7af486345d429f264f8cba4e223536ceddc5bc2850acf24655ac11f0f0baeb933c4e549d5a1f9380427177fc0f1e7b3f2de3c2bf6567c0f048cb48c535286fb3bc681e5fe7516002bc3218fca3238f144158cd29bab0a5444711bd9dde66f06c8b7287c93b4d20a84fa2dc5c16141ee5cf2efeb7609411cd75d3ac02ce28110450a061a32eef569e90fef5e9ae52aaeaa146d49f3a07dbe6ab0b0990228000fbf4cae44b044bccad91bb9b42a6fd3f9d54c82eeccb010b38944c544479f6dc4abc574740a5fc296cf9688caaaee86a2df1eb4155a7d85cfeb15e6d958d4b6a093e0502e721ea951080074be99d723d13ab199dee007ab23abec49a2d84fbea57f3e4273bb27d33b2e79291a35866413242915f142fce028effe1e8d5f4ea70995ee5446fce87758be16eda8d0ff74e0789f768abe844b7fdda99ecebc2115efeddbb2eff3df5493de584b8bbfc6e77596f84a6b953e6464fae8d02ff6359026f8676ec76fd3f50cdd640245e9e33d0c121fa88ce3f5bc1130e3afef94221ce56c9de3f6bbcc5afa4cd93d448ccc15b86df9a3f93645f8bc72c327cf0c11868669c69cdeab7a0f79ae5d717b35cf35a5ae7099dc1bef0d6b8f09874f8ffef9baa61e0ecd064b8d851775bbb417a47e63048ea0ee0f54c9a771dbbd091fdee46b36fd8e4068aba165a0958f1c34c9db7eca768dd19ed5f4fd9eeaa5fe8c25b5e59f2416c1cf9427df59241dd62bbc0d26cc89b38bcc45b40f16b82c7eed5a243cad3109b73ea87777588244a70fbcda41c091b797455e86d09cccb438ebdb86c039c6870a2d1c2f104f78b491034d7ec36d314d514450929a7171765c881a05c9853b96b4b5bae208087acf67f0452a6facb7a072151f94ac0b2c8aaa159d50ab85bb0347100cdd4b54d3efaec9179272eeef490a01d432d7abed3c8220a8852bb2da78c06dbc14293d94fa06baba2d991b7e93b538af56fc49758bf702929f2d037d9dc3409290b131ee41addefee4e676bde91d3edce412441bbc71633360a97eeaa2a5e8bd7cb9c787479b36f973b3661eb867051ec0273e478435c503c3f4084e1ef8535a68a79c99557b2ae640c0e58906403b5b8d7a6d67ef768f60ef96af51c56280b8cc17b5e7f725f2e50b109787dd3b018ba1cd4f966afe25cfd8fbe3a618801e1af443ad4597d38d1c27178c7103bf3be9a1d7a68fab841ba26bdb14658c591a2249d62bc0aac7d3fdb834cf29f4c068d81bad9e51412497ec70e9ff96e42f993c7358e612ba5368d35fa03544fadf14230cae1dbf9df8bbd5de6c8672e6828217c0e1878c8eef844c44f055660330a7cefbd0e55e9d1f4c474cdcef807a636347cef487a03200a0cb56ada6f99c7a84e58e402147acd98dd291e86c53d0279ee2c445262b4f9a109047097cb922dc055d3f26dbd9b4288726c40a52fa13cf4d3d1a1823a518818b2c6ad7e2b7ee4ee0b7544f9709fbb1f3f4d70b8dc3cf26c62eb168b0ae904fbc5f632017c85afa57cfa4c07e274cddc486d077b71250d9efe135884b9cf358747d9503451e4d0efa2bf1ba9c3225ba17dac94c0410c92b90f0a45d92346a4027710c827a90a1d179eb2b36d3ffde47bbea1711a623ad16322cd7d9a5c3d8f3972c196163fba168cfa44ca553855cbc2ac5340615572197b7eeda7ec375daa35d97ad353f7f7762039c4cda5aeb502cbc1242a884c3cc4881234837bcdd166639c2c8e3b71b984f407952d5be139d3b26a4fd19ac456dd3ea6949a437b396abe1a386f281bd5c70928798c92c37fc05ad640dda02e47e02a646923f8314a53c7d18ef7cbce8976b475807d249d78a35c663f5befa7e087753212c6b90e70173a2cb549d74dd6edb5195bb5891311294a3576520b6d58d3ba2dddc264e01b36decc2fa5af02c811e943102af33e33051389d01ec890032174bbf0620afe6fea0688a6dcc756b34b791127478d95047aaa92a6a6d961d882130578e4d3a805a4c4faf07f463f3e00ff6f187aa3cda0a27b1ab79a7f1d703175b80ad6412bb9d7f9a7745ecece18a5acf6348501f6b97b2151d39b3803189f2ec5c6ce2f7172b3fa24a2ac1c808918c0da010c43a76f19ee9690af3784cb998e0802707820831edfc098337ee28fca0973ca4241b0c0c763437af6e5b197777af603cf9141962b1c24eb216569231ce43e480a5f36da613293bda7857aeae1dda336b059c0527f4bba164a577a1a10de7ef1eb9c64b0d411f6bcb9fe016d7bb7e0c75c6bf253206523762680d6cd75314e178389b724778f5a1f17b74b5539366cd9a0bf45bb971e5ec4d5dcfefcce75ec2dacf9c55bdda76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
