<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7373aa72daea43bcd50ff0ef9f2e1a6a740ddc75c2ea0a4fe9323fb73aac24573b9303c2638aa4370b3732ed69dd16f96caabfa3eeb06a5c92b2f24a5333dd2d4fbbeda106735ce9d5e6d109ddeae4e5ba3e17c4391e79f003b76d2a8bd81fe7ba8178c7853cbab4b7c62a4a56224dc06a563b66f675f0e7f905cd4341311cb1a537b8d80732b380783576ceeef19fcc5dd45c7136562dd4f1a32010deb803c6c9370d257f1df67b248f9e3d8e5ceca3bdbe1db6b02828a33d122a1978840ddd9666e821cb6081d2cd41193a2db299428287dad5c75893f5df1d3264317376ea651afa45458a110b59d36be7f7b34de5197d3c547ec2079d1089c41287e7a569efdf1570dbb866fdc373ecf37f440642c233ffae65b46efcb40d7e8364406493200e71389ccee3b10a3375a7de491276d3e2bcc71120e1dacb23c4664c7ffb086d399ee1925c0be3f33adc642898b55897bebc9d089d41a01ca9a4da1c18aad340dac859b3eda4badb738c46b0699a2853e2536c40ec2c44719aace0fb567d8b35d606db894f06e1328232bffb8a1607329b688cc996b059740316ee6ec3c3b2bca6229cc498bd48061f4e09e86c6642e891a5ac03026d8d0537ab528c9585ebb90013a0188d15428b1e3232b616639b00c56dabf4bfeafcb528a9e812a57390139690b81425815be4017ceb0565322d2c4494a04aacc87b22eb177a7b7352dc8fa6f359364211ea49507bda226a78a0ee423e5cbee585e5dc062160ba67792aafe532c1ed5901e12818f0e8ea9c69da2ba2899c8648fb7ed88f81e4b9172f902776898a6fe506c8f1cccf462d789125f43a875a0d47615f7c29dc40383cf1af13e54d2c2d3ba6a25384f3238ac589947dfda71ebaaf0ee68bbc1f833f0394465b3fcc7d6aeeaa109f377dfd819b53282b4956e9feae2a75793c6149504a9c62ec9142403568f92914d08166dd3f7e24f46b90257ef8a509299394a3c100768a5ce6226f64ca96776bf4e89273f4a43ad4b0114507e5654294318a773209be64a29664690ec3b799b685885db4a25bd98f1db64d0191d9df9de7092924fcc914edb0fb04635ff93f6481af58525f9d0e49414ebf52ea3cc589ed972d5ce9285343ccf05e38ab4a59580ed3504c614d62af027a6e98b89e871cb36bccfa921fe5489f3b53a4ae95694f2dc1606d0cc6ae261cbd83555c55f479cf11dad6b2d3627f44396e0d22bf8d3dd3bc654b3d10c901dca0c59c53086e2dc2c67436990c833f9685c5c1be4ea7a17832e63fe95aff2fb2ffcc21880aa05b98ed78ef5f4f09900c0bc7858c871c566e6567a9fdc68d64e45e170de739289ccb88bcbdfabdef4cd5e501b3897414dca6da505b46679cb0ca558fb1d25b15081b5b536ce289838b6603ea648968fad04a750d09464636477950ebee7e700286c57c8be7df91ffa5a893977cf535d3e2f69b9766a961e1ad333f9df6e00039190ba58ca0668e8f5bea83f3f5fded0259884400a572de7abcd7692a5c0e873f4f9713efa9e6cf4325dcbea58d973e2ea7447b070969c38b788a8a2e190fa8666e2ca25c3eea29afd6420861cbf479e3875c70bc8cb6d6b3a876c2223dd9876ace188768cda267e6cb19bcd74885dd986bdbe47665aaf77d90a55a6ac42675cad43ceb5092cd41d7ecb1a83385419502364aa773c78a3a4cece9bf9a140949fd1213dba799c8a6bfc8d483c06832b55e4616db8a41949e7d2fb2188b3ac986ee26eef59c4c7e097b00b278bc7b61b4e7bd01edf41e28d289b2dd8610867cd4b47939ab5baf3fbe51c896dc4734015336f601cf00aa21afe6f4e5d22a482bb204d35d172c8f99757c85bd8a60c2c022bffd1d30870e8ce940d73db4e1f794435fdec89d330075a1dc6cd47c0fe205fc0ffbaa084e3426070555756f8e5e6623ec08255fb051bee5e6b4698222cdf4b146833ce2c1d9f4d90e794251ce05781180424e17514f33abae8d4e90a77496664a5b17ad233f733119a02b740431da2846e7fd8b9bc07e71bcf8f2f1455167c4d282fc92d9ad0dc240e9547847f7fb00b534c0fc3ab97026e09dc8b0f20560f81e899a12b0a26debefbc09a31b64f09c7993b661313037761134e8a8bc7402f828ab9744dec07e7b61dc4dd672cfb6cdf73971c3d85d95cedac23de5e2da008ac3e8f4a728047a2b65c36afe64bac73f9e3940d9d40c39ee131f0064e4f7f5edc6ccd8552631ca232d4fa78cdd0643f8bc526789835ac5f7f3af42549faef49bf6ec6c6008540f54e266ac44f509f37b606a8c74c2b79d7ffd33c2eb36b90bf2af4f79f792e30b492c0b091c2b3b09de8fd2f9a5e969d6ba28c122e19aada9c4cbd0e33e526acdf19af91312eda67adad309fe9bc4f2b91fa3caa1312cf04a7cfbf75f5d627ad3818405955863e866011eaced64f7d964b91a45494e4a0506e61f2990766c81dfa7b617b9e3fafc7ecb21d58396276098da7a63e67ff825843d00f59b00a41cf8c425b1440e418b2d08cec7753752c6d509edee557cbc10ad44150b3ba48d700e3daf1e71fe083d73259ab09b4884ec20a49e3a453ac68e9f39d8e7880dad628fed79a22ea16ce565de729583010454ba6ec0203525807e9a6300be2923a00c4354f8c8ec6b78e275107b5ccfef669da301080d419b48f7602430e8f9d99922049267a3f79c5f567145506cb9387beb8523b587fb6d479f0271ec128c8b356b2b92ef6807da010d9dbaa6a62934599b0d1ce6cdaae44ccd51e7d0e300a3f925f66c910983b121e906126f2a4b4df5c3de3a7641b5c3a356741b48a97c7e9b11f3019059880f8f5201c76d609fb0654a4c09bdb4b7372342956ed97523492198a95255646d23ed2450442bd881ea0e7320d7cc96582a77268cc7951a866077b1cfae87342872b5b70aefd1c112e1a49715a0b4c618f7b3745374ae26a4652f34f4f4077bb3ef273b384eefe338d2bed88c9ac32610a82a631195f2ab946f9f8adcc1ef2cf4335c9e9205eefd8f49034f1cc3f4d848c8d561e915daed4a2a8b738d265bf59e805e296c75c89877340fdc48c6e93281b5a1b30ab384deeef903727fa379ec3e20b890fcd917f61a06718e49d756567f70b1d596daaa957939e1b1961f1f2e9da8a0ab36e7ee3d27ee26fe564e88ab6c671930d22154398fba748862ebc053ca386ef24b00a26600da52d3a28c850a05aa57bc8d28bb8bf1952890442219958e600dbb0de809c903ed186eb560aececa45e9b77f04a6d3f9b7fcc8bb1a64e8e3ee0cbea2ddbd2a8b5feb2fba7c16c3f6e3f4e077707afe74ba90e19ce49b16d29f644d57ae3591bd3ecd9c72157e7dcaf01d51dcaab5564a308c29f1c2624689d0cda9077df87144fbdce6c31c207c9271f7906859bd0b42e0d63989204c3b4931069e2726654145046308e60daf4011002cb99af545471f815173b53e24b520dbcee7628f967f1aa5f433a8a5719cf003db6a65d756d8637ee61deed6d1a96e6bb2c8f153465b6d018f1bce43ce7a707ac084399e5f9cd83153cda2d6d0e06e04f05e9423d83be7284fb905567e6a9e2c4dbae5ba6ae2efa2c824ad260785cf3c3af886af35754dd9eff7b0a5fd82de6b814143751278ea2e2a9202d366bb1792f92bf81ba557240df0bc90a4e641789cc784c0d955a41cc3748a9a9a73a0cc686045dee7bb00f795622516f16096666473ff40ecae6a8dd140d9593ed13aae7537abb9a97d557e5979aa2e93e408ca65773c645152c413e9b0f98a3c7591e1910f8153cc0ea46cb559084ab1c8c265d2e0036cc814378cffe78fa4e3ede4127c6390eb8d8b652153660872d1614e2ee53e6ceb79b1e97b8d3b9733e6cc150d2235f2368fada6c561b07eb88576e32ac01b549a5598139625d61a1215d330120fef5836113fde510371600954fa05c1db0f9f8dbbfb0dcbea7ba0ed4b7826cbb1c22d7472885b114fca504fe32dc069ed548c22dc648226905e49c69de01d4e4bf5899f3c86ca459e571427ed501ccff06a78c171db5035ff1f7d8b2d03da965c208c180add846d796c5725d0a53fda0124cdb53235571235c70542002785d8a64d0a4c083525be802a7f93dca90e6da1b598cbc184f88139b366d167a86691b56775b752fde512ab70a40a8082bd9708734b685f43abcde30d5eafd9f08b4ee403fab60f53d2a2c3738573999a1f8f46764f8cdbcedcc2049cc3b507544500a9f6e23fc538b3de097e47eb941e37d53b61bb6bcbfe41196489a497e46f8956ede3d584632dcadc03a8b86b5a5a613f75d075d7448de3576a5e89257dda18ee038fd7a1e9d51ae569eac4896d0ecd82ad73cf472852c68f58c535009a676d117031ec8d93dc63da2d01d7d4cca2c3125b3f21a3323bb879353c5f79be5181925f8e42d89211e9aa136eec63b2b28331982cae180f2dfa92fd3532730c5194da9b3ae62dcc175bb25069542ee1223afd255f36faf5a0a9b5153b28535024ccb4ba7b2d2f2ef4b756e3b7b6fad8c0029ad925263fc320948d9be8e4a794267d157b637bfd0445c714877cfea87557549f769da293592f3d79a42f48f0c1df51830ac8b6b12698d09fad0577a24d79cb801768a0dc5c072bbf2aab7cc36b04c8d5aff580343c7a67a523d2cdcc80efc0ec10c577ae46cd583d7661fe9e097d78bb359976a975166ffae133240834d81c18272f99315256365218491f73a68b69f1932ffc49311cf08e10dba65f0e8d929bec97d5a64be25f921d6c5290bc9ad8fa042791ec720304e0daac058ccbc7316bb5cfbde45f405aab54afbe99436d4a0c01350c69efdc782f31c2da35cd5a166dca27d051daf78c08c6cc6239422641dd846aa939d9691a2fc5fb46593359d503d9ece9444b605b6681e34342b998865da952f423e76c5d62fbbf547b2b43938b9241db00ec21e3c89bab6777be522d9e467c8efd8e522fb66c072a2d55cce4dce3363ee67bff4f37ea3f76be7ab6fe193d50c9688dccbd7d91222bc9bb57190856f22511cb30936072185ff9ce3e092734bda4096fb6888be637da638100005c155bdff50873afb9b2ff3ef4c164e9f3eea9efed9ab4dc215274fe4182b04c3eb0f14a9c016ed1f3fb8b22c14884455a3c45a79e95b918ca180ed3c1a3f629102aa8a8c2c9fd2bbb4c07023972c84754fac464ea6219a4b5b03500619b72a847d6f8b7696820fd994b2de08a08f430377cecfa906964c744a845e819d0c81bff52e794eca6234a35243a57ce31395f4dbacc408fa497bb098dd76d8c412cc073e58d3fb6c694211abc408c1e1f19712b526818723f7ba46768b01d1e56e53492a42255870793f657081b332101650c82ad8defefae826029308eca5960b6b416906d73151011866b1ef1748d94c43b4a285972c64c6d1540bdf0c9313250250c20e668aa23ddd642b8b3b8f4668a521d605672cb6e1ba03b8b831add103d94e7bb8bdf1228857a66be9ee770a5725fe318fa4a25b6048c0eda2c85d81e5c8d34b4a9622aab21767fac853bf34b1dd25a2c28be068bf67da0fc43846e716bbb99f820e4be91fb3214958ded2611424bb0a0fc970ca152aa32d2a4e27c48a5c419631a57f651735eb94584fcc4d9df54ed6caf734a7b2984e7a4e048f51b3376fd3ba3030389b8d645bb8280e2738f0ed07d133b0c9627e478553c233f834dc5179c8b239f898ada0c109b52e50d9c80d8c0afa27514dd66bb9415a74481b79bdf9ffd632fa374f54b30f0e330a33a2b4af3f68393f4aaaa2a4921592dfdf548ce4d6854dd44ace55cc62077c746944bbd0acc9a414c108d71c3df68f8cf7d9549fa15ebfada01fdcb7564c95fdc9b5319df1d2e53d5926f820a1ed7e602fd6514eca22714033bc56e65d6d09cbb2d218a97074ab541d5e6cb925fe75f83bf1af58200fbd2d074b496c8b4c0647c42d42bca20c8c910a6eae9b17664cd35ecdab580390889eaadc2b5cdd82c6b543c46b31dd9be02a4cf75832cac256f62053c465fb74dab52a6ec6c3e6fdf604275ee6f40e75f08437983c4879acb8f3d65618199268fc2562a759e4cf406e2e84b790df9638bb452ac546d495153c69437ba2d64cf770da7a9a9e0da6113d41b489123ff3b09d1ea1a4ad0e7b608c8ca0073453e7a53cd71e1203c25ccb70dcdaee68d4200c5b63b8901fdb16a0fdc7f286b58000fbea99de83acde2ec4608bcb2b1e61bae25a9ee596e821ae3b98cf22abab6eda3e2e4250f6f643441aeeac58ccaec6f2804ac4591e8e4eb088c505ab52d7b8ee83cbe65ff718e5da441931f77bfe7e7fd42024839dd218e07076806ca5d2cb7572345035cc5324b42ae01668d82857cea0cef9b3cb41306d69b0d258add6948bee7cc6cf3764bf3ae70138806e22a8ee05d8e715fb59d6050a812702dbf622d2529837f76c37691d5077f60255dc3d4fd6a69a76a984454195598c48846e166f24c6da12334179d2a184c976216a9c9438e71e420800d08fc4daadfbf2d69549d3dc2d04727e4af4f14620b53202bb31dba3d4bcef2c52f6f5a3146d4fbc7c5ed87d8ec2774b58be8a41eb119d61cd88672ebfb6d747de4c3f330fc2021a64e3d28ada9ec78f983f206281ff377297a408b8d8e29d08873b6278a60006bd5a2a867af8b2017b01a71ece8763a0d5b83bfc2ba4f9de9b887814d27a603153acc6df6ade280a3e79771245e3eff5bd879dafa68e268904455f89711c5c74981cabc2c260ac4cd44bc5dbf687233cc409d62648693068da7180ff0e613889b5a0117f8d2f918665b93a0a7e995000f236c8f25d31dc7e73bf9945995bcdc8440625d1c98433b93d07b069c5279f90608feb120a302a1ac0038ba2b7bd1547182f737affe5e1c5218a5153c0faf0ca54ca733c22ac126b6a27bcf3be703c90595d1a3b4dd115f457515c812c53970128f25dcfd06db18025e6b2a1215589cef4bdefbe5d97e01f1cb504b17091a51b51d9d27db9c5cb2afd05ac9eb9c7d733d4e5d5cfa45965ddbe42e5c4219472ca9cda857acba9f4492008d8e42db379bc1096ca8f8018eba3c7e04390b188fe94a102514d3aeb8ccf00a9be1824d7289ac9eb87290635544d06ecfc1be55baea1e84948f34d315cf9901a4a13b063db894aada91da365a3324b0908be72767b9f345f8641316869f3693464c2924e8acd08a0556ecd8e2522aef0014b2f2046dd9636860c51b22c6fc0ac246f72eec05036286bf46f3f61cc65dac0c376c9a60ba69693cbc10b8c91adf1e85cf2db34cec147e35b7290b8ca70aec5c38a39e1b947ed90c2b3065a25b1b79396ba715a44dea45c621b9db821589196851384c9f8e1192fdb6b99dcde4b5162e27ed63ac135c517ff4b469e05b8f11030117e464234142a8f7417584f461307520199099a5422616ebfaf61d7b382e724465a902b5beefcd822a192b6c719fab8807d94d2be37f0f7302b3d4d22b7d77480d86352e7306e69bb7c62fec7089bedfba55c104c1fa055203c7301c692bd1199c0f635be93026ff3424b9bf027d3d2ed110b29919e2aa83ff0659c3ecf982c5218df6469197483103b607fbf889a5157ca07cb2be2b720a0468c02063b1e6742e1c5bc4a4f2ffda5447757042755b30eee8fb871d1792a8d150df6db1bf0a0692a5f36a6c224aaa3c4335e1146fe60565eed31c92a43469db340cf8c78ae008b1bb21bfac8d8e763985fbf83014c7bb2fe79a3f2764af2931ba3aeff4e9e07dde53a8f736e0202af5f6863e2eb206b0ec806181c49bc51af862b93a15a1a1c3384d98565f37fcf0b89c3437618621245baf481309f5be8761185fe7f26af4e94f8cd6a68ec4c28d04926a685e4723014dd1ed8a792fce96f672626b1df586eb02aa9443dccfce9db223543c388f727b4df4c76de2a7ef5bc56c40fd0bacea6ea9026ff4a209666d8fc6600cbdea884adfd8e261968eb9b1349d48b49c24d3ee3d70a4df5c687ded07fa1ec8682fd4c12ec9283b48591b21c57e93bdf5bc84384f23322adfbaa5a3f11e96c926ba29cddc1b1e62e34ac573bb165b2c72fd1ef46df590462975ec3c0410b048c5bf2233de7434e782d3a2c182eeacb31732061a89fda3ab73f887f756d33e25918b4bbdd9a560f748964c2339a836f148d8b0b8f556d91211fa2f5043bc73647b71d423ea52d98964381378568ecac4169e8c68c802b0020bbc4c7bf3ceed433acdd96224123b5b14301b1a283677226476fcb508f5902d04e423dfcc3ae9805791cdd5300fa942f7775660a233f8c3116b9383197cc15ff6c368d1f0d2f289671c32a0c7c1d98ed4930869744ecfe85ed909ef3aae1829bb20f7daccd74d2a0685298dd427280db0d1db12113ac80b519a5ab13c8db0c5a16ffc7d2f52a8b479988f66e0cc26c39a7f679ffe5954f0c42394473a7f4b1ac5b23a30b4aa70a88f6b784918b620e3c76f55eb1d60d2030080e25b0faab4d16ed195db700817a249f653d4695f21efbb199461f23d6e35b76919313f14207434ce5d9c3f61c6661cd9a94fbb60567888b71d1f0039df00cfc2b31bf4885da45f8ca7cd89cfdb3291886c92446763daa6c36f4ec57e88472434b34d88b829a6f6b0085100f4dad5a3c7f9b3b4dfa1f4fa23bdc88356efdedd18b3f3581c59368508bf0b3b76d4d79a4964ecaf6a62223afda48fad5f98486a55ee67701e6941dac03ebb2d6e94e1809b4c84f2f2814d63170f46a12e0859b8adbdedfa1162d60605344734082fd6d7ea524e03e458867560c8cf59c9cf76ef8cee6a27975cc9b84b6aa2f7c25b1ba702c6088c62810aff400299d56c3d2ac81b50b1146582940a9a5ac57d7e8e81174f4d44381c78957f73318f3cb602a7fde5a0cac527436f47edae2811445bbda2be75c32820dc23f8dc871e5577a746f6783faddb43409bd9a4f89b0bb9a1ae76b38b265ae5c97afde6b4e8602ea7557991112c330761e328b0be5abf9930c6ebd000008bc6ff0f0946c7aef822c16891848757aff03c9001376d3e0bada416d3c79e99f17401c57973ae6dbf64c376a7d3fa46063fb7c9746aaacf91d8573ccc94071e66509f34411c921f3791b98e80216be050079e94abd7c1ec096dcaf64ab010dd780f5dca0d2c8224ef0d76fda563e2c6eeebb4f5ea3944ae297e829707761edb2d2662a90e1843c3287c406ab073422b1389e9e3ffe28d56bf1e88e1f722dc2644744704fb4ae550b98fa7bdfa04b3630c99ff43dc39985dfc81ade9398acaa15da4798ac5c41802d76b12a59f48d399ad6826c41a0ca2652b44f8f27861de7550c63e9790bc5477b6f25e60d91f39eb27f54a95216c4a813d083703136774dd9c4babd223311f4bbeb1573db44ea097152f6fb397cbeac15707e2dca50475e2727c5edd59282085f06f7ece67d991420571f4fc2b4246667b82131b5abf3e426891aba5420662ea602cd78eb85ed0928111dea4457de1360debabef27b093b2d55e7b106b253a0b330fa1e8c9e419b38bee8c4f688af648b08138fded3f566a6c6adfc0a92ec564f5e6206d0de6453e89302380a3d5d760f1a423c95c214ad6595fe6e8f3db44184272817d460f03957f87d043b544a90cc0f813ecb41c858bc074c2ee4b6b4f117efc7b9e587bf5f002e08c894433ad4595c4539766a2315565ff615f44a495f3a2f043171c51f0410f2a1bee2b39f9d6ae013e237814837009efa1c30f7728078e7c1cd53360666ecd9fc125c282b5fb30d34385f0bf53cb7f94841bcc2c15c27b02ea5b1a931c71d22121c9eb9e0f7ad83648039f65259f857f8eb2d38c209d4a015ccb6a0c931cd2e84111387f3bda0302e7f8e3c5bd164b23c53552a7f7dfe5176356d9b736d02610d6b63e0e82a0cca1ae7960604317f7838ccc270aa8c1480452b5a64e06d74a079d8bfb3299fe638619305eb666ae974a3fbd1ade41c86af72260f391e6967e0d02b1b3ce99ce82d9a705a6145e6be7aa9fab821c7204359354e1eee9ad83dea2ac56f43ce167c1025158b083251917f47313fae414e4c1aa546ed61f5b9a870e0b8d822159e5b21bc939203d0fdfe173c4a00d072237dec23be2861595512b59f47aae75a49db8cae3572d82e8036ebf964a44ed56b57e66353dc4bc63cf0a1b9331d4c52eb245b4c6d171baabd65156538e74d8f55e825ed6cb9e022c6e9a7d1ae1491123920bd2360eb4da04186c8c4cbd9a7be9d48005172dbd7d3551c70bcf0cd1a1fa55f32f8823ebee686ce5e3384d49976f25af7c1dc194f862f26e9c2eba34e96d640f59d4756c6ff2961b749ea2c5141c0b217cdb417271d8aae9ec8dce4dcdd4a5221299bae20de226c1a93bc9e4bdb82d3fcf8aecfd3531bab452ffc2f65c30dee93ec1c8e791ac76eb29b432eb7d6e3bec39d19dd9ae0fd0e343f02a9dcc1685b9ed96e115d188f3eb1cadab1f7682e52d3cd6c481c8f95e75dc6a25858dd3e13f6cb8e5cf84d75cef2e3c6b848391cd50bc84de6e6974db0fc006ce484a57b238788fa3438f4c56fdb528c2a082141113b7ebc0909fb617f5a362b3634a69b4385fea4131f156888be88a799bb1abb9a8cf45bf76b4b6e5138cdd7bc40a235bc6a287770b1aad784cdf69cacec1cfbabcabc5e4c39e4d54184bf611ff359383ab1099d42c5da659e50b98d2c50a40d26b33ad6a7611c838cde8513649566774c9e0b3af06724e47bbeedbab9219c17af93c095f14f042d252fd3372af63ba16520ab667caccedb335e96d037437aa981177dd321a0df06f654587e67a344730837c77362fa1f43182bd68be83d86b33c4974095a33d28e06d07cfe84d6279664b0943a60d1e4fbc167ddfdd2a55cd7cef299a1007056d98c3d3432b2e24eef96b9ecfe975394cf29cd29d847e1bc1d39805032c5086435fa4e2b949a2ffc234c139bbe49d7a16e6f40a646944d3cca3d8280e9965d3569a1b60ac2175c291cbbcad8d357455bc775e40852ec61324cd74926d3c89c598559a6d96c950461929d912e6e0820ca2e73fe5d882de91fa9fc721584ee71a49411c4dfa555f5534e15c60ec6c7882397ca0710f869fefc66926645a4e1d3e9dd114d8f097fde35620965d19aa9e1e3e44d66d16c756b523d9576d1f5d65ad2b521ef459d8ba3b167896b889cb30105bd7fc6a0fe360f50fc9f0a9c58f2bbfeefc7ca9833c8034c67c4c23f28ddfe705c4d04226a89000d9fd5840782a637442f0884ea478f2bfc22f9cfe365ee637ac1953c425b039ba6dc95d43cb2b7cff4af4bbceda7122a8d460e1ff7f7bbe8de395071a157e596bb474f8558b94492750cb64ea867d358c627a00a2dbf549812bd5397d2665a80b044600e7d684e2d7d06efa9da3e2ef0b8cd1fdfc4a27ef708e1df7bb2c5b91b8f6f6aac4a2ac2d82936c0d72cfee23dde12a1d3b3d8b36abdb516b395ceb71772dd31e0ac43f111af30abad31eac82529fa9c695378febdd9448abf1ca50c4352ed6c7cdbc6ec7d3dd50cb3f97feb42a419c1d547580ec3f2b2e4d0d881ae6417497ec67dae84cd29158f988af7ffb43a3f6c9a0f8b669a4055d3c56c0203a57f3cc9d80889a43ad9cd999265a8792c2796b024f58d52f59006275e8d90c2fc140401aa8fe973dec701d7e29c6cf785767d74e2aa80ede7912f61d9f59989c3eacc7d521da978596a1cfee56bdc7db3dac8e5231715d3d5e6e7e0e959dcbe662b4af0a1317d36bcfa2218161e4fb9c2af719e750fed0c6cf6f99f4c492169e07a91913e5ed5a3772228201e17ab06c4943cc42e4fdc3b70340fe3c544f649366ce6cc450d03e1046200a701d706a21bf0f19f92010273726cf20e6df0ef12b37ef93f136a6d1cfc5095fd4c6ab5e9b5409360808e8975f3541ba8ada4ca6c1cdaec0019ee997c4bf3af4142fcdc3b58b7906c485e1ef52938f50530632f2ba7903d198e0e1c5a9490caef0a3638d247d9bca82580c944be85f8c125d5259d4174b4c325e4b12042576b4412bccc09fe53ba4580f12b3eb695ce8814be22d896cf29d1ca0a91d26b854665bb9c3b99a82ac3b6a13b56bce883bcec65358d1610f75ce15de2764039c4718d5558a29ff1e055bca12f40690a8430c94a235c67b9bd2816e482361ed0cffd4738ad5ca019f14913479a0570c77dbd4eed1e7614b72763dda2fb0d8166fdf00bb92a19222a8850be87dd62d2852d0d5b46c3aff4561b7c7733740ea62da08f35e4106f855d89dc3674145c67ac77d554cf046b811903ceefbf33cad97ec6a451cde16847835d66f2a014c298c39c74878eeeb86b1332e54037f7299ea58eb6f5c44af318a84c9c3eb6dcdcb16e384108ed7d58511faff7c74dd35e90ad67cf1509e3d7763b3f3f3f0b139180618d6b6c5f5d376d7d34b52ef00d6ecd928368360a2521c57a734e32eb03a949da18f62c905fdd57e3a8a6a7210a5ae8673cace82a1c69541fb34a9295c65d1035bb74ec2dd275dae421aa5eb684ed5000b02f4e53d9b64099d2eacd3d83213b828b3fd5faf2a65b0bd85ba7197b0e2316cad8e7ca9b711665b3fd7dd3d903e5386652e47a63ee685a5e06e95d0312a0f5bc86042b77ea7d7e0b45e794b74d8df2baf67b3fee2f318a899cf2529542a1d093bd089181e325ca6a4a30e3396281ff7217102be6e194e57072581abed43f3963b9b8fed0db60eb8f92178a558e91c84e9996f80762b58c64f92e1dbd76ce9797b7c7fd935d5fac48e860a64b2907a1d601c25d62e572a29043e5796373d95f5acce40085c3409eb71d5ff5bfd1023659701c1e4637e50bd98ad0632dc812d7fc33c7685cb5e475784c49292d2aa0b70a8cfd22f8e9f27253d2979f90514f3e70cd5a6d61f66a12a2d63d9350b8818738f27173b35d326865d9da26aeeaf85f447cfde4fa04457449736c4886391a2aebd8daf8dc5de98cf683c3cbab8c904cd2ad86289fc4b7e040cc881568c7ab34042f4a6a7ebc93dd624333dbff548e43404c91e70bd2a28ffc528806043fa17de08dacbc12fd6682835eff0ef90806c642e0200567ae665ca161023fdd770f16aacad78285d74a801d31372ae8d58f068f7a0c53e4ed3d23a2af812af80c13f8b6f968d129a056c7df5cf986f0170915048d8470321350ca04b5b63e0c8922c773dabe7f2d1060457134823c8be49681ae7183c59aa6f6669d733d4e0142a3004e0f1130f20dd88aa408cf059b7e2e8c61f492048d48e1b328d7584bdbd6715487251e45e7b635ebb89adff1e16a59297ac3a20b95e560ef4568c2c13e746b1a907a50461243e978e82f82ffc0826ab450fcb28fcd0adddd7153b2940bbfe77fc7350dd3ab01440e8069e2c931eb0f9de630374d76dc980b0cf5bad271c059f20fff389d20ba8f4c8b29bd82e4b8ded423ed8bf23fe6bc68c5d1aee4356393334e269d9b2827d333393ec88ae8bb305617949f0eb6df8546d9edc09e1002f40366f01a26b1a04701cb2869709539be47b6e835175f61b8fd9a3b151715973b8f68aa64d65e7781cfe0efce5fa0da669d87cdb13d941d71462b8da94d973afa94fc6546063d70efb92afcf6657f1487b3f372461a4e724b7003a34b31e0309f05a5eba4b1c9703c87a8c7c729125f505c70ca30bc9171b87ae3d4f14faf5e627994b9b6c8aa67251d18595cfa160ea02c35f65df7511f81789ff0427cf9f9cb7f4c222af6390fb7be34778f507ea7f57d462c0286d2713249fcea5559e43c57db7b5fd65298b6fb0550ebe79b1e809a8809016cd54ae5267d46ea74655fd269422435e653a5ef1de5bd84f2065a4c9089711241c66f035a10c3adb25c2e1967401d172ee9944936f7d6b9d1bee4350f5b85b26a93dd7cc759ff80e0c1fde479c4aff05ed9645dea1a1f388f313099fbd6bbe89787be40c0af97235e57b74e4387b5959cf29b62e8d4748a5c6959cf5f512e100851952a62aa65153a891459e0fc179af1961fb4aa309a029c3c822a4847e29865c09d67dff3c489169dc6ef6e7224032960371055b5e026c8d0e737d06249b2f7b208044935f2d04525d67860210362ce94604fc363ba49924569818b89447ae73003bcbc486cfcc04cac5ec4959a4ee869d7fc5e01ac3bb498ea62f81c9b3c395d8597aa8e46efdd0d50911ec27e2b9caa9f24631d1dbbfe55afc4b3874f5475dc9d55ff943a22eb630c0851562de07e859cf4d8cced8299012cfd560fd3e25ecde7f41f2e33be4798a62482138d8039ac6b2009cef729cddb8f290882a74e8adb327e7aa0ecccfa7b0fac5ebe314eed20c620c107bff78c546eb22c7c843a0817086d32218753f3cc93c2156a89abb7535de21109d2ef134d3019ab01aa5c1dc6d27ff0c0d17067dc15112a6b5d448461448caeb6ffe0c6049988b056a01a6e7f5686c73dd2c96ef8d4f5925749487de3e19c200d79ca4676e4f6e7dab93ad9dd2d305af89dc093c4626496dbb341d63f002e39984ad8a0fb660e6f96d61da8f24a074ee3e46df0ddcaa39b3f39552fb23bdd4b5745135081d12a03b3b43a5fdff1d40263b2f6c45147dcfc805e1e3ad31f04b52648499425ce697dd7c6a95964d2e3ed6ea8e6d7e555ea3c87b88f438ca3a2759971347e9d714ff35d69342b74a2d6a0a67ca129c607d548bca3919eaa5de0ba351ecbfe553703c82e40ac03420ffad8d84c77d510a241d5b9b70f631f03b0b7d8cbd2c2ad76b53998f43a934f411384306087307ddd26643e9f8df647de3b9b756154664d34d78f4b9ad3ed7d75dc67ae625da218139bc62b800c39765f2033077c0e9f58d206c1adb05bd9ead55083be992f0f9e2200fe877ae439ef3d713162d7b1c94d7fc4e21e66b8b54e34afa4350442d0f917aa9158173c7809d07b2ead399065eb8b46044edc7749066163c2fe55fcd1f02e58898cb4711e8a5123065545bed9add71d5a68f2325d63c0c3a980a764b3037aacee5293a10129854ff64a5388f824bf0cf2147b5b83fe39827500d44ee4500182e987154501bdfaa26a1ae2c2f1bcdb93e1fe8b39e00c773340e41f844532adb29bd89cc5f47802cac3ce8575db035243cf4953040f305faccb260be7ca741fa5de4bea27224847df818828aa42ac06856359aa30fdb45590668bdca6f8d4aeba93c84f46c538f4809f52db66d49ab45aefa10c9b77e853a1d5b9dd680ecbc8cbc57a0774cfb0eb8abe99a5f6c45ad52fbf6422396a0002027d4ea87d27b089441363abde87ab03b6b9f735c2d1734048ff1b678056bb80abe0de8e9899d50356a4ae2793cc15d12ec4e2400ece5bbb1a5e6bc78af36aedafab7da1ecb6d4f20d76e87e8eb0b5e1825b3423613da19b4bbd3e08de3625c6f9080e3cf83f72ffe19b3df3cd34799f61ad0e84f2f37f7cdf1d278adbec695a9ccf55ccae697cefbd6a2e1a0d2ce188267818fd2d206e42465756c67ae539648c68d8299661a7b55e3796c2c5783d75a45cd48c2b5082ce8dbb3e7cb27e07d2ca6c9e5277f4bfbbf37522d52ad2a7c5db1952a9899efc646fa2c732a7aca588e59b15db1886c0ffde38a957359f34603d10d0c74d223cf73a810b7268ff63789b13789f0b02f22edd97c291c72133f66c8bab62912d4521036fb6e60cdab371a50bdcb9e6d98e150097797fed186d0b730997d4deccea441db82fd0c1df5ea8ca5bbcaea217ff86bedefee433c64e3e7d462919316d78a33d2a866720c7db9d6c030d4a6f2137337247362460770a41e7db531361b76e4cfb271f4d5db9f49482409d815cf17ea5376bb44be7f2bd31962165031ea13de6b62fb2eaa3af725d752d2d04b8540ad7899670d94d41decae746333b050a5c4228768ef9f67ce8be474b7ba5c0a566ed4f5f620737f1140dc061b27aca69fd6157101399a67ebff79c719eeee905bc07efa2ccce84041140d6e73f821fddf9f2d4d824240dda5aebfce1c99c1db26384ccd54537939855ef9443c6bf01708b75506bfade53a6d428d37036fe0b165b38a283d5fa02d672443962491ad04ad73fef4d53d6fb346648da4466969c9d1ccbd7d233ea25ca0d9f45f3d0f9b613f2bfb8ea3873e6788d316b2018c0ca2e6141f371c3474ecfd47448d9df404d43dc86dd94adc0d971364206f2616e34497fcd83120cb10f38a00ec52f4bca5cf0ae167466b6dffc1e4c1d196230abc0196231274df6fc718cb34f5386ec18e2516f8f941f05fa3a3515062fc2f4a14cfdd32272cb0748f91f300db4c657dcdd9037ea575b78a04a7a56a8c1c344cf4b7c11d07f081df7cbed05c757ecc2538673de40f239516f03e7f151c36070d41cf76f398ef659ce4ecc8ec61bc20184183fa7e2f95750ad11c2a6907800dd68de7587c264dadbf816122f2815281ab6cbab90f74688f1ebc2e9a82f7c49ca369a4f0e2ec577037430a462228ad216ca320071e6607dfd554f65b764a3b9cc6767c46d3db341dba8a938ba6f016852247cd0a9075906af41d4375dbed6376ffd9e78becfe3f5d25e391b03a931af35b7664506e59d0e6c3064b71b37f0253d4144a704daa2d19a6b0d6aa432d8add1d565157cfc7e8a1d27defd5989b9009b18efdb8a033a4cf6e2a55f6c1ffe884cf6a35e33b0190accc1b994adbcfe4fca0947f4fc9ed56dec097ebbdbd9520ef144c57808be07dda81d93e56df03fa01c31df6c015c5db09bab379617836f7e5409e9da731460200410b9d591a7dbf146138b583b893b8dfeffa43fb825c7f3e6bc04e0cdae965cba2cd440eb18107ea85dfc52751a1aeaf7cb7dc1a5d56f828ae3ebd13599951a9081f84bdabd11be7e359f72675beb24d006e85cca8ce0ce856ec9ac7e616c9831bea86bd222323309ef0c2e68a0465d5d7b684082d944b63d5adaa2a0502261052caf83eaaa7e3606d58e48e8dbfe89b5e9286635ef86c205358279b2fd871f30fb41e0360768fb19aa2d8ddff56759298d1108b81166a4b2a09815eb05203e9a0baa850b66284310ac9e313c7a1996b4cbf55e855feafa46eede62be244c41a2f951619c31038d404a1bbf1999b955bfd6e33fa64b548edb234244ea75d7cb83883467a85e265d7420d0757360c457d7d1230beb4d667defaeb88eaed67bda45fcc004e5d53b1d1074e503b536be15e49b8542b493016cb3f47c08fb9c09f8862de91ef5f3828059458777037fe43d3d6699423c2c7cf41fd6a4a798713a7886d2ea2bb25802a0f73876af2b567455f7f8d687160518dec65939f6e3124ebe87074bc173f35b0d70a96f4dbec4c01e3f6622686c360b3cc71241b2f83e037bd6b05126a12be051a2995042b3c34e76d02f1760c9541d6ed6ea0269a23bbe635cd47bc9ad3dc5f2c6c717e3642264db665b89e96c92101b47eb92c0e0130b481685b8242f239e14c38ffb4cbdb018958a245d17d5dcbf2147c277da29b72ec86f422e01a5814f658ff2a1c3c880710d2f91221a65a512f80d561027e33cf1db5f419373c2d9a4a24d9d6ffa111608915dcd82d84e5b953e5e506ea062c57f008d8e861a9244d92c7eca692332572291d5158b73e04f135300b3fee32d31ccf2260a8d6a0499934f88e662ab05c41443cc55da4308b853019015a8170311b8247a44c3f808e5ba64899eb465e3735634741d5c9fb8790e1d5863a5e0eb68dd3ef121b6179a16b385f61d43cff813cae563356be50fa248bf56b6aa69ad438113b7f489601789e407c3ae1c3383698c75a60e24bc0cc3b861cd71e702dfe7f3b8a7f408043205ce320d077b884524d3c04cbd7bbf4c0db31d89e372b823a24daf45946de856e74f8594a484857739db8c0c20c4521984739f7d7fa7a4fb9fbcead22dce2a25efba471ebde341e5e8a2b28957f6c9aa17fdba08ef25e64afa49050212740f7689a618a2457a848d25575d39c8186510484e189f0123dbb37e855d787fd780b873817b83560c3a485aad20c6158a50ec76395a2aa47b24f77cbd1245249df1204a1feb2baf950de5370534090c02d78a781","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
