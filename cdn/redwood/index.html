<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b751af06387e30e073dc25b1bccabb20a28d070eb3bd730aa9ac3cf81f0d460d42fdf624aef3dc6c18edf4d20d8e4bd15af1fbbf8bf476c34a6039178c8668aa2e6f175d253c0eec02c0e3b674fe077e372aa79980c0bdda85ac4873923524df50d897921582e076faeb8bc17ef98e20fda1d033c7cffe929ce5d2f06f492f2dca4512c2cdd2dac57ac662d464eb7cf863acd41b17a64e415b113319d4cff089ea223e8f1016226c430e03002b01a67b110c694fa95f8f9cf4625f94a8ad90f72dacff025440aa6b0d219f6fd61dab1c2175cf8332ec3d7ee12c3c9697242017ec25b8c9e82a0286f5b2bab8cfb559eaecafa3182bb036f81a99dba6038c3a38a5b87b7394652b9a1b23037061663a214f17a10ce6c28ab8c8dedc79b2c73575acb42f12355caeddc02743a24de689bb0e5ca830cf58b8010ba178d9851e8400d8f94ecebdc622ead7457a6064d910480765bf74776fa77976af731c110c0b4545264f1f4e34973c34f7630fecedba0cfdc04ccb2fd9016595425b098d0e8f5eb6ccd31e97ad722a3df73fa07685471b61b452a93c30daa55bc64fdd7e7fd62cfdcc55a07749acb8b12569613387651bc33e089700c0217dd4fcd7975c203ab186ecfc06d4592987ddc39850cd3d5d19cce58476d966c62c9a48d168a0f1614bfb490e2acd300faa387189c5c5f1b2b0632de361eb5e074e78c75c5b5b929d6cb9d0a6a0ed95e5a56ed8f88045e6b663344fa117995fe21ba67d36dc733be926e5c959a475536e40707594644fb8902aa5b4a15e60736eb0cbe08550f63f96e9a3882637045f9ef77ea1c34eaa9574384ddf9157cc0f1302ec26b99c65702fd7b528fae7d60f88e3352ac73d028d05a2106e5cd6f0f76c093a14c77d939a1e1f23c84a68c02195f28c7f2797fdd93164b42d054458a094795cb84f0d9228aa6170ff43606eb679292bea1cc1bdd753172b39e9af2bdab79734c46295e65582c4b1ef2d95652c18530d4ca61d2ed0515595facd9b3672b00537e755c9872786879f066191416b175822c42d48bb7eeda0025f72d67e7095c8a7b3fcd40260a965f9d03aea3d58b428b98bdde1752ced607e7cb151127d93cf5c818208ecfc1ff3265fabbcd22df37272ae202239b6b87b37f95ef97f57ea7d34b4ce4a8f63867b5fafd08bd5ab93d03589aa75b82bdbbb0702c3299de2e15e990d72032a5b543f95144e6cb4d2213a17e0fa21615c20235a26b40fd5d4e5fb587ee468777412fd7ab7631449ae73cebc979913a8f8d16b075f8d66408d3a61ad051fe1a0024957adaeaa08d414e280333ebb7aecb25a2226e01e1e0596f2024bb87151c9c0d0e8e2b0c0946b0920e0ef6e43d0ef44121e1f2af0e56c6f16413e5ac78f4f2897a52535ccd8cf2a2a799f7a7349769cc4012adda01c3959937f2f8b7e52d7fec658be960cf06b16c14614bbeb0d7d13ee36915414f4192127220d6358d749dbb18cb858d619d59175aaee66d6aeaa48683db5ead2d62a2daeadf96ff90280d14311ce3f38f64a3e856fca3956a4817002dd013c45b97e40fa7194f4e33b4fc2b12b205ae453e5317806b4d3ecd36bc66b10eabac6702551412f6b432982cc8d912fe7def43effde6fc4233f6aeeefd1d35216986182eeeb38f88e7aab8d0d38210ff6fa640ce270509d9cd2c0b2452802791ba8ddf6e19617827e7fd41187c6a6d5079dc55eb83095369abe283c5aa643bcd307409f7675b0d94d2fc161cc5233032667a4b7d9e764c3b472e724cd50305fe8be4106b214f61141b0b4807681b3bd02f65530f9a7c8b0faeaf4c3dadb3ac089148e1a02bf56a4af8f5dfc5e29773584b4f7d3908a75cc108ec6e1d3c13d9e34c3d9cd1444cef86498c2faf1cb13c53a1023fda13637a2813ce99ed02c5d438b2841a1e60e5067079594fd5048f3b671e36d41aa627f6d6fff99df389aa930eb3e87400f97074126917ec15f356098826a5dad3940eb034974591a987afc46b8465d1809986f3baf4660bd7ca109ef2a13021864c10cb147dacdee1e7902f303a945d2e49c9d26e8dcfc8675d63cd4706096bcdd58d5b58e61ee9101e30e81d4199f086cd782e5ce95de767eaaef4187a31804f28f1159ac5b2c84739096d7a6c39be4232d574768a38e948630baa2771975b84d7d4b39df0b39e528eba9336e408fb93c9111963a9d7f5e29b8c6f62eda30f7043fd548f075a57ff46a1bf662d0816dd7a40df6081639529e8e52144af72cf84f169fd666535cdc04050df9943c1e9a5c48f51b47ac7dd40810fbab6df8cc887688cfdc3de46c2b6f86325ad5cc9311fd32f59b8b78656b08c731283d4d84a6986022102406fa187a0a48289f938c052aa285d7baf4750c763eb95da04ead70096cfef83b2499a42008d10e220bd0cbdef5fdc97ca60f715b86c828342d02b31316039ff5cec2a03264261646b4a85a122992f979afa3bd86c7f7e3d8eca9c21c922b2a7cb16ffc88da64128bd4bee756e3c1692031e51bc4c454cc1392cebe039c8e6db51b107ad342bbcc6272fd6e60f286a6d23ec9683bdf844e9661f44b661417f1b07a16a79ed33ac5782ae56d9e20b2eb9a17b8801d5ccb79ac8971154cf047a40f56b8174c2ae2c2cb8c861ad8ed17124d9008726561f36a66f4bbf6bae1d2303f358b2dbedf0f30b144f3cb5eefbe520d92e04fe671b8f16ed7478579af21e2ff5119884c9fdaf3dffbea0bb9c833fdeb5a255f7168c3ecbb65763e3e54cadba06d0f68b812639dd5a746a858d5aef78070fad92ac2492c14c1800a373cb6647c6a25268e6ea6ef0bbea6b2477c85568a5543197869c1bf367005ed5d27367ea0e3a25f2cde23a79b429d4fbd74c3408760fe9d7725079f64436138cbe7c85044f20a5f7cc16f1e67e2716b0cb1269d1e6208c555615d7a0d531e5a23535cb2c07c2a52f341993429d5de571a72b64eec7d1ff5897c06d4ef0b42748742f8ea118a83cc484f4c6ffed8854ee6457b20c447cac350913d78b1290e13eac47b303101881b6a36c1cb135c63c297163b223b51ebdc5902ac3547c0830c65154fc05b6b8d05fa6a176e9c62ccfbde90a584d7f9f8fba4ef10c7970d740e412dda7c2aafd36caa8b27e85c02a32b1cb893f4a85049dfc4d3b55f69301c73c88f8e9809cf07f53a777fa7c59dda1ac619ddf7e40f56d7744e573112cc2911b860b03b3019d4e0ee98948ba9718b56c9c05ac97ca1c4dafeeac5646851b757a926313676be2d1cc41899175475662b90526faca4a2b7757c56795ae3dfbe51555bcfd7e490e2630a2bbdbc51ac781c6a83fa1a007d84f8625993acf87f7eb9b40b83179cf207009bd36bd0105a27f24db07fc2b5d6af8e37ab4dd4e9e77407a69317586130405e19f17dc0ff199deb4e403c4b7c8ef5680be1894637b3e23f48c9a8b9e78aa55ead79d3dbf58521bb24b8068bad0aa65e684de2d48ba015df7e493128ae7d6501d6c0572e818df3f106253b4d18c24456b0dddb7381abe2733e37ab83aecdeedb1b31f43771eae719b4efbb5cd9c31328d17221b3b17726ce86e492e6c1b9868433ae2619b97df128a9b047f8da049a5cc05fb860475833f42fcab7d17e34af666b06efba9ff3daa9a365dd0a14fe23df614a9e81fefea252c4f739528202d2825a599d05ebf6efd9124b90069971dbb00483d0106b1aa9e1d472b2ec6d49bb8bf9a8624fe2388dd8638710a065761409537ec9674003d4f05b647b6ea27ed953ce875a276bdb4734be357cc9732dbfc4c0659e3cb3b02aa63472fb1d468db3a11f14ccd77af4195a529efd50f08d6902fb6bf02cbcf702e477672561a67e49306ef5a5f9d977671f4d2486ae31d38028d69e63255555b155045031905e6adc21bc0c6fad5df97a99c8f2f7b9342ba934df4d32eae2c423e056a12dcae80862e7cd94f60c200f07a45416670185f5066280d2b1664a827a79de9f64c539bdc8e1bee6c36616e5d7c0f5a9e8e5ea4f821cd83a58369437545faf719f030dceff972e94961873b2b66c3cedb92835a48ab482720eade82a0998d8e2f12f64be19ce4811da4e962d492ff0f1e75261be57567cda593d7f9240b9347003b7ea7ac48224aa7e02bdbbaae9b5a4680dcf4d072c54928677247e8b80033fb818bc15d35ac5baf3b7fdc434850a77b1e7f257c743cfcb36d8b7d49e5b94bd42059e28a4adaa0bd534246bc205cfab3e9e8296974fdbcc4f35eda6de08e858075bae92c92101e159b421c16069c2c3abbed07f49c04be97e7f3d671ffdb47d2fdbd402ffcbe09158eb9d205b04f0e52b1a6d4dff31ee166a9e56397726812405f4fee933c7a81ea2c7d82ea859a8b0d6667abd684c3c04cda16efa934670efe9be477390cf42809e8d56d9ff57a02d08bc8d5791c02a81622ee01da8ff23e724e706073174ef3f13d637cc177d90638b9354dd6148348ed9789664b1b5db4a6ebca9c056283b62792c3e1ac8bcf52fa98cfc2b6e3d02677b7c6a37f0ca92828ef3e9616bc2f7971f22d2c001b5682170b5943f010235e2b73ec790b039d4be33d03407f0efb1b6ac73acb7aa26ab30da28201a83572703b82ca78aaf476d9f78ba1bc51ae1a76cdbd4a84697e1cabd71bdf5e1260217898b0e8772c64e676f32dcc573c7a91eda388abc14343b0347394ea512778aa8bfe43db4f651375621dee8a7b6972a53983763749d98838244c15457bba36330c03520d5e8bf7ddc8ecc6563cb3c815ba31b737aba2467b85391d696ec21310c96ee909219bd3cd61c0ac6c1b918e6a10678ecb691b0b0f484d14ce16e560b37d05f3115d36371c4e0c6aa568be3b4ee746c4b8c34c3c1d9ff2fe9458c04b900cc7f3940b63e41919a3927075b2195920bd222706d540a084dedeb49958d1cf3aaa35a546216ce4c8435aaf1ba13a51f0570ebf1ada3882ec555b349d42dcbfcea72ec4275862084b969c59223ffbcf3f10bbec65cdae3eb9fb5525f629ee2b84d41f0529803c343200dbbb2db3e128b69c7c7e076593393559637f225820cf34fcd77ad326e1d9a972f6eca718db0066132ccb2fbe2ee0795138783b3564f12ee2371f3dbe66e300db07d694bd63d9cf0beffcc97422e36b8eb959043034c24be899ebc63ffe9dd2c90eb738019f644694b0401f2e996a39328dc10a1c07a3d67de2c222453de2cb0e570487b1b16297d33fbe74ea155b4c8d676dd92ee46f14ae706dc6d100f94dbf9edf9e498f9011b776e56fe904a4fd9674317fc804bc9e053ba6effdcaf747e5d34b44a2391812d14ee90e2a0adfee794929f03d9b36486d76638bfea574c0cd5a672d33f8e75aed615f0ff299dcc05adc9fd662c516cc63276e682de8332990077dc26d6a8e851dd2d0a5c66e0aa4d5c5fbeb07f191af7723b325286423ed11429ea0a3fa443cbe8d42157855061eee08ebd9f4af9254240001bc775275bfe80d47adf5aa0ae4933c2f407833a5f71dc877b92d802c19d012a3783cbc179fbb8b7477fad780f6e385cc266ac4ddaff310d29f41288fa48b8fdc45e7120fb793a1aad3f1c957a314a5784dbdda9cdaaf66096916e79b0c8b9f809d06c34eccfb569971c42889c4947f2c4f83e38f58171be6a3a97c8fb8ac014ef2d79c260760640a3bd5d9bea5e6b763b3f36f1c3200ffa7ed76349a50adfeb94cc5f96656eae48c46e1abf670c33029ac250d961767f9918bbf4abcd0521a241e6f92b5f42ca378feafe8ea6af398e97b6e21336075423e66c5392a02203e430ef5963d85d12681c2b6a600c370bd50cbaa4d67c413c573379e4046e9a44675fa055f86095cf036380febc247f48530c23af0825ae2861977c237a5b8443cb6084e4d402f4412c1d7170f7364d9b6874c79f3cc211d56143b49a411a05e039c2b583c00bf1a2ef5b6c35eec84277b0d0d5067c4a664096c28f8c08a5b53971379730adf2bc2157974ab892e2608e03cead8b7344465a8a902a1c93a2ebc2cbc4dd26aacb83222603dfe0f9913ef8f303909020af278ebadea50239b19daf43fa2f44b405498c3a14842738ccfe4cb0cd04feaab72505efaea41132682e22b07c783e97e0fad781c4f6c10f47be003b0592a4a2f591aad5ca5eedabfd4acecdb20a20f53eb11d2f292c529fd4127e8b858e4c77ab211ac556b35d659f1c4f79e63b400e563eb8610b6c740d1c196b036b6619086227f9275ddde87fea1d4b6bb88472f994a95d9cc7830c6eede32fff124526494cbf22f2892f7d65f5463d55b95b14ff66bd1ba936db867f77dd4c85714a9e301b2539d847e0569e36c24753779dd596f0378a2968378df43a4ae5b19f5d384bad5a8aa9e618d4c4c9c264cea2df41b13e7593ec5d00dfeb779f206df445647a0a5e681ecea6b86345a1323ae0a93afe93cf9a5ceb0acd923ce301c645a07bdea7214f2f24e05544da70e7dc39a1e7e4acf0bc0f17de2f3a32dadde3f79ba9afe4d16092001e82742d7cf7ac706c23e5a2ca039c5e45684fca7530c3bf72ef9e2040c441f3fb97ee0db5d74307d01cedc9fe4afa8d6ebde46dad99b8490b2e9e90af75dfffa643946559d476ebe86070deefed57d0ec961d93697b2c8fcd89deeb1be58ae15db89a5e0ddf81391e416394a7a64a31f7cca2bdd7e8042ae088c8b8238b485d6ed4b1ca8adb60a05e224192f88472b8f9cd7a4f7f28a1b1ab12240718900b710f3965fa598bbf85f54dd69eb45888c57014f1637b755ea58193bf39950d467b663ae8b926304f32abf2e0de33d62f7f9a200dec4ccf7a1eb3a9cd09419d718ec20a90a6d6de930549d94029748c8b933c83c51a38eb9142b3b87e93eb549bbbdd0c1a79eed17ad9373f6a6f7c6e6ee10b166f0e24bae4a3ceb808c5254cb537d03ea8da7cb218563a57edd27cbf328a42c5a2d83907a2acef71a08a4676fc6c8fa32b2ab1c09fd1e47dd2c9405d5e200543b2e8337caf70d723d5a74baee73d68e32dfd6b2858fe0d2693fb6530136ed395bffef315031afd19d808061a61398dfbfc96e9f2482bb53b3e9a7f227ab9a06aedc62b8ef71685f9c2a8b46d973483921ccbc35def048d492c1125179ec94577680c8fdf5fd9629da4c659673a47b3b4087386de0fbfa9a07184e865dbdca146711df48cbc26f02c0f6dcd86802d8256ad4d8df0e0011aede705b912e3b26b9f43eba122735daf281b438aea0d9302082793d7bf58c9ce154f9d0c217b8cc28d1ca33951013a759adcb89b2ac0ff8d7b56b996d1cdff5aeac6177fef86c62f53bafc89ed568e066439cde51d38b8803b75aaa39354863f872fc8423849e835cf4a584651db8f522e36456e3370ccfe7d54d3e9dba9f5246bb6de4955092ab5b4eacb6e487b97931e9d84c9609a7a47149cb70fb067cb67de339a3ed4eb1a7cfc63924fd14f739d05491afddf52c218d0a49f5bd7c201e1e11ea4f44d58a9f06c6238753d4a15a9b182c0d544b76b6fdc2c6b1d0ebe57d4f971ab1185080abc304418503dc78dd40ef01017164b839044e2ab33c1e448b314fa9372dab6a1529d22614a95c7885e513a1042a259f0a430f21714369dd786a5c2ae2943cafa87e46334d4fb09460c617a060d44290736e5a4de90d4b2f5ac9d99f8e247a50fde061550830261c5eed44758878c3c1a759d3bfdb35653541399cb62bf37ea49c0538e76d68259d7ae9e67fa44ced377e3460a4aced8c744451a4e2cc1363283b876fe7a8a81c8fdb61e6af61a211537fd8e3fab69c0c6d2d405ef90a0e003df4044d1cc43d4fa570e44f3d4c55650da7b0d6d3d050395927daf3c7b3b6c33dc122876368200d7163c77227b18da7d0cbfb4bb3259e34f46cc83704b6a9eb74f31bddf22b311bf8fb254ec06f0b329c9c99cf9bcca57265788c0f7a621c4f56b243061d5a8dffa9aa134cc231618826d46addd28794c9a3fdf976f4653b6e13ec6083583ae0d8e691778badefec780b0284e558f2a86c2bd46f7640a25f879b9a9c9400286d521dcb8042082a4abe93275832e92f4a168e58b99e5e89a2ce71afbb5ceaa118f41e085fd6e5a066325aa312c99b2490d970f324b8c6450ce3eb1a1c2a3187bc26f894069afa9091aba8bd239f130ea5f905db8d1d73f2eaa8e8881938f0ee753578f1ebd1f6f7cf2565691586a3d71726b4f3435f0fd82d430503c5ddc6937599795d51521f3a7dc07a787015293e9fa173e4203b0eb6bfef0fee2343c60f0c70083bfc0d33edaca2d299ea40b30558378458433aee265afe4c4691ee2e4c92c646fd9052a278d09e9f6e9d3a4b109d2248cd69d76f663dc7a51ab09e91a6bbe8d5d5b3872d0ce9a92346e44654760eb7832fe59c9913adf368c656f77224cc259c4119e861bee244bd0940805747a78767691ebbf2d16f33a922e67cd9822f71bd2061fc588009d30f8acc091b78febb9df4e548280a47e9f59a345c94360e1b2b74a04bae09a046e1d53471ed4a09d2c9747525c35e8e098481abcdc1971a76036450a0bfb36a16e7289ae9273b83af64a5eefc962f5c528c0ab41b642599aaf4dff52fa74ad3a4807e711cc00dfb9af4032fa9878b717b4a14e2a23fba0880b3ce780ae09ace80019e6ee0fe162701e6f4b05db0a9b9f174c9fde07a9d2ffe205a69512699d83129a28e20611299db01404aff238ae1e1dcff0b5ea9cba751c423ee8d6a4d938db7aea9d95ab4d02da9644508263a1b5f00ec140fb02977400e6d00e938e252e0d2d61b7980afb0e9f1c45c662884453ab7a907858d09bcf516e3cd0910d1da81b3ee080cc678e9ed1332ebe912bdd81f4da6aa9132b5837a19ffc050cb7f19ceb183f387f956f8cba67998e0afd8c6d44b22c17d3dff4b29ffc0692579a208da83c0f1322cc16aab6d3f5fc2c5d7354294bf2fc14fb96f5cc153af1f1409553bca67f53da35bb8a7b530bffa5ed0d81e79b731560c8d74bb71aca46d0191960a029cb6e3151414d37be414b73702028cf31d742a573423b9f712db30772c132227225cf4b591baed2cfe50c6d0e61fee9dec34da30ab07a13e0fd0d86efe7e1d553c48afd6ddf60e7d7359576d7c4c7e3af7d21974b4d9599907560515c3b5ef964f7217bad0f974419d3dc5fdd765a1b4af3e79feb1cffbee3d2ec90b83455da11fe35b5d4decf8715fa31cea3fbc89227f8e1bbe93c23df6c23971263f7fe378edce0a9d12be18b550fcd08a4708a3cb03bd13fd74608f62e91f107ab2a44c63fcbe994b5eaff7691f7623b6f936dd8ca9eb4bced85300253c670796833cee4b3d3ceed387f2266ef6bedc416d36a364fe669a888df69f5bc378759d07b4d30133f8b0079755ceb2b94769d698e62ab0c0f867728509a28d29899f7bc5750b95222582ae8592a32c2032b5dc535d3b9ec38f5644940637838b1ee90779f59173b24e7fde5771dcf857e97053c7e91ff70e42243bd5173a9f3dcac9ab3c478c817a8b8a04c64034c2d4398dc2b0dbc0a613430f61f06181bb9a6efbbc9cd1417e89a0465c1bf3429df726193f4f452ae68a1d238e3d32f9718210c6ce8ae0a66926c26795dde6809f2ae3718f5cc7201e089a213ec35b9137a5fa77aa47cc3cd4c6618baf26bc6678f4f5e0163f9551a4a8c27cb852bc170723a3df781e7d9624fbf341386148d8a5bfd3c39b3f22b044c80ab3821c027cbda3cc23861438eac2c4e94814d28ac72bbba6ad1b921e09a570bf8677d9985e3216e8c09014412b45044b90d34f76228f2af53cdc9f0e32e51688779f0052144717b1b28f96f1fb2af3509008dd3aa431d2397a434e93ec30cb8bf64900cf012556ba8e17721b12ff66a8459d6c827b118e67be2c808a3d3f5905c7ee47ae9a63889c4ec3f202ef51205e76e6e3e27ef0b7aaf0983d3288e25a0cd06753b913047b9a88c1770504f68a6da8c52e993cbc177d6a35171c1116f8d62350c89cf1f5e95a75f0c272b1d5e340efb8fcf2bcfcd9c1d127cf72651940892ce2206cdd479ff8475fff51ebe95ffefefbe814e66caa2501baaf8107e8c8f7a1805fc9d0e2692201680735acfb8757df5d1a3db50472a1654675c5c94d5a55ba37a6be8541bad90fa7a6bc237c8fbb8c10f1ca98f5a024b27f1606cac4f6f59dcc9e671a0218553147737adfc1a8397d3ace906787a6647eae1a200056ac71a2a3ac4cb0d037d7a900a87eafed21b166625d5379593980b7f4714f61bdfa60be8979df4e1078c81c50c7370b8be990bbc7e09d2be65d0364f0f82f223146d6e68fd97012cf3f47196303c77f3f0981d4dbde90fb3cdedbe461301ab7dfb2702a4643f4390b7844edbc8aa4fce2938e4160fbaea7b9a81d0d93c0bb83b58882c33b6c2fe08b16284003ef2b21c44823e2557edde45945f95ddb58d13c5374f99afcef77057ed15114f9df413dc3c87663223ce60f409c7fba7d6fecef5849ee48ce413ebe166dad25fbc3e5074927214c9a043912f65ceef82e6c05c9dc22dcca23da57a72f2fd21a8ced754da10c6c3c99028181afd3f310ebfd8c426ec86241a46a1a5190b0b642ae3f2b26c882a0e7e92e5510e7da0febd5e0979ff2697fba1597f04edd9b7d0fda61c4842c847c4e5bf154e91a144a03f219eedd97b2642d7e57b7d64f64fd143b150e42538a641d5057b07e026451ca7c28b1611f1f25fa474470d593b4cb310c8c30d5182bd8c439db76155ec54857f2a5f42231f21c8e951ebc3f9113f90573c50154aff572b2e84d5faa9051890d188248b8f9739a5b4d72d2e6104940b5d2213dac8603f52caaec8989660701f0d37a943fa61d9098cc211aa0f10d46b9109afe8dfcedd30fd2f142eeb499ed7aced11e5bfe12262ef30f2cda9f62206dde7a9551c0f67f89130bd74ac62a500f7c639a08c85049882a040cf7238696afcf55a31e2cba762c04772ad04e09b05cd2c46a386336ccc5cc52b79700be94d5ddf32ce14999817ed0020be993919e8953b969c8c7e5eab1fd2d5b1938d6061622962acef296cdc42a35c50ab58e7d1f17f866d6bd906dd97b9a12e9dffbc6d1186fc35f82b4de6523f0f886518881759e4a0da753ee26ea8e838c5291fd9113e8ce44b18ba8ed3e3b2cee6c33b0ba85e539ea6eb4759f3857397deb470820f6c5ed2032dfaaec845b9bf7fbc4d61cd34b075c92ad30e9bbc3be7e375d525dc604c740564ba9e57251eb98098ed55fc42ef12b15249e46212d935283a13989f7e6530b52eb3fedf31c4487a5c4fa5beba820026f46b29e9542b77aa1b16b64570ae8374fa6647cd3378f17ac57e3dec19b95395bb947b67131bb619cde80a0066f39ebb60b78bb55ff10bf1f3d980402444913628d554d052e35d1a199a2890c1bd67201d2694ff43052529cf23ba30f03abd535677c0bc63202f7a6c2b1faf59fdb46982a66f19075f92ee3fa13bab67ecc6dc9669e7c2d2cc865f31c0847d04684fce3e4f7e885e3106702ce748906223eb04ef4d9aeda3e29441ed4656ab3cc29d83122e6112fa64249823bb4174eabe994c978c57ae73c6ffb1b6bad4a589c5c56d3b94f09c99bf8db305afdeec73c15f11da297b05e67425fc2957ce5542d4e98d87e968a42d0ba8fd62095b2d935e6f769075954f47e7c39133bc6fa164226e01419a4f02f7a3a490dd6885b723755177306c668fb5f84e27dabb7c21b3d51a04ee1f1ccf986b4af5fbd1b5e9accc803b56d32fa935d6305a9892f3ccc047027752a8b1629b00a8d4187f7dba11c1f240c540a56e9b17c3d48f0459e24fde00ef11958a7108c308d3a97b8046eed4453363531aebb059c54c4a902af7ba3ac878d131c56ca0592d37ba9d4e9267949eec63516eea9a6371247d98399895e4d2d82f0eb28a2795b35b0ef2a1b220afa5b847693fd2ec028eac979028448242e8ed237437f21218e5ce1505689c4fa754d6cdd33f2a083872fc42b4685060ad3199765d719820c4d6d99837bda0584006755680e59ff4496e6632f4afd2e0d4501a6969a6f02edb4be99011aaa29339fc6b530678958ab1b7d5e18d274dcaae3e8a387df004543d7b05b31628fda0e0b4c7a12863568006d615baa51160e202d181f38144ac16a9a2eeced220b418fc6ba3e75a919cf87af30c0adca90b0014d40a9ce2731972e0359e32678a78205f0f3344894fe96fc9d5e12717a0bf66ea28e0276dba082f11b8a30504ff5ff156d057ffe295c8339ec545239426ed0f451936990fa6ffebd04bf586b3f0f0e4813e6fbb07f54840a6e9a3d857f525ccfe83a3f3b8c5dc8ed231e80b8f0f239f5c14333973b131eddb37f0e8237b03a70a64d60b5ed1f1ef3fe6c4ab922de588e3954923b3919848aca9d44125894663317390b2fbf102c4ed4cbaf0007ee7d12a04eb8f9ffefd71f400db3c10a942e09f5d0c17f724f3d2e9d47862d90f81761b7d1bc42fec586e260ccb4ef07ab2461890decc8f5a410d7596a533f98bd8c566c7fbaae40ec418be4188877f09b13ed742e744ba2f757a252cc2eb83255c92e0c64464b145ed4ff411f7682c07727cb1cc61cf0fb5c7ec180c6ed885d8d603ce22706a495f08abffe761f6345a4145143ca15bd21f7d1d2201e25365a23bf63fad90dda8e34310af460e8bdaaf2e12a0632fb6ee480b1eaa022c0f770a878607ccf24e23ad3ae4bb45b4b89911415727104f5d55f8ed00e97d329499d96d1e5e343f3fd4ad368d2b8d718fe8c29da2c8ceefd8e7596b2692330fd60d1bd71b4d2849ff740951903baa574f5ec15080dbf24e1c1e726f5657bfe31189b7f6d727a60749af1f2510c067af584f06277d258418e1bcab4d0cf4eea81a964275b4c9ca838f45bb5fbbc87012d66f3e98c9ec656d282440c8bc0c2aea9f4de444596ffc4ec78d45bcbf1dc9dff1fe53ec2329e17d3931b006c8da8b8324407f3be8583dd5ad5ff3c27787b985c26201bca431f1035f6b85fe05d65790e5c41e5022f77732aaac57ee9c3bfecac6943e6c3db69d2ad93f18187ed9552c70cc6a48fb7fa57c7bc011739fc1f043e1b68c1eb6ff48573bd2d16664968ead1456004953f42d29d44e3574ec118aab3dc396bdaf7d3f2d8388cfd64dd40fd4d6ed6f35c6e4857cfe437205758c74730c978c2fa5127673665a39014997000534d514d7dd18af05bd3bd0b35d15e9b2c769feb3bf6f85d0e73603166f384a4b9e57f508d2b80c1635d103864fbc5a84b051c4aa3f2d9b7aeefe53fc0e9df983481f506467f0125e1f967aa0be0a043fed5bd7f33a0ba1d7e2ae64637a7ac2002f467b0f52cb60a99e363bacc73b688a53d07dcdbeb9d6b4f56c798c8e52a391a735888cab2608440c7c11bde557ee7ce152fd198f1d6a68a8f6d40d23549257719faae11a81e55bc776747744c881d7566149f385df48e46daaa78f86f70f47fb3ec93811d14efad7c39c4a8a68b6586db0e03ff450a0f6a371eada1b132d21ed602008dd80dd2afc86158b7b85611ccfa8425f77f0ad30da2e76d6aea8805e48cc1bfe6ed91bbeb8f3920a7a21b1a907e1ec488bf85091a0ffd5308b1d394668cba0ce1add203cec1db9ceff8e6d25eee2644a78350d1b8818240a48e02d88e0df1a9347b4d50481a4a70ba4bdfc917fa192e93ca5c83f443e608c877438ce71a6ac75edaa7e45109290e079df5a6e49857cf755bfd420eda6218cee6acd6c794472a091e3ba9286a09be259af52266f90e54c94d93b7c01d4a5bd395475e0984fc1cbc5237b88c5ae43e02220a6ae0d6ce64bb307fb1d80ca72ac8ff1130a9d0a40e698f071045304193f5d5247d55c1ea00cb1a950c72abbbef09aac2261c65e57be863d358ccf7360e1072a4e406a3772af4d6eab9d5d19e19ca3390c378affc4421845b6255ae48c0e58b97a8bdcdd060e985565cf5f512c0b3f68631de15cf061e822039b816263e3379e6862e21770546061cb32a4c420965171144c4b5a0e733f2edf04c9ba8d34151aff2815555dcf4ceaecc11609cc8c847d9b0bd4c0e33be6ebdbb9ffa1132b5c9fc77988635314323e1db342a209ad14aaf795b513277ae777491e86c791f6cf007097c226d7f8bf027cd53b50a9bb0abf2cee2b4bc21bbda4531188aeaa155739cc6267d7fc42e5c4bf59fe39a34a7139f5782b9ce35f741af6e064037df4ebbe00df162cf0b24e0abc66b37d7bf549b33d11865dd6fdb84726ef26f059950359f118969cf73485196f0b32aadfdb1945e7b51bd4d93a1d1efeef315ec39d21edcdadbe91839f60b382295e2c38c396387d759e22184c3ddfa31f22f703d611ca48daa6972a87d164d24b921d80df919de3b5b62482ceedceee380921dcffe150b1835863deea0cb637fce0f3da19976e89666f93dda96246697e21025468598be27c0289ab03991e1446a8430d9ce85d5f5c021bb053bcc40ec7d2d1014db83e262121bfde0a1e2c9c4be0f2300c401133277f5a1fe2bb34a16074105ae9ca68842b00b9789ae424a9142d7b633bb564b2a666e2f379e1ededfc7838baad8ed84f47b94b31ce6dceb8cb87d3b0a1ec1a74428e193db3c71bd65b6a212151f4cfcf476edca630044752e8d2e1f3b74d54b0c370a80866cd675065261a08f09c1233c47e90cf71206a22061ca9810a658130048fafed38488051db336d60446afa03a0250ab22f5e5b8c6bd42a3cf5dc7cd6d1df0b0b2e8025fc8daf7374c98828dcd216fbdb29380f5eff6bfbb54658b86995ec17b9ee1c68ba46ac585c8503471888398eb2f62fbc9765cdc15ec344cd1dd6195307813bb32a92425aed7ce93c2b555062d25f21ee798e2277e71204cddc04064272ddeb893c9b327bc28c0d09c389ab5041740102ed80588151b9101bd0f0bacd3a6385d5beb811ba2944512ce8c605a3b23c5fed9cddc516ad9829b3e81df057eafea57d8f9bf4fcde1d3160e4591f50985fca10b95769406049dfe06837b48dc54fc2c121db2532a68f969a4da6f752c23a288e566d080643f6ae0dfe448d1c299a83e9d8f7f0ebf60921df8c7628f850b41994e00ac6fff4b28d32564d1bb7d34244278f04a65eb424ef7edcf7d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
