<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06497a43baeb95436b8b86685812a6f27e033bc572316f5b358b0deb11072173439206bfa5ef58eb5a805689e35569164fe843eccda768aa077f3592a6dd3dc07ca4f6ea05b8a7a06fefd597b6aa4903fff0153e80c777f623d5bd7b8024ff55e5d1bad8b8c29b68aab008be62bd46ca39b1f88cff7360335cb1c59651cfbeb865887da991f46cd7eda22a0a33a6693a2dff6c9cbc4b08dd0d06162ae8f05f0c719c5842f0ed9644c4fd42a5d94c9d037c04f8f8811868136882367fa03ac815d4939a9663f6704159180711d01d884275d28f6fad24f0080c74a0a2fde8c4456c6108f370a49aa5223886008bd6bce250ebb111a46403ff234fd9cacda90088e7dcc4d0f2801d37cb6a829aba413b4a582765d734058e86bbda3bc5001a3be5a5e25b536d29682ac8311f1b2b6db0621c715833309e72c0af7b99dea878e2734306b12ca200cb5d013d077130f9afe436f2b608b7d90f2fbed904d01d270060607e95f9b7d6a21be945f591f77f095bde4a83ed6eff2daa84a3c968792fa8dce910331091f33d9889b11c280c419a0466165760e7a0f2a2854124a6405a0e08e0236ab733ba53706487ef5bcaf5d62503387af011585ca9580a8da0816ed3a74011f9c2f39786b94284b3c7d86403602208a9d15e1da0362ebd5102f6d4b6f3f3576d56abac39b219d2fe687ef238a1197057c5ad96bbebe93ee026d1470b3d036f71b8efb7a1720c676e63aadf9253a70fc6dc0167c11a64968b287c8472b6ed871f918706bdf84a79c02520ddaedf00fbbed24c92b64f9331db8694b32ef4a1352824ab7ae253655bae411f1fb078978ad2b3f1b3c4bae11943592eaeab8b082c826599a094d2dcf5688c7bd4d80ec20f5478475e058060a918f899c7279019d4041b2a7711cd9461a8e77639ad778ed1efbb2bd44c4bda8a7a179b0acc489d98fcd0001c0b30e6fcc9853b144bc0cccd8d5911b01e94865bbf3bf9248737ba0e7e8ded696e3340db23162828ab7931f64ce6311100f88a6b8ecf07f65cf5884c29895e844291fc6bf7b9b08645c28899ee4676aca760a3f27af8ae6ef959c9d5e9f1422a713eee0c94426c6b2475780f1eb2209e756fd9df0ba34abea328e5613de91adb889b773cb23fa82d69d7f89f05b60faffff866be0da8c6e504f2704550407718598e1cee83f96d50e3715b2ce6003c877885f4a38fd6377319d7d21ae6e6a643ca0072f3c71fd9337f469ba21de875732fe843beb1ed9eaa782ccd644b053b79e5034cef759f5de694a6c1974fe30dc510938ab18b8a3a105bf834c2f799bb53a69dace2fe8dda0be28da4b755699203d2cc4415c557dedff18892ad071cac015c3572c8f75a3bebebce9b3e4399ba9e55c249c614a3ec889687d6686ccd9907b55da1043bacff26fb7e7d01463e6d4076426249b993c83e7156e8b1b7d4de991c0d8566bb465b506771d2f855e2e9c885dcc469f4aaf2f79dc81526520591c9674e593eee183b818eade3a0f5d7b23a5b0460a40126e7c8e8c44ea9317655dceee6eb015460835f4482dbb1b7612a58734d197553c11df6d9ef340e6f1b94ff238119d11145a301082e78cfb039458a726af5674d479867ea75c45c6249cc2cd38c1780e870fcb4677a04dd99d1cde5b9557e7f0e9ea7c3faae0635ba45a2f8c63ff7c92b0f6745c413f6851059940f8a49a1e8cd44c5642e487d7c63e622fa97fa4516bd13f0459423a758dcd6df02e0fe83284f876e7d9b59bd27efe1ec177bb9327939ea6de35750bb07311786c613cff858fecb96fb89fb2020eaea36f56256a1452fd9f660d9ba298b7f35cf97e63d5cbcdaa684bbea8a6eeaf12797b1b125403a937005a7b8e0ebbe231ccbcc2b6ee29f01a4d3798eaed7b5e830278e3af17f5b3d1ba93559c8df6efc5a6630d9a5286688be24d1e71be1130b23e1891dd6831fa9ff5192653c9bcda684598ca255a0b512ffefdcbc12ce93d39ddb952e7c593d8e6dcddc65d164ca4749226d3780f17fb6c8207eb907bc59d65226dde12ffbf97c8e35e831c5aafe9f4560417ab4464e881cf9d7eff3bee7c75431385c69d4a5e4888ad017c919d90370c65a8f821b09c06117ce26a56ee7fd1eedba9dcf468225bfa53ce30cd99cae515da86a7cecbf4acc747a6551af3a66e19be74b9f613e23cbdcc8bac77181d6bb8a7d98da69615f191b290bd1e6b059241b4db471013250f7350d2025840cb2c763f1b2be3d06f3b19b6f831674ceb9e0a6d16378186bdfdf2785e009784a771af35686c972b9fc5f95d6941c378ad9a047a0e780828d2f518b7470369489809ee79f14939b0b70d6850325edf68ecebd70c92c38fccf305c92c4aa3da5055ae5d15c41c7e9c70d18b6d45f7ee240ce4d240d8153110d50f8c596afd5f8e3d7fc04966f3a7c455c3a2ead7bc3489c2bba6afcbc8c3e513d189f03f21fd167c408485eee8d4c0d0ee2bfa9e12b787d15d6fc5b077e22916fa8f38a1ebf240983aea06d910f851fabee161bf13db10341fe714a31c94931f88498d4b679f574edc41ac69e0f9280b8c7b910026aebdb7b45c6d804f2f576edb77bbfd703ad92babbe6f3b8cb2c5ffe971c7e3e58aa88b20fc032a02ec3286e53712555b25a196077beecc1e24b5c0d05958dccfabae60c96695c4c9e001748f05d84aa0abd6a1771b09d8148d5decc03fae672d9e7d8eb403f5ec3422a0a6e7a776b96fcb1eff27810cdd9e201bae92b8b7f1218e8f8db627549165512fc9405bba98bcf5b1bb56f5a396943bd98a3cca0c396640cf175fa7ae4254448b8453133cf2a7e71dc899a4deee55d91cbae66912ad0416e0c5d9c7f413ac2a954e2de39061e1ca336822295e7f3b87dc3541d162362d6606efb04ab50e624f850d5814bd0a183d347bb3f90ec0254420592f68d8ec904880673456c95e52936f15652947fafde2032be1bbd6cf2e24b57a5069fbad79c2be65241d692c0b9e70cacf3eeea5a4f726796cdef5aec916f68d40c5f88645bc0aaae3cdfb7d3080f9710238af9d59d7864bef7ea28226ac7fe704453d8f3ca51f22aa311d9e3dfb7534c2ed7ff81328524b7b8da74e275e46ef6b62c21c70afe0875cd7b69aae2a40a9c3840e49fabd1a5f6d38085437bc2b7582cbbbfc165151aa368de1e12a833422ac695a99e17c9a514610c241132870e95f95742e5cd5ebddebd9c2f2c8b327fc0630a67f90d58f0e4dfae806d80b70c12d055dc895acad70a32c5793004731144b6fcecb8f0e16c32f20aec3c2c6ad8a78be91281b68184a4d0a362b786900b48bf10d35a6a6c48f172787ca6f741771698ebd35d4de72c99f52226dec8027fcc848d2ca3551f68560af968cd0366c32eae99d32a6bdf51228b3f02a64460742af1f26a089a775b3c978111caec34b528fec18076a1f532fb80ab1dbc4bc9162a5da23e43ab921b2db679fa1cf55833819db90122168e7e5895d780c349792ec8a8a5deb299e1abd685c21f0ab159aa7168965a791c27e04f13ee2de3932a2c2cfd4580576bdde038f78a2e4deb42ec2cb6be8072baf152af3fea9b8ecb9608baff5d52f168e94271365ea64ec2e36913b6ca085b4de509ccbeaef3faa0565fc0c0b2a806ee0afc24d2c46bf8629f47b194cff761d70e78313f5ea2b561cdf21d9b8c842d1dc062508db218ad86da6803c9c902d079403235d7bfb86f5c17de53a83a04098847d201c3d2bb58fb72f4e1221c3a152ac4f9a06688882bfe8414c68b6b2d9adac308f1b783e7a4b0f02062e314756f0d1cea9ec491efef5b4d5e2f8492a28d7bbb4174bbaa653237ea777efbf9138e0a6c1c038bdd2f0072a9ff17c509c990a57956f23f0cfea3d0a6cfa377dc034a3f61cd674b1ac6cf38542b3df5a8bcccbf6c24d5c95a7196b2e9dc616c33de568b18ca9df2db331b48e630ba75c14df8b90d288c11da12c5b5184eec1dbb1cee37dfffd01c22f9d13b5e1c3e850bb48f7fe438e93b8dcef92f7cd583739714e69c66f78b8ce53c998beb226eddc02a41acb54c48b852acd59ff1d5fee888dbc368005b6fbcd9914460b022b7cf4b1562892d70a1440c4a5a08fffd301cb1e84973820dbfcc95a01d3bac612907982d40be5a75d96a8fa26bd804e2d6d1fe187cc8f7cd6eec49c1074cee5debc17a23b374290339423cfefdabd598167dab2a3dde2d908e5017306516eb1aea634d14965994f3a65598d928f16149151a903aa57c481f03816343958b99757a41f290d48df269175acdb7ddbce47841c31e96b80aa22ab391ee49e76034e860281debcf49c708df0a4b6c1ecb4725527c467edafeb9e45de04f9db343e92e3fdeb5445a788df1d7da8d7e2070a38b22ec6387d5b609f5a89deaa1f51b2c64f9734ac25a9a4b3531d1dc7f9da5544ecbd11fa29d70f26307fc1f8cf25a1a2bb84510cd9936a4efa1aeea1b43432cc708381f1e7bbeafd2632cdc123ec5d2783930b6811a1a0a05b2602e7a218beb144f904194a930b93c804da3d416cec5dbc117f2e8aa33a1b1626b5447c8142ad1564333029698a745985019178fa75729844d21cdd652e95689e2e1f7a29acac6d29b74ea8851cbf3b870f86e5974758cea8aa1a3a8913fac5548d6be6eabd5022d1e16b29ff579c1e9332284c37a520adbe672926546a219626e0999a5088ee5fd3b123d542597c687abcd182ceb28a55bd84e7ff780750bbdc207b1b2160ed4e557b8954a43c4f84de02ad4f405ece7403dacc1c9c1baad2d21597c24e8927a81de92d474eb89c299aae932cf42c06388c0ef3038448302b9a238004b2b3d3ee477fbb5f9e30e641e3c140549d91c4914825ae4f216c06b714bce18cbf76cffc78773a2ad71cd25436449d06e40a1bae1203d36da9909608f7597707ba8c08646bc22f8dfc80ed737bdf7851d985f9f3c145a2cee34e383d9bfd46ca4cecd54809785e9c1756a8ed38104e29e7125f2794579297abaa2dddb6a6b581ad86906cf335dd7b13131d43de5f7673698b4c5fabad4a88029568dd5c1d336d00c9f66f3f9b1116b896543d49482a298dab64063a6f38a053f0f4151e99c0c2792ccc0d052f5bcfeaa57b0aa69de147a0d6d9eb152c1b5c18054495ac614851caea0ad5c5d18ec330dee68f2d2b2e285c311fdda04b1c8417fc8e3d7ca33ba94271bda9b28adc88de4592e36ee0f9d73062bbdc15225727f669aa00d3aec1737b0b679be299c4e93afff11498d5e04a26263375987ab0fc6331e54bf497e19fa6d8968828d1d89051b10a9362dc513b194c09f2ff86f0e88e72d7ba182d4eb0eb370bf034f5a24ea3a2bc91316fd73bc1d9f0a03d560b0f295aa46df7a72f464280832cf60c12f2777f342647d7538c0adfb2f23f0d5b539e842c5c442d0f4f081c420d6e41bbbfbf718905e572e45b19933867fabfbe2b7bb2dff181ce0d1b2981799919c4f9d1e0eef52db0f3975737cbc052026d06008508443c692b846c8760011aea4ccd161c6bf7b140b27fd0a8db5539631e164c21a70544711a8a6de6368e01af75781c0d31d65923f0061c9d5f58687b5c67e94ec2fb56adcb94f253c862c55335fbcbf95610f576be94b01d7cb6bd9d69ecf30d703cdda981b49a8b87a18f5e141d42be50afd0ac687ff57433a3be29731aaf9c4ee333301fe3daae72ee67bdf623d695f23704fb53039fbaaf53ff993eb24a23d8f344eb6416fe503f36ba5718a73e3163f1c6faa8ce28993868d4fcb1b0ad0ada63cf00c4869d56143c7da12b6d851dfc3fa793c5386a804b4384da0f3c5fb99aa63ba37ee77034ca36abda6eb30d83e9fcf7fff31f7f11030de89d001a1dac1d3babe0dafa93f1f834ed0932f0832200899ac12db5c61f29bf5db8db2af16c4e82c2be75bd3c26f156829ebc687e3120af7dbf0a7bf74da554a4d9b20b5c4ba28b1a70441a08d798d6b2e807df198f44f51c694877404a35bad921ff37aedb04e6144d8394a26877ba77b0ac7a9a5b61dba17f52f8ab4a1b1578e66a5d3beb577ec2ed7b3ab86c296d8d64b619d298db02da7107018ae3be2e9f3547b5f448e5a865ccae85313950f29bf7b6327453405e0fad2faa8713ebdf63f7201cd3c60b3a591538db0a527623652d2634f3a6bf1450a54fcd858457a761acb7f2d3587a7a3fa7c6bd2756cdacba4872e53c03ab96d30dfa8f495e137bb11a3ef7e5c65ea5cddf66e70b12a6c598cda49195244495ff8e805fff2886afed54834ddc30cf2e41c9db2c66448c566e286105cebf416f2f88deba5bb56c891919cfb427f012e7c884fc03924576ee10a18d3a131a64220d02986344b390b5e70ee5cd33f02d762df0dba9cd2fca2e2121b5bf128a41b94f4431751d605504e35ea16b1933f4036c3ee0ecb99a443036d480970316d2dc41ff44822b8ce98ef6586351856dffea855a26c0e47941ef1719ed721de8658c7b48c1e8577f889631219aeacc537744c0d61246be6b4f7b989a29a6bc315ced7eff45ac00e0ae378c0211bcc93d8b43d33731d2a24c357ff01acf4ed516074d022878bfdbd1d11d491b16e85624c1ae867f0321c74ace08755e0b45c782c24aafb36dd5633b9f1085da20bdbfc513c19972b1430057f890f8962807f41d41c6f28f000fabd8d424f5764b2581f4d432b37015cca4b34e2cf3f6e49517ff642f5c031378e8df6f3503d2cca6b4d3c5ecfcd835a5fd818fbf6b6fd579ce6864d8b583ad4cacd874de0330743c5c82890a7029c9c6a015789d25ab38041407f704893dc75e06ae48264e27aa0d013741d7f13258e96ce92142dbbb5963980bcf5b403e3d9cb4c508b5353e7abbeef7e3cb51c65188b6b21347d9bffd6b048e14c04d21a397ddef0c5d7a82c3f4d904a1ced59035e02e7b2cfcab3c9799448637ecfede668e8469ac902811a01c7bfcfb0592b866cb03c90c2f1e19533fee500ec18671c984438eced134aec8018ed88f3a87e12c766d001ca3ac7eb398e6f1302ffd105f72670dfebab30c6cef1af1f507d19ae798b5234b7482ac92d8846e0ee0126d58cc54abfa699101ad9e36863594801dc6fc0ecc033528fd9a537f1396d421564a3c5ad55027c57fc8a4d38d02922fb992be6e14070b3f5dd44c8a8c31bf4efddb3fd08ba8c33466ed41c624ca6fea29ab0d53c0a4ea373b407b21c73e88e769b0e27166548f047ecb2d71f5cb75187fb5f8d3cfcfa97dd69a3ddd3ae8b25e3278596ff9fa72f46352935c3b69fa8b9d73905937f311c3f218449503ce51680992b8e399dbad935c801da243f428f4a3f09380fef3336292027eb5fa9db2b3112532450aa82822473c11f21ef24e46f3ca5e28d9df06d58b78d9c8ce4d1a095e24c50e7f2938a9d5f2f5e334604983430d22d6d47ac38408318b9e0622f3238704a4ec3f3971ca483d1126198e1454a5615340217d2ba289abe00971533b9f07e72c0e1a911dd1a728c1b58ce6449a29b21ea46f36c2f9f1553362cedc3ce1dae3dd9b8b77380e3aa5771f28a0e62fedf80a5bcf7ba8d3301c2bdd7582e4336b8aa9b8798a93f3ddf54294af9a0683648f75b480f12e8fbfb7a651e11eadece7fbc0ab2ad3dad4a5e978e40771ea507e06b3c5e9313775f32999d637c9ec089904265e2dfc0b2ea03f865302e514931d2c190d1ecb4b3f6ca235c2a038fbde11b8431ff164aa20ff9acfd7ac40101583b0c7e9885bf83a676d93bfaba03e45b350d74772eedb15017c6909d220611f6ad535fd6e150ad94fad0e079bdc769be98b444b12283bfaec6926e0b51d1ed51dcd88c6e4a84155ccac3efbc3b55ebcc529b698578c751f50cbf15016847fa84252135c646bd16d1873e409b3f6508cefc85b073785fc9403697d5cfe3c17c4045c58e1416ca8fc0a2a3fdb0ae106225a3a87e929733bebc242b77dd045e4ddcdfaa6ebee66683a90b4f51d384f5e377d8411812201e963de5073f2b519b1d9a270d2e526edc33f71b9a11d9a9a981956208dc22f3d9582cfe04c70f91589cb53798aa3a80743a994dcf8fef0edf0bb4d46f43566f4b63cd3157e3fcaf391d3fcaa05e2e06d6cef5469ea96fea1f86f90f436dfca3a35f972a9be126c2beeb512ebd1131b68affcd0e119c0f4db41e95a550c8da4dc37c52a3a77a747348e8e12c30b8e42f8028654c14db1c08809e5e471f138920488c9133206ca9b2074fe01b1f72982efbd64445c5d3422d384d4dcdd8778b55057e99d1ed1b82c68a669227a0c63f568bbcf3afce38916b0eaca6db6fe617cd5fded42188d198d72aa3bbcbb97e74b20daf7db83be383c654d22c3065f83f952029b308414ec25a6e1a01995879e8e42e1199395c4c76c3ea2ac7f5a0878be5b823c8a020e165d15c3e11ef598499ed8c1cc42876fdc35d4e48a9a848a1b9882e10673b7d26f0d51d0ad9a8ca1d816ff63ed063154a2ffde57a0cbc975f0a25eda105d5b80a340d3364cebfa1b828a4eee9fd1b8e639c7baada5c2502fab04aa5da25b271eb97f6bcfc1d3a1d5b56193b0594fd93c772d4672b6f890ba10500b737acbc944322c47f237b5a65b410b4450c79908ba9a3dcbf68af6855c576c551d9846ea395b999c62707aa7a95a59bad6d604d6228d4b862b079788b3d9260ee7bdcbdb316eaf677fbfa5341ce2d75e55f444bf1add3334ca68f94db275673b167b100f24506a39457c41c87d67cb4d8c9f2f8e6202805a8bb2e3427106bf33d66619c356c82b2e0c5e4ff925238d3f8d7587213706d06b2042ddf955da1bb46daa8359a2a797f9517d39ff4761754a09b58a1a75eceb32924878545a1e39fc9f1a3c4d89c4605b76d5ad3b873a4f8696e13bde908bc83acde06cc0cfb017d64bbeda55c5002b168b6ca94ecd477023c0aa1ba9335cafd15be40e8f0dbda6d7867303a7590e7da293eed5839b2944f585233064a1efe6725c9380bd6fcbf333349ee3a7b90463e57dc3d66325106bfc760e398c7a47a48a6cf26543e5e3cd674744307fc31b25a476dd79eba43586a50559d5c5a82d84650041e6edcb6a02a7a8408c29fcabdb0e6d9219c2a3c5992a0e97de819798eb9c8b241929d76394479fca8f7c8434d6be276287d0997092f37775d1d84d7aa21df09950c7c22e3b9ea0339097b5e0ee0891db573a03d4589f0fc7984ccf70ec982db295ceab9f04f4bb36c1cff853a2bd1419b339060a639f160e73c82b4c5fa6aded42945e9732cbde2a6eb3428e64cd8cd3629189fa30ee9d17f30bf12dd89fcdf2c6c2a6ce8b9f017b09b41d4d576adfb56949980cba7ae7bc1b5b6e077317c3b6e5c55b4fd5c6237a6b67c2ae811afa32bf0d2f196b18ced3c7bddc835b87e3b5f651db4417e481021ea874c7ad944d79561ae8d9aae07e6bcac50e47642af93ffbdb3ee9b01038d671cda1b29da54c4388ff0a7a84b8e68818579b485016decda36c96f9438fbdbddb15af74cd654c94cc58605bceec97537e881e8182c60b2864b0ed642620e41e5ccc3aad2f6a5f6b0a05813e4c99adf09145d648e57e44c7339a3f08f45e829bb7f4a73fcbf60f059b9a9c23ed307786ae1d472a317596c9d1eef36a9778174f4db777214624ac64162e1faa6f4507ca1fdae15ba20fd2d80520f00d3b1f34fde224efd5c3a24f64d16cb9088fba70a14cf96a8b7926544c0df84cd537091b0630bb2df63087db6d65497360cf315b356d226cb3796eaeb972ad50fdb10cda426a4bff79b32de6d3ab11bbe5fdcadf387d101bdd3eea0fd69f198d0cd10c989ff01de779dd503ed81658dddb889e5571f088e63dfd118d9207b5de7c392428c46f3a045ef2838fe707f8a312807215b0f4130fe0a4d5fcb11cff3097faba723f79f1e72912fb0299803a052c19c9b6bbd64fd28af0b570b7511889c4a211637e79c7eea40be89fdaeb5f0f42a9e10c364f96dc15ed0e4a32b7f59b4a64a45bf8ed8ab0e4e84644b819af31016dbf039eb62c0afb0571deb08656a2a60dbff5fb3504c2c30cdbae0776c908dd40adcb641e513059b0a1624c3f320aadaf3f086781c8f30aa8e3a935a2ad746995530a2cf11df0d24a0db0345b2c0815a1b13ac56e5ed73297dc30605d7088e024b81bb24fbe960efd2ae5530ccd324e19e2cd155ae152203f5f4920b5ff2fccd4026c485b8572c743318d2052224d8e18601640e8b69fb96c97a76df854fd9b33fefcba6bfc1bb335a02af9b75b00a3fe2d9afa1fea6fe00821a9e6f5ebe98522b6506c96ecbc5d7a244d730a9651046bd4b75f3c6611cf9352c577bc9264760cbf03167ce4e49c8d9c4e9d2587136b3efb5a20f7e9d54573bb9e3f0f86dcec5ddf3ce84586353f4b71589dfd96395931d8ffe6a03704c13d599b1057e1618e1328513428b01f5c7b7293365f5016b72c607183b7e197c3b025bd403eefb89829dc95ef63907e0e0e3351baa0ba5e739b825f517c8b606991fd627737f50a36062de21475a5b64b3c90394c1ab33109deaf1bfc0a78681e02cc7d5952657991fc7568349a447c2e844e9958e0f5025971c546cf877400676b866b233bdbb8af555157f4087e1b19fb210644fc3995939b3c5fe8e0790e5d990622a5bd35b223d1e37bdbdaf41ac697c1a6e7131ea6e3ec1f79dfe599949e193e9eb1cf81b5cd24138fdb4b6cbbaaa0a8de7d9bc3d2e4be6908ba5f2418a9e810217aaea64a8ef87ea9409b2d52f74cce5ff35bde678adce06ba5190da3b0be2ab3f5bf80adaf4c744507649546b4e34ee341c7ba202e1bb2f34312f161ea24171ebb44fdfb705d65977ad7eee00305bb45e55ecd46832d16d90f50b77f7f75b8a6ccdb8612257dfb3644c0296efc9b2cddd4f40e4a916610dffebf59f86ead556de8cf99799700a0a5bc15b0904f89e23fe3ef816bd561757f9598dd7def74df1cff3c59ee1438d16b8e9368d0e4a55fc65827bd1efb3f9c11a428a07540faa178fa7b505135085e75fd6a39d9d4b589a4031ba8a0c407f22649ca78af63ebab1117a5ab6e1d666e81520a0fd3e73c937481507b6c2f793f12ba73ca233103b45a1d39cfd61d14ba9b8bc02cc65809ac789dbc8a46e9cd2c2ba5c10507bfeab738f8a221fe788380ae66fb81f3d691737881cafa169973c25b2041108f830c214b31996d9576b00931f29cbfb16227a83273b2c81968356a01e94bdc8c7fd50cc0187f9217ef332bd0af4dfe536d18da9428e6a7a3b8b5012643cdb13df3a24bbdca8de0d7359dd0b4af5e7cd1a7711ab3e16ab42a92eeb8b31c0b983227d4e215b8d4ad1fef6c83ff6efa90cec594e6d9ac1a7403b9811d93d6d0fddda36b35b4b2bcd4fc5c972a4e237c77e50023057826680b986ef8d767a8fbeb879ff3ce703fd29cc6aad59b1d205c785c02adf113b7a87e0bf8b146734d8df6d62d128a63521d317e4c8d6bff61401931e0243c2b8802464edc713fbf4eec8108ed185f485e57d8f02ce08b8d52392a43a91a292b654845a223f9d5c72bc667cd34bf2460d7dffd453436a572ba1e9cd0060f3e5c45917d202598d32bf28553a8a981df3834b8bf439828ed83a72757e4323690d0e48638eaf41e914d6cab4d2079895d2ac0a94f157cf107fbc987e5af5db2973809f86af3df92298d817b78ff5e36f68fa6a2b6ac064de492b3437a1ef2bd7152b1473f401ffa274a6c0b426d03717aeac949400b69eec5abe4583254f8a37d40b7bf8aa8545f1f21a67283ec4cc8a8131cffb9e69b1996a4fa1530286248881c1097ff3351c3bad68858e0319d989d077b226ed589f33b4693b630887d40bd362d13b43299df97ff0c38e0bf872601f077f630cebaa2b60c8080cfae439bc88a5fb0c29ca468ceabc798407b2d130aa0bd9a086227681256fd3f8ad99dd0827fe41f61402075b2a1d3641256293be03c91099df4a377b5e44f4d0a55c1c7b548c092e8f76c376bf11f07f300ea823b3cb750624d50d4e8708081734f6d3e8734eee34f4d8ed5fe0864a0b9a8773e8ce28e2bbcd76c9e694edc88e2582437a3ba8b4bd8a25cd1d4e705f5ec6e6d2369fb952594014c4cb2c8ca7ec7697bc42f40d6f02a022a0a1eefebaebfa854cd8603df964a7e0ec99340017635aeb7ed74c810d95defd594a02aa4610577ab93123bb2e584354f22fc65992104e5c81c2685b8c29a723a6c580f79974a2201fbd70d4fc641e429d65294165e1c2d928aa501f189c5b4298e3cfe1d69fb140fc2336ce7ca055344875c6c30fb78eeeef1eb8335cdeab05013e5a78901ce124ad6e7015f53c313aa6858bc0c1b27f8110f457d448eaa20c318cafaf4465f60e6874643bfde439ba6c3ec295499165b91a3edd65404df550504e26cda1f567061ab36dd5da5822eef9bf125bbeb233edb1460d3601f3d0fa8c35df2d5fab8b5feefd3659b3e909b678b1955e3c5394848b5c1869b2b8e9c2c7cd3a60eb9e9ffb666aa04d7d54640281936dd2a40544008f08aaf1879694f5a9c6194077503dbff86ca15348339db8e86c3aea5acc93e95094f9bb6af69681fccf3378d5c9690f913d2be775d509c2b0953f24ac184e3ebb51199a19be2ec01947f5d803eb77544fb0bb62316b9ab035fda0e8c2f6d47c0a6d10623c2b0a5edf9f3c514ad2387845d63f8ee447a8ddd0af8669b98e71581e6b42fdaf80bb1c1bd32d31abeadb5764c84873f2f7ec252df930c7d2cfecaecd4157267923eda16bb91c806ee0889658ecf332bdf1588d90c8e8a0bd5c24f04089324bf9d74f6375837250124c51ee2319503caa9ceb24bf4630cd5cdc2c36944e56d7390aefb943c9fdf8f931945f504cd3e37c47746060edebb8166b30b970603ae231edf1a7f0389ba4a190b5e48f8d972072cafadf88349a0a069e5731fd57edffb6e799f95e18c81570ea4f3cf4ae24629b7a55881b78668ebd8de3a27319786579166bc4b515fa7c84a24f78065c2cbe848371cc9972592878467b003b248ba6d0fa3e61e395e7d083b524123fb8024e57708997c9db349f9b6de9055bd17a9f0e22798e863259663c441a3b1451e8d78c57d581ff1b607b8bede0d0638dfbf291ca44026ea72519c992a20a29bc20092ef28d6136a92baeb7ac19f4d064071e30edc333e45c07500f66c50f7325a57668cb2c073801db49d6f618335259378dda267ed39ddc865fb54e986aef831eda697282aac059fa5cd46977c5a9e71cfdee16e96a9cf18f8197d4e87c52aeb41da86be9f7dea2a560f07454ff6500cd0a4a334441ac68ed93e5c4571b43832a4b7011a6a39b6aeb60a51f87da0c29c35e931d9b433cde72529650ad2efad873825ecac23cfe95f37f39ca844b888720bc11747e3d83d85f30bb472a1898ae043ad99b3d6f2a2d4a8a46b091ca009a31089f9f6ef1fd03a720cdadf962dcd9be84486c97554be6c789f1f7b75949b79e24e8cc98e31c859bd255b7071be6f1169e3ce41194b1d161d4e1e5f2223588d648b63825a72b102a7d6a63862467500d61704e76f6766e892d28939909556bd0fb1b6e01c57b38e9ff0542c495f160ded746155b50bcb52f72bac0ccff223559519e0ad7b2b25a88c72dcf3c0b988266bcb8610e1dbc0be93ce5ea41aa8cdff85c3efb46067554601eff2c9fca47f88e174c4068acac85f16ea3f9022c937cdda694d48df176be47ebc54e4723b0e515bf96e84691eea1c2500d7e0f3d824e6a6085b729d5a9bf43c48519432b29f7bef363766dad46fb92e865c239b068527bb2ce7aa300a790af02b33777f76b8848273d004ebc71e1149f0ac219e3260d088d8ee6ab865c75fbefebc90e3363a74c2b463075bf22e8ca2ca896f7a145af99ed9e9ab3f54126255fc28de143b0129520e5c69dcce8055a7353a725ba83bb62d727f6449c67b035ee577c782bcfcc3c9a60147422134d55a64ef25f7b144c36deecf226bb034e51ecc9c11e28bd4e7eff473fcc0ded50617cb8d7457ed41e663411b7c981e8b3d167428aee64b97ece454b5c9610950fed551e401d27e0158a2f9105b66e791a8f502871d365c5caa00612bf0fe444da342e60fd86ba22727945521bdda73d80d430d162ead518c7fba6e3d1ce2e2e6c478825625c8b8d9a69902365b687c9860a38f48aae15c5527af4734e2330b45105e0a69d8a0277ab39a2c292780e1dc54c380881c7749a5daa7f5e659d7b4a5f3d52617cf4e1399b5beee673c116c049176e727bfe3e308504fa00992dc74608d804eea644312156203d94b5186de193108a2d21606046e82373effcfc1df53cc1ad35b44501786fac5f9848ea73f6d72af41963111c3f5f8d988b652fb6947c0ecb3a59cfbf317c63a86434b5395d70d95660fbc7dc176ba2ac1a550f0dc646c2df7c7a3b845cb3766754e274e15f68f9b944ac32f8ab312706019a180fa25cf176ca5789ed7eaae2039d1798b312d62a7016af6c60c6ecef627a292206ac5645dd394e9f0df3929219287957472c0888314117581a7bd29a877cd6f387e29d26a16a658c5f38a491b6eed7c0b83266277f9783c37786f7543bbf7fd1909646b0be4e027d6561717edaa9c39967a25a35206ec32e08fbc2fe5df1de0cd401d131ce091645a3557965d2b9cd6af2366ef789602775b0d1430da7afbf5f0875eb4cd535f09f8f5ced2bba2da3d22f82ace18eb0404a882af23372d942b13919831287bbdc54e2bd17c8957a121e10a69ae8b23c1c69e1616e261fd319a2324f1d00072d7282d9c82ace7068a9c81e8debcc08ae1392571d32c564279258e85f42f6322f30823db7214cccadf47935474d0cc35a1f282bb6da2ac4502712ca2ba118cb35b2bdd5d3d212006ba9fa50054c1a66d97910fa731481d8b8c50bfd11646e46cd2277b42a4cfbbabd54ca76045e4363ed80e7bdaeb4dbba64891a9726a26d0675d532f485ac3707bf0603989aa007b29f5309f496a72d7b800bf421b4e81749e01c21ef5bdbb6123a24136953fe2d473c98b82b3fa72b3bd07d81e86179428e228c46342cd040a447a90d781f2d88481b97dbdc7ba85295476f2d6cad410ed32e154ae8001fad4334778fda0f7bddd25ea007f20274","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
