<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c78a5e29009d2a0c853b1b89355f2d4aaf70a07114d6fce1b54e7c690506b125d1e1be35d47e302aee0e058b903fd792fc4431544598c038a6c4422c78eda8e2d94d880ce94e08f47e1b2a9079769ae61cbc9fc5d41a70af08c99ce91b6dd117bc048b907c0b4d73c10ccea9059da9eb01ca65b8a2abb1edce2c55d2e0fb620997ae82409cc638bc9c840c0d93acdcd48b2e7f8343690cc3fddbe395308a1ba57078d6760cc1d65405e5f6d514b15641541286a73e212156756b38e7a212c20f72a10be1dfd1eddda063e11d3dcf552613b036b897a748fb3f9b87a29630fbd9b6aba7bd2977931f31cf38b47c349e34a6c84ba45f7d63de589d606376e5d3c66d255738b85bcb5a7804209abab15448722a7064157f62baade60446726b6369103ba53ce7ce269aff0b5fd79346bdec55a0f8b9ae0d924ad54df69d3f3e746f395a80e0fa6b77f4d61d2c2a9c0749d66f9fb64411fe21e4d7676a703815eda21e233a65d6960030eeeb0302d5df91bddb7529131c7876f817efe60837b74bac39569c9f6bf74e7d4893216a0b63c4a374080037a67b22ba11157ec34783a6559956d634f9943dc474660d637694d2ef4d33a29b5614d7034f120bb57084656b299cc11e380987f719c346a76b66df750448fb31d1894ce167d1618a4913915af1cbb7bac4bb7e377e70786fe258db5ae6c21350a06ba27d72da8053132892616a0f2cd4e3fea560e86bd248cca315c484161ff647793ba022e1bda1377f6a864a49ad464fa79889286ead728fe27c92146c8c9bc8edf46d9318e370955e712e2a34b327f08925ff4b85e784ea3b31451105a41a5fda826f46d8a78dd7a53894196a4d51ced0554ad2851283eb5f96a55ffbaffeceb4a8846b50b7f59bd47de4be131008dc01e9f837a1fef6bb29bced291a0d4570c6516ae06aa67d357fab18764473dfab97f02c27207e5ebcf494a41d8c434c5e4c11ad463542516ac221d20d9248a71590626c36ed618710714053fb2b6cdf066feaffb7db6e27206e02fbfe1c7013340835e36bc4c0101df6e58845304736665ccd5ceb6a33d9e8b1dfde5b640e93790097386f6feb35c7c13dd037d1a50352a67a3eef82eef5965ccd4038b224ac3be3adc1dedb8034a0c693cfeb1a1562348c6f046930806914e9a09e5494e5f79ad6e7883689ccb1da3a1f367f7988a24472b04901e510b1bb2a076da24e96548a691229833356f7b7fc1d00359dd6ffec92522de80e5b6cfb84e39594fb6bd3ad326fad0b2523e33b6c50e8a012381689cbe59e4deebd74b385bd0fc886eec4f094de38509886a8bbf43d142defa4d6fc81e432b7fe3ca7b225c862a28d0d59039185ce5fa6a814159c83fa7aefe3ae44d7a74b316b521089babcba579b25dd2cc102b2013d22376b65a51615cf2bd86852102002301abf7adebd4f7443f66f77c2f55c373d8a5eff2536491d888cd5549bd7737d414e8732025b2f7d2fdc7b9e22c609a6fd32f72142bae075b9d19f6d674ba6a81e7f1b92777b944d327a7e6a3e0f0e14025996b31d642824d9f32c87c2ede0ded8ef2305bfcf2a559bd81d6acf0b49ef045a55210a5df1fb1ecc86e3bb93f8c5a74618be265569a433d3875bbaca11cd05daa2818262f1060aff6d1de5a0894ee1969cf618a80a208ca916c8496ee877938fdf6291929e9fc86f72d9155ecac198042ac6ab3921466b140864caa421b991f95c2fe637b14b9cabdb1896de8416c9e70c201fbeeb4726a3c84ec54f428c1f49543133902cb102a8ef1b0eaa1377fba9e16cff53d9bb3cd2dea9dafaa91d55147fd6010e1ac427573c79169acf0dbba6c0c55889f27042059be858b9d7fee8e5a234a8059225217236b53c21bbb5a8f13227ec1f606e6ea57531ba2fbcd5a0b22f7e6389842754bda1ff6bbdb930c066ae42aeda176d2e8711cc0cab7ad2e2c7a1e9b7a61e02443c0e8e3e436b82e58b003c5bb6bbb12ff5cf3cbb6ff35382c96fe5f943b48bbc687cea109b3df2e558ac4020201f262ba7d9e9ddce2cb5c03c58ae256b0725f3806b2d997b6af97c7105e91cbf5ee63ed566f59d3b72ae78b14716e8a98d9699505335c00764630e0203abd7c5e55dd5a664bfa74758883b2164fd8159616bcc5da8226698847b2b4dc59341092149aa7d6e888e3be191f1cc16459c76c03f1b9a71adf42947d50d9d01c7943c2f928a9d24403b963995d1856bed3b89e3409cdea397c16b0dfa0cf823ce1a37384ae9048084e331c5eda736807394fac4f21e384e1716c5740f3579de43af3afcf891b76940608e0cdf1eab6db726267974945efb0641e9cf48eaaef206700bb0c6ef10f2f8e1cea142fdb9c85f35edbbb36c9c8eb9304b15523cc5d7ebcda28437770ebe094ebce053aa1b3ca3ca819c8b302cbcaaee351a45889e1f20cfed10f8210ff3e692e1f93bf6810b96f80ae1b4e0a406cc17bebaffec16bc91180ba11f2744b511a9053f61f57024a8d451296baa56ec24387a9be4ff9f89d720cf9aaa822f1e2d8204dc2b36892a7e78d2776611a2eba665feab7d67d85678507e1a95274484c29c22ef430ecb2cae00a2be478c52570cd5629d03585f214e06a27f598279679934955418651c3d8356e667bd5c06e47d153bf91f42cc6345afd5ae15442a5ee866aa268378a69ec3699a2291e76b77c201832928efe23f66f4131f3ff131e800b733d3fbfdc7dd1632a586b1d02e066c21b411fd1e29ec5f8df818a65da822669cc79cce71a64348f0a05e3b005f515a2a24dbb39100a1f8933bbb00f6ff1dee7c4d4bc3f90cab821347ef4fd67054ee741606372cdab9ea3fe197f7b435103c90b6e885fc856ad18a5e4b9e599e67c8d6b3deda2a53d50abcff0d14ac8fae1b07cea209f8c2a7b20fed0376c605dc168cb3001111babdde7f1c051cfaefbaf615d1159c01bc069c75806bea59f4f20c110229c1dbe0736d97f33768f65c5e63007f60fb12620f7001d17b061ab2583a8c9f5ccab911ae7162e91a2b5ec46a39bc768aa427eec12d34d04ea225a7047045dba492465ad2c3caac80acfd2a987aada8324bb117bbcb204afd213a8e9c00387f19119e4f94de841d3b8610c8a57f25bb047e7e1c327aa1beb7cac67c84e881eed13f982b5db8794fa1825285bce60d581b75885636862f03d222c00ed324c5f5875219cde9594e22e2e68669d3cb8cb2dc7e330b65a098008b0d260bfb9e73da83819a5a0e3c90ff5fc92ec02f5f9c2a5fdd16cefbf5e732d7a5bd9c1cadfae90b863e2a10b4fcf1abe1477817fea48c21e3e8286ae54b420d0ceb3a236059fe32946958d42704de395e2e7f1c3a9b30f2d33415e5034ef023b14db001bf7b31a01dd7e4c9b06df24f2485449c54054fb731d95a88b5c8ababdd5e22bc7cae005ce222b349865c0e50fa8720c88bb98efd4289fb2fc3ba7b38720cf5c7389b5929eae984ea4bdff01147497bb17729dd76e3528b2a191ca39b5b4f480b6441defb17abe04b7eb47822d794ef38ec9a5d41bcb9cf65e50337251058b7f49708a89d6c9f3a79bfb63cedd065f2f7890b02cad07126b52c6a328d7e387c2fe9e9d4224ef9369404020b262154a88219023fb566da7087536c082901b9ccc97f46fda6179160bfa0ae71b511664fd975a8c581380a0238698f5778b1c7cfb177074806baa91f264a8c434482add6c843e2df0df9a5988fd8a0a031b31019bac44efde025e4bc2a95fdbb3a5ad2432f95ecde1f81e66f2941137d31451518f7391e20123a560d0f17da498eb2149c41c70461f9bbccffd6314db2d96358ef49f179929b1b91a91fcfc7daca81ed725456b5f4a08868b1c19531c6195f94898359c484a97cbf6ffd3d92cc5ca274648f3e4aab80b7bcad65aceb23ecce3b56345e7ceed25940350725295bfb606114741466fa79775e475becf67d4bf961b0f0d6040b6a2b1ea3c14e83692f2d3daa2a6e1687836fb34fb3851c7c24fc8d731d3913ff82ff604fc8f4d55ce9c4efa73b9d0f4eff0818a5071864200a92f35f7d11f723f51ff323f8c24428181bbced4dfbb4cc352d5fbb9fef270fb85dbc65352a7f8c021bf46ff81deb680e2485ef3db3bece1bad2cbc0b51488b1786a8c6270681251cbb45ca6f3b93d9f4ebaade7b8ef26c57c25431ba2d4c863d6ef7268696d18571e9f16c6d54b6d24b3150ea5d0b23ec110acd8963bd9094261f19f8d2703a59e4f9fb4a74131258df35a5e81ca91c1289f2b694f62540ec6cd05a60ba7df2afbbc451560101b97ab47d61ee4f9e23668a2d3d9e80fc6bc7ec397d71fe94319d3a6c8a1403ed17c4b43c0ac55f8bbb3fb82e702445d0ec908502d37e50127cea5803824eb5bc0ef959dfb90291a56a3d683a8401ff6d58bd9910a426e3d25a6eefec76bd389caa69c4001c1e88cddb60190ec89a80a93d83efb6103cc4d7c43d8467f18fbdcdc9039db9d654213cfa12f2fe32d60ac5e0219442d6a4363a2e98b636ee359411510fa805b5607505beb705760e9ee0f909b44e7ac774004b21740881b519ce4c9af6c7f04834bdc7f7d41fd736a0e2db239500a3d508bf0e902327be7614399b0a654c30d10d12622d994952e6e2807e108aeac38d5bfa60724845f9319242210b55cd9809dc8e70d90eb823c4d48594621f93af447879875da9aa57d172c379f9729e81a66876cc613ecde1f06391e685657008ec2cd640001eafb09411b792c8a7ad46024bc40a3471f3097ea7f27ef89627cf224a097d30bd547312afafb6477faff974e712f0cb53c472ac04657e40074224aa43eb0443891448e7d3b8fddbf798339a09ff66590f44e1e6bef1d9a05e18233821220a96ed06bff5b5ae6f2348f5bb73c24b0c0cfc5e47e83edf8cb6db595d70919a90f89e41887b7b83fc0c1585505101e9d79eb090a912cd90f2325f53eb323fdd1eec0b75da4ef2f13584f2320f9bc882770c7cd6e8cc6aec4041597590e94d8b8a69542764f12b9a86102580e666c8c45f0617d03373d8a0af6052dc540f24f9d6ee884c2d5fc9f70fe559f937ace772c5232120fd0795f8597b56a66b36ad410a55312f1d19048e5482b78b2de4e528856ab477b164b39a95696a7015c7410e0fa5778f165a76b3aa88ce3243b6e2413e68f94e9bc6ee0ba1b8a394ad3734d09131ee332739982fc8be71195f7b7fa36a9634fe9722ac369f0eefce8c622e2217d4bcd56d588a0e21a812e112702e8c41a606b6e4d55d776311cd0e7cdaa8c0c09902289dfd4413de5e3873b82409b43c5779da0ee1ed4a65a4ad1b3e92065007521a7c1cbef748fa240492321b96708a989790953a071cb4b8c578e4aa6f6c9409df326bafc255a836fc6a9a247a1460869faff14db2815d73ba9a5c4a93215fbbf5029419db1f3acc7ad25099b4f7bfd8a0c4850d14466a5f2e6ce0160e9d02eb47e8c186c58eb62058b1743f0e6f2c77cc0d7cf5c5912c6e87a59b685f9efea5585724f97bc4171f18ae3b5eb62160291f12677fd784a541913a6aa747cfb07e7d48270e6b2812082deddc837f2b84e1a5087c54038a189bc31ce02b46d35c2af0d9130e206efe7d4e9a167d3b17a1f574a0c2b5397e0e22d08e85e557378c9b89426610dae7989637a94e40dca248b70935cb81dd39ef72467f0137fca35daa9a4a006d361d1726d690595be2377f20ed207d08f32d7c41c76e44c397026990290fddd0de0c7be6406b12a5473e0c6a3f070076156ca13c447b4fec2ae78e1b57478bc0bfb39db418ef69521c9d0fa5c00b8160d1ccea6735c30404487196f4848ba7791edf9045bdc32266c89a823b588c8d73e294c75dd4b93d76f72b7f804c1b231ae086ec759049c384bc7e0ca78ceec268d2a3fdb12fde7dc8c40fa78729d2a5a8c02646e4b115ed61ec4c61b658f23efc5d24514eef9310998d8c9d26505d9be4cd8431e98261c095d9aa8dde902b26b7a2beae91dbabdcee14fe39ecdc2a75c7af75280d6b0938209310586091282f6727425f0ba329fc30a32b928ff53a1134b1d372dfa64b94a6a548915d989a8fe78eafd2e2a8f5a7458d958ce293fb8f749a60adc0d33a6cad64fa799a42a3e94c9acb0c6f4fcd1d288451dd0fdb4b500a374f968fe0935a82cb4bed9d35c0d4a15b171237b01e174eebe0b31413336f00d3a0ec0a3ad65376e406a590944f86dcdcab41ffdff204896453dd82cfc7c65ad34874d6ec3bc5c457d5a3ec2b640be075cf7715eb8bf62c8a27f9920f489535a73cbac65e952088f1f1cd14109f0cf9881fe3ae5cf71f87ec2750f708faf5ed887b5ce39ec258e8fde45048e102ec59f43bbdc6efcf624a9b3191027a4f64835f2d0b34b96a99009457a5b9116a48cf68863857a60d6349aa1539148e5eefe1473ce599adea4cd288756cabea9f5f6d537aa0ae7bcd57e11314be48b4e9fe92ad6ec91d283b39c607502d17175e751f6956eeeeea992c60a23daed020be443c845fd619fd3704a2e0f2f8653e163800aabd010411cb0662deb8cdda6c888a4fad4b93f613204f73b1069f59875a75bf60e320270bdc64d9811dece8516a6946a9adb4db4da3a76c849320b74edb220b656a196f8870c54bb36e0c6d2d8c0cf12c9282fd73955ac80cdea3edf9932c4adc49a2f5618f2809bee5705bb211365d664f022194a77e74e912bebb258e77fed1ab6d5dfc7cce9fd0150cee9c3c012f305cb503f86d2c5ddc7b69b305a2a9e275b6ba7aecd6213f8f03a1ed3bcc7c86d40a51266c1375aa025c4a6986fb5e291793359b082c1acd17df08ae20a9cfaaaa1b20e8e0e0f71f97403d633c7d434121704da9d801eb3ba3c137c77ea160fd014a9784b2a8e49a996bad298b91801d6a232f425c0462eebfeab3a84794a25461fcd9aced32224cc4843e6b1311faa0f35afbaae459415ea0e35b94c7f946632fe296578152080007849b1914fa770207f2b89b78f283280d5d66b0caef9123d3bf3b5b43c051aba5fd12aa0da00d528b3ea1d2cf62ce1acaddb15d1dc8a7f9feed583e2519c033bb1baf2f1803c08abb17dfb70e2a2532b6bfe1f037318451748ca26323558916efd6c51ef313781a651bf78ee3981cc72f04b53d1e49820c16acc198e7692f73fe23009d596f7742fdef91920a8810ec4972424593049171323623b36ebb48720a9e7bb29d74a9dc0d11de3fc033c05602c8579661d7bb16a2b85e357f3befbc836e4eb6933f7bba0dbe12d728ac583f1ebc77b467cdfd6c207077dcd00786df68d226938dd5b0f9ebddd7da36d02accdfb635627b8eec4bd013b2d1e2720ed94b74ef7f67a29e3e7f595dfed02906f43b19524f398bd87d661f26618727aba1e674b53aced9b4f99fc8c96fd193bdde81c2c6e38e2bf794ee887a6d0d0e72c3f83a307178499740e9ac083b82a6c939bc6ae8af027d3437d3e2111d1d8e005b91429312dd329ac3bfa9a66c26f0a6785db25466a0609410410f3f17cf6edc94093cf3ec5b9d7b4dbcda25d4606c704ff33540f72350eb027e4d0a7db36dff3f4a0e9847190d8d80f75e7d375c85c94757c485213e35f78b3ced19dcf288e428839cf0c017e04fe4de22454ba777de782c40b6473612f4f9457bead5be600b18428b3f80504fc11fac3621495a560e525b8f8fd7fbed2b53400f7f9f7f45112afd335ad007c5f22be5391b88e65ec88b6d951e1b6f729e67c683d4833aea8ddd0caa5337c6f54163152b58a97e3d59cff76f22d19bb8cbb34e3b1964a80fde5a3a2431c2bd66a0754a6fb258a2f60274ca5bbcf0e23e1d3679b08a35f1b1b390c52177403ae1fbcc3ef58bf9e0ce6ddce3e10421ea7c67de5ce9936c5d01ffe3e8510aadef6534cfce98ca258704d3d540482f5e9e1e94be2d9fe4b8a78365649bb13b5d31d4b106e82293dc83cb16f4a2bcdf2ab04a2d5feefea68d28d4ea7b3533336973f5bef56cbd71682e21a42190fbac089ea06d53aefe8e495842c51e8db2ac120446daed7cf447cfb651500aa3ede4abf0989fe49d8e50a4facc067d41745a1c3f22bcef965473991b793f80c5ac5ff2995071300523914b42b3eeb2b8197fa843f19dff2a903e79dad5d9418f48e9800a380d571d8ad2cf12392316cd91d4fdf390cedf7734f2b6ea0be889f19b67401e48b399cde570fc857db5989af8d4be76d88614a9e7e4f79908de9a2ff62b888873eb14eb5eb18facc028af2f21bc6d83ad2bf6c76993f06801b12652fd8b934af3ce8d0b00bfa24a06430b1aa71d773f0f4bad3ca015d9ae41ea770c5dc8ecd3623008aafed634519f86e0a859fbc56935942c534b3ccd29d5c4accf8adde5420bebdee17631d0b6de0d9f88001f49b3d02839885156fbe8f3254a600a886e90fc8323bfeec359444fbaee5ba8201267f10b8de7b60e265a3529d1c29a62b19a224df6011753566c4345e682bb28df1326b7585a14e4eb509a2504904c081372452e46d254c8258a02421ce62abc1afeb35cd5b71de49694c7db7bffb1c84a748f51cf2fb0bd3b84262ce067ce900477ca5f34ba02ffd176428c69acd67005e03993ac4b467b8cfb5edcbcc2fe7dab532565b1b934062d7afbae09c124d400176bbdcc24b8d3c921511cf4b40c18c2ab68ce7691cbab2b4eed2effe72fd73d679700330ddc89fe9f142ab28f3ae47dde6904081ca6a05f14c5930d1e099289a21e060b7376fdaef3e8233e1ad58deeb28dc9a82dca044678131b7c87e2e61dd0755db836f5cd6621a7e630856d6c1b85afa354b84ba554ed68376c3c436af3d402228c1a867da92970887481c715a26f8b617bbc9ed6b42a5c6d54f7f8e422dbda1a3b3b4f152752aed8c39390a0df72545c5c0bad75b94471a9423ceee5176e709fed718e845ade2e6fa957379366a12cb1d8052e420c24af44399ab3206bc508696dc54ba8d1416a67d63d65ee040e29bff04757396ec2353dc9948950fd52a53f447a86b36437b264393cea4eb0c3060b6d15e20d18b7560ff48c02f1ceb037483f92fbc0a98524608b05a8974c1c2000bb8df3548f5bb50b8c520008248b7eaff2afabbdd54587d754fab46b4e073e78c0b170a5dd817a8f13fbbe52b1a589308166ffb5d722e0e4507186e0018dcf5ec4a93897d364c71930ffc42dbd2428010272cb1f47f0563da7b522230a45d032877f6c3aa9cf661926c26d59f9254c78f24b260aba357b76314b596ba41663531c11d0f395bdfb739f1f3352df28b9d7068e19dd7d7c7af476cf6cb7005362ad4d96bd1ddb7995d2a76fa35e0baa323c951185df8271b7437107bcd7dce469f4c13b8fe793f8d36360470678ad79b4a1578d785ada208f65a60ad776d7dbfd9532d04d56a5979e1cb47eaa88c28aa5021ff3331ffd6f5af95a0d67ab9b27ef5b5e168b1fbf542ce519ae95e0439ef487eec67876036d1654336e28efa19cef4a615df6a4fa477b70f0def870aaca50ee974fd64cd948fd9f977942360d90a4676a07b814901646bd15bab28f7271fa33b6ed318af66e35a2259cea468c15ce9059be551e2e16fab96dc3627ce226d94a44252be6644e73da4189e95b4fcf7651c97edeb210f916f004e70f6139c2c29384c4c45147875300e301402e7716137fd184fa06bf85f6b2a3c607bb2945a3efac727fe5061e00395e7b5d823d2013dc03a5a696d8aed9c9f367d8689a2c6047ba357f4bba52606536bdbb1ea91dd774fc79b7065a211a776a7a7dffee81efaf46295d5682112d1d848e0b2f5b41e1e0338e5a8d349c17d9946669f30c842522f13ebf3c1af68b4f3ade512cd6e4dbc05584ecc6a3afa029fcd1ed9af9828f8542c343bb331af8050ac56d83fd940834e78aebf388b8daef1af4e4ba06ee47c88e213ee89ff96f428fa442dcf20f70c9356c2ec0cab9ce5ec9d3eefb198f6a9db4293e91f1fff2e955926ea51eb8ff60671ca5701298192032d755417b7dc060467390be6efdcb8b2cf25b711c3b761a5cdeb8fac7fd3a0428c4f3b8aeffd27fb4849dfb6e5d7ebb05a50cfc027c5eb9cb33abe88fb23ca4ceab7bc479ca717b3fcaded964eccf4176e69211f83fe7004f09016dd96b59e769fcfaaa54d7aecd5121aacc6050229e2f747f4365bcd03f2b8522269e9fa6a9dde67ff3b51db64a2825e6073ad2a42b335324e6ac4f90f5f757563b39d6c63e60ff2bd29e72235b471d5081a61e7235a1b4ade9d6689d4e2c3b634144cce951876f3bcfd76d37b636ddffb6c4aa5cb53dec4846e2e25367835d343fc67cf83d2717db5e3d76982c7ab43f46900409e441daa27dfd0aea5e7e74adc74a2a5ec89efc9601b0dc079564dd67815af6fc4f28390e22efeff1040c7b011d39ac9b9663fd134187f30887f09c5d1c7f269b39cf750f4b12696f58eb18bb94eec0b29cdcbc25986f4c62e580d20bf00c57571291094c0d4af3c41c8af5aaf9b06f64c21a54a5e543c109dc61811a13deff0a8a7965679bfccd19a1e4867230b677886db57015f6fc67022514521e15b103eb2761288e07448b5aa4859adf3c2fc76ff2e360b536c1731192f1b24c0a8cd3e73a63f0d5a21c981f8aedf1ee2fbc49a3da59466a6b053c2bde66be7a2ac4701ff321346ccba37cea1ba485980e5d39accbbf18769e9ab49f1a5f0aebf90f80e2a967806e0bf8a95c939c39f56f0c7ddade4e5abb58b60e61ed0eddc0447f7174745d331aea4b7581f6d70daf4ac0d9c864b283c0e695f2bc3db9b6d52f80a4d8f59a83d1e3df318175fb228cd26b8c7b3d17769f428df699fcc224b131033dc2d08a6d67f3300bb6d106e79556ea71526e496f71eeae966e81e5ddb76ad1af79692329ee76ebda6dd4d3ca8e3dd7bca4772ca03cc01a6b1e76b3b9b06ad2a1491f74479b67f2914a0f0b5571f4ff3b573b382fba1788bff4771e1ad93f00f058c2dc81d44a6a53a63ef36e30e4d3ca8c1fd3b9d7326da11233328010e57ad96b0733cfb4564f330597c0e89d7befacf5ba4bd74eb8fe657fced631670060218f420972976cd0c25c99d9c336258ea60271a9b9bda26118da27fb3722f7925b4b0041e914f3cdc4ecc2ba549e26323874020a7133e49b3a8f5c5b7b07b526e82a85a1aec891ae53d7d48dc854b198e2742476e33d2d4c8eb0180c3c613fe0e5cfb7c557e436b82aab63f34b9b9904df961a68e0a32c8b6ee04d7d450e52bcc81957f677107bfb611557722ca7c6c7f625a9a00b826ffa1dbd35d2577663818790ecfcaffb14c05b3ac2ab14a4c44c9b6f6093ba42aaa4e4cc80be1088923ec2dc4ef2f76beae91a6178c3ad7861ca30bcbb3d22e2be9af1ab75f29af8cb62a612338a1024b505f085bc71c6acecf80748d1101c22da7508027a82a380c4dd4964c51118030de3eacd31a735063c7df0fcfd8a5ab8d517591b58b3e24eb40ec569a556f9eaa1afc9942dcfd75d0c3408f67c73904842f75a319f1e56079e242558f82d37a0fe6fef071311dd428e628ff4487413007db9adcbbbae917861b55a3fb3841e8fc31dc2234ffd4c7c3b446b0e4b8718274fd21fd9817a043225eabb353a7ffa134f6d646bbffbcdbb4b4edb8ac064efcdfe6ce49a66165d65fe7daa17e264205ea7536d76819a0d9875e2af8ae3d142db11e1fbb294ca6a729c8af3d8af6ebebff0654858cc49d75d9267b21277a09c71e3fdde5803ca624661f04eb629b6bcbdc5d433d3a0480e75ddfe01191d91bccdb6e32184741e7c95c724ef41644e7fe0f94465a47360e63652b74e279e780d101e792ed119c539f6cc119c3e42a4e2a6245f5eeda699947f7ca78dc4899a467fe444b136c85dd798f3934b70dfdb8f551eed9bfc949fc90bc041d9cd9f59aeb2bcfa804d2aae55bdf943cba01e769bea1b3dbff1e1ebf98d976cf99fd4d9dfe23d33a03a4c7e5f36aea0c5b94a6cffe72fa12654087d4ab73fbf6d2c5d177b07f7e25860b6eb8ef323f140ab9464ea66511120a8787cbdbc9a87e7b8c1a1e7b0b0e9f3499f5e1ba1697b2bcde55d1dbc2f8efcdc414935d72ddbb543babca467de2281b2c02c97130007b462277e62a16bad6608487b6344386af1aa5db8d3a4e829950c7ec07b0c871adeb418ab838a0dee48bc5e932a8bee105e0353154e89df6a48340c1641dbd30897b27131bded74a0fc04d7d89ea62186716fecdc279ab2c25d51fe1d28644c0fd650ad9af180e35cdd7ffc59b3c85ee81a3267515202e10741d0fd4280d8c0c8568d58f616623c07bbeff56ca0b4af234559d5e92e22d362c961f1b0a59d911192ec839793df6faecb42362755945a4aff6058b5747ddce406d723c6ce899aee6e663d7dcab4106e113cd29592f5da227a713bee0039a6bebe61fe8e0f621058c9e9db96b1dd24b5655dea03c83f07c793a08e4274c0fd952580504acd2186a8c84d32f985cd353561b8e973d8cd28b52feec46661aa90c6db16348f75b142305e47ba2b86f7676c6725a8908803ce0149d931da7910191c14fed99fe2518b8068f494224cd095c52661b26860482c6c49313ef9e9eabf448ad58c87a49d249a446b80198b189b55ca21846fa884bb303db9a06459704d40c4acb7767d82990d0ad1924676d8307bd97c20f5b55255a1305fc9a716fcf6af4404bfbc4ecfa7b20315527770d7673585a6e12a15513972d515ebe5222537566695b47fd6c14610bccd37cfc81c01c68aca2ec1ac8864bf2f2074c2ba0b1777c9ecbb3c5d4b9c7cdf05d6d65d455e03a7e8a0a05fecd173f6ef300d3ea110b61cd2f5af6191ae838806fd332d9b75b6ae5b1ecbd25b3e5cac658c73b9a447c1319fff40103191fc31108a73c88d4339d8b861f374d0790c8da7a4afc466fe3e95b4b305874448f1820891ec3f5bd8e75352950b6f3642c2417b67a6efc7bb7095a776b884c41609260b90d72394e3ecb42a867fd01a13418e771e08f3edd6a346cf45d63bdb4655c8549c8aebd4ee26923849692067d633e7b1bdbaab7bcda6faffd5e22c802233119828491a531b493e01b4b2ac746d236bd78195f8d31a626c97ffafab674eab98cff6ffedcbace091f932986e508a29334ae62d41ac62150fbdf76584ced76ffa333f55f43370839b1d3bf9b52437b194fb28c3b6de0e032827782f19504dedcee8426351637a96504f511137ab029c430807271b64de58eaaf1b0fd06f528819990a212c1301215c369a08d78c838f60cbe8e5c4bb15ba73af758df364997e81e29df8e716b80be45f09729fc5361214a6533641d357f7b5f24c1b884854e4bc54c5079f2ee65c2dd716bf27fc8372714c4f9ee9a0c361acf5eb7c7ccde96ec062d8cc0ef04675c65b8a60eeccb56d9b7036c78c36e330a456f01e503eacdb9316866912eed6210e7d7a8f3301f0571231f8b4efc8efb97ab25a24ead61514d9e75609096d7f5df86d5770f8dea7b5fdd2fa3f1589fee28797311ae154b6f2dc00277b0f28e79d74af0d5313b1e6a3d48094928503f7e3c6a2918a998f985c442bcd532dcbea638ea32528c376bf8a5e126ad3186ab344a33d986f9ada4d9516cbced94b60b9e94002c8d2346206d4965522a841ea7c40d36c7b07e4bfa125425d66d09d5eaf4d552137f6676ab40c43697aec493f7f5f5da31f09aa4b10fd33d633622eb204fcc45a03737e786ffac136f79527f1bbf06b13fddd756ec1aca3a9a81b2558683835bac5c9e2d9628d272bc59c73843d2d00ececf4bb5290b649b4f5637bbd1a7116de894278539ead8fcb4bb85f843f03cc1334fed5d6ecdc9e3e53cc26c6c0fa2ea9a20d38aed9836a082bdce8a007c99393b9c1ae69c9551fce299a17e9ba1c9463f2f03ef6f76690005153d8f50cb3304183b1e802f2bbd36ebddecba4743ecc2d23bb137ceab4037b147ab50130989e0b799ca7150936299ab23b4db85db93db4d172631d112f4c8d3a6afc271547faae860bf4c8d707850ded41c8dbe3e4f8984320287284d0d4faf092c79ab1ba7f1bf149d4c878b30ebf2d44b0af3908306d4d7eb7774b71199ab5c6b2019ed778581ab8ad02e02c9d48c0327f2f623400a851bfb0a9f94671b43f0c6c25059a6d50ca54ee8b9186fcc717bff1f6517542ef442c538f61afe8eed1f23b822224a0e32c35669422201f92e1c20b4bc513b923b3a3fb19d048082047d81afd6511386a05c4192506e58514f28c72eafd2f01630be29ee2204302bc90809b259e3298be3c2bce797d86aed25583ba9f5eb5a758b8fa43180a617bb58b4ae39c0b2274f5ef891fbfe8c7a1a820c71c3148194216555beb72f0a96c762d1c46bd9c6f76e2f7bf36774ca1b88a65e00add82269aa7734ba766a547b640855c37fc75f2bab4d5de423569ab81d5785c956bcb6988747cfd4b0b8c67453ec321324260919a702dd35463da508a5e3384198cba2be459ceed12d08a90de37231cdfe0ef383b4c25a6a834e34a10f707890828327d639b7c6305baa10d847914fde9517a5017e55bfa85de9ee088ba8f325078a85122f0adf776655ac1cc444888f8ad6bf27f3d338626d850e46f70246a4e273925e5fc88d1d58bde6601a060df1e3b87f70309a166af86234095068cd8f7d5a8421fc3cfc2f262b8efa768db71b51fa67e6126f9347651782f73612b504949883d1ddd0cd222592125a58f391568d68e87114f961b12ea4d81fc5ec46aead82e5b3ef731d8397793b664e7860eacffd5c56bbee1afc98102cbf0957af88f5a6e96ff69ec6cb1e79bdd20e0786a8ba1904ef7dba9936af3ce8773dbfb59c420ca1dff6064043722ed666c6442fdacaceedec90869fa8b516fb0539d860ef5e8e438cb0cb11293e607224a38549a50beced1f7c320f9d311caf571679c297b2cc886cc2419d705ae87d85c3d9639b4c24ad2123469b2d906e87b8bea3facadc090d1a32f72b5a153e7a5be4ddf38a79de0f684c411e1400a04fb83cba4698d8d2a63602d3925a2f613ac16613da58af2b1e2858f9583214dd1d3e5c1b6aaf9cc361f061b0d8b0a1c321c9bea86510e834d4bfd425cd43fbfe5fc162211bd201a2b9ba325c1e7911fb7ba6cd3309d0a16c4893e19ba64037fef138df04826860bb831d887eff50698f779bb67f5fe7bd0b646d4096374f6292e6c7af24cff03e98de1862ca267e7ad58c571938d634c5b2ce3162adc153bf109c4b85fbb4ce1ba6be87ebd6d007574747bd6ab5329dcec5543d41fea839bc4dc46d8a050c61530691baaca8c725f53dafdd4d3ce8290666de0118e6cfbbd7c109bdfd59149985f30b079b477a73c4cc8a5e2e2dcd9898d1eb3b535e093310448ef38b9ba0254141e537b5ea6f4fc62aefda654ccd29c102fccd5655d2149cfb0d7dc7931d71b45e01262ac816f0957a42add1ec6ce881c34b270d08035c08dc797050204a652d26a43269b78a2f398e49160bdf51a3727f65fa9bba31003d0ee5f3fc155a486d72b98e8cb15ad6f363a1e79af7b9c8224296c63753a9a8d317476a41e7356f1bc1b7b96e7131d856ff117a243b3451a9f43c644b66aced03c864942b19df92d82f191dbc38584159a55b554c9d0ca99fa245872a7486555e0c4a21c6d7f6d2c7ee0949e2d29d66d1838fbbc1ad791475d7137e1e6b31c1a512e9f84f124d69d4f4478a74b15df93552b85ceb2545472b1cccfb6422e2a97e4a7a893c9376cfe8ff5b80b46432fe800c9cbe4633e6e656dd9ce76fa79e028f2016e6b5cc1fb98d401637524945257889a2334dea54f980cf28b14dbf692a22ba3d045ae3c5c3602240c12eca945aa1b813c09e31a2a052f81bcbd67dc462be099f9defd3cd86625d1dd7c8981a251822e11439656d167e2f715e313342b80fb241b72a088dbe611982f4275afb8f051c7f04448118c823773791e5b98f9a9d022ed9766462ea3e29ce9d2a58921c1bf1ebc4ad9c90c1574d588020e97c7f9c7bce2f1f5c227f5b4f19e9733e12429755539087124149c1f4d2534e52c7b4f044e034b04dadb40b6bad599d87f2de566b78ac65d32412120dd75f48f1982725744cb3d892a8133f07cf678fdd00a04298f93b6a206d84e6092f03a5c73935abb243bfd6c01c6fdbda613fe14779367097bdca7b72fa31e67edb2eef31028f55d1867e5fbe17ef8d440e0c4d3a2165458ad558ea3613f88e62883566390da2c5ee0ec3419035489a926ad1462b33ef4b565481448d48b69f12b220a502b4759ce60e91e8d964991a8acd157a0be465968dc89b0910f273347a4b91c563832aea8188bcd4c05506c1e6e130200fc24476de66f81c0123a1be27df0aec0fd7d319b743feb53ea708db529b0a14f9100eb92265d4a6b7fdbdfa6f0cbd11b9e77b721cfea864e48c557ac713fcad935c173e6575d068f7159f664d5cbdf54de857a257b85e4a049f4d758f0b5404835e699606e0473dcd3b2d84694df333f8a420fae1922c8ea520645feab269930e82b884503ebae4ecd2b34b26946360022c2deefbab5b953c2803653b731823c91b66099e8103f3989681fd15a18105e5da88b1871b1f248c9aa1c49dbca0173c571c77abb1c0016c7f1f19c01034339d4ff269f97bd701c0ec3ca0bc79b7630642f1745c17522d91dc3e9ad8e9b5fc859e71f144a4b39747a1fbcf1820108045514a205c9537c8757e1f5d0f28489eafb0f8b34bc893c7ff3c7619602b515e815402c62960895a5c98992f2f3ad9fbb10084a9bccf2841449f5402a86eeffbd791bcd33499be99c67c117b4a0553ff971b1ec477000f156e8889b6a647196cf5a63de2078a7bba1af981081f093c3c97d23968f4d91c1f9d0a2a6d37164bc6174b6456741675fee8340ebb5ce1ba513e800b17cbc6ea2d759c3a56bd5f52a9190c00c5b1bcca35b1263963ad49099979cb1ce6dfbb87e3eded6c521a227070e78aff0a364a8a1fb3b578e8069d2bb023891a86810a9bd659fd9804697cb53cf243c29fc8b338e2a0d3f51d0e391bf0392dd8638a6472620046b850e032e33a52693972f75bf86bb8b4a119c15c980a8ea478f6c2a63e98099bfcf0237795931d263d76f275b4f456a779925ddf30c260524e7645cdeb47a5cf96beb0cce0b4ebb0113ce923d8701f5d70cee246a6979d472206721698eb4e44b749c216c6da9553be7ad83ffd858c8f4b4e7e6d0931df5ad62645c885a70207d3066fc307fe19dcd5e3f3eb4791a8fb0c52b8e0788955cc1575a92e9593c49585b65ceeb469f6d6c04d6226b87fa31f61c0af2b8890cb1bba44d270a0a027d4caff26dcb4eb94549f83fb47a2fcdaf14953dea281c6cd8cfdd23e316ecc8ec5581bb0b3ad169c5d7f85f739183a60d5dd5934410dee2cd795138cf7915d85fb5db410f8e6e689b5bbbfb64564ceaf4ae4ed6406443cac7a9e47fdd57c84dc95546089244e1bccfdfe117ad6156c6de28c89c0c794e55f8c71c636b02c45a2d8aa670d9e436dcafdb068fc0be69037c6b230a490557f3db2de3f53b9572badd2028d0df8f19bff6011985c4947d4038fdc71fd79d8122271c61ee0e5e9b01b1286dc321d509c1897d4e83defb3863ac40b2a6d42e5cf95b44ae1985eb8d911c598defc5a8545ba6c60ec6468af0bd20077d64b7e3f6ad811e005c0d6938b41b707e4dfafe0c169960fff94a9949165746d6aca43bb4608102ce529fc31e976ca771e7c53ca22ecd6249f0a4fece6da596236621c1ac40c43a710bcf6abad4c3d7ecd96f47eebe17050cbfca0bc8d3a92ce9d3df267d40e4439d92e9c0bf0d76f3eaaf74923533239a7bbb2716b33615417c2f01559312b725a5b9e200c38a7f8d32e9bcc2385e940463b4c77187381e019f2d0436f7a9424c0bb7510fba364ba3a3a4df2acaae3361baa1433b539ed3186a0d6c80745b54561efa6dad06a113b1360099e0795775affa27f8d807ffc675b4597a3425c7b068bea940240b05e7a6cd8600f8aea77e9609bc3c44ada8e6a85e6dfc695a20be39617ebdbab981","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
