<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5950a52596a684bb4ba8054424eadfac430bc4b51c25c7f24eebf3d79efe6f747513a4ed07c1dc2c3b210c0d453d46cf878b2d9b5af99617e23db6153f4ab533b9a77d632904d8f948885d456c35c7f72c024c40565419c88e5e99a2de0d8798c9e1ae6065fbc8f7275f1ce58dab4829416267a14d8399cfedc12aeb7a5e4e81e64c2aaae0bae88842c4d940f525db613d7e38628ab313f681fabc1ab1eef5af326bd463f349478d9aa025a65e0943044bd494dff046e41b308a8bca116c7f655594e1cd0fa68c0dca7c2fd5ac1175c87b6a3773b88aa46fd12e548ad9eefb1a7c065cf394876cb594853398e0c27e3b21b5c7fe3f57000de4668d5f2cf74036b1ccc650734d0a54ac24664ee97c8a2df04a48abb68617267b978ec8599b402594ff067208e2dd2fada27dc29f1342ffa47305232b3d3d1996d2669fd5bea7fc10b433dbe8dbd65b326555dbecde24dc8013143a9f4d6f678a195a8631bcc0c0c3fbacf3cb0402d37a47c650edcf619c9442ccfd64989b651717728d2b633a371651f96d57097935edc6a27823f14a6921b0f3a44b08f58525a4dea4fd57521411815c90af9bb7a5b0326ba604f964022c66cfc8df9379a1e74899646c79ba0a3b9d326700e42eba6a46374d64c3cdf94f580da0e7f421334e3b7c38840f3ad63cbeeac56649cac301d152256849e1bc1cf8c5b9b56ac4ca72130c0de473da72f1638a200ab5bbd2a7f9ce427098c611f55cbb189c779b965f049e79bb2c081a76effd3be9f8d55218ccbdec14660c6e7e81e21f451a0ab37466ff29297bb7d27ceb2cdbc60897a06318417cbdecac11a482767cb67b893192e9a4165b280609d72bbf214768082dbe036c613292628600cd4e102802ef5ef61e68421e072d397b1a655a056642d83d14008bfbb6c5e97fd9bd04b441a28ff20ec61df36ecb4985c462b06968bde5a12443907811579044cdc589219123ecfa222edf71b9a5d3cc74422c8c1f671c005ece993160090855b960dae3379fbf15d6ba9b34710dbc9ad82de6b71e7c62c1f771d0ddfa273a4f4f64ee8f9490c7ce73e210c1e4197dffb6fece3b31224e08ef905534dc2d39b1897217d5ba43d2241101eb8fb090691ca896a171bcc3ec2b7879a4f4ba6bdde2cebf24ad41626fea45056d3e7d1d81dd9929ac585b479d1612de26f27d3d673363f6dc4a9b905a5326c0a8c51bfc5f95aa1756a4ff49c5c4530980c87e8b1fc7f720fd9f47f032226e899451254b506dd14523109289e4e6b38c46a21f0970719bf827077dd73dd02934c074075f4b2290966a32b4a0a1896c82e6cc809db2e5bf53e73e0191c3c3ec1f0a4fdb803cba516062e75181e5c5c8168c5105e610c7f1e5bd71259a8fd2596665c4a6dfa04fe0f6a02d0be05b506305516f157c2dc3becd0d76bcd9a3ca54efb8cdd573b343d7769d61e973f737917cf627b06eb7d644b7528c4d9621a292239fb3c43f1daedf118030a10a3d95523fb2fb0c68637dfc00a8b40e20a0ce4a946c0912e86c7e1be90f4e414a5188c07548c48cb15be95c2a8c54cf37a2ef57aaf21bb185ef7fcf2be9cd018581e5513d75ffb04874b0b97b1eb5125c1fd7957d8d7976fc7c6f939017e8693d0f70b4a7e2a02d0867e798a723da9eb530f30085b8b3848fea0edda469c98d0fdd690e258b5f725e1c7187bce65aa3b216a6b8aabdee73722981afd91a0abb71e7fc989f6c3e2c9b90ed3d11c7f91853ed551660c5416902cbac55d1811065cf8d93a17dff93898cfbab382ea1a4fe09f6a88e4f85c4f08156b4761f943fcf77bf699b6035166c78d86c86614e769f59470ebd3198d6b45b14ddc0de939151df4ba4241728abfcb9342b81eb2c9e7a29ff9e7e80095bd934d132a31227fee326605a589a27012cb5fa453b515cf50896bc74c1f402db503580fe6303ca7b8ca218e8292c9518f5e255e6e1d8ef26f27a0f22b5a0633ac1cb766ff5cfd5cf939e266f2b7205212cd4726c56a95f182bf4a87dce76dc77aa95580b3a27d3be608e9bb3672036b5f97c1693f3f6f69a197078d068410a031d0486e6d717193ab06a577b6b473352eefab65185eb4e3b2441479dea85a38b9d886e2670d7c2aff680225d9b2f4786b51be63acdff1227276fce14e5c900b21f5a5fd53704922fd6295db1e1e74433ff8cb2add34f37078b304b103e15042b90e2108c7e4a1dc9d3f551cf4ed5ae8b9c61a4f9d04aaa406896ac90e52ef150642e87bbdd86d15417ebe4f29c556655da7ac9fbfc295f7e23e7d3d69ff2763797731513072efd836fb5e57b965a8565c47987869cfdbbc0f28cdb8c14465becaceb7dee68db641c68c3aebe5e8b3c9d3ba66654f83e7cb4505af23f1f3b3add3907e44f7d366bbd1ee04810189bfa844761dc87b04ca3619f03dd59a9728776370934853af722b91d954d718c6a2e77e0e91f2b5c49bbb5eb8d76fbe44a34c25e65f583d475a4cb0bc7a0ffdc29d699d1df38e998d2da70ca0626427a3be4bdf4d1f6f07ecfe82778def0347aa6fe5695241cd56a485b1a4146e05e300a4c51f8e5a68ff686bf36ad0d9bba2a2c962aa304406b090c77766e55f89c0191696dab27648bed0bdb1933da2765ac54b5fb5b57bb587b40871dae9b1d7f619d5481e5fcaf9b6c9b2490ad20ce770960ee1161596b90512a46dd046b5731c4b147aacc19881aa6678374a701dbe3e95383a49049eb1e7cabb5ed3d3f1cc0197baa951a9cd604e1ec885dc20d2c1b56c859409061524c938506a8402c731b79852229dbfc513807f6afcdcb6d6dfb01b01f7a550eda97e82422bd80cf39b3a0b849241db0a043436792f1450c98d1b72ef07a7edf115445f884c6d455a723427f6631c431f702fcc53d2f33dc7215648e46959c6f3af9e2aca559bf3012eed2681362b34614712be4803c3f833226138cae62baf2eeed75b0e09c6f1ee198f7a5a482206e678c0f8fa7b2af7513b0fd14d982fd932e9ed74d306d14cf44f15fcd5314930e026c1752156880b285ac662376a6a580a2dccfb48064d920779e35e0c66a710fc6aefed868df38896ed50b47e17f43ec1d2215de4204730ad433fbfa57f95f8425e00bb4952afaf3d927a1d75189843df1d10472f419a9234628e81697e623d8e79f0cfed2c53adbb060d977aad86cadc938a8ff194878d82d0a557422dee6509c81dfca485da35cbe33a034a45e33ff7e08c9d528f0b49de18361548f40d99f28eb643f4080b74f623077637ac9c59835be220cccc902572f7fc2b7b76cd67837df54f321ae6b6e6c65c1d76754b3ea39456a2b8773f9349b71253f85e3c3cd8df9683fa5349505745d72c2cdd0c380cfa9e1d7dac1f94e2898de9f6d2e56afb28cdad4d3d8ef4d90b7e1ad53e1499a6ea729a62d063c7eb263ba11de0b4ee7de897bc12854f47b31495e886e48de2b85c1a7cf79c1485b1ddacc460051b6d38bd7ee7ab8b8cf2f6c84d5f50350ca23b947710f5b802ce99384277c407808fc7a707ce6ac5d7a3b7dfc3e5df3faacedeadd2d97e974f60b6c557c123422f5dfc1deff3a011e336fdd9e3d12556dcde12b93ef6b4039d891404cf7ed3f521fa9d18bae3e885b5a7ec46c9a33a82cd9e42262411c106c8a215350d783ae80407603f7b7272ee59ce50ba7fc91f77d592ebbebf16dcce6345be2a0b19e97db15bef3b0defbc9c47b7d4477d1c6220d1c7d3576aeb00e88fbc83436dc68ad48ea0a1b1498ec5c1813025283e074cdc3f6d982bb75af7e3dd5b809f39e5414a82a118ca82363ac931b9b1dc59845ba9aadc66c8141acce851c6561eb641c658d37586899b7684201565e3e4d5fe58a295beeba08216f3bd4a9ed9e7e9cdbce68a110bac23c91beb97f58af8b29dbabcf6012215d19728c5531dd4e8c6f254d7a92fff7d4fe1a89546dec23ee119013aa67d38f4aa72599221d2669b181b275c861135e2c5116309b3a63344b997689710415ac71b0bd9a994bb4965d7665df16e3b1d61cfb190ba080c51fa031f7b4a7b11924af73b7ae4c0f660a285d11eb66b64593bfb9db98bc4925522de213091fcf84cdd2d748e6e54b6d332e4ec783058f7924b189572feb61331b0bc680f08643dff9c96396ae7a58bf42e86d344d5b6f0b07ed46a01fe6772f3a9276d09f6379381e61d3d2be15ec0495a4244124964cfc971a10cccb2a6cc8bc7499788311c5da4ef3528159608582eb07b7c5775967805fb9569e68ea1c12313e09a3f02ecde608941ddd40cec47e985e9fbbb4192248bb4244934dc099425dcf66021765539f59abfc920ec07164c08e6ea299f729f87c0b70c690cb356e8ec3b3ed501cbafa26ef705febd7fe2aeebdc2708e24aeb627bb8719c26bf3649bb54f6fc73dd48a9642f5b5ba6247351aec42089d023b47157672fef4da5f16e060b7bbfbbe70af1eb223b20a8e0fa12baa23aff2bd7054e0a3354154b90900b48f0d2ef362a88e8b7cd93655d9e5db664afa3ea37ac95770a620d7ef512dee89f868362c2c81601e0846a34a7d49d83e7e9eb463332991deaa07e2b4b351e6069fe5a0aa5bdcbc8a9fccf586a29a81ea2306ff05e06b6161d0261986945d2ca3cdc79456140972dcd97bd068063bad7930d1f7d1fda8b6a9fac5f0bb4cef69050e54c6fc61b2c47ad7b09b56693c7aab6228c20d677fa3c55ea3702a6faf85c809ef4395e1f12f1806df621693dfb77e3fc3636e9b4789fd1d9c85b13979b287de6a72e235af9701eec76492c8044de9fb03ba41cabd680694eaa44934473f0cab4966eaffe81e324cc7e9a55e717d6f6f15bb9fb8297776bd368d03bb841f62bf648da203f8c45698041fdb28ab84b846808711cfdf86969bd88f7ef2df51ede2069cd686043996e358f8dd519a51b7ff215c94dac625a1aebb00c04bed2fe866134ea6377e090ebfc4771c181ac2083c8e097d99ab2e1d969ea5bd6b07b74d91b0bf19b7b0ce691936ab93046ba5d892b238eb9f54bafef8791bbb990afa07ea618596756bed3749808581858a3797be67ac563da4bf49a3d16e883ed8691de5bae5f78a4c04caeda0cf869d39d6c7d00285a6de9cdda0da6c266a7eb8ec08ed7e8905d4480fa8a047a27a9c5173b003ca4c4d4cb4ef6ed7f9eda548e9cb04d577e5513e7c63691ca6ba0c37c930a3d67c07a9f851567b596c49f29c8d1946419b8b9376309deac12894e0fb4d868540ed6f28da10f0c9199cbae8a0ab43e9e9046a58a7ad94d59b23cfaf65c30020d54ab9db7b8c6cce836649d18074598198b4e41151c1c464e8e97354bbdb93c0ac81c74b8a9def79cfa90d9711346af04dcff3612223dd35a93146da48c614881940589c07539d7ec2f91e89c6a04089a3f3fa5c1ec573dca4f5ff8fb04296a8809459086f21406c3e0bf56c08393bd82a12362a25c4666c1d73f1e54d9ffd3128c8ba1edf7f24339866d7c1f60b5479389896eca2db8dd3c26c932fda0128799ee572b8b3e4bf1d84f52e6fd9f2ce0293a3eeb9ad96e9790a1e2d3930f0346ff6083c1f342403da6eaafb369bec72e57133f09799e9d11bfcde039e6c772f234f43449df8b1123a7a507b4e16bfb04c324757f87446073d7b81a02c510d3a208087c15a1e1a4495da945e243a9681df8c55431125a2fbae701f97c45ba15eacfa844c35c82d7c206603f280e0e9ddc8cadbc640d37d2a5814790faafa24d80fab24e915d11d25602ba28fa87ead7e67da7e6c3d7519fb8b4de1a42f94b05a45931a89cbb46ee72652a74d1229067ac65e9156254b88d598b167dac41a1a8a77f246aa4d57d4bff1c69291f1f45c228c03408a945d4b8d686abb545e29980863abdf68b6a3679e9ced783d78a5179e26fe4a1fffcbb703c564b98df4a06f57fca0faa4b496a7c64f9f1b1480f86c17771d4737f36308b22700aaf3b6e8901c2e90c6f78a060270e8c779b19839f6b8a40077b3aff58919eea2dd769c89c77a7587538b581d3646c51c5079922c117d4caa77d7a0df936edfbe2aa3f3c62fd85b93824875441de4ebe0ee6aba7ef2478ad6993285128744294612462cd39d9b3083f76c0514a1ad8983671d49a8f313235fd01d6133b248e0da32227abb3dd070ae25674a14587121b9cb3f33e053f7248fd3fdd786373971fed1761a1062661e5ed36dff4ccdeb82f1d3ca43fd037d77d1c07326a8a2153b1c63ddbe9b14c65ecc3032d14871f76e1eb92a9cd9af4455b78e842a0e145e60658d18653f42f28eb73ce518b7847ec267dadf4a612380d12edca359a14b85a78c4250ef6838b48a94d990ebf040ac721fead54bb64b0fdf5b792fa6596338b5efe57d8899763139dbdc56444e336697565b1f6bdd982d7b948058d828299b64081504e341bed2d8664511a57fe085f9f912c65f6e9041ba3333950bfa515e49a17e3351fe31af422cb32203ec463d09dff9ed370d2f28dca8aadcba233a8a783c54c614f28abba47aa166410f43c3472f13f93ac42eca7b296fb33e175e8cc8f95a9eaf1c54db5fa275a5c083618ac6d076080283ccd452334435793471387bb4a36e2d9f6657570f99263dba7f4eb346f0d4e41a25115bfed543b107f3b711c0f8e04798299223dd69574d2a1065809073bf9c24033ccc65a5beb94b77fc1b17c21e7b759a97581a6b3e2a15cdedf4089bffc3393db482757bfff1b9c1646195553299c031ce23008710201c6bdb25a08810c576d45c98d694f59868336969d5263c6a616a5a9173a4d359696b08088520debf8e3110ee537e97c7496178a7cfd85f917ffc31e2ba8e1bb08874d8160a785f042b77823146ed12a12bf93a1a3cca89937e05c6f876311670d698659f6cf2e8facd1889a9f65f84aee888604cf39b19773bde3d5cdd3242763fc2f411be2d75dd1db5c6880de22244ba897cede5178affe65677e5becbd0f75eae0605337ff761b038aaf0f288cea7f892fe7d1aba70e7e788cdd3500532c7ee2cfbcf9bc43edde6f7b43fcd6449f53b8ea9e93bb183c4f8686e58cc1a0e1df058d19894a0bc62bc7f620995fc1190fa030bb7555e9d2cbe8d42d4ce6bf3245847306a6cdd49b48717f9ebc712ffe0779430ffa6c856631418d96f9d9b5d19e4dd231d1dcefd05aaec3a1d1960fe843d0b67498dce426fa508712f8805e1eb49c884a381ef1699173d0ec8884eb2115395074d45ddcd8d81388f4cb7306db09d76b594fedd2f436f419bbc080afd37ffad7c93bd6f26e9940e8275cb4072c832c81757276afdd8dc5d0078e14d92c10f4836b97b2fde3a0674e4b65c4e5039673cb330dcab4d2b843aa76d22ef791ef346ff27c405f14764da6567e522a29f35fa83f21fd2367879d0a5f8f5c72ecc4a41c7688bc679a546126cbc71140d942e94c660e805790161291e665c39d0971e7669e36973c4417e8c0c25863d6e1c7f52214f3b04761d2dbc920a6ba5a0c249f882aef73259fc3696c79e28347c8c08c9ad77fd8dde18998e0e723d886d210e20e6ce37bdfbe09ebfb3d0124daf6d405c310b451ef0d9688a5d6ba79916ef4399dd7b4214b6a4e5ce1e35f80ef4ea78af330ac5be3e459a571e6c0f5cbc7df5656779269f2a77b443089d63b423fa6e95be92ee8115cbff9c890336ef6582c60642ff44b1e918a87506700e52872688d9db600a7ac19be11bbc4a33615d38c9b33956cd7618e455f73183b35a901d0d504ab21180262a5be26026c2fb594ee6729081c5d9206e47d4792d61eb807732ffb573535f9c79433913ec13b6e2a64940655c3311a1aa61c8c0200a94dae7b53e972cca1f4ccad335db1b2d63886036920079f3d8b392c0c8455cdf2e6dcf6b2bd1a087ca11f46a80aa7699ce18761a4a19c32b3d1635a3f73e0e5212b1ada41f856e4f4cf94d35c01b9d03d5200820e1732feba12da860c3a07e187baa4c3894bb2fdffcb8f20753a408e5848143fbb13d7b5cb110809e2b672eb5d41ac4f6d167317758a3c0f46b56a05a3ad1f87185b08803bd38f57c0fff9e1624686a180ce69786f8f8cda70ce98c8d7fa64aa98ec339f66ec05329601fd794e87e9598abb9b614eb78e7b5eb9e353ed6bc9b4c4a92cb30ae2ec1e564b755ac71732b8796325fd2cd13d2f09e2e938cef9f8b94549a3be37cd2278bc889f68c7270b592c6775636a65952c01585ed1199af399a06cfe2f63415c9aff67278b9278331734be5f6e38405a508bbc01dc3dde8d996dee6703fdcd68e9e58b2709d5cb279e7ea16a38a10dc2d9aeae1f4a01165f2ba6f248033b17d614c535402af004a49a05410397fd05568fc48483833c88408c65d082520590ad26dd5c5eaacd3c820088255b7149e8c920c4621845e38620d2fcff2b01682841ab4db4b69926d7a8b7ab6947e50cc64b44e1a08c3b685d6238ca9da6f0a3920a3116d3613e12ae0ab83100c5e88e3eecd555331282814ebba3a874ab77d1dc8b653bcede5d52b45798fb836654b517f61eb808620e0c43223199d2fc44d15a2b0294cb61bb23b0b4487e9afb5ea174a2cfe7e4cb5ef1277323914ebd5db2c8a00f3bb80929dd6c3bc3bd6b8ea9d0e150c0e6d292deb5d27c34695afbe321dea6f72685170b924d13f19e8371345790d3136457a382ebfdb17ee90ce267636e09bfaf9ce929c5c61cf7abccdc44ea98e32156a9270bcd38bc4f181bd9cd7e80f7269d43ca1ba6bf1231c71f3d706d557ab74210d5d34286cb9a350a2650fc74d0f56a0b8fdacbef80369b93e533a5fd0ab81c7aa33d4e495bf49a1acf5a1e3df2f3e17d4b9aedf0213ca972225f1edb32c371728fe1b3a155035bccb81171f92a32ca06a9c0732c74b63f973b811f87ae5b52ba132273515b436aac6d8eca0a2b8d3df5b1f4a7fc37637746c7e22c288f44d5fee365375811156ca5efa9e201cb77771d612754b7fd4a76e6cb1b2d1af63709af0ca95bd8be85dd7512a57684ae6c38a4c33f1c83c7443b1df0506ee68716dec7b6c960f4ccd074ef8b189d7fe7062d3a0a8d27c381b3d95b76befdb3dfed1636420f426a2434e6687e1593fdc9c1cd6ef3ccc77680c06c87b871dd57d8edd797f93390580a093ce75be25fa6099a6d4c612c014a15ea690763fe78e766231dfc0be6e2b25626208e2366b78b1c6bbee337234a1a050dce094a415af1d0e50c5e95a8f697e8d3af76aa5f53688dfbf5235e92b42e1e7ecc14d7d0d0a1165e4fdf4b28240162702667732ac04995246e57dee1981c3c7c56a09f781826df4ed2d8a65041d7ec8035c713b6fb9297b6a64326aed0820ba18bb02c8d1e4e1b8bbeab7783ae13d4e2b9686cf7eb0b418ccfe0cdfec72e644c6c2d6c1b5456ab15acb35de8c25daf5656510553e1fd61f55ae48b8627b3111712f6ac349b470fab6cee78bccc2c6e8e95115d6c294e97061d971a5659d2c9428e0c24143a7ef9b82f83c86adfcb0c80b32666494dfcbbf67f8077bbe00a6f16a8443f50147f5e158203c3e2145aa6ade79330f1d6baf714060875b4a8adc33723d89c7f92916a00b73862e14c7047c3f75d6a3d129f08b426e4b40fbe9fc08e8dc083c50615cb1ba609aaff97a937279a123835612f0354d4b28519a673960a7815c45e6865670fe435360cf80c45431c0d478eb06bb061d547986c890f03fbbf10df4470ba9194cad52adca2534461ea1c34d771ac6d8967bb7e9a80c2053dbceb7081122cf7275bb93e1b8eccd150190cd3310f09e672153e6bb0800204accc99e8ed09116c92fdfc87c75e82371931c846b2ab50ac71f1a28410ef4ab279d6185b37cfc549095b5615d3d1544c33e4e030626bf26b57c3a7cc1bcc8f9679819320721bcbee6abd3762396a5e9d115ec0cc4c4a04ddf91dd2e8cc541b80d95f16d23f178184d37bd3a62578882e1edd77d31314608a44577fe9112b4f9a3eeaeefa07ca5a7d6c024a4c8651ed5930a0ba8b191adc5d6d30b949d0398c8afc17a97a198b38c7d0b221bc5aaad1ae6caa87774572a95082a134cdbe2fa5b11806dbd408dfce869c1f64c9362a35b6f299eb9f001a9009d10749a067212542ded7b75d1addf64af8e39c4182d6174a075644eaa5b8f66484af476a7cc182d2403419014b1d6457384c599700c6c275aa7b3f6ab24ada2e507aaf6bcd178ec2e5a984317f3d7becc0960fb1d564eda665a377c1a598ee228b33efbb8a3a88ee9cec4ba0e4500cb07181e0d166bf83955c1b609d7cca43ebb3055afb86e59bb6f10f0ad1c1bea378828715baf9a057cdba193516a0613ae7bd5c5ac97f7004cc029548c261e797d357c2a632f0aa4de8f427c9471b448047d76d4f4b35391787f238c1227643e1c639df8048a23f42ead4832901089cb37dd2821bc15ceda89d13c35aa54c6dbf5885b2de404b8205290067c404fceeb1a576830628dfe1cb8eacedcd253c0826b6e7aa2759735252e3dfd76ac9e3361e2ee9fd677edf704a66c1349ebeaf8a3e709682c9402791fa6a25a357a9d38d2b390389156f67449d4fb2c77a76faf9472188eb812c2f3f5bf8d062fe97ad21be4e91b005f9f0d7b0bdd7d96f6bdc113e7e1ddd75565f6e06f148ecb6c04dde7a85f055cd38feb9365cdd80228061c3489d928028312b74b3c4b11e7e2b43fe33696b8e63cb8f475e1ddf56b86667599adf0c26f5b60e90169f9bf4c62841580e00f460fbe40b415c21b399cd2267e0b3af4192c6c70f11791be1beafbbcb14ff4640736662bc69ae550796fba0a2c0bdd6b322019b3d87fc415c1bda8e9368178db8919a5b65fe154307acc7f35a8285823f208d6acbe95d75e3b49c0a7c8d1de64efe5e10eca7d5bce5db09a7bfe1839e0f0c9419d26afd3c383fa3bb9744c445b1feaf679263a3feacf464ca8ae3dd289e537bda19f71e2f9fb2a6dd7b0cca6f2e86df696167b1656e9c7773ef035a632f35131f7c41a06d2a5d8221c06786d4418fba791994e45556d685f28f2ce7d4a57ce5d59c8b6b0ae5dd0d8ba7634b008a006f1bcee9ba35cb022c7a633b4c7eeac7b658846eedf4be747f4e68ee24f59ab1b8efc014a11cb2ee7ad19551bc909dc83fe6a23a1b717e2745d0b772e6740424c09d6207f7fd680650e5971df1e0b4a26e3397905bd34f5ea1ddbf9ac5614811e866a118b587ab610f713e2efd672d849dfc79c575b064050008b49d7e61155043fdcd1366565eb92788f8831f495096b0e6f0809eed427e833a2687e1e0b9176d281c8e20fb69fd1f28385947f2cc86f3a320dd6748bfaf5cdb363af2db6a174815c95efeef82d96b2a28e3c6e621cc2373bc20bfe0ad5374d3db2bab65b70c6416481c0a66447128a29e2a1456ce3e7bdbe1aa6b25c24a9ead12c97a18c1705e420e720366e3ead1cb72e9928bac41981b72934a91c2565d435b3fe857786082dd886217cf078fddc72080e1f023a3ab416e56627fa91da01fbf95eaa1c16be5b28b4f5cea714c5ba8942c46c542640c88c2469e721af72d7a3358e5f13da2009299222f75b337593fbd78010973526a01f8f9e8506932ce141d18fabbb4479e214b2fe3dfb5c9955ff63e145bc3b767b9274f8204024ea8b546f2db3f3793551b4c18a5f71fed469320c8f506a385b636c5a1ba522218c52b6981907718a0a898df453160d91c4851ec531099da5d554a76e001ab2fbead95c322146d55f3a8849a3f1163da9eb1025f4a6762151ac4cb048f131beed30e1bbe0cf518f2c7b78e3f732db9d959aa199766b14fee08c9bd2d65f4ad038e3b4a34f247730b9122d2cee295ef809f3f9429db9d044c3faf696eb8839b24a68fe9f264db645904c258e3abb1607edb71f356382b8ef431780af10a1983485a624be23a41dc932a86c5564e8b2ac85ccc900c14675c7abe70f7926ff47dd31fdf5909531aecc62700a1de2f4a47bca8fc162a21760c084adfae3317c93f12b674ba397facf186b7ba40d4ec3cfc7dc0acc859f665b2ec522f62183ee1a6b8eecac6bd05cce597c89a9d314ca4d336e0914be61a3ad305485cf1b2be9bd796c39621e08ac5fc109d322bd6f32fbec352a69b82b503a36621a05dc3d7c36b51f3d6e452521ac7d1cebd17cb9e7da9260fa39b2c2846fd357233a8d120c47d6c83c942ec053ae04d815fd9550a140acc702833554d54a944a56f877c287d182b460f60bbca10ff8e316d0c96d354e01cf67e0bc31c39e6b84e71b6bddaa1609e079babe91fffe0b5ec0065c6ca2738c93d85ef57b08d1ab01ec9f6fb33c3751abaf7508a1f83fabb4826e0c673b8de3f99b4048fd996af6940201c990c481c0f54514ebba977d1a741f507b4ed3daa025b90807f743839d55cf118819b779bbedcca285dc7c91a949c6085a8d18c779799f2ba2ddd80c608eafe9cc8ac0c4ca71b702ce77342245027c4f696d92948284d0cb8b9ab7334bdac07f9528bed7623ad46643a2d73444bb853f832b337163ef590f08472b8b08508c7302fd7080d3cdf73aa5e3a1dd9912bf2c0427add6db5214a941c4071b0b9bd69587d4113fa44647969d38e40b8fff3a7d004800fd8a0248777f046eb8923c17769d078b1dc16f2e4eb11ef9d14d559aa538c95dac7841b18044262c357ace38c1cd7af1517db50feeb5032567f5c65dcfe075d1b40451e7b757c223ffd89fcc5f0f829e909f701f59ce4c908d2c24d5759864e968de93039716a7c447854024dacc4f5c02753e5c8a2d463fcd492476e93da444988407e5a2d84c77495ac997db7081eb91a6bbdc91ee23f23f91d2cbef7942f08af16349dacc66d8bc24da41ef4fbdf7f6ed59267ffda68bc0dfb82905bd81946a969657d79da710c89bcb13af931098d115d065fff928e60e851c9629ad294ecb4720bd633491b0955f68a820fdb9973f098b17d5817722093c5aee8f7abf7aa732f29ee3f03c587114813e6db8c8b4681f5085adca897a547994be43ff00dc2eaac4011c1122a587c145d5c37baf4a0c1d8b12a47ecd91eb1cb59f56a10be8fd1fb3dbfc7b994f3e4ca02893c6d108de87721da5f681aaa2786ae03e2bfd14ba38af56b6788dc1b714a178d3f4e4ea3a8426dc6079dd0d6beadd0a337cda4da1718149f2efa9fb6596bba0ec3203a8c59c68169bc25a1ec6f2c38b8cdb92b38e6604f9766d56d03ab54e198a99157b0b02f25661f5b0dc821c89a44831e63d806463021ce1cb58008881afcd340500f8150d824e96d833eb01ffc04a80ec35e1237d04569ebb58482521e794734c1fce15c7136c354b5a0fba472e81ee28d5842071e8a60ffeacb804f114c2e8adf79ee6ea3570e35a3dfc56d78d570c239771b83289dced8367bb5c8ccb3a2d8453b353382e7325dced5abee969a3b9fbc3938c4606df065457e598300380aa0616f3b04491874c718ddb3f46828c86ba3ac160eb246aa74a00a3c256d3360cb109b37f2b1ae67b1004e30d10ea48ab83e81fea782bd1af572a156551d7996d5a9cbb77cb798a8a9632218c53005f82634d1c7ab459b1365355cda2c8098d1f2f8394fd8b2e77e8aac92aa7450a089f18ce72023df097c3c9c5dbf6bbc310aecba9e7476301a8646ed24aeacb0dc0477f395977598199308df0466b10bdcada23bd5b9ff134e31a14b052168b49a885aa29bfab8197fce91823ea0fcfaef57a7935b85bd2bdd7b2c44ea334bb7ed0f338997f5f0886113cc9d4c1e3af288607759cd8840faaa7b64781cdfa3c68420fe93345da0103bcdf3a4864c0ef357f3c4fd3b464d6067d7ce93f4f2b6751d1620d360bf91a101710f7d778c3a01e0e4475a5e04cf793775f8dddce8499b1ec564c4be7000068a20be775c2061fed39b0736be2a577bc36926f155add83ddf10e67726bdec5da9d691959f5a20eb7548b0a5545140053451aefc1821891d422887e3faeac01797f34bb05db311ef0133946ee8c0896fc52321dd0c5c68f0f66edf1eea33548e768b8a18e39e68488a915b17acae4e90edf1c23e8bbdf5b5e617995bbb1c8620090738c69c7ec974bb44aa9e23149be4be4f2c437f850311cd9aa89c0af83db583df59175e47d8adbc4ad205bfda574d1fbdeed4bf16d714519a01d9cf499fe51f2393e5a60ba194a44de74e180bebc96c93e0a39377fc19e888d2619d6fbf26978ba8e42648c65f398248e3b510025c68f5ff908d0131b5ab662455a37ac84ec58a847fa99c455391b4948629a358f2af5a2d2b1dee3c660825e7451b0ad3b9b533cd9232e276fbe8013f0457d8f031e30d4742d86226897291784624f61a4a9592ec3b9ed1efc442ba022d1990ba1317907464411d7d26e5f1f344d1783e8e6976bf6fb205d6aed349b9b3be02cc8603739860febce62763dcac5bc1fd1362fb45e6b2344778b361cb883523ab5249bff3933b1da93584b726ae78f15076f20b174105b0714566e0dcfe0e03dec121d319576c3eb2915a47572f91b5d8872850e0099b99bcbe3a8e3551ba6fb3a46aa6bd99898b80aca4494d3f845e7589b8e4a5421cf8833651f4c079c0817743bb97e433bb9ed9cc039b311aa7b254fcb522413ab9e160e5c9c12d905118344b0fa58890e641c868b174ad4f44625eca6dc18a2e5d08ff678559b1c542a8788066e1139600bf7725dc5bfe6314badfc467c7c104f37b518bb87871dbd24221fdea71e9519cda4d19aa69717f04fd2db8de96203a00229b7ae41068c7e43fa487a51aacf087cf06544be0ad86164cabe91d3ea99456aa1eb2a8336d68430a75563134e574b36884322220244b8365562e2495636ea358def68ec7ade27c905f9551612da7b9dea9826707270ea553c75bf6fb2967ab7d7f44d271f5a1de45b0e8303e9f8b5c0acd5695c4e708eeb74ac1d5e410b639e41b6636c7e0cb7222f1c757cbbc8f56b539ccf075505802aaff59e07e3457bd6cd4230251395637841dbfd4d7d1d4aa37673f0d2e275ffb77d9e766c49718cb888e388061f3a5347cb0abeb21503cfc158b8b6305682377e1d1a8671f4046d84285200a225cfff8f6e9d3b0878db486dd3f97d78a8b459909a2c3eca91e5d47f16dfb4152313b08d84ac98fa3614cc51c1cdd0567cc4071700ee303c4b9e7ed4134d882d849363fc7ba403c32c795f400afc3a6f1518565d995a7fa74cedfd7079fd72dd5f3481c2c14f2ef3da51342c08cd5621fe25d29adbfdc41834c57945c2631df595ba33280abe3afb9e7e0ef35f73ce9195036cbad87af4c55a2275759439c946e8ddfb5a8ffbd30d034228220a3f3b068cf536ed804aa01577154e4a0be62b5e3e703c9683ab565085f7d1a5126a3e7501a9628fdd0a1d439ef15ce4d366f9653083cdef3ffc060b593131b26d469d43887219a86bbfe792d9b3bf877f90145670bf32e44b1fed3dcb7e2e3817fd3dff3f1a33d972d83cc68e5a13c3af128a7a6ad5ad9e0abae4b794c7b4aa58f7d146c51d9fc73ffad13e55171fdf0e7a1671649ebc88981fb15ea79234a60fd6fb65bfe2c4e94a3d1934f02a122f988cfbffe5f08cf6ba65c9e3921cab42cf6bd25892024227ddaef9581548961b92f09ef3eefd4f5d868ffe5a34145c2a0cced00c83554505c157456226d97bba4505d4e8b093c27fe4fd968d631cb8b6aad6c06485a4baa77b648f198fc87cb76006faa873d3801ffdd1a1ac95475f2e133ad0d754379f8d4d64769cb42599443644bc51aa84a80c21ef39a2632d0bebd221935bd13dfb7d8ddbfd51251c5061edf3fbeaf1ed8529770bd594a35d8a2e44c47702b0e4b76cb1313b45e73d2041326e3c81bb92aa3ff0847952eb9f84c5948e736e0e219a8febcbb4e5795a3a69f650721e7fdb842427b7e7b07406b9e80b6a9ec4f661c957d26b5c2ad1e0f3d32b5c4705bd0fa73fd048fc1a16ffe361ebb285527be366abb2b4e25a880b5709b7975d46bf69002e7c0d2ae9e1d3973780e7372e63b44032c73397236b5adf4f2013f28a77424ea486f2182b9219f671f26b035cb55f748d5050e0aa9250f22eb110005335d7cf2c20c2666b4e915e743a7777f6b29cd9948a65c37b74e01b50ea00cec4ad1ca36585250e16c8ac30629b8c277ffb050fbbd9234abc8bee4b8b5faa19e5c5d31e026da2f4cc00e18ea86db270f5022b571f5ee3ad7eef79b91dbdee2851435cffe8a38f71e98e6ff74439452653d7f47af277799d66c7c842ac450f8c78a2c1dd340a167ed74aea0c1ef0224867165b9a53400fbbe049ef535fe5efd223963912bf6874036b79ab2827218eca72fb488764eeddcf246e535a8d307fd150bc9599c71ff9160c58f53478d6afdb74f745e6d50a80a46317f77e2dacafbf4524b560ec58665905a0616beeee5089827a7d4d19d86db590b190ad3e0e71370584be05a32fb99a53697c42f54d88b20b67f9ea6932ca42a03cc1f6ce75ecb54d1ef9dbc36e86083a8ad8a8072b9649e007ba8fca04fbbf108c69b13353783419fd34cc54417180beddb9c4131daebabddcc2178d6aa16503de3115ae027617c70a1ba9b078331e9b2f21f39e0f43832b05ce3b5d2fd75e3597bb5b114d35a474d2540ddba532f021f4a7b6ffa9fadb91e80dc3ac47fae9a99d053bfafdc4c27c8c18e4230ee7ff3adaadfb5454240297d5c95ae1f7e08dd89c9bf2dc5bb1ba05f6456d44ccb0ff65f85b71057bc500d848eeaffe656e18e86cbce5dd6d3b33d38d0b2028a852bf98acec4bacefba16713ab0f4b0f342418083c78c64c0a4d5cadd015c4a1a4de622bcf3bc36bf42ddbdad114437fa14fc574682522411e8b1844444d2a55387a693c487ffc1b51a99524acbf3f6cc60764b68d3b5447f58daaa9dad811ef62993fa5f5867915bdf62bf53a738a63fc13ad33454fd348e4626c7a27c57754e47bd7a7bc5de9c6f9539eb9ee96e9b4fc125d12a93b088dc03a187553f58852d6c8b943bc259bd81580af90febe07e6642645d8ad5e641a91cd9440d28e4a4b98b0f482fd5893b138949216ba6555f5fcfd12e3ba720dff95ee99bb5d6bc47da5defcc7f8a8b600b7b56d21b4c504c1f4ab6d7ddf973b836a467750addf48f99616f1d96d74db3dbf0cec5f4ab1adeb8151839b343aaaf912fcba4bd67de7ee7ec42d066fb68fd1ce14cf4a8dfd06a8f39b9f9fa503864db472125e402b32b7634aa2443256588d7a06d83ecfe72d0ebceb94b8bdf223d9ec8fe6031ac294716cabff6792b4674c7038dbaa6ed9327d534e64900515f1dfefedd76b21ac5e16e358b819c992d036b8ba3c097f95c9591efa8a457f10e93e5a37db554a4efb156fb2fcc70c1bfeeec87ea779424a6263740fd948c2f9ae38457e8513a96cfdab858e0093f90f3b06731b14a8d828687ddb2f7c1ee71d1887278ca60c7f93c714145d612c1cca4cd46396c3adca71e66f7f0f1e5d3a10e220a5bb42ffa0602ced6db880b353f999c6093285f54be9fcfad0550952ef87a7286b51f54672aa60885449171cfb8c94bfa04c27e4e3fa45f913cdbc71556d574213de107f483d1ca3d095e48edd7f4fabc88c734ded404346c6ba157ca2c64d85aeaed03a41f3ecf2e61b7485e6adc33e7a74bee26e5fa644596cef257b52dcb45a636ca4cb02e10792d24bff13293f5aa74c0928921c0486c619e000000173a2cfb1cab40fb3121026cf1e3798375e2ea5af32d53f7ea513a4618091c4d425848c55eba407a5587fee4751e316fc900957df2c2f10af691ed3e6288368e0f661cc8d759f3cf692ab0c6e97b911183eb439dcc83f35086b98f02a78c78d51540d22383941302ed6e316861ccab29d1b384ac702cb47cc49f41da9bdc41f0549d7cb868a177a756e6a68bdf7a3378b46e40137bc20e980876ac0671e8f4e4809016d9ca214237273b62f6951740ffcbf3a75826ecbd549747e9d71ab67e16982f23b6e65e5be2f54c50e5fc0ef869a7b8bd7c22dd94e44c9c308574d74b5aa627bdc50cac50a38cf2baee00c488b63cde0c5c5b956ff5e3ef426f179bf997","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
