<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8295b5df46a424f27c5ab5748483cc0960f70d6fa247cb9184be92f09c186efb05c4ef131b71671becd9d3f52792c1c96b39bc069c27acd7f69de98dfd2a123bc33b938fa9a6ec149d6ba0b47886f3a4140e4d7de2a648f16607f6e5797fdcfeed21549b0bde1ec726be61f38d98181c1def7914fb0be1f9bff402b5b2710b2eced9e2a48a36459e597207b11112f0612a4465cd76ed963ac89d7976f74e15bfa7e82086d38e07342e8f9b8926b0feb2c1fa90af8d55330955d9a9b2e03edfb3e6864e52ffb71fa40e44b1f01d9227ce7a54937451b82148e4b164cf55f8d87fc5181c844ae9246999408e90f5776a18c6896e19e853dbc3a1f460ef1f0f086387aa8902e44729d352d8383be37050e6874b6b95513740abade631495ddf98ff7d4b49183617aad0fee3ebe0babca580605640c1bf1ff31ee2231579eda4a36b4531a1c0bcc220c369eb196ae6a3d8a2f9d1aa67369038ef12455262ecaefcb795646a79462c890658b7dcc5cb16042c3c8db81bbd4e26242fbdb4632f595867a15be1d45c4d2399728365ce4e8f7197a4b231f9a0fd95c25b69acf852e694972e14104d018ec1f63a706a7389012856baa2501a2b775100f6266350e08da7e45fdf601270a0577615ba23dc2246b5c63d462b6a9eb10c5c65a3d42c32cd0ea6edf658441f12596bef0d5a714c90e794939cf36cc733b45fa7ef92e6a0003b498110227395ad3f014fd71411e029a3eb79f721feb7a0fb22af1b1dfd70a986d3a720ee6b615c4976809e1523959e206e9475532be55334f7dd2b78142b03ebecf3632281873d0b434c5564aee0d4b4e8c64b71eaa6ecf2ade3345f9ee03a51175fdc488a354bdc63430a3f1c97bce7f586b07253feea68b1a37a20cd0b66bd6139a25cd01a7e16c3ab58c2d7b4aad1aa824058b21c2e3e437450615484c5f8d0542863717cb7c73713e72e112331b23a73858d97bb7adb65697363284663ea88a731ab37baded6cb9d2f1215c3bba2a97cfb3249bde29933165fdd87528d315820164efbda5dbdc89a00a67ae55b4a4c55d14fbe87b4bd3404891fc3774c191bd729179e7a610296113f7f3707c8bb3e4ee291f4fce70cab30c6939cf2b8bee97213217413b255b37d8b98ed6ff98989a20c8af0e0628e99be0303df7c095d1d79d5134e9b3808b57d1c6f8f22bf8cee4bde36c851ba95e58fe6e5c012ec388a0be822d4f378baa4d6cc8d57546bc7fc61cf72bd96eb027090782ea44a176c58552e39b15af0c6d6e1f00b39ad9417359331fb31946c3fee2b89f82f86be38e3fe4ab860bb881aef0beba56b851ab69d415318b37818f14be8a0081b2398936ecff075c6e90acdc35f2f0e150bd247a375358eb1b0293da3fceebf63613458bc1e96d9759816ba201415dedb634fb24ebcaf2de9544bfd84d63c1695aa079c33b0c2d6b405d227a8a24f931e00b6682ca4fe9f8abb6f2c88d29b3bdcac4b6ffcdc4ac9a7f7ef6eaea5b76ac7f800e19c8d9a1280d7d1a418fb15d1614043cc92a4a277ea8a57658231d38e26e8111d6f1f9ab31af4287fd9cee783f81b920ba6b166c018182aa98f6aab75aa74a8fb3f527b5fa0cdd48cdddca6ab52ec95dd51f8bd2a0d86062e4c3fabfe8a1160e43a7e0d947e6f1f9f7b254fd7271337128456581547b63640032ecde8e14764b2c1c328993da91822d9b25afcf7ac5748d31ccc4350b207255b14fe2b9d4e327a70f0bf88751e673db9958fec5f4ef85182b5b9420ff1caf3c4458f6c92d0b455c62c2530abcc290719db76f2fdca0300a94a691c79bcbfb983e9a915222d94889a14827fc286a51c868bf50c86843c8fc57a377bd8f7d7902d9f92a389fb59098edf71edea9fe08c7c64edf15a679327af147cf142165e6b47e88c7369780f78612ea20eaf7eec24d08117120e7919690ebff33ce023f36c1f25bd7ffe6753ddcc40cc75f9314399beafcd2bb42d3312523355e8a10993cdc01386ab06a75adf307ad7a697aec1b8f462f5e80858200270b7d904929a02424591e326247042fede225108f8fb4fc2166fc3e893a9a18096b309c3950e35ee998fb7e09e071734117638db1189180e99d048bc6aaef68ac651750a47af096316edb33c6674a55405f4b3256d172800474605204145136c2007e8a4cb9bf3ea9a31cc51cf1bd7ad73dd80ffa296644b5c1c0e087328b7b8a390d03af273fca58b9566b7140b9b638edba90b792e8435ae020c0ad8da896db730670967308cd744fc451be29dd57142d91676414c88ed5afbf733f0eeab6d4fd81b4703a120c71dc9cd68b20db887dd3ea1e4859045b3f0fa59f45326bcaa50c731fb19aa280aeb69e216a8502473dce5e72ef78d816a92ab1df2642b9e8f3474fac641868e7b80dfaccfe7d0e93e84747968f877981137bd325d3e2d00573187eb52617769dd1931fe5acf9dc5ac057d711574b49c14de0db3d983834c8cf556716053418f9f81ac1551bd700592796782c25d0797d7ea6c63cc63bfe7923e8162c2fdc59ffbc31cbc1fcaa394cc83c3f6e803f6e1881e8e45377f79d8e120c3edb7e2de1dba90947615479d4541c942a1ac314f50a1301fd3f6ed810c997d2ea7ad6bb24bf7acfddd902559ebdb2e8b54c07df57a129023c8d96111658041745e2ddb35fe0dc81f66fd095996d44481de61f21fadf74f6a9f225a70556ea048e619728d3fa4cb6a6fb9b3ae6aeffe4603afdbdd58f65e286284e8b4e001a2d4c77c05af7bc5dff5ed86e296f34dd2ff00842e0560ad07bdc1edc3c6c2982564139e3b811673de6115ccbaf2fc206c099f03c195c181205229aa56de62afe872be07877442688692f4051813f0aec0b3ac2f2ad3784a00f6ee4ed84c1599b41a5933855d30f86a435ea869d9319aebbbe93636ccba0de003aaa6b331a98dc09975db84aa54eae7b1689378ed495ce3da418b1383b802c89aa95f462bc2a6fc401ecca6464174105a69e15c9d58691464e892e300531702153f4f5411ac377ba806a08c28601c302cb134db8f05d1d87352f494d2bb42cd6dcf0420da071dfe5c10ed2388f50f3cb6a711dfec2333e0c90b8764e0b1b5ec0f70c83b4a545fbef5a3ee5a52914fd6e857bc77eaf32a5163a13893edbd6cec5b5b44fbac2a5402a7c330882221b4051127ae2665ab4e763602726889211d6735d878234bce6bb1380d70c67a4221914971c14c23ac498bd4fe6b8cf49435a0922a6b40b67331b4be5f769e78fe8366612bdc0750e43226a5d5365732c5e7641b4c7800ba906c8f7a491de0f1b210a3c3a8b108ce53dc2e65835a9c80714a95da3d0588bdff5a05bddfbc8633c987c5aaf0208ca1f5e49ab08d8689c5f63fbc019834ef9c69fc34668ee25d5e66d3d1a7c04ac73bb29fdb39ae4664c7b5b231619484bdf5cf07c4e1383a43d8a8e6ac390a8e75eb16f069286e33ecbc67e6dad4f5fb15888f31d599e2eac723ee25dba03b5b75e3e8ef14b26b2e08b25597375aa613e84a861fd8b7cca2161b5dd4b825f9d76b2d690c2cdc5df869168c0875157dc25f818c6a073d93a2c223dc6da9e46a3a1e280720a0a8f96d9c532d17ed2b14e9c1078912b83b16f1b56a74418acb261957189d9024f798cc3e7f2bb19d42ee7e3eff9dd801cfd0bd8b7e11950bb836c7097f2395f70feda59140351cb90590e913ebce47e6328e3393967a6ed01fb7b9ff3b8bd208eaf8d92c680ecec673fc23df7a68539b2fb3c5536c31444bb30d54973fc3288fd10a8057eb706a20b14fd18622ff30f875d8551b2eb0a61917ed0e954c52640a043bbe1aa5d1cb24fbf674b1040ea3525104ba80222150317eee474f4b1df0ec66a62a0d1149c5b2f2761a476f73d22a76917379c3da0d9c854e001aacb03c211ab5a7f92829643616ccb77eabd5c1cc5524f6eb51fe547961a848b94793001e166ae0c1c835a7d7f9634346f5fd2860cbaa37b9450f662965348d22bfa775b78c746cb1de0e76fe09c0326a4c7c0a352b027b446e85d9ae8a5f60ddbab40c04d8e9d5e038d59ba40ec8e2ad34957cf2cc7104e043509698b1766e186b2a2de1f908382cd9b15dd5a491690c86b4ac4c50ad69380141906e742fd1139e0f62a25b687c7614e020b5cf3f004859ac9fa46195713f808617bcbf5439c22305b0ea6525443eafe897907ffd390fceb7b0517f137ce7582306e666f6a8a2bb4ae9c18f837a13aca37ea4f29c08cc2cf5db80fb296a7541c672ab2557e52d82ba32f327741a9739060226068a8f0c3b2facfe98f561e479c54e680a0ecedb7e9774768414fae4bbabc7c0d7cb8339a3dc89a291f74b58b284db5d428a16ac1d1b0612989dde1cf5786bfde4f74a98a0a09602cbdb41495ba1f0faa13928533e1bd7dc9372258cf73962ef461c701068cc89bf6f0753cceccaa6865460b136eb2124a3d60462c6e61a4267cb219cb4f4a00cf4b418b3a9db87b0dd55fbcd021a0f89da81ca4d21df7704e26c69a6ccbe7b7f90e1c21862d46a820e186cf98621d2986deb014bbe50e32e147cd5e1417e61edba93794a9ab42acc82b3558130079bc13d53c2b0eed4ca01344540548d9350409d6672e1424a345df64a4e44921784706ef7ba2adeff975a1cb9129015d12bc822dbd2200cd1616517951d75de5d143a6cd5e50d0593d324b0f3935523dfec2221eacfcae17827609006d4a8348cac9298e4541b8e3e84b8272c90f1136db49dc1ce0be4f3e98677c9fe0c68b92f8bd17743b93e81dfd9ad9e4a2578a85c858860874a894a3829de82d5306b9169c7337f0fe15a779e5c75fb2fd122084e72616513edc222ad0e3732b27bf3d16e75e8ea5e111b788b0e54a4e9a961e22a00ce032a3cb36dc7f453a0f68bdab6fee14e65ef3aae0a8bb480be4cbf4eb614d128189b2fdac4a00893dbfe46a807d6eb9dd8537dbfebb2d673203b117e9fd596faac834609d889af77a6dbbb26793bf09de7c7f52dbf2ab727a0b0ca6ad7233a679980493ae324ecad261d5cf69b3d898bcd3747a8a21bb2abd4c0129e9b9d9bbbfe2dadc36f197611187cceb2b1fc318fe68f473f9e6bac4a897a7e8b78d919926d365455caac04bc04e828cea248535b635923691ef9e505bd199b80ce909a392484e05390b7fb2a2c4633ce74bec31c7c3828b54b2d7b3cd282e3586cecdc9990c947ff8d18596fc08a88b732ffa8dfb532e1a6ea9f50956192b1ce8dbba0b9d3013caddb27c5495d7d1e4ca542e6dc878acb06c3766a0c05b182b87fe05ba442f863305544f5c29dbd67f22e0ddab2417f438f48229220c3a9471f1fa65199071feb7d6bd9d2b1d09c47a3a6052ac5f24740e7069a62cabe6809f8cc2b22904d33c0e29ca56847acb19c4ab5264f3ef32b87bda164cd599d1d7674186c812464b125c9bbc707d186681eb9d37fe432a2658c6d8f9c7e1e449cc36a01a24c0cfce262b355ae055a5e34c797158683ba5e46aa2bb43daf11549461b6c976fa802ace9f5793790bcefda9aeffb89fa2ee63c9dc53ef110ab1b262cb0ef668ec43841e4cfb0042640ae5d18322d0a679fe279b63ad11ee164a397305c25f8033cad5f5dfef01da08caaba2c491c0d522ba51523309a6c3d3e45d1e8179f6dc5a9beae0ca48ef37023cb230ce9009e10c01e35ed1198c7d5ec2f37d1541d02cc3d9975251bcdb0bd7ce797ebd67e987c1adca9cc0049978b19cb55ddc171763bc9f0d946aecbd2e20deee819dd6406d66b0f7483d6dae4bd8e32e0ba080a5952307cca9ec17bb3d90dac7ed28d255c5d0020f96166374a6547be85e9dd1a154e39aca04e06a75834253a0e7b07b1fe348af7f76a397e817f0cd3a666dbc6592eeb7d4ca73978817f820dd1f5547964dbfba968b2eb78393619b2e35dd53b72939b3abe48193b9501c83dc13bd0393faf4dfc7ad31d363c2c56ab9c0a80f6e2c6e1ca35e8c538ad03f66860eab7099a37cb606df5b0b0ad2b4a5c882aa39883f6a14122b9008ddccde3aeed56b5173ca972cd6610f2f0d83cc13a08da7852cd62394ca15165bbbc3c94cc86bae95d465686ff1b5377f204bdedccb833fcf0fa293d308b11475d9b33f8f78aed6fb7d9db6c8421974e519e401f1c8bca310b14e8b7aa8ba68d7c2c3be34a16222af27b1099f5101daaee0e3484f50e3d0da952ba5aad6a1d55e10177d89bf51ff0a30921a4ed63ff29a44e573aa2bf922ec090192c38c9483ea662632d9526f2e6b58a3ccd571ec766d393a3bcde89f85ea75dba2dd5ccc2eb27d34a367969b0dd89816846d31a50c0ffae3f3571d33d9a3a9c23a3af95a2e25da897b0d527a1cb2ce936e26ea7bcb6ca4aa6f69965eb6421485dc68cd7d330152655d87fb68a5aa19b0c76617a809bd4ce7d2d5187fc529556e033f66134b6a3592abfdc160b651eb2ffb78b7feaa6043658df79348e40d730d020b8a8f5958b0ecfc355c432819f53699cd55a12d230c2be8fe02c9d8188df162a624839fc150de89a774061db474b584a7ca950c30b0545bd9f3f76ed924cce2678010f113bbc902279a66167d802fce6e6f42896f051a0b97cd22cf66fd0e4beebf9e5736ffe01a09c689f140b2ed7e8204f0859bd5201694ebdca3286f2c26f46a3cd37cee6e6afb21973c6318fb6d198672507033afea6ba619605e7329b3eaf906d0cc98878dda493441fac89cb3ffbe15757917e64c152ab61f22820583ead91e883cd4eaad1c98361bbd9b2c42e00bd95e6d76b98b3147995a9e7dd94ac008a55214c501851710045822c254ea1072c098a17ec19d6fb5c07f22cbafcdf2656466b8bfcd23d2984ede5878e0f26b8b67adb2b1058cf15767be0b82e0931b62943f65a9316b53d610ab42b6c8dcd7cd598981238773227c873193611d41a023ce8f1e9442cfa4384bdc04f9bfe4d025944dbfdcc75b354fa1779b200009631765a270b1e7e863dcebf55a2d50c00197da5aa869f4565459e429b9ac7b23f2d0e48f01fab1f39098043af0a3c082475eea762ae1f5846c3f965b8382b5c051b9a9108f30bff63f49dc9934025834015b776630710683ba390b3cf16a37f7949e83506d456fc174cd1ff170e52822d3721a626c8e2cb9c45864e84d674f8d79d808aa132f34d62998e5d3cbfb0263454d423e4272991bfaf554645216148aeeaf1c23be8886c327576e90a465ee195d6b6f5d5905e8a9ba4c15ee053d07180427488ff76a7afd1cc9b1df2fa4812c6c94d1dbaebbbea2277e6d6c140dd82c9981826e0d685148edb2f792b33aded33004fbfd03cecdf02a41d7cac3c46d010987188e2f73540d112113330813b43d60c8b035aa21da705fd5215b80c7ebe7103312525c8b6238ad626aea3feaa34a6858f1d6e3d3dc6a8e8ca319c94ee44bc8c787d2665a20489e82079713fc09ff734a87f6fa905619c0aa2e2bd6c234353ffcc360c4ba33f4f8c3447048349c3eede5f87918821bb72776ff9e64cee838387ba1260e5fa2db7ee89200f7c16f03778e071c90cd579c326ec532e7a7928221ada006f6742977ea0960d2f28267197228000e42d349c5755290e94acce5b58a9f9b6c4e620d083de28c9fe7e5f7dc348bdb76b8a3b4372f8f3178e5da0bd83ae79d5f75499bdd805cf5ef40c17d41e5528f2afab33d584916e3d20244d08504d876407ecb1132920fd6a1ff37916555d8bff40693b164deaf16c0495c238aa5c3181feaafb09617c3e1b85d47c4d7d54820b1883215548bc568dce4da92bee19feccfc12d0144bb206864a9c52baba11e1a079a137829df330451e8aad21700b0a6991229ba68a0285dfff77217dcf88ce6f247f849c9fed93269894222ae1e7451c033b324b3ee1c695f9d7f0357162bc3de0743884d5da84ce294bb0fae4120be47379e0c68a057ba75e6ee41e04562938ac94b342713bcde2baa7da57590f36e21512e6172f43f0bc08949be3b7b1aac7c1c95a513e063df5e984a2daa916ed4254b77f6bff07d9c50f4c4cb37eecaa92adad0e5a4d5f9fd4896cb932fa65c1541f8ce42825119bb75dcfc97e4c63107daedbfc6ec6ebbdb70f955a4572e6b20b9519f9e5e4dd67b2572311ef085e24ab56897bb7c106196a947cb30edaeceb10793400cddf12e982ae6691887e27f9156452ffef7b8215bd99a2eb2e33e0c8b5cf67720127f8caaf9780fde07ee3bbc0fbb1a9ac3f6ff1af5d005770342241b93ea6decea3f407dd1dff38d340ed072c25c74ea383438327e04825604840d4a67ed7dff929cdf5e2cbc76b6e1459085ccb9d0e71ca5a6ea33a87d62e0a8cf30acf359607f0ecd1fcb0cb2979a4bfeb9116ea2aa5e9caa4150345f82b3938835e872023e32b7c424c6beff1dc6109ea7893fdcaea2f4e81a9fa2e94acd253dc7aae13ce3cba7880d2dd87a9f0b553a4593aaeb6036a90e663bcec5098b2ed3b9283323c6fc7cea33a6ea794382f962f381732ae40070ee52cf4338b19f56198825906d15d0d6e621eb8f43fe7c7a1c71a350ae450647090d2db5316c43a9995b9e231307b3fa2a5b9e07861e066d71e39f085198dd4219ed63e7d8cca10e7999527467bea04b6e3753324d4e13520633b767eff73ac647a88c2f55faa78c85be93e383133e5b72072a44f8af0c02f84b447ee5abd50acbf5a43cce05a37fa3ea097b8f158a989115362544d7cf49f7c5a393cba16be2c33d2fdb21aeeab554736ad560c9f9e85372ddb8221a67cd4be38eb9c1b2cd188da96811419d02ae86811675268eaa91a73f5d2b437ce7f014a7facf8b7b3aea47e74083321a6048fa83ad838cbe22088ec8a9be6f0c48933a300f1d5a23358ef9f31f3f3cd89d7c256d6845ceffc21d4d090bbc80e1e9097c7dcd4065fcf9da2b001b2ae871ce94bdf0461bd7bf22e4ff5d43ba05f969881c504f1eaed5c1b6a7dbac1b630147cd32017b444c56befab4514d1685c2ab85b44455be2194ec9f40c9723d5805d1d26fddf4b751bee717985d1079ce588177b7c27184d5c0d48a6d064982bc1eaeb08f57ee7b7d22089335818c9786ed7168ae3aef9f176baae365feaa654a178c8e4752bba5b8b58c6ec5105e9e00976e0b149fb3bc9c309b6223c634f7cb96692b1ba6b63226cbc4b403813d0b8141a4cd7af327a7934e2af6a3227e0ac4e4cf79d4ceb2fc786275b409ec6884fcdec48581ab249cdd6ed8e2aea817c7e9e27e8b82a0a80d9472cc18134f604d971200e81bece1c8ef51394a8c9bd6f98503a48cc3acd24fddc815c602331b7b234ae7a6f9a99d1489d9001239c05fae050b75802e11740c5cc35623921cd7341e80c7b552bee689a8b8cd0da416cb05b96113902e69f530d2424341c308cf0eb5478fa17955eec8ef79e30db6a76fde0b43ea40a0439a8f17ce6a2979712b04a3830bdf225bce9e014a3b13e307ee723a3a7f7a267601ce66956c238a080db633aa6e1b136e55a8c7b54466227be2edb2ce8f6883f8509b7ffd1f2bb03108f7d628da3ef69b1ac2a4f07af0ef088278c224977b40f1e7765dc0db0f0f0a87226f49ae4357e3360b7a64830bb6422800a0efa995fae77b13452212f9491a8f6334965be447553da8d313da35cc66231174b29c1602b0fa6903d7d8be910eda350a1f228eae950efed8ba8a9661243a3d8f5eb7045b9c68e46b7625e4ba709ae9826e677ec8b22db06cca8edde77bf51b8c9873dd1cc9a844a0b51fabe5b6ed6521b465276c5132547719e9d9ef485ed242c787467eb1fd28d67e662082d98a97d188eb35fbf97a988dd1ca04d28ec07f1f54660709b6eab261bcd69c14eb7ffdbd495820988addb621f50bdbaac5c15df5d2711eb925e9085c9af8a62d10f2fea9a5922dced8e929d2a09c9356c1a9e59bba8b8714211da52b97a5e145ceed5c0d13e8085cd636f4efb070620abfeb586fbda7c6df7c5eac13ba10e3c9e287840f9904c245e7daec3bad3c45df9c9c55b876d0da43d3a9b0d56522fce15ac2be1baf9bf7964a43a0e211306f5ebf6a9a0300fbfc8a8526b509e0a11562477d78038e82ac228325031ad1b9fb09374b0607a1dd6dd146d49e20d0666f2be854d9f6e2482f08ef741785a904daeadee0c9ea3cbc76c8a499df5010473f77bde33c473a7f592b06ec920b5e0b1a052418f734d7c1b5319c932895f937296788767b53e53ef935234edb2e62d1f2078cf7a4c9c2b0f2877e2380d319e939a94c7fb3ed5eab08107eee074bdc7ebc3719207aa7cbf40ee9c3664789a2631c40381ff40091d3b7f7e4bccc4484351e19b15c53b0d350d9c0e48bc4eed34f037192b1fd4a37c868cb5a5e66ec70d0cd77883f88898cf9f0d8870b47c90c3a328efd57625ea5c1f923506a34dba3540def7b146a04f0d52de44801f1672aff2a5aa7785054380f5bc2a01949271372367e9972da4f0d696eae30b2cede23677a203be39af45da30a3fda83e857494aa1969b44092281fe3a04bddd579087d2ec6bc061f91b18731d90c272977d5abbaa56f8a48305f550e31ae8470466e65304b7522d57bfc62644fcc5fb58f2651f873ab3b30f7e3b99def877c5449aaafc1ce14cc4e87ef04d00745d4c8c3d8eca139f7779d6b73814d823ec0576c3142371eadf9ae60ff3f3686f6bdc47bb209cd4b53e6531cc98397605c6b4091178f4632b6866d2230873af3f02c16e1589937753806875c04c96738d3135d5dfb83ea9667aa7a3ac411dc02d86a9a582e8410f600fdc276a7b0b38e7b047047d670c64fd4abf49726191c2a0d9c48d4e2ce502635ae788213c759e4b5613598b837e863c395c6d1cb4a9036d61b4955ea7bd1f605533c2272ed37bf04f6a15765e4ff7321c0946b1782ed04636363ce02a81661754a9cbb5119307d1d62b9c521efa56cf6e4aa817ef4e459a555ca33b84379419eb8d0491370307173726b81b51893af6d1694229d596590a324daae71bfb0b574f4eeca1d6d8cd98f020f76acdf47ff65811a2fa2310114b6e18c859d0ef275e16a8504e74885b17cda5f8a314b8bd94e46a3c15a643097bc30343dc5cc3ee6297a7fb8f12a9f064e817d898b79110103d1da84b43383cdebcf6bd43edb4eb9a85d1b6ecf8b966fb1d173c591fb59e9bc3b3fa8440d8b7d8e552d37a459cdbde9d7b71a3e3953d95cad5292b7107aa870ba8d4b3eb42aeb3cd00082f7fdeef2b94d47baebe431dc1a5858eecdedb41aa367509cb4c81c44caa80512b8fa005986ac2322cc9d8b979187e2f791bba3bb0b5dba8d57a20d1ffc894d587c6b5da41857fb89655a0e0d09faa380778ff53a7c6b24fad5542f1b2d58ccc5400ab89d1b7c71cdb18b972f00f40a780e7b8f6c0f7e841f549f088404af325f4c47d83d56ccb07d63fca47a9e003e94586d15f95369e55328a82d8e786fcc9e30045a155ac138d4308254759e3002f3516c9b99126287543694aa01b58115c1025fd63216d5338352252ba448b1bc65375bac65e9ff4938b7fe16ff29a460dfe238e7f72291740e1e5a275a52142ac1c9b7227399597f66a9703c0eaf4be33ebb4d08e85cd859f0de4e0184259aba5de02ba36847d1f3bc60c7268627d21154b57a75b98b4c0c814f38e2f98816618c6ec5d1242c73d9faa1656694268cdc2bf8148a1cf2ea3457bde5d32725b6f2328fe5761c4d3730ce5ecd28c6101297c64f9bdfd89238e9f6dbf2edc1b404f87eae9e15a08e1b3e1cbf3741282e394d0251ee9f216818f9b59366e8e02da7331d1aec6589212f1bf103fc7c0c02aee7ca1a4daa8b3f66223428f99819f33a2f82333663fc3df2dcc964493eacbc5772d34b1c825def49399290eb7f0d4b2ad241c62ac61668aeb5e8a5ff2520901adc2c69d007605e1e434f32410325fe0866c3ffb5052e46bb313abae8e811cb8511e61c6c8606d89524542f5ba5a1b2e7a294826388643363c1c753102038f757bef56b19e1960335a0817458502c5b8f6ed41e5132a73bd3ece44b8b31dde4bb64b3b7febad7e72893884e7211b8c362ab8750d0346218a7ae7855f2c003f25a1773dcea0dbdb7209dfbf6618de6812a80de00ec1d431f3bf75ad87e31a1d6e7ef0e321939a30c8e4c7608b4935ab4e6085f21e23461733e21902c1b7592aa74dfaa60a83955c08331617e076513a7fb2c4bc248be1704bee8b18b21195464c28ebfab38edc190b42fd24d5815265f10344c1b8b943357fd2a94b02597f321d1ad88867a090432a6283283c4a03d25fa72ff2bab7b3ce8eb3a5ae59f238015030af394b6cfbadb05c057634d49f7c0e88c809536024f68dd93175ecdbf311b3015da697c7a0df78ade4c84f0bc0496c5b975265f93ac1016a5e6120398957be0672e93fb8ca9ac892b3c920c1bb5f065c3b0194423e933e352980dcd8c4c01c0af6f0fc5a7f67912a0785961ad4dd6a9d49579e6e7e184608e2d0af4c156a46485394b6b66c5694a1ee3a0efc93b75a09fa828ac65606c1b39cdcc11788915f3da401d086539a55a6acc8c0ca76969eaa17f2a7d88993de403e89fc2e5a8682644a469ca15d362eaee0714e7b439eae1eef9db0dae1e6bc98caaead2ddae968479955b8a3d26212340abcb2e18192604eadea39887f800219df9e60b6b0d916bd999ee5713c3144a46cfeedd8c72a437cfdf0c6bdba16590e91ad4bbc8283a9590ac5130119e835841f152724ded504a273c9a9c4dae245c4241dd5158889c15265c42ec3c61b9e041298f82d4fe4a3fa8f05d4889d445edb96df3f19e00e940c02b526023bd971dde4d96e6be3bca05df5145cee4d8a85d0a93f55d833becd663e17e4bf94e9cccf1307e0225e3a00d97fe8d3ff574ceb2e93a7978115219c22f9757e704cbc320441c5fecf92f18fee57cbebc6000aaa394511a22e22b67667196bc2fec63520c7595233f59c48918b62cf9bcd9df5f35d7885d647d3b8e61d3ee94df873536ad21726d12cafadeae2d823cd1c8166537953d40923feb77c7ad1e02bd49af63236c674e01640047bbf9b9b7dcd4c49ede78050dd2c74a14795f2cfa31366dd0a12ba2c5287f581e00fb206a7fac67c19f35dd23b4caae1d70db4d195496fdb28215894e38c3352d4f8264c76a2c930479e0cc6af230ee9e4a2965f90982b56af4e4b3a19a7bcda5ef7ae29fc99f10815833ab524b51305137fd3679cbe1f1047358ce3d169b923472d09bc9bc7a22467b9ca5fafd74dfc17c4c60f993124ad03acc7c1c94bf0325aefb369afb32a4ebf48031f8243e03c7fe83ef801ae43b7cdbd8c03f901ae442ec248ba5412b83a49920152142f70f3768e1e7b885c4bf7f34569f2fc758d86044ec1ae4dc09ff9e9b339a16df2bd8506aad42d5bbb9d538b19fc194f24c8427b39e53eac733e69f6c26a265ac602c53f73b0f7231a965dacaa40511948de385366eac08dab19f0661dd2e4b495eaf2a7637c0387c8eb2ffa3ecc9e344e3ed3d2176d97b9541c207562018ab22bea945163dbc267476389a64f629338374e72f80f886b55376b2db9ceb53fd22297f9f7ff5e5042d60d8272452d9117bc72b7afd86a314452ca5180d7d94255dc39fa3e5a43495259b9f34bb5adfe7c9ff64bb916c2b6a872852d43d80b6ee9e3575840908ccb29e808114186ae694f510769d3a3b499db41e5331a0bd491c2202c38596cca4f49e9bc33e3182fadb34af9f4fd1e0d1658af14b13e4b68e89460d4af43ee317ea278adbab1cb480f2e4f57c450aac1f12671ebfbe1024c1a91ced254c2323af3651e40f25508e715456decac53a3c68370ee92c487f9cdc275ac192dab7dd21d8e35b2060042e8478ab75e914bf3e88848f647defbb3575714eccf08273c851c4ad48a1da7998e142527e6964f940fe605907f5d9d53f51eecec0ab4c786340e7615d4d8478ee9777a76fa0273aefcf71bd265cedfc8cbc0a73784cbbb5ac20314caee6272660fabb2978aabd9fad4ab4251531967bef21a9a5573317f89091e5dfa61e55d9c6e67e5cf779d6fba7a9e9e896ceacc23853b91b0a0a81360870ed346e063dac051ac712c83d0aef644275d3ebf65d478229c42a6074b776fc7482379315392a1f17aff1324b447e55805a31324eb1a0bd5cd9d153eaec06c6934d1e956420cb53b15dd54caed1a2dc53394541ce49e0940400e5906aaf80d53a7650cc6098043b561d26967b2877251ab5ca0d4a3d6d5930cb6026b9514a63b5aa68b7ce194ed596d2bfebeb2298315cc9f2b1b8392192859c0ec3dff9a88adcf4cd2480cca752521542ada4cfdcd956fd9a859640c1045ae8ef389faec3617fd636cf23c666f2d8f838bd6bb9089003ed015db65049df66187f65c9bc4bcd29fa4b451c063ae3e21d994d17d03f2234547381a1e75af0fb13ce95e493847341ce3ed99db317aca3b25532f55990086d53f990ba09019633e2f18066d2d2a85c3e079a6a6ac37ff4d0ffc0820e628d7eb830035c5737f88c59f08fcd0d6f1b8eb1bbb573392246cf61c5c8f27051a94e7b603885a121cb6db6a3b5856528c48907de9fa3b3b7f0e93504548e825df8156eba4f9993057c91267dc8395ad913cda3e49de471269d26f0d4930a1a12fdf3fd1ea09faa9e9aebd339951d83ab3e3f2289612b9ad9af29ef02f00caf5682bbabc1dc6868f4812c3fa9554523ef4c740ad1743870a67ade9bb384d570c5479ddf3eea69a6fb56814e38198fe7bacfce12c3316062cf682dfc22a6faf145f5ade715a991ce4ed36af813da55220df8a683ecb62173a18adbec6546cc29fbfeeb6fdf59e12a9ab2c0e74d2a937976848828e3b024bf8557d7fb12c25bbfc661f4d7437d7a51e8248d3cd700dad981cdad13023f57fc3e3aa4b760959b390dd369db2723036ba017a1d1c666f5e5551157aada145567adb9fba662c60d2a6ade0cc1b84640ff2c530ed8fc7f3c514f6b1d750be72368b94025628e1b792d151decd683e3d07826ce03a9bda222eb11812644c36fe01eff923e1051f9b4395c29846c6607a9481480ff177bb9aa0245ff2109bd78d666c732b297fb9165d159b745c7c596344ad250cdd24d851d95c4e36891f3f7f90d96dd44d172df2cb2ebfc81a1218756d76f0fac3638db13dbe5cf64fb22cdd48cd0b7e0bec561bd6d88dcf00325e2b5b8c46004e586602d6e9c70ba18e61212e87f48736ff46cd88e17ebd0e564f64b03a2f0dd7b0078117659d96ce976c28b9153b53116a414f79094909af0e2a51479560c9fd9d178710fabcf8d018f6c5c9f7acdfcfc890031fdc5ddcc3a9b57fb5e73dd52aa15d1211e926b8a09d85ce2c01bbb73d280fc3b01e7289f3aa2ed44e66cc47e42cc5313c6acbbfa2fc175b3f0090be12c2a38498ca3f509d1ab57d684dd94452f0c227538713abf5e6cdea40ef77b47910cc2ecf000f7a26e13abfc4d9054bbf65faea5aaf85bc564760ba0c800c013e321d126d7d21466e14877c82a7d4ea8c52e8651c66fa94dbce76003f33644e621566e254fd24e5e67f08dcebaac2206e41d954a6f46e96741b433910cf5ad34edf02e69f2ef80deef5468cef4379addc8c5862038fb2f53baae1a56c5d575cb42b1255f2336ad56597cc1d7496c579ea45928d0e58f280be9ee9812b951efc0c778d42e8b8ed5aa4be8b8770cb024c48e9b71ea501ab7c6d50b2ccc2480a0b9897723526c7c6217b7964a3f64bbd2d9cfbccbc1ca34cae61aba2c0f336862bb451a8d59ab5dbb19338b54cd3cfd9c928369e135714d887d2459e4fcbd106d57f55ca7903d84e59dd786ff63e09b56a2dbd97b852cbc9803401a6a0d2fb118f3e4c340c4179f9d1ac529d135ac153e11d08383ca160b8a35deffe6898f5c3956a31661e6427d784f787ff1175894d42f3ac1fed65f68c3200cc54f1d3246fba5c25a172f5e1103f5972f4f1fddcce26798cfa96c61881f27100b237d4031bbdaf5c88e922faf1fb06d74499edf6ae59ba9b0f1dc93df4392deb3b4fa1bd3ac38eba10f47889afce079967e0c4f8ff85fb3375317d09452a1ffcb6ccfcf2af1c02b05812b3ab659458ba90f524554769a4ba278e961767b6b04c5722d70f48550f3a2d6456f52f09d206c38e82d1c7eb7db5d551f454eb2fa5f92e310d36c98174f854b366b8a1f99dd1c4709c52b0cc2d5c5f04a6d8ad8612bd926043a246f0db2a6372f51c83bb04221f393c05c7bdc964388ea285e8e01befa88178b0ec6946ab9541cdf9ecebb0a98e6f87a0bcf6b3cefb00ca1b764b4ef03ea9c1662b2a8e76e2d5f8f991f898025e381e56878a994a366bdf50cd8e44489b1256f0ed969837b374b39eaa3f90503e7a2804eedf5fc5cc5527ccb6bf69a5a946599b2d1edd47c0ddd6ce5723e8a2416b8aef2effee61541ed550cc81da87d2a1f03e3858faef3368d49e99eb09c914a6f29addb5ba6b58e6eab0d6e2e5b3ada0ee699cd832a421028b79c84bdbf9154fae7ce05339ae590bbd8d0ba7a80c679afff3a18f5da76c5825e28b2b0723eb4db8038d4c5c9d11dda6d54be0426ebd3a63ff91d7a171a9fcbb5f70183a8d8281d78b4f389d48760b864fa05e100b56caa7da0bc2abe27a9fff5bafcda372959bf8c825eafa473d208d2a5dca24db88fc02c44980208ac8c7e195ee402e2c7052a6a133fe8a1860bdb087a2c71f5b8875616f426586f4747ac7716597211156430cbcf93e65332c435dc30e751e95c841479b200b5e8b2c81375959e19faf284e270cc6d6f673ba1e92614604ea541920a9412c51bfa4580705954db631ffe5f5450b798aa0e2b3cef9ec7deb9f336401a60799dd7dfd508750a120b191dabc07c8dd9fe37e37cfbf8520819a21fb520fb57abd8735ba3adad9551a469ee43ad03afef90453166dbd24094b72349df4659a0ef97c31dc2d85a80690d9a3d1a6d69da322dfa7d6ed5a15327ea06989eedc25f039568017c4f2ed91cee6d1cdd8734cc6a6f64b7f148dce35fe527a11952d58754eee46084ecc4b94fe71d01f33a132069a570b4a20d4ecbf98281d1c9296fdf79a3e97855b896ce335c7c9658d8438e9e2e618dfc313cecfeeb44b0afa489062ad9adbd08a835892180feecc460d182da6e3c7589a55b873731c472f5e733f8f377640382e8651c5c64063d28e61d4baf972d542e8fdf6064e9b4300d55819e064479e2894f948b7b333844c545ae02e53249cdfcd0b0160a67066977e3c52b1b892f8977f8c955e674ce462a1a8936fa016671dc5b861796eee5f2bcd819bed8c143b858c9d6ac0cc85d02c191979cb49d1f30ffd96be9febfe149075d985a93e0f73c72eb140621de1ab2406bb09cb1513f4f0f10fb758c79fcd6af4b657cef599548193292aeadb2fdc006fcb5e2e6ce7b6b40b70665d4563f61de8af8320d9808c2b3102903f072ac9b663d117286d07234de2de0615571728f3db79c60059a389ec5d336330913521681c569b05c18bdf50197f87c3efe4f0de8890663314e98104082c2de1f2c7b7864000d61db0635b1c786bebcd9a4e177d7c73066916a4ca54e229adbd2c51e23edaf3bb1dc7edddd835bcf60075a757d8977e4159980046df796328f121e4a0927caf9a9289de603ad91dfb9fcff8e686b4a97a5879758e09730565ee474c12d910e74fd43dfb3794787cdadbb1cb78461f6a0d22da203490caf38eab9e5423b8a2141dc7d604faa29986e139d91ee0d397af2c549e3895bb433efc8e4a22e86e6653bf810379c8ded69386143c5ce74c1043567817a8e9f313cbca4ff7cc7b8279e79793f14821414322986fbb1e9eb25ed30de6f2ed2ee0297de5c6c955ca530e381109afd73d87895a4b18e58a998a54784695c36febed9f80dc9361b006bb532d571b01f5818cfa97e2fb8fdd80eeaffb3bee8f6c4c44122df572ac3212a3fb418471779e17847e94840900ee2fc7d58474003d202b068a4590edcc974375b191e7a147b426dba728965b83475b45db904809f68674e8396b03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
