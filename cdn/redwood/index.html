<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a097ad89db31e0b06906cb5e6ec835cc4f7a3602e55f287e24bea3580b3ad742ef1dbdfce767b510a1dd02783b45d0faa1307aa42eb4feda6082fdbf8ed2ca198669ba4f560e3bc02c8a94553fd46e5ed9becb0a632596a7485dba881a6bc3d8c4678f00b4c7aa491e17ffd671a33ed7c6bf6c7ace5131147f83ab3d3947bb502391f81febd177429a42f6e9cad372f1c469b2ebd77a5642f3c8330a02f99e0d57a31d7c142a2d1d5024f4cebe977882784017cdd139bfdf3086959f70f48383a7d4841f86b9e4e3471f7e6f6a5d2bc34ca102784774364da9b13a1b07ef4a8bc058c924e06f3becc3f47e1ab1662502230c115922a89f9d92dbc1018caee5027d5f99a0d212c275eb4d21602128f378ade53c633268d7a5039fc92d8f49c25231edca606966c3fb3082824dabc51be8ddd92d693d17cc1a4f7ad60d3004201108e0d8ffcf48268378c73a69229103091713584596fca458ab4bd112878cff8af48e8ae1cd9aa278c2589da54c7b9d550e28df1a7d22ebf2fcf6dfc5f4bc466f0c32d854a8933c7a3e6192cac953d05eaff87abb7d4ccdf22adc2620522cf495225606e6ae11afde102e66feb56c81f445a99fd1b4ef0d4e0589dc74c5918b3ffc92caf9c1279b62769bba5cb99b13542829d78e1e8490975473b413345907e62c644166351e280661d325141997111b41d41e1a35ff1a67f06af53fa88e84784cfc6507b1a3b87d0ad8b10e9c2a5b46d12b0b3b2b0e02c2463fa5a64b0b92a9dc0516f90495146a6cf6cf575efb4cba02636dbd2f8f0f2f921468fd13efe894d248e1ee6ddca981b8f21661aae18aacd3a28ca5d1f842dc370b7b873812db7a933bdf77eb5a4c8fbc269bffe4af91553330a8993711a4d3dbf468cb15c0557604eb4c263675c6935b50a0e9cc72119a56d7db80c2ac69b8f7a05e51167af9e40917aefcd117b85f0e8dbc238820ef1d0dd6498a5a3880274a4f81a7501b121345f54c777e02ed4cd54cdda13183caed520fd7f1d12073a700232fef2ea813089b5f40c0537e5642e2b7ea0d2e44c7811b56946b628e1b70d697d509ee3472f94109c5d23fe46d9fca8429b914ad87120a73f83ddb61544e610eab4d4d5145d4d614498b4b425515938350c790f748fd01cf9a36725a4f0809074c625e43de7dc415e018296bf3fcb818db03130740bfdeba1afb0691d7a30817a44ca60a8c9aa41f1b0a527662d205b9a6838d270ca99708781c303224bdefd913b09c8589a741244640f2a50597cdc8b47fbf15bb49f29355b64c3a36cebbf4add37f01126f11194bd211a47febe21913d78d0bbc6053e921ddb798d39e17c862f9b7386b01f74776a504ac75f7094d5272af08e78562138c2fe9fab6be50b5fa9876cec3e37ec3718046248c89afa89ba4b6bddc51b9fa8bb09c8b2d59313d7d42a220c9cff8de58363685019b501298e72688f55721b8c07f94697b86e9a20a952cd3794d2af0eeee72ed68740aae51a81fd07d246d0ae914643f8477ce38b5a3d0cdd548c2b23b0e695a80fce51b9278c49836b4edb25915e2eec9e11392a62a5b27198f8a1df3316b8de7e1a18a934e6d953bfdf832d1b4861ea5e51542dc62273b8a572cbd2a3444620896460196393f576939a52f461c7d2ac75e2d5074f236b13a72371dadc188b13bc0bf784af91329d13f8c54a1321b8ada3b47fa69970d885ef3ea988e5e1cd30ef8ea47ec75dff319c2af32165791970ffd732d6c9804c66450849d912740b9c30fae115b58be61a9fb64b31f5394e5d111cb21f83af974c144e17899ed28bbd403f3f0f8e022a915d1a883f38f436dfef144fa5d14f97ca510bd5ac399bd1f8ee13c2db06ed6596ea9a6d2b76f284d418020cd568d800175b3f8c55e3336b0cad5034da62f16f65adee0b655af6e2d72667bc3dbb105e2a4988f65569f2f85c871b78d4728d3f2fbf9f25cc328b1d60ba3df46506d5c0858f12761ee61189ef8425a63e0b0690ae26f39aa5b49ce8b4e2f0f9d0ae726ac874a6970549c2f29056795a8374dbdd374dbc1798b88a5e0b3c644445247ccfc44d144c9586f752f2db9f1a300e1144a3543b117c499b3d0cfd3387c40a50c36936706431e7fc70d0b300c0e2ff92befaf466e8ddb5cdaf262743dd95e031f85d167dd7ca90910314de560ad428d59cac0c337104fc91f0978cf56cf4b6d82c0b63e37fcf4a0e1c5d1bdde1693d8dcefbfeccf1a53f87188b72afc8cb91a029b359a9d7e32dab88bf9686f25b416531fbf0ec7ffce0802c8b94afdc14d126eb635af4a9bdf455244d28edd6857a21f9541af29e7a06a7d8d8b8b9464a78102fd051c85f03ba0e26515ae3e8bd8e11477788cda0abcdea1c8f5a96d05d0c49f78650c6b9bd7bbfd265b31243fdefacb5cb99a1eb516920effe06997fd783b16c51fd73269086dd4bbc9d4c06f083f6cfbe4d9094ec7fb358f21d9c50100cdc265c3a71c7f0dc9fa1163fe435f5e02de3203d9f57011b6588022e31f1d539e491d99b9ba109198f3ed5ae5d65d141c5c5d2015293652bb916fdc49fdb1f56abd03d198b69436a8fe97ef70984e9eb299b2acc05e8dbd476541ba5e13b3ac8f65d82dc4b9728d2598c996c7ab4192a50f749197fd56abbdb13e8d0dd1cfa259bddaaa3719cd6b99afaa325541b5541b0ec5bf0d31ec9a7a56a219a45e14fa1a99edc943c1d2362517e7a5424bbe7f815fdf9e5e8478c139d4523fc01c23338f29350c7ac6d2d4387abff083ce1aad3fd52cc2bd7f3d5ce816406e23282c240d341d36672479d9fd296417d3feaaf658e609f6988548ae57dce09bd3a03268e19b0c68d24e7c89e8ec91ac51aadbd5e3480f2a1c0902b9c0d27e7db9afd7efd603f02680c129bc351d8426b4f33a1c4db16028afac3d9cbae14da9a8d6337924819a0b101345dd4bcc83748b7c6d0b8a33043a5d6c06a5410e5b6693f7d4df6a71fae9220b9f124e056bd4a3bd06669cd52818492a805a088cd239a4021b15c3beea30343080c9d0bf4649f562935c7727a916945bf9332525cb88c229ffe593a4fac50bb81aeb653bc61a6d1d3af7ba8b67a069260682a061ad0ce278712f75f558038f3ed1ce369873956e7e8886c83dba67ce37357f20102b030ff28c4027defde5f9e529021056b49a0e7993b0c7ec179140339c85e5387572834c37a1d18073e20db68a92757a3aeca0134f89706a08336d385d54ce1a103710403c10489ce5ff81377cf37de876fd301464549f8dc989ef01471cf1688c19ecf19d68c4ce564dc337c29e13ee9cf684625dec3329f2f17746c13db7020e892034077c0f5c0614cde106ebc03a5d42eae28e2c371dd77a1cda5845fb162071ab2037f85c97a02271b3da1bfbd53317b59212166126ae27418a94fb28b6a805edce1af852ca016015be6adc64c6c75d9a4887508217eb25c1d9fd24bbf3420fab17c855adbd77c3dc4b38c04418cfbdee122dd31ee58577fc53b3a9d6358ecabb874d322e24d302ba3fa8ad0d5b0d14f36cf39e350949dccf1715461e75ddf7bbac844ccd7c32233aea18b98cda79b68380b3a59c4b539284559a19833180931e166c49f3b21586211bae9c13474de57ff6409df991349ed9725d540d122216e1887f7d0515507231f62905a517d6ae6486cf9fe404698f75334895bd716d6929e593c204ffd71eee6b8ce2208e2293f52419557f908600c58a9e4e0284b506604cee8c508f57d24c3fc9a49a55ddc0676c1473ddcfc8e0ba46c0a10378ae46ec07f5aa0a1b0cf81fbcd88b5dcccc227c5eef964ab0fff6bffe6d204b2ffa7cc34853176de27299dcc6d9ffd100b52d3530d04f65d10910da9c59f22c73483fff45455b70c8fc7684572ac87c125ae40d1eeb62b6b136b6e5c75df7ac7282a6ab56eeebe408cead295266b4c582b36fba2d28e67ee0d7cd567fa701c1df516312fb83f68882f2c9c355e27f5316221c06e4e14cf78bd1414c552403699e5c7390cc4467fb65122268cdf89ab4ee051a58fbf1ca5272e0977ca5ef35d2abced80038d69770f3168a7a32a0b364a90d3f64245097bbfe9db66eca980053a2cc27b5ffd2ac1d39014e7c769eeafeb6a0cd712fdb3b4bcc723efe5dbbaec747be294e075f7ad9d20d8ef05121553b33dacae504c8b3a5a3f24c3f09fb4e0b12539aeadd8ff1ea4dff805534a170027b24202d32ca439d4b1958614ae608675d3105e4feb027505aaa5b6e0f1f9fe6f7483b34cc2e9db5476e0004d411edfce5dbe51a1c04a06d8dd935a696f5b85b268095f6a174179550a7a30128e2282794eea6d1036fedfce8a77e26dbb379deade07f5a1d4f8f6a81ec31c40ebc07afff5ba88d28dc30adc4b9a28b4f8086416090dca569b642bae4a7a7b0c83bf9ccb5a1a3cd350a12123abd460320aeabda01c0e6b33f6b1f9fd21ca38f63fe60783ba8852bc16dbdbc35fd644b71466581a53326aff4c42817e44fffe689ed7c36f284fcc2532694cccf29606c21089aeaad3d710bd25b1bfd18fc322727f1e23fb545289f516fa577ffd60638c17db931d8c408c28ec5955ef8d3bae8ae9b35d1b80d937f6cb2a5b9fe2ec925632aea614cef9f157555735a577b63d812dba3c67039af9e74af590ea4893c38045c30dd2c3987e097843372180816f3f982fef8fbea7003d0d37dbc5b0c63ad652f169388da8dfd886410c7f826994c611db74e31d49427fb008288e83edd36ccc477c7d57805a7e8648e4b06a8c52dc07a59c096c1ac5a8f386836906d54121de8a1248a80652358785e23cf05b319836f6df9728d9d6dbde053a526a5934e63f1877738dae5e08103ba45c86a23a20be2d67b32f05ba4afafca56da8a7aee753a4003e2b57cd9f14e24b35e2bb71fe6c8cfd22640985a07991d8cb4f46d16d06b6daccdd85bbd762e648cc6cc413f09662c5fdc69045d15ab369b82f1f9bd749c6619a7a487a2d962d1da6743d5ae30a08d589799f3445bb05c2e0e7e5ed642df657a4bac291862e386f664db05c73d2bbf02648d838a1dd47de3cc49958bc86675202aee471b2abc4c159aad1ebf8b2f5aee3fa53c4eed67e6624fc9ab2fa82f3739d49da94806f6eee6b2192e3bd77f9d805044f938e96a47bcc4d3eb50af27c68bd56dfd082a5e3a1b3227c2114d95fa235d90b865432f593c97d277d3cff0201be8ca5884b1b704ebfbedb23581ed11df35e82dc2dc07ba2874368ebf7d4df8fc0dbc334f69b911aadb0c78ae7a6454281a3c509bd9afa25394d29803284edc06736da67c09edd8292f7748b7af44d1490b287dae0632b5d37f115bf8fb5678251d46607c6f681e468b78e9e59da19e2e578f9bd6c82e9c9d87effbb03cc3201e5cb5bc49bc51a99abcc90b39b78f3176f95d2349aa3447f094fc4b11931ead8b5438fb0d18b1a29c05e39b027f0943c5df0baab2e768b04d6a6aa1f2fc8aa44cbeb782502dd3c25cf6b30894d3249c42a1b569365368ae2477985f8964c7936bf56c6eb23a5195777f9c67997fa32665a0544ae559a5cf91336b63cc693796730442e4e0638144e9291311922ee660f87a1d66fbb104f946a93fea35a3da846e00c2fa7f8c0e0ea6b75070585f86c3147ddbb807946c5d582d8744bfff08e834d4d073bab0a6db03fe13cb755097bff95b22844756ab0a458f0cce886a1e7978771d75afdfb33ad743de254ba1d73f237609462a5edb4385ee7c6fd74c3bba4b1bdf83f65a072b249a72e676ea2e89ef482e38a8084d36ffbc9b8fa2f62f93d263347139a6f665a9999591031f4d3d95adab07717e1f6ca56f5bde4b4d7de984479073549eca85111db960d4bd33b167071e4b05eb1a7beaa676cca817d57cfcef87c01ce15328c67090991021205fc090ebac53c5b6591d20a7e06d79e172c6b1eba636ed1978b8389c47c7cf1697862e3f260f24031a47afb4e245d05574280c3a2c99c36d3812a9cbe614717c695725ed9e5692e06e3b9232322d308cfcf033d96484161d875e9b137d98698da0e430a6c52b7cd301d6b106de23684880be4e2bbb16b36af420a0c8a364b3ab4f32653c357cb27b56a96fbcf9cda5d2bccb83787036c24b69e8581687fd28ca21921fd5a0032c5fffa7c97a4f9fa2f9e030aa48c744e5790600b344a97f6c4d87eaad9fdad7d1341b49b1f77b962c1f79bdb67aec5b56bc8ca74e9dfae9cf40b6c762711e666fbe2db27fb36513cf4a13501f212179a147f0d5d38b8ef914953b19362edab219db24e1bc50bb89d79b74f60e9c355b8dd5eececbfdb851926690a02ff342735a6bf037b1ed7560522c90e7297b59b159d2d190a4f32250dfaf1948f7f8f8c4a5492ea3ea9027fc8a4584dedf9eee7ec1010828f8e01d9c28922a2557623e229ecb98b3b02870df3e3297e71bff2188b152769762161f212501e44333bafbf91f825ddd7d0678c690a9aee0efdee81d62addf1cacce41a83871742488d9beafde3bc5c54bf5b0bc8aace539c3482d809549446e929bdcd51640c9cb837670cad7ad8db6206e2f3add7d1db19b3fa753a317f3f90b4a6ccab85ce2f21584661a3bf38fece1c710e2406f31a53d47152a1603ed90912f778f8be8486afe138676924b70b702457a8bddffb0fa7f42bde22ba30e111f90471d7c4e42adf5ddea8458c9db57e56384382e1d2e796b502d58483010dde3d3014ec8954878b9e14fdf022b7cfa7068723d027f49e99b93ccc1c06f7ae6b88756effe358a1edffb45dd8392a88124f57d663dee8fca9d3bbcbca4ac46e5b01277068bbbc684f0b9d5fdd9287dc0b7ea13e9d656bd5fee06430f2bdf7bd785e8fc3b38128b8d351b636a7a8e4200fde08eacb70c8f275d2448c2bdbdccdcf242cb5ee453b1b6b350111367b17cdab84e4558c05d8b30a224a4d84131d5c6aecf5f708bd1a3d6b540a8bdab07449a77d11fb26d8ea990efc39fae3553e1a0ef6f88cc850b8f4a0548bbb8d60333a9bd0907dc0c82d2ec36f7f2e3bd33aa1efd7f6a4e8027d28773544fb4526eb850bfca51ccdb40ed6cfb54657761b695ef1c0920034d8a0ad667a37413141c14e7871b4e7e791fe8fbe7353802fefe0cc41ba1e45bef8d0df87f6612cc2d5eca8ba80863b1c81190803026706f8d9e3c3e5f619154f8d36c551ed5a1d7a1d2fb5785c981e2ca736167f262c945078b0cefb793d5a1e7fe9b601ad8a5a1e124426c137a8b13752e6327d3172288d88cf11210e04d899c88bb98a04cd8023edc11c14eb0f717d80aa70cee12530b636de62c6df572bb997ea33ae5f206fdcaf058c8b5742136628b9348e512ee9b2c8403af4c9e9c23b23ea32816bd16652c63959d05d45709f80586942a57e3f085a5683d0fd91ceed688658ab8a2471589f390012be15c97fa13f92561b7a07b83d2053701c6fa25c54306d267879ea5c6ba9fb6c7a57268862bfe7ac987f873e3ef0efac0da1b1cd4b935fdeb6b1d6251aac99641e5fcd2f6c446da079eac79373115127b2f9d90517a3e4156c317c459b11bcbcfc71fcb4462f15b43a9a1c5719416b196b2598307e7a6abb7fe45020d4fda762d596ec6e0d59aa554dff5f7b85810cb87a6d2bd71a91dfb4585d12d60f16a252ff7a2a6c41d90b89891172f97743aca1c91a2d98ef9b0aec112cae916c8c56efae0159a0c61906a4ef1a6bc9cd81ba4a5b58f86dd0f8f05767f9e75c7c6e34055949b97dfece3b57d86b636d09b027027d9286d9508427f71e450b05f886ac9f97119bbe74ab302e59b4db7048e57aab2354eaead6e5546df723742982a41f639a143fca40f023d40a1725fd47542fbe53442388bbf373b80f2bc5c72e334ed32520eba4899955c3b9703685cb2d54ff4788a9a3522c1d5a1f115b1075c34544e20f26098cd02fb7be6e191d2183ae5fe27e881ce47cbad06e3fc6a488a3b70a10d099c354d584ded0d81c5ac223f0036006e187d3113e78381bf71c01e26c82a53f0344b526460689ed549457b852840fa116b7743eac85d00e393909d2200139b2b2588a7cb745b27c72e8a2b443395c7b9dbbb153b4a39dcf9bf93f30ced1cf341fde01ad662726d6a8870e038a74b6dfbd501afd2df622b263c2fa319859cbf78ca793dd663770ba9dc97e926c76dc3ae94cfc668657bb9e6ea5dc487faf89dbd9e7a8b9ff4866b1234a39b1f6ca62485d0d4556b35349335d38830c00272569f4b9d02577732bdcedfc6c7628d3c7f63ab88b3bc955b4535a8ce676c35e76f200e9a32f1541da934ed7d3533c5bc18e44fe6c2245e68f2d73ff9bc558e6cabf3efbf661d913aa77178bb64106993587b1e4c5324e976755d8f1538f24948be9a6b6a69453a3776cbe90933d9268861866599c9751209cc2512cca79725ff1d18ad4dea00133fe0ad79a06d92bedf6c245742115e08de72a15d29bbcabb7d0cfc5881d5fa3ffa3f82334a97e533ccc6575a2c100799e48557e34dc4eb09ce0030e05864d5175c933a70affde1e57a55696650311dc0cdd4facafef8db26a49222a5f974c5f847de91bc9b9fbbf62889d8252269501c3c40fc7d71fa8329b4bd2a05af3832b6f9b12e5aad6c9f12e727926b68d921257dafd2d190cc88f5006c4f233da7830270f82c38ac60289d4418995be66ec1d7b79006bedb99f3fd571a6333bdaa55509012998359a04361a4bb3157d7fd280ada0a1cd6dab7f0d789e1713f1d9580887a96dc9e1b33b2c08bb95ec004562cbe7d82733be189a3cbc982fa8192ad683bbd9b198d30d9a38b232b913ff16f69a00c203ed81ff465b125e17973ca479dd71af6290fbc8fdb2056dde134c9b357ac0416c38f15339d54d9f162543a7abda8f11f74e5c605ebc73b962c072eb7051a63dbe007a83e9ae71b791a4802b306d3e3d235e7bec3c21d808e53024fc05eeceb36db091827b3588193f99d0e46be90a08c5839bb8ef8e291144c0cbb7605113ccc8d2734dbb9f3156f73511b46cd17d833cc37a22fe1e032c0938d0ef5ef6ebbeeb1e125996c149df1ccc017d701390b3e33e2f242a3deb3b612ff74edc64d4cca57e837d3427a37953de97ee513cd231308deff9a2c212c033c60142b3d8c9481fdb80b5b417975532b16319a9b2894a4d849befdec2250d801764b138a92a2a9145a587bb3fff0a554223b9f7ec1ed0b44f5ba0c43e068f88280a3c41a9be3f0cc37ee44c4723e96ea94e350d6556e4875b765ae2c16977f6fae966758f59e89fcfbb5018657452426cebcd07738bd0e8f522b49324edb7cbc56cb26ea9e11e45518cffc086f9b1e6174f5e55cd921fd3406617b39d980f2f436c26756835de0bfc4f7ae31890940416f435890c159babf9c6a89236486a15304c4fa6440ebbe6c748e49f0e897aacab6915eb2da6d3542c746fa0a2b80e7453ec50ba834573b6d9de5495903a6f92eebb82b05fd5b81a76bae8c8a3797e453038e6663192ec8af94bd27f68057f5235972ac75363a4ff1768ddb46f702ac41f1ef7ab93455d7d743eff61324548fb063b7ada64607f5f1193ea0512b6b031d0d5287900cb98485033d6097a2fdf8b3dfbf635f8ac49d5f126c563d636f3c8d6e793e56a76c8cc1617af9591dbb8496d80d541f593a7a17949b8dc90444c69e2ef0b1dca737253d8154c1484a769702ec8566e2236eafba6f9691b856960aefdbb995423571fbd4cfb49bdfc99d9a430627ee4ca90027781c92a992deac7cc891dd66ac7b2bfc04fa1cab50c02e468f6783248fdbea7a0cd5bf2fd7eddf175ff1ab50250ba6b49abed532732ee325a58a560c1ff18d48ea526db014602f746d5eb69cb6baf66c2cb1236f8055b44943d31d6755c987a4105773e4cd859d7fc8fede4f4adff681b0e197434d3189253681ef98a79c2fdfcbeba7ae789b24a224cc35721bf87f8b4d241dc7fa6105fa5c1974cb6e289377ace1ae346b19e2cb609aea9259a5d7819fb44cd1d124dda69edbc599484c93a233b2d06de8333f428017ff97c91b83e050ed6013146a32fe90011ce142f9f2240a9eec6794a9489a7b9b22e2d90fa9765c6c97096ba32616a70846f9f4e90ee96db879a7fa90925b3a9eab7560335e59118627ac439735ee293a7e479f8fa257b9c86b35042137630e7f61963b6fcb1e22c73ad3bf46239701ccf4dca743274da29bab0d883b57f8b1612cf37399313e6300fea3d3718865a8d294556e02ee71614139c1b5705d34aa0841e2efdfd804f9fe866b530b51c51bea98eaa5081c630adea78377a33804b74f22658997f5dbcf43617364828c07c4447e75536f44cdd15dd05e098997bdd9f02dc503abe372c181da027bfbdbfeec90992fce2d6da38d25205661c28018eced44331b916af40d03e8b56a1556e8d894d8c0978049463e4ee06588734bf1d7cedc9a00b9bf957744efbdbc15174041e4a25d0067e301981f92f9e8b05043b58ed8a4b68ea502410e2c2cec2501f1719e7cd7a4f5a1711119dbda05f8813210190851fa7e265fb48f057bdc943fc6e352c0728afeccbcd0fc5338b8f4e4537c934690ba2f7a32a3bc5b05c16161408eb7fb0b8586bd19bbe9356cad4a40038665c52785c21d8d233cf49e1ae0467054cbe6856e9db1e8f81505809d4580b1327f74c1fbabe57778a8368eb83aa4cdcded6b263482378c0414239b05c110912156d17925829650aac5a41bc81548937e31651bff9d2b34761c295c59becd66fa2bc900f4e0a725f23cbb90b16f3b1e5bdfc7f67211d9672ba90a6aecc906a4814896ee13d2e33e5533db5fc72e89f6c7f98d336639d9b0bd9a536335a8aa8c9840de384cfc4d1adfec0b40af5eee704281ad91c2cb8dba3f4fa7aa2925bb3ce58ea695e5c6ee6b0c199cfd8fead20b8aaac0d7fc3c4736d4a2bd85f2d9ce9abc2de63b82ffc6d0639c5a7b127ac8265ce3c81510757d9773587dd2061832d36694cfac77d444f79f4b46b3193e7ea941888e165e64309b9d79337ac0cea76f4c3c879cbaa41f9eca073a38946812c9ee0dd5b8ee0c5350e49a293fe8509973f6b251e241c7cd91fefef504c2fc96448f29f8edeeaf8167672173b34975772ae3740832bc1abdb3e5dab4277fa85af2c539a4142f887bad3e84fc69a097fc4ba874a5d97a965124182fdf82ac1230809b0464beaed458ba46c9cd03615742905729346ef385f70d4e419d07b8acce4a05920f6259c8744bd9c76df88dc28190dfe50750d11c23754b80977e64cd754688e1ac364f6af88fc607b13f9bcb7ccd6971a32f4f8d32ad463921b705e1209e42e758f8f85e0a3df584493c97e704dcee7921c9fb2d89cd3f2e0289203a879d1f1c23aae8b5dc82c80179a0ae144cdcbda4ccbd7c7a549520f12eddbfa38d7d97b97fb4c7d5abccba57b9c8ef9d65a010ca1dddaa3954c67c9ac2b35149c1dc2814380552ca4e47884840d06dfba91abde23565a88ba98b95417a187e5b9e9387826fba392547bc2a1b529f22837005e47e544bb0a02de08cde10e4664f21188ce3fe95fe51278a88cb5456ec6ff5a62d296a026a7356c01f5370774946e3339e31fcb4fac54cc23f6f6bdd0f5c09d4235187828639c4b4fe30787726e782e60efcae30b201da26c210ae55a8dbfe1706369a20ead5edf58fdea63b229455686b0eaac7de3a98385ace765921999d0f40846794c0e18446d936acc2294f01dd2208e946e7e099c1638911eeb594bbd186ecddfe994660251f1c1cbd4f083475ff2238ed30a3e2dcdb1344b36de51647b0ed1b9a6d911ff8845ad119a6b3f9918cd1d0110c290b77900ddf51a43fde2d6c097329e6e4ac5c90a21329298423aad1bcd9bf4d76d93c618d30bb80db82bcb0b8f75f3364e41ae105f20486d900ac20240dcde2ad8b8effd2563e724d77631240f5e23d8da3a7b868ceaf55ff5b6782fea29ad985bc394e70dc580af8197a66efd0459d88a8461f906ae7850f6f11233f3eaf1d92a9c15ec6b1bf9f4c12c1e5ecffbcf428dba3f1d3682610db779268de1aa4f5a32c6dd72efe9e3e5cf993118ffeb49ea06a1e3ef3c0c9bf59e62880e727ba91ad34f5b1502f95e14348b328e528121c872c4c6e16ec4b4d9a28a1635b2831622218c7d7e01f512d048f18749939c49b60b9127d8595dd31735fa962816f0bcce976d585b489640c140de6b22cb497d9afb66cfb28eade0556aacb4fb9351e1fbd93ff9d424f4b4e6ba7511f01dd251611da282dbf42634b160d5b57726f08dd40dc5b0f91040463d1e9e9cb49763ee318f8d793e12602691c3e9f8b7e04d43f331909f465f923a3ef59d3c5b8ef8f9d13f38cc804d2c7212c71fd3d9cb75680a87374c1379e5e121b4cf85a83b45020ce66b252767344eb221381c9bc2ae904b2e3c062d51f81537f7e808ca07c521fcace7590327e23637788a0637af2d142a04323b1d1fd334a0dd21dd28249154f77d15308bfbc38c43324348877f7cedbaf7f427cd1346c71a7275ffb5a9537da519aa6d8f62b48413d641acf5ea897871ac7d948c03fd40b926ccfe1c45e628fff19f726169bcdf0791d283861380f9723957f95024f7c89747873ac20e63379a6c66e93af5a3cc2c673410b266728b7fe19b20be234419719ccb9d1096a11cb65161775db31d5cae3e365118066909a52e4abf20bb213e19c3b55ace3725989aea7975aa759cce21d203aaa00a92861954efe663468e6299a097f0133c9befc10d5795b8f3ba86bec43e40e10680248bda2478f4fb56acf7ed0aa3db15d6656d46489a4754ea5503c0c937e4b52444c9cd2045ecb3da1b3c528db1ec7ea1bd034ea4061143c1e1fa741585d98af19efdefaf25f546d4312b6cd76d6162c4ce652dbf1ed88567887696ebd488c8bf2e0c0493ec397769595f26ec79ba42a58d0901857a7fbe1a27ccc3b1baf63cb798a67448f7a69807048590787664a4bb3ba8550bb8483b9bd1f3c2fd9ee4cdc796762f3839908043fbc5f8e7ec029cb52777275093e9fc0b577d2586ff6a6b22c89380fff40b4f5d029e716602548249dda490905ffe384e6824903c2196b15fb04bde311f9e742cab76ea3f9addc527d9e61627f45881c23ad61d6431039cdce10716d6567f3a0f5215372ede475e95ad4bc35c4e06abcebe786bc7f4c9a80b529a9119371e4701863a240860d8037f4f0a6946e102d11e7e4b0821982da73b6512cc6b3aaefeeef65882f690399c02450b8856700d5d89cfa8ab6d088affe4b9a6dc229dea432f8c2f109089bee989499b1d6591c611a7d11d868b5bae63ea4a59b91da59307554fdde16697ae27936b7162ffc3cce12f52ff23f2ae34d934d08af06f4084e9282afe39268f801cb5cb72ed37ae86ca2daea1d0f91ea11df55ae586dab673d27c88636bfbf6c10e33e9922db762daf38b72934dd6b69b2719b2f2d9cbef6d78636baebc506e16d988fadf0726fa35e38d41548cda5c6f29316d2bbe09db001420f54f434029b716108d87a6b72ddc357710a52e447bac563c0ea7e2f158333d4db39b9440bf98d7363ee360f9858fb501b647e5a05bed831968f422f57e01ce64d2478e293ec6285b8a086c5401d833935398e62ea35aad1753b9189ea14338034aea9d84713b9433a46c25653449abdd1c3963690996d4d04c2978ba06d8fbab83b86e5eb2f92d9659e4115436ce17139ae5d4fc76ee06e092103093798bd610bd6628550226474cb8a8f468392390b034a4f62e9e20748dafe08face2613592d2ea853fcd8898fc09e01e3ad68ab4ea515395457839f89ba6ec6f5616833e5b2114d31dec048985b52bc0936ec1b19ebcdc1963f2613aeaaa93d4d0c91fdb99a42d5cefc2f9d15af24a384ccf3593ba7f60db55057a6b9141f766314298f815b7e0bbc32c4f7e44f92011bf519fe4eda97b2de76182a3744aea546abdb0a502c4f0a8e08bdf1efa4ba7f3b425edcbbe47c9d05f617a2e5d52598d138922874e30b8de9aa8ce25a12cf589eb6eac51ed9ae2841255b7f4ce622e8fbd8158504c77ed4821d534346ab6526a83c87c499fadba6b113b8b41dc7c4e608a085a4b0355ec30b08648776cce99711a6d04e2ad93c87c3c5cd99fcee02be5b11801b31804a3522b628860f9df4272dc4add862029c6cc053731bcd5a35e5600fb5862a002f83c51de0cb4a7b554b91b5b95e22f630a49fc026e31c14d4d2e3435913250bf762430812fa9f04def59cd71f38aa0b1aa38216625e93d8792d9d9716a8c44ddcbb816ebd60d45bad2d3c144f55d02ae66590286aa7815c3977b52ab53bcbe95d0fb6c16752d232022836869aef609ee263d4e02909d8b62cb2eb425b75c9e22a701de9b84bd84c690fd2b4a31c27dae8f8eea7a95adca40fc6d7296d87dae32eabc84122df158294a8d01316ed037537883892608de9d003c5a855abadb51d946869299122e081b60315799b503a129431fc3287a234adc090790b9db49f924eb83d8b8e9fc19e8053e3cc0cf58d6fac3c57667b6e64e29478effdb1b7283c65a97159b119a5a58f76eddf5fb1d4c660da5e304301db551cf5a3d429604887a3b60ea8a8a832a052b3099819f86329be11105c19820caebabc09173bf81e84443a90866f931d8a6967ebfe6e2f1dd968da5658a82e38b52dcd3c1e6719c8fcdab466aaf48005aad69abae9d2b12f94111722ef1e03365988e8cbca6594801f97e5aa92b111a3deb52559abb0017ce4fb14e5a4c3bee5518f0250d183b2da36aad940de5804ffef9236421a7e5a239955c1caf026e44989e5c7159935f4f3712be167376d77b82930da40fec1b7bf549a75dc3c42745c892da256069a4b176a702254a602d0e6d2f828116b4fc5cf7ae749d9fc5837b8df50847e258a6ba1351d5f3ab21ccd1cb88e4fdc09323b7518a81bf4f882d9cde0194e179c1a287d1b3e7ce47c1b9db764517779d6bbba945ce9df6cce016a221712bc237df6d757c8c3d66baf04d7b3d196e56c478e68977aaf3d5a9ddacc2e9a6e1573a82143358743b6a3a5dfcb1e69abb93912e14684150b9cbff466b2d05470a1f20c87a724bd304b406d908c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
