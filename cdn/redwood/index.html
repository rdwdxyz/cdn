<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3271e87e1faef90fd441fd4260fff060f7d6c3bbb42c525cf830b4599c571d7588d2766327149a846cc0354d46e0ee823902f3271e90305fd9b49396e62229ab1d26946b2364554f1982558684332071fb4bebb9cc4890562c9555cbece104460d8616b3ecad39399ef85085f2f9211da594c27f420ed410e908b7f0492ce796f5b37cf0f4465ee4544ecc6f120be2e9ad89c7faa8a185c063a03d04a02d448bbb91fdb499af34ef7d78182760d7d358a6a6b03725d193ccddbf183744fdb7c054360ea7d3c7ecd17a29dcf583b3f901f6bf12a0bc8fc6cfb55c277e1efa241cf61fdfd93d60aa788ce6d775322e3e76cd4260deb9237639ce6ad13c475e3e4963aa4f3dc5424701befe1b681d290460dbed4982e5073dd2b8a580a3d1e06b9a6c3c689487a7f08c60c8543485a720ac073e821d872e2df3bcd86aa75680935f8b15041a5c2ab40d1fd9d5bc0f34c7ce0963d3dd4b38390fca03fd33e7e249eef3fac1cee53f7669f4b8327a9c0c93860d383cee3d740db3852c49c1db2060e9ed6b27855287109b69c3204f0a2166639545ed76065bf9deed01c4f586e50d83389c686750c5bf67b99f66511c4767e5b6a9140c2d76953b7d606b6c9c8faa4574471046ba9317fa27b762475ba473f12b81a6c1749ba090751b6b37a03584f0761eb78cd34fee13fb0c9fda8fa46904b3774df3ec2827c17cd654db7629ac1e6807f20d912ab6c21da1bd81be0a27c505e724d42715746a6fd7b321ad4ff15654870acd3cf1e5e42a6999b5ed9172d018c78738212ea277a1598a31aaedd4d82a515dc4a66d593e570d9841fccf952e5275b3f92b3b4781044f842e3ef7055c996b5e096a8b99cd3513021bf138307dc408d3e8fee7df615c116d4b80177e782b16b929590cbb21f0c03394a01205f86d18a37d8af3bfa17e473a5d80b355e3cf19888b38aa172fb12d2b202ec984371bc6b9c36ecf41749efeb5d6e367d029eb86d125f4a5d9fe4f86134fcebe944ba0186391c62c0c4190e2313af0caa8ec0b4a3bb94ccdffa3c78a6fe40e57bea55bc2d43ddfc10ea8f7bfea1efaf38e4239c7f428a5119057b00ff83ddae7e05679fbd904ea317d8b1bb11c1132b81929a4934151fd824cb5c475127ded263f7d0cddb74bdb6ffd2767fb112020d0aa1b04bb1fe8ee365f1793dc154955cae8be97819003a1e0dbd0fe54dc7b3c825bd7aa1ae3bc68356a1e653a457503664ec5144f4b93a2d51feeb027b72f70aa8ec219c6ce30289f2d723a946e48c71643c0fde6d212c13735ab95d8dfeb99329291f0f54d642d599b9f5ea1b1132348c5c6bb4b7fb268cee8709c734fcaa722439450bf6521380efb7571c3e85c848c528dc569b75d90dcdf8ee0d75752e95935c481f4f428a56ecf3aef54afbda3d6163629dbe68c48c5a43c437af308dceac1282c40e420c1e8491bab1cbd542c1106f7a2c2d9587e5267c2bfb6a0584d6f2238593b31ced493a23a0bca8fd93cf4b168572d94038b59ce333e87bdd980e5bd8eaa2e510ca003f2cb5cfad691a5a3065ccdde60df1c30a28fcb10818e56ac24bbb5fc10b8ddddb4e877bb2fc20b5a59f992dfbaaf0d8ab5e802ce7f83c9becf81a204787008ed9217080d15cd693cb086c35875416d33a9f45301692c1a99e9be78d56f8afa961109a43596d9e88bb1afca57f47d51502ed56c9de4c4c1d80216c9a947d1e78627128e546e26ba5fbfb400a3cde56dd74876b5afae83ffac70a80befb87dec2b0f17aa30a2511008972e4c1d19d41ae690c3990ef812f84da014e3062b79698c2c9b1ea0d3287a048c62fd86c06e1be94f1f74d391115094331e8a09219e2066474920946a669f6d8a3137d7f4482eadcb950259a5dffc68d1567161fdbd1fd184ba6e277f8950c2035099bb2eb1b5e774de65227c669519a70e433af81ec259a9b2cda22af087f15ab53f222951eafd5c65ff9817c547695bef1cc741233b04f5fbb42224757c9ec093480a478f10db46f73e9507dec24ef1f16fa86bc9b92c788f52b0b5727b4082e01efb1874e7bdf12e74b3966d218e04c3cbbe8c7aac249bca8143d68a45a13eb594faa888db308ab6e8af24b812b9b3f079c20a54950d60decbe5fd84f1a326acc1660db03d5a094f7d36d75f36293d677450721ca14e47d77fc651b850130ed248bbeb19437bdadc7cf409765ced9a802999769a75dd7f3d2908085be9f58e6c82bab33338310b59f6995b66d4edbe90679ec73dca9a31749813891dfdd03a3bc701e420232d2dcb49217b6c388e6bcb342a4309ec83747e1d1e29e0da840655d64b55b65252d67e2e421e27ac438162ffa33dc3d94f4894b63406d49ef4c3c05a028d08a565264c217c3b9244dea28bf9e1e55a563df41b51532479690126eee5973e25183ad8ec5ec277f2e450ee01c106eed86f02eba6fe71fd2c61544f5e33e106172eed95b21c155e67636604a405f3c70f454ae34f08f43bfb0f1e00a92223603210e718269846a40a30acd5cba520ed53274d434f9cef851dbaf3125f486f2c3973116bd17a32b259dcb3a7fa25b6cac90919212614d601312dbd8964ffe10e87b2e674aecd388f832112f45ea83ade947ba747895d077a8d845fc0c60fd63aa15231728449b0f97498184b2e9114b7fc169be7689b61bc3353602e462b084c6baf3bf062d0b88280931beee3e0e234ba5c05c7c9a81c2bf65db24d323bd90de1372d19e6be72c28126b1288e347b4d1f06ade1e8cc7b30955792ec69337d5c8f82473ccf4f0d8ebf976f1d667828b96297c40ec6a5661e8bd92b5c428cac700dfe93368938b42e3992cd159e4bb3596b22003ba86255d0c76bae5363a5a2c65d72eec077a9d5176eead66e27f9be89a2365addaccc4c3ed40068c71185920019a840578f31bbbebcd0171e59d8d63a2cfc0f7c9cde6a79b0ca109ad611424a6409a53e0bd6f12e6e428b3b00f96779e5dddd8fbc304705dc639350ae0e7df314973454737dfb91a7de085e9aba3d8ff3d6eec0ccf1e14d60fbd2a17fc04fc382e494d77e0e87c121cd0bad7fae85215617d905cb6a117dbbcb0dcb53bf3a97cc180a4e3ea8363a580d624699d114a2071ea8f04e6e013201dc76b59f9db669529bc0d4a780041aa6c7e4570084fdd8f9a204ddf95c0f7891bd41f301b76ba5b51641f09c38cd5c49b0c9f72d0b9465c9f4d740dc1d04702aeaaff0097b11952e2b3852e93d05c9ee1fd4a557d1b3f395203636ce6de680eae35d623cf03d6a7b69136772007ecfccee017c1634c6deb104ddc5c4561326bb64b28c3fc1765ee3d849ee9971681063b0133c71a34adc53f2e85fe8ad73ade0a4c268332479836cae2f2e3f087690d4718663072cc2dd2ed7279dbed9652ba4b81bfce04b5bb0d37e5a80a22d78b0b1acdee951a1349122d896aa3785d096cac94268c58d0c276a26ae6949cf2bfbc8e2d0f8fb43b2f82634ac4a2e0ebfec94effc35e1869377843f2fa71a6d4d9045f21ea2fe9c08d9fd5d6e01adaadfb25a7f2568aeb0058c55f6340a2c55a6faf1edcd5f69068a9fa142827470c332c3ec81c140ef95365eafea10350f5b07d5a9342cb253d597db112f94a5cf141bbc5416cbd5c41e148af986315e998fd9e22ce2b7018c66e0965a9e0fed14c717426102f06e3881a850eca33bc2cf2029f000434ec0d6a9f95e0f5363f68af5c1327b4902f00ab2e96b5cf9a740c9b48cbaf879f1c365636f58559bfc276566218d9cd31a903408ae1664a168b471c54b6b39c2941e950b9ad11c96a98f5640f63b126d0596e76501f4682e20255222fa535fd4dda51aca98b65cc4e1ffe83d32c3576f289ee4ec733d130d86bf11d2bb128b0d6198353c87492d876752f0d9daba5e506f6bc0b4c74ce8422d4c209258888a468ebfa60cd2f1b832affef20d762b74bf138888f2e0e1f5bd49e81a51c5251abb7833938ca398ef9403306388cea1da06457d1c9eb53171713950c28bb532c58fcefd2b30d853b980af470131f4667aef17b152d23e3319877e4f2dee813a09dabd2af50f2031691c72deeef105c256746ed6e4f1144c20b99ae001e0cbfefc446f1ee4b35d0e553026522a4669a0a6973c89aec3b151bf4b6bd42f41911ca6c3eac6034c8254b1648cefc4d7b076a54bc5364d3b4e348e152205091eca7c27a8a0031f30c58079cfb7abbf335805f52c5fac189a5f8b7402478a03ddf7e6fe84c0e328556cd1d2c0d8754976dcd80bd37cc8d0b048e987e290d3398c1138a3c34954df2958dfdd57eb58056f1adcbdd5acb83b28c45a5d1041424871fc9c37c8215fd6450e6db14c412322b73f329adc64dafff5ad5104b1fe9ef154a42517403542506029e13b77ce34d2d5be002c37f0c9a0ac16c6a2f7eed2a127813f2e411ea91de79f6475338b8ab5cc7f8bc90214db9ff43a8c70a0e668c55b8bf0273097535e72d5f4c60d99b41a3c7d0cdfef372e2f1fe1272c2fa1dc00e01bb9229d01eb2272afebdfab7158aeadbd10190c9d9fc27020ad676a71b674f331ad5669f87b1ac8e31deca87376073beea7d1d7f71b97ab047080977d9083ba2d177965c22fa16a7a26d3056196d5ebbde1f76be46c732dc9b134ccdaed028d72c421eba88c3cad4ca7f4eaeb96a026c53b923b0e594b1cdf3dc260bdf5d1bcd0d4f078e9721cfb0699296c685af6886f5ed1b84acfd830717cff033c189237fc6183044e4ebb0307165136aa7e7a7b9c4b8307231fd3ee49ebb5acbad720d20ae302efccfd2bc17dc63fcae62db5d0d338a867b96d2a4e85bed278b235efa6b5737b15e4ff031d454e6e91e696a23dde0fe39d0a3912dfd51a60c80b5712a0134b29a460428f87a517967bf8e732767c7b0292cc33e1f7ec649de222f56b9ddd7d75fa160cd0e787a1b3cae23fcf17dbc09d382fa0eff4792f8b1886cdb9549437c759f6e3530e9a9fabbbb7b6dca3d119decadf0f933656719a1f35e481afa1d26343efdc6ff0c893e70053338a6b50eb8623ac386a24e2cee739dd3a1fee7cdc8384efe7632e6da13d280886a6862c98334a69cc12a2c1ad7d3ee76e17e52c0abfda49841ab462c43d8cc1e1c365c8ea89435a9935aace8372adcf754091deaaacadd60a25c2f2ee4faf835faf618ecc3166f781582365461a9a5fb0f831311a280fab92a62fe7043621d1d70b48a05ca4a549acd2c302120f84dc528904dba98723c8fee27467f4f6968054738735829257a5b69f531d4fcb78917c5d3bba044cf6fe99c2aa7a2ca95935af561e4fe682762d57faea832258b4a5f4c15920272818dc5d93c81c1a8825de5facaac42151ac19352b544ce25cc98e8a9725756b083b36860cce67f2dc9f1dc1d0bf8b71204a8c6bfba42fc16c2923d92b58bdb6a490e7690e3248a870ace319f6970e0335c6d591a576ce90fbcfdcf300fe09a9625f1afb1aa410618627cd8c58a3f3423927718b9aba498883a78d97cd6fee403978398d24b01fce365426439c670fdac8b7ccdbb5713aaeb7ae769554367bcef09e0437084d0a05c478b41511c885a4b66678cbf8988e3e2dd0cd6fd3499d79f5c7b1709db39d339306f5de260d50eb0b4a48008ee1f96204152cfd03217ca5f36b9ee5ff61bea0ff605da6ce4751f3aac5bb02dc4e1e2c3c5d318241ad6ee28ece0b427e551fe9f8f0baeb5232f2343fe4c2517fd6c79dc44edc818bdc65a85e5a975f3f08647e8b60e9cdc8308b173248741301a7e09dca318e9e627a5d94af25efa64acb567377e599f91b992c78df50a17456d6265fd9411702d714edf16fce8c6144d7c102b4093651e4bc0df0ad76ec49217e6c2088746fa99f845df91f2874e8fc5bda1bca93daad4fbbb5be9c150d7a78eaed1c8d65b35669e15c341e0fa031102bff8b9b87dd03d13c5ee83056debdb7a95526088d0a6ff5c2f0578e327980da5da0eba7e682a24360d4c2a32fe259a6b1d6344d8b0dd7c87f884862f003a48dd3b6ab27b48dfb62b922a2c6b57ce62b6c81d8932c9ab4c6314d1fec3f0550c663b89610d01b5f61d875d2fc4d94e7898bbf6f91996e59e579a7183ac55bd933611c0bcbcba246006d9f2037bcda89c170eb3844fb5757798a29908d347dd177ff0a79cbbd421fce2348c84e618fa4d44a10f7a2fd55f2fc969b644a23b47a180ba837e6a9cb3398cb0e2ae97cdb466957c971ead8cf4a6c555723a07b9e2767941733c658131dd70b8c867ddc77b7d90ac8266a2defa9178ee2377a2e2a45d2166592515725d05f9eb67fd7a730f962987421865a1e3dca8a0ec93fe7d5d56c3c6c89326ea4574d9c643cf9e580754a59bc9dc1e2e8fa42a8ee5e7386c2caf6b378533f733f86a00e7119d2494d55f1ca5ea44a04530c980928ee2054f639e61c140fba6c7a359ed133506dc6e8831b205d7ff1191702736cf981f6f0684adbe8fbf813d225d5d4c7b28ceae5416216e6ba8b163204aeb44843d820cac7b296518c5d65cd73681ad7346b6fbe496a008538dd0d92db9cdcc0c20bcea924551a0b44c8b1fac33f7f94d1b3ba1ae470ece4600362081483e9a7283df5ef6ff61b5dd4eaa514d7609b3da3581f0714fab83c082b549025bca1f4108c3cf4650dff07aa069424c7334c7d1b98b22463275cebf440abbcb35ee7cdf63c684132feb8c9e81e31bfc303c8bf821070f685c3f5b9df05724053044501ce1dc1205efdf80aa3c6975c0efb4cc9c03925d0f8ccda3bd05af52992ab9cdc036f868989b4b1ed08e1af14b60a9b75a4376ef5bccedb70f3af84bbbaaa9466199dad99ec2012a147f71d586ba82249ccd922993c95b641ffdca903afea2ac621b762218b05ad6264a58d57bb7bb01ad71a8bb2b4f9a9644b7f3ddf6924c0f6e7a354b0e3ee74538780308ef6a69aedcc07eb4093d0c223813d8dd6da0db4875b9e446c23e080b8662ca340fc2cf0e4ca1432d9add209e799cb68bccaa29e139472ba70306b6ffeaa53490e24ca58f6af5f042cdcf9a59f6572a4fbdcba346276dc8ef13ceee78441570472ad84275d1b89e5c7d4a9a93034e0243a984895e552384e5c3b635428358b3c975612439369ecfc422589c641f2b69b477596b407b167d97c25cabfde88b867874f32b1c42fe0c73375288dedfb4dcd2f9625847a46b30956e0702af15ada7ec51122187ed631f6052a413fcbcc56b4c18a539a9e1c4839752401e818c837a04544552ee57f0eb303b4b6f01fbb5481b37a7ef13512edb1f0380c25b672f4a2483914464655d407ab9cbfeac7f3e718680cf2ad7f82f192fe0bdd74a17f1cc344a6fb53ba568c92a48b2082d0279dcfa074bd29958f8c22188df295e9deac1462a9ef3badd0632943d9a513b05099ee2a6ca3ae81167be1d23d75561d2e442c3c07961148ab4b04c86d6eafd854c7c4f88dbe3924003751684ff02f9b81c7b62b04054f69fd76e18d8ab7c43f0a4014e4839cf5a5d544f0c3855fe11015ea28e76de50c9dbe7dc517e5ad201ca18054e1f9e76bd431123c531dad2106ca0e8f8b00a68fc208c8240adcd1a2c8cd809923785313ea74688f4a3e161f2f05b965d383f86be25314c6b7e8c10204843b14339264929ab550e7468fad21b700eb7259924d6985f1edde1cc9e062a7c64de3b28a177de9e59a306669374d692bfe089432105215258bea1dda20a0d2dc4fee6883d71cbbfb81bf89a7e92cf1a4b77062a869dcd582f6f045ae7e657eb6b6eb8ddba7eb6b683b01d67b0ac17d8e87a5676c898a30011d254539d9aad9dfa1ba9b2be9c3c6848ba016a247eaaefe9c2da63a09cf4e79e53cb15cf30fc726d984d5a153fa4ba4a470d5af445a5b79033bd9735a60c837dce4ee7c7c058578e0fb173a1cdde3e4194ca78195b201869f767333f2124ec396b88e9d4ae9e01285737baef3b9855eb8d1cdcbae0ae96ade256f533954fb6c7ca5b2a8a0c5fef0e0b531a6f0da3aa217555c9f8120263cbdeedd47008c4a0821dbba3645421c7f805a6aeb333e0de83fad786895a2b153d7cad73c72c147591c8956c261bba8fe2b96f5d41c1ed9772613b61ec4c9dbe6abe357744859abc847befaca0fb9f025e5b487946900f3b6d64df30a7e6465fc495e126357bee5f34c8529c23c94b359ef621cadced7849b97126f852a5fab9c60a384756f0a8651f48bf78eed15ee60c2e61f7578ffbc90c8aabdeca2bea728215d225da7bac65e8cddb3271c158ee431e115c76c40089edafbfe3b68932bba21542837d952b0c2da74ea615f10f17993f24c9d460497b5c90735f164935c38fda79086f416cd1158026fff81626957c592ed4271ae6003728a0ade6d35873064820f1290116ce1dcd80d963d2a7a701ff569d4f26be1302b14c946de8a519e2785a397de40c4c54567a7e3631b5e6d8c62c6d440b8769e2edda1ce42fac09c3e4e61c1f9f1e2f32115c26d8b353689699f329c36d4a2e87567731ddab9262f0c56062681e105f9484fd3b6ee4ccce93b15b1bc20c5aff730d5421ca027cb6fe6366141eff874154c04eda84b9f64af8010962dbdee3c6aea209d753fb675fa7a40ba2b8bf117235ed4d42d9b63b1f7795e26eec7465686398fc71bf7b7600ca7ff5d444ab5c8147c0973032cb3802747c17c851d69e0d8e9db0b597bd34e3ee81bc4a1c23788190a8faaaad80994e2684e7c922d189200a71f0e77cc93d750d549d4a1ef9033e5d3b5a5fec9fae143b5b73929d119fd528a66577320923ca1f6af2e0916fdd83143c8515f5c05cdbe2a580950a20c36f210d0056094bda27db144beea4a3f5e3e805809f046bb00984ed3dbc1fc6b7d280b4ff76c2ecf26fa12b5fde05b4bf810dce65242005489184f7ba4a29c0ee02ec42cbb876f24827cbfaeb2fe5119354249b1bd82388388c3b7b62b145e9cb5dcd335fdc02d5c591df9c76985faaf038325a1a8d5234965c1ab1cfb34d886abb4bc7cb0fa2df90415d581d49c4a2143a8634e9e2a2c98a6c6ca5133b4bcdb3b2777bc7cd0810faef0d5b41009f3261bd4c4836fd2b5e70ffcd34fb4f686f345c037567d651adcdbd73cd45b2e0517c821d236641cb6cc730b2ac3c617020244324a513c23fc1e4687ccb4e5eba22420ed3889f55032ce3db366642631864a6fd511aaed320dee4c102f6e6479497ed1e16cf37ee592b61d9665f8e364cf8fa5ae8d869cc727d9c335ea4df4cc50f028589d80bfd02948b90b7f31cfd38cc915af0c47929e2627221acb371b8ba2fff603f7deef5c61a7ea07fcc7f8900ee7515766148e367f55078f1762be3c9ed7185e4f6c4e0dfb66c245e6c812c35259422ad118a1684bf60e6b18a38c520fbda1d4fe50bc45eb2346aa6d6549f7e658422b99db72ab32d7f8235424efaafbcf0fa64508049eeeeafcbb03042b9e465e091ebc028c43ca72656abc79f8d51e1276a5b702e6ff1295f1f7ecc765f6957d146a7a0dea2b8596729d0c53944a059f65c4e1aed820f93c4923189fa4c9a7e1d547dbc4b31f479112883253bebb772f4f0ac3b6664a7160e0e2ba82c86d8def3010d89e50011542896ea03539c2f9484af4e542a04990125846b31e9d4c6eeb1922602169ef5359ff08c0f0dfd7b207ffd04a8573386cda6680af6359d0fc92926a7fed71d63002e231ae1a2caae36f7805558d6962156225cede77a4a31da6e066354311dcc7bbb7775f50ff09bb6cff5281b3d770828155313fd62b04d338e759ebd6bbf0912f200f6773a55c11fd46e5d358491bb5f67c11c5e7ff8715881dc010534924cca3c2669f624320223e025582206611bfa1b26cb1fc69360214c16d50bf94f24c607815a978fdffb633b6355c96b91e0f53bda7cb2c8f2312a4d57417f893eac2d9ec626f721f606d272ce8e8d6ea8820f4ae3abf50aa1130c79c172111a50aef2c6f590a4608a4e14a473fd917025afef8e069f8cbabbdea1334d8b241614e25c0d9dcab2f7c4cac0e285edbb91dbd2b9ad10f42f88a4d88e7691fe37413a85453c6825fe00827495f13f540d6f6c01aebd62d9dacfd81dfdbb1a4352a6042828b74a41a5d2fa902e7b83ed1dcf37f53a0b18955c2e1610e5d3d8b5594aeff7d326342d8aa31e5bb72474ca98b2bcaa6da24d6c9b582c0e3ea6756028ce54d6bf131a153ba0bf5f9de00588122c9c71bb03e3a15ae8ba86df88e61aea99aef2318971128b77488b0e2c0161a7fafc094dab26e48b70a3f57889ea99b4d4db5fc109169c8ebf0b8794481c48f8170f3ea121421afef708ff7386bb0b334abfaeb7ed2b6c00f0e70888c5918c7f9e193ab20ad3647c712ddbfa6ebf1655c29c236c641b0737e762e97e312ef72f6d7e452c56f24796552cadc82dac45a3469eee48c86ab0f7d165afdba8e6b749da0f850a63241f00daf17f21f56cdabc0843e758ce7ef9ef0001895382986d9e55748a2ef748d9be923704e312f5293148b868dbbff45973c5e1c6be145071a66b45249a3158aa17312047c752ea1ed0c841b24f67b18b6cb4ec97ee0f82794f688e92e3d4440d353b86ee22fa8adb5fdc2fc90b473d0fca301ce9d94c22ae707f46c95c53130d00503313914d52c53a5f5dc3f4080716e1f813a62163c40bd0ee01421c72862aa0c9df9ac1571863037abd25e2f6b2422910b9c1e3de5e481a531e3f591d215ab4be85ace564451c842fc1dd155812f8dfd8e5eaaf8b108c01b3b64a773d49cba83d3c7de6cd70a25dae6f25af2209d193c1387482983d12130fc6b31c9555908e41edfbf36f60f4ebcb40360804618453150519296b8c3c3699c53a77fd404acb7f6677af4da7fc703e817d7d179977fbc8f77cd6f3008cfebe7a8f63fb3054c81048ae192384db537ec81f397ed26c310d819645ba5f9566f4ccaa53075c234ebbd746669e9635a93f6394c0115ba52d6e1137af6c462ccfd3531a3c72e599ddc35ed539a973085e67373821a79e4f470655a0d1fee5dfb379725769ee1381db6532b5eb92dada18324fd26cb19a670f718da8a895e70faecf7a4992e1bdfd882bf97c6e384d0790262111f096a0b31b3f9e34e6c3a05291c685f88b66c9fd88eaa3e9dbc1fc57f32b618f8e20b6df2e9f85307432a7af79ef1b920701549ea9aa4e52f500fbd846c83f5ece239bb3a4955dfc2655257e9b06431000f4a92b7e230685c3ddf72ecb2bc7548cb751ef84fbd5a3166db40d76c47c191d1bd1a5ff00b31cb7182758045a5b8eab9165361f29716f87d77c055cbe1908ed8ef4d34e399634135278bc678311c453ffd6c05b8eea5599b3f4f43c602f02ab55274386e155eb492517afc1515c6b3baf3d9b59c7682b8057f3449c4065e2177c0a2f48285b3e07672695f96698b534f98bad3b687b0b4eada93163b44dd7da3ae2a3e3ffd2a078ca725829ccdfe671b9a21656928fffe7e61bea0c58a6536b2dd3a11c3f42eea280d989296de8c1314bec9b79e1b0927a0d1c97469e44c9459970124d65f113e4d676ecf2eb09291b1845c716cba7d05539b5933a04ae5c74c26ddf2ed9f9d658c1b80d16a2ce2141255e9f900e6120dc9763f971c3be2e96407cfde30aec68ab260f3488ae7742d36c511ff78e1e0822e20ee296b144f3c018b90ecb42716439419bf955cf3d4d44b6ee5ac4eb76134a5d77ced23c2f384cd93b74935ad5abf9056d53a179d59672eb38c1d99ce7cda53cdc70f001b2a4cc976cfcda1b95b9ac864a02ebfb22b3d4e0d42af1df08f5848cfb10ea6beabbcc4ad3733200a3895552b519078bd6e22e01efde033120cee8e6a8b7a45b216ef1e6c59e68249dd88fbb38cde8187582e9ff783aec69bb2abc7ba277a14ec76c66a987d11193a9ea6f4d542edd5c6c25fe058f83130fa27aace35f70ee16377f2e58996f90c6cf4ba7a3c66973ecc911648fc6c46964b2153e4f699ec57670a164529554409bca61071d91ae6e10cbdfc0da98fa18eb2a89add0bc58cc4ff288553c698ee0f52da0a48c5bd591be3348896cba1f8abc9917015a83eab9f29fa7e5d180bd3df381ff3fc7d0cd006d04927a8b59e9e467b267111d06d042b459b4ece17ca383aa2bd95d8eb419fec2e2c16739f7020619fee4c2f2f79d42138f9863aca9c687a9108c7c3baf59cf1b3d516bd8fc1ff93111de24f92780d7c89c3da2c166ead1862b9996165bef5bc2b6b1dae7b10d0527c1a5d6d92e6943552a12447584f2c7468db9e2e37f0e4b7243265014ee405dad6d042d45286dfba9f50d85b5d9555621467c491700d0b806d0da96a327a3db47bc7fce41c7e28abd220c78032ff061071a62a5c3f8fffb38e541a07f979fe0e27327be6c0dc87d42db9090498ea9bfca42a214da32940aadbf5aaeb6412b216e7be8179b697daf5c467696412d4513911a61ec5b725e555ee81b1bdb9282a323b65a8ff3b36a69943b8c81041dffb70b650a7b4658525bc50696b63f414c26edf0f3583b3d0d4ca2cef10ba3ab0e03d20e95d542ef51a8289cb423748d3b3e5be1c6260adae37487cd0179015834d4dd6a53720ff6a324afc6f9afd1da185303da2a9a9d6be7d73764440b3ecce2fc89ef16a04c00a6d16b7395f4df097d0ed91077e44f66ed8939f5fed5fae37ac5118aa895dacb7723fd8448ceb075175d565f75f6824a867c3d3ca5f1e955815c9644480d5ac60bf457d6cdac00bfcfef24c9ba13bec59e863244c20156dc0033e9d10dd35859880d7470a3684c377d87f84f519826358b52386709430ceda5d5b86c515ce32f23c8b41ade65afa9d9d3c4799642bed569d72e9da256ed2e6a1e25aef37ca5197132670cb591505a80aa4e21a435e0f0d92740ef7c89e247c916b6091fce83c6971aadbd7600b5c6edfa217e7e54fcc4b0003ae5861f8f73d2b2c2a50dfbb7c4bb12e64de073f670720789c298aa05ef907c3bab8a40ad614d0f6b3de8575a09f0adc0ec2783dc1be265536d164d6c13cd00e8ee582bd5d849efd3f734495e7b43f23cea8d9980e90de9da4c4959fca4579c804650dd6825cb2599a0d8b44fb78c5ef81dcadc7611844dcb275575b21c36a8ac74d4c232333fd3e6bbe290ed29aad5cf4071a8df748e1cb6da4c3c2ac12f6e629aafb18420ed97ed69b5b1769d26e50197374854f7f7ff5113efca93388d4ff2822c390e4a9fe4c5dedfaa0908848b77076b2924351a22e690581adc2d682988d33955f8c60d4685504f63468223b52300c4e0c7d5f0c1de671f6d4276852e4afcceb8c83cc24b73df8ff63f35f260d9fdad8c0c06bf91f6dbc2fcb9802718ac27896a4e37aeb3f19edbc2496fa15d5dcb1683bba673dd3bf4e8c2c1e8f5de4399f521e1d878b6936ea0feeb5f9fedf7265688c9f87083262a21ebd9589ebf2cad9cd8b6109b41f6da2725b6d9ebadf7c4f16c135edf9ceb706947118a67e2b3b87958925a2c0fda4a09cae5b4232621dba9e14862b52dd9d9670be2eed36f1c7cf70af95ec261cda180964aaef122333614293f49292d04255066f90c56aaedbfdc91cfe3fc71dad4e5f5dc7c99619af5bd45e96db65827a979e96496fd6d3b826671f3272c9f43993264280d535a6cd41614c0bc169281ae520c2b6f168067eeef0ee294ca2c6097a36ea8467bd45d498ff26bc168838714d02d557ffb19e4dc3cc34c508b0b7ec38d2718368d5e6e0c793ce5eb824e78eedad07fe053f0883f1962d0fc82b0de9cd7ec1c2fc2cc37b3de6fd415e05c25364fc69a812e8591343c24c032dfac1b726a2b69d56db4b846e228c0432bd281c11225106c41085ffd85c65b5bc15851e8cb0c2acf8baba64625f63786100ed6473e2378797f5d0110e1382f2e817b2e345e5d770ff732a9f188af577e1c72723b05ac200e30589ced79d442997f88d0c172a30254d670d16936952a508c43cf95aac0107a84e1b9d10eaa33c386ade83f397aa7c959f5480cc020c3a93c69fc39ac49dc1758829dee782096ee6ddc399f3f6aed741bd5969f10c3e2b279950dfd272db8bd8cbaa447162c307ab00de119c4fd4060d68038e650d25cbb67e6896ac83a1bbd2ed58e67d914a41a5ec63adb743c68d24a5e27ea78447e3b78070c78862b7052f5520cbbef605fb5d804d07f0e6ea574e8871a1e2d3e38f2126ece392728ed28151e930fb9ad7d7ad21a1842d826a019d36a832345deb48ca810b6054ffadb68be90d11b4e648d69a15eb7f82b0dcc0eb35dd20ac8f7f822ba37724ea16846e128a7be169f43fe4af41dc6619d020edf0ad5dce4a3c6f9e267ec29dcd47c8c19ca8176766b304fce8ca03e8022a6a95a42d90d7ca8c39465c9b70e03d345a49bd262e2af8c23fcffc03b0c8393673b17a51d628a5a9ce3e027f9b138bf45867cb54ad6f535aa5e761a19d61ef64b18af02608b636e036e2c2aaa25ee67562f68e19b4465f8014da538f5224cddc3f7607134a7dcace66fe8086f755369c9950c67daa658b5ff2905a54296ce96dc71cdea791871f88ea0abb65631d4d8b7cfe6ff55e8cd8fcf36107133efffe7dbad89271d2fcd5b5a16fa4f3ffe790990ef4a6f9519dfd5ae96b777275fcd7a57d6fdcd1f42fe80869ded5ca2768103f75e0e0d74f07caf244aa2ea25d8c10e3c37ca8fc5c4f1aab103406b81136f444a1626b630d24681d50d7a11672c0a9cb9455906508a873907c936b7decfc9d38a254011da21edc42e9a042b741b4a91a68c8c126df6fe2017e4552dacc96956a59c82e598b9544c6bff7fc1618a851f8bdfac789a4d3256402276862a891ca391d4fd0bb47cbe75701025d1472bc5bce4414619cca24ab7a96835562f8ac95f824a2169daafdca7031fe5aee1ea72b644ad09d59ae75c6d15d4b41480683ae25abc7b5f4a14982d4e9dfa46a2f63019cf880deeb049b7d3594f64792af75cb787237bdd3844da052ae49f629b25d28d9195636157b66f438e2861c59839ec2d7807470abe123d59a275ec0435ef0bb2e6ea570138c5e8f26b88ec32e8d23304b8c391d2b27ea974241c6fd3135aa595daa600347583e70e4e15c1449a31099035cbc2654b29f5846e37fe1c2abd951f56fe61cab11dd76e59661970f7034e474d3feb48483d034597fb2682a2c10317193ca538abca3015a630de6740ef4e86fe22a7f59ec4376109cc5eb19aaea5225942224534c00ade952afdef497e298c7bc6a4406e4e018279021b9a547bb6b2404fa559d7e3ffa8ceae91078ed572b933179afb00317e6e4cbdde941fc3e05b91233c226f3fde12572225f63b7d980c77b9f8c9234fe6376d0c2b63d97b5bd48f93e338fdb57fc3f52ff3026ab03bf2550c4d1de14273a85c51228b8907641735e6ec6e24572418f7fbb8df43e351863d254ac8f66a47d92dc1fc5f1b4ec77f8c286c6ef6ba3cb436d1b3add85046ebba3f5440a8cafb6ef1f990fd6949f011706495440d056aa31bb8596f0df9e5659a8abce5da78bd81b2efbf62158161f71e5ba56196ae8b1ca725be73c9e7709da1b897663fd7c7222cd2c11a8d1e6df41b58fc426ae005357d6346868934ea1c62a5fc9e2155f0696932b6d76e7ce8504b8136ae16d7eda352a031ffd6dd0f4383d369193566e51b4caba10561b764bb4482244582148f748b545af2df7cbe9a9242017e74de3beda9e232bb1dadf4c74cfd35316f43105741be8478d9f27dccdd01940b4c9934429bc5abb64e7ce5ee857307d5383cd6fce4196997f7cd075256a7c0fdccb2433d7770d33a7ad3aa2e153c784f5c66e6ff0bc524f13f7e83757d9b0ce7177c947518b818a437763c83815fafdeffe43de03e8063ed79fc508f50452d5063125892c61cf6cff09fcd502061f8cd15067c58b0d267feac6021fc590e12e5f76d592f2d617504bb45dcb610e8dec90815bf98798c496ea16267958f59a85cc79aa0fabeaf3c5d1869fd8030055098ef6f34aa021f032745919a92b49dbdc9cf49b48ecf3f6dd13244350829bdbaf65a50f860886c8921e5cfbcbd00362532f086d25cf88900f872fc18d796381a7721f695b4468bb321284ff03080325e4e98565d4b51b3d2f523fb7574f059320e405d8dc5dffa3a06dee8586f00bdfc7cb28645083339e5c16e35281c001d7553565c7c1bf792a066b13e08add7273a5bdd92cb60ae9bd2ecb9bce4a6886605389897b0f95eb1258a43b82ed2e5f373e68ca51150dacda17b8f6d763b1185ee56cd4b7e76120af469105c980bb684f3c3f81444a651da1b8e6e4033086646585ef9bb36a63d0711e9eeceb695d5eb3f8d6ebb0c0e613881be3f8df32159c4d58f9aada646d23a3e7c7eb894f4467302f1ab24a891995f364047a1835ff1a964b174bed1bfb8afd2992047dd2b2bacc6e68b652bf0a2bf66a18ba769a2950351fd345e7726e51420d07c36380603bd7079955d24d98f5d617d206f5ba4463c3af56f7cfec313bc99ff5eda22a8457d3383e7c14e59246ae754d8a51174735f22da5b313142cc9fc10b569151961b859f18bec98e6085aa7028e55c4650838f20a3c40471c81f008be3f5980a9e5f123cc8552d4b8794870d351c988fe237d4a36c41d1d6ff2075953ecdc84ef6af1438ae9d9ddd56cdce60640b4f7c5c9551ffa1741ebf1c8c6caca25d93fa0f1e74dffa1e99ee09ed0f47981fb7b5158de1ea782a7155b44d45d361ba8f7ba73cf948157198c88dd64fba8f1f638cfb674a5ec54b072cbcb9c9b7d875d9bd8ba2b2e3ce7cab6a80a9ee2c051d48c604fa28b40156cddf390ffa65ae0ba628457750803309b88b12051072f63b701ef7ac2022b8aa93c01317cc4fba363733807874877222a561e53ce1ec9fce315336a1c22b6a2a1348c5a2da24fad07f7016c2a2f6d8954e3200633c440901c0ec8afcc361084dd1cedac3f475bbef1c9f5533fe185e5771572a4377d956f0b271b0f084a091b3cf741fc20f31f0ed15d48fa44362489d63572606cbd7611b3f9f6442e30e1638270a32eccc0c1b3557a1037909086577162be609798274a73684db09667eb389c60f1b85ec9522a37a659a87b1dba110c45cf0bc7e2b416b95c3405c6d6adcd158ea5f1fe489cac1da6348d8eaf2a01ca7238163b8f524acd1278a1e0ee6fa166e8904dca99c3a2ec40cc43657272c928308bfb30cd10cf457192eeb598328e98cceee4681c71d9736f2a3393b9c9a79b10876f26f93496855335af0d4692d883690550aa31cdeacaaab5d09ef37c60014198ecb8136c1737f1eca84deda78533c83b589e8fa4ff23160ec19078cb6d8b5ac6a1e3ea992d43f9b30ced2f4a2d093c28087930f07c249ba03b09680867f7f1bb43cefab79c9f743fd0c7ec0575b39149c87dbd9c96d5e2d4b0ed0b355e7fe489b0fb0ff187b4f3f29b26bd92527f3b03a433e70b6b0992f39ddb009bbf366edbe739e9dea97e25da794057b1f2231f8af7be8c802cc75a67df0e9a37c72158ea486834cc33096aad1c6664eb71441e56276b8ea074c2fa5a4ab9f3fa7d5d605717350d588e2bad30eb21c1ac7aec32d0684dc81a7753e7e4de9927c1fa98e25d97be6a7a576cdda0cb58579cad3a0b5e15c9d1d56b71aee7cd0436793a331b69be7f5f69f88afca29a977fd159d78b79bb16a6b1394e40cb078857691cb8275568ef4b136e9af430c82bf57fc177b2c66b32b3039c53dced50c68e7b27cdf8cc25966618f595985bdf6c6300ebe0263ea39fca89131e1006a19b2b1cff49d0b7dbd8f38dae835dca792207de19be6125056c75478831a684d166f87102483a2b88e794851ebd723f26f94457e05091b7b85c736ced699f9086be3db8369080f8559cea8af9812763efa4d1167521975e1218c312776746a82c25edb9fcdba94a36cf5842af1dcba5cb51475d63149a1acade9a3b170c80d7d1179e28eff2220082f93634c67fb18b285c27f1a9812e88f825424cad8349d2ebb38c2464a60dc2d79ab63cd92a106a8ab216b4d6783931b73f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
