<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d1a506b2017a49f54bd760c3e95a3edc4a58946907078688b27776dc631e18565900e4092ca27e881817d77b54fd907bb71e44edfc11905efbaa4652971ed76040162b77645c43222817828c358f516c4b336b430252f9801a9a47836f54894f63fc0f91c720dd862c3120f770071286f1b94f8d3762a2dc8e93e312d9d80bb18aec4b7028e5619c139b6e20df24ea4c7a01f8b9a6e40a43415aabe30875d19486950d60026a58f456c2e246d14e293f51163be4c17d854b53386d58804e463b248b57e7508cacdad2aada6787f24a28f0c24dc4c8014f9e5aa83c8f358ee894728882f5b0f9fd6c2c1f47b8983291eeb232aa903f86308d8dceb0b42f31d5c01b535a68ce5fa4306913cbd51f558bf9819e09981d9b622782886d15178b6bf7a09c569b8420fe8b906ca0a86549322e63031ba4fb357b9d61ecd123e1228bc8b11217976f3df0f415c8f1c312f6735a5e8fea6c740756f2a5916e10936f672adfd744ca0fb519976ad432387949a1f9985422a91164ad692e44b321848a8524b0bf0635db7be8bd2cb207caf3d4e748657b0aa4c98df32e162f4ca61426928ff672a5c2dc072496d0c4030ebb1bc8d837bc8c9ad0f2786091024076e0ff744223c884c64f9fa3b86d45880a30dd9e4f1a4c66fd67186898b4aacadd3d464189509de448c8a4f8d0819fa0d2afdeef3a9d1759808962a6fd261ad5e4470ee8fa5d1830b7f802c71a014b87df45b5d4e786d92248830ce30a0ca49e0150a79eb8f579d4ab532bd6779e4873a48885c2a2af9d0ad275f1d1d1c42b3414aca540bb85f765351e14312afcb2c0b36e8cb128daf7e081daa30d5415394398db0942608cf1d11e94be12f1db11d26992c0affe60be75b8a4660964c53ea6ba5217a64564a01112a4b112d71bd22555176dad0e40b2fc9a023a5539a365bf9c9f5ca902989b1e8877cfbe0175c34c0b6581aef19f71abbed8f32eac4818fb87df6aca4deb2288a25be6a633cc580466037e59d42c1fecba101dfeb123e2711a3b0b38796978e652e04dbc0514f92baaebd83c34afcfc4a0315c90018214a7aca9fb29dca47b1adeb10c6d4062a0e02f52e5f5d085c935e13956995e77b2ba5861360fc6820292135483f70da829c7a383df9904ba5c73e14a15e151502394279c536b766a57536d83c0826f6d6514db9d2e08fafbae8ad5f65f57211957f1ce686f8a50db26b27584b5b2b65040ea52f81bbf1f4ae6dec41b8effb43b6d5ed4eb662299ce0383c672b8829e4021978781757f29b085324f7f592cac389e1a39478953bda119e776eb9e5f887730cbda19e973b3f7a75dfdf92757c52f3e4f388d52eee2a9e15ded6faa0c8eb85539818eab86d222d7fd67616163dc6322598d170cda4dc99811f1cf633b206e35869e18d1bef32a91daa084b61b8b53306ce5d2a468ad99a01287634a9661b37770f7285d0e4a98b0748983ae0297b77462cd87142d67d0aacbe02ea9c99d373260fe607b641358a22f29ea607788dacdbcf8d177ce2a097d9a8785769de9615ccd1b2a1887d170a7a01e46ac4f7dd144723a0bea40cf1e6d5888ea89191e2ae0adb9641ecbd97a095e066ce0571e6dd1f2f793e7dde84cac64636e3daf2c10ce95693792a0b2feb485d6b872b8395ea100e59cf0584fcf92359f99a684afeb1746994486c397f41e50f1a74aa0a19b9dcc105855217185529ccb2c39a327540e8f02602141cac2e09126da7932830b5e29871194fbe9dbc1aea2775e68a9647a44fabc5f44825082f0e3e34d214f139284af8e8daecdbc4a2314b818d6c62db44c7e77d6ab1c7cec9e19da24817b84cae814e8f6fa653f5f65b9cb93e23c913a02e5b266ee68b83f09fb9bc143c98de6a5e94b2ceeaed5f0376298f27cf8e9ad6251beffac39be9bd08b9534b1751f100859013dfcad8a5ccd3859e0de963fd9ac7848cd9adfd2eb9f7591f190340763147c7faa468446622b793c1e41c5188d3040e353d267563d53a73a6d8f181164bac87f4662541e67f5a50728099601ce6c6a19d2d0e1ad247a0d2f81164d43f1494a041b627742e5136f35f5b81cae14ffe4243acf1f637556a61cb5214a6527e8bed6e07d8823e6408d4310ff8b78a69fdb35c2510d0dd6bb2b751ae8900aea41f47367ceebad591d869a8c0adc2186e086459ac67fd841e9d7d81165845bdc9c4739a4a08531d29aa5236de79d0ee4d7fec1db05e9f3930b17cda3b6ed716d2db47ce2a2c18f809d1a9fda3aba9dd0abeb97eb152dc534536dd0b2b658e35a2069d13cac35ba8e39db77454ed9deb3423a93f92333d17779908ce061af8b307c7539f310a10db9ec04a74ff00fd167e2fb2b8cf8f4d709320a393447f977ec3f82a8fe6adfd280b58657e4b04931773231cefde563146b92317a964cad38f1ab178037f998d42b76f0676ee4290a37344ed410a165d0b8908e76d2a485e461e8270c43f9a36c602525d59161bbcc2bfa628a845d40c12678835a532bd3d207c8511ad9f1e31ea5d040bdb03afcccd3d71c8b936f54be07af0a60191096c7e359184df64956e047301e4a21152694e6b3f47bd3fafccdcbe27b2e76c35e6599fd7b306072fcd5e6ee5f514915bffb7be60737276767cc034f8f9da5d21649a48a7c270e8b55acea06fb26ab925096951a29fd1ddc5d089c14d89caf039554a6fc7ecab6b611b9447979af831b6d855544c9402e0c316ade6f157d314ae0bf84eb12554a2b683e1aac26a68f1ee51f8bb33838b26d94c58707b6e033449e0eb200a55572113faf30e732d1be2264a0a9c088f7540bbbf79bbc7e5993fcd3a2530b834f0553a8fcf0a441fdcdb3899e8361a94fc062033e0ae0e29fe5925958d2d4f8dfbf95bd65e6623f4c740f56c72c2b004c3f3d45b3386a117a2a89b334503ad02df2e2d50dbe27f2e1993b1e8d6859b197851d445ce9cff47c4b24ed3e64dd08227cabb6096632549a7062f480e38a38c59f9eb142cffb2b2b8050a5e04fe241a85cf106362c84822143ab3de33378efcda577f5e6b141155c73edc602b633f5e6981f54f1fd54e8bbedc7135e4b607eca9070ec9e1aa5bde39c925d66ef4d9b70c04380cc9611ceba16f652fe93a33dc8cfcca2a8bd8864f9483561805c44d4d0f8ba5412aa11075ce7e1ac209ac2eb8828e5a7b11de818a511db226fd4b0dfca94221edd13fd043d0aa629d1b6645444710385d26bb691b0448eb8e6da4e1ae994071717fa559cb72edcaf0ac0ce49cb7cb9c1f499175ecc76e2a52e28f698b381aa996f417ccce53389cdd1e71547c36ccbe471ba65ca6e51b62719345b6a4a5094376ce38b4681d829957199fd8c0415d219f485419c90e7ec416cf8c4b11f3f125c0092822fec15be3e5c1712c6c88e7991e18555f25fe5ea9931699abbb9a993df7d65632405e165690c7722e7eeaeb18c8712f439a1871d9b9bef6dfc94f0d0dd9a5ab77701f74a1b01392b88d42540f2d6a248b82c96f8eef4b4518ba0acff446aee977dfbcc9409a5d30c3a11dc7f79a9b55df3781b0df45e7fe35d6f995ffab96560088add74e77217b32d73445f51ef1a64f5d03f85792f74bc571bd407fe9835c444f68016db683d0fbd5fde571771c59a1e7b6f5efdfc06205f08a42a0bd0046df535a9f51c032d78d1460ef32a892bfe8c3c08560e42ca52a7aa77fedb4e2f12cb9fc57ea3c4efa3e82bb752c00f6d053a9208632670e551b7c1ccf62706cb651e9d30c05f805b26645ed39d7792d52432c8e39fbcbd0a3ba63fb9042a4053bd60d9fb50061f1028ee6e086d6fe1dd15b862cfd1f8fef27998c177ea3650e521474dfa074cc410e7425d87e761041437cc8e1d882a69d6a804355f94c55c79b10bc23c5e2cac1538659f04f4aa6e3942a6ca78c1a49744921f9e6ea2c8f850121855d5a6b36a8cca22b5f8314fbe2baaac581a8e321b1cfb5f431f8ac47a996f85ba607de8d272d62ddb810440af8ebb1db6eb3fc3108e63c9ad1837dfc03c9bfe653a7eca71639209c70c78240b7e961be7dfdcf9d5e5bd75da10e74d8084b59eaae8352b69ce2b77f2596ee836f8b882476fe0a08b4955ec5b01137e7dd23f5dc5127bb248839218ec21f6b65bdd650778ac2eeefe0f23936476981a0ba5ec23e44682d86b42e2bf28947bfd368aeb1b10b42f7f5470457f3c0b9a9fa999769c48e1b566870fdb827d2d9f00da57e0b7ed32ccf1d919634792d1ec1c7ce26910f785df9c96f8506fdfcb5d90484322827b1e73ff30acdc68c5ea7d2cfa94fc44002f53e0760cd3d09bf50d4ebb67cd1e3a3f6a9cdbce30cbcfc4dd9e14d157c1ad0226b5f0595f595da9246b5b11b9e5a477a20c0773fbf23253faf5af82e6968c93dbcf4cdae63239df2d0eddbff9a205bb9d88b570dfe50ed57f995bb56d08a646bc64f5b4340c6aded2eb1bd49029c7aad20bd5421afdf2d938cd93949f08954e6def5ef7451d980fa6f8016cbec038e3f9483b2c963a3c146314ee654ad9650f001edefa400511c318f1b5630ddfa245e06e2c846b0acab59319375bd09f4f13c18cffb93455c0a8a41be4e9865ee135e31598e71c4d55f317e56edb5150b2b87888669f6f1ffc80dd31e3f790363dea33dbad73f83f3e17818731279a23410682ef5ceecc526f6f86b672c71f2c9bfae7ab3ce4e444dcf1744746efd71a15cac67bbb0fcac00a317620c882f33d8c8ef23b61ec121ac564a0a0043b2e8bb5347677d16223f17a2e907a57fa16af8e9184330ec1b39d26fd9ac894196fd45b6bbd911049d2b0ffcf4c057c3dc3d02b484efe5d506ff3b4d4be4a68eaa6a0c199606efd985fc22cf9d69576722ced8653dd223aa3ce9ce687897debc3fa4288c009b388ee6340a6658eb9fcf818f82ea03b274b47545dd164e9a5b86f0f9c1f8a517a10a101b07566ba863240ad90b52d22f09527615d050f280e593dc2f173265d0a5dd364e35d24cb1606cae5d38c627553995b4e7658fc5ecdd8162580a70b037e2c4aa1f41697dd8613610627ccf347917c7383a07a375fa9a21c15fb3a5f9eb144239d84a3911518a91f886ee18c457ab24780e556a3aaf59022c3159e564ae932d27a512d5e8b929a2c207882d9c721f5309faaed4941d030f065aab6902d8d35a91836e875a929ce3764b6ddb642097d33be2069af4bdc22d4edfb2a38492c463df85ad694d9af5c12b4f8afbcb0b23ea1388bb39614ea37fad797809543be795554b369f8182a5dbc743d06c4d6fc8ce76654d3c7577caf85228051d82dee6132159caa7b6027b5995505e2c0183a2f1db7e2387e220ccc90d57426a30bda203adf0ea2aa62009c2dd5c47149cf46ae90293ce63ec5963cc004c63068c88dc5cd6e91803233bcbb0559b452794be640975c4a4d020474a2d21b978e39dd33b5e2a9488b81e65b2d8ce8ad365fe61745908a53a59b29f11f53c29a0666f32164d703cc7c13228bf55b18631d806a4c194c607fee9886d48cbc330bd45111f0cde7b67f319389b89f3392c5c934c0af05f437491f14ded2301d1c128f3cc2043501185ea83aed638699f02b659b42c4e282531edb45c755b36a0ded97ede1ff61213f788ab835f09931606a57eb593b04381220b2e185d7867f80379da2721888c53c212c6e233324477ba80f1e122fe84845c8a0698206e538f5b54debe358e17ad44cf4b11b2b24195f7d0b0817d86e2d8760da7487ac372cff94ade99e05cff066735479037714eb5b56eaa313e713c42208bef09be450dc815eec1dc7b38c0330237ce5c20ba08bb103f77dc19da42aae435b5fc1a83ca557a4628a7fdcd49d47ccdb0fa74e754499bf8006a17ddb87ddac8d6ab85728965d95de7f49ba742abcc85079115487619858997a7a86cee9400767a46fbc84accc8ccbdcbb0f2ec3207057c9bcaf4fd7e860ea94362eabff8b8c87e5159c64164e08a229745f7a9a97d8d8064da5d818a75da5cb29aae6437c02ab7b55407e6cfd37988264eb62975f54af1b096635877196d027dbab225f20941e0e61aa0a7de8bf09f06518db6029407d3d7ffe0bd2354f874040c03c6888ee8c0a2accef1bd02e1801b519e468a6ff166c7d53dbd1cc50be729d003c6ad8ce6f595ae419b556a9667164b72c80139aa63b5faa06dff71617fef1a51d3f762bfc10fdc2625de9e3684348060fb2ff01ea571b47d50984ac4d88a03196fe8ba6c380089955d2baa27b9b64d0e81e36c8c39f108f388589a7fe1277124dcf76cfda7d059b8810d452157e86c906da920b8399293a6efc558be6e9cfba22d92dc25cc6fbbcceaf3dc91d0ec2d1e61da3007194f455408b356a5be0a8e79c099230f43a2d835739fc642935766abfd416646c1c12771642b28914bac67b49a9e2de9bbcd350777e7b35dd88fb6dfa60e6b552c265590b834fdc5f0a628049bcbc0efabdb0595d43819f5d81ce32c08fb3a43d9f93ca27fedc4837bd81de4a1e5c8d60b79fe58a83041db7d3cc3074b79acf37a60d26806851c66571dcb3996d0048edc0f33e1cb9fdf946fc0f7baaf55013546b027a28772b469ab76b1c46ad218088644c68591e7c6203c97dac31d9f72aa2184780de8c5cc5568944ef8661ca5709e597e7b4636185a86972cff73714a0394ce40ef118f08e8f35d8aa876908a496b381e71e126e5b4db017ec65838e48a2d75b13c0f2f2e156a9d2bbf63dbefb7da24532f04173d582f8ea270e2d5d152551c24a620917a3c764fd8d85ea2eed11a92c2f73cb210116508ca60300626bbc4a001b28af7f447f260e325195a26545127bc72fc264bfc4c0685c7160acfd01c8f1842c0598f1f09abc376a539d11dfaf9cc6ac6f77bce68df2ce63a27d4bf668017f30fe1a0e7bf00c7df5cf20d5767aedaae599f0117b1fee38e9ef8d42f9d2b43cecd194e47934ad6f3e12192626a3a128a489cac8c70a77850624d2f80e185c7478bf89b150b344b23fe62351f8b0b2c46308316bc0d00cf30eca92bd5cb373c633f700e2c4d4622a20c596bdb8ffb257712bee9dbe4087f00703f37f30118115ce5fbdd8edecf5c8c595ae625ab2044e8d719197b3064a22642b13749cb92de9db3b3c1e0683825aff06e917dce4056d774cf3746100a8b23e2781da362a5270ce7523f40e3a2044500aba2cf7544747cfb94d564326a7f270d31e413fe46aecff46928598ef7cd635dc7d0151bc4f590519c29b354ee585b7d5a5254f14e5f2ffdc623d4d1b38a8af4de14710ffc24c0ce68986a6a2666512a64410b93417403d226cf9e8e77732af5f3d57f32bc62aca3e054d74a679be2b9c8afca0057209fa135359b0f5cb6283427c9876615bfa5090706a229eabd4df221f212e7efa7761c1058f76c6cf55b21830b31e82c1df7da6e91f2e6c9b6f14e129d9b3d3d2ad4174dfd072b4b988be1c2823dc5342ccd4b7065c808f0270c9e87b29d5c0daa6078dc0b432ea563c3d221a5d7e9bca0604fadea05b54c8a048c2027cf9f40f7c96849b151c2671c0d60b71496dbccdeeb9b5e9f6a293596a4289409f087ffa72553752008481e4f72b2f2ae6ff829e9b9524e51903eff988d50bd9833bd3ef65f580da6c9c0629ec31314a443c6aab0bef423af7527ccd27a16c63e8d30ef86060a8644c34ad6438d6507bfb5aa80a43a44b517600b138f25d8742209f5b75c4bcc7feca7b9b68beba117225358fd62e55772044ea1abe92a8cbc7fdb67e0593d2696184f05a8e5ea426dd195bcb20624284f9225cc1302858ac211fda5305be4fc0d3dca4ac330fc0068a45909ac053e1c9abbac607a42ee01d6820e4807dd162681981158287464201b80e0dc260c935c71532f7a8e930c20db8cf8aadf40aa8b9a05ab6ca576a88b1c648d0dc8d98ff62b00be97f311c31cd0b82763993c182dcacaad0244774e27e541cbef15c57b4fd680bf5dc1a4124fe2ef2a80b6a95e6e32cbbd9ea32f1acb6fc82a2c3183e0512de09eebdf3d723e9b4231352f2059d430b6bb13ebdc0e1900a4f576d82528953589124c97053952a417c00328961403806e32fa4a3b3347ef871e78fa0c038236d0ce27bcc48be10562888eda48c8f57828d2ddcaa5eb19582d156510c151ba066709408ccf448f0abbf662d499daf001cfe3f7ca4eeb28b3d0c59e8f78c3c6e7f0694729ad0ea56b778d9b1c33921a05a8833d6be0d3ff6f003394bc6a680c32e30ba43a49d4038c380efd34d07eb00c8d021926a29b2a034330a970d1c80db58f584a4bbf45d00bd1004400dd3b619d7203eff932840d8b85e4222657ee34afff3c021398130ce91aeaffb937bbd98518a40db7339aa0e251db9cd39fbdb49ba3ff9eef5d74f7e7f5cafb091ff71fc2dab715acbef367198fc47ee68b57aa2a560d5e47184a490a30558bbfa5cfaed5b079286b9106ef7a9b274dd4d7fa846cfbd2716d6d45ca16d3dc7558aee9477dc37d57d24d4b09ee376e9798a8d4f751205ed0ee8b294a0dfeef781c01d92a1672fc391a125638e465ce9a6109d7354ecca97ba22791b1ec29210c862a366202daacbf147451548e8fba4843dcb118dd2b7b83797c935ed4291b9e72287f027418bb5f079ccdab35cd98928ef5677a682647e94d226cb2a797b9661e2dd7a0a6f130313ba8d2c8685ce733c6e152d2685c7a5d0f2b76e3c21aff88de07772c380d423f3bec9a2cf8b44346bd9f234558514763d1744ab99829175ce19004c013afc6e1b9c9b90f9f227255016658cde2e102db6203e5c6655adc9bebc9205af1f03388e975380014e4dfba7a72d027dcdeac5f015aea7d12797154e8972a87c34ff715eadf77763c73672e74172e740f15113993aa0ee398a54b83162b445ca025859b64e7e2cb12d2005028bbcdc9a2183c3bb358c17f699a4f0b32eb7af51bd7a25fd6007b29a5f1a456a45d1b70eb419aafed904b94f71abd26637ee356684b765ec6ac1c71dd202a55b8e84714aa537e317ab40ecde7eeef4b7c7c54bb5797b503791032a26cc6877c6104d8fdee922e3ea4346cc70d35558c0cd9e1cbdfef1a5eb9b672a978debae3b08c10d17fbdcb7a73ca19fa3be0569290232f6ad0ec0526a174851dafaaf289312f3fddd67200a4d07be8e400c1c4a196605b09477ac8bf6fd08bec2076edf7ce12003b03a550118dc89464397c6a3fe7c611e8afed0786807bd1657a42b63ada6cad82c19044f4626d99c5ed88f8f3faf553e1cd914e348aa82ba8a9baad421b025ea88494a589799bdbff3c38a4bf344711234547d411fdd0f2884cca029b256dd35ca1af443c6b366fbeaa4d8f4d0656bb0c982e34d6d702545ec3bd972b06b929f357872cdf18063614bdf97dde910aade3043718b4c0c0005608274c0dde71e406914ece6a01f58e6d6f2236bd040ac0fc80a609969f491ddfcb84a04e76cae44aaca360788c34d106f2a972852fe2117eace903ed0b045b771687d8f2121fbc17fe092dd49c6bb4036040feff81ff8c6383acd044f725ea752fb4a404acf3685b0bb9bc21353d13a26eb1d64175bc6564d438443e6c3fdcab516d1829d0fefb3b8199a584dc6c08c31a637004d31b3e469eda89f71cb9c2f81b1fd3cb3d88e30b20cda7d58ee155d237c4fc8a864a66599a2ae75d3aad18f9d1f79915997506bbffc87fc05f12b278f905212fe1ede6907e8f6979f22e3af90d6dae7d2c93ce26d407f1c83fe85cc85c6ff4d9880232161409b8597a04aacfbea67ccf5174340d96ecc7432a618ff80961f1903dca442aff5d486f59975809a06ae5c154f4aeb93b88667a980a47f002f031e71f682a433d6471d353c9812275cae22f918ffeb6193c6e06a1e7e0b6c4b195f7b56eb02b05ee6b0b0afd5ab0a2157bfc0ee3cca10d0c2fc100b87a90fb0aa0c833952fa758f6730e4d302379dac189a2057dfac9b4016f351cc79551482e6eee779d4a65653197b1ca3628a6423670a2b1abed22df4a357e761f5f902f407e3e389418f25ed6fc518dc415635b75f98fac7810d63d841e11a1f8e34bef5c86c22a6d77e248dfd0468afc14f8c001fb4559f1f102db432f9f336e2612b5780858104f607c630866f526769d968e87d21019759f7a5c48a0621380413098682c1b37af4dbc0c6f459573c6c2a7e155e7e82ea88fba606a6ffa135893739d88827b80c1b23b46ea7607fb44e2abc51e5a3ba15ca670a1fb1a19a77123129ebf3a7bbbc9e66fabfc9854b4a80d305c0f8f760389b81038db4260626f8c36c66b922c3e07db1748d9f46b48864f0dd7752251d123966dad1a0062a916fd98943e11d92d1692b72d590d44c852d928200331367a5a1599c32fa169456c1f827cff2da74b59d6d57dba9f4ccb90087b48df56e9332cdc0ebbf06e4e911810660b503590c7e2f6d916562bfd109b1d0e0aa8ceddba1fbcd8f1b732a9f63d25271c425abf9e3fd22acb1ba898fcb2a0f11b2b9d839213e48959a2d62aa87fe44cb204ca68d6e08bf48895127872a2cf8449077de331481922e927fd23aaa4df2d93a58776beaa14834edfe9c58092d773195493467c1e86265de1c5943555c71c8f357162e7d1ce8c630b25d2845d61215a813b49e9ecd9a0e63910986f50f4ecd38ee43b41e7bcb13f4407b296c03128abbb63b6eb47ffe19a6263cbc1e2b97ee01a5738a3d4b0c49fd6a8643e60a44e53cd2a952b4dde03d236541f1947cc94076e3b7f224653f1400509e419adead186a878c3bb0b74d8d999cc6437658e08b85ded20a617b9c44e0128dd1bbd80445e0538ceb5ed31783a7c6adce74914a48b141cb8b91203d32a6ed0f4704ef164fbffa4c1feafc2e2e6bd1abb1214454526bd3dd0e8577f349bf8afdc97b6be4132b57c09bddb11d2d674b08f8f6559f39ad4aee74cf05aae3ac44f70299744b2d2c4fb1182a6b94290cdf5c41391237733a459951622b2946fa29517068c38f697a50bb9daef184c336583eb125ae1c14c60b5401aa4c6564474613c579689cf8cb69b9ada17a88eb03efe4d551675fbed1d989f7bbfb526e8526bd783d8d7c11247e0047b01372ab92bb2e3fb83ac34f6bce4abf85fd9c4099898914a1a3ac43693b2d448cdef3a1500b6a4b6bab157d6ba57bd51571a20662cb671177541ea59057a25ef071c836e35bb3a883b6b5cf3a9b763ba1340bdb84e5502fdc1482197d6d35b67caff5ef35026a9bffe5ab7d60c943f424e8ef9b791a6c493f69b3ab5dea5be212954be0650f6d5e6d9bc7ec31a944fd4863afbd759b23a8147eda8db7ad9deb44121c0da8da3ff696c836cb17ad7f01103e576b2ddbefaedc5e2c10f119654cfeebf7fafae3dac2d51602ad16669f0ace6b32dd130900d25f420fea9e4b5f6d8ef0aab0544ebb0ee7e3a1dad49afb560044f84f2185954a972457ce1ef15e9018f2f21f24ec0b9408f5dd1b0d6d37fc871fdf0325fd358aa797caebcd9afcd3dfc4ce6d4557e301c4941e24908a7b904057f62b1782c13d581498d8bc96a26936d0086290e90affdc24fcf4361b2b476fcfde17f4d00467c57adb85b2577cd049c2939538cde81184fdcb1fcafefc9991e8bc8844185da66207ecd8900a91e18265d9d525cec85909779c4246198a7265e03854406563487645f9b5655be53e5881c399b033eaa57a5dee25cf1f27b577348ecfc65731422ef0d8878e647ca22c0526b9216f13fc9fb3aae42e76ce8a31099e628db4e6b29254b712526971b7fd3d20c3932593c7497238bdb7d716a624b8caed2e66f8d5da537f3d74b8b41c2efff0a91d6028725186adfa2f173780948b775be82cf87d414f30d3e6bad45417a6e6bd927dc78a711f51ddee29084936a5adabead1d27106cd8ec4b96fba452ef3b6c7c52a089a6e82c50a3e5801b8623fe3dabb721899dbe86dfa046573688821fa66b46670060a2ef2d08e187276b0436816181bae89801470839bfcda3f0b634be2014b04e167df3692db6421b2140c8b0f7b43c0c143fceb4008fdabeed44c4db1292f544798d14284d2ae7ec1ebffb8f925a4d2a56b7d7db6548900167a99b8742ca92ff6481237f01c88bebb4fc03911dab080be78ff870943cc5cf4c2a740665e43191abcff3124a1f68cecc9f08c175e25adb5e7db85f05fc011a390cda25d11ba6e12619a2140dec93fde8c21179754d3abed970fd586fba30ae3f9c3862b4f038ef87356b2ce7a8feea65a43af0862dbb0da70ab62606c92ce7b257d8ff81a1b5237507be605d15252ee315769baeba807cf6960a373d12b6d412062a7aa69a91aa43cdfcfb9207e79a473df5a5fbe878f154b092b3b80dab6953f8d1ba3f920a914c9e8c7e5e00470c0fbc549b43601aa6d7beffdbf09dad6d58d2295966ed64d43c30e4b26a2300c559e0e1a6184c678d979c3445eec4d1584dd867337c8ff0cc7460a6e5c5716318e708cb6ecce301a71befafaa63bd153b7cda3592416b187a7edafe754cdd24d6c45bb47df84519c6e61c3340a5bbe32463e959ba16c0dad7687518284b702c7ca8f0b06baae2ca52eeb260045290c7c62e2d538b5fb5ce3aab75ecf00c43a594a5a1a98ab99afdacd85c07d8283ab0ed995aa88d39694747dfbc5bfb88cb181e44f5c46af3963bfceecf27e8c9739e6aa0de2d1ef0f2682cb06333dac08d74196d83a87fbc58d323f3417a2e2767bd6c254648af342535cd51d76970cc0aab8c43f71ecd41c0756b5cf4afb7db260b3ecb5e5ca817a3c3a2ed0ffcdd32ab453d6f34aff44dc3e291c73446e9ce179e377074bac188d5ebac7c8c44ee32b7493af1491d16482e3ed625affbd8f5869dd14ff002fae58589f902e033fdced490823a25673953e7353f073f5488612e261c3a5abef7b675df9bb2e3235ad081a43d6485a8e42171688167782b6c67d7cf99a2ea4e57863f5432eae11b1a1e6b9d5214140c9d43c2197e26506b6a9d9ccbc3a3f9a941808adfd3ba7e85fed1e18af23fc27e297cb14c3714655914293773f855af8896c256ffa6c87b0ac2fdf0372372b162a37a2c9d199af07edbec2964a8970fc62b559c63c4df10a1a2e2970c7173935e59743c102cedfbb7a15e4ee6318c71a329e775f99576f2e045c646ad99cad586cb7508171714144cbe4c153b5417d16d1e333941e3b7df18498c305728280edf8cc01e8cda19a12bc56291cc4be4bb112c2ad054e9a54923e9edba22e467fe9beecf81aff9dd322dcd635269d4108555003630b4682d755eae2fbfefd6f3c84c5377759165e30e9c2c1b0e2b2eb541c12f166713e278933d278dc0d13f8bdafe4f757ac23a3092e8dbf748ba2f3691e517a10b5005c7a7c7fd87bec6d25118e7a75a8fd719421a8a6333f09bb39f15155efeb3cc17e18e04afd5e88d30e0de5d870fce773ebe35af98a0ca438c6741c60cb3185dd5e0eceaf4f0c535d1f7b2eb43f69d5d540a1e71ecab22a7aa5abe1ee8586ee92bed647c921ca931a04bd37e596b94fcde533bdd754fe00a585cdd5841737c76dd20fa3c7dbea06bd2621051522f47476c8d09dc3c96f24d3703347b0a7cff2c1d92d8592892622413c4ce74a8b106d67b35ea210df08dd27c673219cf2ff00f3b88dc03e381e6a4b07c8506895ee147e5cd4d6761e90df488572d76f08c02a62cb296634da0cfd209bda4aa1c4d902e179c36bfb8a149bb794857c65c9f1e7f436c55160a51cb62680ee5d1d0ea9f82b2a0b9ef2a357c7d5c68f467c587befb1e44f3e42e15ba5b4d8e0887c69069fa692a3c0a26fbe96bf86e4bdb491f95909dc6aab4354c9cbfb58b0c2b554ff404378cbe4d3dd036c8422a665d361ebe7879e8109b767819a7dd63372c93d88f779b05178c39326709e7bf21c36bc8a6ef5c2cf65978c802449a47a158fd00ee56019285caaf825ba2e256961d7e46c728682c0c8d1125402644b71e3ac69848ffb68f0d46f473211bb5e5d2de68cb0a27fb93a2bff726f0214a8d842bd12cf8bf0c00843f74e93f374f268aab436ee0dccc0b9fbef2d21188bea371a16ecd4e8868ee09d32f1900712bb63335942ca06b5975d45036bb232bb3a586d76936acef34e805ac2c9d83559260ac1986dab6e60a4ba5760f371227a30e19f6e216dca662e447c3af4a52b6803e8f51a0a868c4e60025e5d3ddad6fc28b2749efd26172c6b4f80c76284268a7581e81c7e6ff5a3a4c456678326aaf713732cd41ae93128cb24f9b963e8f67649e016bb0767e3dfa380ead78341d3e9787730dceb98f2583d18c6ca81a2555b6ace280c19f9fa92508bc6154facb457039992bc03f2276c9a39643785ed2fed602491c05f852828d99f846778c7ff3dd910f7d1f8ebb5dc02382beaa76aa0375215ae9fe1fd81db3cde36a901417c46f947f3cc25bb090b49565227e137fa22a8f78cbd0806c9aeaa3302bb5f7c44696b948789f4f52505fbc594a9496ee6dbd6ecfb02dbc5ec570ce830b7508a962e47d80d22a0491984c34ec4669d26f327e37484becf614dcd52b5a740fdb175a37317c0b5169d2dbd6715b4195a4dd1401f66ff9dca07e6ceef3e23837ff08b942bd43e55fafc2c6d7e8b2d1bd71416151cb0469634b502dbae55f456b44bece42cad748cf727eb4f2411a4a8ff4cf90fdade3db599df933f2bd3cbe10c1d144863bf3a161c3639ce8c7eb36df2fb1edce636111f7efc8006085d2b852305fd51bfd6a38cc024e3ae5efbff3e9f6f60719b333a8776f9e5575ee419002bf476e8e3201fa2c9e164bab7435b4881bdee6d62b80450fa4403975436882d23c3cbb59ceb8e85917a9884e38987cf3721d8f6f91174a31b92838d14e534263e8c57fac281a7a11566eb0d764898998838810941b991c76c6dc3afcb924421dd7a9afbce9fd54934368cd3e82cf89cf6180d3f8c0824680843ea92fb91d4cbe11f12887a1044b9fdde7dd8bff835ab3931bf2f52860bcbbf60a61a77f9ae8c9a785fd87588cdb2f6c885c2137310f80b9306487f3c95096ff9644cdf25eb421f9864482db52212c9979c87fbf8b2f8b4131f7ee74b10910e61d6995a245dfcc3f65b231a1aeea96a2993c672f54e75d4a0f8f5a22efca1cbe2026674d33fc8cd846b26ed590e83322e4bfa01c84ee7e93f5475197a6155631320a0826a973b430614d044a2630ec100af349876c8a1dfc743dffafb8315e0cb38936aa974a7599978e8619e2bf83f018a950cf058a8d8c44db740a74dce6184a45b1f4b27210813a9f104c53282c2a3c1a86fac2413df0d9e0d9e214fdb305663976e2e07cf94cb20299b25b8fa35c50cbeda8a6cc021b1207169b224ebf6e64dbbbfd8365a804cda8dff10ec585d40aa9777774f017d6b14463e74776e427d9159cb7491c096131f10b5be0b5e441cf835fe0e36c86b53b76ae47dcc3aed0c5290a6cba6fb57158adcafa168a4f2c14e3d8af9522214ce7232e5959762a051a97224e0c5ac3944c555452ca50d2512f479931cd277d013732c58f22644d1a9da0f15fb7bf07b262783a5db78a57e589836052b305584a6542e18338f32ed37616ccea21b61eba1f7b38261e82ed32afc5812febb972335d78e652d4e02697bf5795c2f1d29774386ed0fb58f2ac6ee5271f56f2d326b01eb2f257fd8cc63ddaa665a1392c52826baae1617c42af36443be9869903e39e7398b6b0e8bf7a07b0eddd117b7464c010327d99ec10177c51346d2d6da048473a03efa4bcd9fa40d0f8a0a0c734f8aad891ec1374e498b0431c959a4cefcbede33169647f28483e42d6dd2b3f08b3f2f51475527ec30790e0edbe3d8faf6ad9d079bcb641028f1465b929236cadc36816dac9dc0eda40605d5b6fe088b65bf76b515cda049815cb83581d11f8450ed47a0ad8728f0776a58387cdff21f3d1bd500f08a208b8c875dfc1e6736d7ed3b2967af4e2cdac927e32cbda0a53c766b096e3eb3a809a365423ddd9948f271acd259613d9e34184e0db2e55ec4ad09bca5978e6bfb44fe2bcfe3159c538fddea7592feaf37b67bd30e1ca08b8d33dba23089fe78e55d754497e32077385f50216d657b5cda3dc36b55c60ee9bf26780e846c6bd1013a8822eb9c5813288efc12e1c26f5b36c0fe3f3ac318fc25547639e7f1157db475ce61474d3910811c8f51f588a23ea1ba54794aaaa05357953621e9c0332679db0d5f5a8917699382b97a4378118ef1ecee58698ee85589179132ab745e04887868a1b4dc1ce97fd98c5f4d3b39d67caf03aa88096a4846c2bc0cbe855f51d2fb186995def78b47d696f98e378e016aae6262520a2841aa6ea32e43b9242d1c41c6bb501710d1e59341a6839b98517187a65beee7938807fc0ec692f79ba26bb40e283b8248fadf39a44fe8183b0c8a52ef011755018206a716810db40ead54da5eb93830ed40d0f3f533f2bfeedba3a72ac120575d5cde86a78a8cc6b6825dbf60e2c80fa38f4780d1a67ca4d953ebbd0f82c699325e7baf73b67cc7fff73fc5ebd6d110338072ae4d82e5c1e5abba7e3791b79257ea888e8c56fee071e0162cae429565f59d69a557f60f8505ef439c121e2a03f6971627ea1285e06c8f0ca53f23a6daa726d58467a626f827a0b856ad09108d6fdb07be202d221b9fab9e8c5d33da00dc42d20805ec2a507a10f5bee860abdcd160fe4f9e47c92cb0fa9f20e3d4434a7598c08bc3998ddd4be37855afb32deb9144d7474ead85506b29a838882f3bc6cdd9be2d0113b7bc605b362fb656da9b4353ffef93052b2c866c339c72d68888dd567cdd47e07213cb290ad974a939b3a35c5e8118d1214c947ec735dcaba3a464b77ba5dd01c3e36a8251b18f2b13b31632b981b2a3d404f1dfd05608677b680d19f2f55bef58efe6175c4835d2247bfd0017846a4ee5d30968d5a127b84020e8bbb895923bfc0b3f08ab2d9a63fa3658ddd7baab7f2cb4f3067276adbed3ec7ef283600b0a8e8820e3fc834c0904849319ce4fdd63d2e909f5eaa6a51a36347b59428c6b6501ad1e53ea053ad2bb1a80adf8caad01104d459f818fc0b22888f673f4e6ab287b968e4100dea572742d1b865f52ae7ad5a6b3c6bc7556abd9a89770f7eee29f495bf89222f292a07bb40088c755e67f44c663a6a7a511df44c493bea368d39a68ae0ce33d4bb639dfd56a520282a8107725d595f1bd1fdb37cab4914680551229fe019f426d5357d5d1c6bd276c6b2e140c4a247fcf73595b561500b9808070cbb4116e82b218878217aade4b16e2fe49f6d39d2ebbc6eaf5c9f542f9c86415dfb6cd72d00659eb9a905b1f1173bc8b7c0f51dfae0301ab4f5045f43195534de9b2797c7f72730a585315872cdb29d4eeb6c045dc23905710cfd7c42697f5386e096726e0c198e7d0d9ac59fed99262a65a66084e376ed2ffd069c4efe5015a3eaf4e3229f0ea7d57fb085d4bee508297d6c9ab14c1315395e9c3f6ba9e92d808f9953ac4790a411bf1f08f9f26dbf5a6655a0f3fb6695f72e02a6749da423c76c4ba2b03545e81b43b58139b1e1cb9cc8f607993c453f08b2526f6cb79ca72d030b052b245254763102092ba41179929a668b450471257ba72b7784675c5165b41829321d4a7ce8eba67e37e39383fab3025467a41a786aa72d1c6e5be9d17e96637f91000cc353c2706d9a9563be15d0532748d61f2ab3fdc5f88da46f9b0e4530034d0f5b5a81f99f5545920571631346adbf3c067e20c390b46ede3a5ce63c5cfa44fefa7ba0bb5a03c18a609596375867b770a83dcaed4650791ea09255fdf8a260b8b594a92edff2ba6fdadda8dfbbfd6d3ed27fa77234bce8337d3694e681c1e91989ed8bf388106a2848d596328f451105cd151a6cb941c4c2fcf5d0e087fa6f245b2fd0f53731084498758aa6074aca888549a92273a52b50a17bccc4c279379c003e418495317eb171cabce175370b18121d7a6025e0d72c7b2697aab492444aef21379db75fce20586c93e6febda543","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
