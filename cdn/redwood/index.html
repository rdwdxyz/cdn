<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3dd61df3318805dd940c8a1048ac517a370866456a2267060edaaaed0d4b079fcea3b66c354e46f3fe271410f061b63c8fad97e554c83c08fd415f59a75def836d823d009aa833036e2373914ea54c5ba0145a867d51bb92a69988bb64863218b8ef280b0f8ad8570024db1dac37be744b659f712df1fabf08307205c23c7f041f2d1b341add47b5674865e86a3a44e7133437b47f159367a02ba4d18a76cbc480cfd707044ae491f2ba16e4bd78ff13f598cf9bca7c8b9442c6d19f16e459a431ed54b6c9488cddc033237c9efcfb84294a85125bb2482b0ed8e138e446cfc8e6410f941d9a10ef3b8d4d28770ee453a2175cf3009cb8dce28b9fa79915c6db7d65a09e7fd6a0873fbdbc73d99229e241632994fb5a8987ca5d9fceb753cc9ad52a4ef07126a02798b9a4bccd351b7bb1343a035e491a13e693e4115065642f8d94cd1c00b1ee7ec9bdcd37b967e5c062fac51ed8217b526d52a839637936ea7059b11b07db20b62d6575d7a38985263f50d1eb740c568262a8d25416a4ea98d6236a5b64817d4fc225a3e0a66753fa0cc4df0f85fff389d1d7c983afaf090d306c24f6271c3f8ebb433087c2e52ed2c4ac698938b0912cb16482d9441f6676b746890c6adfb1f49cf33d1a88e954784abd62cb73363d561dcb7ae4218ff1ef0ea13658c2f60310bc831916e5bbeb132f4eddd856858c10656332fcef0a2615cf284ed21f0694281e8e65bdb723fb450a58f5d9d6807d1141e43617ed479668f6ab0dd2fff8ed80f274a9c31cf11c02bfb2d7dd38207fcc7cb35c261790b05f177661f344be5d5a268b1dd5653ac79c7d449547ae48e3afb5483eb864086ebea6f5d31bdc311c006e84ae5921f8a878e7d3ea637df8558e0407dd19a6d35ec51c1c11bbce86b1ecf81d8b8c55e545cc10ffe97b9b2f03adaa4d30c8677149393ca8fdb4ff99c1ce3351042fd9f2ebc83e8d1213a91007c52c935133728358e9aa5edd349fee3999348ce31c09e008da67e039c86a8552015b55cb40285bf5deceabddb44586405b45899f72a65ee1b1a4676655fc5258282fc4890799e8e2e53ddab423c5cabf0ba7e50a60d1cf91751fdb7ab2b4795b636b5546c63388f7e2008523ba8cce15cc9f537b1cc58baa65f0aac4c9c771d7b1b07248726c6e50be61ecdbc7c940d46ce7a844db8be6e8a6a6a321213b2a3b1d50a53e04b80221c583e7f00da7504818cd2f02358a3ee72c9ff567eecfa2d236c9162f2c417138020a3442452e25bd813bad0960229d3c6468cf35dca67fedd06dc1f8fa3a3b1533044e0d3cbac93331581703d6a21543af416825ccddf837e1bb716dc39f05e7ce56a485f5e2b46d9cda4a5a3a786e3706b37b32c55cd2b1bd1f01f989531a578e2e24a5f72ddf85a9e87cd5ae8da36f7921918411a7776266fdde3283e6a5769b4c3ae223c791f0bd164dd3dd3b6a61a4f93ccf4165c22f3d17f2e112a0471f41427d5ac197fd94f051347815d568bfa16e93a5340b3bd1c682f681c5cba4c2eeaba76c82ac8e32ca0e89afc570553807a931987de102bafaf54999b614c94cf08e40b264f5397898f0fa0684cbae5e039dcc0ab653a36dd5d97fa07c9d3005b7f0bf0ab14ac82777a7a2abfbd831234bd500351369ae6897d014eadd5fb5c0cfd271e803660dc2363136b9ad085a005801e03ab707024cfe9406663b39f9e146c0f635435966202da32659ef75221fc4d89393c34320bc8feb5dd23bda25c3f6e910380ea98889cf4ea642c0d971fa630c781dee87504fe6e929fd154ab07e7353c2d6ba17e775804c9b5cda5d57bf9db9d1e47b878cce0109974597bf031df7e457b05a684518a9d07d03100dde5c40f2aeaf7dfbd2f6bca143ad85d13a597ecea0a100691adb032b9fb9ddff0eaece18d244dcd0907f121710b81e16b27dc1670a78fb09e4eeee23a8c57040a66c9120c680783a48b72faed7b40b920dfa0fea987f3cd74392a1027fc095d0cfc12228191b9b0b30e236dfc569ad9b0161cdf7b837caf2e06919e2556fa4bee7aadd1788f6b7e9e0fa60ca5ea2767c0dbe0e0c5e99ba4284196d0777931f65132332732e9239407b67be38f53a22cc72b694c0c08dc93189bf16bade559a6276d525e7930b94382868612ab6609f0ca0e6fdf00b1ce71f4954cdd1a0a889c0217f742685def103432e1b5e81349510680f3256fbc9a8954c1b7d423f7d0540501899ca4bf22672a7b026a0b701ea9f85acf36f123c71613e0ce4c9c32c24d1078a06c2e4b3e41790c25f1d5e3f1e336aab11089d8bf4e0b67d762a82074158207bc03cf860316cfe3f5eef16fb7fd6ab38d625cca5c09d48c1ad623d7dad101edcddf07fe005e4deff4405f4e8987df316e0979c0174f03587a5228337c369a886f20f92d45facc052e49cf2aa88ae66729cd35e5aced909c6d89cc36e0c4b4d47c3bd2c322c3da97bff59a2c235b723aff5142922bcce33b7522b0334318d55f21cfd446c415598742b5b9d42a8b3cfe277d266aaadc37d880889405a9125cda9e8747cd6662c7b2ba0ad4d221ec3f0785aca5e07e9171ea7c72754998b5800070c39e6034b033c538b908001c873bc1e7e0b3e7441c41c4e1b3951c497a1003bfbbf109163b53b2a4ee234a62cd4c9947682160dad95b2f692506e1be5af90702e0ebfcf911d17c35860e397dc2d3b860aca07fd75c1bd5ef90b19a948baa4cb851d7465da55edcb1ec1440d32844df23f96108636dd2b3b3e3e0dfab90f5fe373ac7869a15a010db2d57123ecc74141de290e0892056d21675f7303eda7f50d3377073e2736a2ea6fd4a85bd59805d34a21f2eb13a6320b6a24bbf5b9b83230cdb4bf0d51bc7c1a69fb0a3fb0a4413bc4656eafe30e678b67acd4631f6cb9b525cb3157e642a517350e04c1e11fa941d49f116f9d9a74d75d3d012da00f6d2df871a285f5fffe0760b91f30c1c3595c1575abff077d2e243b7db0c67913f1feb170920e7f9e02743171f9e5a704a267250c7bfd03a8938a155169acdde7bbe33783109d13076891cc241c71baf649b31d5447ff308753052936008ac2c658fc1c685821076838852b9cf625b40b2571534ff77b85d1f998dc36a45932031f607cabd842e43b51505911cf17343a595a72fcd133e4de7f52019cbbc95d1a27d28cace771020662d52969142e1cb277ca846dc0dfd6507cef1beed2df5b5be1b5d1eee5a7f5142c85fb0ad46a80db63c753a934aef0c4e2428389b51d262b7d5b5e4e6736b1b5a27fbc3f5adcd2e04c0bac2ff26c5b56630fd48dda6c17ff524550a333c6a5f57d28c5fd104d02c415c84f0b9195c41b5b0ce62a00623a16226872ea58277fa455e0a1d71508af9083289d5787a159b24eea8d6d74dbf0cd3c00fc18f700f910074a45357c15ad7f18641b2fe64ae3a85188198983b56be4be5056da808c69cabc8b32adfd01c3be1289b63fc35f28fce58c0368c0369845a5e4bce3c72ad91254f830afaf5ba2abbd59a695a1e4d71b0e0e8fcd26ca8e6b6d0b97e053971936fef357f1e81da61225dbcbeb9c6698c110e753f56d80b57c43e60e644e4e46c2fe483c7a23dc8bfa4e956d60378c936ea823d5d3f26d201d5aaef380049e537f62f179648a17b2b0b8f0ef77c3d906e73dfb4b854fe4762723ab376bfebfb38480b028be378ad5dcf6c21e1b32dc32ae7f8fa39cd0f9f9a76e283d53f1051cee77e9b5ec10da1761dff477386358aeb39dbfff9ab0b5bbb65bfca0e5ee3ec8a36fea6510d0951bfb1df02ff0deff586d2660da11d5135b3e90876b32c990f4c7a8d6f4929750655e8565e93f98b1260b82239defcc73c4a8dec475c666f48694589bcf1bbb2266f2d9f722ed4d73271e0b47334fd9b0f8ede9cb332703856e4682f9d09ceff8a9380f3ca85cd126192b911f57ca503dd48b91245d10659515ba281c966fef879995850e688f71dc22aa256d7eef0c4335be37d2506ba3bd7680704a27b931886e8bf54e3b050c363e77de1a7d9d72d70ceee6a583d0e512d1584d78b529a511e6a48aadd097b57befa7fd60dd544563e4536fb66033995a9fcc1b879f432fff754981e080828562f62e2453cadfd73f8eb56e2359f1ad8b8fb40fb6f12473e61584d226b19af217f47d7079e486e4bdb581f9cfad22875b35c750494184450a5cc78a3e4a31d50b0b1552a72cf4857a7c378ef005e611f690994c7e0374ba9bce9f6dfa76b3e9e2c54c93c2d2ab494974e7084f8cee4974e09051e83f2022a80e97b9059c471c7ae2e6637b2fa88b602e8d0b667f68f0efd74a6297fd593e1d035818b4d59d5ba24c5da6690b51d9609cc42228ec5eb829a043b987bbf5f7bb72a9ea013e9d73abd2975073da7356b3c4f9e6169afabaedd2de7caf6d198fc0073f668bc0b00e7d6de5190f3a35d2a88a18d4ce8c0db5c6b0e51b1983a7eaf016f206bf1b6a1f6472898cc33e47bab99a2c87bca52f65086133e0bfd9940f8ff45ca7a51eb4f6d0d298bf48a526f4e3de97c232c347b64a66361d34eb23f4ce592301ab9b61f32d413dfb9745cc9e390eaa00a86c5526e0e278d400a6e7831d4e583d8f7b3f509c77488811dc71d28ffabc4db472feffd5141e4d3cc67977c823f27321d134279a1e021282fe16edc96f5920f7dfd4b4f667b9dafa25f79abe92bc705d956b66f81724431fe1368378b11d6643b7b31ec608c6b0d8e0764a4b8228d288e37e031706a3c34e66d94ef552dc3851484f15fa7c2e17d96a09bc5ee2002c7f48ef96cda70959ba64ffa21752612f8f736dc3bd576195bc5b9c5f4db125f698b014d8b478c28a24119354b4d5b13242cb3d1b9b7581188833dda26d6a626b7d3a95f888f5cec230feac16ea26e2362a3b12488e256fc586558564e624044ae0aae7134b8b2e88d60a54c02228c31f1ca9bb201397afd6b07ae1fc7004ab2aa0a453eb71b3bcac75f9569a20e32753a0cfdca2af7b52c68dfd784771249283c991ea22594f85295f9f0008c47201159c6ff1d6bbc1ba212515927045a21d4634fc39760f9a3c0925ee79859ec7abfa24e8075da377a02b09f099cc07a034e6d3b697e48c97b8e5a516583ebfe738b409cef796869287ae00c1f77f761be7a467a8b14d2ed7be707da43b199e7bfc539448e30266988869c6a2b5a25f2751ba7f7eace96311049fed2ee9d62ec5062c64bb85991fa48167cbe42a94c19eee1b834c7fc92889a6369c95888bad12dcf68160a93ca683868214ba009143c8f5ab99a007cf13114feb250ca4dbfc8dcfc21d2163a374d42ebcd39639aff1016c75baefe602f2d21e4ac00b592603da484cdc85db54509554865f3daa7b5ae2c4d7ece4afd864492674582aa4d68eac21027e513cdd032c5edc1a197f0a8ab4b84771f712fc68b1571575512e490af50f2e3bc593764c1d961f3be67ae02f6121371206fd7a635d3e16de758e23ec5f1b9b6819ee200aed8b6715cb1f23eed6f2fc642a1f85eddbf4bc65b334615a9ad6c9bfccda58f2abc1a6968523779200029b9d1fc521af91ccf0a70451605023e968d879697f7fe2ec78e0bb3405985fa352a327b9ef43f823b276e50268299d7a4a0fbbace885d960e7c5819024993bcb5aff90e3bed99bbae9ea784b1f16585a980f848162bfb373072ae7d0055bd654e44b8e86a29c114f29615c0153768e42e529f81d5e8372dcc1c651e21e1c186d92832190d09d0d5b4c805aefe564f3c22aa30d49ec5f56c3315911ee8ab4b68af9af9e88e05586bcad07baba951852465b7060a45b0ea1d6e08001dee579160613e677b2a554e1abaf0f382b62df83f8b1b64eecad6f796cc809c2d3b8c45545e2da6795e2265078cfbf48138816a28b3f1e73f82ca1c28f5fcfc5ec759bcc8745456dc13e94a0bd378a5e0d7e186f1070af3de7a61fdb2fc5e92ecc2066615382aa7833409cdfc8e00573d2142f0af97ee2236b269d6139ee03b13b4d87ed420e7c3efadf14c821134f84cfb1b5c99bf2c7e6032a67116eb5a7e20d8842335c5323c24e31f6aab47ed28b9758949f49e1b94a35f716ea87b278481362ca5d5bd98347bbdf998073dfed04d1c44111a8956309d847c67102ad4dfcb9d74f175b18960e9fa904dcf4f0249eb41c4c4f04776924711088cc298a6cdfd931d10bc26be0122a28184c753510ec7b0784c87633db5dd39c5a04874f30c302bba985cbdf89ebf46fee4b83524003b13865416609dd26f1ceee81337ebf3660256b8185e289d2818d1c6a016c1a1f8744a30dbd1db1a0cc3f19029135c76ba70b6ac132dec245330b62f9ff2b543b417f1ec082b2b3f00f4202581f17eb7c4599569567a291769897f9318343842f7317e1f4a6b2918af094a732500041e9f6c03c189cda353530faa6a32efc411592068880fd4354272fc306d07b8b3d1c02bbfc1ed4e5dc35b03614d0049a82bc230a8c59b78fddaa5a3f85e8f7b94fa37d6c7737f74adf44b30ac1c57bfa12696f06647a1a1bafc077d5da6ef9a23f6c17bde52c2c239e126e1e14b05ca4ed2473b840908b266170855c166c4d9aa07aa14a595f75a24da3f40aa6c61ccb5d5fdd2f2657230844e3828658d090a6f936ab242e2171309878978e56aad108ed189e32af0e7790c45e4160a81ef4359ffb547b99fe28e6ef8439b6df975985a48272a06ded03a117df5804311f4d8e75d1c992a72368b3b6fbabe24c158ecaef1d9d9ed813b574ab9de90ebafcc0b9f44824010b4d435d6760335456defa85a79f358df27c27a0edb3da9e08c09efab967fe2e6298890aa14e4b73a0d379fcac57840f5f54185fba135f96ddcbba6c27a9d1def7a0404d3d0b5f48d5389370d364fff0424880f9e8895a9279a5e25eb16af03344369c83c969f856e776eb5cb7a6377309ae7331e12196b52520a4f633da348ffd74412cdf7c2e8b290ec1e95af108fc1d002234a83e6d93ae421b1d8bfdd8bedf34a5de24fb4e0dcf2afb6e14a25a4838675c95b956e56e476bbf96b0ff43978376820760212d16dc5fbcc4b53497403317285e71b6235945dbcb4377a45fefeec40d3231f814496b3dd5f8e48b617e2b80764943491859a81e989d772eadd2c81ab37af76d53392d4a9dd9740d99da4e96355e96579f80896fc774557121df27a54271af42771d0c06246a3536858056ade384171d0350e06ca61949586dffd71b18592f90b15b4dbc77d061fae2a8334317f06f5bd5a0c73632c2e58eb862717d80f517dbfb161c5345a1f7c4e88f2d89e60a44d07bffac9ddb10b3b61a2858d13e9c19ff6159267c4f5852283833c6b41f6a7a89d1673d520a054c4be9f5b4f041c2c8f316310e5420c768c635dce4d00aa5db958ded60bbbfe7b918aa9f9a2cfb7ee623a8a31385ed9664b796755d1db5daf54e5239a2ceaccc570db6868cecaed14be20737cc40eb3e810fc8bef3bff125d616c11a44d01b8fb5893cfe1606202642eae823b9d6bfff523b725796c2fd7cc6ec4ad977f506ea7ab322a6d8c3c1101d68fa578ef339a76f554574241f6bfbd16c3987f084685439a6cb843f002674ec05bd2d5d2666bf0097edecf8075466e296659d9733e927e8b26f406e062e83d085e2555aa2e61379735b7ba663eaf3966a5e882991406f58251d8fcd078842bfb70d1a9fc3b16aef0be53abe8192f6ffec545f71b4852a78ca0eda99ff629eba1b149065c71a2f357e5be2bca0cb36aa3c702969c355c2f8c2bdcb18f7670cf344d222fee5548777af5453086ee667c9ce0f6b88afa12217af4cef4115f94484c125ffd6aa9f886821e0afdabae8975640fe09daa2718c63eac45ef0f9838287be205062c6ee9988322c61e1519138a7a9baf1c9b552df2612f97bbed1638e9ad20a720a2bc593ad5c329fba126c405be6e0bb24451e83b6bc5ef5b4e63652f783aa3b34c111eaede9c16789eabb420a2faf69930abd732a2f15845c2f85822fe38d25f021e8c0b86f7e15e0e3726ad822b8e3edea8f630df82b9ede7084c64399e5055346f831e8128662f622668615e4b60c55e9d13481753282850e4315d63b82082baa473a9bf5b3b7b58ef33ec0e94efc6b1d6c2aba0cd5405ead31beabf30b5e08d221d13d9bab714fb750c7c934fcb96dcec545f39d0cbaa1446b8b7e515320696e843ea8f2f286b56dcc65b4c5a91ac0b817551dec257b4b0b0f45ae992cb15fb85c63e058ef6ffbd65757ab7a6238a1ffc054069f64404438b0c8c256f8a505f5e7b41614564209c5732ae3eeecb7795db5105e2d0ca73c5b141e7465f23a82e97373628443fc5df9143a5d5690bab536a74e5f735892ebc775ad3202549d0d2077e574b85cf68d755146b2cdc061e3b96acf112f9cbe8087198877ba82ed3f7e016d75e4bad61c369da9639168553ab8e4f4d34c2ead33ab047319877ee954264eb95728f33177d0004660e6afaa448785b6b4e53aae1c0ef73837aea11c0f443e80875d41a4f6358ee5b55c8354db6d05acb628496a5bb66c540fd1b43e514cebad64ae6e6061ccd52b0deaa99029ee69013f379978c8d35b539492735323a96abaff254e323ce5ecb6101cfbbbbb0e25b60494ef4c921b47478dff62e8371e0b8fc310dc9c590ae357eeb3b19038a2351512c7d685bed9df9c58c7c306e637c82bc8323af12be48d3ac77c2b1a89129cb92eaa45a30de46787b9fb0aac9e4bc8d84144c931fe70f7b0f627a8baa2ae62b15bfdc9d1cb70cd11753e57d67d82e31fb21b0e87c06e4eca02dc9e5e62cace146ea65ad8e0a7f4f5de07937765a92e66ded736782318a1281c50777fa8d451872c070cd153feb029fdc0a6c1d661e5f6a092c7955d301e3731978ddf293fe2d53cc33c1f81a947904a109c0086e02e3397ab4ad1c50377c90e637113ea26081823ab1b319024d824db8a6e23c34c92ea57462c4aada5ae4e5f7247d7d9c6a2aacb6516802398b09589c0d68338f4b141a96315d5147f67f37645036fca2863fc99d11824489a757e3aeaa7f1ed4d0900aac50b27558225b94554fa1e817833b7897453fb32f5aa3bed2cdbba4276a007c6a5bddb1ec2a5c6baf3be2fcf46b863f48002bb2c3d966c65601ee18fdcef9a7569fc22ecba18edec196c33bedee441c4099b5b1deb8e8c52a9070c859b56697ffae3924a25246095edef126fb6aa4b66c18163c8e3e753f096061fae67929a20ed16f9895dddbf6f2ccbc71ad5cd5d44db694bfe15c281b9bf811e2a49559222d0fba1c128af0319370998031a78a330657facc02c0a49547ead676ec0aa4d18134dd7982c1f5141c68c5416d43833130ae84f82e702ead3606a7cafb9681cec432a8ee64a217be5dfef17b3891c12ab575f13101a109ed0b935655713be0ac6c7deabb2e738b985e9db62cec6c56d508eb729c1eba917c4db7cee6a207ac0e2c21294886e9348546a75be7db200ef0ef5a38801a40856b8c486b9045a8fde1f85c9bb583224b62025c1a0c63be317a44ddbbde962691a35831d10893ba8d021110a0083edf975a3fc21d08304c0f875ef1a766928e50720babfb788302cbddb1bf0f00858904e7321bcbec9a20e3118a53ad128952bca047b2d617a9859039989c092319989aded503c844772f7fe8d8c60d07a30f8b4fd2d0e2a2a7e53e3ae10419b65077e9a433ed52fc496298ee36ec1dde1cf83fcf09be9263c18e4bdf4246b89c9b5f22b97bb1e1a8baa0c7aca441003c8779880479df033504d7577c66f104f13f49a761767b9ddec317e08a56f363a08ed80bb1c13e3eec80cfb3ec906415b066ee67469dbb26c0ee33e1641cf09439e34157794b394b948f322c2b07dd609afb5e9695d59ac245f843537d0dfbbdb1ea97b908a0f12dcae520b12ec353546a60904377f8a57939cce9fa5f2affed3034cb0651d5d7cc0e12fe170051f9ed844786c440e50ecd5725397315c5a3035bd232f735c972d67dbda651f9c93687b58c3b77324bc20a2285907c80d39d58a9db12ad2edc401ba42faf25528776ffb31d2c41ed7c5ab171101a1772535fcb03ea80b3c8948bfcf2b359cf59ec4507a4e3e1a99868817cfb950f3ff95bd571aeda07888500dc3f9cbf71d90de13307a986fe45c9d941791ab8a088cb73b188dac382d2c1412257eb7605c62de970785d54020bb91daf9df75c50710f0c50400035d6a12e0f4eb91c62567b815d7bb3e28311bc4a5e2df60e6c9322412821b714e9f4903bae82a862992c6c6b9634fb1c018c14a5faf65e351a9f3efd6c9e889bd9a9d399501d0c9fb0acd25304aa721202bfdf2be6477f1a601676bb08893d3f909101ad304a80a9555e6cf0db29c3f8d5ee279ffd205204c7c55e7436694bc4667347a5d2fd871ad8bcbb8cd9fd6478c2af465dd45b82d8eb83cb509b91bdf2c0bb1a5545de32495eabd19ac80e99f600d56e86e82240f876145abb69d248c42a3dbae2d825018d1a6d1b839e7be4771cb6525043123c8dc91599a2cfe1128adb017013e41de008e489dc8d35bdcb44faa7ce2ca3b374d6d5cc22c1253bbe9adf8a010337c2bc6cec08161077ce34d150e7dce0db612c8ec94c29cf84903dc47ec30ae711f049b6cec460d20f813473cb719c1ae88e5e68d1ee90008f95e82064dc34f822adc98778c05138eb0ec454ba5225c736a5b604aa9efdbb7ab3d532d0e05bcd737af6d9e85d659b235db3d9e866e71a173cfe7ff92b381c022c21f88abb197fd08bde1b88c022e565494f089e4e4776dd46be7bdff2d1d46093d931ed887abff840efbc59dd76021a7f68dac390f8f535a114edd72126e18bc499648f7bb2d198712146779c4600138d2938d844f4e8f7573bc38150fcf079188ce28794060ae95d7a75f1f11734dcae4e4cf9d8b0c85c31081e81128746034beadc9cdbdc8ba7b3057402e7a91526a43ddaf6bd2e03b80bc8f6c2b615ab76e3019d22e3692f5a7078f2ec833c5e2cadb5e1e3ffca98630addaef8f28b29ba3124865ae184caa0e82228e6123f979b80768f540374c66a5a916737706640d2f542ce95402303802d23d35f434472ffb3cc3a8d4004b7bd71cd3bb368f81d8ff7829fe72e6bc454e11932498fb12d89f133d61b5042773be119b84007f97bd1245174cbd5f98c6adbf4feedb70b972aef0d85a53ee2f769e92c2af9513bec26f03e160192f2dd2bdac0d503fead012d1f4dbd374924bc71162b72fbe56a791820a08f2c8cb18634f9ee8df0583284d870640d3df87e07f5a1eefa3c1b9d0cbfc6fbdffe3d0165a147939149733015822440a15d744cc07a18a3c9db797a67329fcb9bab12391387a854b2cc11ae8d2d5c6647704110799aeb94d1a1c8a484ff2fb8c9669a47e4c9d4270ba7cef91bddb9b0a6ab97e3011205c48ec89609ea0ab08bf3fd675ed6d3a5aa781b1eb9018bc88178e013fc1e7703c55bc9cc66789adeab4270ad55a9664e00d809bde10f55052b67aa2864f341de26918c0726783a635e54fff1cecf0a1b3d7fae30b685449703a9bf5f4b7d607bcac20a8eca0487a0da7fdce3de856f666570426148f16cf31c91005c7c351339556228f33da91bead1dcbbbd48e183ea9dcbdd1a1ad2b4df1dc3b9f9df166e9be7d8969a1167e4100aa0860bbfd2415407ec21daf933aabaa0c0fe71b6930d45657c0b5823398c55206291e5a1b5bc64b252d83558eda3ca5927ac4110e9af6439889613c9284885d31e8e22b41c873a607b456647ec858ab40cb9089f8071a22ff3cbc59e0fe24e3bbb94c39da5a81e01e9ce1123d0bf255efa958444d450f77322f6ab928e67318932f26569ae96d8499490d851d20bcf62819e56d6bc151a7cf6012c42c261eeb04e05673a4e4c7ce42ee48c38c58453070512b1f829520b4fa045dfbf67a0af5372cd573f4a06eabd426dfb4444d2bdc7b6d2a65b4519b3ad4bc6eea5982a90dcd2985490804bc5a1b369731fb858dc66b83bf61d8c8daab46495c35e19925dcf8e3f886829152320420d07e70c90adfd6433de7079e1d8258ecbf0e9109c73d4d8bc3920af07b22a5e0ced5c8850771a9b2d9062f5d8ba2cafd018676aec7376cb021cfa02778d110228f45f1994fc46dec622589e619c2c77a3d797641b7e40eff66707b11bb8e4b76a71e7965f26e60361aa90839730198aff9be4a9772daa50fbf87a8df04bc88ee09690d7c9a8f458ba88ccd84c497afed55c51cece2135093bc77072ccd7b419498532e3f81b71c8b19237cde7c37d66ce5e02e4e8a88dce16d478d41516e4ac43f99828ca44c57856b4c2f285f42439e94134adc8a04c23e100036d6922599ee022fc885bcc05d8519c20e79434f02d0d7d214257e3b5fd9fec29c826af8f5ecf50fedef4e4ca33ba16646c0c4455be7dfdbfa050b681c583bf3534ed355e115065ccc58f0b4c3b87c669da9d90eb613567e2700c60901a56e81a27695d44e6d9ff1b929cf3f327e23e15c75fb1077052e07067566ef760c66e3c20ecab8e90c9042839a36065c3af4924b9345d10206a83a218ea9b519075e2d633b893c264be651b63b13f2ee9fde5706352bd3b0a1f5ef34be049201934526026b53f51e04c0ec54be1a04bac73d6f9c3863dd9ef180a49316fe123d262393003513418b408af90a5b59502e643ffec61b2c7a5530c52084faea64733a8552a84b8c4df09c909300c8378a514b171b6861c2297c037d58a53783653a808b447b57928e07ce3b6a63f4980e696f8aeb28afaeaa536209b3877a2d5aca44a838f78594814d086a1c700e03e8d7d65d145654297e2933449d2c5310257aaa59ee9a220a93fd560034b805482d4eaf8cd48f0e76ce4e917b07986339b2cc2f4c8471c4469d149e7bcd23b207d551bae59902360a972f91cc121b0c0fac45977ef52264b596e3db5f8eb9e226f83391811f8639b42422c429ac4dd143e351536bbee384dd19823ecfb765b7c7308138a4c97e1c57fcaa91c3ebf4009f2f6850fccc0194a90cf39eb0fd9e26a8bc44141a289e483c514c6eb5658ddadfea5569aa1cf8e1ec1a1f22179f6ae148f4f82fbc37d5a19f254833fc938414d8fe47920ab1ad0e573d71d957c6d3820a7d77c5261240a70b3723a24d4841b9a6c213343a251091503af35d74dc9ac0eee4ff71565d625c9560c60d5e816e323c30fca87fc3331b0300734693283f5970e28de6f3e0a6ff26ab9c1918874859ac7ca0521eff0a7c3ff5ada668e4dd93666e29f4588fe2e9c227666a5acaab8f89d2683a759267d8431514e1946ea20d62292b1e46aa893066891fe528bbfbf4acde372402be82d825a8ab464a8b1e0f702b54b4fae1ae789c58dad7d8606176eb0b9f7b4b1e8264ddde03b9b833a4fd23161cd4fa3cbcff057b46a31a6e26ffa7c231691af6bd2b4d5f9c10e62d32e62ba26ed63bfd78bef1aecead4b7e2578593639185150dfbb141eed4b2668f5bcc7c6703e1fa6b8a5fe82072c268042a0bb93307dd9c18903fdab5804761881d89a0e84f79ace06f634792fb426809bf3a3a84588a6086819cf200d1b0450db5e6c01cb305deff235d50986164e96720dab40ac46acf82dec30a372ba13a6140b616bd789cbd43eea1e2215b8b7bfa9bcabe6ae7fb60d032a689f5157af91dac0924bc27fe1f72778e4388e837f5a29b67fef8e0e723a9ad99a338dbb8cf98eef7d0ee051cf0ec78d1d9cae78f11723c98bc762a60f32197c2a530f4fe31deff4ece85d3cfdcaceb02447686e04eacaa7f9dc72f62a5ebcf44b36cbc571afd588676f0aa042337c7c389bda778d52ca9b2d6c89c356e47af851e2e2a00ce75bd8a7bff7dfdb7e9cc83ce67b94cb176516b163ba2bad655d2f0c05872796ea197cac1956bcfcaa41bb7be13c65ca92cffd859f3ba32bcae6f4bd46c1229afd84b467768dd1bfc388df62dea07e4f8fb82c220f015fda800676e5255a5f6435c8cd622cbcbd34eab627e8aace232c8dcacbf4cd771288dbc21d3a4ba8df124b26cc6fbb8ac8a1c5bd543bad7fa51a2a7b8acba07219e435a8c9594f103c5d33e8f4dc614acd318ce2688a253756268bac43260daa8b062f2b0d8925c9de96e07b8c19c1b38bb9806c5ee87f4a1d99b1979dddd241914ddc7f8fc614ef6c9bc5867736e2aa5b6291bd9492e3adea18e189de76114360f25c1597bb336c6a979e21dea9ee6f12199ebc9ac1bd8e29ce8a5235d00687bcb1ebdb99eb2456f5f6cffa7f85ef6decc02416da5adffe55f930e71b33f5a5ba36472aff60d96f0d78f1e134edbfa12480dbd7071aacc8fa41bce176504fc538da83904f280d61eddb4521d91a32cfd1b1f3354997a103fadb3b462741315e0ec96956274a4984703c7d76a915972aa4cbfbc2e57df6469458757ae19b132bdf5bc82b4442d502164fda3328b361ea235e3179f53b08fa949b50a71ad60d5dfaf1765ce17c65897fdcd0b980e680cb82d0363776a4fbd07e61fcd91ebbda3ab4abf2ba43ab529e585486a88ab2d52407695b3ac041d7eca4b3517e43c7cb26feecaae79c8b8386ea3139e4e9d82e3214103020c1d2bf2cf4377b9ac1fc8e2cfd7b2f5ae0917be94036982650c78368722185f27a88b29f5a7267c02cd84671de48a6c6005e41fd9056698a5049ee5910d1a33b75915cec33f6a7b6bf10236ca41fbfdc488db0ef1685d79632f1ee4bc984e872b54ec3fd4cf10eeaac86025d88ead15065de52fd6133d1710f1c22fd043c971178d4ddc9698a4fd296321a781ff1da199a17d304226f5ba568d55c155088ee37162a5233f7c816e6b9a45a5a7b4353150e7925beefeb72b4ae14150b109604706c284be5ff6036c38be043a9f7c3001de4293c1f3adea78edfa187348a8b7218d0a57d8a2644cd0d01ba33d9768f40425524669fbbe50fd390ca86e48687b9f42ca51712098d4a1645a1c272786ed68f22ee0dc5dea4c978e81bcec75fb5ec77926ed9fef63c8c7a8a8cb22416fa3bddbdbaf0be69524e2ad8904298e2595cda290b01fa8b3553af76603faad83c3bd74aaf37fda79a91e9046055835c6738d7ec84b31f9faad576a1300c937cbe3145d6a8eb6739585a077939d46e07a1886be025388f4697fc17c05614be9f99d05233de6a2daf09d593b9847a507074ab8d504c865eaa073604562eff11cdd77d4ba1cd53f4d41909251ec922d668aae0e8769724e02c2e764a2dde6040fc140ff3fe01021c37384d99e3118146ae6799ea674ebc7919e40cf1a4357b0a17aa9ceddaafdebbf96aee4e3141bf6d49397d990810aa92514d44f541527d4acda828c11a5a584218ae259da4e45b33a437f71879e4e6729266a39518d02a324361a34e7232168bc2361c479deef38e84520ae99c2412e84d7f32de1cd674a53cb257466eca8931cfcf53d52c871e35aa5452e7fe16258e2dbcb1561a835268fe9e8fb6dcfccc48d8e27bddf899767c777f3005284863fec4bf5683a8b204b3af4c60d6063f43c5d11ec66dadbd39ab9f4c1ed5ca41f63a5f64d74b687c00c3326b15e5b27cab6f374cee0cc4536844669f26d02a4e1175ad784728576801f746ed266ae6d9b4a0c06ad099218da44296e5d5a2e093d4bd140d947ed47cf39fb08e92491b094ecefddaf1de1866df75997041cbd90ec8f40621358ddc8830b69e6285346860d59862540382f2e85ed45f1dcba1691295b9be7579153283399475aebd5cc1996e8bc1f79a48e30e5a392abe3c52bae70ee66b42f16277f5070bb304f60895de48b8581a59aaff8ef8012b4966ef4d51b9308aa6b847914a06774e1e3e01cc820daf9d317be793abeff4e1a922930cddce7a6160ed890dad17d221e1aab1a35ef5d2c5f98a00a3bc85ea24c0612b9b9b129a2d3f74770595acf89a17371c8fdcfec9fe002b43e7c64ce9e3d1e95ce68789ef51dac2a67bf2f562e4bee9b18e686c6f9214050c54ca92d52679da697708d194e61293e14df51c8176eae0ea76ecf7342ff5156104f44846360cede542976d5948b89ab3214c3656aeb8fb5320619481d43831c116ba392b76ded3aff550e21850d9569f7e7f8b7cdf9be208549e58efc523af3a3f1f2359ca20522ae3ae43ecd447d15df256545f1adc98858b1532112d6bfbe30ae11a7da5b50d1ef0f4e2b09abc31cbc2f90c3fe1183d18c240d187766fa4525b107ca9aa596bf59c89c45293013c464a14ed137850c6bb7e267e34b84abc4ef9a05d8a09a929a755b488e56a89e909fc5cdd9ae90df1292bb9713ac775efbe44dc21f0c97dd223db0537379076058c0faddebf864f6812d267c0b44aefcb21fe6e4b660e66b9b13510217bee9128750f3a967e58716abc941c978d7fd97d9bfe6fb3c220ea626282a997a366bb07b7e0186472962cd705f35121bbbbbcf0935342615ce72b48d4364396fef6b4588defc1de6d41835e317bf0a5e20fa723cd7ea31e09a2e765cfc9830db4ab42514c64cbeddbf7d090d3af01f08d14ab1c59eca0cdb7ad078cd46f98d12495d229e909e3bdcaaa0b8d56a89b6db6cf6b8b23cfac2df7c58198a94426f1a8fb1825fb2c56884a4d0c415796b5f139da85f5deb8175d0289bf53069fd70f00bb53a5c0a4d278651919d274d6e3eb1208d502a786e7f9466133788e8d5daba7d0efd2be1fdca058539d5901e9da6ea4301287881d89671100fff2edd64b76036ecf513d4915e09327e34d2e8eca54c507a5f41bf62cca1fc5c7859147a9f2a7dc4f677033f2ea347fbf1526d9c2fc2f676041bbe065b43c5f0424f98505ac75189e2cd4f361d4a5aff3e0cde9936a8d135efa43f0c4cc2c50ebded926e44afa755d404b7613d1026fa87eecd5aec9437afddb323400ef46e7c4ea65c9e522536c7b89cd214e4b5bfef4074fed8893a87a84296a322ecf7bcea8257e0483a17e456ab05fa52033bacdcc10b6c31dd1e25766b449f30fa9fbfb7aec3e2144fe97a50f9bdae8773dca739a4e399377efe5a7f52e720f48f67817450f931a6f130c4ffc208f183ebc094bf47f6b764b28f7c918dfed6d5e8b109ea9a248a919d9a78f6fac7be9d5ab319b4349b199ce6434d6de3986e6a8ab11fcc5744a81209d844e0e58ef0a878cd51eaabb91bbe358ff9cf63c48db42c2ba3d1f13d50dbd701873ee3d30dada86ab339847023b71fbc397aa4733766b066ef908d76ba9ad18db71f5744e3cbe1fbb9d56b6ab889417e7c1997a12a00ffe3626b0bfa616a85e66460340feadc99b5494402905082482930caa30989faa8aded51de5cfac03cd0cc47f8f4eb5a5b2b5e351239b2fb4fa72bdc68dc2ced796418fc01bd236c3dd0269d6795ffbd79a71bbf56621237fd29b1bb8061de4c1642cada16e4c1a08c5b50e502b861f3f73c8509e46a77240ca85ff606cfd21fdd9a67fbd97cc8a98fad4ebd0aa5f4a9135084d0ca59644b18f9b12dcb7a5939cd1886607e16a0909a58d4e61ae9a7153376c3e29a4f2897f6ae86cb5f4dd8e9040fca0b13b3519fdc0529800f861610b965ef9bdd77686521d6495753b9b8a619159e14d7ede490b87306ac2c2a6577e5642a03bca7d75a3877ff2775fb51e31d3d8d1af65ff6f38ef317da073ebbd07e6ecb02e81772687765ffb4c00f3e16b9521e564d4f7c6fd1276851bca13ddc82e26c6a99ec7a0195ecb10f0628868d3fb4230500eaf6711a5fd2eba3117c291df7411bec30f36ae58c3a227887e476e16ff466b606d1b571513d538919412f0ab2be7c5dba276dd1eb2c1bde698021fbd5d973c768c23f233057b0fff6addf6b0f223f2224d4344907f65aecaaffc9ec1c245fdf572de80210285df4ee9e3ae7c65f0a4395d94d48adc368b850152a14775b11d31e8ad63de7b9c149dca828b1b6520b658e94b6cdbe0a5a0320f32651f03da854f3edfb4e8a54694ef6dc19281a4491b9a2d4a87e3d21133d6510666d45da504abb1e2108cbed60621d9bba3c353cbc7deb77caf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
