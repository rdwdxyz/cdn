<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a60e4185670c261003290d92636be15ddff4dd38fe01473add72fd08dc2d9d6557a89e5d34e3ce8ee780cf57a2d91aebb02885e58737af14d8bbe90f8990c5f149a3959b3bd9a3f8af28831cd887d1986b3d7b0431a078544d1f69ec3ea7ed7fd1a93dfaf627ffd521448cc1b6153877354aa5e2480f83ac85d096717b741976c78b3b2d4d4f202874eebea2c0a8d5a9e4c94ba72c71fe8875e39e1ea352e451c11ddfb0a10fbe626f23a402530249237bff161b325fa2432231604a7899f7a4c876bb8a563621f06e586a6d4e84a8bf14b635a9d7d3558c443c929897d7a626267e6fb66cca50eb656f00b8dc9d998e9ba9d455c3596891b3f006b0d31bb69d873fdcc12b230dad3bbb33e36135b73beac3b96657581dffb9a19dd21a865a6d5e899ba87a6121721f6b805a75f8cd9fe97bff5566be89f53e70e3f6c66656bcdfbe1f8b71cc9b310bac2885d7f95e563ab275c63b77368666daebb72832f93288b54b7804eeb0bae8bd8ad04223ed29884f530811e405b069c6d84df0160156c3a4ca74b72ab06145e8e29dacc93252a9fc461bf7a12d296dccc5205453c19a8e46fc26fbe591e02c93d5dea95ebbfb3223291ee1227042dcef6e72c67c8657d77b26c69b048bfd4975f78c47fed6fedff6751f6f390aae6c68eb1113c2ab2ff0ae307332b0f557f953c94856359cc5aab3a28cf0bd36b79cf93adb9487b81c38deac46ff064bd5b71e985da052d5af031b7449445b24bd439074f819bff0ef8b8ba33cbb689cf422cb91434875c03077a8e7095da3ac96c8d955d53211af4fdbf004c51a133bb29725c792526d8cf930941b192a7ba195ab7b289fb229eeae75e428e5ee5afbee1ad559929f4bdb2b55eea70321e9f7414e657165f16dc201e9afefe0ddb339ec61eb416ffd9b3831440eea31b93524c19183691ca8b4dff780fc82cf63d8820fa6e0777beb5c66aa0202cf89bc53eae57cae77e5532f181f55a8f8644fefca365cea4869fe315f9e4774463bd901b4c9b72dec24bc739bb9dfcd1827224efd0b6a00bffe61f3f6390ca68cdd0a323b564b77402b1f5664e9fed44af43942a3497cc3cc4986aef844f16ce40e0b0419edc455568199c82a8b24f64ca1db8ee6628ebc8785ffeebaffd22207923438f0c9d12aac0030fb27db9e5c8bfba84e8d084199b8d169f0aa515d5276774be22fef8313aaf8466d9c92f5c18fd1addfabf0b5a8482fb529581cc8ed59f6608ee500aed3dddc5f6d3a8b33a4c992e5bdfbf6b3f71450d97ea21915adc09f61234ac99acab24bdbfe2772e38d841788743127489ce78f593240a7449cb131862993f69c56882687d8d01645fe845e195f50a10efebec1c3c32574badf8ad717fd2361d3d44de3aa2ba92885642b003272c06a35859a526d690f8e4c8d88b42f56e28a2609a7fbf2d16feb0945727f3dfb05bdb3de0914a35e200f31de73b407d772d9539bd5fedffa8e02326f6690aa1c400396587330c98fd642276522261aa733fcd08a20a8ade4ec7274fa353ab885f085314211e31122bfae613b5bdb8e8763e88dab4ff36042cc3c9823749fbcfe117474e902035559f5e349a427f33a9bbc46485dc34a9aee4725213744ccd429b1c435c1cd0cc2edc91942dc8e6cb5855f3adeb231f35da1a052136f8aba00b0ab96c4b4b8af337a3682da66ef502c84dee73cee5388bb9fcc5b5eada9371fd7b0fd32b28e431039a14a17f9307bacd7fec5ca1647eb98a35cbb0a362155612a95a410f350c211448a8e7c52e0d6281b3227275ccad6a0ff1afd5faca19edd9e93cf89e8100102d6487ec98c8bfa237962af3795058419d38e4d693fdcd3ad5d9d0da5df35b98e6801a545190bbaad76172f5e855c4ca50427724761c7d81e510c253c22894d1eb637cf6cb849ea549b21296f19dc8f26fa6c153cf05bab8dc96efae9bc1817b6e20d0dad5188819d96906631aec26fd4ac558a15a87c46016c8a1440961ca0a081dc6446e3dc42b4ba6bdd8c3c8757d1bc89b4946df79e7779661d6096cb8275c35dd688aea281dbe2fb3a95fa7bf7cf4bb240ad49d67b4a3fde1a1b3a4ecd279be208ffd2c665af9a8c5f1993a09b7c544cab6a2acd8624ef1453df87a89f40f77d7f6506ba3686368695731a2d511fe6cff32570a6152e4bbc1835dc4581d424d0b656f89d823598fdfb592ba7d2d956bc8e8d5cffb4ee6483f550a1825fc1233a4802a37a37b6148246b7daa178a8a856fd990ed7ce31469d133610956706150164cfdd211f42abe510f3090c7d983e743049ad2ad9e910a0949c25566fb26a8289271ff971a41eccf5fa55c278be81332f103005bdbd67b232c1cbb3782de70480b168f7a1aeec32c6e113719c8aac08dd777756f7effb95b4ca44895af8aa0fd29f7ee160a204098b3091e4b2a2f8ce87b6d78b36461288b8270e6ce328458bb971fff4f9b8c0f0478a3219e7fa8aedcffb03b9c399c9970a596f018d6861c590635a70423c1ce19ead9ee8c6126911e409aed600274d6d5390b467fea7de32fe58b16149f67596da43a53f566a1f33ceb23e1cc91338735b57babacf209982e02b1cd91ef7d7efe9565a371b7a90ddd41d244cf3b5798f9f60ab819f6f2c627dafa7d8a213dbe782da5ee38d4ce5b04cc6ff8b9d759d8db1f6301d0136018e10b7828e8c3adde40950f3f0800345032fff3b4e252a80f7401ef17c4588bb6892b64c1e80de9c703871102e83069513c0bf71cf5e15f8cd6cb870e6275238f4dead065acd8d488689eaf5537519c92b22ade55553feacbb4dc635d7c86830d3f176854bccb6b6f3133916fc94a7b1a9ff161b5e84f6173c05eaa378e062f58621e894b05791e054444a94e6dd56edbdb3ea8949138af07cfcb14c7887248b056adf57e9128e2ba05762b13cb7e5dd7092cc4e4f1a691629bf9777332736b4ef71cce2dba172c7257ddd4d695f05bdefca04eda229eac6d41f3a0e2080b7e9e9c10e88e4583a0429c7f5cda384e76012467c3dd9ed1ce6f0c8c342c14bf29d4658389bce07bc1e15b31c9463e5d71c367bca33b8a51e7be6a1c767bbbda315230f32d370981f14a9b060cd61880a62d2efaf5c06bbe3f628ca92525a4bddd303b901fc899f99f861d7fccdcbe5d693b88ae8ad9104300ca7dad9afcb1f5febe4f89e6594430ad218c20442ca7552781103c6ace8a648f6f76a4282193fd1903802270f15204032efe7c2339fda1d543b228a54f8ad2e28968f16d44d7e0a103d5cf33bd0c157ff602320d8076b6a826d96f035c6d965038e40cc9ca21032588c144d64cc79e06538a1c8c6e75023d0edb6a3a9432daa6e4c3307aab44c29abc12fe442f5c3586275024f49843647913c96b78eda26d7eab75be5de5dc30e3f9a9b667bdb2fe1c8c97c5519afd66281aa41ad851e13c92eda7b501dab3cff82672aeba308656855233083e476bdc45bd290f47f91bed57443ae2bb4ade42ff3cdce6412e132ab5be82c5f6b249d3e62e50c8ae978bf34649a944a122887ede7c3c92d24a2be31dacdc930218ec3b88a5869c4559c7665bd78c1f333fb22816142ef239b1e5ca85129ad1e067a26fa110693f90856725a3334f73bb169581eb44d728715bfbec1d7216aacf8dee5b1e132470d94e368735fe38a28b53d162e47415085aa5a0cae5caee9c32f7413f1fc1142c22f59d85518ac78ad18117b0abcab65b1ef735ca9c17cdd44dc2db6b0db8daae949d1111333af4f1726b44ab826cd838972dd97c938ccd2968129531986bc067a3e8c0c6543ee9b5921b141b88cadf44445e8069854ccb3d77d35fe2a548b109ecef5bd7e5939798dc9061b301f38a887982ba72ec7f55043fbda428841979a3b15daf0e8b4a5dcfc0b52d46fb9cc8d831a451a0cfa630e5296cd42ea5db243a39f2c697e24ad0188d900a8fca23a311256d1adca575d2fb2ae6f3bb689b9c13c5185533f6174862ab3a3a1f91bcbae8bd3b78efaee45a5f10b9d2c326c62923c60ea4ca941df99ed4f4ea287b5a00eaf3c7beecaf0a31d0469f8bcc037e04c0cd89d0075cfa00e9e5dad9f165c307f9f21b1565e34ea7cd4ae4379b7c79ffb27c41735c8944690af2c8a43f4e4499966c9d6d9fedd6d940d743aebd817a0cbc3c5d4781e93374d0b0e3861d75ab22773a18427f5f8952a9a2086fd0bac2ff339f99bba4ed998b364b7ed8b6f53819b911564ec78deaeabad57aa635d0913d59c02df0e5502369cdb6dbe4d6b068a9150ef1cb6e7b6035dcf0efd4d56ecb461a0940a9274f201287a00707a9ea3f90522fcba353d7fd368520e9cd9f147d1938dcb766bdd10a671652160aa4f41722efdf00aee783d12f0f0b61e59c6d9c48439c1f33b007a216167de50a94f5113cc6a015f7414604f808aed36b97907f4cca9bbbe9e1899035c04549cfbc49ba78ebeda1e81f4645bdef04c6b496dcb84525860c9a5b83326e2f023a225da130f1b1b307417a63c70ab871148105fc93a658844f34b7e1283afdb7543f31747675e845c8adccd9fa58caf16f518945e4a5172e9ef15f7c9fb38db02318e4346e8e868a364201ebc78ffc5e8b8ef89c11dde88ed35a9f920f8d321694e1427db5f1a85b9f57aa993fcd6386c4fd539acf94b3c041a2fda07155e5d251ddb4de87b4fa39185f4e97e3ee32ca25e718e5044f8a2553ead991f5dc48a7e2e0555ad0110dcbb49383b24d3f4ba031e82ab12c01cf99abd0b1620e85311f0d048d2c67812a6a715cbac6a64a77418963005b411f5130ce0511ee880c4ca3dacdceb98602d1e42dc6ff6403b0595f280ddfd7219536956fd5794894b10c03e30c0189e81328b788c1d59d35711de360f93347a74dc33cad352a0ca39a6e8bf08f4c7f7f4d58d24079fb83a2595b8f4d429c91455592ac6da69dd34f0b33b1b88948ac9eb551a8765b4dcf6d9b37ff8afe3650cc8adaba5b7f8187ef69330af3517bfb86788ad07035050a44898191c53116e4afb61847f703afed592e60e695f452dbbf3874b0281a99420e64c415cc1783c30c178e3bcd8cfa0722be24337450d1f47930b3bfbecd72eaabb5dce50ab2121160973c261ecc1262917b663cc1d397a831f6d8ed1ec4814c81d963b18320d66d9cb96a9e9bb4e438d51a07dc1b0e7c93372a73539f92ddc9591a1e55f370adedba7e0455d6d2ed8517ba552fdc3ba021bd016c21976de7e9f3a4575fc7043b481457763a0a580f5475be2db1634c04a4f807a3cd65beb7bff16f994733cb13464f83f536ccbffc1a5703d01c66b27bb8dbcf5cb532de3738cbd995c0333c38b62b3f4e80bcd775bacac3630a100ed627c88261321172d293df98c543fdbc7d0869a6fbad17fe50876ceb22ab1f516e8aa7eb50b1cd408242d1061ea8ca9cf7cbe65964742d0e771c9775e69a8eec5f3f41a0bac9108177c64abd646ee8c46c1468d2f76a6259238b48d9deb66f8c9e461da4e1802bffd1662716cf437116393acd2a2ef81b80f6ccf5720b812ba1194b7748722697a89cec2e6a991c9ab6d5e2a3b729f685388da6098c2ae91e37386a27322be9e80dcf16b6bef1249eb75c374290d5c0278a11caa1e1e23bc3d0066037ad29d5d73fabf00a1d906e49675380f8ef46351e26d32c7f738098c2f3bb615f2bcc48a132452fc1b7917b8d32feea6694edad2d979456a900e2b03b7bdf93466fed15070510b0ffd1ea4951cef281b7bbcedd51a13da1e15cf5ce15907553e6fef283e712c2ce8bf92c995a9ca3bdfa629f8f0a841e92e1c279e917bb253310530f2c5851b59016a3735fd78164d9907c68ca217af4d7501db4cb27cdaf8174535bc772efb88fa9af2902637a3c9d2060cff6304c3ae9100806a713955cc6213efeeb6d5a11f60e0a8270edc8b9474adc4b0eab4b6c3b4762ea1a293493908add203b10c4d1e25c1aa131b1d94cf928ab155d1e9acb9cb414baf3f238fe4c6ad44fe37338606455a140e5c980e8acc92568eab64009db0b5476935040e4abf9637e7d9fd1c135e923707be4c9efa516d426b6ca14cd66f216d6ba97b6050eacda7babbb3870c83eef6db99bff6319fa64acdaff8eb122062b5045f68a4e20fb115a2ceb5bad0aa7ddd03035bea04e02afa08c95d058fa888bcfef011ecac1f26aeba894a7a15885587310a12974e8ad71b3c81a9e45cb41d0944e87a923188c6b06fd1cbfce0ba2053c0ab384252b275d51dcae827321c09d68e34d2e246984f45d791901e7ebcd0b8edb46e883b1b8800d7e95da64764fc66af16f0b3cbf5c6f3e89e2c748fb84158934659d4fb89f2afd6d9b1f763a6cdeefee1b99386e7636d437139778860d9be76311831a204d48dbb74e8115d1746a764ff5c04b7435327d45a1d16729c76c22ba4eed8c1a3200bacdb775984607c2186e950fd5d0348d44294c1e869036c441750dce986f7371967c5f92dac1ebc441289fa9c1ecd4c7528a42e19b6cac0ed54a6dbc961a973679f0fcd08e9da70d9e1420aa24d78da357749e029ce52933e9b450383c8ee133163a994c926b6fd3986edca357bb425e406a9c482a28725c0f0d9dbbe3463afbc90acdcf2a9e6feda2645d21b9803df2af5f7b597e21fd145edf0340d1b7fe637bc83b52bba2af88fed5af6278ede430d3bc48986aba9cf8486c02ca049268854b8119f7d62e9412efb59a5cd2de142c2f42e50a3fc937c92a4422ef32c3bc0d175a93f9f1f5a567c0ffdc24c8aaa2196625b064f0df42ac04bde3ea86f34678264b47611d0705a81ce681ee9a4ed8565f36510d00356462eb7972919582ac80bf042d0a93945213ade0210cd0bc2c4c562e351c557417579063100e4642d706197ade304057b902bfaef9cc70cd547ab1dca5e2798e9863e6d934fa71f53e595fab929fd884694207bfaa69ee44b6157be8e40ef0d0e110b63c9b0b7c8eebebf3773d3280f666973b5da25b7bd50daf53d0e6fbcf150206d03cd6e8519ae419034b23a4caa9e6b73a20a5c6092353dceb6c895c35f636df2115749c600a81464ff2e1c5ad792e3a18c642fcdb0c57890ec6d4dcd158154e3709b461ca08d107ca6666b6d93daa76e761c40fc0d8a3aa6bef29b596a5ff9176af27d8b7871b8e18917d6246b834184024a84ea5db2be9fa7844f5fb6fe3c8a578ef4c2788636dd8c4be29c82c3d59f632d687f120956a46889d35c892c8f484cc9f2bb49a59cd0bc37e998cea50b5b6c81d414ee1781f87299a96e7569dc1386e19f5210eee97a5359ae5347ce7b2bd365f6b020a034d5b8aedb5e4811eedf86ef7bf411c260d41b1e1ab8680c548e9c6b1f5ecf1f5b664e49d5fc7671a8d79aed94cac9ee091147aa41f1baedc1bd475ef8a9ba7acaee497eb58c5658021eabde3c2de954ee1e023de42f49ea1c085c9aa0ca9470419cb64c80b4d38f8ba9d26b905947586f7261b757efb77bc0b60434bad294161a794b351fb329d057db1a1f1c0a52a924a15b135f569ea6f37a9652430bbfd511234606276b06a5d62cb3ac8bb10dcac388bf21c3a0525896c20f48b21c592d701953b5a2c7444abc6c53d229defaae8c21ca6883f3d9a3f65f5b1a0c569c8a7aff7b4ef4c5c66676ee2bb1b3a30f5edd4ed802542b0ebdfa8579e7685661d740ab6d7145d0517c6e61e908a533c0ce3510e3cc902716b00798cd16c81315628a7665b16b6a42300c78df0acee46c90dbc02354c58762e01bd28b421c2c0c9f7e5bdb61818c0222837b57c0ce540f2b84b9cfd8433a176f377fd8be50ff28a06e586c9ef6a64d0756fc487f21c0036c9ede97f21e101c9bc6aec1f87e933ae63e40e9a9cb472715cbd3adb1d0acdd4a4c88e16574fbc290fa7b6499d4e22a0364f02f7372af0f664c25a52a714b3402021a865570e318489b08c2ba2bdddeecab3eb394151748c1eacf73480fbcced0158cd5b9c863b43de97838341863c24b0f96d64af3cb00e180b2cdc2150c66c53ad5f47c65095ff8daf46ea5ed7bb35cd0531a7283cc53feb931d14e26001077f13a94674ef297fcd7aefc5c87490a1daae365f4c50b2eca449a93ef433ab1cd777754ab62099b0e0df5e1cfe4484cf18b1f231402efaaea647ff90eeb2476379245c72cbbe6a74ab6bbb5181c957511685c94786dbcd1bd8c82906c458e13daea79da6bfca93386ab26aa279592630ca893ec4cf21a0f875695facd27c3248f04c3b3494a853cf54c50de238b2372e96eb0576ebeeb08597d1289b4b2e8ec149e5c8d8565bfb421bcc81cd2eae6bf11635d36b4acb92e205a7d3b0378fc5959a493eb810261c121c200c00cdfcb286a810f44df5688fd840df79860d9a24910e7730b3a7af711b25ca084931f4098b0f22152f994b79ac7b4de2355e62e16899aa42b042f994eaa99311437006825a1d235c9930a5aeb86124033b80e33035ce64a84c9460b76b2e734aee5ee2b6641bf7afba4b4c7561ac4f11d89a6e75d4ceb5f337a4ebfa7002a39dce3bc00f05cb8295488166bf6ba0291513378eb8de1efd55b2e277326a0d6053c4695c4b1bb56addaea478cc6cb451754564fff41d4ed8e12c6aedc036d38a4599aa23469d6c5dcc026983c61eb121be49efd94483e2234a888ed4d287075f40946863e4c8a110be3a45a284b3c6071f9d83e7cf9791a0c93dbf60b184af597a1940e62bf455b6dede272a180bd82f2384c77fde7d021c16ddfd323bea3b2fb906a110334cb97b5768c2b4f8592e87b8b1a7c433467a3aef05189509962df91b72f7453b4ae8ba361d524ac6a1eb15677be510471c817022ae7febb0a43a53dab36784eedb3e24117b1bbebf376456657428baee15e86d9bb983765b849d157672b5f831575b7297e1229c06bd4061eba9f623b513bea5b29de5c45ffb7a2e6eac47693505928e8dbf327ca348d59d227292326944c776aacb6d3049cad463c4f412441280018e4cfb0c64adad9249a9e64610992269e98305198a750ccf0ec69c2fcdf0d879b3492db2aea200c994bd37417b0c41cfe9bb6d4f277f511e67549c2aa40694fa59a92fa6c19c53aec537efe638f0d53658fc15dfbf05b6945bf61c7665fb8428ff9e0a9cea5571db71fd8e407cc6280a2f082d43332100679a6d211e273edccac155aa1da0acaa342a4691cf2b3849035c6b5b5e19afa9f3039ff0ddae6476e9cc8e48fad91028b14879036987706d6ca4c5c85514dd9d61737c836a7020d2772c45d934e5862b8b682b051bb937d1c8a92ba5216f2ebde763e8b45df2c28dad1cf5cc883d04b99eab0b28f6b2a623d235377e7e4e29de7e8e031709a36e2e0c0d5134961668c4a96a80eb42b30820f2faf7d287bba34149b87d3011c63209b371ab065b4fd79740da5dbf566cedb0ea0c66cda0a8cc31fc416b28b8cb96f7d73a4e342183def940a03d5c8295bd3e970b062b982a82d57c6644c877cfdf309723b361f460c7d3bb90660bdf853a6534dada1f6f7137460bad45aa0bb1118948d402bcc36c925736482c6102e3c58f415d209301b887e0062c3f699f565f333c7d5da9280cd8c3e7dfbd7bdae2e805c0a0242baa0f16e9e3ad3856f1c12895ee4c867e1da8f607ac3f0dcbf22326055c4b8349e0bfbc442a2621846b0e2001348f726c457df981d57e216247aa1637231505617dc62cee38adf38f722a19116d86c2a5b0a8b14293a6ec87f3055f055e507fda4d473f6e4838e7ec3acc977600bb91a034fb3aba43c1c598329111b4be80804067364dacbaeca8969e2adb95eda66f7d90a827b9a42c94a8bda70e24476b9df076afa3e9031b626839f71006e270c17d7b1973cb0c527880ca5bf5e23095c06e3e693a017e4821e2d480f337b80ffea30c35d6cca74f69033e45d3cc86e62e9e7a9d67b637baea1a92fe9d24aafcdd67e65db33dd9af5d1f8000cbe70786114a15fc361c5312bd95eec72ee1b91e82485ec430909c532ed11d6c8bc72ae052f5e98b805439db2b51948d5deea895b7fa6ef97ced95442b8e45fe90d14aefa2bc977b2d46f7023bdbb5d1cc97bd5782db9951a090626c1f162c573d6d386adfeb8776620433d5c2cbd991885fcec16d697cd2572a11931f3c1067e7d9ab881e2561055454e6231c4cd507f6b9d76d938d49dcc4bb5e2f9279ec5495203ad901a8cefbb7897cad8c3df074601b2b19a309900b475395de89b63a2eadf7a22b974ab7288dec49962c9e806c31765c55b9ca5f27d01b3e27974fbe0f03e3af0a96237be21fde95200f8002a681c9348c6795f1150cda443fef403a0e074f6ad5afb754a458b9096958e7fb732ff40331c3a4ff493d60ff8623f4da8108b43792bfb7866e7f2342126db89aca984dd553854e87be6a65d4140771cc319aaedfbb901b5739013a0d2008ae424e3a3422e3da46ae8da1e414503c75c936772c25861cfa8c4a7ce295e0822ea388cadd6dc23716b3c59c8b54a40950847220c75791be959120be626747755f15e46a3fe80633cd6032397f7eb5016033a4b73c32f721c1cdef45be92def2cb01dbf53e6c381fba60dba2396f44fc2fe33669ef5383e269ec6a263c72ada9ee255a9a6627e1123bb005a83b4a990361366261d9b54a64d44a3f275f6a5456fe608b63a2069c7e96090f61f735a4296c952e0d0c879a35d0065913cbcf5dcd2a12e549d5d11e0cc37bcf5df76d5d443037fd7fad175232ea4a5860765a79345383e48f6d1ebc8f90f32cf12848242db24cd8e16b50d133660300cdec101609d5f4d92c95fb7fe21049df9aa999918f1feb4f057ec42b9ceb481c41e3817f26d3ae6c061d0fc2e73a23925edd4e492f81d76b49f695e0ad01872963d405bc70207dcdc7611e9c1a3b1dfd015bd4a0ad5ff613938f1e5b552ad7d0dca17f18d3930032db2e05132cee56f2ae75ad7278b8cc562e45ddf5f69112b203723b40a2684fb159180d8e5ae8cb9e7ebc0bbe1ed96eaa007d457dd4fc78ea550e16a77338ba289fce7f5819f0710a62cb918b8b7004990a0ff3e287a8c85f5922789ba4558776f0f0e2976fbdcc4e057360bac7a25488143bb192482846909f058e2bf836ac51ebc3cf2b01fa3f4b17c949e8e7364e8edec61bf1e01b3fee612c0d21d6b6a45cbad05bfda4ffe536214685d6bb25433617453526808a131fc61982a64b8a882ae7d3d8123f6bdb5564e9dc0e983ee008e18a34b795c24fea481b7f080a037c5e3575c573d69bed1836c7a111b53f094685bef78120c62ef79056e17d7522c7f20e81a73028d8a05e24d40e02e26befa1090f94d34cbdef4c2b15477e567677350af9c069286829f58c36dfad7e6242b5dadf53efa17f89a89b9511985aba9189c231ac99aa06a4d47e6a86fa9fe3b42e596e26372943bd7be0d459dd08632cb5d972a165023f1e2a6ac556e8772ce4c958d73aee541def414c770e6fed9daac1842229d20b4ff95c6b1fe48fa5571bb7b520f8255a4550b41c597d0c41d46102e5b59e4efc79e8ed77dd2dc375fdcf1cc8246ceca1588377c08f66be3b910af4b0bf2bccc5e77f0533aa11e4fd32d4cc85648a9d804f7570b884fce9731b0a322cdce3fc74f23e358bc9cc2221b9966e503966b4ca4fe49256349b7ccfe48f614d73be17aa5d792557d9101bfedf5586ded3bdbf58a707bc5cc87fc79385de4acf4ef1304940fa4e85ce513781821be5d26211a142bca0e7ebee792401615c8e9e109f441f5eba7efde7cf92aa078cbd977b1d58e95d84cec3ea7e7d17c17d63f748ffe39a959f7912718634483b1604579dab0387b32c4b738f145969727e6af3ad1680acb908019b8db6af64f07c6c0ee82c566713641a2f7a60e0c941f70ac164d475ab90c4e5fb033142858932c577da1073db74f88b2971cd3e72dde74c84bcd03540be0868b92562772101651c55bad6de290dbc1b3f71ee875fe1f20827c688621ee51b102b68519e6db435cc32b259b235cabaafd574b0264e7b632d00557e22f2960ae7837a7a5f1fa6a05b929a2962e4f637ff71e1c049ed85c5185c9ae34ae79d2be8ccbdbeff2c60451d6c5e5e09b990f1fea41734c3000edaaeaea8d83e7ccea73631e6c8633c749ca20e75c15b14078bd5b4e8be01b6e5634a6525866a8d92cd797025c49a2632aede980fcf949b060b35f2f177a9c40125751af39e068f9e4461fb484b2d2d423b65bc89f463a9a843aafdf6540a20da7e229ce07913e07b605683f2642ef02b34bad99f19dfaa654df0cd75823ba920821983457d57acd2ca547333f863c22f2eed47af50c1a84d5ff969385db5603ffc7c562f55a95bf58dbb6c86220ed1f70beb71c2064b46b812a73302ea35edad6cef021e28cf33ba8112ecb043a8242a78ede37dfc9fb73d070c8f0865c82a23a55e2afcfb074ae4357a6638ebee017cac09810958f06eca99269c909644b3f082e27d654a609bbf9ffb8a885fcbca7ee280ea1b415b6560463821030e508945f867f394d8ab6711e293beece1c60ab431cd45c93f6761b3d93fc736c30cc961fa61c82fc0e1e403fca2b50f0095e81bd61fd9cb613682e002ff290e8ee593ce3f532a3a20128070f4eda0cbe7d4525315a0fa3d9c751ea90a94ebcf07fd7ae70bf64125a8726971632e780619e8593e4312982482ab000e28f038fe3c8c48ad275d6be41794e7c090b44e976d9e3cebd12ef166c0165b41e253c76912c090bc1356fa796188337b69acc7d827e105cf1aa4fb23fca69879209d31a798ee91990e460437650ccc229d88d6d4d673a1b57c56eb98298cfa44472fb38db0e21ee7951b4a924098e5243d3a6ea60fd7f70eba95ad150ec82c912a9c8aaf60fd35d78ae93072608e05994b920e815d8541363eecad5cb5bacaa4ab78e902ce6a5d0d1e93b37aa38f8efad836d63947ed6ff99d35b0e32e80e9c2ff00e537b703784fc5b71436197a6b290771287b8ce70ee565bd407ff8fd64f17938728b994def0de1932a641a4012d0edf1ed223a1e10decf56f940c1dd57144d4947f6ea9c95177435f97ae525186df0456ef2b55f1803a293812983299ae411fd8d48fcf405d7f98798edcdc740d51bea09ba257f50e910a5fca8ff846d770a6b76ab9b895de76e0eec9722405c381eb86e1db8692da0a4955120203662a2e44e53947fcbed55a493f9be55ce2b675f03b3aafce1dad9542b449fb96ae8f12c2d200cd4ef4aab117a73c96190f7172917db74245365c3a0ba914fc36676b2dc53ee6f86764fe6c79447b8bfd09af8b1ef9466394361ff49d29166a85889af7505e048b0e18eb417bdb59707c640e636853877966a95a7523e6e078fe7ef04478a67aed0cea7133690b5e14c8c4b8df72d29f74c1bcbbcb73c1cab184d6762351eb5c14486e1e4dee10f90ecb1b02eb1656d64230ef96715b06e09f97b3cbeef79d40f439a40a1dbbb119b64a41ddfbbec3a478d3df536b90ddc4a420c44eb69d7e2ed016ce003388678b79a08300d85ae9680a036605ac80871d53f5abb6bde0ade9977c1c32114c36db637bfdde400e0107ccd18830528c6e853c4d0d4677a00cd15ec29f452258aa208bd0f3ecff75c572e2d4a57d60fdfcec4832c6ddf59eefcde059fe203638cada3767f04e6aa412c37baa0a0d5991052a687728454a1b6249d3511699bd7b5b44368735c9d3eb1f48043ecb906ea98341d98dd0b828bbfbc5b4b5b0e2b263ee83a2937e7e14ff97b563067cfc962900fed8fd0133d38f99db29feff26a8d6b70add08b8a3ac048a7050de90b6f146a5e28d5779521d6f5fd3dc5f88911e88c0932302a2292206f6b0adb42c241d9b90777b37d1d6df2ef1239ec60510fd7646d82745404368d51fc8b68ecbea5a91eab2ffda1f225c8c3711d15ded6985ac2fea54ff4adedb3864d4a7a437e6f5b02f558b9e16586305f333dc4d65d7031ee071c37b18924659618e562a104029434e1963800ea65b588db58f713cf32c96309e6f636e18db025db4bdebedd18f0a03f734dcb2569683cee78871c275ecc5f0e3253f3e1a4c666c5b7774a63d19aa4d88667f9aba28c8c6024188269bd05f1eb8ca92fc72c68bbd5900f927b9d077e717ec098df9ae5fefaa0d076c98479f18672ed4aef92a4ddf9005d09c883dea1e3c9d7507fa71c6460ca214be9357b41f16d8b0ea87a6eaa60ed5c7e584579dede2ea5c7361ac767227d2526dd15216dc1e86d25e4004eac7732e172b05173dc4e0b5b844851c032347a99af0ffee87cf475fa57055594876580feca88557c9421e97ff898b995fe4ae6df51d4c4b684a4c45af28d9c50be573608ee632d3afdff1dc67e41e9e84936b0340d6b38907ec366ea6961fcc75140a2dcbbd4d8def70eda5c5e4bddfca4086b4173c769caf8109ea48af6a4d6b38eb08213c3a5489efdc9850b55be05c1afdef46648e33c655cb0a18112a9f13de6a0e45882303a29a1892113d83d2a70ef3c2db95910867d01c7d93d7c9157ffc50bc5c42f5eeed2125a77c453cbf58172a6f6aae19ac22cc6a67533fa709bd3f75eb2ed12dee6ff95e99c48ebcffd060ca0e585830d621f03d30060420e7b56bf5eae5fa37486467bb2aa0ad0da8306c0137d0a10c285913e5babc10e009e02fb12956679c97e738817fcce6ed770f2d3cd75b185c6df097c7ab9c0d717b7afdb4e344bbdfcd23f5dab7d3bff5d7656eb5e0b9bf821235ee8efc4d8daf2b2f58814f7bf6c871ede4b6a48cf14ed280f87bf6537135aa5b3a0b2d016870cac40dd44af57cc7462c05fbc322a3a948437f663f3c75bacc46953f481250c1f77f5f9f56c52548073ab3af35325dc75ebe6eb170fe045af30ed1c48ab1d232c1ce241cacae16605f121bb2ac33b6992365a43c9be878ed8e6b0ca502c75da1ee8aa1d745872bedb1e4f3a6b8501065df404c41bbd0f5e9db808599bfe6a41b434cd9629a573d43e258e5df40415e8e1523dfa545a14025073292ba7e08f7d4e55c0bfbe83a8f7f24ded634793882a18ce2ebae64b76064b66e3a1564654951ef2cec8bc283e21cb6e71fe262bca38e8fe2e2cf17fdc726ca9f172ede0106b20a41cdc6d89626cbc77c372e77ab2f75c857a3b75f7ffe54eb184617dc56606958c9b25fafa273086ba5ba90a4f76d5ed51bffe8575598a5221d0e17249a6b130bdd09a95ee8c30b9d941d28209f5912aa98b991d3221d1443d35fbb3d5bcc131ddcc41228d14c18228cfeafebaab89d4c28722fcc613dc9f3687fa7ee8a60bb2a37b35b62584e055eb965eefeb59da0da59151efe91afd36a62d7fbfbd91be3d55a9cb31a60bddd11891d361888c2c076650fd2ebd40770c780326472f91dbef82fc3165205184fc99442b337ab3123381d4b4bfb1979cc7192e61fac7d82d79e7d6def1d6e76cc94930d3ee5abd9baeb926f70e8143c44ac5c29852e7a9d9c916d42173736af85cdd1ef0bd034d996c14fad02582705cad95c80364ed0c7b87d3813bcf446554664689e1e0d9665fd81cd7312f9842adbd39b79a77402eedeb6c5763116628ca3865d418776340d4918499d9af328ac28820b6ee638f7215084c51e1bb55a72c69c68afc6adab7f04282d6d2620b9fcec6261449f8369ee464c4fd5b481a9dbf2313d26ecefd796e5827189cacd1910f1308dc056e6bfafdba83f457da673561d82fa93b8313a431c845c474813d9b43aed75d3c26315a60c22110c94396d8eb1494cc5e06bcdc94c6f5444f5deaa6d7ed99ce398d5b02cc010e87a0a7b6a33c645c80a8e6793d1aae876c70ddec1009b61aa327e3b912b3aab46efc91012823d810892dfe92739925ea9ca54fec44dd3fcdad80bf8c3c3b408ab761259f980866c15287568d099938a6d8d6697aacf70b77184369e050f18c4272fd9b9612a882cd7561edd6f41098b8cbf53e0c04e84e3f31c27acfde930f9c88e7905829ab34eacbd9301fa1594e0876641a6269fce53dca881d23872af106232acfd8c4fcc4c9f35540d6d7470034ad66ecefdf27511945e3f32de4d39576d7102de83d2ab4aede563ef8d3b37f5c38fa3d5e3f4f8eba80bc08bbd3a35edd3f90f3dd90d85f25bcd164c3c9ec674af53796fd52461b2a8c20f6fc8059ce1c89d325950c61cf723cb863987eba281fcf65e542006bc073b1362429f1590fdca59bf0003a3a3a0ef15edd486ddb1ae5b8922bf913293e56e3e633cdf19e3e8c8330cc9fd24aa074c4928e2eec8d736cb343f4e6c8b20f81bab37e7e03927e28fe47476725eb46eff7734653875be7ef0e67e8f9d33c0eb15635c4ef2ece122cbdb16a8d21a3552fc57cef9bc9ee36b997175df52ca1cbe8e35e4f1825f3d7fe0594acff1985cffad27f50d5af26a519b304da406d11a927281d5cea59a38342bbeaf97ceda5c32c8886f27fbbb5dc5e4c90d8f3a7ca363c17e2a49ba5ca4eb2fb22e80a8b6047072cbc695b57493cdc0c0d6f3bf917ca54b8a8c99a7c16ceeef289d61b7b037d113c08a83dbce63aa79ec051603cf279b546f0f6b2273eb032fa55c570edb0ad4a339adcad029b0997e7c3e053a3d75ff2d24865fd8453a1c63cf0ae6a130ddd1d3e3de6b0d5b77b664a1877e2d398c50e4549ea25f070d245132998aea97be6236d0a41f5ed6814b7fb58b0e7614af3dd584a488544818fe4f725c3d0fa519e6240a1f0f8e04177747887cddd05358758131aa8f0f9786de5b060019a77165097e4ce4503411a6c4d3f63e9f6401a8327cdad729d7c0bc526c6c8545d7935b9367c4b6f3f2de85cee158d39a45003a905c0ce204195e96aef61bf3e0e1c26a0166785a52efe858a8e5f6422e8c9d9146181646d11828371655746fd3e6c3dcfb61d89ed7be530c337ce3d4395e4bd6b706a93d54dde884f7a1473e9689c6e83388f7ef74c6f47c04c4b1d1a1a1d144364aee373bdfa663d0b2329b9fd9ca9a54b63b3f0b00aa9be3c3d908302f4ccb1066f337bad907b7a13dd5fbb5ae7bc0c46cf29c8d46ad3b713d958985b224ac464c1fb316ade21e6e5b0c05f60d14f1643bcba1ae99bea8334917b2958e37f456321359156ba11749b9541ac25244d60099445df3e61ac3953744d1651d7edf17095f492cc514b7ae80f2e6a7fecb65ababd4269f960f29c189e19a151349e0db0ffcdf5883f75196a0879753d7b3d3aa0aad0b2918a1e2c86cc24cc55df68dfc9bd3c3dd9c91018e2d46af0fd49c45aebdb09628bdab55befe64f1a8425e5573c38eadad672757f3113209c5c27f1eb226c25c8bf0467b4d39721670eb9015b693a25a53f9c7fb4e405088fc6dfd386b94bb671ed85ccdb2e58069707f33a8607cbc42b21295a63533ddc067218179c68c731c0f5fb49c25b52b93f732a4236a303018a090c3a16ee646c8d640f27bab3d792ed09e328014fdd18f24b4d55b706466a78404e8ea674879d9f429954049ee1886db80863494169d10c3c21eb7e5445efa35d70db25f6045528dbde83a00c38c7e24e4e3b42a4d8adadf140c05b16d1ed28739272f8114234b2665ce28a2e4dd73b21341de172781d83bdb12ed1ec7c6780aec1c30a934f0d3204ace3f280f7fd53b64548459b5a38dda125282cf9b94c79ea8a61e064de525dbedf82210803ded8d2a021841685e0903fe98d40588b1acf9cb44d4306b2fb5df79a974ceb7021f10f4f198aa677f5bfac027fdcadc844d2c16860604fc150f8d8f92ce061115cdde6b8eb1e9bf6bc3d902d1f6400061f3b37832b90b05f58640741a9a56e65f17e60f66961cd3d770023b23a37c7b2dde374af97d714519d77938b1dc846a244081089c28e12d9ee210d3517bf76c9a31c2711ca8d3405b7acae3b2db1226738b8eca7fcc2ba3639523c62726561f8233619a97adaa6c6eaa11c613fab256d6de141d4769a0d86370a7d4428dd8cba8a55dc9b1218daa43a09dd6e19a98af7ecbdf984eb09ba234c7b9314ab2dde72199d07cd457d47742aca5f6c21db1beaae9f9708","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
