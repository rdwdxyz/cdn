<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9934abe5c85403f84ed82ae34b66f14044376d0bea5dd319c6598c0c657ddb5ed4e4bb7f0cfb009b97c279282a573da1eae414a19cb2e5c91cca58f1544603f5b76e6b1d564fdd770c39f1a2f522717c9ea9743aad47b634f7935956b8a9aa88d9fbafd258a9f6896d2e335032f5b4f50b339c3e7c9636c06b544c3a990e02156298ad7afede5ac3df635e872dd1489036d92076d3aa16006b171e7fe4663d4ff38e8dc5e1c1ae5894d5e9531181043365d37063d5c40136be70842c734cf1a916c3da53a7f479b6c3722e96498a18a9b1469030bb3011d6670ac8110fdad48b320a4bc6fdae2289f6c9302e4e0b51a360fe30b663537de29034ffaa5ae81133ed443e1df42526b70a8e266567f304bc1e214b09117a0b17de368057bb58ed41f127e4145fbce1ebfbae8dff82d5fc018c1be22960a4ea21ef30f4bd1c27a7ed6429d48e445cda82b6d8cd3e46eb5a11e3fb200b86a56aad3fefe63195834c55d4110cc4987851a35bf8e639bb189cc30135424d5ea971adb9a256521fe2f6bf5094e4cdbb3cbc560235b3aa38037dde680c4cddb80e1761cf7d5e518171d43eb0f173e39706248646d46726e92b150dc7af7357df7d05197dfabcdb13dc1ee040a8a96caf0ce4615dd6d3bebe2e03f6203e7ea50d184b9640bd3c1927402d47570c5fbadd0610b92329ece79a38c9905732d7eaa7d3e374fab7d7139fcda6827f0673b6fdbf141f72b958cf70623037c65aaa771e11964bf63f06da9ba9e18eb9a5746a7daf7bdf76004c633326c067787153de838a6e146218eeb57e12d771cc3acc657255f809cfd71c3a77330853831856459d4d3a03ca4b1f24afabafea6ef1a5ec1b6593cb0642b032721a7d3a36282ff23eba4321177e34bbcf2851c4a250df8457a9125d3dcab95954da06ad94708be12c44f7be223a9578cd166bdcbbb9dccb42e28882a3d92eba0d05e68f659921d00436345aea1d25b2ec6a792e3cdc9e79b77869d8ee4b1dff696aaa51641097a5692f9bee559ce3691a079b2bd7963271beceb1991af5dd9ee4c917b187066c99c80625436cc3283aa135cadc50fcf321d72ff5b44662f19511e793558fc1aef2f65e1ee70979f3542f6664be270eedfa5377dd700ca10580ff62fa912fe00d2d45559c8efc75017dbe32b4c127a2277bc183de680d81ceae272b52752965815eb7d5ba5e7f30e5fd338f34b759875d1623071258d22e8a0290ec2cada55758d366b27d5e2c3c7e183857d959a5e31d5eb3a753e7f64ed47fafff3405bc609260669e7b86f366db1d12df208df81aad56e507b781babf1fed4676097c4d3a740dc2f2aa6216e90f037d195e501d452ff78da28986ddaaec80be4f9935f406fc8f8209da3535facbbfe6b7d0250c37b96fcd1c46a3649deff1a94e4fcd493551db9d8475bc642894d852123694a10e9cebe2e1d2c889b230ded297536a956447ee9becfe2d53ea16b066467bcb95df948ec5a0f0885ddf7449f26b327f044c670529a21853b46a32a84abfcec55fd3871466166edc99b3c005b449bee22a9655ba9a5d4902bbdbfe445065e68edf229e978df942c0db32190aa06bfd158e56b05aac8de7d2481f5822aa269cd2031061be659a59b35ca087b80086febec5aedc44f08c1d59a581c5126649898864ffe2f993d495e65a8559f848133d00f5b46221b2f661fdf2df2c510407a81a4bc6911fd93967dabcabb197ce891a3695656c2ce3c16f18118f9a0763287698a402e3139d2361d47b19d5ebf02a9f5a815ab9511040e214c5e8776fc1a1402b1817d25bbbf799ec9f64338c02c65dbcc57a9ad6f3e09e996249e424429a469973c530f749113c074be80c352b41066ddedefd4212fecda81620b70c1cda7031a8cd5ca60bb8c8027214a1d5833efda34a1138941bf6ede9cc291fc4e0d037e441fbc273470abb4606be03ddf2c1870d0e067cdcafb5eb8aa6cb5aaf5819447e4da9e66b8cb3d5d72a85d09dd586c5110ab4ed087b75c810b578ffafacd4856007659b833867cac9cdabff7f9a4c01a836308786a3dfe8810d08f40640fb7cc0fc5558fafb24dc5b5878aefc86862da6e4a6cc75611f5f1cfeab880c84792831d108a221795d89afb0e41b22fabd7956c16e612e37018136624ba6955d73fb6f6d027d65cf92c80b07ce577ca9f46b28cfd44f0d947315c04259118cf4d1bb2fadbb6598fea62cf0d194e3bb51ffc21043d83d8d4459342a963a0f75126a9f4742f1ee72a68c4d59df0e35a31222180a114cad59186f2e724f43d23e2a423505ceb79db5074a4f78ad94f808d96f58f98a6445fc509aae5b93d574796161d20c37d70dd4de6b681c96327f4337a133097924a5f09498ea90732663424a28e5ef7b5be5c63f70643e5ba4c9f8bab9156e3d44a5fb2ed43c4dc36d68d4cbc13663e1b360c66905a0d3eb0909443770a6908d1e4b9b5d57f2ff3eedd824d411680dcfa311fcf1f9b116b07d010239feb6fdd79017de477566900140c941672b73154fde7804650b478af003ec8b04aa3f93e487d0ba28bb259d04350f86a8e5574bf295266597a6dcc156273447119310a62910406f2507732b4c00a65a83e90032fc854f148ea12289c6e1dacc5d5f2274c4ac8ec314c894d5f8d64bcb79a86e7294ce1f4541fd68b949f9c2017beaff007a78cc04e46326fb2687cb6f1a28acdf509cc2b1b4c494da3f376751a964bb8f0ad658e05e99a34763a9be1058301824c3c33f2904a97475af1b9f7d0b9a92bce58f4d7e8e01abcceab54ca58f9b456c4247fcf98f86df673b6647979d4b77a7e6d78db1dce38e9fd163eddcf0c4708fd8512379f46f3997513710cf729eedd124c9048433a41f1cd43a52b480a8132f8a244b49db326f5b757353f20d6809898b48288c50f44995a1e8bbd2c6182bdcc3675790378be68ff5edef835ea7c04885a64e103723b6da870000661936a85503f9f1b3f57cbf4b32dd292135cff6f10076fc3e75cb8fbd2e4a95d981d9147651ee54159fd6760c5a5fc81ff909877bfd377ec4783aff984561a7118219a0a7bd045b75f647779ad6e1a8f58f68abd1a66e27845ce44160e7601b9d56ad927cb420ee9909f85a2b8a30eed828d887d6e907c19bc968f9412629ef2222f1e1f580e38d32404495fc06c43f676540275851b8b652140b78be63f964e443561f4faa69868002f270f4fcd3f99b787902ba5f397bc1df92bb75ceea70acaaa8d3c361b2d83cff503959bdf63078b7a116f3a5e374a4d61ca54c14663bb1dbbda8a5b8c0b840c442cc6b21de4bebcef18fe38ffe784efeae318f7d4f5f01b3da762bcc2bc6908e3a00f23fb7c45b96bb3353c92185dedbe2d973fa3fe576cf91a1192fae56e3e348b791e6acdc58f8daac2f3a50c21a8bc110b1353040f93564f5779d8d3644c299d9ead3e57252589f91d346dc1695c0a13306ca777e104c4541f62c78f3955c3d930edb11309d284ee0ccc21172681cd544c1814670c6b6ae9685eb3c0ff2317c9ed5dc75bcbfdf2805991307ac04e6c7322a2a847f417d2394a61f82572bf3cd0df2f98745048b59d3e842be5bb3684ef9cd00dc778f85db6b22b4cfc9555ffc06318a1f28d8b0e1387f024179ced6d2884492c6971de3df9d35831a91a4e8c082821b28bc2d0a74ee9da83efb0004175025181ff44a32fb19fc9f526f62e8b2e764929df0b6d9f3cfe6bfd53e252bd9d078194b9e7efcfa232ba64af54d5472855ee13016092068b2fff151af9d6978fdeb9dcbcac1658cef0ebe9211b9f7a0b33d83e819a9e20c3bfa695aa573140c5c5c149f22f0a533200f70bbac83324594249d89b0fd035ec180e3de2ded8b53a519310f74f83e779c9b1076b13f130f098daab6057fa5150db484b3940533b07f6b7ad55fdf8ffac6abf5ec1f8f90d15e04028360f18d207f7ebe96cdc54ae146a139a3a6c682e50f3447b843701a5b4a295dd517d458f44615b757f05de57abc532f782fba963ac0e02899e933adaff1ce95939cb9aff5c457fc82df7c5897866d74a7800bb58f2ce9b059c9692c248ecc7724f8f1471350419f35ece1bce67b017a4b9d0d77707d332a110e77708951414dad031df5308b160ec9b3f89656aa62f7025a51adc4fa230650e1fce4cff3960390e554520db4ecc7ea79dbe1fda116b80898035bf25d3069c79c3fbbf2b840e5d2b72a5ea80c51096c7ae8eeae5023b4faef8d45533f4f034559005f3a9de4458442ecbd29bd4fdc7c6258d1c9170f425c2332f8c9dc08b54be653c2a8627d7b1209c4f81e0d8740f8d9a1478cdfa24d843fc5da35d140e00dbdb9cbe3caf0c6859db3ee256629d10013085bb696136560378e641d872b96a0745af810d4b30f3b0b3cf287502afb27d5316bf5345793c4902026c8eba3715b633637e72c62db330fca3b8f98f2479b0f52151a46e1e627995203e36d835f588fdda01fe17aa5af8071150c3ac9b22bf6014854852e00b8fe9756fef2d8d2c19f674ae58f445f59be3fae7441126805ca178e5fd14239eaea9112e01ec025de13159d2cb6b97631b3b5f562122ec08525f9485434e9720bf1d46c6f7df387c14f970f217f463764f2682880ab04ca47cf2a88bdd2c1bd49beaef757498455f67b2e2f9eebb877987655681819d25eebdbbb3feeaba5e6b9951651250bbd45c7bb8c54248b7434a9c33a64d55d5a3e2b4508ed4d2dfcb1d9e4e69aa88650ef8aba301ca967d472cad8a7e499b4d174b795a616c72cab1374fd65adf6f37bbedb2d94fe20af3484141f638a765c322a1f0eba6aad10beb0a3421221de05c171eef33e68a879918ab30daca3f9246f3ea4833cf4e02286112b43b8e19b70c822daffb2a7ce193e8db76b6ffa9327a752184c5b3b360291f24303c27856cd740080396ac2469b9e527b5ebd701103f8ae358f6ea079298f7aea76554a84ac79f53ff665e1abacf530a034b33f29c0915381a02bdb7b7243523a4e4db74bc309a2d644dd33f7c19fe0675dbc9abc8843ce5e04168555c3374dadedb96861340600a86c105e3e243630f7d84c68d73daa5f152d5fe7654d0e58694facee7b199a9eba6b0704535ea9727f9eade6062f2b3cb5f96e4af5d0000be2dfb8a6185527cb94623836f382efe14e4d678638505cf9ad4280233f4d5ec6d26e3f274c9d4b4aee8a56caaa5479add67324709fef9442bf4015a9b1c605e5652d4b1a97cc89ae21c55e0f1b23cef477927a0b684fd5dc5e4f97c6e22a158df2d504c7582c3351d54dc95c4c8b876731b4fe60150eaf89983a068c72fa481be0e2b31911e2f8442a721a91263b6caa15e499cb1887293daadea883833a27d43a71f6ddc4584c8b4cd710844b995eb5d1db222153fbab8bf428b0088dd719fafbbe8d7bc7719f5267886a3b346ab1fbc968421706f5424de102cb0401228c48de19be60e070dd7f53a759c76da23e923c6021802fc4ff86914923d6cef6f4583a84dae4050c3413add9d38223ebe8bfa30ea29f4920854f9bff941a41e99a3a3aaed0a9522d53708673e4509828bcadc6f07421252db25ce5a98eee38473abf13a540b5bbe414f379a245fbb245e01c0daf1bd1f83065b0b701dc0419881e172785e470a9f373d389d0770545237c0c8e9c107c1c90ce2ad6d7484500985de2321aba13aa75953ba3f1bc1cc8358e5d8285e9b18110da4b6d9f7b53f4906217c4efd9b091b23606716cba8d032a2c7768dbcd4783d7d2cb7e5777069b336090c269c41d38b3e91d2a812b30813edb8c12487dd4385762cdd298c4e6e8dfd2301c285daba387979257ad3a7993a27f10dc2272824fb5e37ff5753fa137bb1389bfdeb6a577f3a6e124cb71a8e547a68881e6c19ae0f64ea80958ec2d76af9c1b328628e26f8e7f0d6883ee60efc9fce94c7c4ff79f986939029a50c2b888764bb6ae6617f945c7d72cc48c38b42a9f15ca44d836f688861e2cc665f57ac2ef89d25411a43b227ffeb25ff4cf8f1b881d246e5cb09ee5532bb44cd57e4e7b125cf00f587e5409a7091b946e4b150358dbce8cd65e1b489d8ac762bae55a4612c91beee9c0b4f8976a4b2c2844378a1e97db3cecc3aedd1810e97cf0c6ee9f7415ac986bb7149e1371b095de84ec91334ccaa6d40888880321ed5f0b304846bcae8a06e6375093d6d4f6c0122ff3b30ef4f2b2abbc7b1645b8d8c65bbb96586072c3de0f289e4484a3e8cfd5ee137757e1494b277f90a2b1c6467152fe9d2d09e265d3735bb5d107110c8ff2c4b9fcc68bfe3351079bf0123e4c9ccc5fa7969930edf32336b1a71d862dc63b8058b7a3b38a903de57984ecdbcf9ced53de4940ebea3fc1ca7c4ee27bed05e825a1fdc2f0b2bb792f12159d4511eabdc7ad999d611fa59ff744c49c51bb319c24f05106ec79f4122a2b07e9d1746526d042b00a4926c7ec0a50793e9b8d2de40091225eb166c2a85ee4be95c249e5aa2a3c2577e71197eee32ddc69d2de4023ca546b10b6bc69c8fa0d3c484f1851a9121d66ee1043d1ee0482056e81e5550d03d1f42b639ea305a4a3a75caa222a4bd452ba9ae2e78ea6a769fe2a67fa0fa0a75da8537db532d52fdcca759c63c5472df23f81c59a11ecd08a5c3535c1a1df15fbfb28efda3158e12e3f346ee4a9ca1ccd88c77730eb28965c830022b29cb3b4c9901a3be721be9e50dcb91b998ee48e045c11b2f5177df9cc0d4025390fd002b979e3b07e71016f51d373b570f74b2a28d345ee4a6fc5637962a24b00cebe4601d0865be35a3b7a520028fff90a4f7f2d72c25356109059222185dfe9bf3807255c1badaffde4ee86504240e430ff1ff775c52fdcdf0055940694fa8b52e44be05affd132b1a0639cd6bb38526ca3f88e2168e471ec3d528077e4c9c311f0d9def930272747dce008e95f5a6e2fa8cd7fb6cba098544f4e02a4fca0d2c40a0426405402e0e3dfe46f7759eb53baa4983f2c730e03b29aef942704a7e0cd2ae9ef57cb59249982541c08dad85bf89ec46a920364fd32e5d8bb10593afb66979dfaeaad82408177d4cb008c90869b392cc0e037636bb1de20dd3d87c534cb1306c296e36f18c657937c805ef99791c998e39189886634dec5e77617897ac19883a0d69b16c6ebfcd81749632b182eac0a7afa59ebf597bb09de30ff739f6d54dba2b8f2f0d32e061a3803148b35e9069ab391d0de012ab01403e76077e793f2f8114da07056b6b5bdf6557879534bd78e1ef08137fd9f57f27c6334d620ec92635af3669ded7ef65ec19cf4211dc1238495f99aa05428ffb208d56ae66397085b8c43f1c2b3b56b45ba4c84bf80f957ae08bbd708ae293fc619c5c123468a448c97aea2bd40587425612cdbbff92bfb80d3757d9bbf8b04034e8361ea6699eed45147c804666847bdf6f95c54bcd8fe7d99bf73a2ecdbe4cd6ee3c8c7341ce4357c379d54f780605682c685a1bde1774c41a0f3a1712d3c772b7f7e0dee7fe26f96b2a8bed82e15ba406981f7b95722f452a5a66daf5cc1dd20f04f3d2a86f31d196bf7c08a4579e87bf34b29957169bc01f0a36b5b61cd61b727ad14ab57562b34dc2f2d969908a4f8eb99dc4ef318874dc29cca232c9542b70c231a6e3c34dfde02d5ddb7f30cb5804c70dcad2b6823e4b5c087b6e5dc514cc30e0fbf0de55f3f80c3a3f350ca12786b7548418ca5f4939d3c099c2b56ba6a13ec0b14313e24a278b1c1d33074d8564ec835e0975776ad4ef94de6e1919a47bca1d4ea29208abab33ee0a99ae698987a1ec7b87e91e004c151f5367205a112f31222b5a913d33102e1a18a0e2aebe1ec50dc8b617cf3cfa3c3cf0fa6313718d68102775d842b4b03da93b6a3f4a5a73474a6074561603a328cc7e9c2c18c4f5b3576545ac0117c3bba7ea689db697c7f5b5211036f7a2a60b1ae7238c002f4de580548960219286d3842dac03ae96d92f0265e670ce82e65ea0f4a1c460494775f33a2169d9634019d82f3b2d366a02f63ccf620ca7207a6bf589d83e5c6820c3b8af80f24f75bdb5a7cdf0c3c176ac9ece6eb6174f2c8ddd3988985ca9956e17ef6c94a6363507572e90e2d269fe3152aa53766658270ca1034fe1073fbb7d47e7077859547f98b6f23e63e5ebbcd4dd828b115132ddaf1f5407be56b02bf81feee392a1cef584daf26a631e5c8077c11b2f6b1bb970c213710baa5935797af4a8fee6732f5ee4820fd530835a43b95395c59547eb902409b02263fc7918c779ae9abe0aa7ad3d9a326052f50e32f9ac0a050969b9bd0ec389cd7efc484c01b338998b674028d085dfefa16aa145336a43479e9187d8fbd8a4d954f87f4fac19ca84078c415b77b9810f89a2959d32131456db4a0b6ca2a512f15b1274c9a9776bca669f586fa4dd1bb94dfc677339b253d086c8cbfa43c41ad8e43f43db78161062f3e60b41885a101457f49b67db5ab739432d23cacbe144a5afab6234fc06f57fd7d29a0a7417c53a6dba0ec441c463263e41770353d6e0d751292d7278c281bdc925084a563edfa9d5fbfbabd117953ccdce771e46a0d76c538bdca8aebcc8be36658c6f2033705bcd983abb4fe77d6329509e38a038b1fd8affb0219219b28033d6822acddde556fe1a93e0f7d0950a189ec182a945d77836e7a5a63da3e3e105ad048650224452bb6fc1b6a60a6bd5300fa0ce835ca035135702352967fd063ef0ced5ac862638c4c524dd57274befb9ffa149c23de1fb50c9b0a1fb02a9c3f4b6d7c94c5db0306c31d021a9939aad3563d47b50c1a99eab5f7a231445bc9eb4c86fa51e1d52ca15f119f6db6c79cef5a55353cb7962faac70cfee37ee668c58f6e5e96a3de0a309106bf9c8760c321bf2fe6fb8a293f238f3cade16401c69b58ac6b951114c4b29bfd1e4a4986baf2c6049a79a315d1b76746cd2937f934e77a6789acb928151a54c5689aeca73a9db82489f4404278c246fedebd2b5510ea77944fa6a0d575dfffa255b58af53a47a1a0210c608044986772526f8597b3b477d5812046f7b7ba00ddc54b9b4d777cd975717f7b4722e670f1f8e2a4cd169c0c634d9f649e8b51abaa4cb8d28534ea6247ecccb79a4fb41f9783e47d8e1b7e38a881380e318bf56a52758f04bccdcfa4ecaaa2d93f1f023ca3b0648bea9f4304bab5dc824bf7eb991af5e1fd84f644455cc42b1d781a1c7ec15185e771f0ea34bd1fdf90bc44f9bb1fdd5ca3f801e1b3a8395b969c9cc77bb985d1ef8b83d26c6a59ae18e5cd1b3ac8ad0bc73c2d4f20026a16be58580dc54067e61ad4a64fa329238003bbd9ba55f4f9b28f43703ba3e3850b900a8d3b8387fd9128cf0623b9e85fa4a277912e409989f475dc9d4018fead4be10420d59e53ca268ad58efa3ef981b15165125fbb363f24d8dbcd8ea0fa05b2bcb2abb7a3e2f3e5fbe65f1593cd54cdf4edd46267b6bcfccabe7f1068d357ecf294a5e2e3a93b78e712cc58b36fbde001c4fd563797d102ac550fd341abc69ba6a09db30cf29a9142d715708c917a8435eeb764f80236b464141440c225925d22bf833ec54064241d14701ad087e1f07260b6705e775e43c620049645ab8daf2a692ae464fed2383d6669c46410350ebfd7b8c776f1bb9aa106b521e82a76c8ba99d5b0cefd0cc1e7dbcb1319e8f35e3ee217f0247a05be82aea19cc748c7b767e52140f9248a0e0f9adfb5319198471bea29fa09808a784e3d327852cd3e8192b05e9a0270b41d5e77778445ebeaf893f52ade75dcaa1a8d840f0869e9bc011c287e2bc541a31d2d12041ec3e5ac9398efae668f11107ebf60f6bf69a03cec5c5a83a33fdfb92ed9fb761ffc1cb3f3e08d59c6eedf252ab99d3cb259c1876cc23960ec55d44d657c7d4ca46e8a4677aee37cbb7484aaa34f562fc670be615e3c6cd3ec07b314f55f7ac29c1f59b45b62c362c1bff20adb8b19e8dde79e2e561ef38972de476492d5091006b95c9659e52a1862159a4eb6e141f211ee0067b1ec8b9579a58e5a854e75169b4244d4c84e7d17f20b3c159cdcc4608319e07852b2062e9740916fa43a4241b9604a98cc1b2b58343e4b54312147424c24b8abde8a4379b4d35d0aac3037e2d95e34d1697d4cddf4743b7ef6590d6feaf0dd346715bd1974cb6d3bdcf18d0147b7da9350a93974e62579cbfc4fac376ca97c1562594253e16f79010fb2c5770596ae36c6159c387a476f4db86d284a73fcf125d4376059150993266485e55af05aff5e99c0a05af18b5fd05742079559e3c0ff1c1621bb51d4d66f443466312032d18d1bcca4dc9238f66b109bdbc4c7c6743034b1698f910aa2bf188c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
