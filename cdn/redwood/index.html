<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82578c159b98897f0c31e1681c149aa7bc972092071ffd2e5c97924343a29a29194cfffb9078ca97b822c6eb8de9188048e6799ca38203bca07b115c49518241cb2f83a5dc8178b200d27434f00e577ebd5192fcc4736e8a4efb85252a027d4fb201db6699b41b57a89383d0da0272183e5dc6bf45074eaf3bca54e38e460743c1625215547f80672a6f242ea08f690747049545a5c158c63a9e94ca41f920ebbb5393faa87ca4e23fb1abb2861d17c478cb29097808b39b4a76c030ea8237362e7d4756649b00710feacbd6a680cb35ad7334a37025ffd8fd1f0a46371de254182a217db08b6bb5f2d8902131fffd15e7a49a496a44c1d0f8d6d5c4cb99f1c117a421bf56a587854957234c8aeb6401766806a1e144b55b47292dc25d1c71b9af089a7bab380abcd84a0e16b787c373e0bb3b60f219fab05afa1178513152f1c0ec7e5cf66d5ce53fef2a2fbcd50e4925fec02afe6c7e934808e9153b02511f25d04f639e77f97c3ab9ddbe6f4ffbbade1debd4b9487b5f84e0983e19fc3723226ccd5c2e541223640533eec2a2579c13abae5dc10fb0df7eb49472b5c38dd82c8f02f0f7df3adf9ee4fa2b8f3703d1b46923c62c2a70e083887d07b2eab6c0a3cb81a9b48a4ce541923eb7119833cbcaad944ec0c588849c055baf0e06a413a25e760a36b858c9e74a7edfd416eed072c5b6684ebf39768bd4dfdd83f5087511df49f7e912a480cc8d466f1ae509efc5662d6d414716e65533da1d41c055f7c0d8e2a7dcf6f64041ce20ec570c88126076b6aeda6513f97fbeaa678cb24e1478f9d9ec0112058b89ac73927da487cd3e5c12fb880ad93e9b2b0f2d4f1d4b9591670e8275bb7bd093dc9210696b0880da06cd7e6f0ec6d3d4a2d921d5eda052100a6a3ca3ba45bd4d55f58e535fb6aaf93e9450f54a11f90e5ab08e21949aaed28aa9edb4b9d081f27478c8e1e4f1de2dde5e620cc74f9c96e15cfc99af9dd7fcc9f5648153b18cc5d0e46eb1f1ffcf4793f91d49b54e3c18a1cea7b72c5820021133b76c9bdd0d3afa9104c23d5d56c1dbde1fa3327c0e334147ae6b3a54733b3dac66b5f926de736ed60aac7ac75d9255a4f8398b912a033d8dd66c0fdad621ae6998a1ab4534927666f6e018be35608e1d7c403c38bd1609e6f941756869b35ade864ae20114a4a60f04cb7401b3d21b8b806f4c9cf8b63386b387c87891e87b91bcbd4978e2534b35a954d8707954bc98ac45983a74a15ecbf85a91a5df96cf438cb78c8d67d639bfc2b1629618ef47053e411b62fda93e658ffa22bc5a5518ebc9c394056e3bb27f2f173cca235ab9a0d291948a9fa70515c4f75e81be69aa47ff8a725578c5cd8a895e86c2be6fabf8038d9bd3d89f6db2a9c0bfc8ad15de6a6be690886400416c12b67dd86db67960c88705ba94af3004abc9008482f3f30370b71f8197bb8d5befe464056378da9d7b857cb98042eb576652644b3b39d19ff09522365cd12ee54a249afdb1e182e22d3b000d3e868200fc70870314c25c42e42d008cc17d47e7081c6b3544c32cc6ff95af4089b08939361c2fe4a1018455f62c4124b6f87e289098cf0a2179e7e1392afe47f708f6628d97642e3f1236ff526d50f6886754c7ad201d6233cedf0d6fe16015c9910879042d332451fc14696615c11961b8f11b70b8c373d14daa2588ab820552e886fe30b0f74ef7312890136f7c7d772976dc22ec6848e24efdd36c08a03a15b690679df1675f49bb7a0d7820bb3f2650997222987a1351e0c734f0da44eb5ccb98b18e2cff5d43a80a708cb2d75bb5333b40e0cb43bf6e7b74c13286e303fa78eda89e691c24d3aa88b02fc7f6ca2a6d66ced5b97ac9d85c47ab25d88f0bb2e1c3393342f6f0af2d4ea799bdbdb4bf77ff58386ea4f2068707cc968dfe8683e46bea859e0ed78661dde223fa805dea5b937c096924d138fa48e35590d1c2de614d2184c4f73da8bab2d736c72e6a5185a1a1430f9a2e224b549a45f17a2f70734a8910187bf146a444f4131348cb4f0520c428f512122af1836eacd6bf7f24574df1226150a18aa814789a34183f8ef0f15a6f3d8e2c8ce03341b795cac34ae9c1be428b4284f08cb7fe84c359fc4f51dafbcc0d3ea590d1e71673b51404ce310e59c7e5a70ea993dcb5e08b52c5fd236c070b45148e689b5b8429f6641e877c3cd06b790f8776418fae2e138cb45c7f54c51568728c5d364b3f256fcb8629b4996b57d8c8f6e990ca56bea5d9c6967a27ac66d88ba7586d161d9a88a17d7b8ae88f9c129fa47508f0b2799e03c162575b04881c63088f3cbc4950dba0267359782628bfb120b76762e878f44cd10bf444b2f00daa6d3afd4f125b91fd95b28508f6ef73cfe44b39c4fb94eb0bcef9f360770d0efdbf5aba1e5a545da64c02bb740b25b00d8b6eeb4549a18f31c22525921ec13a628c3a5a8a72ebb07f7aea535260b8ec147cb76041546d48d25397a0355d735f639bc84b2841ba0e0f21b340cd55f2f30aca13f5c2371e5ab506a4a9ad87474df33f2cf38774e045f9f5b452fb37ce4af3010b692b6ec7bc73e238d2e5741bcd5e95a37c80e999fcf2945c7bfd186b10d9074f6bda61b975c7bed7744d1ac3d613ffef0b97c25d35127e0206a9e1af45058df6d8662af2d6fc86406c841ef1fc9e3cce7583e39dd00f481131fc3a22bec88ba613a1578f0d5a3dfcb4e33c8c39c8971a85070dea1b5403d5eda17cb6d02ac2e2106437b4394e38289c04c202c06655aaf0cb2374dd7584eb2a916c1ea395d5b313675c5ed768aef1565e0552c9040293094bab3a6608a0dea1250fe639d4b2f05f1e938f3dd066151b609d125f2645b3e1c3f00c7f8a1361d950ac4c987b9b6fce1e95c741d79bb17a39e67d646dbad88c108ded9ce64339a0b8af9af1b5715b1f89c2626b47c55c6c8c9c09bb593ae891596df5a0da2f4b86e44d7178e8ff0499b55fa7801f6293a7c8bb19d9d6876f26dd8c066f250783acc30c6c9052dc09e4abe6910357ae26814ebeabd15c4bc316dd9a3facf1471002cff24a2231cebc10041d4c039ac7b7cc1c4442c2ad4597451970c0dff8d5e66d9e9a729df9c943364a2c8cdc213bc2b6d713ecb603aba423132b622c1337603cb57d1134daf4b013936affe51ee69157e5acf907f8146cb2dc8968ebbb7e64c6c4516e9068404d0dc3bcea760dad5ef11d4cccdfc1dc07a3a8cb22a58c62ba128260b6ef6c7f3716a99e249f919e803871a81fa028f96b73c422e832ae163fa6fbdfdf8cc91a10b2ab1ef042a225461860b82778d5a6e9dcbcd70d2e1a73f30346df9171980841a8191d4265621113aae83ae8bb510e9c454491065818cf65453979a15fdf126f66d8174325617f143080b4e97f9bbd3f1e89ce1256b9c63aa41e2a4d0fa96af88db4d2cb286fc59d734cc8f27e552b28156b1e2305d7c49e0055861b75b6a52fa62c0caa8c72bd440583e6dc333ef0d2944b60c61df76cc1c5dd88fc3b466110c141f27a0717beec065d13227c4c007895dd6ecc2812be17a86bbde1b4e47f7929a8d7b6138b1a67d35800f9499beb958ae01f6e3226ac8b2541466af09ee55d7bc5e3cc117263961625f15e398fcb35659b924b180a526d4b3317892066f7ba2e03801be277686df2139a2ee833e97e21c56b52beffb243cfec9f07752adb91d9c381060e944afd8d8b70939b8c894e94615e2b4021b01e74014e0de12ddbec2caed07f8eaea9a106d10307df5d3ca56b3abbd737bcf16470793e6ea8e619e5305ffae2731de10c13ed7d9d8cbf7365215cb882c64e8c04e68883123dc9c2b315089e9ac2a17abedfa788a8bc2e1c100f7424f4fe45d11ed3bbbe9beffc6115e4b5c120f9b1bbb7ac456fb9f26c8a871461be7f2e7d1a70f87cb0e14c01ea2039c76036c579cdf978b359c34d1ec2b70c9dd9bc8b5e9b5e96f18b2b82201a651679dfabfac0425a277103df67b52d610f69e945defe679df23d636b820476f1f2c64f5e8645ad7a04ade59e585fdd5d6670fe7360ded3cc4bff6a8523132c9040e950447414bbdcfdcd81d4a751389f2aba138f51bdd4dbcc7357f739e00a14b47d754feccc6aaf39ac806f35db5b0de231579477bfcb6b4ed8255f41779edb291977f502511128d9c3839709cab78a383c316c9162f10509c25eb6abf54f1cbc06208e0848e2ce0c9e211730786b9d2ba4b8efd9fa9e03570fc4d45b2b115fd4bfa5ed51dd54eab308d28a449cf73fe764fe8b7bffaff3b8467515e5dde9f4cadac37e83b31016d12f3a16b0d592a992816f151698e303c2a70eab34e338b399ac57bb44157215e13784694a875f1240c51127e188aa7ee8d27f1f0cc0c70d230bbfa6e0ba70d83ff80f633fddaef5336fc8e934d9418d743e62e42e01ee83237255f6e6e5fb91982f39138ad94bdfb702211865a26eedaecbdee0722122014232f7a91cfa4f36ef3b7bbada47b3ae6788df2d6c9c281500b21f4dc0e6d89a02da57e05972f7144f03f76c08e5765fabea6b87c3043d14720e7ba550facf2b468874c051b560c6579787a0003cea63452d478b1bf53e5e3fe28039dfdb332b41d6fcbe14b38056dd61afe5d95acc8d8c13694ca65acf43538ca618eccd48004dbcd29e55191084f0158f65ae416398094e861ed35ce16ceadff2f5d6f601ebc5ab8d9fd47ce054fd57b0856b74dacea4911fb8c70cbcd8da2220d42525acf7090a0664268c59e12ce19ec3df326f2e947f0a6129adeea79fd117517271da00c6b52f376fd3600194621507b76d520ba01a698298fc163d2528fd8c0571559feb2721f8236e5b7a0ec3f650e72d934f8049aec5c723c69fe3eb75bd60c1ed3af8f0292e672a651969b4a123ac16e38c921fa0964c97732a725ee45e621c2d37ec10f7020f7e345e71acfc0999c3eae423b01016d4b85d5c2ecdc2adba5b8dd79cb6b3a9f00ab225efb40b910f1a76e2b0cc766e3359b61ce3a686b9235d5a211ecfde2fb37d9ed7748a426744c57d50cbbe50db2b25e4695d0661678ef3571959f2e271d129831610cbb39ce5f6e97bb79cafcb495ea4778acf3231483090054b9af975e2c3c8984a01b1eddffa953d350d22180848e794184014a4c460508f425edd32273c6e478f964dabf9e31c18555efaa1cfbef3a79b55e500da7c1111c617d5637927986cf9389749cb49f0a95c6b42ce9bf4cd19f169d5e234d1651dd944b0a00f726a043a363c8806762922f95b91d305b7a7dafaf24f8fdc491fe8737c4401ab38a3dea13092938de6b9222ad01292a0e0e97c045e772311aa029a52c2265bbdbc7a08d4ca971bb30d2e38133231f409a4eaacffc00fe0d6a3bc2efaf6dba13bd6018971adbe780b2ecc259606c362596065652c8bf692d9f9dbcd14f8d7de3fea8123e7f2b2613f259a8923ffc17b1bd9c5140648eb2e85ceb0a0bc452bfdd39ef4e09cda8ca548787dfa92e3e413537f385a1af33a7b68686004e51246809d5dbf99fc539251950ed249496ddb55751852360f4de88fff2f2884f9567cd37edf4c504d38ef7043ee85c7fdcd122cf0c3eaf72e76b8fa265a32cf2bfc2aa283144cb6308043310ccdeda9212950b5cadfb223f1790a3140c06b28e4198b0849154f0390abb530c6ee9fb39b52243e9da707f844bf3e954b7fbd44dba01bd57d46d415b1155695db03ca79f9cb20a0669c2d3cc73f3602294230374cba0348051ea2ff6820ae8ab0b8cf5a3c75f36c326c48b7d7e3030dd25ddbaff5f895e67aa18a674db2c289b4812fcc8609318e8cf39ce6cb48657c39aea0e296ddc1859d7f5b3921f04a615db23027b17d08296fc1e69836ffb6ce7b481eef1e2e6e3a98e2062e01a22435365c61f41be8f003374aa5e58270e9304a144b15b7b0e4d1faa63073de941de0939e60920729b36bc889f19a6c13078a0c6ccf64207fc566b8e0f67b10a20b66d5148ee7e22db4157953e2f3e63e452867cecd366c2ca81a7f55389962583cd09a3503951fe247237fab67170e02248ef801d372c932e000927b4336056955f8e10e71eafa2167145839ec9f9104b5a62055eb7a9ecae09893ee877b2b391613587bbafb54a0ed73da024db00beb08ec155d81e716c85b9da6b0aee46748978308b955e7a5e7b0b28ebebc0e0b50c650e9552179c36becde9f28996a86f841aaa6f853df15a7418b3bde6953f2df7ef57b61bb276962e1e47f69b50f77df63bd62575c8a11a5625d2facd56da77aa82578464198d06cc0c5f2672e94cce6dbab175b89d9f35c9f3214b9259157aeb4624ba46a7b994e6e6bdee7d313b8f0fdff9af24d222674ec53431de8cbb13b8379833d9d15aae99c88ef0617a4b4dcbc332dd95c1fbb6771012db8179b0a2b9f134fc4d6c91c131ee0163ccd067d80349f3d8f24ac3923c76f9c7bcaf6f1c232735d1cc8b54dcab8d241d81ccc4f5a941d9827bae595c3125ceab491d1c9540482ac2f86571a76d654dc5254dbd6d24ad1a7477e296e47e69b8ee0374a6c6f0169bc37bf75b9cbb46f00e291e06892732cd85040f4c1635fff1af67dd9be1d8f5ca7756118ca93c9fbbd3c3afbef971a141a75d35d1d2b60b2beaa38bf5c4146ab0fffc36776276111140f6d69b29e504a9969390fb9c53dccab68bbe967ae190adcebc9da2f4a9db439fca01e6c42d1feb3171d24c599a5051fe0d81a2c37ce45710f710acf555cc16fca95a9b8f846fe1ebd5d6dc950ffac6f404d8ce7c63f903b6b1ad275b73b4a18d2cbc6f94dae24db666125a452e47d30382122910240fbfa763096ae74f42d61bce069d6d0ff6ab8a93940722f9d0cb291aefcf58989e88f54fb41f8d0390052c25e803297eb5ba92d474e267bfbfa4a40839d8b87987ef63225f748d9eaa0e7b35f9dc45726557c8fe47e1ddb7694067d665f4100ae04a554d2df6acdddb0b67dd8ee698cc1e95206723e993e2218acda9744d13fe1fe952bddc909d0d8bfd32b70e079ec806f1981935c1ecdb13c204532c58e1d3b6f1e4f696eede3fa1a41f2285731c2084602e5e63cb1981367296b060206e3546b9e4eb0d1372f10a8b715117764d96e5c77f2a529c1cb95bd39a6e4a0ee8a1f0d49eb99116c8f1f698aee5f0c5b55f23259bcbff61928224f780ef9a59de9fca7d89d6404799cf33e1bff1214ecc3c93ca209dddc179ac8e90e8c17d5ff70dfe516ebaf4e3a3fabec1c2570db14724009a8fafce5daab3a6c25e10f78cb85d5b0bca34fc2146b7e07e1a9c2431259ec39bb6b803c1cf2e8929d7bf1f8d4ed801f9196ab8165353ae6e5474e7368802b073b81a6ecb09476ceaa7634759962325f7146e40f18e5c7496d911553a2e43ff41ae590235d06331df689bc73194adec7f8ff4ec8904a48ded559fc93a74d8a5585bb35284c353dce792ec086cbc6047f2917f82d387884e6e4993c18ddb38f530333f8fcf66fe7e82ebc31ea13f77e1ce47c6bf1557e19e99fcee2af4252c78ae8d60cad9b30fd3a06e0cc0bd876e718e51914b7e016aef775ee18781f7aa2a4eeab41051fa9800d0772544f5862476ed8e38813989d06c5385333e8f56ebe9eb0ac80ec68d1eb548db95ad1cb64dec3bb510e58381ea92254db67b39200cab5d0f0cba972a3169a5671263a6140760bd2fa6428671dd4e48daf9f8eed98e659b6b8c9f7b8211b11f58fe3a103c51ee8faabfbc554db698fde9a11ea9b2471b5fd18dbe017bb93409324773a1821fb3415845d8bf7b6bfa1584a5690a56f8aa4aabb383875ae38f8fb886fdc190d88cfffd300bfc92df210ae03ec25f6168fa7ddd5900d1ff2d07fd4fd2473d513e67eea7e3d777720e36cd70e53e81f8e5f20110f974b5034c456dac946cfa5dacd9f11fd27087bca675c2d5e8fb210ad9f2be9df1d9a8f50e0938b4d5cad4dad119b2e5751231e6920886d95938d2872d1be5121302c114013b36ad40b0f182d820e1692125b2a62b885e48952cc03837ac16eddb96917778f8f52360a89035484e59846079a2f3ccce4e7afbd9a23bb2ed1a1eb2b55490c0fb6db59fad1af87fd1d7afd029be437c25c3c1d4f78275a99fa80e9567cc114aff2aaaa6df173f4da3a0cfcf78ef573a4da5792e349a82734fd6509bc1aea51a1b2fb18126ca6f11f1b259403e60a0f8a4ea288d88df654f56f2ea9bdec9ab273deb8449a8909947659ca55c2ca82c1b590d8e38f9f075dbf618c23f4e90513b6ce32c29278e7530b292cdc7ed3db680556263d6748f3b07c6d3a6ebd363cb1ed7a7d185788d41351942a68847f989e3bd3bf4fb5d3ad6a8cc54be56115e6390990dbb6f89a14f9b4a9fac0a38765e71615ef11c3a19e1709454c2d5ca559fce9acf4304a92cfe8fb0cd06a101a125a341e94cf4361f251f35222af0bb7b70b7481105e08aa8c0f7c66b28bb3ac8c79c541472fe7b224a67774688eeeab6104ca8ee6417d360c8c4c2ebd275f92afaf914d46cb055771b1a3463d2113f6d40fec559b61ffeb897982b05013d2848f124812136bd266489ab9d9a0afd1d5d1b46b52354b9f0f81721b7f36681a22358f4f27edb7b937c62398ee04e4c2027cad31b8c42782c004c3c8a82652a456c0224204b1d9b64c8d36e4db117989c93afc5ce6c01b7fa303d4d6423611e62c88d4ecd46c64aa3ba07a195164b341647c6da5e7325908f4010bc59ed4fe803c06c9fe239dc49b8be5404f80f585fbf4c5db1374d7bdd25eba899dbf91bc57543fac3e082f71af832ec0a37f20e8ddff801e8ba2b02936a46d3225ec3e428a90f04d7ca0c4b59b5d059215d29e3d8434fc39a781821bfb1db3443ff0810be0d640fa04e559727e3d726d4543a6e68819e2bcbbb661c23381baad7b2a8089c4958530456f0cf04d4774f5f2a59b343b33ed00386e9b2dde41c46d404be3e613a7f3db8b32c0b9fd3fb3258ea30a990ad0e3d935585c65de58dbd16637bd32541185eb56cacafb4f5b1a0e56c750a4030f1ad6738294a704289aceac539c735a71a5e3cd0003145b4f360bbeafd13258694e2e77985baca657f7084c3da46a19d38b3349b9a06582f4d086c175e68d425072548313cffafbe60d1743a7afece54457ae8399c64b1d42926b39ac0fc8c8dff6d20b1459c1f92eb85cd3baf155f23a3f524fc281450d58ae804738b8d01ecb1e8ac450e23e90e622c2fea89a75317037f40ed379d99d96a06ec518a328b7885ddf51ba33aca0473b32ea0dd78d549e0df2495e3d743159cb50a123a9059d90237e7781737f764463f9bf802628deadc2f00585be771808d5b91e9bafd854ec2f69fecaced0e3422c4e8e7de18a819696d722509749f7ad259b13329c34b3407f81d59b8bd1aaeb56389e91ef4ad8abb37748f88085cd3c731057d8bacf647fd0b71aa0579db488d2adc917b88ccad91ba9c6b7653b730d48abd3c9d27f9ef09ceda9775e26b87f7c8ee8800f1b921a5951826f65ada56c3af6fc81ded28f2fd2038e79a64b3077b9a4ca3170a3a08a70164a38dc19fa424fc325868625da97aaa8f89aa5b3f296270af2b75c07332e1dfe3a591aaf78b215f3413df704c10486ececa0f4f3879fb0f8a831d7edf5eb281e890117334a0ab163f1ebb7136023f9e3fe825371ee79e2f408e80b04c7b1f6d62f57ee977d07d2a1945403c2c27232ee3360a86435a0bea9002e254bbb0ed4ecb2813c4622681d98017d37f13948640e6ccc7305328df26c75263c6fd1c9e047e6a98ecd6775be3fc2c598b95ac83ef1dd5a60f0ae2c0cbf137ae4a64836458ee08cc95798d6d763a8e29549baf09255ff1261c73446ed0825ce04340d9b2c2f219e3d9b14785505a812117e8dc5638cfd46deba6771c14a5f2c3af257d761f03bef291f6e146aed6bb983b05d0a02ce193161403bce77c33c667f9f5c8a566a9904cd82074e7909fb23f7a7153a7ac4f6873f8dbc8862eb673c45c3acd3a6eb00c8038e8c71adae0d490dfc5657e64bd8fbd9b7e4f6fec7a9a4f78ab6ae71580c41c70635dfd0fea371df851e4e6f57e4670ad18cb3ea07f612bba3a7a921c6949b8767839c7f89367c2131f41fb4d07a2681c7facd55986e85ee7c4c8db97153c5e33b29b72ab0d91f8f8a3c7612852da22cb8bd7114b9d749393651fe7ded357ad3a5e781e5f734f9c59dbdc6376d312b56754ff760860c3ca923083a5ff6793e53c617404842649da7c2647abb901c0e3e5791a2e10ecd0e6294decf71b2077a156307a9e55d57384b2a5447799f7fffb0497d6419103865f0a07e1cbfda807a77afab6e0618bfe29e0992c8fee7d0282bc11106f18ca90ed1116334ffd63cdc8791f50c07f68a7f644f87d7ea4d5e311f1315ac0844b4b09c0fbc6e537e1c79d36d7d607e23999eb900fe9450cf16f51237738c4ae3a656bb230596ac6938924b084601b9ec9314f58cf8a22729147d8a7fbbbb5899c8f0314de512dc9ea83cda4d922f80c5f778684653733d141d824218705040b9696ea2016eb6466203dfb34bd49af2cd057474834d53f01756e2c5e8e9b786102afff4ba73300122573470b152ea5e73b1fd285f8fd9e5cd613c3d1236021918e8af64a52c2e9c5a6f7c18fc7fad31860c6d84300697a898719b9c93f2e6bbc681737a24e5e8dbf06d7a540f6279b79fbd4d9a7cc3b8b74bedc97290a01ced6356cc35db4ca51b108afa59b69aee10b56c6bd54daa734d6df817806605a44fd69ca96c53981193bd37945ac4bc236f4a78ec2f120d47d0bfe6b63a3e2b6fb5ea20891b3b1b9d00c486441cf8abcf17d09c71023042f5924ce12718d6a8e8be704d0b446174f6d1de9dada7d8f02e770d3696827434b5ba53dc3e72af25bc7cb609f0e54f7aea7ea9089c958e2c6c43bc6c00c4d524f144182e2dd5f64b465be5a4db23e014ce08a36115b2f0c1890042cdc8ce20db44ab0b51ee377118f6842af932e50b0e5fe02a33f8156b66decf64f9eff84d00b4422f78ac4201b8ff6b67dd5e83fe1e37533edf4848a133f96266f974349a5fbbcd1b8a302a95142047857c07cdbb086db56afea627cca87a4cc269ed70f0d8c60a1daa58045a180b17d36520d39ad8663f6a0aaca451ff7c2a179eb72c69bca24bf2566fda15ef80038a7e57c1073ca37d9b253ee44a3aa2bdc82e375d096e6eefc8136203122ca69e851c0f16423f66361420a1578f68ed7c9b92d545fe708169203ef9b78a2be12ad99b30b24170f83e4885e533c9e8a3e1b1125cd60fe4d544edd3b3ff370e23e55e5e1e16e2938215da1d9f939f1b226fc668729519955b2363a9d3dc197ffffe3d83cda106065e48c43fef6e3f7327323fcf9e99dd8cb8d0e487899dcdd6f44d55c9691c1a8206723bf5f0f7f69c866c76f41563ad5c9134dd59c2718f851d26f3763cf3f157f5107b8ee069678f506cb9e23b8a0ce35465d38dd9f0ee19c2bd58ed5c95f8a886f8eb4174ce4df18b6ad6e2d40bb8311d77a0bbc7ba94dd6b76067be93ffd7b03194e66342720dc81014afcb2d9ebeb352c9541788c108e1c86d0ea756f01dbd9cceedcf45a27a1717402b265c940a407c987243cb9d8725dec5a29e80112294e02b8278e2116a03d95a67d2ae2eebc4c3fcd895c2a313ced1f2cdb3c5fb3b1451a088661f11f8c99f254f14102413df472794e23a13b0fcfed846f6bf7eabe0a6ed050d5f272e8425b1d131bd33bc14b088beb8912b29fde0fae6aae7783a2e5590ed97501208c8fbe3be25326e88486d989776042dcfa6d424c6fd3a3386a7a07c8fe3b4340f68399aa0a4defafe99deca90ccbecd36fc5f5c1348d79ce1b67322c7e4d9145c3541e748b7eedd341e6a7b4bb87557f5f898653ea2557ca8dd74f8feb92662d464a053b2324502ce7722c0cec7b9a67e43ec072ef25554860d83f5e933e8334f3bfb757b39fbf0bb88e3d6eecad6f5209159def75a637143af8f44887abbb1f11ec6b9fb2832247b8836957637e2a54beb2223fc7c8b8f829daa7e30e7ffa87b67d85357e43b0e1b5556497d6f6e1b12702594a7221dc0b2c5641eee6feac10541a60732a4b2beb82f2947d1aadf6d735e24339094b9724086cdf9b5a4f7be308b214be70358a6ae20b891e1359b06fc1af643d4431ec853d37c37d4709a8b41d97ecd8af770dbeadb6d6bc0af25da21715a59b68128600203549a914c4cc0fbc81b04aaf77da998121d46828c5dc8c514008ba3cc22425bc39434882e8aa0c736920e54e09450dd01c666c7989d251ec57302695f24f1c1241bd7af47ac2a97ffe948d31bc5e699df38644fd879da85af37567dd40e447aad07b49694f72411705ffa64f6d080983bb4d927fb70fc5c45f791f00e9e968b987d7b079a7489e11013157ff1af90061a3e926469623b8175c6e7cdfba4cff576d3c84eaa3605c826899ef7618f19151704a1067bf78898f8cfd164155755907eb63f980e4af88280ddfe3eef59fd6ec89f6110ae2dd1794ec2ef051a1b508ceb59da75ec99627b2223fa06f7f405d3a9168d21ffc6ea3b28fb62f550ebbb01115b6888d7207448d69f92f6ed4af02414da1e2c3aafa976e66b9bc6f1308c2c7b2227d1cc4786d722edb049ad4d28514c17d253e40bafdd399824eb0cdef50611b5e5d4991c51f0557fbeba0bf051e9181d139bd08015f281d3e4e41d5cc551bcc6671fa848f2e9f2d98e39406c03e59547280212824cf719be8f0f3374358775b3c5c2302c477211fe4d0c1f16ba9c052c4864ba9e4591847a4741df20cb52e45168ede387a58c5b528b1da3cd98fce35958137be106e2378ca56d0dfbf8cba361bd205855943490b62e6be66b638eb4fd20940d24dd290095b06d2659cf514fd85e472d11d230db12e336f1710d885894bdac926cbd00e2b39ac29fc5cca10a870baa005cd007c42660554ea476f184121f167835cda10887b3a14120af075a8955b9dd17876600fb1dcb8d6ecb0b688c0c2642137ae0db728da7c2b4e109fb317e4ac2b75deb7f30e77b1e49cd46f68afdfc2ccc0d5c3adfde15de1a45b6785b60a5a88905c42510f9f3afd719955ddc971797042f888a2fab15cd43692af9cd30b3f6faa2f4318711fec6b89817966acd00eb2818ee0414a2bbf7df69b978a80a7f28d28c396c2d71a443f6091b79d4518ad720c5789864aa7396a2aa4015644b6fb92bbb84737554f153a611803d952009f141f5004e194c62c78fba2ec057fbf0224914278c68d36b7ca318a5ce60c563d4c6e54c979dc0c154447b250bdbbff821d4b89af38f3f7804eeb0189fb81aad480f7d5f922aa82822eaa871dc26928de80d19b9c89f111430e69cd90f3a9d59bdf4b3cb91f3d814331f9bd40b54547e13a532e6a58b12a46d665f336683efa24365496bccb985d883c8cbf141af87ba8119ef607fdb497abfef50c35f5a40c47308f965c51ae16647c2327da0b890d9c421ee0e1d8ee497151cb61c35f4310609b10d77e650eaa438766f22e5d9e673bf47dc0f077e9dc016c801fbba3d5dc70c9f6125470d675fbba30e09fb40cd329bf306578cfdba6b5f9ad2205ed928249c344cfe07fdf6e9060f021b81b1db5252883f50281d47be1237d43f0f1cc3d90a0e287190e19f41ca9ad0024e13cf718bac68c017184eeb6969fba411d98ef8aa636926336f7ccc14974954b9a976e83c9a5029aee978c53db3844d13f6cacae41936adaec5defe4b7c3764ef9d94b4194b5f36346855c4f99c4bb7ade40f65327e2b0dd09001aacfdb3107589e4302c3c542fba264192344d3a59593fc5231efc29ac314b3eff9ec5d0081179b406337526bc286654c93767ca0464e8eb245ac77cbe765ce77c403adae621021a46411180a28d2edf28d784e4a2e23782f137a83b58ef1060dad2011dc726b88ff187de1defae228578628bd136438f381b24809602c018df36e86570cdd8869c2b58160cbf300d7e05c6e7c1502a650a02b0a47130e6ef225d5470a3b350ffd86ed941bac44f06bedd3b76cded151de4c92480975a4dd8ab4223e9c6fb43b5f6188c20da38e36dd726c9c59fbf2a035c1e680bad83aa0d33cf933a4ffcc81bab9942ae39f86aa4a469e3193e3c9f8c8c8c1e2771c6709fa385c08dbd8be7fe7bd4fd59e811308f67074973ac3f510b8b50157ebe3563ebe3fe1507af7a7d2ea93ff4efbc44e30b38a810c7e87d31f79d33a1bbd90a59d80192af9040dc31f4778191a1c4d4322e9baec37a0cd055cdd9ab19a3cd0d19bbecbf1cd08a4bb1b3956484c3a88ef8b757fdb65f69605df373b4e7a8e3e29f14345a7eb5359f3bde690343bbcb779a726f30bb99c5c507dee3e1cc8ef8ebdfe6bda57f2caade5ea98b17a1694f9572426ec4b09aa14ee968d455ce75ecf32bb8002bc053f57ec0fe235d2f76b97af709f08d63936478531c4ff61be79c1d348a3860fd3ee6860fe7c2af97320a8800f7ea767c000d5ed7c96cef5c3aa35a1b24256c85d2e8da44a6ab5d5477282e3b92716f46ca5ab2bb5bfc32968a7b5c8164639b4ae256252e65042ee0ab39406f94dd79b2d3f4522908a6f2c82c016b3f61bdd4787a98f0196161fbaf209d80d03f938c8f35849ad5f320db3e4550b3477ff49ddff2a6ee3ea7279e8bb18d3ec4a507878e4b329565ed568bd99445da3ba14e79742f61364968ab36bb1ab343660f1491bd9fac0af345f9e573c1b703d076431b7843de1edf4856572e3a53166c2aa65dfa60ab2369f4fa72f603c077348cd326969ab3689e14a3b03a9adb5c4eba7aba0e727b95c417c6603354dc0d8734c46f0106e6e0d27d49f49f3a5228ec787ab74f668700a78da6bc9b6067a6219010edf40f1c6f90c8a20fac9c4d0e95f46309d0e55ed186a987847df38fdd2eaf6b11266af54c02a926c06262db3e6b51f4bfaff2f9337e729a71d6481082a4e9e6559ebd315437b24c7848faa054c8cb6b0cd2ecacc75846bd0c1f704e06d2e407928bdf2123bed1414b46bd2ef1e7aa628f942fcc026f56a773fafe42b0e42caa31760ff0386ddf852d026aae31b8decec08d7163a37b4e6e6d8ac95430e0d504ec9d9dfcd67b64c6427df4414e55414014af6a3c0fb8e0e1538e0eb2859558e5b4a812e3ad4149558126a0225ff84d509431f59af05c4a219074f47a64594d1b847a4e62a2166553cc226d85a7289d9205e3bf9ef0e04ddf0b58725008882ac0e7640557a029f5be26b7e429b1863f68156e8332dbf979e14053d4e07c415cbb12ac8789faf6909d1efec0ea3703b33329ed08639af32efb0c51551908260510428c6af3822b03a9dd40a1f8458fc0885c4a882867e3c5956bf3ce6f595cd19b8565b733c921b01b3876d8c03f1da53d43d60f9276737466f7fad2585f571fcc004662cf5a84547a59f8276bfa5f9c486fb1a395047fcac701c2f60986d15e7dbbb8a09f01b3b4f0fc00cbbe4a15f90367215a71c2e34932778e48cebe001e6267a75459b3be0e95e499d234104002fac7527363c5f24694d2d52b68a36818a9a2ca30d77f48792f706d6f76a6b1ef72691c6d2c4d5b02621d00658845e74b79d239d58e0b18d035d6616d263f949a84a36cf90012eac5e20003b497ac20a835cfb13e923877b10f065418bbf1a35f6fefcee1f0f857ef528b888f60eb52049d652976e9a663b5b436a94225701f5c7b7d1f96c7c8f715ca73ce3d235a27fa6ba53d8eab679ac6c2eed2cf564793aba425fa60274db087cd8a474951e38af4057024d027922636ef16d1e4876d8f8e7015e39f9097a9e1d0e8ecae3d05265a0edba7f5c9c4fb013b3670cf2d7e7a73e4e0656250e47e69b4ed446aead930aa0063fa29fc1cc5522821bf7329c3112b20f6d01cd52f3b23b80c5339382c7097f1a81f333c8d17d95b1bfff59c94fbbef2eb5b5b1e3bed6187adb3443159db4e9442148ccce1d86b95af62d02de44f0b042d9471ba155d541f90e388d503f38fa99354af8b19a792205418f0db9102267d2907a954cd4962e49437a953f965b8cf4214049616b282c6f640c063eca25b3543801ff4434065a19a09537721184dcf0ef7b84117e6ce3a2c11870d95642846ffe02b8c78812e4bcb5eac4a7c4bb1414549a8910d98f422488a2d0a0bf66a0d432e524e2d220392c8f7e14bfe62f8083949d28ab9ebc886779248702b023f79aeee211cd595e64c459428f0eb698df92b00644501c1e763a3ca871c960238dc95ba15d44f3542ef4e61a3a085718d4ea9dbdd70d20138da12a4b4da4aed28842ef7e679325c62ad7c798461ba1c0bc26be9a98b8061c36e2d3657fa3d2c9cae293b473f6483ef768d13ac9f0511252b7ebc4246ed32353aba9ba6c58633b061c351e77a67449b65c9bf47f2d2aca7f4e10ba405ef4acf68176f89072ed5d6b003ff287b2c636c5b0b1ff08a45fba1506d3d73570b43560ec72ee199ac49e1a8dc458a0d02e5272f68a6d91c35218fe033da8d18242931a66bcf0fb380755ea70cfcdc203b0878b91eacb1f859406dbda1a0a010a00516f4887755e624ccc5d7589a017533b04fcba5849e8aad45a22db3013f6a17d5153e47f596e34160233fddc01a85861ba55633d4b8783f1f6fe30efbecdca831462b290986db2551b6633b1dc538f9a9a9d2671fd0babad13ecace63596406c0837027f1171d22568d07fab6935882fd3ec87272dbb3a4354aa97e9a7ce0bf8d646c26fcb22491f3c060461170cd049feadb8e6e24eb6cd65c65df424ff40cdab042af8cfd8c7148a06827b79206ec9a6ec3a56ce97568066bb89bd63f59ad52a346a36073fd8062ace6d1e824cf96401f51264f131ea3483b3c59d9eff201fd4ad618d0e2aa8fb7a5d07e31374891363c1e02acbe4b2e5df3d3654d08826ad89b491062d38256d5d057c287b67caaab8e9e8520bb4c7c6c70e9949ca034655d82c946c698d04010e4f0afcbf8b8d74266685491e50dc840d44adf81a3f9cfb468ca63fffe6362f6a80e594e123eba4063fe172c40d7307df55e0d9b43d5070174f21e4316521d708f3489c69502a9a4166d8e00bf6847cfee857b08ddac6d540a89b28d09dc2b4da6c1f48a69c333ff59c450d76bbcc8e530094e2e7ccf34f8fae3099d0f32ed7b6ff7f731d61cc4b4b54972ced8860b4abc8303e5c28748350e3909571684071e391adbddbc9f811f79799a6497ce1353b1e245924117afc3074820d708463c8ef5d335231fbe0c4fc2a18ab414c6d268582817cf1bd986036c3dd4c02e0d4bd6d92c5339704ca5f3de255e14af35506d3657bfb0a48becadfcaeb8d779b836c4c36cc95994fbd0fa8535d76f7c07ecc21abae019dab03a2a2dd332dd52a911d009544d3950cb9df77f5970b3cd4b167ee76b8ce6688d33b6e8ff6dc787f45e251c43eb2e211e017f85c485771341e4b0af93bdcf69e619589b5acd6b0dff03d2399e681ef3b3cb3ddc5a514ade8bbb6988caa508dd80169ce9f1aa77c13484888e5690a1aa52e5c75a603bc15fc43f82f39736bde81ba55f8076d2c177b9a2d87b04f66cfedd7a274ea55b7517a61f0ee104b88fe64f548288250c3c67d004493aed86ed93e4d5e09d4a7958ddd852b30a839331fc27ccd50266474932682049db94763429a53d54f4a8a29cc5bf647a35f6a5032a208d4c9c97ff1c68b62476c105cf2af6bd3b03838b02767ec6ec1d18d6cd8177d1c727cddd88b1ef107db70c4f6f3ffc91c708ee38a66246a61408975657d9f3a6e6484b385f0884330e090973bdf98845b63b9e7e2405adec63cb5c4ba4bb45cec30b08627f57dc5fb7ae300f2355d10a73f9b1cd8af8e2bf3519d83e7f98cfb11a04db9768453beccb23375af483617c7fccfbdf25d0f41f6bbeba255eb83c4f21ac777bd1e146f56b968f52f4b3d962264b9376eeb007070baba00c4f5e52ee046294ee6db9aea58aaf7b3be35ba0de74caf00b2d18130bb5ef0dee871479f5c32de9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
