<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1211cc4061b2d54b990ff07887f9371faccd281cfe3da6b8cba14670fa2b24ccb5893e80f86e3e11c3950eece11f16a3a4b5e1d1339dd0c87acf46bbb7aa0346a430db63a69e366d05ac9c7b9b8b7e2062f91a894701c92f53c6136ac3550ec5d7dddd0eccd90ba5bceecbf9cd448f62e4eee182b9968b32d40f44d4d77ce437ee43bac32c1be086c0a1ff776745ccfa12abcfda7129c4cfc2889f876b763df96ac205be71bc8dc1caab7af81d1edb4981046248ed31034b461c4962d0afa35b0b5fc833d511d97b063cda01971cd93d22b790438080a729e4e3def910def8106460074ce27a42e9aed20cf47b1e4c4b513ff283185d95d1e626a9d9471c400181163d4be77eb9eeaa6e00bcc47bd3af48c1b53f20ad7c1ce2b033716f5c2ff68c66423d4f1fa5814f6a6d50930ada5868fb8f332e4b93358277d8246fc34a0121eef05fa6805df72e959099840788ee502033b78ef521ce6b12ed50711a4c10e044be104ced6fce8ed5e0335159280a9b9fd12c47ad27b2a9fc46b3d433d6fc3fc7663d90398916373cf6228179eea2fdfb9fddb3e481cca66f2096ab49e0ba9115eb0f634a78adb2ee48f7c86f73f98f747962f0b29cbd3d899ea2b7dd94fdfe9423ddac00c12b11bfbbdf01571cbd386354a7094fea973b659ec3cafd06ed242a6512c4bf5c1f1e417fd2d1ec08676a680b01602dfa08a6305f490c22106e5417e1b46f34d4a0b9a5e060e814dadb643b813f0c92c3bdb28fcff72a2a676266e0760c186e0a65a08d689c6aeac337279aad870fa25fcb86af5b028eaabe280ae516e8e639808d2c1265f2d6c7d6bdc7c78f826a721deafc907ee14745d73a23271a310b897867ca60d3b9f6e63d96df7c45a5056f9e79da6acc47243bf472d0d2d4f7e68c8beab351df1c76e4d752af71ee17dba0cd966a931ff7aaa6f303d592d77100d1bf22e4615a20727dc5662e854ae8f7e49ec52ef2c4483136365d09b6b8365de036bf37edb1d8431b21f9342faeb0428f1474dc22b2f29782e103ceb73e292be4a290d2149413821be7058702a1d7ef5fd435168d3dea52b3d6a5f4e70e0b75f18e84e5deeda952d825611e1e928fed138e09f0778566730ade3a94344a22ee4dd671838b8a5f9e1a09ff83316b055515b0e60ebc40474f9bf90e935b9e429dd38825086908d14b0f6ec551ea707d5aa967e2730bd50ce8af7b4f9bfac614bab6e50e90bc895fd0a3c872b385b0cb4765bc18d0c4419502ca2b3ed33d8e2eba65b6fca1949daab9d831b148ffe0e44bb5237586d1e2cb8fb7df0ddc1031e805fcb7164d732e8e0294f55b02256d5a07a5ba33d9ce877ecf70c899b990b00d92f1b711edadd388d783d13827990cf3b7df33d6c69c10d0d0722a6a32bbdfbf0a569a04586e2b977c9b123e0692f24f694180591f1bd6fe30013d301b180eb9953d3a34210efce2ee7a548895a532333d93c118725eda77a7151b54c55605f6e33417dec8cd01a7e2380d1299baba3d00f073a2e155ee2d38e1fca40a92816055a64ca3c2f20620eb76848c427c0eadc08b54c3c78f5de9a08e1cb949d1525a175d77a75165776249ac79f53ed78563bccbc007fb71ab2df8c33ccf3ca5caa7aa0092d17480c8a5fc46f55c53f6e82885f29bf7acd3a3172f92b4b24feb7a4d4858380f1ba1808e19b3c08c46a1e4559e6e836fb8f960f0d81d9d0e97cb4d6a8629c5a552763d0915371274fca907fb49de5e960f54ef4a4c7fa5f7680630ac38cd75efed106f6c757e39723f639a4ab3c3129bbd89f1e774d461c0fbd8db348f1e50f8f8a9edcb1a2d4433de1b8f819f88de620cd7968772f29c59dc3df0973cd5701b784dd3c38f0ca5be072617f9fa3bf273ab72a54a005ad98bf9fd99d24f43e73788cd65f0875f86e23287f4e1b64734c4459d9ed41f8f75a2bf0ffccac3ca09cf69a723779d130b7ef94fdc089fc11d584d82ec49f9c849729da2be4d32c4de778740c4ccda781ef2ef8001ab0634211357cd981c042c53e87a0e22056c78a201e9b9fb0c34f90b931e54f7e11e312e5a53666b5573d481aa14184d9b5e9d729e8d1ab99f1a4d18b35cdf91e71d623d7c0bcaf94dbf648b9b973aa68b53b1e2e4c0f57695486c184ac3e925362344b9abbab7f07d4eea20b23f9fa7e9c50e53242168b2f8ad189c975b244e506b201f6e41a7a316a30701c777963644e81978b2bef3e330c8df56451d44eb67c3d8e7289d99105f0672fb23a5d26e480ab0fa50c6ba6025079ff3738bbdf5f849b2ab04c64b816de48d7fcdfd22aeb92d6e645228dcb499e800aa22b55d5dc929eea99f4778df3082c00bbe95d8f9bf4cc5ae8933ded214adc47d867fd1578754b5555f86e88a7975822dfd9e970b4c41e408cb0d183ed5384e51db5f56eda229e867e2cad83a95cb6db99ed4be8bfa18c40ed71abe9fa16c5c0d81eb68dd954e76ce8bb5517994a566a7a642fc319e41b0d2eda119af05fec6d7d63f4ae97220328611b9f0c8ac3e5be9426ef8fbe9b253eaf82f604ce980ed74ff2154c52c31c5e874792e3b0d0f456063efb50aa68f26b1265b30155f26f9008cc162956c41f8bc978b3414912399505c14c4e8d67a79bf3000e87e523c4a9f3a6a7062a6721e65965da44d3f47878868c884e9a874523a83ac62762edb4a864621108090c51477e0a212bcea539314a13f431342c80409eb11be1b88b8f5fc470222834916dafbc6140c64c78d0d50a6abee2d5a27ffbcbea176de5ad00d51847e527d48f16f5d823ff3a73ca24cb0469cc304fcc5b036230838357fea7e84889c3b000ca961f89e0a8643d15084bf979987adaef5ad73d11101907701bf2eca25eaf047b04b4b184b94ffed67cde3fc6e92d3e56f80048f8a4eb966e2ce204cff4919054a4f3b3464914b03973182f63550f0b7b816f010fe8baaccb7c621b5a1b4909a86ee98eab53b56fcd5112fefb4b193f36c2fa830e796761faef4b1d16b1283e2ae4b529e902a4684c024120338587b5011c81572476b7fb83ac93372f2a9bbf681d9a79362955a63a4b0d51008f685e9024647961d344d381d46b7e53f2c2f9b34f50832a0d899dfe7ea82012d7b3c88b8eade15cc557301da5a187fd2adb1fc2ff0bad18991c97307347bb939d80098790b67d1587eff5fe032cfe1a536e7a95ab6e75ecd4b5af1bc16bdc4cb6ae745d216b3f200378b26ccba0b65eb79c467d40fd5431ec5bb262c4d278e718ccdb596f2c8664c273f56fe4fd011b56aaa5f5bfda4d8bb340fb34051feec36869b4c520cef6c85779fb660747fdd4207c8b791e109c9b6f5176411cfa79d2a30f50ca8359f33597d7308449d0719dac5762eb441940dd8c16279c2227164225f113516fe057e0fc6da066484fbfc554a07a9fd57a243c909ca0deb8bf7919d9e3f27cb4cddb915c1e3854ab671f60063fe28159e865636c7beeec7ab58f8b25a7361e0ac13710adef1cf8cfee5a5dc79e402242373fc444f60e232134aa4390a1a1a55cb43f873ebfdc80e55945182b7781b9449bfc5c5adbebc4a3da9d19978c580f923d5c716929609274c7bc962c351c6c435f67826dca9c0685fb02a668b755bbbe650527bf488fa805d0cea6ea02a1118eef67393c0adf21e8f390920b87e05d17cfca3bdd14f9569136f983f699377fd30b6c74dc3ab5fc5e8ff5d6ef53d961189a280c2b90ce825566288dd17c4f88348993c0dc96010ec3ce5af3dc5101c1e50ec1838fec7687c338bb0c8590b6dd001b8a7079213ada0c2048288437f04d83bbced9926efcec3647aa41cf645c1686913ee78fb39a6aa7fcaab069c4c8c28ad7063091ca8958d33afe91b8a77021b03f0177daadc289cec612895f7f4c326dda3a64d7fdab2c7c3032ffa4042275d167e4c9980f84d12e90d640d5a87508a3cc861bbfd6704b87f620d66b83c337625e7bbfb6da5bf6c51b737bf3754331a0e69ee7562206892083aa4b5767906ee7d5e43ebdcad9de4d664ef6e14d4d5c5d8f1a5d485e8f23dbf57d4f693ce03a5985fc55b3e82aa21fba39e0cbd8d6a5645240990759f5d78aac8031eed39dcad29060398b30404558035a5f009bdf24920384c77452393ee2e9c65a3cb29285f80bedff460f5c58244c74e012affb3b450f27368d0ab148d80bf85f86c36a98bad7af9ccf78cbef74a9cfe97593a0398b8aaa02edbdae4f53458fa5b09e8d689c4da2d2c7ff8a0b52e42eeb5a050aa178ac42f3e934c805e6d4c76d817feeee41748f6981fb310880fa2c676dec46dc902f4ed8fc115e65eb93ccd1d6deb924a0d2c5f14854f9459bad1a839dcdcde6e334531e7f12078c0e1785408ec7842b45437d4deb05146fa4bcbbf0b844e033fb06ed9e0eba8ae245b184807abede780294d1476b00cdab21bdb3f2c494a5aba20e6acfe11584fee6485994b68f8b477f77390970c36bd3ae898736bd25908630ba8536df146ed78ead6bce790d859ce9994f9df573037e6b5e21031b7c8af2bb4ef30ef34952c2799e203344f80d0d8aade1e65c8ca345fb1bf0d2a5859ac113e1549ca2f0d6b6f720a0ed7d8c97e5874d72e29f6fb7ef7f8c805ff6410ae175eab6b0faf65acedfd4fcd929e1ac9d92ee71b58b0d93de476f67a9990cae812e62e4ef77e84c2a3f9ccb968c914b0872638559f795fa04323f822e207436ec0217ea33aa7321a571fe2430789603dbb98c7bca1e89c0e98773651b1a63da81c40d6ee602c22e3daad0b160d62ff12756791e0e6ae82f1c2cf9196da5d27d6e4fcdd75a2fc5e88631e1245d07d49512780873e57661930ffeb4ff12519ec36435aa62bbf7d05a018097374f57612044ae954e99e9d5e103ef9d3e35afa3e52dcfecd5845b21afd002960ea9220ac9f339e61cdda91485a8537b9105e3f6308234d18da9859afa0f29ac469d863de2cab2454eb618c5e492b7614218f8bd4ee36c5262f0cf01347057f83c97d7ef3ac6ab30b3ff7a833fc3f8b9cf0c781aedf28506d4614eab67323d0fd2e4b3fa0fc6f597cb5e6669c7d27bc9744e7310eaf0c131084f19f54490a108314ef8c0899740261dbdc055fa2ec84e28712d6652e6efe159d467b0bddbdf578bf95c8b3a0c159703bdae28ae697e474effe7d6cdbbb75aa96c6c07069435b14db02230d5c1735d580290f98764209aaefdff6ddd3dab2855990dfdc5de01b11f7c08c396fa660113f9cd065d443eda4510d657e90910687570f939a4afb57b09cb9ee272cb8a734a537ae447d2490756297f4ad3cbded22426d567386bdfc34502848c4245981be5d5c2c426b8595f72b4d7736cd6c6bcd96ef84e0c13f38948b523bd5b48bfac02eea377ca78b0638c75d4c722d1aed8f8d2fe8b3ffceea86d0b87c45bae28d61ea114d5113c410ee4ba104e7d792252c890522f72df8d05a9dd0ab892f1f6a80e744399b27a2c6120fe892f67396728182211188cf6ef8cc18d78148d851f7ae5698bf89f112c9cf907752f02c22473f6075c30ec4d3dac3860566afc1ae90375c894be7d5ec8b1ad886b4f2f4724e6e1d6f429f49cea1515aceb569d6af9cad269ff0cbd951f20a8f9aa8ac052d2b279500e4aabced3bab162e4284297d9c80511a4c4e03b892206533201912c1e5a29f9ef5ceb811644d1f9d61294b61e55e4a098958517cd93ac1b36b189f9fe1f5882398cba06b00aedc018418447e31ef981b5ac91eba08b088124465e70bb2629355bfc321176cde5f72f06e0e50b70ee1c9e7d2ada7edac2583da443322964dfdbf5af1efbad0f1315b165984f43fb5d1b5892210646ba4f97c862ed430947475f6287872d5d1b85ca54f75de6eeef194c48ed234f1042cd4c248c16015271edd9a728d183377c510fa6a426b29ff1d1c0683a5d6ae16b021df5280d393c4dce4f4ae17604169812e21cef45c53ecd5ad95691c0f0297b7f0a399bcc7e1a1aae94608f02f79bee696c77328dacf616586961a17860d63b8e8d8d147eba2bf7a81c6857aab6243c7de01a02b985ee6a397ed8054cfc89e3c0cf62af1515a0f5f075330ac200e00c40a851261ae180985439e5f3a5e67e16ab3bf46a4cb224db83bc218664f241c12f0872a2791f7b0427b90db6efe8e1b27160a787e1b50d36a982a0d768ea6679e4858bbc96170f9b981399e7df63362842fc0e8f654259666a5deed712d911ae783185c7bbebd34d6422493aa7f786415e2a559cd9556c867bc7d3a536b7e84bb087230b2f71f55639f5673c21d672336c09ddcf4c271f75d92f825c3aeaf997f6d99c69dd8807239e8cef0218c6ca13e10de18e50be06ce1b37957e8063a363cff7a317cd80e384872ecab97a47def5d714d43fe1bc0bad42103715fca7b79e6764253424e72b464b30405020565e7b0ce87bd4832159feedee52c8c9d01e9b8572b2513dc15d09dda33675ebf0d2e9ca3bbf009ff5ab3917efbdb7997be7a88387961362d9470fb3ed39d084fc9657530bc508f40956bda4766c8ec487221d829501706345ef5f37307604446006d648c7c5f4cdc14a09a453cb08f2f0bc576caba8359c96f9ecc32fd1ef5e957dbad558ac0d015b22f092e4dc8304e7052a4b960ac3d4517cd62d5f4cf056f8a75584ce22cd4f849ae0b187669d96813e4ca9f9f4c616dfe312a4e26ccd13bf4a02a4ea1964c846484fd2373cec064dd525e96b97a86e8ea15c3de735dd08ac9e129b25e87e5ccb2791c6b9c6555a9e7306f94acbfdb680249a6807799b4ce1182784c2445b6fe65e81407b34ecb9dc2b0d4a6c865553a89da696ed3574ebd44f3d222c91df315efd2bbea3e75dc4a4a9747ef6c5f7f5959809a9ce2a092d856442767a209017953765a44247c5e37430222dfbbf74d003c9cd15e2f7c3e8c9b20c81bfa279305ed7cd242df0a566c7295e1b530d7f730688ffee5abf9f2a05c37f4f9f776a2e5e0ff7f6edfe485098a1389afb21d6c33f93a6c77865f61c6dc42cd2379b28f84fd3ce2459074a56622fa8635244ee504739d858baf65f22ce4597123f181a7ed8a9c06a2755aedc805acf7b1b715002b43b868b25362e0af29e8e0e3fb5cba5e68571d28497fb23d375e8414115057cbf09337f7e91f17cec44b4c94b69fb354cf49551692078ee78e7b15a5705b7bd96e8cc7cd86baec5ebb062be85f4aa623f327c10f17dd5003c0f03f3b1fde61b7af6b1700534781aef95e121737bd6f7dfbbf2d688a506d5a5a905e65c2ed179a0ee48a8a84167d17eb5e73271eeeb1771632abf45997742feac7856ce7468e6cd839726cbf4adb44cc56adba6315c7ab382a77a8cb243612c939a648c3d297d9f40299457ec7477e9b6ef0fe348215da76cb12872cbdfe546cae364acb40b150559e761069d2bdfc0224ad586af65b9effcaee3372da0a2c2713eff1153b21dc38c2f8a5cabdf37ed477afc2e722f188783870b3d9b9be10670ea6c013281729ecf40efee83e851bfffba6dff9619af33058cf77d5241e4f9a7d120d9223654ecb30f28b59db2ea041bc6935696acca66107e312714f06bd5f771e4e3e3baa53cbee2d45c3900467e961d74fb615e99c0790ca4aebadf16c8f22a99a4acec7a94183d2e2288ce822816e0a4e83f36a05f0caf6ec254ecb7536bb8dbfa0af278aaf9a718ea8aa35fe5a040f4966a3ce170005267f47d74869925f341e848e320e44a7b190a89a4b6514633e7f8bf6ca30cfdcb5450c9984687377053677f5b181462d04afb36e876dbf90d4103e70dbbed1bc99e07b0d9755e60c81b17a70079b0841af5c8c2bb9d666b8a881c6105c635633a719e52d662e0574c28169b92d8fc782b6c9f052715f9402cae43ebd192141348720947d81da970d09ebc44e308c5a61f1ad4dd1272aa045670045a2aa24728c2572885c100d8cbd54a5a304615f851cba06204e4dd029378c33cdcbff8effe789398c79a1c6786db70e1a7fd681ab7c88cd046ae519d65ac0825bc8a2db4b6826d03ba614164d543e1444b082e5260c465e2d31470637a6dbdd2ecc3d60c57292d86a65a07d511b8f8110c59d5e801645a1ed492c062cbee84513b23e1e9256d7f2d64eefd8167c67436fea14d5cd1114451184f25ab14aeb4b178663c859df39ffbfc7854a5b8f1eefa6baf371d931ccdef53af246ff24337e4542f8806c835db03c360fc73004e88853502cd416cff72aae33f9d3c468e32ba683b0fafb97327205c542561f05a5307d0f0cdfdfbb0ccf5512c7329dbc0d946d1b246632e64aafb70c7c6c33aaa68fee56f058f2f549e32da030764d17f00f17c5b15ef88d88b73dafc76947f7e00dfbdf88b697ed9dd6014ecdce02845bfbcee9014c3c1a4bffb27a5ebe609cc5a3fa5374529f1a439d2c09569778596d3c3fd9c5ad59dd97ee65c3f626718f1251ccfae10f60e6f006a397dc8ffcfa52e88244c1b28d60837d68ec01cb2cad208555f5506669340962df1ba1bba49359b1a5310bb0d79220770f13083a2d446ba8c585c1f64f9d9751452c4789fb460ca438ad49a1d28df50fab9d7efdb3cb1dc638fac24c4ad855e7b61cdf7c9c66fca3e4b0fca35e52fd54a130db7d73329486091bd2a61dbe8a22cb09ab23bf99bfc6a15383b1f6835aaf83e3bd82db2b1f27c9658f23ce1feb6c30c51df5b91d19be23e8f55957651b199caf20a5143a510d89aed4316546906bbaaf0ca3ac626b837ba2ee81d05c33939d474258313a79e68fe402be02e7dde5d2b68c827f60fb42894fca978dcd66148ecd14d98e6a544ca2df991f2d6d5132db40f1db72e4d7f865c51879c2dc7bd50f7663240d5d9f753b48c9879960967c724ac22339498bde44d72ecd56d1f02990801a6b949f28aa007bff33da7a05fd75c48b43dde44c78329a580c09db39034747b6827f62d236a98b18235c1a5ee8b0ad32625772bed8a28a609ae9d33e52c910d30bc64a40c234ada986d10dc9e04c4dcc91fc379069ac4b9ba28ece4df6210fe5f3e2f85b7e7349e8418751812e236067aa604c2624f4b19792068786cb22ec9bfa4f9e7209c91a806129243b7f0c5693b0718fccf66fdb982016623abca319953a85dccc04f13a0e9c18adffcf5f5c5b727819f443a8ed643e788ce699ce4662f788462557c7c1cc8921348a35109d7ef04a7eddfcbb58145e05f5e467cf7f0baea21f0a39fc6f0fdd2193973f02981b36af113cbcbc4504931ccd483c3d37af8d39727bbfc5891ffee1753585e00319c0f0c5c47b642d42b5cd5900ffc8c9142d085867972917c81e2377c8d3295a98ca89352f2543834de4e2471cc1ce5c0560e58585271635297f53afd340a81f6bc74a78b4b8850ea325bcc24c6b387fe966d38e7119ff813fdfd103808980de22a3f73cd31eab9c8951a3487562d879393a9cc9be06b70bad92ff1587e282b07e25e42b2b49c69a76a64bd5be89387770fd7114d809314596f0ec56acdba68e41820386d4f2edca4d0bf9a555ec49170b3f19eb86a0b6baa3ef941f8becac754c7f6fa7e338d57c09ff6698f38a0d9b57e83678012d6a5f2de858bdeee848ed68fe3f89525abcef854c2c7d8ce90d3f4e672a49a1476a136cb165f60cc385e58aa521c0194bc5dfcb664c62962c00457adcf92ea384aba6f2d9dd20e32f24e58934cc0801ee22ae31155cee4fe4c174d0719b3b6819cb5b5c26ec10731a12f93d2c7a09c76a1e17378439f50e11dd5d477a5892aa87f295e1ac0de472e92349685680f3ef4769cfcbd869bf9891b2f45afc08d6a5e5553d55f1196a42c0818f2be0c6ea87933ee214d061a38e4dbe2bddfa98d92579d19de5bcdb028b1d5a6c78e5ec2af880587284d21153c650eaf442b694e607c6e5434dfcac9cfacf45e25670dfe17f91de732309c9d45dbfe9b98223a8d821815f38b10bcf908eed05f974643f2d33155330a8dfe8200338a37328d613defe5272094fbc44e1260b021f7064cbe99301e0cfede3738d95f55e17b8f6571e7b53962b48b11822d06f27733f873c4438b063946c91ff611b2f3ecb10cf951e5774ed96a6457e7a8ddd64ba77ccb41f76090748f7847c53fc7a9e386d0325054e9b797826688624160d5ff6d47811b84d3fb0e4a484ff79e268b7dabf5d46acdaab41c8b1ee6295545adf73f66fd22c9be170dc1629f50a61e6947cb5cdd643918eef704fb7f9c61a7dd0a0b1ed7c74f4bbe18bc004a175b409b8ab363a398b7da9d4829446ac4495909c330074c03f50d0d31b49cf8a17448fd738551f937010a8ae505597f6dc3b74fa0c5aca71626a51adb233c3fef0dbeea02404fb16cbeec84aff6e97068e24c275476f30b3b5e66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
