<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"abd099d6b26ff99858c1fa2d4030ee285c1196852d73ba4e1d6cf0e300e7ac03974d11182306bcff799140990933cf14d481ec2060e002de93ed29b533802b069955bb061e7e91f10013b66cb2bfcccd7b523326c1d35ccbe98045121eb4fa78d58cecda60cab49abe64ccf549dd0790a800aa41e9871eaa693c21740d1fbb03b67225feaee7de091a6d0a6f6e2a72fd7f97b36bfbeb2ffec185944abe2658be6c354a7a7eab21565749264784693d56d1c56362c03bbcd181761ce7f652f4d337b327eb122f6386c47e448d87553fd590b9543987ed1661bc60ae921b59130086a72b255c1e226e0c09b06a8421cef59b13e8d62e43ae51a6e122878a3d287f6d858579f20971667ae08bf588ab5607443c969d35886ca57bc3f41558a9be303c32db63b6d1f5c80d357da4a15dd1fad6b1a8d478017988f27c04225fc430c28878d574ceb10d35b2f4388364e0e90fdf3b5c56cee0fe7ea01eb8861f7bf4f84d6f75cbe392afb251774e083e5b3d7b0655e029adcd0c3d51f81a4e4f6b82efcfa11e6185730aa74e70dbfe2321348b0801a0adbbe80ae6a7702306fee738048bf0d471caf43ac5f789c9fa969c19e0b19cbd9b2ad0c73e4a2f3a03870114a6fa4f48dd9606c8654e3d652387b81c7657922c45fb673fef4cfc4dfed18950637a8f49a267f6b5b4c91f9a5d98d2419907c58884f6fd0d2583fcf1199b69f3e36badd840880a7f34f3d504bfdd3f8a6807b4487d0a5a9cf5e42e39c3e11fa6616fb1d7bb12f15e22b51949257f398b75848a343f372a593eb92c00df8a4ad87dd9ae980d9a620d007762f2fa2b9391e6bed33f46361462cbe454a2451c3298968137f6ef2386e83d514b373de468464756d50a32e65f222ab5177caa2049d5be037dc3e788f1a48b66ea790a8e774d038b7c0eddc1d85f39fc6e8746eae98e5c73a04cd4b179d16f93a5dd23a6fbf3382549c2ccf2296a9d60f80926b3f9096e1904a465921c850553605237512d189b83c43ee91a5265c671eba98b33da1e86d0c96a0fac01a41c33b4aef21b71e0c8cde087fae1ff076ba076ac0654f84ae6bca4dbc8f9373f4c3f870c4c04508d66f9376a1a00f293e1acae7a23330bead7fc30cf1adae9ef789b80a59bcfa6975fdab3e6f2c7af1233ee869d9515f4f709e718da868d227c8cf2e8d0dda3e7046bc80e07903c5663da5976ade663f93d6f5e440dbf8f9fdc4491c39087d6421d28b249530c12302440a92a35f9c7a2a0070f2de7abd4eda19b19e3012c56021dad2f162bc19589c5d4c808178eba0cb05d7e86458d916046653afe209543379fedd3e548b587c740f768553cb9c13b64e0ac3d6fa3a7aa070ea5b59032d6a7a01cb1256a771eb33d681392fad93f725d0b4e92b79b7da02973d7f3105302a5d9ea02deea8f8133c32b9a0c0952d95e3a096166a49a9052f303ab87199cb31711fb6666336215acf8ae656e212dcdb5289841fc58be4d0132291c801110baa7390c32e7c31154274b4659b1e331f4cd3faf690e89b68d8fad683286b0f954e1efbf4459162d7ceeeff1636a1ff46760150882f005b99c2bfa3aba8b9376be0ac640dc507a0c9ad72702842f6a2cdf2850b9fda947af227099dcaa5381133ef5e389b73d8ca49c551045581050cce5bd0503917f9b15e120d14172b21d051e0e9bea157302eaabedc46a3ed97131308841d6d40e991e3d1296b9e509a7d1d58f2142d21040a357426c26fab8680adc9d417c173132f9a7bdc281e03871a9ddfae373b9e7e424d0ae8c21a05b559e28642b067bef94953dfea7fe1ea2d2f5baff09e33473a02fbb966ea57fb1f944636799a1130e38af826d317b00419b2838d4a3f1c70773084bb7be2b6b3880f7a22660eac6e47678c1a3982b26f616e81532c2a8c924f0adbdcd605eef83ac1c0eef31f0988d15ccedab6b25fca661d43f9aa35c190537a39b5d8f1a67e2ecd1e226b445da04646d5efcf507bf656521b100ff4f745b792b3adfb94bdb6fad84f123e200711146c16f72972535b07702e5e7f44a4c072edf28bae57dbf4bc015af0673966179c9959ab8dd66e675673bc950d616644898fb63e7c01341412e1b2c371a9038d926e08f220982a03454864d5584fee103f725895743d3aededac45e302799b3d63b5804b6e578f17f3ac423afa926144790541202f47b1f5bf0f9c091f21455c9e362cb880696b0c6f4f6b2b8e8142224e2036ec2644c9c3637378103b81a2f40f5f037ba0e785e33c42a4d83657628a256aa5faf4fa34d5de4905e26e642dde2a19a84fa75642459e19a3f22337c2ded482f531c07abc171db444e7af80e90fdb7e95adb1663f2378a7a180ecebcbf632b8eec9e451a3936100d50454bcd9609f841a7c354f585d1133c49cf50d85e04c08f99df5e13c31359f1f5d1dcac1265ac72520f99c5d91f26d3fa7745c09b7e71d1cad311a4978cb4f9dbfa54435ffe8a210d3557867859b29d4419756498d052b85d2cd7e14eb653ef66ccd1df85dcfd6ee307443726768baba7bac435a8b020271a400717a903fcacfcb26804b9e0982a703c8ce8ae954a61f565a3e16fa2a6afb7bd5c5d0b1404d9cc3fa8484e062507118c7a2877179934291807eedea2f6f3597abe0c8dd7bd43f6cf3b1895ce03e5a8795302b5ecaae58215b8d0cda6002fd12f5a012dffc674b25d6942e735bf19c79f6d8802bff9a95caaad2020b70210baae01d0ebd7605661b43afa6362bb37c58e6dc1b751e491c2c680520baf5ec35e5541e667bce8ed5f964b6eff07f00f3550780743508dc6a8fcb255f3004381d59cb49c98ac07b4cd0f05bc50c3de1caa0a8628f8db7c66f4776aeb5d952a04a65db55abcf2e6dfe50a9096ee8ded1d8a8a8ff410134570fe350e7826a85863d80c7ea25ad779e382c7fdd016aae5f641b7e0c9eb82db24af726808bb6f7c698d70e2345c474fd47d47be2784d19a8f1d0754d2be575eb5aae46fa746f7d753bd8913fcb0580efc0cb34a2cc46a29c9beb5ee68198d2b43b653550072f51f62db393ace6995406edab83598dea1c76d1d0b5092191af8325a37c30633fdeb1f59b72d06b277f269936e7fbd4cfef38cd503c6299866a2c5cfc15fa023a5517e62c776e235f8417de9563ada7dc1e6e54480bf94f4ead192901f2f0f4a73f36c8b383f7a32355c2a104a3cf83fd62f377530bfda90993cef6ed434883a38d21039c3e715391adf0e9286284b4d94acfafa419e8694061e9bb6237c5c376ce5748bb122fbf4e22c7e154962de38003bd16e15671b426e486be2d767877d42c91675cbb087fd31427fe89ef43c743024ed541d56c3158834a8d5f11d70197e62e3312a1d40b42de58607d63ab5897e81cb6aed743f81a51f46024a0228168c27380a715836ef404c72fb2c6bc053d19637961f7c74b3784c6904580429199a91977de4d89567e4a23923612ca5b4ca34d6fe8841cf5d82a714b21b8d06af127e0216dc1b5ef2996f4754d36638a84ffcc15a3f6734f2887784664732632ee77032c98b6f04774896f35066d7cdec2c7faca0c0649327bcefde969088aec310afcbb8c5681b4f10d4ef2a3f137f3bbf8c6e8f76b5a60da998dda648ecefc2052c24396fe77a7608803b946e4e08cc1e55ea465fe0db6c403a0ae3d42332812f19b3aa814b3f7df19cfee40c9cb0e658a3adc8b79ef73a7c0f6b846d3f15a75c710517252878dda309af908bae43f48d68575c8ed010a09de002a5a37a6cab3c841554cf01190525a1e62cd2cb4f83885612b922c2ece38ecdc6760a9db1d746ed99aeb0cd89633b0d03084c26e74065f478a21c8d154c7e0d605949c8a9e0a1f41c1efb74162eb0f7ae5de259d45cf78895ba9f0de0b3a1aea1f60b0e3bf694e545c6f1e4971d8f71ffd3586a7ee235e2ccaa8a32dd7239e2ff8a621ebc687ae37495b6669673007bf426dced0b9dae40cfd1fde5c378e40632ff9e056f8c97546f6e922402af910195eca67c3b3f2bd78efc1bfa932ab5d42d0ea09b78e1881408a89c8cb378f279e9a333f90bb507478d53fae1973b734594c92332c6e50ab9a7a09d18a3cdd8a82abbd21befa675877ba002a36f2a686c839b5381f9ba59b4b752ad2682bb9186d5791d3ce9feee268c53013befac2519fe3514452f71b84f54e85c58dc6a14de7f1b7d2fc66aa23fef0690e49fa47b29b3fa22f0d10e91cc16dab27216dea494d3b2b5ea500c4c2bb4bee0fe93f1e3867da383d39f2777e36defdfdf21c12e8c3eabd816b26a0f29677761a93dae6588f3ec472e190ef185b5fc130b35faff10241d1e7b28dc0600a9aed6ed0647a762d63a2132e717a6f2faa6d95c20028217d32110d8c52c3ecf3c0286e0c719febcbf6f9c278a509663713309d4fa90a54aacb9ca5fded2e6251e355ffe197be27050b9587af4f5e6e14fc116212ca297e6171c82e5e1f37701e57c524ae0146d10734e6e55d9834a1aba606365df3524c58a74dd8d48256029280e72a40f79ffbcec73f08dea6dfe3179f435f99b2a4506bae75880bc96117294d9a5099de641074ea33fb7258054294d274b8441436a34410658ebb08dce47d9c1e3aebf2bae187d651c6205e1bac70cde26adab03379758fdb93e3ad52a237f411252d86a9060d68726bbb86f158068059832de0799b33fd2dc00f95f469430dab8e647bcdb4e2a3134107b614359744ceaec6e79e3abc6572f7c745ee597e1ef0bd8cb368c22f2fb066fec65bc3d16d3999449894c8ee6f074032c1d569b8acd06712233544ef555d2cda35218450f50c85c745fd87d70327e327997911759b6319eca52429aec2c7d9c8fdd99f7daf61d03dcbdab908661123e71a4987a5a524d28df8d191f5748d08c24a8e9320c4dedfe3fc6cf90589f32f5339e2d4e0e67acabfbb8401d0dde468b5f1eea4cc5eccdee6565b5a27cc6bf70267259c8fd970b61b8e59d4d9183b41d572477523a8c589539b4f74e99e68f3bdfab2ef94aff913c1a567aa7934236d899d5ce9685725e2dd54dbbcc693f025d235babd1fe444987ad97e704a684f1ebf587e62205915a0393e87b1f1811a4b88d594eee8747e30b1c98aa4e34e0f995e81508c0bc5fb1ff23f0b1126f8a8d78432e6c80a670b86108244036fb47eb801c73a1367d1c9d7079753c4883223ad2a0a8a8780344128cc8f707cb6800b1f7793dc6a24f67bb9289c3cf6fc64289c121edf4d7565d4dac377f7b85c9e57f61defe2796dace59db978fa5900660d5a5d8e5b5839951ff86799e8d6574497897730ac11f4af41573778cfa19dbc322537ce4ed68c8bce2012c210deef62a35ae2209cc715831b659a30312770e2ccfd3a0f88f20b4f3bcd99a89010f8cfd4f059236d518462c00ceb50f6e2e361fa48c9334002d2ac49f88cc92147ed0bd1d0b37482e7cbc3fdfc409651518f2a34295a835698b66255fc5304a075b3295774d7e128ab0e6dfe20f78400c28d9b13f903029c2f1982962052b69577805f4b585655bcc526db76b1b61502574cd82ba3060ce28f9dd2b51f10c83a06c58ef44547336bbc80f9a0a9345550ea7341cd3d937ca803b59cb359dfb48b777f874a35c73600a008a6167f2596d1476b5f33dee5e2cd4e5881a8269612eacc7b6ca5738f19cddb792ddd93df29e8ce3450329d5f1d8961f9076ac539bf578dd61f1d0c9ff925c335e6946e6270ed9e47087ef3a50fa2fcffbd0d013d4aedb9e0388b1158cc4879cc5d4d0a4c1497732d7779125dc3129db216944c4a2a19ca454a015099c4323259ef0fc6a613173d7315f8e6babf065b14cfc1fd19a385e73dc4f6ce9c11d66a7d95a2847cca680db8357fcabba21b6a374bbefa0d222c0442eedaa5a8ca9cc3860d24f4c982d8c9911fcacbeb74c55ae3387d4752e50e01e218ac05464bd64d4ac5d717f908b769a04b4082c01ce6e9d59f3639930deb0349920bf8d46eb3a10cd5ca9f56de019c1d48fbfd186fd3e6350a87a81be769949e7c3ad02d8433752ea39993c611c7012c4e44a7c71ed5e0d124cd0635959d0bb45fd4104ff6576aaab13733e5613d2b742f95da3bcd5895a72bda3b6b9684f6a5713d581e62bd92e632e1e34b3c05abd11b8bd60e252178086a66898b7db536ad2fbf29b506f5144b8ceff8c4b8ecb915e60772b5759d2c2af2474e0c5d93093a56bb9ed3a7325fbd5531f1e5bc31004bed1f122808364b226b6d0adb6fe0606dafae56771cb67c101fd3d93a6556e3b66b16e2aa79c58966d5dc0a722420dd79d112850e2271daedc4ee1edb24bcaba4d3d1e34c98825157c5c1e53b2d03d8613af2d471913a74a6d46505802f1ed5b4b3bf11d21ffabb3d17900bf3e991e23096d72c3e527ab96024e612d5045ab7be026e1982cf361b07927fd947705828ab44c65a88fc205223cca32b8c8c672e1a1984cab1df68eb4042f3a5c9274a422ad80dfc96ce05abd48d2af7a89730a7f184cbd4a0d75a950e6deb47f126b8096c3281b6e4b81c96a251a6255c1a9fbd06a46eef89a3423ea2842bdf4777d0e8b940a26bb5bb0d14acc48b8ec721ce3c5b99e7c6e78e239ec1484454910fab6266c08503a74d3fed0db96900ae3bf14c8753f3b95b41184c619487c116caed7abf8c6ebf09d0a08d1491322289933b879ef8f2065c77398afa0666db5dcd7c8cc0330cca53ee377615eab7da71f765be363fb845e0faa5b5d78b26499de83c16bd34a4cfe98e588f73233f01de7c798b02d24df22fc1063c072cac2dee139024f16dabe9f3037d14202350b24927967afc02f8261306d6c7ac9c8323fb009f3d18c4ee9916fe500b16078ae3827cf2fe8848eacc3d5b922583c3fabfae26a09fc4eb31b3484ea2a68940d086497f3ba2ecd70110086037eb7228827afa113280e3a0161bd15a24c6e1b60d1aa15e11b846d7198be440e1630afd83f9e7fbafa1442052d87898f13e3e46456d344605ddb3da3b27e9da65b6c76be363009cda4525682ad3538e56dcedca3f41480a1482383ccb04525cebfce3a91fccdbadfbcf6fade9fb116ad5ba773caf69f982562ced45fa4dbbd71957b3fe1a7ba3fb2560d74156792b1acd16e892defcad28398a5e0052ebd95293fa7e0fb7616e612ca4216e41cfe598ac463f8dc7f6f10bfb43efd2b7c1f74a041d7cb5b33dc738058417ed0bd1e9f69253c3dc82cf5ad11043681955fd582a4e2313bc8fb42fa6367f644e434434e541e6c1e148e16626338752ddeb9f22211b70b7dedeaacba1e8de295505a29e752384bc9376bd28663ea3da26cb9f8ada9fa51e8424364aa26d3be8b06db69208fbb805f492f9c32d62338404539a5819e412db58444963d0784fe9dc07c9bc494950f20e53abbeb936442b160b5d8c504678df1842d147f4697cf9ec60ccbd39e775d5f19935c0b6f9ddc72d5a568f227f758a053e274e1737ab1f4eae41931fa99d6721adac5467a367653387da1a0497988bed0f82982980857795c0a67b2a1858f0b5f5bc23c9c8f401fecaab251b1f685143cc20d7ee2b1598a6653ceb1d30c31b5fe734b94d78d64745b3d00103bb3dad87d30c029095bdbff1ad2351745718d68e8147b9f74a88eaeba649e78b2301bb105d4a72c26b24aef6906a39c449bc832202482a5de0819470e9cdb7d9118c0013d4c6c9993440c81d870d7a62ba3500c372c51a12df3bd51bc3556e5bc06ef4243f2d2473129dbeb345a1d58c86e5444790c17052c461cbcd893cbae3c5ebc21f701667712cb918bd83d677abf8c65365c5845cdeb68495b7867c947dd06c7a69cda687373c6f5d45a0b05b9ad3a635e922fc1c95dad2300cc89d88d6e4556b2a1287c5070422302e71dd9a8b483379c2af042398eedbd2c8f418c50bedc0698e2c94c7217d3ef02ce0c84023353d753d8362dc615e9b3637691f516d4727f9468098656925a5cc54cb9e26e974a275e64bf85fe329dd33cd72ed13922b17cd235198941586b996c2ed047aeae4f8884fe625e7d2420cada943837a69a0f43a1d04c0c40ddb6553bbe6a3b1659e4ccd085aae2ccd44a1df5ca3d23884b74a4a271e4c3b21a563156b84ac40a395c2d6afee54f45d8febd78c12c26a549333feeddbcf051009c62797bd538dab8fa2a3727e5f467d87805c50155e82aee9aa4963e5b4dc8a8984c456dd196c39803585d0e7f3f1a93f3b390fc1e44627b1e05410a1e189c45efa1739aff8a16a142d155d3ee0ff4490fc27fd5f27afed88a26fb13e474049ada6989b4afd0e7165c26068982b7d042ec032ebf66a79674f3225a33c62769359c30ce8ab55d7d4db16464dd43c8f6555651676b48b43f78c7f20c759351e4dcb09a5b14e1694aa83ab4ebd54e8782acdf67bc46ee5b263b2a5298fd57b6407ca286842c9fe9dc22de22337a4509dd62c608795739efc36095d841b1322f3134e01a0183633c764fce5c885da8c7063f0ab6370a27928fd126f6c2d246030740b6716adcc824b27d7b3f189ab41017f1a21efd259375473ffd14f0d045a4e1ccd1387e93e1a0aa284e961bec4485e9a7ac8974b20a8035802157291f8df0ccf8d178838b92939ef3197f61ac16d99e3aaf2ee69ce9d7f0c751629705bc747aedd25cc8f644d48593334887aa82d61468e17269c665b3cda95ae3922837a4905ed95e9eb5e74098bb096de319a309eeeb9a26c42d50032d7421892d3efe2dc9026dc802de181cef644ace6a207e01e0770545a1c286b88473f507c03ad41af740e20762d44524212f985a9a228f8e0da225ba5a2a65caf7ebfb7eaad1c2cb4cc5219a5d7713afa2e857a92059fafaafc0498e9d816303eb55202c29a9ea2a7ff0748cf7224000a55fc37dc02e6f49cdae1868bfdff16fa6431153450effb21fa7ef0cc6b77daa5caf20b57d81e4f0109e53f3203529f2333406e6a55d553fbcef475c74d1bb5bc8e667327970a807b4a29cce67f986d45989d230b9edf1266dc7fce33e42305b1d1930af240eb9b91c9bba6013cac43d5f2cb91db1b799b0ca05ad8227804630fa918bf79d1d6a4e02ea754754b3f820d7acdcf696fe699ebba9c148c0653eae659433e025aea35d397af82057088bf76283f083cc694d2d8c126bb9a9a03cdb7276c9924ba4e1b4f2b9493387ee103d51c3e7ecb88ae7ca675bdffdc135e2731e65ca9a81bbef92b739763bc251d24f60787491ab049279a4927b8d256c6bb000fdb1d2499b3b5a4dc7e6bdd7383266c2d9bd631fdfa26c5cf53beaac16062ad07b7e3e13dc7589c1aa1d6c8c5d9de30c2db259603a71191971dd4e8b934a8e1b25a461ccc210bf7caf08ca47e6bb97f835a3f348c48bb789a705e16cc31a1c3f1fef8715a02dde77f777f9d48aae910b083e42130a083fc142f86bff1c9b215cdd996026a81e902e5b9cfff14db6cf9bea169677dc8877aa5c8f5498fe6203c4f299414687433a1707e5d623e51089c710ee7c4be25890090328f15183711d8040a905a7cd1f6c2370b3b40d699922c835627bf3f1349b3947179d0b4cc5b50f3bd2d525e528d0298ba045c6eb8428cae9dae2ae7a2466a22f10a273dcd94ae790c3a29314fc7189de96356af4cb6aa97067e90fa08bcc05f092461e2e85d51416e6c2a5e49d397b30bae66d12b3748410665504f63cbe0b631a942ed6db38f0b80eeac13f0bc220bfbd598d56ec29e6111cfda225d11b85aee7bbcdded2987d4e0657305c3a4931b7428977ec888006f66df261b0bc5868bab2a139401733d65804a42593dbb55cd29df999a74059c0d9ed8a338d3e19653360d08ae42e7b4e218aaefe2b5be19cecfc39892a36c49ffdf1058727a67a795cee428cda53ed3e312952a155be3a01fca5de66384d1e6bebd9ece4c311808b0c3355a67e8bc635ee5cdf8425b0adc5a5f79aa1f520f39baa7fc672d97779af70425ef2d6910cc371c78c7d45f34a5fc3db7e251a6893e761059e5edb58f99e8557b4bdd48f48fb9c072e7e901751395aee8d1e2b5e8f62ed30dc8fb6c0a00adc617c5b967bd364994ff0938294693c05f9dec5ae738ae07e7b55b0142d937c1781c2a8e546102fc1ddc14312f6dc2e1cc80e1f5c65ab11b54d0b2e877310a897ffbf29775a8d534c607ecddf3d842369c008b164f4fc47caf37a8dfeb471af3f810fd85705b8e8682dc67f71d68b527f4483cf6b226360b2d0b819dbab7d9f651c42b86432cb066ffa97cd9a558874eb4b0b5c17546f40eca5bcd67c60f72223b6183b08d5718109699bccfd6b1f9fc78af29bd5836001e2fb91eda902d86a695560bb04f89baa49206d3a8d0404550cf8b5ccc36d284ab88367dc11507509c808495f74a05a2b49fdb7730c77dd05be92a51635d448fae095fd17172a924ba7314c6be51bc22ea55e86982dd453c2ba8708646fdbb1baed3ca75c5e7db58eb2863340636b5553a5afdfd85163f43b0d8685675399aa7bea1aa29c28507aeeb645147af5661287466d83ea0b8cde84a5585c9395f7c5b3058c50141f57ef2accc383a5b6c121c3a25993bd1a862c007984ae5bb185bbdee735b644b17d9298067c38b58083f3e0649df6a0a15476814e3586d3c579be3ee6675b4bd34e23129012ef2a31d0f140ac57a249bf7f02177de9f1a532986b65854c4be308898adef6cf7566dee1b5e263a64868095e708c1ef885ed4182e045f4be7c2bc3006a0bb56964b3806b355929ebe8fc83badfc5c137edc1fbf3835647dc7c237518a5fd6e09613cce6e9a7f833d2daccbbac35fbbc91b2cb2d1ca9b7e0ed12bdbdca254f7e370e12416b6b9891f8660358bb4bca09297bbb259359b60537d36d4fd5898455cd53d9aacd6be640e6160c13b8ae6022f1430d1842acf334b23a1a955265cef2d1d00f24b44075c72c6b8e9a56872bc7f2fe17ea38550e6f73dd7c6d61da571be3470a7bf77b5ed51b51a1318a37df52d051d7d2c7d63786301bb4651a8f93b030bcd816db0a64e44aed473005a57f910e0bb86fdd8e0b340c7407e0b8b275ba03009b5996ef7915170c010b02d2ecc4442d6ca5c3e1730ec3bf835cf85d0c478ff583d1d602d78ce3135521ea0e043b7c10cc30b61645042b0c04904b5431ef3f9160e3e20f407f01301f97a29dce8469bb85f4886d6e9c2f1e8b6ebbab925aa6004407c7c1a48b8dd096c368ae9509659223ebbf753694acb296e6f0952ea745912d81834b9539397f67fe76cf519d8fe2744830b4e78bf162bbe4412ec51b212709860d34924a5afca52fc28ce42a5de4fe1584f75296654857a95d19c4b5fc7afa31df769a979113e94bda88fc14dacf1b8df82c89c779ce73528a7e926fef9623ba21ba7450f1d7fc425e186ff97466617c557871d6c5e1e5e83ad916c8f8a34ffb8ba644743fe22c095e7d6ae24b6c9f7e6877726232822216a990b8e7756d088098741ceffb9e1410a15af6e3fa416ecc1b44926a1a1cea2e8a766fa6e4972143c7c5e28c4432876b4659a5c26024a652220143e38a8d9779fc48efcbcb981e2d4986e0e8d7377ba44b8c2e80125151ac3b13846b49e8148af26ad7e8d270836ecd663f7c8d8eab389b961154c71df822bd77c44fd2c8c0e86886fc1d0d95927969b36bdb1d3f57ed2a5aa70313b7c51f2885e3bbfbaca55f4e079fd00595ffcebcccd7e8a475af82641d6c41ce2482c1251e6423178964efc9ec797a30bceab07876121a828ebb33ef785ba97815b199f461f12e454efd52f18d375726b91c25dde8dfb847f792950c5632cb0d6a9a41505dffaad264d3114584d4487458d25a708423ec98252866eecd4b1839bd5ff6dde6d02a2d937a6329ec18ff2e11259ae2188f61bbdf012a8714139aed99b34c45288ba476d060bf01b584afb9029d4fd25c0a6021701d1b9bfaab9f09757850835c8b85fe5e714be699498b9383eb680939c3069e742b3e12c1903cb50fd6d4471d2cb7f4d7f36e0b2dd21b8ae5c6c69185d69d0492457496caf659bd7bdb1e63f6abff8d1a377a06e78f3b053e4172bebb383ba0ad106aa3ea582e62e3490dd1d8b2bcf1dbbb0f31ceae58c2e54a884d02b88a6c8fb6f2b41e329aaf0da94a8c7e4844d002fc48700e0e7a41fa7a5f344c8e31c9eec416cab9d3f76bc3a6c8c4fd32fdbf603c61d10c14338baec5662acac15d9b99d8bdaee520e199a6a10b70448c24eed0566583e20583777ab416b6ee74896b05361d7daf34a5fca63bd731d1e9fd5cd5389831af4d28f1602a368b3864b3d049f1fecc3734b0e78ebe3a00745f317c0078475a1453c7eef06de53a206299db7ecab5e1e4b7e5cd6c42ef3233f2f0b08ccbf0616ed3af8c298a7ff03bd402559db097bf0d1115b336abf7ed952f6cf4b34d0ba3a96c48fe4b6e186aa3d0d4b74b7909e9c794c69053afacc8b6a29c3a8592f49dddd3ccac9964297748785a746d8ec70911ee333699552d0431176d2600c7ed50bb4dda1e8116a154b091075d5a040a508191f123f0dbb694e9eca5c684b3d4b357dba6d8c6cddd12f0f16d989302b536759dd8fa9d9909f2e933f6dedaf099132bf79fbead4641c6715008e9798e6198068e9311cfeb9e6ed6df174e7b693c2afec0ae9c20f02a9891b852808cf4a1c86e199b438d32a2138abc33bd2313ea97065d99dad683a94ef9169fc650d9a4acc2a1d785bbfd793d1ae3905218885e2422232d8ce8ad2305f8fdb6a81beac55820c917bb952cddf2f0482ca7fbdd0e57818e035800724ea2d82c0012dc7a34438e2f3b0682bb6c2eaea52fcbb88edeb239f93b02854b199d11afb3d4b4d53a3e62e89ae0aa4c24a7c3c72cc9c72b8ef65e739eb3c3661101d01827cef2cd0c5ff82f31904272b39ae1876304f3bf96be81650506bc8840b4a9d2e59c416934322e257b59bafba76fc0f5c07c2445f170cdf516321a8e56a72dc73f35b6c3c35639e85675a1e65255da46b593dc88e8c74ca2a2c9aacb1393dfdf11c1c4499881249401692c4855575b8f4e3e51fab9e529c7cb80e503ab045b9812af4beed0f5b7b2298336a52c33e47e7b98e49586f94ecb5438bba51fc54f79f230b68643312e246b690b41099f08c4dfb4544e93f7e80d87f3b4e66c1ff1064493bb2da01b64430074f81f8388b74c9049e7762bc4ec1233cc9df1dacd0dde052b73075adb2d153b69d5e5fc238faab69dfb0d3782d4ed7d8fb8f88b90efd24c42b60f92e73f8f9c3aa728fead88ede25cb1f403aa940f7e26f0304079db392a359b2152b887a67da0d6ded51576e8edcf421afaa2894dddc64aea517f52a2e41104d429d757305cb8b0bb9cd41e19229e68180ed7a8531ce8c017026e7c65f64ab364b7f024e26e8f8ae2a03afa3665a9f78fd79f0a763cb87223311a1add7cb045aaf453a5128b36702d81ad4575d55d83b7abf15ce890c15c093ac94d43321c0bf524ee3901eb13e201fd22774a3b555fa8945120527bb0bd14d764dbdfef9d7238a4be7bbb21cd4413601dea01ed83dfc61805897b8465acfc237b9cce9be430a7252958c5ba7f5fd0a39f9a32f492c6a7c639bb4641403fcfa1acde5db7281bc74b33fcbdb2f8e9c599b6af1fdd1c75df270a464fed04f26a75e5ef81b00c06f1f4505157dc79ff3a4b2a1e0289a7e4eeaecc6c16b863de53384aede9a1c51f7fb38ec95f35ad7f1be1f0c25bbcfea981a96af1bc77f7b42f72ce1caaff41bad8b1c5396a2d7041586f2bba58c82568515a8448039ef2aeef8a3b21660b413384e25a49680782514923a4135ff0c1c57235567a4881c60861fd72a1d2513542f4307082e7305d9706f8de664573998145e190f81a722321027061c598883dfd970d7993cce5215767f75d8e5e6b61121506615e15a18012cc9cec21c897e9d8c5b80f449775f6d5354663abde7e99a690ae68dbba583eb9e198855f5653d4bb6dba963ffcbf2c7206f767d142115755e17e22e59d541166058e7d4b548592cde590bb28f713a3660a5029fdf0006c7548b525120594e0b9985d07d342644dd75832af7d6355da00a5f60cb3b289a7481f02cff92b581293769dd6c818d1a911053e06ea633637c959d5eee1066df4778226a234e00f01de02e275a932059d11743b737488882ca8f81bd809929e8c21e5e5ec34e6afdfb3eb7e3ca9c6a20a83ae3c9845c2c0433978187e6fa14e6b02ced6b05fb20225d29f8da836c10e6e5f9ab33f7be90f1e8db40cc6756062f988961fe50f4f5b9b2d73ee926cb3f216a1001fffb2212f6c300bc67423c0121d8f28c2e005f7cd280bf8d4f1ab356acae2de94645e557ca786a2bdef942c6cc9c389847f62934432ee8758a83fc8a40df893a520f2dbc87d1f41edd76649dfbede414a6c303b8cc8bde81ba48a9d7877e48eee9c711def2f520ca6429fad7b8ab224eba6786028341250a7754cf53df31b3c146a1e7a8103aca67d0f2763fda8583e57eb16d609bd9232777e5848006a9e5efe803a92e0b80c98cff3694eedf0210096f60917c9c815483108b3cd89d41fc5f5ed024e9ac43bab056fd01452acce58f52f52f0fc0f2768d166fc5c16f3a5ad5936955d50753229e5e53461dbed19111566b0583b1cbeead0aae51f448ff371d5b9acb273961ccc4d24e7208c30745bd0bd6b043f1b8bfe5027f7fac11561d703bcd029963f384174aea325984b769cccdf682d7f72679db83a2cdced8a01adf18bb169d77c25f98161dbd32a66fc3331502540e2f714ab48bcd66af8379a3356fba84ab5d49f086064d1a0720f6ca0dedb2e094302b8d0b5f165e75b686e98bc2b95b50d11628cd814cb342f1c2c5b79809a498b6f6f1550ef8e965877a1e06f4e7179d2158d04acc719dd4fd1ccd6cbb9ee9b7286114eb09031d362e192fa2d57f8b189c4ba19abab5f61544ec799324786204bf8d0ddba9fdc6f5e846ddf1bc120bd9a601dcd3c11b0ae9f189173db6769d293f48b26ff8fbaa00c7633a81465eba7945af23a9886fb56535ff703bad82b3218eb9086e9614255dbfbde11b5515f11b6a7ca30380838026fba197823ce9bc9cdc11314095c47b79eaa0520d6701cf845d5942cc68ae23ec56cf5588a52cb0bd3a55e5c5372c76e94fccd285d834e1e3cfa29999234d02b079f6953bbef75de38169b2ebadfe86d6220b013306ee949352275ae3709bad1a7069c768eecbc0bbade2bb795ac8d8756fce6f214e99a8190ea5791ecd4ec4cd0af7828902e2e127b439956c2b56e815272231827517db4efe29e8f481ff964f28013ecbcbf17c4878599651ad90f3fa66de2463267a418970e63ed1771f34b58ebf47a837ee0a3a33240a4826c3abf95a89f6649961ccebf19690bc76ce080a6455fc7c960abdbf4c980ccfa72147170dfe4f6903f083048f2b6bd00532e7dca0b9dcd48dc6c09ec2af7478851542968e21459a97ee922fb5a0fb30fdbbd3fa56c0ba0708c514d0a90c7dc0c44f44f3c4824c38f0a85d0bd390e08bfd4bf52cbb7b0a64427c4431afc3799a9fcdcc48c21ed5f11224a2e37eb42c81aa48963afa95a552e1aa564464f79a8dddf10cae68cfb794737a5020f6c7386a66d08358c892496fc57529d6b232c2315bb6c1469b805ef79d611a0f1e03d8013f76c75b506d57f6400f0f47fd4eb85f0e1a070eafca0d5d6278eea9d01af0a9d99784dfadd6e656af171eacd560923f8e73e0693a398e50fcb206e5dce20edae60fb139d8cbb3275152bc3513765e1f2af54568664f54f8666c032883d9a2b4aaaafb2982093c3b0a119cd58bc319e97382d9437f0d99ffaaab67d2a2d5b7a180bbb11eed84996d9181427e088e9c6ac5d365bd252813ce5417247e9bd2e9028eee59c948dd52da1b99f79fc561bd78934f4d3f237d6b11b757e8463bcb00d71e021a92eea57be3889811165e2a3f587e4dbd4c0a14daa8c27ff50d174cae84151567ed30f7058593131166ca04ca8627a03f2536d37d17acb6ee9af3d6eb80a1508ddca382c0f10323a1968477676734d54054bad2f0607708940b469ac476eb4970089931d7460d780a2f8720e82eddad2b0722bcf8f7ff25cf891d508dac2ba9cbb745fd030380fdf5128807940a2f45d2cc1cce6f0e23e50e3317d9dd71b91ec0e030dc9e7806507b8c422b7188a27134aebf396f84b21fd55d2e0b86767f8955e09176207cc05db9bb395fd829b3deac2e5c0ef688f954c74a1efbc9cf180e13925bb18781d649de71332c59f876aaf52f9e7c55b58759dbfc5e1ddd99a0971c6e063b0a3eeae8c3eb481f4bd6e9c3a235446f19fa22e237f9ca29e812b600f0d644b5fd63620054971c68c155bf2dfd237ce194810641dee078e7075942e0c3d124147134337252b9c4150bfb534c75927980ab87c7cc80980916b55df9ed8f74057f62aecd24b058185fffccb95ea71a99bd660f201c1d3f71f5004afdb2c81785d6120c90c60bb35fa43e403cc7804960199525665cce085395d5ece70c9dccdc8d4b8347cdef00af988ff17cfa28a5c3d7164ecad260a1cd9a942eadf01fa9697580fca2e6d94eafbddb5b792f8a4c8145fce7cf610f67f8155f7e6f6fc5ba71d782d59169d8ead770bf5e42ff4c83717c5ce86877f36cc5a3e501c48b5eb4399bb9982e78cabf862fb4838e30834fbe7f815c62854551d875f41430732fcf2f3f00f4da774590a8cd6e934ec8273b2e6ef4c2c8078375a4b789a6e97855c24b0f7c9ec9ea8dc1b8cfea7e1b898dee1af2646b80b566fe0fd16f96a4b9094c9540e6a43073f149ae1284cb5da52dce4fe371855fbd78fa40d3f0856b0f5e49acce4ae5793ae3159e8cc32c5e3bdea0d42a41f0902126e95bf9e2426b5b7a5f68b84e2a53bb9dc02c751dd9b1c54b132c1a75b4f909fedb1c5bfd0cc6e644fa92cf3c819eb655cca7b918300e6e9996ce4750722d8990225666ba4be981fd1927d9ce43f2cc264ea946acbc6b262c643ac8c9bc3066fb3ed1992fe0d996dd5bdfd2ff9b6fffb58625d8e2ff266c10c750864fd3da9dadb90dd8f62dd8895804bf5a6ea526d88ce01bb2f21bcb757ae2187e17dea35c64c8cdcce5b2789a65c33c0620c6ad04393b54d47c2e07ce939887cc46dfdacf33a0e6a91a176f9e3180b5807387c8c4945c50877cf6e01315e99f5d02f3d216a2d7b0c2ac98486b792e511858cfde92bebf6b3b20229eeca4370cbac6ea75aeb9fca0ef402bd910bb6eae0efa86c7c167ec1816c4c8e1d44f54b20a77da69d318d4be88faa41c4fe2c5b33f709b87b2e350696338d965c1b7a9c771fac0823b4de6033a1d241924c9f1e5ff1e92840c8723a6b2e8cc4c8e74de2f7852177ca51c4dbb84a0ed175afa1ce1f0f472320998c7e5decadc2ed6de8d079172296eb9608c1d06edd90eecef03b5665624b7f5d5898a2026995c2d9dbb9e01018c2646ff16110d932cde01cb8e1f7257a6c50368eef4e610c5bc91e8d2fafeab8076e1ac835b159bff312350648b13edb2ccaf1df0c4a6e006b599d0fe6a41b3d7be4e661617ae55e986b85e36b75308bd9ee235fa59b711d0f89e3e0166dac1e632e78511e7bb1fd6e5eb1271b739b5a00a161530e04251ba23029117d275dd32f69204fa72c426dee9142ee1e10fab2f6cfbb8d3780fbe2ddb9e996ccf1ef6fdfe1a24571a87f3009e0ad0ae6d9e6d5e2d14391aa0286d94454c19db01a7b51b436a5418947cc94ba41fe6e4401e9e666c4d747609ce0357cddc1341b8e0786bd12223760d3880e7101774bb013c2169dc2de866629a065fce6e848b7029e83b07d48eaf476f587fc243692cfa9bd6a2dbbeac7fc64333e6119cbc0f15da9ea8462d5f5141760ab4622a5970dc0c70bfb3821126717f6c77cf4950c26955efad1f00f68ffba0ed53df9ee41c77c135a60e8617ff34644c1292662ceb89c838ee2fab383fdc6ec96acc40249aabf8c0e3febbeee1f257df8ff4956837543333c6069c4fe841001787dc267f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
