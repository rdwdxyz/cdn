<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"493a197ec4263e62ac34f16543f26dbf8cd612f21b417c252afd29e6aae85394e8c69f3aff8af1c6b909e88d239a68af367969b6cecea7d26f7407a111fdb716c54a5a78d05fa016a60b0de5966b51d6506a9ebf094b9f3908be75917c53592a2c1bbfcfecf6a2d2701954f7c5c7542e45e3e6e438bb5870ea562262e312e4acd6714ba15ae54006cd463980f76eb1ee55220dcc561a919fbcacc54e60108543e3c969d28ccf57fc6027227bad47467dfca5dba6867786b70308b079cbde131012726a66c5b0898cf5e8f9a67f35427809781145b68029be50d8a03fcd9624c1fdc667c31b96448dd432e704850c83945b3f0db2ba37959cf5cd33f8cfd71ff213f41987228c78f990e5952303bb2012e9ac3a12239c69f59d1ddb942c54ea3c0d0fa819bf05ea0e1823c14fa85c1397e3eb05c344d98c45cf140436155817e32e483391f9adad98963a5fe113e65a3479c1bb040967932157e6494fdd93b1e0f6805b3fb8cca9d761883850b8ee22bfab438acfd7c85737f970411ea9dfde87585966348a2933d357fee5833a7669274aafe0867365089c92b7f6e94c03bddec76068c5574874d8d8f8b4a791d31398a075ff496f4eb12c4d7220c5e4cee2486f937389cb76c72217db8abd041684b03f34c19f3914e5276bea3da5383fc505bc3569cadb7c34b3be46935139a16d1aef6da0a10838b6fd27bf6c4fa571c5be28cf393c7473f137680d9a5a7e50e59eba1561bef1d2146c9d83749701960b6915ce6413e3fc2990e56a386d2ad6c7bce015f19eaa4f41b1f3a4f07449dd9b79d5d60e3aa082e31845fdf025dff7f3108f7a1e851d7a7a24bb3486d633009b856be99fac28ea1fa19d57a8848a0b8954093e9624746171ed7bdb04e5b1a8e77e0b52b7221b03079169f998649fff60d6feb917dfc18bac1e49cbeaa88e120c691421935388142b3d869801e2990226c1c9dfba35d384c63c048c4a1f89d990a623328f41003ad7193eab7b4326f018d64174ef0e014d6c47c13dfde9a2a98cffbcf7891412e7df556836b950c22bb715aed49c0bcf6358e4e0f5cd0b78d2a5460f9acdb23830bd7d7318d550d6708638fb71f6a3934787d957155e74ab6193fcddfd6750236326a8724b0fb0e89400deb87b0f1d9a80d0c665bc6655e784caaa91e06a17438860b8197c38e1db61b82c130826e9745c205995fe75fd47aeb77408a1380da7cc4d11e680e788a377a88a1ba2bd9c41fdc9c740858788490f776023cbcbf7ce4b973f3ec4dab44adfa65715d651b97483dbb3d8ab9912bf218fe62cba5ee4df84d8b5c7979415098b0aa99708f4a439f535d238a360139770858f26341ae7b809fec36fd8b7ba719f1caa818b39e3b4b1845e24193536ee9df23a9f7904e254234f172b632036ab95f8e38cebfd55c399e87b5b7881515fa2b5aa4f5cf328c006d344e84e1f077411d43e223eadef2f97c9bbb6efdae45ca0032541ea88be7f7bb63842a7de2b4b86b82303d0012a3e0c3c065f46039e5605c2457f3bf2f4c6b7bb78e5ab21a64aa54c3850ff30bf774354082820941a5fa4994fefa58c0132f46d33f75a54486860f6243d541b58f3bc598c10d90aea58f70a8dd1fa316d3b90e114bce0fa037d23c557bfc3c782ba585db068abdfe05d144685698fe9642ab58608ecb8c06c83373d6ca96f655d7f338f6f5addd8ca8942fae4d2ba64fe7f742439a56976a266816376c4766c50d5941b0f56525ed929d15ab81eac8a2069e40c41a6ddd22ae5397efc23d179dcd894b283ea76bd0944c3231342efe6c116838c73020d8c3da972bc5de444eae9efdadc29dc22aeaa91b55307f7ef3c08dc2aa992dadec686c24c54e929ba2f5f5f49503b9e3c6c7c7413cf44a0734f5f7416eec2ac404dce087ffb907df35bcf2cd8ce6685c59b442773c1ddfa1f904264232b7947e9a9ec1560710b8c090978dfb0dec41bf982362bc2710f6d123ab58c62be56d32073b7ff77ae6b63baee754fe1c8783929b1c2bfa60cb7b73c62f804773d689bf2f9422addbc1edc2622dcf3ee56ac0d43b7cd15c6ffa4d2a0ba0a454a45ad56dcc6253fa66c82f71ddd209f0671b7e9a1f1ef9ec59784f8a66ca9a89967bd1ddf027f7dc104cb3e85f7448bced4a6bc778813f590553a0c382c5e3e8932b5594de98635b185f88fe1870d68293693d4e9d46743ec436eea6d9b50972b9e1c9600b582ace97a63342f90b28f74ff0125f7ddb6620719c2e067f24a1640fff2bf34c0dbbd4c3264149d1a2efb03fef478cc1f382399a5ce609fdb3ee54ee82d2c9c4bd6e1abd5653394d02f5a455608e01d8c206a531dd72f5b4ed5d7b7ea590851023ac134ff5d3da3485a295a52e6b0b8d1521e4e2af3713e450a02da96f267aeb0ec7d260bcbc0e9ba224483ca3452ad44b6476cfce7c54dbcbf6d010d9051107ac5d7c06b60c4175b128e9500ac1b859d200a52776cd7f583957de1c2727b6e4ef7d9c059a516a6e53054f4a8820173068d4252ce75b22719d01df98174d594c6c8dc78e9975e3ffaccd43efb8ca854bc33cc1546147abdcfe1c3400234d2ef3b4a174f79b6e12f56592159d75865c8152f119956cf2bd1cb4a7af9596196cc4420635c5b261b45915a977ca8fb7606bb8199c00a6c85e7349f0de5f5a1211adc3910bb326b46556654558a1287566236303b058e2b2e286bff922b324bf29c435c52c36d5f3e679cd0c14423ac7d218ebfaf42f97107f1439d846282f2b4e3f24e9fda4c9f44ac42f1914a76157bb4945b1b7bfc76b649c6c9ffa065294cfb880c0a201cdec14e9117acbb7de639e2326fe2388715d930092d27b4302747cb7a9cae57e0eb6458f36f8ad7ec62419279bba0102e62a50895e23dcdff1553eecb5000246265c931c030639f25bbb1271b53021a50e0df0fb8641dbaf1a107374e77333d5577484c48f5e80588019f7e1e84846cf68294b71ba306d8e80cd645dda254a2068bc4b5f3601ed38277dee9ca6ec055b9867f074608f02df6f206f7f03cea34fe3e0e9ed9dc83fb4396c3205c2d8e685fbaa67533db441d23c6971964dfde22df446e0c980175c0872cf8506d1b41b077e2dc4587dd076e9a6b984a9330568a0a47198d4855b67cae92cb810d46711412c8ef36874b3f362b563c618d4515227a784a61a9cccad2215c54a416f4ea489b429b1338b27f1c7fdca5e68d42c1cdc24ee022685cb5bd6a4a03c449ed4ded8bd1348989899fd871eee8ee69330e40b5712864d9522348434f812d6d00242c766007ba24327f89dd91b1398f430bb9929d76e4dde43ac55f3f08ff54fcf9410368ba209bc90fbd4978110b1c72162a06c4006ff6385fc2e2d1187c8139ec73e88dfb50cea560f2ebe797d2b7e55c3ff1f6f1c67f4451dc669ede334e2c41359523985c612cc46b8c4a3525d0963d317af2e335c17cd896e2b31cb352479474c266132c84ea6a58fc01f1b608d32b461877640e6baa764bf2fdd050c4437bce7ea46028c1d17b656500bbc19b3a2507bf61a18451cf33f1c61101e3418a69982ee3caa16f5ff5083d10061436967762577ce0a4a8724b7cb415695db701f2db68b013b38bb7d1792060969af19bb590608a2b0091960f8dfbac0fef9a74e76e553bdd5f667c84a5329c8b9a410af368535160722b6142ebedcd1df2f9fc5cb427b5e6fec31b4fd2f4dee19853e8b6e50fb3710a7da9bdb3cfbcbd7b800dc18266530dedad1c483ccd48f142e1c01a725dd51ce5413b4277cd5bcd1b847994b542c88af37cffefdac18f4bec86011475383a05ad3543ab256ed0d24112f3fcbc3868ad16cde524ae8f2433eff686852e81b9485572c1c91263542b435010f3c473728bbb0689b6fefbc74a26bc549fda1ef30d717dcc4e0a3565c052d9d84a0100b89706c39dba8c9bfa300bb62768deaa8585e961d4a0cfe5100777dbe0199f66baabe2e604c32aade66f1d0b58c85a83dd92e815a244e062c960bca64c17d94f02c241b5708bf695e982575819231853b351416fe656c0f356b43d06ae1daf34a862077e7dbf89e47b0605528b6a3636a0b86a3daf0bbc5c8fe100791f62ecfb0909d57e68977db8009395c3185fc699833504823409a7d6c5ceca4bc0d44d76f592397c5eb30ab6e1d3647febddcb242b19cc2eee806ae7216f30f1812f41eef84a8b49381848eaa72f6efe255c8d7a84aa68c3ac364c6dfb2f88a33945535ae53d6a8152204833b986265d1006660ee1599d2c0c408b75ec9c1522adba0a428126f14282e99548c1945b5f98fc93db30d85e0fa20edd8badbf1876c8abe4ce5f5b2bdb20121aa10a2b86b8e20dec2c9eff54863a8328625f94816cd64115dfad1f41a218773b7cf7e77768d7d6300dfbcc3d6e762e3d25a01016cfd76e28f5be7953ab062c52ca1ff2b269204e410620dfa053d0bbfcfc2889dd97016b3e7f23168bbef142660dc0756f1fb0df3bf515b3544dd4051abdaf258890418ef5a5bf6f2163b5b3a6cfc241fc1ab60dd5b1d1166a41dbb188ca2b836d6881adea1e82983fc9eda176e50086557b008e795cc88af3db3e25e4c0f86b6e151ba3b59b5c645f750d6711b25c53ab5ab2ffc0ebf432039daa9a5baeb5ba0164673c37ba907e9a08defc15b5f59c309dd884d40fae9e129154b8ecf9bfc1a9614029b7d68402738c6a4c31ee9b0ff6753bb1d3d6bc7cb63590a8170af429415783d82479d6980e9fe0b5b849303d8d60b732fb230d08382a9f3b3473e48edd2d81286ad139ae070a58591438e116e19f6581fc68824d47b4b017d02177e439b0dec61c2cc180984e3537ce969c97a97af93d46e406f3bf9dcff16943b1d3ecb89036e5e1fb390aee47f9b96145fd846b2040aa48d0e6dbf4952ad92b80f6d0de258b2b0d32a4fd90936b6a9c18a056f9d020b28d975843a32ce7fc8a0f04e145cced944c1050f1d091872b2ffdc3d2403be3340b82e2efd486fc7ce114d568a46eef53901c15693e2a6c2dc34887cd08f2f6af56f48beac61ba3e668b5e3e7fdc8cb98dfb37451bc747842b030fb9b6223316b82b43b030422851f08b87d2a94c8472d16ba26836761b1c0b8fcc627f3a32b565ed40d33361dd3179285634bc8283f937081b957ac2a53d006e346f2a19cbbd780f6a930aa611015af5d6ee39e7c10bfef714aa8653f46857b13bfe0957ace1647c1fed593d557d7b1f1efa4100497da45f09e6689a3dd262c39f37e1926ca155d16786a701d057bfddbbc6807d3f4848277c4defebe68d0b131bdb5c070b798db52be48c9d67c0bde6be3eb87b9c50e576bd4cd0358b7ddba8a27cab5fe7ba850bf83d9b0a284a8175ebf61e307722324fc81cbad28b3d3ed3e037c1e83b8702eb25daafaafae6f7d621a8160510704d2c148709582951abd3649c0a4a0c5ce5c4fad0a3bbc20335d64483ffda9dd47841ab5d4c597e540989d83bb2f90935590de542b643d8ee292e105341c2c5b347ca5af3b5fed55d064dd15f5f9f76787c3d231a83187f2d6cb3b19807d642987182f1102d1b2cad8d7f2c5360cbd09ca073614f6ec5e8587a3cd04d95a4a20b907cb1ca0b3fd2a0a0a9249e4aeb5532e8744f1d59ed4068b2799c581814e69ae731815fd21bc9f08c7801814fa89734da9fe4b737c3f7bd7758a772e7f3c3f02ea8730c5d91204cbfe16114483f602f7a888bd4856bf32c9d5f763f5f2929af0df4832e88d84f44a344a2efcb74aa6d1d3cdeece36bc9c612d1b8914220ce590ce759aa4c876a77c481a7277356c7a080ead3a305e02e87dff6d8b2b439a1ba11a2e73c2e1c1cb32c7279d1ec806a6b2b9d7e23d9b83be265c4eed39d7278b684bdd2b2d2700580d2db902617d9fdf58a9f6cd5d0dc802d04e97d8ae4fb733fef5c45e39b39ee93d4e8caaff17747b8c8954e2e0fa39235cb34595fc0bf7e9d13e0829aabde843b0b4f489855707ae9a0a73c9b39e1a05a132a2ac232d3304b6625d108b9b085133cf2f29ce9e44e1b56e6b1099576fa5c209672732a95ff6ad0a1b11e77333543aca5c92eecfa85f6adc5898ff9a268c4cb0b9efe59a925b9ca569214fc364c560ea5a9e362b80ad52901f687357209c4f49503ee6d7827aee1a0792eb45e4d270a811ed2c946c9d5de2ac74d9d9d3f417a172f1ccd0079e3544b1827e9ec48242596f8989338f03ec67e2d4799df45c29a5adace5e1a18afca6da829bc49b79301f78de3ba93bb214fd9cb7a18b4a460eb29a7fdff6a40bec1c8278a03ecbeaafade0398826519bd4c588bd7f4f625baee2798b45c56ff4bb8a8b19efb8799982332e8790ec017aa105fad25c0ee50222e08d477024675f78d92ac35177a8c70e030e1f81e778a09d148d53e857df68a39d64464b6065f2c993b9a050f1493d0e11d943d72d2f3f3b80904e6d2947be77b579a1c3ecff991aa269efe543b5397383b1004283a1b54dc48c840001cfdb2e01e85d5a318ca332367627365e06f9a66b7eff3132bbf4b37a56ff11463a7cee9fee1b23df5664a47e5799b0668f7caf48beebfa796bb7e5f200a225a3848034961025b4258dbd3ddfafce5838e5fc4e9920656b9e0b6d5ec8dfe833871a75c7728495a7f32e8de8c0c2e38dd48d2fb5910ba12e16c617cdc078b4ee0af5e559783507ab5e1280b2dbce92ee478f216dcb4d2878d16eb1071e505695849459b9e8339845595c023ee8db59b3f38e2b75e08e057198b1e9ee0bea206e380098fd2b8eb8db310cf1d342b7a47c5ed9998e0ea0f955bb1858157fc391fc7a575c61a43f191b97cc8437d41cb268290939d96b106ba5e5ee82c431fc4f6d250880c518409e81dbb6d69afbc93e33792308675a18db2f1fbcbc387b7fd7b7b3e4175b3b094bc2b11463002b5a0a83f836c47372ea561453b1cb8056dea16fba1ffe2232ec3c93a2ffae9fb4783fd195845f5bad6818a858c13811dff88f78274d8c4d154991b3d87d8ac61338cc905f11d1139ef40af0a7871fffddd25af16fe3e5038910aff5c6198b2b56fb857533dae523da634ac3874381b2b68e0751c055905fb189d9f9f2bd6fef4e4a37004ac7299d6c3a41cf24308efa6eb2836ad4571782a9d7c5bfb0c037af0ea340043b720c23587c2145d5c4ff84f81e6b55ba01a7af7d7642710ecd3345732733ff869393b8842e7e97b44dd79046a01d637a99089d0a71d3ab7565bf874f5d95c5b2d79f483efb6a92090d7ff3e28f5922ceaea8dabf543c9b7b25cfbebae063fa619af1098eff5856d66f2034d5924041b8cd2d58e2aad2643e56c8b3fecd4cc38317cdc5e497056722e1265b9d780fce2660d603493024ee0795fe68eac703f7dd8a56c0730b126c1436f7a6450d49c4065705f9142daec2f0e206a9b671fb9bef4b0313f155268e1fa1ab7b57788389dfbe3d1d788012c14e913aa528442a69c4307503c5e7dd5d8443367358bf95d1a7637e7ddce59530f815163df93ce2ab5871a122ba7fc3cb4207b275689b186e5ab9c95d13bb211bdcc20724c0a59ad6c4eb9a2591f447fa15d11d9d9d5b4be3e9e680fc1320ce5b45134cda75b5c3c599d31b8885925bbd60ca3f3ad401ca53abdc97828e4eef6d79a29736bc3613aba30bdfc41c4a93ff90444da51a66e3fc0be34b7affa843756a80632dca7b19377b33b3d463a059f25a9fb5bc1a85da61d97caaceff72bbea64c21904c325210e931af1a7bf6794c46807c0029924972767decbbf22f87744cec33b0405f9cdd69c23a6315c34a7727dd53445f617f390ff5a2697447e128a225454b0102bec1c9f0980d829d5ccfb5bdb264e31f24f9921b4149cd818f77f8168c48c687dbfa5d2d72447a4071239f99563508709beae5e9051de129c46de6fec22478507a15346eb1dedea73284c131413f0f3bb17be423cc84ec7adf6abb6c6ec7d8620d144fb3b1181a530c63b083bec03c1efc2c720035858c34525e98345465b3540412a3a26fe5436f86692cd6a7e4e233cd97889c8e83154a2bd8bf4307be5a4c720dc2f99dfac0a3d3175261a510eb530d49570aafa4bde5cc8277903788b1b87c23eaa916fbaee939d8ed744af4afc90188bc819b1cafc0b6cc2698f97dd7f60af6969f82b4fbbe4261523ca1c6fe5eddff28d1cb29c0bdd850347caa312324c43f9d2ca6433cd382115d6cd8fafce7dd0273a4ee1c019aa2c0e82ca3db5559c760c2026054e1bcefe133086f932bea86dec72569c251bca27efee6ffbf1e36d541b2a812936292d115d0eb59c71df14e7106dcc8b9c863e09597badfd40fde5d88bc9469699312d78ddd600ae24fd44e93ff86aa37f99f1cb731266c01c905b482238a1d85daaaa667f3a5ff40fc97eb5dad16854ad063d35c9b03c4fe56a512b19eb1fc4a125d389e37a917ac800f4738774de571096d01ea4a49cc2d7dfcacfbfb4e30e4b07607b29a0d482af1f022668862560f148095c4656aebf9f8128ed14f87430ff0e16648b66463cc65f5cd530eea8489786a9f785ed8fe471034fdd70c60e1f63def9173d9ef928a76342220395e3dbd041d358eb4be2f72112db10f8bfbaf020c82bcff8109e31066239a9c3718bd13652fa8a6ba7de9ade0c9c365fd6bbd209a1043f580b6b267d6dd57cf47efa73aff23bbe110cf76e3fd5c76ea8d6bb4e5b2954e2ba12ccd1ed71c46faae513625f4af0a2ce6f5b22e2b442aa3cd0df4ef37be09d6ceb24a4c725bfeeafdfe6c49f7e8d5de41029a4d5678bc6c91341fa5d18f8b3df94407c9c491ce990e0e43e9250ff5ff4986afe276006513df6e88dcc346ad9efc9be40a0d210b0047a9b67805dca2d2a100f02e7f7ff6ef4c4ee851e29e1c10a122e3a32bb6fb42ec13dfb27ae3b3deb299b3b24a880753f963b7ff4c3f1b66545ac0022c414dfcb510cd2a7be7ced07f0b8dcf0c3cdce626c598fd6c73d0982552f077df7415b26aa9f95f8ce974b1cce522d64c60177f7b59804ea8217b08f0d865a872935f7c45018239aab1e4f91c7574ac9afe7dab8d508f072bac35b8af30b2c37babccaf4b823a020110c0936defcbb447a2bcf1714c7dd2f177f65563c7e885275cfe5b205de301dffe6466148e99d4462b9f416898ec46c2d5d5dffb051506aab40f0c5042f11cf1c69dc183f7f59c5974b9d1387d4df42acb75bcedcdbb52d33c8084d438f56d19890c38f241dadeb7425aafdca04b15e40d5999fd6d51f2b74b83e35011b7127d2c8e72c199e6adc833a16625a2657869886d52f18b980af665070cc252f80a5c6ac77a85862d3c7cf416e4e6cd30526f002bc78cde71997eef8d55a029ec8f283f988f9fe7e274ca40f2d36b6c674988576bef86e4df60650f33498eafd2a8fc74581de6a292213d7b776fd007e646be7c26dcf23224f9f398755d0fd9fdfdff55e1f7f15e849999e6837a168448827960d38605e4d3d0ed42fd2cba1e462e7b41b21ace8bbd79d243bef3dd01992a4cec0442555fb36ad75226af89ed1362416578e8bf4cc0d02200b89d559f9b1ba544b28d16cb0479f68d40b77816c204b3f0999b2ed630f6b3267f2e991046be3a8a5f7b3bda587b0c37e4e874c2f2c60227babfc00cad260701839ac429d56a20b15b0b01db02e716c37165d5292a31acc713f5606e5964b2f7f314bb589597a57079902072e15584b0c9dab0cc95276ab26e96132d2e4870017e14fc0b62886fd02bdc54c40fa419ef7c32f4d08f30d93aa85fab2cf303e9b40505a02b57413cfcfb5645c8ac64851eb0a2255b92883cdadf0a0c8bf9a059d744e64f01b5c392aa72015bccf20dda8b0910b201ec07acfa6021558de54248549bb09e3e124ca28eb3e70e0304dfc08633ab7027053955cc7b2e3ec0250e07ca776e67e9aa25979fc53213a13f2fe66c7d5ca69922fa638e7fc6b36e360bb8c158cf3d71dfc09cb66abf9967f75e9c51498882addcce732b8357e5bd1c9071bb7b87d3dc296ffec74ecfe8533670010a39353c90dcfe2a0481bdee1c7ee7fd2eea8160dc025d47b8499e146c4e61e966c85402cfe48d962003efec09744399bffe0d445cc3db22e56b8c2dc4f7f1c7331890ba3f8f2cd737f8c9efc4657ec02041a142456e0c39b109ed5cb15bda9ca89143734b9b1d03b6239bf5f9a5c9574383e5cf92cf5c1b79ffdaf5a9cb23572b88e82b715b36b4a95e01f836a66b4ea3ebe5e39bd8a30e4fc4a4b8be4e7afd076d98de532b04a18b095b896135a67981ac6e885f85e8aedb0c603ddab315b3eaa70bf6108dbe47e9be07d74d067e3e1ac9f1abbc71045d3ac47cc9bb26ba039a18354e3f7821d3e4e877c58f221b2e54fe5f582411328683b6390c95a97858d2dca0b8d614fd621199d4df88e1f509708991936ac9a580479c621069173d09f09ffbd752869ea56a16987632d7e64252c9e8bf38750b2bc8ebac77190fd0b2a10bcba37ad2655f417b0610a9b734678b4837227c557bffb6ce48f6501d9482f19955e49b7af327d3b4a7928a160c34225d1fdbe2454ee2a351c8da6eef7c891b599ac7f7a4b9eb00cd922f54f1e9df11562cd1d1e0ac73b2ab9f8e51e72ea6df971c3cda4f7fa279a1431a19405b4395751db7c6d6a5ef0e77f750eded7d4804184d0fae785680d604ec7df1a95c7cb18dfb24c5b0b8c9c4ab4804270f019f6f453bfd9993eb77a97d94c8a6f034a31557864ddda38b694db8e9544ab80cb52620d199dba9c635d4ac7101f013a5d723190b6fc23e3ce4267aed7b766a5948e5822bd150e97915b051c195c74a7ed2f861a4724ea6a3fffa5c8f2dd4278ab7cdeae3531dcca306d0f40d0d6955b2c867e838f76b39e64ad5599e370e0339c2829ce38f22ac73be7d464ef354e8eaee25d2405ff68abfd6c59a2ee9caf0655d11c4d5bb4235a5e1eb64099a591198ec32c20ef44bf0d0c4be3497c4688520d8c1bb622ead65f37bc3e03ce5452e4ee5cfcbd88a00d777d31190722326c04ca78a38798749a2f66cf86067752d56ba807a14c1264c118925b8a9906fcc318929460e099c5e1bdbebfa500113e2d7e296e978cfe56f3205851ce93c6f3c98b9104073a3613dfeb4f0e3299be1d0d255db971afeed37c4dce2d6cc4938414276679a83da4da6bba57fde1d41c4f012afc59d8b0ebd5e272d9656a2814d5dccfc05293be5127814671fc79baaf699de09d409b3ee9e35e975cd6302540485256a4d2779a0d7249827398c74005016466310f9c43642cca81908af6fe86f92281692f67f9414f462df309579b4aa22b2f515e785c8b852a46c6298bd11f9eefb954d22bb1afc7db464b53f17200abafb219b31a88a567c602c5440fd09629d0885e3193b2bb8e5b4ad220c519917885ad4dee5d2d065cefbc758b5e8dd405a64b06ce532ead73e6635390f287a8bd6b3c2958b5a97da9ab098cac68e7dddf4532da500a80e20854e518f5b7ef5bdbdf814693b6a2e60649e97d9448ee2866053ec94481f33b1a26775fdb7f0383642bae03257ba8b007e5dd3fe6c6b91cb99e0d4de930a56643558bd22f88b505dc04f1f61290f1375d10a789af3c7cb36d2c0c51878adc2448b85d62f2f10ae55959728792b65f8ca450de19ef5b57505715804bcc45a46b722ff7b3eb80acb2caf76558128d66ae86dd8ef5119829b5b91f5d8d619106c82bf535be9287637720fb11fa80bced3cda1a3cde9d92e6446dd564fc07781986fa14fed5ae7c26bbb94113920c3445c660d6afc5ea545287552475e2e38fb4ab71d723daa149bf51d4582de0001e52ca8d6d339c3b6fe2ca15b0d1f98cba43f07500de2378033c75351ed1cb3c588648de33a76b106cf3e693a86dd3916a5b8d10c920fd65fb7e1f3bb5deaf5b9b05c6721739b47af3e8a099854b52624fcdb06fd7d9e93b96ac781e858237ab66d8efa606fb90baf1e2d0677d89149d177427961af8fbc0f705d4568d0e5d2d6023eda84612cbeab6b8445ca5370ee602301e3287c963b4a4e3b4969be9b3bc82d54c40c2c56d9c6c5d095a713ccbc5c0be5957d7c2c9532317b9536abb6f088da2541c6ef7a33fdfd3846a233517fd5e26922cd6237eea45eefb81207b804821c2f526e31fcc88da429499871af8b3b22463df04a89a0e569ed83e0e0f1d3743e3fb74c0d3d15ced3f7f65986db5792631ee19ee2537daeb01f44ee0bf2a204b60a30f37961e9c2cdbb1ed5ea77ba635f5620c8c82e92189ac824b6debd998261b6a51f991661689383bdf58908ece8d2243393de23efc5dea082195703c8ee4debc7e2df9cb51014ea02ba85f66db80773cb6c045e344e882610696a606e9082e807e9cba4ee42f055da4ca2c4346959928855591447c035f90f852efd4111750575370234fba71285b9fc3f67d1d16fa8cba2d72397916e2086fa6f26dc21e281428c38aeb6725745adf51c42467332af84b5eeba9504831d523b027c2d8ce217cc95b594bb10228154ddd89af59cd2daa8ee30321dd7aeae282ea5c52cf1548da8eccb5a60370a7d2e893029518022e4760e417ff0f51d9ce6be513e64a599715c8f101da51ddbcb337a883c0d7db2ec4dbff12fcdbb148b2f6d4dd98a493ea05be00c5ee7e29616bd90eeff5d3ce6e0cf4b3106d3f2263d0fc7b8d82932cf77cc087ff689fd2fb3a7e7538a465a3d26ad44016295b84809691ada040cb665b927bf6e8aa84b5ce366054a1b7f47fc0234dcf90d7b9a13064f1acc19e42fe4193545e493d2ce5ed3c76a2dac313cdf79776ef86132c693a0ccf4b09b0a72bf21cd282bb78035d003017bdf33e354461d0643df626175ea9c62d70b1e6a0d0ab62c8b18bf50b9d05d001219de1a666f7995e3f6d6e39dabd9dfc72d30d47d775a3168954d2ecbb6ba0386dce67d2d76b1e42e1dffd15346495b153fc5ec9577661645b655dfffe6ebf5efeb87821bd1f086798a7b3bb172cea8782109b903bf294fa49f07268565619f70e10f5d541ed4a45354bc528d43b73adec21ab061fdd3d53cbcf3f6bc8ead0be5f8a421a31b4cc93efb0f4edace69a5d18e49447532a15c52d1a1235b86b857e981bb734ec99d41b5591f9632881777d3dc5a7ab3a9d37dc2ebe78472ad995f7c9cff32fb9114ef83d11effe3d2ce8a967b98a447bf70165015b83432d3dd93aaf23ae1a69ffbfeed454c71e3e40c00ad87a1a59dd0de3fc8db871c72c58da509edbfddc0a11ff829d698bc31691fe29e00dff51288bb12c3e32f3c5432754b3d96f4b34e2e92d09280491281cf46360ade42dfa0db6cf8735c17acb2fc62e175b2578aa1878d4f3c263ca64a049f35452612920114f9df635839e747523542dfd6ec2ba233772a951c4cbee239746659cf8bde4bff36c87d905537b3f5a9806b47c373312fa440045edeb39f5e89a0749429e94ce9a696555b733757bc93ff79729f19e2afc7523ecfb8785437e62e9ccbccc9b2629c6817891ea0808524d9cf2f0228869d0447b4fc7fc3c4685b02e0b3045aac32fa2e70a5eb98ed3e82d48587bf741e1f9c36b26986bd179238cd144a51b317db78c750da019131a237bb3debd71e0d27bb274b48326c4dc9e1d84eecfc1e0058fcfda129ec2ac4317cace0f69c0da8e17cea9039dba726dde7dd46ceac204f9c2ddf37bd13fb4adaf834fcb11a10c162a2bd177b8dbe910483a9011f39a6ec123213f92d84717e353fb57b9d72fe5220a76212870342b6cdb5c37fcae74eafc23bed2f7d1b36b905e94a1f642f6a1f511f40f745528f12db36d12fa912680a0781d041c0f82e48e908eafdbbdcc0f1060d19f982c90a1f8c4e3016e931fe01f856c84896649206def92f688e0e31733188bb27306e4280b99775b2fc467f3dde05cd16ec1f5fcc75b7999afcb15b69624a3ed0c984713a1f37988bad3129daaf3281dbf4ca565afdae38db9078e5f6cedbf0620d78f8e01f595e8072846aa82a3ccc6882c0c6a99489a4ac85c794d6a3b574fda3ad6838461b6723da7da54e4a910ec46604100adddc685b54a26e73aefa2907907fa08ad7f00f322e123195287eb105aba5d3e57740bd2a2b3dd0fe87466ea017334868ff0dcdf69b54adca71bacaacdc0ffbac887ceb374bf3f96bc202d7f6f35268b4683b7a26a45c0b3a25245d3ca780f9e44d41d922bccd8d6238310cf0228227676884423d174cb9dfa14ede7af657530374acc960e87879c5f14671ef77fb0d9490a2e111189c9377144875ed0c07c4c5f2bbec05adb1bfa2bd23e182e16cbaba2dc8337381d18826624d7ffd336e85e91831af373e983769ea31762ed6432ac569f6471f3cba4dae73c617794c43d84992950a31270a41f91b8eae80fbd411c7e98193f2fcc270da499b9e44f5d9f7d477511e5fbf015547c8e7cba6736bf777de45b5de2a7d80d4c00e38a60ec9bff1e58746f460c8860759f651a1c8a4886449a56304fa63258b05676d332e56f5da7fc80a476a785258ab77bbf2c7133c6ab5f72e3ac657cd54a39a2db228cd4513dab92c6356e23c6eb13bde416defa760997a6c3195e1dbe85051d1c77782b2b9e21f7b7f9e6e2085d67ff1bbdb1a3be35be784aaf84e5ee1b1adbdbe27ab1f2b5ec796466ec64512db9dbe9a06c1b1bb3f50fee8a718c8b3a36d6f08a3e50929fc2f5198286586a2c303de64e10a68d2c2ce6652c42dc7bf418ef87e644f5aa917916d671f18b1732f6ac6f0cbc48dbb3e6f3d0e7e45fc28b111ea4aa32690cf22d8c1600ece01999527c3b39b2d2ce3b96f5d314d4f4565f55339cd388cf420637ddddaba289f9ee70aed15a0fe9ae05beca191a5e705b2748af95b5afe4c2eeddbff41b836c2d71e298bb15d188cdbd501ea4c81cedfc40a56708728374aac7ebd87523c97d0a5b472104c6ceef08736d8e8e4f19ca58e989149d95bf4087e897583f78a6e034df64e4522ab0163181bdf249d76529c1b0feed34964e4d7aebeadb2942a495c35a304a3e651d08acc6a81c6bc87b35a2a64c2fd8133482b3add8690294411ea2594b331f6eb752b61fb40268d2e0a87dd081ac80d95bcf88bc83b52c7d5de200fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
