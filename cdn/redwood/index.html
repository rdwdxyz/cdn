<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd4fa4844f7ad3f8466714118841a37e7062fa5f944037e69baecb2acb2e6639d7052b8b529037f015b21c2af230ac63b69250e5b2ec6778a004140f3c23e69708f00ea8d3f746eae049c7e6dad6fc25c66cd3b3eeaa2aba7ac1b1fcb189a892ef0e460b0039d53fb68e91dbfc60012768d1a5e3589cd62658461af44d615bf5e5bf75ce2c5f08a5cc42f58d9962be3355c37137a5d856f474a781a6461d6920c2543e256748999ae9493f346ccc3e7412016e0657604615a452f78602419ba0e97c38de7f9f3f568ea8e3b3504228b07aa4dc775a3b73064a0049322ad4dabc7c2ef379b90d24cdcd4b0faea6aab15dd94e0b360dbd3ec76075f2ccfeb3d030f3531458761c1c388696e13f6a176719d4348896f556298c434fcfa860c101235f83d55926211f1b657f8b3b6de1b59f3f91246149be13a831a2de92d455ac6c5442bc87c60a4660be1cf7162974dfe819262a8ed12be8d67f0c0723ad5ccb544bd1edc98882b0b5bee7eb08fedbfdaf7fdb2e66c7ca12ff533df1a9dd99baa74c41d813ff28013d9608ed2f34391f7d402f4013dd5404fa451d637a2a402b5132a0a2007ad04dc6a42e88e6aeb4873a42114a3e34b4096311ba554b455df59775cc5184774dd8e61c1fa6f2089236e64152bdc1301f9b7a247c07ec29b40b0f0587fafb43af807bfec85ed6e075a13f6c6258d886766bbd1a920a14105e042ed8c1aa5b5d667fa26583d9842c02ce4b9a98bc2230834910b0d208a538edd8a05d43cdecc331087b84e40d11aacedf14476af1d9b79459a593898a148f3daa2999028f94659ab0ad2bfe3bf5d5bbdc9d47edc963280579dd48e96afbe7c203462417f4f3d9c5a61f505698e80e737896392baaade08e969da1f65ebbff4cc40b94978cc96fe9f7a0d2e6588b0d560027e65e04568e609061d386ed4d46b9dffb0f157eae1a3d3cd25fdff0bfc4fecf1474455c67b8ae936538459f558baf1c950da3c367897a096707ac729f23fc309e5d72e0085d1b55b3049881cced15986cf5948e29d0004f53da9fe97675681669d0812c3746a678bc4bb318966be563168047d7f594fc923f2089470d627b3e6627ba46d24351b140569cb0860f4eefe8060c36bb31045ef6f6f565a0541f7df9242414f7c2802e6edef75a6ba191b06428da3afeecc149941819c62bf9b0ea651a7e34557e2840e99a146829735835661ee54a3978fcd7c874e23ef9ee003d6b5db2527cee69cc93a0f3b1766dfaa8a19e634b02f191cde9f41ca7f5cb227252294e9322304c917c4211fd4a40897e7a47b8f1df2491ed1e32e13c86446b089f475dcd125229e13ee6ca0eeda67babc8c1968151fbe8802002623ecaa89200598730a0076c0bf6cf9d730376fbd4696c77a6fb401eb029debd0cc268b45ac5dcabffa7f548dbeabe7dd67ecbf23af54c78b84e38d035f6eaed4c8e2d1cb43cfba7f1bf9bc4b2fe91c91099f3220b83b1d3e8381e63e364a96127106de1879b157855e826e0a73421fc62f7ce56a9b800f043379e35f19d966c9327af2dd759754d7b31d3fdfed8543e329df2249017da8b8469eddf721e584347e445c73f0fb3ae830f27e7f0b3510a8007cacda38ebab0c67b74be3396e70e29bea568f79dc58f757fb09689c403d97651aea1bbfdfceb627bf19a4c7fba7093039fa735be96cae76ee1e6bf54859f914fd4a224191d0924a30af656cd3d25866d19d2c9b378a6a80cb16575f96dd9a5cb7cfd490d8ed3f6ae49f3bd459a59652819096e9bb2f20b902b4ca371569867577cdd42ffbe749d281d2e1dee56eba457cd5414d88f86f2f24e64ce5f47a1b163f4911ec8f021fb8d4ca6e6b9a1c0ef9ca6e9314e4a6bb475521eee87cdca25df2b81e73dd75b4ac48c460c8a3cf78759a0f22d9170af38e588d1d030e37781474c49ec221a3a424dabee2876c49bfac0ea356ae7b584222432b1aba30a6f6f2a3074866316117486697c30d95ba1c8c64a416aad1491d7a53f89244f7409652f4ad16cbbfb6bb58a40b5cb84084e54e3f4686d45fd6e9201bd4e6f25562856bfe20846c85efb69dcc8935e4d485a9a7a096b298e1f881d5b4e993774abfaef635fa93177c1d6269b9108cd0cad5bb8e2a566428fff755c3817c9b791fc02700f2f91c80cc7659d4137910e555c640fa83e012a2328f8a4492b4aaab8811c077c05c901edf4e3c4768c30b2d8c4496324e65fd91bb0f26d22cf64ee23c5503f462be0d22873b86de6118cc6967acc881b7a5535797a8c7401526217a6f8ca36fb1c6b16fda3dbf76598641dec450a930d7e659576f3bb0665bbe9d9167176cf53a7ff2e1659e260fbfefd27afc4d6b8273b5e47e58159f6deb46f3a50ae864aa87342fffb7694e62ca56df472dea43881b25c49e9cf178de4e1b96cd0c6cf598b39dad72abff55e3a17492748e9519e341461e47b29716d7a579f3acb1e88ec22c6d8f08c4509feab0022b1e9b75fa3ddd4ceefb78e91ad7ac5a339c4f9e691018925697874a15bc1efa8907bdffb38955e1636840814c1cf063ff07d21a2b83d011b002e4486372355111655b7bc9d81d8445e67c6af19372877aa5a71f3241659b05fa38265908999c465fc95fe35a5b0db4c7df4382294ef6492fda35b3759bbd11932e56a652e6d94319cf07a7d14f435e18ddb72faa76a91022f3dd9f802008e5a7d7c23b0447327654a702117fc7c374a085aba067ee89350a4e9341e6dac469570902731d0369be5b03b81c6e0c206c72d60e6e79e1d05e4b169037e91dd3fb087be8741a484f8bf032e96d8648bb8e0f62d01ffc9f43dcf03f8e7d38944b562992e0e3dd124deb19667fae5b8fd753bbdf61fa37d39b2e08d18464fccb65d15687d96d6137b27b8f597eb11d3c97571ac4e16ae1cc8918242abf297d005f7107dbc29d03e700026df1a83c70c0c88e5d8674f1cfb0f023d550ca0c9c5f8403d6871d3964640d2a4a605291a6e15d9501b6a334bb88fc799a6166ce15cac0e3d3013b63d2571d02c9681f7b2ac19120ca95d4738f53e988bafb7bedf53941fc7e7498ef5fde3257fda962bdae6f8d595ea49bd545e9c18f06d3ffc1d2bb59f9e1e51765fc8784d14ed42dfcd278f5894368f41831f0c873a8704b9fa2b42f9eb97fabd1a111f29898830e5cc25dbeb004c22176b8702715d9e88afaa75c433a1235da0f77eb6335a9923dbd87f88edc9e7e90102438125245f40e524f11dc2106fdd6cca2f28f5e1e0c42745a5b18a4f271893a23c394c5fc03a84b6a984d4a7c5903b34b82f2d638a9637133776512f9fb830d565797b3c7aeb1dc921489af1e03049fe3245d46424826044f0efaced7e433b5fb825e23d89c08886c812778777f9a13bd5dfee796171512301c30abd191c397aad50fe68dfa2b810db19c2bef9b949c5baf1a71812b7919b3b69d68b205a2dd5ebb214d25db980de07f1355febaf17ec00267ed88f5d2149b587292764a4df4ae4e6bcd1142bce0d9a77e0f2fcaf7637c4edd85cd1c0f8d3006770adaa41d8163a586eb9e53c8dff2169901001b819982f2e1ca04c78705cf9813858829ecd1cc41a2ee096b52366f6951fffa31f6690bab95126d4737640ff454e503eae5cd2f54f6cceb87fd1e95de7f0478f6e56d03be0f09792ef2d8b2e97ac94875d85d10503b453a83946d8d818cf772d9d5b55ec1d2a80e32a4d42a4a24c2c349081769eee1e51dfd5d478eaa8f700bec4f1783047406466ccec32295551abcc09b7150c6c8246e619176df524f1703d4d2d94e67779d80a1aed219544f81fb7eef6244c9c6155aa5b80acd4a66722c4539c0367691f705b270fc21f2ec8b4d691b8bee9e008a726c87121c98f60ddae0cc2b4e2fd53baef47e5960719c7a984d3c30631a5413db0341cdba959b8c900a93e98ca8ebdec61321018e8fd5c44dab5ff370248e7c328c9f1753ae816bed75e5ddaed5af2c706f8f2973a136891983a69299341cce13afd5047437bbb2584b49871f68a131270757a59a6941777cc499e519c72a1c3322d2a57f3c3b2eb518a34f0e0701cf05008a27133ea02df4e1a2dc0057406456d28c81bdba3e73fa488e16f1fc945d57a863264334c86d93e51834cc8c999a726d4c09180b72474894282ef37e69b21092b6e630a6c2b7f0106176371352bd3a709cc2c774fb0fcc882a4c39d306ad928191923fe7c3e7c23075844f70405d528618fbccc60113d4ccd923a7e63a0854502adfd90d6a3739f5776dbb93330412d4aeb77d71088aff7fbb0f66301eba76009ad4ab1a877f8ee8d60f9e4ca3a7c6a0e0db7134fc65bb912ed0c76191b4ba810d1ac40d8beada4c6e7034bb76c2dc81c03af0124d38117f02ccd0989516285950492874703c30521af239e9116ab82baba30ac367f5e43fe09597f255c2268ed5996ea0eace2b32fe98acb5426ef922d65360d75ac0a388b17aecbc01e03320dfd12d34eeb19de69c616ca1e01af5b8eaac80dfa8a9ba00176ff6d6fc43afc0089a5c6debc77988c0e2363b7f5fecde935c71ac2252268a3f5569d4d50c6486bcdd0a1256f96c6ab19c5b4f06570ddf16d07b60af10b167c97d4f2702cb73d8a798b9327fea4bfe14ce133e784c7e1d71a16ecd6fa98cdfb5e31e0fde5ffe9b94157ecc0c0bdaa26d6c21068bd2ca83538af7205c21679ca371a308b4f92dfdf6ebe2eeff33d989a2c7f148e41bf9ae957ec68ad48bf1d357451373c18d69285e69fbf56b6b628242b535341e5adff59d8371a9237152195d8cc4f353ee9a12620e706850c0e99de05eab9ec08a0ffc47bc51c1d0a47c08b2a7e22fbba2e0928fd893561ca361550c7b3def481310ecd0ed7ca1967973fb1db498ae2ac1f2fdf652025a18f92c286a1285435b3728481e9892f0f727407c249c6030d79f3989d19f49fe99ccc7beee44be89bfc1fbaa7e5d17f12081dfe3645e7c04629f7f93d6e0e3d7364cf4dfb95191f274d6434d4a403e42a921e1653719c4ff1f9ecb1cf8df910bdccbf107e064dabf70717537f2d4b008062bd7e588f9446dd201f377881ea49b3ef91dd47823a4bda148f09d4d7ed07a3bc01d83aa270b41099893fb02127ae959299b1dc309934473db7d3535320901a63dbba0c4dc8bc6591e2c0d3380860616af516f7610792055548f762497c5f893eae0011a7f5b13bdf1c35441bf17cec355373038847a475c051b8a235ca671b797b5e165f73eb16cfeb6156be6ede555c70ae3774043231c243ff82eddc97b28253cf5f86b2b9f877720265361f29e0573618b5efaeed60158805f06c60cb76a184a5a721c17f3175ccb0a822492b275499327ba3ed83f44ed39f54bea8368933fc15f0d721d84b99054f20723ecf16550504913cc8b7131d784842f4df879548e502758c46c60debc537a1fe3f8d3644acc8a6f224a4e1c553688cd90f13985c381d45c4a97a6feb826e888841b08b2e21b123bd1a66671c67e9f169f459de1f2a130701887fe8b423553e88b600329266c8022c16ec87580c2e81a7a3763c834cf1f6a208515d4d03d00229baa56eb812709b93233fa1e6c8b7a15af324ce46c4a1d1ea880048e243350e8ea5ca46929418814d56b00163aec56dbe8133389b6801b4cb4d5ff8c939596fad4e60c79e34e774bf9d2afbe67c5fcbea4ef030d02a222d62dc37919769eb17092fad08e9aee2cdd5e9276299d8205ed7534799e29421e43dc64b194e24c4b22b5e71bd1a78d5e719961d3282ce932b25246bac78ef4de147b45a976845cc0806f4130641ba687d8a68dcd04dcc71263b888337b9488f1c33cb2df1d4b5f542996c8588d3ba19b13faaf7819389a146eb27192c8d8640d2114973fa94a166e80257046095f9ef99156438ac0febdb643a23b8c699a09272c8d2aae65a365cd4bdf31e8a6496b40606b285fbc06c7e05c6b9796ce60194db71a64bffc9c8ec10bf0fc6d57be664dc6c15951a86dc30d44c91d81680515e443d5fe1c001605cc03058c7a2c37f3eb0fe18d21edbfa4dfa691b99e9b2a69bc1bf03cb65ab3855d42f1ba3f94a27fcedc537dd84b61e413b6de2aa4c7a8eef22ad3dbde17f487ae742a035489983e0658dc453ecd66df0a83313cfedcf4e5b4e117b762b476677b85539ec1dd6eb71a7a9fd25b77100bab0c278ac60f598c4d13f6b800dc6a6f1af66ef2fc37cc72ac42374bfe1cc5d0b60b3b2285face65754764eefff612aef470c13ed47891277ffbaef01fad46d4ed3277012c5613b072ea8007cd671e507e72e57ac6cf833ba0423ac3164d085a92cbea5531278432b1a3b1d3fccd233da97d7ce150cad6ea7f16401aa1ab14a470f74bfaf255fcfab10d3770887a6765810b6dccd8739b3ec5e9d17ff31c2b0f545d971a922cb3b13f2fb56d10007c92592345cfcd02726a7f03d57eeb7e86216b86c7ecb60f2f126d47b9d3d4c65c912147ae11473fb37b447e8aadb6140ca2303adfe528a584ed33e25a77c932e26edf7a9f650622bfd1ab17fa7ce0843660d69a360f0f1b3ecbd2b816ccca9a5174e6a9478fc8d76798f659e657360fa59b3e8c0989862d397d7e524a8107e8e932ca9b383d22b6e17499078ce1436a3ee58098124ab4d3ab3be0f5ddb64a4bffbbcd4b9a857696428c49ffd27d2f74ad9102bbdfd1fb1d407d5203c2ea81871283b520a81402dca46f794c29be16b3087ea18079baf9aac3c87d617d277dcfdf2044133e2e2f4bd651b87c64bb17bc25b8fa1ad1ac8288c23df872d9754e82ff63ca6ef52c5a250043cef6819341f48a3d0cec5d6cf22d5dabd6bb208066832c201dee5a59b2cae13346a97e53c4f1de418f0ec22349c8709aeaf6ff10e5b8e194bd9bcce4605e8fd5dfef3346ba491511816ce27adb148d6b291fa723f474b712c00229db255703893f5e6c9ae960e93935af1650008124c89de2a756970652c18ab6a383d2a14c621e7b2162e6041f8480e3e6b6c50f670ea2566e6efc27c84ad2a673dd2dce59a9fde949e050a7d8c3731542a95e2b01121569b26730e82cc3bf5f8796fa7c62561b1938bc4551024f9f9b782423d0af143652df2b22aa883438572a96d7daa92ca3b5b52af04dd43e7c8d448d8c37f8cfccd417ea8324dc0c9ddea63c28cc7abb40527a8eae6705add2a69fb7d38009e700669f577daa62ed288131d06d702b509075bbde6384e9411f65216e02e1ce547808eefcc40c09e6d49ec3238eab197e72a98b3268fa46314d78b3f3914562fb66edebc3851c3a1c15ea9f38c1086dacac958d93af48da34e119b0743d44af9a6d4040f820fd51ca69dadc0f22174c86b380f7e0b1fa78a3505e0255dcc1b7412a572d5f910448ff7f4dd77e99a7b5c65d7ac81d947f291ee8da9e347b87273d755103f5b148a9b72fd0e908e3dc4d882f7196ed007143e35d788daa008e25ee67f44fcb42e5258e93e780c912b6edc7d3be342228143cf1d6b98e9550a7238796aa6d863af3fee433d25909fd062d3146b0a0ca92f449aeff72bd4b314477302c2f45023cac2018384f7b2bb3105e4763e5ec5970ade119cf419180c1cf50e9c8f0f2097457402c99191e6d6a6e44fbbb647cd66f775b12a64ce0c34b0f8bb3c78537472388d01d7f42d66b74356c387738bdca46685bbf46cf3547f4151513106d865d323b7e39896b69cb35a05ff4e0426c1e9be57dbf769b274d07e104181f4aca56bb9307f3d11c24392216b00bee2089b8fe1bdb1c2c68fb8befe4b3ea7c99c106bfba730e3f35fee15cf28eae6f71fda5e0f92875049e7f61c527e2a7065ff06d635ee87f19881f3ca42e6694ed17d85090706494a1dfe1e10716e9eabf3a6ebce6edf106adeb8a05bab4eb62e4bf51fad7a04a7df7a67acf51b8687e6fca1d473c5bd2a3125f70c08eb0c1ad7b5d6325852cb55d7b7f586ed58a9c14ee0a1863721a28ce49466685a97a3eb3dcdb537e9fff942e6a7c9e82f32909b5845a612435633d5860f61af15bc06b3101f12bd541fda53aa06793c4289d0769eb0703b7c425f2ad0d3798d91fc7b5ef6f000f4ff17f8cc219500d6f01d7d27735064da30f72ff3a71aca0eec376bc21762d4a3f9ffc5d98483e30f488a9ff53a686b8b6ccadd75e6675c3b5ab79d007f0878831339afbb500c1ed18aea13a83f29194879e86ce7b17308c03836541b47671d72fb4283a716f47027b676e3f0db01d33015364d8e5a405e74de3fcd48aa5057417cd0aaf3675a258291374a11385cd8767626d95a0c5868807d75fb3e84a47ba3c34cb29b4adf8853b57635e110b1f0045fd2f32885e06887916665b034fd05737b9f4d8e7b708cf2778ea66f996aa593c3bb2083ee2eeedac8d1eaf9296d5895e4d17438b759c685c841a3ab87b7c3d6c83eafd24796b2600fb0c1481b747f5d290a27055884cdb8790a6460d6c86a85e7d2e9c5999079c5fd747f7cd4c9df4d2b393205cfc29c41535536cabd52783eae7977e0dd6c133ec3c27fdb4e3a06cf9eef3255a61d9ee75d9056752ff325d6a4abb3f8c0e5d6cf11e7866016beec8f5be10372b18f7192052f0d2b55aa7d8f47a968b37784576a18a5f14d90a469b47d0f8bb5ce2c0946d7f5d221f682281d44875549b78f58d5c33cca6a0f9709e88eb583f710df2cf64856a12d02fc6f97e46167b4f291ac60685d5cb63a0d736133f346227a44cba4eb9dd05048a93ee9dc5e4afc6a10fdf162d3445d8b0a32a1d4d076e33a2b126031d3c5d64016d6634e3c36e78f3abf7ec84816c8b6566c27c24ec25f862263a246b9cd2a2359d6c584ed45c215a74829ffd7839ab24d2bd67f677aeec4dd3c78e23116c7fcfe0563cd8f98a8c2fb4fedffb469d0d64b6d39a7d42ab09d83b65a4442763785e6b80c9a6e38384d9729213cfc57e5c5c3d1d22da1bbb5a4ce268da064da0eb3962f32a99d0fc7ae8394a481ea031c1ae77629cca2d740b7339e38c6ac6538bf41479f4b509ae528d508ef5466adb8c1b7727f8c4e36c8ab4dca2e05ed3c8648d2d9b49a03f79cff4c7e74bc708339b1f6875ed722ef458cee4030eabde2fbc763f9d722e669c23e38f13da10b492e97207b5ea775f856b5b4efd4f2a61710ccb0667c35f8ce8cedc7c8f3b9fde2595ea0906ecfe4e8dbdacf35bc80550b53d1c602b111980280a9cbbf9cc581aaf35d7ed2ca28234e78f8281b056f5688eb2f335bca9c721d2fa7f3278381e9e5f86a7c2dfd301a0a977a4ef503b1b7e9581df4d4fe4446b38e94880fb2770aa624dc384ce1928fe63275ea3789d35b749f47a95ad5cd4ff633d2f08af4d3a84a90e53e64ad80c31fc2eb65f09caccbec95b96b0ee7a7815114eae0eec9c7dbf9d7086254251808523328e033eb622d770fdb8421c4a52359a6d79c0a15c3a14085073e8c291c098b6676c3fff4a01c92cd0b719919e8bb1e51dcac1d34ea242d243332ca1d45cb714206103cc5b1b8eca8f5877e04b78fdbb3cac191c4cfd471104981090bb2d06fe0d4d0e704c8b121412fbd17f79ff18e5524d0df437d9daaf3438cd55895e7d56cc68199494e9f88ab0768bae694450e1107abce6fae1b0ad3c05ae2135d28f538a1dca0758222d25927e768c98e229ed5009061ba00b616723e8b3feee6a1b710eebc57f592555bb9a0b47114edcbb5550ecf5beaa8672516cf5c581995ffb067dfd78681d964342f456dda15d4e17a24bec3a785d75efb7feea1c2bb51c9271836399d7962aef6c10fb700583951105ed7f269e41645586a8148d0f7089f414c31866af7eea50b28cc09a5dabb49b2f7a412427ed05ab23d08de44998d32724ed99b22bcbf30198f2d7e9151f22c623bf29fdf18337c4deb0a2158b08f122a819bd9587832201ccb4ea9eaadd3043b8d1e4d7b1437e23d8e9b97e87cf6a68ec8293a5a6607f897612fc359efe8023c5269c87ca7dab2b40cd55e258128a3425e28381e4b451f46e8f599a65d9e2daa372596605e0c81054d6d0b43a980800b4cb76935075297f66c238a7121ad5cdc42cfb7a2e3a16d86ac680f8c3beacda8bcbd0ecbdb78955f8206e96ee10285d0304ea1f7abd19e6a3220f16863909ad6dad90f2c8feb856e049353f8a67ee3fe0fe619a09765340a27e7bd664c2e2aecab62dbeb68702d30a97d7776c68e0d062080c8a5836e5880559e15671469a87fb9003c0fc0dc46f178e8da6df4fe6003cd99c40d67302b1df41e93cd2c11ea34fb32a01389e9933323949acdfb2cac5da4f338ac563f42c89183715c6e5f8f0edae8138838598e5bdb1a1788625072508f6871a5734c042a7be4cb6bb0edabf670e2c8434870048fa03a8df0276f5ea162ad809b41496e4e4db752398cffe00d43e1d67a145029bdd7c8a066c5098ce21b2dbea4baef395530ff37428061119c7edf19f137027425fc9364f345e3840d991ca6e7aebb662d5adf3d6daf909a4ff37e16b941249f9e9dda8710e7778c938231668901ca4147052f2e64614a578c5f477d9015d6f682ba27ab4af191dde5dfda477a5909e45b6295c32fcf225963d5a7fb11808d25a8fc593776b0c5637ba164e3ce7bab1f818720031921759bbba9d4bdb7f205c0090faeb043c7db38f1034ca0c3df63d9293e92e39a9d397bdc430b66967fa6c12a0ae5a58dc4fddae5f23c6e624d06699f098f40049aa74f8b9e5dfcef4841dc60843839b9696c7e4c7963419f50a13b921bc6ef8385b32e32e4bb34349199425642c51701374b4360deab753ab8456a6a3dd0612acec227650f95d93d8c22c2597806d822adba71b11bf812b178186eab198daeec01e45fbe0d8d8e0d99507582b50918b6bee61bc2adb712e43b8d92aa6d64970e81e485a71adba49462da9613fbf7332868508599c978aa13ce625c5fc9cef7e7fb9c6bfc18d58d0122ec38ed5813305600492c599c2fb170381f7c119f6eab0f81c781452e352fe3be0e5c1e43d99289aceea8913137ca837e7db8f7e744b39c0505e12d99f4a9352222d39314c9dd8db53d0aac83131af158031a7ca0ce38a3c2779a517c99b28764277fd179879f0683d040a068cae7e02185bff0a49b92e16a934fe929b7e57bf3272e6a13e927a3c458e89b4b7471d30219d7f3ec132326f63c72baa30a261e865d3381ba4b4a347f510c69b25c57f23775a89109355b1d8bd0ec425eadd9f12e40c7cb5d8a17afc19e8915676db8a12ca442d7f72dc74cb729a2cda1f4c025944871a4dd9e022cff36fce820af89c12c3e7e6c9d6e28cea976a7e2fd3aec0fbb3ffaa7a5a8745bb59795416853de95c5175ca349ddbf8a7c296b7e6413fb54bb7b10291a301af3e23b0a8f710d882a484027ab84db6057256e6c9c74992fabbcea0d639727c13f68376946356d60ad2b00b9589ca89b6773a4021ad0e94b48a442cc1a5c90e365516797234841813d88a5ceb91efb86a1bafbd15fb51837926af03a8c4218db42a96b76a7877fe7e913c350476348863216a647fad2ce26ddeb742f921369dfad1655ffb5ead090d617d65b08920c7d470cebeb057c3d9627d677a2cc821183cb25346528008cabfccacf5ef9ea73ca111c7b1cfbf95323e52c4da1a14c5ea05eaad301675b0d66664e7f41da44d50e8ebdb9cca1d5564d282671a0376c19fea65897fcebd678726688215c1e58b709842b9fa824a7b58fe0dce6584bb5c090dc7e10cc2b08dbf88be541369912cd74d7b9cfc1fa564e33c3f5a103eccb3f41d9e834b49d009c43b5ed783d06760c83404ef0fdf5260548b67fcbef9a2218aed6a369667209f33e23ccceb203e1a4a170f6d465febd474c08b1c0f78a73746f4f0b747af8e8a267712e86553904ee16c4896b80bbe6297ba81888a206b6120e02e1345a79ff2b51af2bf572bd53c3e110e69cdb4c85a5cddf8291908205dcc1aea19552c8f65934b61310372bcfb627b79aed03187dbfb2dbeec6353e13c99b9ade2e8f1b0a03562b9d9bdbe183878e832210bfcbe5af58d8749f765a92569da4d18a43aee99bcfa78a1c26577ac4e148b8b57233ce39faeb04a0f1e7ecdf8cea52b74a24d39e323cdf0b9f5e1d202b5fc028abe91f037f4bbafa09f53d695d2881e16b2bd482eb71b2d46bbb8896326f0453a3340a4a00d30514e39414ca04126b4009233c3a4d9bbb22ef6a1a87d61dcd9484b35514a574a5d0b5da5eefd5bfa7540a4524fa423ba46dace0f69f7f51b788300d5683c375925270949cc9cea2e52eaed339f412e7947f03d4f09c02c70b92d91fa80fcb7167c189be2e9b4ffd0596140a479eb056fb339904be7b89701f3c81d30f3b361b9d395556ecb8f07092019fda4cc34f1719843cb123bffcdec38f3d057909fdd43ebb8cee2277157c6351f1cad0ffab252be282a32249a24f4f2e320b077c813a96df045a09b37f90e46dc080813c535d197ec07b5a8b61f1835c8b2741ce0507175cbb8e89a99aafd4242a31ffeffb7bf199849b1aa74b0af64420ea21989477e234a67c7218572b04c7949b8adcdcb1f8ec664b465206e0774328caedd980a07efcc2b38250ef979fc05c16a04e664793ea4ba376ada9ba0d33aa0b15e1a5d47447de1bec0bde76ea8270413578e008ea9dfc447bfbd33fad0ccb660d5441f48f261bd57a6f00590dae493c4ff2e3b6d8ad2fd87f971b429647c1b2da0e5281992db133e1318449b9ca9eb1304b6d2dc7b773e870152a553121124c1fab9b925cf2ba889b68ef5f68124f23c890190cda85694cbfca216ca92d8b84d16452180f3b9c84e9b593a3a87371773cdda21bd045be749eb56fcfabb79b70e28b5217892b35c733735b4891add6f20020d249c44e637c3ba281032a336cb8bb04cf941671c33dd42f99e02f64679bb3eab8d98b4aecfbbf65bcec138efa69339be1ea808fcf76450ce13288a6fd9a682e4ed09e2e15f639e6ad47bf224da6fa45b9ba7af071d4acbde471ecf7b406b7566f4cde5178cd57c5df62f3ecf5f98d31fe5b8e4d519d6f338bbb27d63d1503fd57124493cb53501bea31fe79a912bd4fb92235fef1f435595573f82f7dd8f0b703fa327224b6087ccc13781b9e0e4a802147f3af89bc8b8a7881c44c8fa1e0d556e39c5e09603e02674689d3e5dbb2e8bad9ea4ffc329b16a884f117d8ae2d05ba2c357dc38082162635b59fcd173a18bd43afd19fd537e41c26d860a62bdaa74e4ba558f12cf495efdc3d8a3e26a93c85747c49fa7872f049d52ace82b3f0b092f2010aa6e370246445724a420a9726698d1d41c74a49cc2e1e2f42b560f0e0bfcd1f9043837123c3f2074ee911cd344ec76406ce412b527fe08fd1b64002fbd5f048ed125469ca0d9407c8721279bcb3527655ff0f8d0c97bf27893af2dff58ab9df11951467419db88bda6835484dda0bd96accea75ee3aee3adcae67fcb07b88f618e40ce14919ce06f7eda1b67f8255768f0467ebd410519840ef402bac62366a0455ecd3a2e0b08d7bcf6247f996411e7ae19225184f60ceb234fd019144797e32bd1862ba51a36cd7f7f569ebea4dc3c0e05e39e5c2349afd5fc308e8b32f5706e34271997d39bb3c0af4f28a31eff8dd58bc5bc7b219a553b21579114e1d6ae01702d220ff2dbfa12ea51d421e48e2b2801182a38e137b332fbc6df207a4a8447f740199837028ad64a2522efee2c39016b64e0fc3a5a9c7472e8cb034c8ff8241f87d75196edd5c7888dc8a8a24b7fcaa519b734b06b502726b10f5505b0ff5586c20b91b5081ad3d40aeb901eba87b308588b68fc6dfb78eb24c68d55dc10b3d3942a0f5a274c2174aa6e5bd56149f2d19ba6f6cc539cf6edfc2722c4ea54c1b400a85bcd37a3886046971f73cd79bdb79a84731fa240b477e667d12d3068507f0bc5a41e5123ae3efe5d0858fd07cb9d760bc1f76af1bc8acb188a8664a2c0ee8330cbdffc8bde9c15b5c68748d3a638194964ffa123c2d2f7116a5661955cc00d907c72da2f930c807bd98a9463dbe78bb7b81c05752959fd70b44decbe3b7c166550d9a7bb238eeff87a02ba25c4eb50d4faf0e15857a47ac904791b3f3e8290794700660415bc0a73123b6f215c80d2efa65c0007dd0915fd899cb181b9d466c15ed9e92db7c58849a3f097a0321d510e78683f7ab1aba2e985fd0589a865561d81dc58492050705eec3bc41333272752361cada920ec2f76b74feeb1fd0c34152b608723ff92b28cf0fef4c12a4b6d308268ec0563a06438f2a015476357c947b6ab824c1a665571606d460289a6164e7128c6a7c4abdd8483442f6215f2062a47c1b5abfbc1e63794182b5e5d12787951399759cad1490029db6caec18a6bb30fc4a9e2c98b8c683f448e5d06fbbe93f2e0c2cd0b31f1cd8f99e03e8952831177095f5f7fdbed134a7e8bb3ba4ab4edf4913495e93a1a8c3712385e10e5238f5a544988214e6694c10e19fe418082f40b43b045865673001f0946aff0b070dc8ee01ea2b66c1ee351b128b9d8fbfd49e67deb50d005034719ec84cc7468173c5a108b331e07f42b55504f9d53c6b4e05e119eb3d0541cd1c7638304e808744696f71f2d1e0d6fe77077f3bba1c9466088ef864a4c3092a75400cff63dfb566114cbded79288934a5092cdbe459dfe0736c429f654834931400dbb0553008018e8ea28f97e6244cb2f2a104aac8633c90f3ea8b0588f0a10b8c96212f9b4a7355c43f224463122e0569fe74605782126562fdad2504558a20ec727eddeabb7688171dfe05b8624da0d03f31e819d84b27219119b0d6052b88efabcc2aa30635d0ab395a760bf8fa96467a9f9a5d4fcfafb54281282b9479fac33a44b6f92434631c977fc6c67046eabb661671a5b448a71b8d7ee9ec5557db3989cc58878f8024f90d4be0e6d98af10b19e4f92495c42b73a7fd92f0d661947e86d3fc3db9dbddb0db865bc83a81045e2e178d326a84d78ac67621f825c939470818a4a2bb9a0b2a41df304418d59e25c1a24003448371b703c3cce3bf81b5d0e1045c27eb83c812b63e3406a36963291fe05553fba3693a0704aa513e607a0ffe0d6116e1bf1def191824057723073b6b62c539d3accab30447ee534b60415383233da5ced5c5d72e92582124c91ef88bfa5aa4511ea88f65d3479f0b8074849f58e52df39e638e20bcc0a5b17b3514e1571fac23ace84a88de7c6ac4d613245d951ca1793f6916aba6e580fb9370b116e0eec630ecb1e4b2064903f45a22b9a4aca389b62f46778368b1051b8193dff24b4cfea84dff17099421a8e687e90076a89c8bad9ab03f4ee8d46dad03f55d353c74bcb6006abd063252807a2a110ca0459aad6a5452446086e09649d3c86c22a08d78c9561185e3a92a3542656c4fe2663ab8a5dca37fa800fa3da851d5f5977671c2c9745f5845229eee198c3329668088043d803b23e3033f0ce14649eee86408843e3cc3a43e4ab96432078067045eda75b399ad078e4cf16258b41ff4fb2b5fc4f4ac21b3eea691a7b8ce59515723dcde47634d89401f99a65c6ecbc848b7b624299e1075bdf389e78eaee37eba00206f9760e2c748dea1485179786c41353a452846a61339058f6a2bbcdb0d27964cd59d18b26a923563791b8ac641d45c3df1764fd08f4e5db9f567d18fce1d2db1435f765850c3ea831b97a03862db03e40eb9103a403264416fa2d42e4c9cb0122dae715209b57b7b4c8323dc36cb30624e124a92e414cb6c4bfe19f64a26eca84fca2f32318a6f83afa86ba5f82caf37a9cb461982db4dec2697a5b78b9c8315165bfabc474d19be84f88c33b6034f2ef69a6bf1903c3ccf47cf57216011969be8f2344c5a2e1446d84c6f89852f2e95b91637eef39494a2547162fb34c700879a8e735e54a8a3a03390a01cec2aba6cdf044b16d1d3ee0c10e4a35e27ca64da73ae2e9c17642a1f7fc7dd875744b2e29a0de41dba3de5f581ca502e45e91d008a60bff24b7ad7a6f484b441c81b875b5ee45421bdd649ac0734e6332f3c70a764a251cef1881193092b85606c98b68698b9f81e12569ca2c268daed205772cfd82cd109aa1c4aa7eb09f79325d47418e66690886cf56b46c7bbe2cc198f3ce9262cb03a6ed6534755d076acbd3d6d59b114632884f99cb05e2b965b99c1091b7f5f1596e12dae26812503c5fc8444f0b7feee8c012525a5daf4f5ec5749639294afc0b0a0a899364f8eab980c91cd177b790854e7cf5399455544a0ab7c448fd9bb74fe5c4f0c61934a1f0a8057fd8f9beb21c2a48982048505dbde09e3a348653d079121bb6c77d77ceb1a8a4eb21c3344d94a9597134358e0c8b596db06a16ecfdbcb5fe8df494dcc9c2c47100511ae8f18cbe7bf8b6a180c359d3c3f6b2ea9a29e873f44195e26f8b02258eff03579454e39e8ddbfe5daf8a97c21fde6cc5fbbd1059b47610e4d6fe0d9755d0c4988bf10ff682d02d84bb2b4de6467939ab30bac5fb81daf8a89cd4d2e74e39f8a7e205befc83b337475bc230ffb8ee2a05e3726748b22089c65e65df1cdd9bd51c11ec2b1b92b291d6d195b7c6d1890aff28889fd160179b0ad736ee79be5abec0b8a820a2aef69fe65435467108f8e2d9f2837ddb9a3051318a90a9f7a4d692d731c801c8f3bc253c483edb67f9e4941e6ec892071c1ac794436e1a7356e0b435ae5e4fdabaef5bf346dad4946dd3c70f6571514e2f77145bb63f0dcdf9423f643ff7c1e07a7587fcd7d75d3d660224a3dbc88701d0f7770e601766adf46de1ff0bccc137b9bc6400fdd0c95095fb69caadbb33ed54a2bfa654f166d741888f7f44ec594002a933bdc014ab1c4252212f10561d6b16c3859e474fc1351d4988c4a23fc72d1fd7741aa63c9d06329d04d75208fe8d22b6b1bda80ee5e727db2dd7f8e96656e3d2a96b29ddd413b7885e5291268368c95267d562731513cdd9ff03ec937ed0262db444d06e0ccee9c5898e7d425aeb6c9dbf99ef6824b9f7780d7d1d49f6497de26234e80ccddca0c849b81c2afcc75603a728a52c69e66c16f25242349dde8b5afda328c0ce5fd52f24eec5879c662c9de61e9826799fdc5f6c981691398cdd4602f09e8123ff40a56df4fda8e7a46894945b06538a6c4b0b374eb6770dc6ab4b41696e6101c7567af6d46a653adceb3f82422fa446cb3ff87d0dca1c0ecabbc08e66bc04437f8793c8b9cbf1965ccbd744add3113d2d83e3a3f67533f8ee507f600126e8cc44d000acf864987d12a966ba0fa98920af994faeec2e913f5c9356a15cbbb3a9c0ad67b92a40ebf0e67cfcb6369b8c54b2ae3b43edb0fcb5a922bb2ef3fbc0973a2fcdaff1fe89d67c2181702ead2b36b0a9ee05957000cbd57693e25f54be22f58c217eb3d456264453e1e916c5a88248a0a96a083d2dbd943a4e1cb84cfa5fb103851890c52021fc9dc0155f348ae7d8c437037c759b7b726c6a80dec302202efca8ff344e5df80c03e066f3e6a1da8c1bee6524df9e7a1feeec4a6d0f1df533826932e8313720465ebed7b8c812ee6f7bac514ad110f3757315f3d19cdbbbc33d55b64a52c7665f0bfcb7b380c5909995e6b73ebe0f756b859bb1d02623d1bb6157ae413fc43bb420af4f184e6269120958e8990f9dec94066e978abd442bc765275db340ef674258e5ec519dfaee3ac67ae56bc3d9c681f24532fc0740e8b195c8f5210558f9a1dd136178f2253b00ca495822d8dd41d6c07743e71d6e80887fea238c8aacb43824cd79954f2942d61ff34d7eb80fd3599d45aafb7c0885de3c43a27d516f73e162f91ca39a328413394297a33bcac74284d7716e9c750e28e3c106c8d2476e38c79a1890ed76ff1533821515687ac5c6c7951502d0f53d37eee4c73c159b25842c9cedea8fbfd3c365ed213d2093686383bef967b2f6c7b1d0c031927d5733822299c9699ff39d2d39153c112dea997e5a7f82595aa73ed0b712cda55473b8b9fb5cd9cd0688619af55c868909c21aa07","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
