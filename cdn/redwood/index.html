<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3422db6d24fbeafa7531cb9b1418ee2319dc6e998db47067b45504fd91e43a5ca3ae00636a49c3e2bce63d647a817236f4266bb32a9ae57806c64b16fc8947a75a8e0758451ea3dfb5ad89e6a78ee2d75fb34c297178b22516ffba6e811822218761c10747fb1959ee479a5fc898b29924111f8a3c7736bb185ebeece0b33fa4e85a0b4588df5b520531b0a73b45ec75a58d4ed8a07082d234ed6a9c0593d840b5677ab1b2b91f30707dbae4e3199fc1244aed114299d3a6d0df82040a748ee81f5b6705a0a3ac961fe099fc80f91aa825fd583c59d837d87fdb7345ecee74752983a37e64567701fdb08220002f4e18a7ca378206b9a4286e6bdeea67da96e5cb7f8ce33404182d5b00875eb9e0a35af3e8ffc876551bece886cf551261e4390c987930fbaba669cf74575e091942c2cac1254101963f1093ec6c57e2f77908ac73c4ec59560a5b4fe3fdd792f8504d7c18e6833dce2a5e52653a5b7deda3370ad4382efc39b2329596c645be159c5c3145854ba244c0411dddb320d39ad881f89404f992e493fd44e26b15f136eb825f33e2516acdc5da9c26770406eac14e27b6a16bfc491f04a678e01a97ac840ae1137402325c16c041dd3daf3aa31b8163c7f5ccd5e988a27c3637d3d9d0ae7e1619c861dffa0d069bdc41abe518c454521c2e9fcde4f5fb4ba51431947dd7d6f7f4675620d2cfa496c5febb77d15cf23375a0efb62cdd6fa679fce8aeb7672df735e8d9ffd80b856d008ec9ea905583ae647a0cc7acf079aa88a7af1f4309bfb7598c9b481b09c029e0e351a824323cada8062baa2af0995bea02c14b56afb8e231607d21196168f1707777e177482cdda97b32e5a2a5a87734d4b9ae591c8aa71f0cefb3269f13031b0b9ec70464c92eaac50ac5d4338ae3eb22bcc68625c1726e4b1c93cefc48a3da01cd7ef100479bdfc3cdc4c4dc056cbe9a94bff522b2b27a86c73c44b0c789ebf7988c4fc07f61e28e247e6f36f39e1b5a8a0eb8c18f19bebd33a48439e58ee883e1a2c03d569923f91592a9ce03d74f30035a2bfa8c04e70521ccbed2c2285cd2a973f951c264ec52a147056e0b9cb265241b6253ef1e5618eb87a8e5c558e28f417bda538b5f5fa07cc580678d2e561b5122a99bac130fcd58f749c8a9a2c781f173f280cda41de786db90d39438e499490e1dd328020766a38b066eceb947b3852469fd5ffd013817ed250168c789f84ca07985808a1706acc8214c445a7e835e957e17a2ae9349422ed1d25d5661022ea8eaae98be3865130c1325d1618747e726a6f140e447d440bc0fc5ac4ab8b6a0e8b4710b5ccb6bca8d3bde5d7dec8286bd9bbac7144dacbc69fdf9c00b421881748470c4da3c9a94f13361fd28cb3a295d17a0c4a725d9175b4b1880806e8d5789ccfcc82ee6c8e43a34b84cd44c20eb83c27a9647a533e12804f42320db36f3084507d5ed6c5a01309945c7e12c50a8832b6ae79e1d7922a4133fa0d66661b5025008dd7cc0d8d78ae05fbefa0706ab6b74025f30bf85d1fdcfc9eb790867ce6eae5f032b8ff0b1d9940ef7d84089281db7b262f55a67d093716a3c0ae513213007b1b459c4481a4984676f7ffe75783969ff8a1a51d8486697952b24be7d1c7e509b5868bd5d19a68e6c406ae0617894b411364ac8eed667a50729d38d5d27f594c458f4d58d0e679b22dba1e8ae73471c3ad6711d384ee9ed156a36974e10b7baf6997376b8ab384b3689ceb769146da26795587761be9f5959bf3ceff167a509cebac82c5314c1e14c543ba3e20bc17c1428bfbddeaf8ae8fab63903565a47b790024578a3c9f0494f2cb95ba59ddaf7b0b99811111f27ab89225d60a52ef91ef8e0369749296f45888b5ab27b80c83ebc1f3d0e474a3efbbb63837c6942a5182412e0b59374da2e49c5792b17d2de407111dcf7eb49dd005d9f17a597209ecaadb5b561ce63e551d9d9f145d3d2d220e06759fb484b05cf59d01372bae56cc5416ed3258dd5f109eaf6c83756d9abbff874a96f39f281621b0098770e7f359d0650259e71c17e5a5d5a3f952956c3ec6c5a4cf58a8d11b7892c6d275dd49fee8edb946ff765b9297e3f456d688bf0a501a836edacb67decc2e383cc273eeff47215f13337f42bcd775a52a5db268cad4d55ee92d57b349bd7d7a531041ddd125eb79dee3415f28585ec54e362573fbd5d02f8eeb56909b78cd032a1ac0ae9b1d2979cf08ee99bcb5f8b088b88b75e77ac6c856559fcb67d623629fa0565b3a4404d8711c9ba724a698decec0f4e8b419b67a9004dcd1ad312ef939bba43e626ed1b2918da1bfb6e0223ca22e7fd8cb8191ea5639b85bfaa3521dd720f828731bb67cb9a7acacce61b5dbf0eb19ef8a703a650118fad9fcdd3cfbafd99bd33c264161851be6221851fa02c5d1be70fd017e6667f9766c6ed795353f5465f51cbf8f57973f2a05fcd02dbeb92b9f4a5f4e5dd3a5cfa876cb206cfe81cee55764bc37ed3d77a3bb310f0cfa7b5c3a1ceb0e38ec3e623e5bcefc7c0fb47fa4cf8fc76d4778bff9562472cf93ae6bccd67dfa37df6a77652c5adb89b07bbc5f452b21addc05415e92a5439e44e16496628217562bc3c41eec85f3e27e3ca7ba020919df2b2fcfb781d42659243fdd59f6357d45d42e60436c0761b84997d216bd2463825869bd9986b87db95a21a612f88313ed43d9f674452079230009c07ed09710f2b10471a274c0cba592b1b06e91b5d921464837e34078a6622cf4fff85ef269421a2ef5a29904deb7bd7b59dc3e04af52602b49df9f97b3ec16fe76433a9e4af7c87e8ecd8ae7dd882e0373c811e7a1a84f7746adf2ac82f18628bcaf1c301781ec9e8cbeb9d39dc3ea4734293a8592d51f04cae6c1d8ec1fb1eb1ac3a832b9526ec8689bc8be0412b64e4f870636fe9d582e48e87c706610fd6a5bc30e33e4026961b4b52919bba1682595e70951acfb2f0630ca5678c5aa0141397d8a6f03f7603375a1c8a38f991abe4fbd33754af28195993aea2b9ce7564027c8834ca7559a5c08662337ba9ea1646cfb4616073324a50f02a96b57dfcdcdb1ab2a8561dead172e276e0946a29485d2593776ec696e417a0a7a4c82016c3fd8c3c72e1dfeaf8eee205651a307e78f447417fa2bd31d87f3e30a44d3c16841d8ff54505a10d4f896f9022f25723aeca61b603cafbcb3122d04cdacc417e4e8e1fbeed6f61b867cc2e4baee8a697aee156255ab6b4b817207aefcc0dfd7db9f997bed67659d48d8dc24607d26c7a56287eea7343a67cecea9b6f5a89c62bb78f9b3453ca2abd059667519e9ce5bcd07f17fa6ec121b5a264e0fcd0ad40cc9fda36e8ab5e7960de87742744ed469ff289f690d4179477f664ae6f5db26cb11aaac18badee1e467a4dfb576d41ccafa9e64aafac69a23ae1599145f542426c1088e1942b6c9b766d969e2a109bec36decf88a093058f0b456413a32614f8b010414b045b4b3e7ca065ce26e73d0fe8cd3ace960ee6fd434d8cafecc46f2b1f4576fa1347be3491a2c2f4148a90ae6324d83ac2eef49e4fe3fdc07595f08f9984041fa7b668882e1386ec2f1d2ab2143d172f93fa15b12bf04764ed53a9e06fbeb5e6c160b83365c488cd75c48d3da8f7f820a9244b8a4d9e1efc0d8244c6bde1709125fceb03daa651dff228ba2d491892be5377c78498c280bf30482e8ec85459aaf5b94faea4b52deb37922b28ebc02a6b32942afbcc3035ff6bb9def0ae4ee83202896de81f3e29e11074a25391a5fffc4cd6f7f486aa956d75162db6bc4bd20c105cfcb5bfe91c70520245f9b90e6772450f44c7b3e4b4f280794b5ab1b1e0d668a176f030a75e71861bdbf27ff5286a911b5fa21c94f8e558b9400d9928780d40720c2f86169b20aeaba85d8aaae63fa307be6cbebb4dbcb5934bd17ad614cad0a84a81c85719601e53aba18b1edcaf8d80d9c2482aebbd1c0016a0c5d7dc79aea05f93dc0f48ef4b5c3eb4de1aa9d0f15327a07c4ae5d5e08a4dd52563da96e1a60bb91b083e541d42f88501ff5777b3ab13f185e728f845f3b8ba84d81fa6f3a9ed6cb48c294e1704646a04eec5ce9aff36564fe3c131e0451f5dae0005c34f6887227c8ea54a529f1d4721c8f7c1da03af628c230a720d15640355a9fd14968cff439a845cee74826c35b144af12639131dc5a94f81f1bbffc0d353188b0e08fad8014c10f11b150655d86980c71e825d7ca094d6bba4bef717d12111b3751397afc40713bdb893e011db52c804ac29ead40517b8b44121c0339d206d3c9fe4cf12ab4789b50355f5888ab4972001c0255021e214775f5b423de421daa4d1705b24db9ae168e183a10fc9c3872f9c7ba69f4abfbb558dab1f70e67fce0ee373095162685d42c24ef07cff99fe011d083b8e87f056f9179428268e0d785b6834cfc20c5156ca02087cd8b7cf44763db2beaf891005ece331e1166daae1a9c4d0109122b2e21a8325e834851d3a23ba949ad8f44945e0900b0c9a4e9f3b9af9d35980814bf9093cc0992dc844f4d45ff2c1550074a7571b3f87455f8071f8814228944fbda8878974aa4b774869defd45cde8083bd73f2230e9ee35e79c018754c5b7f7c5c336eab77901e58c38d32fff74686ea9c754715b950e689dd252cab7f9b5a251fbdc834d8568d06f3488c59b55ec8000f75a7992f2e35fbabf405918c0108c8605923a230a64e0ad599e1c17344439efe473084b93b42f122889b2a440762c0c06df76ae744408cb5133a926cd23d30921f927b290da4b17b2ed7f03b422671c29066be73a87849f93304e1c40d52fc69397a81b0b55c3159be0cf11eae2ce3dc33f1592ddbf547ca345c0b70d191c4d880bb7fabe0a496e169f451d0a283ce17cc565a21a7d542a50245d41182d78c111aa6484e9f3cc88f362eec370f07a447f57324d202688f0cd9322444d6c9a9ef21e58f53ae6b30c271002b0719281c1104986c090ffe438bb4c01c62c5d6d9aa19f21d28f062216196db3021837d941543b23878ad4bf9a17f650807cdec13a113eab797ecc1672cffbbe0bba438f9c435e5645ef0a68fb0b4853b739dec7356e21d8077504f874c36e294f7e4d578f25e491bb2e3f3f59bc0568667db1adb0e183a4120224798a4b0082e3091f33bb3ad5cd84277ba6c18704a3a0e57d8ccc9e15b3292fe3c04c6a752056f7e02c88b1bffea75f6113e567745757bd265b3e2dca569e5a99b2a037856b5cfd60625bda64839d8b046e81057efc6df2890ebf46304ed1eb0004a365f4369f42088e32a97e9f0d13cf05cd36b8ccb3e92df5888c3d3c64a515e91ef2666e075d012305f2aa452a2dfc07beeddb3806d7d61938501ec4e1ed236d6a345bfc6c104ec4200550970cb790bb69093d473afe8e67e5c4fd9ef0196bae2dc5967d35105cd19c19f4f41186f4086e77acdef797299e2d2a73ba4e1b56fb4500ef6a2953cc31580ed2c554b9fb6477feea11b4a3418311b90786f725a4cf54a2afe1e594c133ce6e9415478725d983b3005777a98c40a9fc8768f12bcf6ce956b802096f1f296f7cac2f2fb5389a5b66cb8e31b77430df39e18bc57bec63048e73b549194c258b9f80404a5381d508b21f27230b67ab963c20d716c05748023a523064ff538ad1b60bb752d8f816703b2d456f84454baab0987ff910b672ab3db54b451a9e31ac4e5dfc36a3ec9215359389d94175206efa9ebfd0dc7ad68c2e524919638f66ec22c3904e7876d395ac1936ef8596a4a4175b5f4a406f69b5777ff683c7f42534aa3713011eb55cfbfa92a84673bdb6cb372ad860e8b2f565941598ccde729634cd6ac48aca2c25438426b062fe509dcda544245a362df2d9eefcb2d3ed5b7d14526403bd38795ae4095b8713fd164589ef6e97c93a9b63edbfff5c95bab1aeb768d46b5212a4983b9b7a33e018c07c3569da83ec536f89a1022d647c196bd1d96bb23f07f5140e514c5e3dda0f989c17c8ef48862003c42bea1bde02755b179ee9c7471fdbbab46b1b2252cf395ac74d9cd0d86eaf03056673e06e34af7611cd17f17029d1cc51cd17dad588811ea23eb7182f4c5ab99f1731801f68d5ad88fa089d16251b267ed5881c4703342df8361e58ccd5ba950a0921a68fee353babc443ad153e673626f08912a46d35c717383ffc22cd9a685f82f6342446d59bb041df7e42788a3aac465cbf4201cae78048624e694549074910cfe774ddbd8078f1c29ef4fd024f77b5c6d944c70a47c3e73c9d4f2cb41cf60dc31dd6d4496092b51591dc160a28f9a26aa6345f215d425fc8bc75c57ffefb0eea54f8fb3e732f79240ca5d22b2daae9d7516cb49de24529f35d18f31b773b7fef5f9c049f623670a4b165fc51e41ec0edb1221464686ea8f3bb3d97e735a127b5d8b5daa787229111aaf5b92a42c33d9d7de14d1f0f41aded8af1972f6eb0fa3a38b0f54989f7b44fa24cb8273dc35c0690ab72d8a25d13ba6f29899e7a834b360e53c60d22df742bb61ed8451ace2789f9fd40a8c51c73a9f3c1c821f170fa3effc57cc86562f0c65c0a08dea2940a17a82db387ce0a503834daf6b84c77495f3157b7f81fb48b308fc9684363929ae1b694d952fcab0c48c88a83cedfeea92e8eea5e4d02c14e030c5d87941367d7ce923e32a188612e1902e851337be9c9d1236da97525090ed18213dd72d2925a43c65855960f429c9bd663635beda2cd0096b8ab4d2a8f291ef02fdde004d3f852d9360d156ab489dbc1b06b6e15baba1160ab95d218ef2fd61e9667f3e28bc45f0a712dafd2922bb7b38d7f0a6349c5085d53487c681f0953f365740f7b1450872d5932fe0187b8b19d358b93dbaaed1bdc6d0415f666b0cec9be5cfa7797410418839a76b387586b1f7fbf4f53c33f0600af978764aee69a975a100878913db0cabc4937d3f5e909ffff780481264791efe1e8a1c83bebb164f7392812696e4e865dda213b4bcae5d110254e11b00927e624b97277b2d51e08c59f56bdafcdc51a1f847851cf5fc58138f385efb390d388a56faf5a422ac5765df96a895904ba4afca11d5de3c598f9a953eb17bff9a3c1ed9df4d3004a7067000671386e0ec0126df6dedb11ff6164ee884a77c939d4f81172e1b47084223a73d2f9bb279bc6c06908e26a6a0ebcdb9543b5a719a56ea31ef935df204881f1901f43e5ddd170e557d152d1a57bb0de1e9a86c657c3e9fe464e643cfad2242e6b3b71ab1198edc85aae06578ecc02e503628440e24ab6bb3269dd7f4bcdb4e8ff9adcfa1a1cccf3269a395db0c0eae852a20c5ee03772a78790adf6aaae6b5926114f3756eb78302dad025fb01a2fb4a44b293ee4b733468f70a32e2163162a12ee52f86f808dc7076a90205542c187c7b91cad665a03a94f5fd2f37587cba95a3171532df4b48992184c1410771b9b491579fd0be8aca5d665ab2e610ec73d472e62d7997e3732c5915baa220075e9d006a16372302939d172a53f77d7f1ae1823335a674273e12fbaa9709c1ba443330011f9320836534286f8f2b3005f09bc61215252818a14cf122bc98cb7fcd2f68a5119232522f28fbed30ebca90c2c998f05f6d0b397b7b1b7909e057ffc322872b921990506c0450bfedc07d5e4abdc89e78bf8316115755db50f2205028cc35cddcdb938b8b5bf1ee12fa7aaa0395bff5ceab010a67d652bca1aa07959aeb6291eace31ae8901ef33d27f54c2da3e96dd4909e074d49296e15339f919252215c1171ce1e87fff355921b25f8c018beb4574baac9ed7318145c11f08e4d96d2bacf635d6d0ed2f0dd643ac863f17e1b83d00c407b8e8480fb51dacaee912ec758dca94056da7a88df067065bf9276d9997ebdf4cafeed158594232852877b44c11fb738f3eccb1dbe84218a4b428bc79ac2f101d29fa244712898e69bea291d3882faf9aef599b44eace0275a0cabe34c7f0c87b0274e97c4914f74f35c45bb67baefdaf52dc3bd6fcf75cf8d7e3286a5dd5f03f1123f730e90119c9ef55609066964d1a8092e0eeaa4855c7e0770414a3fc3119d3130c948dccf4e01b594a1f19442bf118351330700d36c3f3fc422a3ad64942cae2d85b4cf6dfc76c8aa9f320c78b8df8369776b0e1e70fd99cdf70184548abedff8050dffec5393b9ec23a4244e36d52420f4c8b92041c22c35742ae1dd29d97d3d822fc410d2097e76db82b5febfc730a258b658c66bdf35737f8c2c70cc7c25fdba31141c7e4178cbb7913c291a24d5aa2e99e9475b13c368a4c28e52ccdb505513a1a5a4980b0977b6072423c289eb4a8be080e7f174776860eba809065289ed7724340839ed164ac824e47607b2be555c870bde87c630b6a7383bb6207142392bedb7a6e4be1bf105ac3ab8308f49973b384210da556dd8386ac0ebde6ca6379cffc8a869253d1790c7ddb65c309494f0e06a6531fe994a272cc0468fe3653768690dd1d106711459f8561e62d2ba023820f3960c552b578cc43d477bf7d12495f82cacd40f95fb5d0ca46a51cdf5b58904b1df0a761783f614610605915d983eff6e83574e3e3c9b3fb8ff143a72730e6707300d1bdc7bcf9d488e982186009c90404c6ed7e0362a48163f62594b6f074c16ddaf6d5f5a5ea626b4ce1d65714d3b60bb3008773373da0c3cbdbe127176e6d2f1b2563d90045751ada60e4532ea8dbfe0d40fa5443bf95f3396418897961bd3de8cc2502bee60e98ce02036bf54e7103258db76d1aa8c92b6f92a92dddfa6a1aeac4cd3489ef2db0773b399648c360c01510ef563198c12fbeb853c0155a94eb022cd8cad1e7aeb65c6d3cf0e8d2554f47d14650de7294cddf7242127b8fbd11706433e1b62f6c7edcd3717ac9478524ddf764d3a51eef1471fdcaa47b3baf536ff7bca7ccd857592a72c8666b36fd5769abfaf6037733f441d007c26a04d71beacc5ecb626b69cb44393795807849892b5cf2283ba8aad4bbd68236b641cb0633cb5babcfa742a476b8220d12d14049aa29ea1491c4b5a943173a2c25949ba6cda63f249a13a7e9bb6e84cd85ecc40c116d5d209f1acd367ebee48370b87ee849e83c59b51296e60dbee0e608248326a75847c0912024ec995e2f3aab4ebe32934f94588be549b3d1dfb9e400bf3f8fd2134f49d2eee5caafd9d4c35f617a1463e07cff870156374f623561aa047e9fd1428b5ab914302465955d060bdea6abceae3c7d4cae2d36e9568ad236a699eee7a7c7a8ed3fe50ff46b786123884faed4d8dd1f1a12bbe8bf2c469d116c949b47a5dcab13e8dbe8df89154fa2ece355dd195ac6f3fc474e6f3e43b09ec2e7f3b8ae0f57717ff17e0353de4b046aa8e9aef8ff0f37cc8adab5e0ff5ae14d51c0001f3f2d504fa9998e4037aa386e5b607703a57487e1d050d9566af53f84b2d6bf427b9e376010c735cbebab8fa0ccd7977888c50a1c936c558f3e25989c785a64970a1732af2a1928ef2381dd3d26ce94d6c9d9d41410bfa7f95edd5bb161a703ea95ef9f6622bf8b67195026682db15978838dc0c5e25f0096e925289b550f6ab50b4c536b20cd164a27e36dd3396ed4f66d61da686a364935a1d31680b25241454cc5d97d95ee16c44a9d6455a38d221a780a33a0357217d0ca72fc6df13ab6e60082b30be4e63e1faafd1529b5dce7232745477166fa7b0acb29c8be10f95952439b346dfc62b848dee32ed255b9e4254c4df83858c9adf98a22e42709257668a9d066b6af735e70e390697b93e8eac2c7b29e2f8127890b9c062b31fde24b9503501e1351def8a1e6b323232a2538843ed535a0f9cf2311f33a187e54cb39d6c212aa2a2c795588eb528ae0b944a3c73fb0b6f7b6bc90096cf82ad2fea4387a7a39b2b24810866647b1ed75fb75a0adf3f9872b2f24dd20f59b9860821c043b057e4a4cbee17869ff09b572ad79260184a10368d5fa2679e52e21cc71ad492f857faf9c0a659064ead18fa09f801234c2d875ba14c481dc8d52088bfaf43334f4bcc3b88662a8ccf9ca88e004379ad0fdaae7df37794837fa3931cf05428b1e98f7d6f525c606e0b7e274246dcb1df566105bb3db9372f95142342206144f65beef34224c6c8eca8b868e5cc14859962c1fa350c68360d02146ab74941ad5338ac47ace6ec91e3db67b49454a1b4e18771ec0140c1845c80142dfc499928dfd50a1c6af48173afe7fb4d7516d6e15478b778682dbffa16dcb9fa25d6593d86bd78531f3a8c0402018616d35df3fa03dacc1b7254710aa25f797962ae7717ad971181b308ffd745116490b7d13014233bc5e184273d6c1173cf732fd1f0a5713485164a8ce0d4366446f4e01fb18debd28496eccb9d7d011bdfe605d06725bad8b1591bf634246d77bc815b298b0c479598fa9f4719f56ba14cdb6c0295a4d377b353a8e57531dc0fb54f4e0da318422163929010ac82879491923f5c79d4fe55b2b7865a814c43abb7ddb232292ce9aa043c1d3ffe6b498bdd9460d9c8d1734168995a06922b447b1b60315a352216b7de9054ba3988f15507f2179e6b2c7ced730ea61aef61a17ee9206a9b44316ce025d04c334aab3c867dee34909e52bf7067ced67dc14726b7674ab682fcbf1f6f15e38b0711eea271d561a4c1638119a9c7c0ae833e8242eca5d86a878120588eebef3592343ddd90953e10f8ae8a5a8a479dd3f705a7d9cec900d46e32396ee7dbdc2fedb47681fb9d4049465a2aba260426e4138ee10010aab3969cc5b4c1a7c8278ff6b3471c51eca89466c7cf91d4936343519e05694f8070a93461dc9ddc553ce868bbe4506d44a7dd646b044bf1bdec290a436a2a7f522c84ecd59cbcaa37b27d71ce4d0081a99ae91fc61f655af91718a4177414abcf470415733e03fc6d0273471b7d808f48e6e0243d65951e98b53b7e8c4683882e5beaaac98da160be0b6e8c728f7e9a3c30913c173f2334e49d28e9fb39e08075c38bafe08bd1d975ceb73dd17a17d7c8b16f3d3eb783c27bcffb652be193e06bc2decece31255399d482bacf83a04ab44e372df9419a7e3b6cc812997f4e39f7ac62d015371b31082ce9437f4bdeb6be828c6395789b0a8a78ba188e5192580ce8f16e2494bc69b0c903044e0f6dfee45633ae467809bdb3d5790a86aa354f35587ca0f86a2fe14123e511d72d33b13ffb14ab99012a6cef9436cb646f78b52a41074a8b5ead39197ef8f91d0464e1564455ccd0045de184fb3c90d3e0f8213e51a214a2c481c19a2a341217f75a459ca0f70d52d28bea73311eb5204bb10a072e91f93efd94b063cc74a7c35b813dcce73eb8a2dc06eb5db4fd72d91b8b81696fced8f6c6f13e42e6ba12e0b0b05b71b626f1c6cdad02924de9f452d4bbee82ab31b6d45fd7e577d5c2d4e15d8919feac1baf6fa09ba5ad9a6d7f2766852a454c1727c4535a59a04d76c161ff9e8b15898220196e15d14eda802ee2093924bcaa110caabd54d50ab6a1d283ac606aad5871b1d78014320d1236f9bec07c242ac30cfd262706f635e9934a3e5d8455efbee864acf31c78097fae581db1f1481dcdbce462777a68eb958bdaafc103c86429858a7701b6d1bc5ee4701c9dbc8e45141531524481eaf7720e1bad453fcdd9e8ff7aaf03aee7437769bc4bdcf73be8a0f7a742f0bedc828ed24efde38e4551d086ce2aca5ba010353195e332ae4ca670c7e279cb75aacfe22446353d3a68bf398fcd015f37f6859dd1e046bf67b09dc7c4be95086dc5dfaddf7167897d38e4f70fb2287101635899a686f2b76dc1618b70713cbd47701aff3e69ee5172789ed3e1c936c1a8df251662bb2190a069484c4ccae1d4d51c56848a57d61fcf6d83b8682b2243e9f9176a33a49c15d5d3f30e0cec9f75189ab8edb0082f6076efd1759258f698c8633cfd52638099ac193c0141a592f3dc4f2b9e4d5000047971532acbc7f0430c6f87f8c302308a4d764e9dc1f57d7e3bd7fe3659851e63b03ab6751679d7dcaf0a0e147406ec494100a2aa6f27d332fe57b0d6daa8756052faf2e49a5180a2d47ffbe205a172389fccb2911a0456d40ad2e98eb83af490b16a07cc3a7be9be401bd2776fcfbe1bbe367233f698f74f56045072b8beea91ab9d13173702860643772423acfa9e933b7b90d098834b5d70c116160e977370164d8edb7e86884ee3da80fde1ce02e7318053f193d0b5892d46444f53b415ad78e416fdb3565849791467dde2160967a1535930e89ffa897a74bc529a3dc82fdf1e179deb919a185c1a80b5ecd110f0da2e6d67c78646fd0f5b7249ff6d3b7511e5fe8335c734058502b8665240c4ffb4bb99d334f5afa9bda7f4d98a3c3b15e4f90886c020d03c4da4b4f9044d0f479aff20d5db614298904ec8160f8c66216943c1ba05d93ae8ec29b6a706812ba0c4caa07c7ba0e2a028c98d7e12a0a8c536fa0971eb5bc77f0f9aca52dff5dd650601b63970cfcd08a70419e187e1d383f9208d52db3620cd6af8eddd6e3cf4c388963ca03c1ea6e7afc84a7693aab6863b028b11058e7cee517f1eae1834143ef098a04c1c7256630219db5d3d07e4774a313513ba0b57060be72ad0ea1408b2153cbabef2a12377226dbbe8fb0d25183efedfd974c8d8774ca5627b8773a0984e8fac80c40f47840aae6a604a409bcc11dbc3d8097f3bbafce2621e77b14e0faaf77137a8b6fe497ea37c75fd30129a5af24f693a1f33274a465ae94ae0c64928c5f54f4312e0e5f71df75baa89f854618dda0defe45179c24427242eebe36c06f382b56f7154a60f4829d8b1726996e8ede2dd0746531bc339a23f0e364fe45e9a5b733dd25b1f9c218813aa49738502ba155425bd1928f8645cc98514b40d335f8eba02d392c2a5e084686a0e36e6c435cfbcf17cc8a89ba631c9e2aea46f5f5dbdacf9d739c7346b9a4e0e26c9b9456f2d04902140b43e747c20e0639a000867a71f2e1e5a294eda91ef62292ef8549cb94dc1971965ee057fa3af29345e8078f6448eafd14877866c991c89a113ca0676122f28fb03c52e3651018e556b4d751a0581bd5817c50fff13a80433922ca11450a2064d022b39c847f1df1822f981c296df17eb4a8af3bfed67f5814c663b543850d8eb1e5f58b7dbd64ad380c54c049b943eceee3f7cf1e284928ca60b9fc162bdf8037872a976cd4558b74ba8e817f922913bd01e629fc2d1b0db5eaf8b849f1738aae98cbdfaec02a56846f5cb0d1dc5f2fcafcd497b77f6158bfc19b0bb0227958268a5795b760186fccff87ff86017057053db16ac5f3acc4a806269086eff49f17f65fd292409545b6e1d577a1135135a0008eb70d7f53dc0d5df7ede858f5ff651dbaa76732df98ba7812f8467d4313ad61a6ad421e645e1ab764e3714e3b8eb58a71f9bfd9d7d097943fa11b3b5a3b90b2317281112b73e5a0b77a4e210beaab519bba5ddc39b80c174c0b40d7ae9bcd459182d57b8093cdbf23f9af39847f3767a4b80250ff4d5c219aaec34e9279240f4a993e2df52116713cb38880c8a657f283cba21847113158e74c7cb3b077c0c5bf2aaf432eb9c6d1868523e9611efe0fc959209cc10a13f87c109f8ef02ee22f1bea8ccb0842f4387b177100d3fefd336f1d6a0fdba0c25fad4b56443fc7b40faa74753810d152da80c7d0d702ecf7d6d2442b1a2c37760fcceb8303b0fed722a31581bf212fcf12f836bd78465a5527268a0fb07e22ac9fa2dc9597b814cb11a23ba0b71ebccac6fd61e59a9873bf86c6f0df619f1f91c573af6f9155a7b71181621e1829f0f9329dd047cbc5c094b6d6e0e883c2b916022e78bb7cb3e168bd2a9ccb34cc1cea6cf6142102c550271e028691c5f3d6118d274405e941673425210cad737f2c382d0d41d5cde215833b35e927c6ecbc76eb063c918a15ea4b7611512a50a428fcc46ebb7677b7b97b34521f2160ce43740bb4d7394e33d6699bccafe2c03ac8b3e581943f029fce3e3657274e3ef813a237c06061f8262048787a5a969785fc09b5487d13dcf932b67f5224810264b2363cda36c351dc2c2b1017f8cd95fab1e6cf3a8cea859fe68dc0a6f9b2a2f65587793e042e604965f96de63b7e59e8076233db1ece6838b29b19edf1b8fa7b54e979c36096d0a1f74e21e81a49faf8416e6efd97bd3aa9cb1d4387f2df706c77176ed5df78a8a37a9bad010ceecea04574e905ce1295a29081793c4621e35a7729d6b0770ef22d75b157a9fadf997d89f697fa75835b42d1fcc8aa8249ad58850d7db9d7f5ec11839ac3668e9196b24581e933d84fd36c3475d51889771bf0dc85bd42d385a73c4cbee19419094bfb50fc4007cbb1f0facfba25de50c2041f40e8173d53ca1edb8de0971b528268a5541eef33e668aff9d534dabba31f1119f47b8f0e9254384cc48d09ac4effaf5d8e2630e783ebafc9421c6e55e94f1ca81e52f70ff754a89335c36662266f245d7fdaaa1decfb66a423dab3784826d0c3abab8c430b157dedb9cb7359c5ccb0be7a365c571e6593e5307126089fb28b0599ff03ae37cd6c523c6f9f8f6006771ff2676c10b495f2918c4f852337e5bbf1354fab242ebdcb88542dbf5cdb598f66bc99ceb4c67e497e03526ff99e3c5dda0ade4c1267e01b578edfdc6562ffab7ec165aec53a56dfebb3f9b1f5dd028685bd623dbeea4fd6548b2d88abe1233695a12350864250ae39fcf1da11c936540db4b6eddea1fab64aa31bb3d77e3b67ecd9ecb0b39965d6a2453bf93081da101a52b489c18ac5ba4f5586eba0882a9e50f1551223f9ec66b59a395413059188bbc9a8793dd3f0655c63f02fbb3746ca03fc077ec5691b48a83fb0cc2c47170ed8b1eda455d82118f6d4429579a4741ef557ab16934ed1b2cafef21de0a643b2f769b9168130d2510f2990f5b1da1a7a701e7de89145be30772023da84bce87fe3da1b78d876de3e90b328bbf89a4a6997a2253d324a71302340b3ebc34f5af028787c7411a089c54b1afc2dd018237a9b4d28f77ee4f7a876e214a785eb6f2a56db2fe01cd1091142c4621ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
