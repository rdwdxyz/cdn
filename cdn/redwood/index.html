<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de14d6951d0748462bd05404c88a0ecc54d38c075d693b36ac4f6cbaf1cdd094578253850ed369ccfbe80c4fd13cd3d61b3fc8163faeced5bdfa045379d96edf22dbd9d587bdaa7476ea5e08f054cbff93e63b9a016853902ea99642f623ac598eb6079f8521b28186f1afcd7a824a48468c45cd2cbc1e375c1c4c865948ea8f77d2671c94ab222b94bac90c95432238a7146b4e30d07627c02b638e4dbda4c6e9c0a95852989f06101977c380c80f71fa6b521d30672e171f9e978c9c6153552cec1a8a25d0fac7af5b538dd5a5c2716dfea07d4e2220311f44a06ade32be21877bf3cc8aa85d585f59240c3bd0936b372d8ec5b5e9d20cbed83bc5a68f0aa4c2d2112b28752023f9ca842ce117b4d9cdd5fb553cd035903e69fa85b560113b733e46b602de3ffb2ff9edae36796e88807fb900706495155f31fc6fb157bdcccef652fc9ffd7538f5a79ee4eec25255d3e9df98ebc425f1f723076ddfa8e6114aa2ead573395bcc7ba2556494c390395bd25ecf45b675cec1556a78e48b36dbfd085f33b918d8c3c3e6cfa1701abc46608397cf43f723798b7b76d24bdd6a93db97f7d72d7bef77790f664dad30745cd29eca60ec0a5715df4274cded791c101ffbc788ad97a0251d3224c93d9d43e5a65ba2f84e9e99e051e536c2e522ed23a5fdbd09e45755d79ae32c5d77e180ce58e22c1a56f61501f2b17d7e7b88d05fc6cf7f6c1e908a3485555b681e4d7d9e438e1c1004ca2d7a8536dbe98b2fd47e0caaf6b8662a1722fd2bf147215ea40fa96a030173a7153185cd888aa19f0dc44ca4d4225224d479ff9e4eedd58ea444c4deee5f6d82e68c24499c09ae7b14f2884695fedea31c03f2124e80a379e36b53c81de9f5dfc6a540a10f669836cc24ad47c1de1714245779510b544265c272e5be2afd11562956215042927d673664a26c5e8f10e230a53521051565d459771e3489f8e14299c71a0c2e9189c969ba9a42cce21c4d2b9c5fa716a8025b174d4268393966ce1ee63251f867b6c713177277202a5c1518c1fdfe36f89d3ce22253618eab50bf06c1dcbdd438ee6174e4c3c71e4bdfcd407257692bebd7f53ab91a92d9f2b9b173bf91cfe278dd43d59a051999cbebd731b8d26966109fafd4790fcbe107416b38bae2c5d99e1b792ad65c6d93ba473348949694a9633e3f1c76cb8497fcb4146ecc00e431cad5340b4e571a54ad0e1569a2f100568977bef16b7b19ab83ef302c283337a6d9a06261b316d4987656fb69b95d1cfb83916cdfe340f3acd1e5acb8637deb91a1a8a9ad0d0b5388209018d9c9af4ab0347b3f9873290efe5e0af88af5e945b9112e07deb04e110a88d486a1d99cd40966c3d16813f6abd98b50be69b89876e669505f5740b5c485962d4e86713c3ae140a26fd82add13048c3a55c06c299ff3b330be14aa28ee2100eec011b2cdf5b3dec2f66411e77d9be46c9daab347af59c753c1dc1f13fce256ae3351b4d5b4e4e4ad2eb56d87994860f96233707f6911f7dfcf9ffc17b9a7e82dcc4117ebcb899ff458ce7dccf66af352988cfa6fde50c11dc58437e0d8b0f3d36dcbdf71e92b2fdb3601182ffb8329da8c2d86c7c01d6342eac080d6108c9c0eed1ca3b27db72b24a514c5a28034ba115689cffbc80e9b47109be7d03654702c94d4cafa342ff1a1e42d5179e12246a2c4cf682d8995a97b22b9c0219348031565a11268c3990866712dca7bb66f9753d620e2bff0276c6f3dea8b70673688dd2a969fa6af93c989f98fd617b0111d004500d57df8726a75a88b41a43ffc2a6eea005581c6ff5a15fce97fb81134f4f9495c520f8e23b08994ade9f09c1b28be24757c075989c378e00b97cac1512b0fa8e1aebef7b3f3f1edabeb973553428b6ff5c8456f18679fcb37ce2f54f1f8757fb761d172a5a4f47830775de6bd0750f6b0909b94c34778ed4645af5e5143bc993392320cf407b752eeee3cdcf57dd1ad698c1a98c5f05d35284caf2b15d6df12634675a8b3a48402d2c1b85e2457daabc6a90aee8a5f3aeb228246bd7229a1471ff8502d056ef4763412a3e35ff6d3de7241090634a6b137f941539ff877e6258666685aabef2616313f300790f01e7bd2755dc6d6d3fdfa4fb54f270bd5fd478e72daa0922ece5f4a4587155ecbfe59f32ef638f96db9de82d5fe3740586a9032bdd100bbeaa8a0b67da8d3ab64c3f67e01e357a8ce9897b49fe7e671b4cb1a7c4879e3c4b29bc6b1ddb6f82ed7e431472869044e6a4435f32bedb2723678bf0b97e309c0cf89fe67c5bdd9daefb9afcb9ee9acf0757d3bc310e15961818c91568b96e16eafed2b4d752d30c7e597495e840e6895a7f274028a6bc1432c51070d248a516e8e0c440f00d1b7286bfb489eb5ac4bcae7587f3755e43ace1448436b1c6b5f9c7a968e07f81d23c6a3a5bb6d504383965b3e6c5ee944e98c9f6fcee0ebe4cdc921821cbff950f4760cedaf31cf3707950d3dfd8f3cbf5c5d7281a33d19f701a585f4a710a27a593ede4af58cedafc486df5fefab2db66ffaccb750955dfdeb6682bf1ec22e3784157f67460405fd984f947e09f58d75eaf530f4e372db3d5411997740ae2464821e8e91fd8a718125be6af7218d7000b5c828f28936cfe26a3732322a3beb44e6cd9a10fe6149b8e02d9dc630a9a9b5afc7423bbe392fb913487b3740f99c68fea7c8202e5f3be81fe37fed45cf2df52b5b6769637fedde3386d65a739a51a6a491004d9d1d37f35b0368b6e0ff5e30b4e056ad4191b0dc711af41c613c8b4e8bee32cef4bd27a29bfd0b36125cac64ce903653d60002ca9fcd573c9ea9d6a72bcaa51bbde61eb2e2dee4ee0954e1ae014ea51f1a6cd3ca44b1cda16f2465e4dddc637d850dfbfc5176995d7641b239de9d68fe2d403747abef2ff3a5739376222b75685b57e10fc8ee91852f69e616e1211955ce766eb437af326ea7104dc89a51e00290af154e51276d51fe4ec3cac27cc7b6781ca5eb8dc0356fa6eefd8a2c5873470b758001caf2fb028ddfe55cada0e92d85b41c9a4af8bc530c3b81b599aec35b50c626080381cad9a520d9925ce4d5887bc6a58ff22678cc28415b3745bf88ecdb7599eb1aee0a7bbe4915f6e301fdb769de9ec7bba7c6193569c8f18e56d33d75560b7f52bf553244c3e989361c09004dc70d49f1d20eed248cac81901b059ad6c8c8460c86676c7107f8126172b90eb4ba17a00d9bdcac535d6eb5fe970a0eac02fa73d1467c826087ce8a19f2b6a3db3643ba2f0e939b5762f2f85c86247d136c1fb8474f59e7683cfe771bd3aa08dfc49ffc23070475e81dd3b58625fb80dcb13c456938bed7a6303ca14f9aa00629e57384edf52160eeb519d52252ec5397e6a2ad6f6c264f48cf3d184538a212eaf9832f075db5dbd041f8392a78e1dd2af9da589d3ea94aa8a3b34c6fdf41aa4a46aae8758f900491eadb35bebc78454755496dd9b8947723af134b508c42ce2c5167b04ed4d5493f172f6470f9d7008920f939fd36cadee6b3d777ffed2a87315083e22e51105eab3df3e045fc72500c4d9e685d5f26b5cc619ca86740e7ebe87eae1749a6b15486b9e5a6f3406b746dab7d585cdf8084615d03c1dcf7fd86ac71d0c1b956676a1eafd19980a09b1a364e038bee8f3ebe051f3475950b15984456a798b311c83f5f0328ef9b20946c922a6b91b1bf22caf1491963cd7265b365eba043538d15b62601e3134803fc87186356d92d12156893257a62fecf240ac5cc075df41b05e87027270a94249e785ac34f7ddd373e2e392b4b7c291f35d707274c7453982dbb86312e11cedebbf45bafdf16c622dbb738171d682bc2edd426bde46ce4eac1c7707b3a7ffe5bceccfac442b130379a630dd11bcfefc0cf3e15a436a4982ce75baab2d1339653dbe9f90880d7c7655583ab2d406468cc316d3d34a61c34779620b5984363971db16073b37a85e5d23cb556b632601b6fdefcf59054ce594cc7d550d9d67330958cf2a7999c4adbe8c43351dce7867af736e91d53b9b8704c735f3dd049c633fbaf8c8183cffe089d5d7f5b998c9ee99e1fb2776b3a562c9b5d5aa80d94ef732fd0b979a647167c253cb651981187127b02b96e22461c49fb33e684713f1e7571fcdbb06cc3e4238b86e8744c627152f974448230ebcc1fa68bfa2e975c8dbe0d9ffad750ef0d0d75e82bc38482b89934dc02ada30ac3e78e062c8a068bf3489cd295d10a2ad1d0fabff31f4749f72c3370ba4e59715660bf7dc2d37bf4cf893975db3af6151417fde9dc6f15323260dd179e42ec16579d8dc52aff37467352c9b2f1778f56140b016180f46709e56363e6855f9f214a89647789390692a0f413554631cb532c2b9f9d56da8663012d859dd80bfd6448c1b8383e6be4cf809ea2ce9c6f736fd845069502d58e88179a3a63dbd9c4c09a6fceb5927a6f73ce663b59e5d3efe98de1830f6481429848303f518aee3b64bbdeb2af8818fce37c81357f892d9ed54ba6043c9f2a67dafe3672f30568a0d74375cfd5e871654017468c0f0a1aa7612becbf4c23404f640a66bd6f6d389eabce08175e68b558c38452c03acb160e06477d74b6ee3a6d52fc041caf6402c6cc8fcf83513451c122d03994f79f03af99d7624dd483100802bf7cd67726e9493448774bb77568079f28bbf5c6aaa5da3cf73f8c5899beff1dacef2677f8052babd721f2c9fd2e7d6a57d06e36020d2a4db0fbda363fe97b8698ec6415dba22bd8aebf6f55cba5bac4bc0c9d62c31921115dce59343a34a1df3fb2077335b9d2b2f061dfc6d82312c2256b4312f0b4c43bb40b57973cb51a970e7e487386da718fd8fdc2193ca34bd2ac6379479e17f9c9a4eab5b3b134da660b6385a47c9c7918f7db1528942506ec56a66fd4ca453124e864b29c63d89343d55545fb57be566a10c6703175e113a44ed5217270b64662e2f9238e45d402e55c3443fbde9a1be97b0c4bcd6aa4ab30d95c518688b18ac689787b9dbdfba71c1ca7d9b570c9de2becaddd996d6eb03fb1b0c328ce24fb10dcbfdb2d924d94ceca8c8f3b38efeef4edda729241612c58ab020933a8208ea8ed176c3969096753c65d28b18c15a126e73df56d0bdc6c7300c9fa0a69c83c352a6d0b083d2da411b565430dd34c250e4f776a254f66f51cf6fd7c315370aa94ff1144fbbf636c164b7320e858d8b32abfabebb655b555332644c9104e777ccca5bd1bb7a78ec7a6fe77a4bb4b41ebc20453b9d67e1cd32c05c41a988437c406046ce46c7e01e03437c4fcfbce708faa9137ca0f6fa510480eb5074f6ce9fa5b0a49cde2ab0371ea212182194f057fb45901e73c702a7a22fd0ca9f8c0e06c43b51e52218cfabe97d15d893520a46b022ca0c0903e39dfac0235bcb5f58329cd735fb946a4ae9c714dce4d615cac5f87219f218714e0c6dcc9d80285e393e53c9f198351a517d050ee2e435fc23ad9a2fdb637937494bd3be5605481dea55da87d2c95b7531b479e1898e14b66ebba3639a11fa09fa44316affd6915e2f3876c069db00d15d32a39e4328dfdfec8240a3a07264c5305d1efad5263eae3eb99c730c3ad91912009c09d35d311ccc5142de8c20319cbee1c7cbeccfd821d9218eb6913252941d720e8703747ceebed825097b095ca41290498435515a3bfd377f511d01ab9beb8e177448c6ccfb6f0dc77438c5c65f20dca5f5fad1cec1eb29bb2640aa46812441a09a303d4d8c0a8d18c7ca56b194723ff0b531148e2bd0ae657f4a1c968b60ff2f680928f013cbe04c01d654d8ecf8d4f34d45a2f45fea49c7256e79061e55742fe707a025b65b9d7cf16586abdeff58f3ec922be17de6f69ec686f93d82560e0312a507c7dcdb7bd7f14d527c355ae898d699226486c61e59829ef54a718ce5e121f910fe38bf0a01c3d0b1ec109e631ae00ee831702185d6872143fb48a3a597b5eec9a40580f98d20237e76dfa53a962601632e702b084c4915a133945331bc83fc2b077f5058df18343767a18eb5b6fc2c77e3dd36d86e3528df09198e9ff6cab8b0530955068d5c5f6f9c32f19804779c8e9c54596cce202dfc07fef0c2b73a7e7c1a86737b0bf195dfa182ebeed5a4a044dc81f2bccd4bc9f4af02f6c19d49c382616b175cd958cc7eadc2f1651fd4e79c81c3e8f80ea5214f4a2737d57a018f553acbb7f7d036ac241ebb1c13ab12ac6898414b5198e8c425207c74274e100694895edfe9b8d3c8164428a669c44d7450bd014c80193a71da59d84d73769690df6fed9503e3b1500e825b0fc558fb2d4602fa5da2643b028a8e487e7b65f8c1a0b95c4dbab96873e38c187d75bc50c63e473ea864104830c92782ebbcfcb6809f1deb1fb3a439bc37754cce3b497938f6b4c9eb8aa6acc1a607386d3a71e48af61e219c2a2e5c1255aca0f81dcbef9aed8ac48939afeb16df1ccfddf99a272be79b67a51afd49d88cba4ed73206d3054797fed06283db6f099f3e15b028a9d221755278f655a11d6376f1a911944d95ec4663cef3b32f1d971e57f80daab02d0c366f3bd2b0b24a4be2bd9d8e4f4b8dc9133f835a1d13fb97f95b578e74aa8e4da95bc6607eeeb85e06350c80e60c58a8fcc838d296d9518f363f98c400df6b0570c4817999b0d10b74254aa7d941da2b6bffda2fb3d26bef1595b0b09ce97208d16cd9a00c541a01ed4c65d9706b385c909428b97b5cc720bbf9acebada1788fa030948fed203a7dbea66da457114edc16f5d4900c628947cb161ed6b477bd5b041cc412fc5c59562a0d2afba8a573f2fe70d722f1939f103d08a5529e4aa5975c4be5d445b2390bed85cb5d923a83f57af096600a723023927fddbf9d69622d9d65a74a7befa26088a482f5f24ba9e48659f4eba736222d99e66de52aae47d639809faedba7e147045a4a18da2e31840a3e6edb8b8971342af29280fe32c0a64b1e1ebe80451ce7ded976d141ba60fa3b61503b71e2bb77ea12a4f1bcdc15b16dc9ae02d4ed56099d06e85666afe93d22a7b67094e1c2b358c8b6f02b723c3c8a07ac6ea17863d7e26dd79b0cb65beb66fb27accd314c104d9bc839c869525b7dd053f73b3ca35190fa67185775ca9f2f12051e69a3b9118d52ae0b92f8d1c71ea1fe5c8f058a2a3db61aefb6eb8d51253360984a0ac80ae87a27e01ee306c1dc0187e794da183480dec8169ca7dd28d6f13c3b0754559333948bb19314e8ee3d211a75722759ff1e51d73e5c7d1f0d5aaed4b55560c9662f651fe85118146199aa18337abac20bd41fb51ffc8bae090cd68c8b91252e62d39d3c49354985f850d8a78eb3f7f23c36db1c74e66cf0e67b243787fb80b759efdd84b0575459c411c325d396bd3fecf7691e225429eef5b27a53d0237fb4b1cc86b29cca11a34846797bd378a81d77ff43bc1265c931667f5bb3a61def90b45c411ee02359a2e84cc60250030fdc514bbe2f233ce7e49df95320691402b8cb05fcacd04294afd3ef57fe52676cc53668346776a337a08249a7c821b33b26d36b7dffc2c0062afa3b5248bbd23d150a3ba05df7f6864bccbedfde79238f3d81ed4c13a51830acea46f90502fb56b6c5a7edc8fed0c07e68ba8571abf883922ea00f5bac5304b761ec9baa84e1e3e53037f89643769111c7462ecf082d7ed1ecf038fefaabc9f7dada00de9a7ac5ce6b79bbd661a5777ba5f0f178b738e4b72f48e58a005ea7da1c5d79e895e251b5cc37d6ff0959c773f7e484a584f9f2fcba33fbda8dfa9aacfaba2f0d30e30024711218c088b3a3896f3837cbda1a97b2fc0022d46a8c50c50205b6134da97eadcc7df4310da468698b04f347edf22348674432e2237316ee08c66ca54f17849f769411feb1a8b407f49ca144009a6cffc2d75ebcd0e2e749f6c13fa04e6e2284036bd525ac8448dbae4c1ddb54942322b76c9bc59ea72afc30504971c22066a7ac38868be928efd238f27d5a3f01d9845c515a024f911aac42be3d3d16f4a5d7b86a926540aab6cb03062c57c0ed86d5fd441b6beae06d23168973f3e2ae79c4b29386ae219c78185dbf97d6df8abd069950615cff07c0a877a27661daacf509f39b7ec45586fa461210868ec04691946f72050f1ed1a8de716e6a2ccbfc9c66a160672648ea69adb894d647ccc9b902121cfdb8fc33e6b70fceb9e665e70d49f8ae0b4d5b5ac497340d8bb9c4ed0d2d93b0f79f371a4cfe604c30c1b713219c903aae2aa26d89dc1bb7fe2a64a3f7ed47ea42d8896365ee39c23d542fa0e5935f70ca8513d54075f6c6d67ddc0dd182a54e5f298b520034ddf919370bd194b563b0f113d37a8c30bbac670561f68414f1320900fb4df339361b778f7cadf2a73532006d434866d63dcbfa87e8baa4171fbbbf76829d8afbaec0eb28765d2d81d2ac324165f87cf6b644a30283b609d5ea90addf3a861918627d3794d2cb478a5fe0762b618954c096ecde698160bfa62b6785f519cdb61965a0352a9967ccd0e21aa33b0fbe16258cdf708d7659ead536204636f770326a5d1b987d8ce22675289de1e3e9ad5249690d90c314dcd6022c78acb2a23635040d6e330b5d7b9adf8ac7d0a03253a3b8b795ded0c2027da74617872d4474c4dbf3602a26f1309da177583183724a7729ba75385c3eefc04783bce40a0ebd9991d53eb523aa6610ca548744ad4de084955c86918f77b85de0dd9e62b1c4a8ee25abd5cb98357dc9f3ed72b5e60971c1a39d9f730c20a914556fa8dded69800cae016fa868185f2f798ab7c95bbdfdfd37201d1e334f185b24eb1b554e878de218537ec36348436330e65711e89be435171251577bc3a1ca102355ee2d27d257fe23ee5e5dbf5e9258dcc26b24bcce9dce391bc8e40f95dd9dab851d096f9eaf2063952be23de72911a7118a3898a51af07830525892f09cb12e1e6674bbb2adc5591aed2b820deef48ad6e787c047419d1dcaebebd41a1569babd11eacbb41cdb327a62095446c2e74f22cfa672af6bbb646705cd28d9cacd636642f2b1dc0066c2361be6ed03f401839a49de61e45e59991fabb7dbc7a14cb70b8257b8123df6f09a8109ff7166ee86ad76bbeb35473e37f977129f8b50ec54018585f0b55bea37fdc4e7c00f012d3a6241d70e5e769598062adc0af87af571caab3ee1c50ca4c35ae571ede7493f11673ddf797741ef86df844b26c576cc545860e81c28da4d8f279690e1dcdbc746b25a3c5785c2b2fc800ff2f33c2537111da1608c83298e718e70582387acf3ecdb0ffbbf09470f1a8b582498a165ac90144a0cb24a21fc1d9b5c3afe4c991d40719532ec560d9457034557f70b8eb561e0c848c7ed3bca4c5b5f574dec39214358dd7a1dfc044e031db271fe785cde07d26c782291fff8cdf293516755367d435b3c3e0e5ac1f50cc318ef5f67545b55bc1495dd9b6c1726a8ecbd3fd447f5f574dc0e320f490172ed5ee69345ded7c16899a81c7967c70d2f10f539af28f0288f1e1b0c40681eb0cc5b4eba557fdf4a932ccf3b1a40851d7fa213fbd05a2cdc5990145b0818734e26ec2bb3242d69a3b79496ca51b16baa135c18f673d3b6f97ca52f603f27402631bfc6078cdef018f8211489faef569457772aa052bd684d1d92661c5ee00deb15c0cbcda835836d48363f7857953ed6b2b8fcb5c5b901902b4736dd272031ac3dcf3f1f5f4b931416a26e9fae1d403982b1a5d16681c90d464277a43dee724bd81c8596acb0ce9bb622f1a8b74d81c61fb526a1ba0321f52fb2476ee10473739d012c853a574f8212765679d0cda8f2a05ca48700513c7c24ce777bee6a62d7f99557af467d41c832ec90eaee2e3264a49866e69ec038021008b7e04b1ff89dd26a9ade14fd48d5491da8e0eafbf2eefde98fa93e0b23c2c1532beb4fec2671bcc6b19066fa8db111f95c0d0e9bce070e18cdcbc0bd46c5dc0d8e208fdde94e8773dc7e34b8f052051c8ceab52ea243bdd401dc04099cbd9a7328476118c33f8bde6222e407897c12b809fd3939e043c576db696939f84f2463781a4b76109f34d6c9d7cdd7975e7b74231aec8a79c53bc48c6f59c16bc3a4797b70b401638a5ee497b96515e3a9dcd4c496884642ddb5ebaf1527f94d6e76a9c4b51b4b4a2c72d8b01b0a3b0bcc633283ff1acb35b6e68b37e6471b84b4f13b6313bc004efaa73f759663809ec8d790c9ed2adceeca0741754ad44d5338bf7338d42b131a53b0d9ae7bc6cc122149da1c81fcd53f67e132b42e3008e95c61c828991f0004c520354753912f18a1218743b2fe5985bc785e4c8f4a546872228175ba9fd404153065a88cc5b8dff9a88e73c06c80557bfd630c71d5eef25f6c1b82db52a6f5257873376c6c953cc97ba757887c54b72b0daee8ff38e1b8269f656908c08db528e509e901cf12fa045716fbd756e6c886bcd652e27b9fbc248202f1ff91080a81a8a03441a1b963796974ccc7dc61370452b575478a3d1bff40db74585b7a283e87eae106b5558da5c0ad1674ccabb09f11b566ce79d85f53fac4ba39e575118da77c0fef450ae5ffd100e432b9fb1c83cade8d27f41b47bd65277ca11a149af3230a5372bd3e1ab30178b4372eff583b5ca4cccd5456f0696641847349ea9a2cb845cf88b7c954231c6cf357220668de1616a0e46c1d06d2f26c704fedf142cb513408d826c458e6da2b3f049228cab5e5826cf41245d9b206f9322fa764ef1bd21b35e4858e2ad4533198532c5df72dbda2378495ee77f55a9fcbf95034cdbcfcb2ffde8a99c8d4a2329ad02daf20ae211cedb961c815250d2ac419753950d2e0a6f30842c27509641c857cd2156d8699aae3043434318dc86c40d8c7896b0c0383ba4333820ea937d32ea66465d3b735f6356b3ae4318bd345e4c53cb1fdfdd5dedc787110e7281f06ac354de30859b0e3dcff04da49ccea6d2cb0f2e86255b895e4d4c12df46bd045d127ad0e2f3f07da67b360c8e40582a6bfb45e1c5f996a8b5707d11b7c8954aea6db3c932a7e9b59d54df9b148a8a7a32258a2ae1056be6cf9bf66828f19279f79f063eef251651371551a00df25b03b7b12a3d4cf7cef8fd884c0fb07d9cb216038b6e5b3158a004658dae6e018ae70376ec775675cc4de493d96f705df3bf75d5af7713142b2898be1dc529cba4fd5fd79399b2d09149a1dd9a919b9e0a859dc0b574ed3f66ac3e41e8d59d1724fead007115d19f9fbdab0cccbd54a3a00a3819805cf6c665dc498dcf5f3305fa44313d8bd73173fc54efe153899e54af9a846e55d03cc7b925be88cf4441d3b89298d72c2cee761c2a6ba2d00706a90a06c0d07df73e3ce0795ceccb80ecbd564aedd51370561da286acad76150bb7b23f3ac6a60553883f421835435e1df2faf5060e4896b77e501d602ae964b622f7540195c8e1e39edd2e2a840047a239c69f3dd46d299aff108c6de10e371c795177fc89f5ba2caffd8e40d3f9ac50111a8305790251c787616bbca23ea8c8a097e237c4a0a204a6b8b7ad99f68c13356be01d48cc218c10eed1a956245161ba8a1fb80794b3da295f04945b9d3250bf13e536cfa135ba83121cc3abd0ee93ef29d8c17be6cfad897016b7b3d46216ea04de000b979f653c4f662c1348c6b486a9649c3e75bca75ee9fc86275e707eee173fba1a381e9580f8517777bbfe90a6cb8e8c16cccc975ae8ab121a3c23d8231d35c707ac313e5a99c9bda6375b669f159f0bf9d75f4414e8a84521db6ffaeb7bb2fa2178613a5b8c1bd5bfa5f5cbab6de2f7e40abd836a3e6eb04fbd9204d64719ee47777c9ccd59608d773c79fbc812b2631aef734f9105e73f123e0d3b92a1f2e895df973dd331c7732ee93df894f03bf2294fd21fb02dd3bff13a6d371931e9dc3bef059939c1b624719207e78d921cba6c2dc8a8e54b537a1345616be5d071de52d3334325bbb2e357235aca6a897e7b2c40b8f0f8afbc24432bd206269bcb007959addde85e111e4a495d689d2c6dfd983ba236515715896a62e03c3bfba0fbed754fdad17fa3297581892c1fbb96ee8c080c7383a65e1c51c5f738cd6d927c96d25ef1b609cb6a4016d5fcc399c41797bb2efa12af84165c74d4cc34492212cf43669e36bec224f9019df9a3dc71ac3c7ed18a733681b0a8aa34e3b030fdb1141514dee0b4a98a71db02c9d53c31ab294f3f305f62a87317320055f3474bb018fba077798e837a48eba6c85e10f6d7c5dbce35519a990173437af037ee62703f09417d4842ac27391f5517d54515cc067943e47e99033fff2807f04246e978aec871b78dd143c493a7fa468a9471e0bf5aa8f35461f93b2be276ac45b2833a249fdf2fd29b9b8fd44d8837be6df7845921c4c9cdd553523eb705fce3d987593bd284021a4e5f3cb5e195eaa4abf346205b4d1c5a80f3f50a331b39bb84929baa700178da9e628ee627f8284eb90c4ae6e201b1f66875b65b7539b4bf1167f6ca52c690735291cddc27b2f86e96a448e575cfc13a56463530d00b0cac84240ed4225019a00d5afea19665a3d48f52ec47d31a4cdd3bed4fb0e714404d46bb0b3ff595ba655d4610b17b3ed1a1738e12c3ee18b5bf6ef6e0ad472d208b1aa9ff78c883228af001141eadc51d6c8270488031b883695ced4e0a6b33f29408c8ea2a89668e798515e1a5e4c89b2f9e69c9245444db8b6ff3cfacb7eff26141148f75fedeea6ac73c44045927e56e91937536992ebaf076a9ceace1f82abbf1d6d6395cc8a94b017ad6bbe71703b4368a5218d0d237d6e0e264eb3aeab2a3c43625998bc9f14e354a4761ad3b37b473ed426cf8c36803b59789f0c2f0ae2c84103e85dcc28d9c103154b0082bc885572ee8a40538495a677608ae32f76b7d5c87dacb1c0d4b679b204f711f7bb250487537b730a3973e69cb07b558b748c9f91c18c185a43e5ee29a81c10817479a95ca3924dba752110bb67034c7641ac9ec0cc4ba0773135136e2af5ee166fef18892468d7f46bcbe64cd58842f3de0c2d3db8bb540047654c64864a02718c8f116ee4f85cae8ec4a986ccfe8d72cb36b61e2a49fed53ff94badd2cb740294ee97e2b30f57b89995465b0ca896677e695a35712895082e3f6bbf20423811f067f37025827e19c24191e98cb1f9bf4ea03b25bc39f7de317b25cd762651d386e51973670acf41b4afd5ab5f24f5a9e21814577b6365c93c4519688b2d438ee1c6620c636c92eeb9e8e8eda8f095ad1a7fe0d0eb6a6a5ffcb38ca4e32fedd051315b195b4df63866066441b1875a6e2dfef5f0c6db435126c296f720e58b3725615a2b7b3fbdb94351d1856dbdd35a605867d89d05530d5c3c3a5a304b3ce3bfb56edf19bab8c1ef538823c74d04b79783e0366114a538553f8dbb642a2163d2461790f7f31a3495fc70ac3fa7266c838788353fffa179fd2f61e0696e840061edda1f4c9a638243393398329468fffaf44c437201b909d3b8e4df1affce8da7ee87461ad6adaded8f8c06f6dd9036042895b86188239a4a0e48ce4a798d568955ba76c479e28894070b1833eb74954c8d6d5d516e4242bb62f959ce6fc2ea2f91db56f1b1324fd54d7fe88d381e841376691b2d03a988e6ef1f4fdf79684c2405e7ec5888ae5849b4a626f92afc92f93b0ae2a341dbecd9084f73b9d9011ac2b7f2bb26c735759aa05316cafe11db737ac681e5800f8af46a782bcfe56bf00353278dfff05c7a6675ef3395a92adfb7e4d088f42cfa2da63b6b4cfd2c6a437d82cd38250ddd6e26e684cf0bd79fb5dfa9db4b9d2ca38f7d98c6d6168e47d4faf56cfacedaff35f117ec8bde44e28285b916a7523e346ec034dd97a61aa460e9b8dc78ebca837f4265204276f77a162fa9e103234144f69a6d674c6b1004be243d349b5041d7c743589d835e86dd0c5b0903feead307524f64da5e32d32b7e4a558a7da611fe336bae405158779c336fe2a7d404f598850c689c277557c077a7a95f0fe86228530a52251599cdb485365ee299a48bfed3679c44bd43ceb180132921523d8e65165079a642353a2e6f6c19d63d28d6680596a028fd0d857660666f0ac95faa2799bc235daadea7cee8f2c2856b7dfec6612dfcc7d5963cbae46e30eb4f30457a80cdf8503488df8beed297e0703eab77beca2add99c013060c064c65551e9933f49b6f949514295de3762a11a52e897dfe201756d2f3447ab34a88872a1df9b3516a99946dcd6b577a79e36c9502786645716bc99212b98b1ca4e656063bb6d5bbec7e1a651a326f56d05d9bea7b2219b4084b3c2ef988a355d1883966c87679e41bef22a9d137a814165bd14816b0e7aa5f0cbe3bcdbf6f4c573b8f59f10e41b4341e066ac7bcd578cc3012359e86d2356ac71b73fe6f5e9c2330f4a43bc19abd3f0562f46eb58f7c0191f5625b6c0b350c874e2cab1e1f300fc60571636c5a5093de9e4cb245d7db4b909a51d6bff7d27d6d5b72c0c3611d4db7dffaa7c2a89830765bed543bbc58f741bc32200a60ef37f6202061e7eef13ed16d604538763179485f2e0f75b16ced443d2bc7ea4b76af5f0f6ff970c42f455a50948b1dc13028355549a10a67bd06eab56af01d552be0932c00325b51b5064166ee91d66ae76d0be1bf30ef4f2e3d920fc43328ae85d20fd78d0d8d29f3bb310059f447dc79b086534496c4548ddfaf3dd682ce80740230fa44f098593090fc525893105c16a344e92e52bf50131d9135fd8c6b57b33d4b88d26f6d8692e7893cb977cc26883dc5ea67644a712244abdbeb2f9c166dfe17c67d481b0f43a4dfcd7228167e96f1e080c466550a038eafa2f43a9d55c189d927259071a0816addfb26ef9c43423e1d81de571d2b3b7b1f1c91b5d33e0c1c340093a1f0a3fd860bb6a99f53ad197afb45003944d685a94938fa2ba2b33e7816a82b827736c0f1a17dac0dbf1bd0e7b3fbcba24b94f0c6470f4ef5c0dd0601c39e6329481e9b5d52367d8a69396385d41d1056cb502d06b77d422b1e7f050589b79609933ba262965e20f87dccf071270243886ef7f94a721ca8ab92a47b2687ae3a634f74d4ea99ff10c470985cd5d8c6b10292c40f0f82f09ea9bfa1ed5bad58395edde4fcba1dd1e286b1863f25a939f340cf726b22176f439cd2f1ac7528ab2b40f3957bd0826222a035f7f8eacf0d5cc9c5d27d8fc973030e4c5ae314c9b4e31bb60b86422564bc0647f75ff32d54df4874b2031bda1390183949acb4cc027d382596b44d3ca6fb5d4f6927324d2adcdaed2215a841815dedb4d9d411e1e03952b4260282a56b79434eaef92d7f045a676f0763171eacfc0f6d695fe53d9e353f364fdbed33df3d395bd8de7478908cf43b8556ae607c54d76a71534f8e1128a2fe329167a1f1c1f9d5644e9374186195f2bbde972846607246b79bf9326d8ef55fdfa0516504a91f196640f197327b998e002e1ac9c8100d73fd151b281b4d6627f66a66339ccfef7a18d1d1d220ec55eed0403e5f628a9d21308974fc1d4345c9cce3bff6ba505d4008f2c4b99c32b6ad75f5fcc9cf8e6af6f0adf6c352d3641a6cecc121cc63d65479f1497afba2ee2f3372263f84323ecbd20fcbafdedef64405a62782b650bb232b479b4155075546206b46a2caa5a846289e5cf8c6e507be6019865308767483095cfc32819223eef017358e0fb9142454d3a6871a0d143e430cbad8ae5050819d3ec9ac20da136bd3b69be3cf22edd4d0c9528bd4d2b2e02c42692cf29d0b5e47d4e73686cb6a1504eca7c84ae70a8d91104c0bc2a2beea406a68e299ddfc58194fea2776d9eaa62a7f6a257efff57516470ff9617b8211858394673c5f9a26c6e18afe87f312b3464f6bd5d6479c147d1972e9a03749aa4003284a306bbeba98abb419fbad5928a5858c2fe88589e04d2fe6553cf75277060ab289c5d8c588d5211bd3a1b8812be937394b291a9b8b649cd849e4a7a3aa927e25e83360780ca0b53034a19e6cb021172ea1949d8704dc3ced21fcc8c26ef372e6d695ac316d8817c3ecfbf158000abe41f75ddfac9536dc5e18914bc5e53def5649e15e185da50e56bd33f6f69c3643ee743ec4739df7f373af36549590af6d538b19bb48f936c8c4330451a14c101b27f10a1aab36d334003d4a6a20fc820739d4d9d91a44aa824fcdc0da86062be26d84e8904cb2a67321c6ecb9c2e4bb60ddc4c408e6f4bb516d0dfa49e02275f69d9a8fd21c656b124b41a58c653d95e04f617403a3eec745ce88127c6aad41507a55e2dd8b11d0114ebf484b4b6272040e67703ac357e8e31624f9be56b9c70c1124274914266b6b06ebeb12b9d777347e453e52f94bce5fe702e0e349b1024b7817bebd0bbe71ab38f3412f115677c81a24705f1bc91a9a1314f3abf31b976731927b20df4ec31c2655a9f56d62d1ae714fa97df9a057216291f964bd89aa2b9ff0ced145d33046daa5529f2454b6f0f7757d92c291bf8ac52a98f472f068702d847b1e718748efb749e7c9bdf90eb347e852877ea117737c26a77967abe0377a34ef14a03566838767d6c0c1b889eed7527c96607f281c19da2501889c5a4275c9372be7a333a68d5fe68bb6f7f6ac0e4f666f858f645fa0798bc29885370c574d1ce778b0883fcc1b035633eaccb6db0f0a89a3e514849171eab0b7901a961edbe025bf9f8a50604413183715e88910ef8b3c99b56e3f69713e2b87d1519d279d7abcda829ef36ca39ccbb11d6484282d08e344a24e68468771b9b48a4d8f6f484f6609aed553327a05cb32b0802ff43e8a83e2f4bec9e723fab477db06d101f3cdbbac37140a7c37f4fae7f3f8da491d8c09eba1f463e1ce0fe9f498749027a97b6023369df4efe35908f6f1d69212a33561f1cbdd171a1d607afe4fbce6c63365280d2cde2b629bdf3c03218538af11b693c997f2e929345354f4b693ad050984c91612fdcd61e48d6b54679bc00d158c010c015f5af6c5af0ddc6292ef080d5168b2d4e0e65914a093246dcb93b5c99fadf6b2e008a5f9b3ceb2f0853c310caaeee29b28904dc3c9de55dac49b7a40ff63bc4d0b116db613a3e6079515f00ed0e45e46fcbab3df2ad526c980e1cd63eac85b9f93d083a0b76bd9303c776dff7b51aa768efdfe9f45fed1dc5a97a528aa4e6f4f9c7bf6c32f3fc6fa92ab3cd6cbb6974427b7ecd724fa37508f5577d5a937e5b2761fdfff91d2d945b48db4444cc85f11f79a948ffec8e483416705bcb09aacc523c9f2d91e843933bd379406019fc5a2c43c9e884787913642724c34ae8ff67295a5ee3221c3ee5968c4e51a46f459bc11fd9d6b9309114f9bc170c8f3eb05ac793d087f731d261145a874cce129110599bdc512b6cdceb557761009b8b737aaf1bea97b0742bbc8a9d2ecda1273963cffd09127f714930f9a8deb9c9e4708caf6182bfa3a4e4f813f935530f83407a7157d2f0f97facc98800bc08727f022ba2869ab0a8c1254dff331d52b3456b10aa6c8bca57b77567bf4620d73c47f12eac7680446f6f033c0421bfbd37e4c111a9274432eebbe41dfc87b8384d0d3aa1d8515c7b189f4fd88577582820e83142958dd08ea99aa9223a5b2ede9ef5b8e9be7b1c3bccb271b7665a4b2ba266c9734ac1220f83045178e0c7be5140cf807476e252e9a6c671af49bac5ddfd9d226aa1ca259507584d38257a5f64a3df897797bc4a51ca274bea3a284b96715ff6ef19bfdc3d640e73987ab9c1f73f0718231f7f99531f071b468e3ffc989aa8f7bb3065de9f1e78cb38fc9b60e92ecce59a8232e036f193f21a0c5afae704b4c4ac9c9b97a17ae9e123d0482634533846c6881ab74e2b2b3c6ac00b1f55d453017370f4427442fb25b14a3f36c0d1e0525b29ab2cc813dc48ab72a0432e540c01430fbccafda29f94a655fb5dea7335ce95400e91f34800c216766fd3abb1163554bf67d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
