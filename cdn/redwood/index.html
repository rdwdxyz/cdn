<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f58e281d8494ee6fe5e67bd42b3bf68f1d39ac40123cd26c7398d94963db13e369a01a3b14e1d659f9992ee0e475bf3eef5591d678f97b606ab8a7ede6981c961803f2ce13fbacc4d8695dac5944f2de10fa12a2a46e405416f8fcfdb4a560515bec55554e1fc56e29f00988bd2220805f4e055b460e0e51895cab78f39985fcb9cb75bf7c0d96e8c480753203ba5a2f49d9f0211b9f2cf6d48e8c4fd0e5ef2643706e21f03a50823defa56e5e6d20e1e92e82bb15fc719eee8ddb1d5510d61f158bbb591deb34bb7cb28b24c9e1cef55632c4b6e81141464c6df315dabcd488bd7cc6a6bc30b86bbe189d1a8d588e9dce04837c51fbb115be8f7e23709c5b43ad3b4f4f3ea0a7a889120f1a4334e87e800f0ec4ff3f4f81be47cba9f9b0be9186111fb83318024c834153c27343ea66e3685382e2f443d0207169d6e69a361aab62e666c99faff01edc8bce3d060db6e7eaa18cfb7274cc9f003a80a5f0c94cc83284c72188db7abd01739c0f1c23e30660ff8cd64fc0126b65297436ca878b966b3e66cdcecabea8713aaebf702f5094457d9bc6a5f6739014bdcb9a2d0f785c361cbd9a38bf8d7dcbdbc09616888ead3c9dfab6599631049c89f4b6bd6aa2601b0258d878bd16da47e6e886bc29ac0a95808d55bcba1bc9948d27372a1609d7c6883355f87686bd108cc1cb26d5aad5bd95ff15c4f66ebb383e09a8d7d82f3a69b9784ffe2caacccfab77ee7ebfe7d7ecca4e22c232aaef0ad928d465f68d965626246083aa9d299eb2f665ae07687db35a5f5e99e764f0068714b35558dcbb3b2e9895b4337610f9cae9a034c77f3b83ed438dd07f5a80ba0faa80f36df0bca67a5519d5f7a90c6a9b16d0c56ecc70da79f38f76d0a12af3b61219792af50ce90ee22d80c7f6e0a24128ad9b4e3c929df3ec1271b76324649db84c25df5fcb225abe2d7c5fab02d6f4924d4ed526c0c53373701aaf40ae45e3efd18838f9bbf55adb27911e5f778b5eb68e7fae940a9c02eea28086f56b68d09b3294cc6978b6824a8c2d7f8f23354bae908ba76a69f9f709f695db5881937f0fe8d67a3ff7d562adc4111bc54be3e917065af1afae2089d8f59d970ff8dd2a73a0740f487be81117cb205b1a00bc58d4419ee15e233c5a4ef75a65ba19a6ac9b1bd231eaeadf1f344301c1d6c0a26de218d0ccba53a34b7d53f40bc97b2108b8be11d6da52cbfcc5968dc8119e8ade98ad1b6ffaec4dc522869127e4a0b5cc7f1245df2548e6f237ff2e395feb33500a5f1a52b1d400ecd4ccc968cebf4e0209f43fca029c93ee3d2d791375f0c4bef2abe222a429859a0e16755c3f014b5bf47449b016a3ee9c9cbf927f3abac225d5de97d76595698f77ae8c3fafbd04071cb950a134f3c1abcf80aa995af0560b716bd2c810119f4d3a009a09cbc3afb55465dd4b5ef02bc3a98789da5aaa1c273d3d235b320e06cb2f928a819d26630ea67e89044a74357a365295fdfb2451882021294123c6641ecd7f6267ba850badb5877a5e55cbe19faff4b388287352d42ef7627d9a495699dad24eb26c310c5222c58c0334dca4b05dea96ebcf2601f11b092b1fc6d37abc8ab0b18240baaa9321c4bfd6c38297dbefdb12fa76969af5e613f93eab4123246bb20125c4d553ff35d07bf73c280e1ece73b25d48c04c30e87ea3a664a36420268d036813082cfbdea107e6ba8f4fd81fbb0d74d52bde0beb8ec2347b920c9a671eb421afa96a27da858a7c8d65addfd6187b7662befb271f8172e7e575a59fff37c5d5152f4ff9619d6304a3f6df0899d3e9250f5ca4b6eadd524fe5272b862f47164edb3c8ea08ef186911bbcc6ec0ce8db70ece15a14c4aedc512a3e2cf046e90d5cc6b8b823ad9a80d1bd68c52b36eddfb712fa5fdce27cd6403f4b91d3e984e36ddfdacc256f03984cea549859e2b5a01dc9c147fc020ae4e3ada6a3336bfe04f067f5326950a5eff028b5c5b32ad897e9c282b8e14c38550e5ef95a135a98e36dba206d51290ad6d2ed01e60f5f2bb9857846e5fc7b13bd810d120d51774f11e3d1d9976710c037550e66f189ae537df374bbaf4e0c42dcaa169c7cc093e403b56375aa77bf2b7061a31792c02822f7fa8d202a299706164f79568b0cf0edc9b9f7b34b106096d0aba653d62c25be125c52730214f2447c36806a85ba570c43d8e4a66399d3d1ec38eddc6f9170ded0f9492b436482c16c08ce3b71f08f98e9a29ef72c60f1b0c3111b96126bfce241b1e63a7eb04e33accfc77a697c58ae9791bd012bff828db27ece957f755ead033bcd4a56d63a49bfe07c980f649776d1f0d26557f7b409517648c4da2f328927632cd3879f886faad44a5353af8d8416e186e77fa14a6f6c71900f2d994d5081821b28f88827b32fc88826fced961b10688f6083e826f783fcd421277cc241434667c86a4845e3d4e690f2b72c9b28026d5c64092be44e741ef01e0284b0b649950100a0d44361fb6f64376bd3400dda89706cf4941ba4132154d8c5418ca1ed77432e8b4100c95ea1521c81b7b6a3336291f30d3f4357fa387817af97aeec5604b96b31687d6178d4c2cf1ad3fa3a114ebc80f9b5e69d5616fce052640fb54b984e2798a95217652a2e3725cf88c51c9fd6f50e6102765d6d749b37a43bfbfe8f9c16217c68e2c5b95277680f571afa5aec12c1d01b4e1a9c5d0c967f5af28267780bf4954b1c5d55707a64a8b2b4908a7726c8788cb5b479aae6d816da66c0b701bebb6c725fb4a616ec511207b8cf26cabdb3265688a8238b6adc64cabef76ef16a5dc9fd40f353fa28023fc1b78d6c79844c5d2ebf23a6f622a9c0f3a302d2e46d1fba72bd2ba28d826c7a0980fa91c0e061ed48da0218bc454df6e90353d3b3973bf1375a9b9c6781a7ee6459b1ca9ace84678c07b8f65fcd10001bb1b57f1cd5c5b58af4a52b91da9d6bbbd6b6400fcf7a11f5ac6f2f93450c1bd3a7943846d36cc56ca6a2b10857762da3ab2471f6e8ae5ad55307cd35af7c516c192e6abfd2ae8b9eb05a1a798fd8a42ca8ce2c8c9370c8b5b4c6109ce8186744b16d225c92086416e6f920345beaaf3de6ddf7e634b826eedde5f5598ecb3caf3fdf384a97fbe1331cfe023090b34eaf6b2853e80487686b54f0a027ed67e2425435f2a24b178e0e5472d7bd2abad421fd68d99be31aa4679983bd90599bef85ad003d054d5d696be30bc289787bcbfb99b63f70f98db380a4c6578408edccc26721c7eaa6e86542ea67881ddfe930a47ed8a67d74e4b42e9da90e4935d499521a2c7ad0a911c6249067282de948d2a4e2428d5a1dc22e8f291f95217df48324da5285a66ad858febafc3d8cd0aa3fac0527b48929fb3e6fef9f4067c8ecb17e51e1e9a7e31bcbca8a27c71332b7c34c9c071f4d266876b384dde79a1dc9a2cea92f4f2c06227592648a560379e5dcc44a65c42171944bca43b14b91d37c6d005c4b9a79956eb4269834e328911af8fa20dc8869757f13e7e459e7c3ad064bbf3ea14eca3a3d012d9df1a1de1ce637d675592e1aac24d865326f4d20442bf1e1f76daef6283797aed8039da759ab8edf36664be85ee25a43ecda53a2329fcf9e80a5285be3249a296315e6599b09a40862859ec8fe926cc8a73d93916ecdf4906afb09f43d536d7034d4db5a040a57ba10971198d16feca4fc502be2087aa69f782f09ef71b2f832bfbae1285cf9ef478d1a8ecf3259268908f6635cea91900cf33b818fedb2b023465ee5b20c62d49f8b0500a51f6aff1aa301cfffd852721efb41877863cf1a70c6d77994290767dd40430ae572b4c7df2356c067bb5c734365ba9516cb9fd093d50de593746b91c1d5ae52535159fb5d7c4d7cb4006d5e22e9d839d2f8fb683c1fd7a5783d3338820d131151f9aedaeaf4f323bb8f282d177b9c97abeb30bc0c64987e4d4a931196e666b0a21bc78da5c0d195ebcc281cd9aa4c26006c3d74cfdb787842ef10db7ceeb105fb778d2549a99b9f18471d861907f33ad69054a28dd42a4a31d4a20e95afa4f6f9de38cf7b173577d0c7ec7456f53d89ce0b6f0c78d32d4fc4df8871932d4b7d379f21d3bf92452c8dd64da648920146d32a58495228a4bbd8c651177e7658df776aa4deb375e61f2b062e340b7b12b89f19701403e0e2ac71ecea571ebe24783052b0148b11a22573c6f6b60ac63ec9254fd13732b45d15c6a46e91257084f6b201b7d610de2f2ba784fd11aa8703317f5ce3c8cbb2e00d71ea5ebf2d3136f245d1f98375d9d08db5ade6776356d9669971f0d0506edfbe363c4fada5de83f688b97d18c58773f6d54d67c3b12c57133d70599572e0a56a5ef1d0611ccd3e1dcb46dffdb382e4a263cb78dd2d11a8e7968d1b2b0fa7466a5cb42ddc389c971dd76cff4c89ee8211ba462c109c10e26a7e1102b56b6dcd1ff58042bfa234355e8e253a008c173c30815c6854f5ef4a970cc525e4482657592c8a143c71b2a4ea001e3a45ff007807485efaee6ed9faccf8e1692120928ea52976e9d9b036eb04aad19f899c8c175e84e751054e70e8fb43f6d3169b40e4afad50c131cc7f4a7865f6bffb2466a75762a65e838252586b478843ea63cc6fe03d885eda9a3fdc51a328d4038d6f27c25d526886a9f8b221377c8d73b3c323264172a4d51e9688467d3d691b5fa4c7dd6fe2b84c58a34cc0cf0015d3445d97f9ccfc455aeb8715ee96f896354d97dcdfd5da8141c82b2211cc4df048117a6965c56b3bcf94647a3957472dbf8e28b68f56fe731e736d52b47d48586c29bcfe6e52539a86868cec483bbdf33f24270c092eb70552aca27a3a8eb299af42f5f9d972fc71695dd0250e240090f4c486c507687133e4e5eaedd946470e83c79ac824cce381f22cebab8a0203bfd679630685202b5a45e7de5d5f996fe4931d39ff05d4ec72c5cbffb9f365239960c2884f236c63c77f880ef3067cbbc5057f44f1eb77e0df616b39f49bc03bdd4bbf7148bff8b67d33f332b217aeae33a4fe779121f9d72dc95e274cd630bab8dab9004177be319c1c40dbceb4a7dffb2a2131c7f4e39dc67f2571ba8492bb930cbd415ea57402a6c487dd6d923f5c12350dffa7e82e44faa4d43ff54b8630b59d9a955bf610bf0420f996b9d22958203d4f53e162a32232d9dafae3522600196a68a0b51a9f90a450a54c762397b2d2f8caa66f665d3af6c0f9145e664fc7570ab3257bf348a8729bc8b15f466534f7870fe1ae17ef17648db6e29713f2afe1502b5a75b8a1ee1b4dc4a49b79d28ef1060bb4bed4f9240a0dc8a576d28cf4323ede0bac41c843e6b90ac33ad7670ea96254bdedaca22368d719ea3635ad06f55385415d42a6b8cdde8ff37b1f5b8e9ae113ce12430dd93dc1e64f4ebb68ae8213243681474b924970abb3c030fe1581b62e4fc01607b9241cd5f1bb12c672bb60e17a7c75ba8af8033b0f138f57069b7028d74bdee378758249f1d80c10ae4176fb60754695fd670bfeed4f6eb8e604d770b7b984efb3b616907d82e96991b00a297686a55b41c6eb2651515334d566a061c40210c82cea307e0748dd04b95b42b15fc2a6f9db7ee3fec50ea321a1040ebada9488cd8ec65858f1ba956c51d80b6493c524d0bcf247a66971a4d5e78c58ed520f3364ac0883964e7af3f41df684025e325e91ebd7a7309c382136d94ba34c4199b349616564d41d039a368be87d3b02924acec13bc204cbd366d0599730563ec549a5b06bb3f231af7366752eb9e023a892b2ed1250484d17612f304a52a9878de22948d9ef9623f0de641202d2cb1d118f564c2e0c593a0b73246eff4a7d377e165898af525b23cf0c96ff9fb98fb5f0f80d93c14f420a5c3a912606e3677c6c7a3b4e21047ed49436a0c69c143ae411346bc37772d791dbdcbbc24fa52a736a2840897fb679ffb8db850f5a8ff6ae36c0ebb1202037ce88560ad3f78f71b873705d643f2075f4b7843ee1c1c8a9cc5e45e715014e4836cdf412099a56726f8eba55fef9fe1ca32e9b9a09aa9afc5229ae7c38256b5a38cc2bec0770183963cfe270a2dff554e8f5b41ea0953376de78aec4b7dfc505e27d40731103780d8696743870da2e6d1582e01d8300bd02083f553e96b9acb6f1aa6b8850dcda2feb3e4881e34dba706eec89753e1f77cceac11605e6115f2fc90f0a62fa42727c34eb9075bcbf6da98ef9a9dc9e01d3270c2572a2f0d8ac873105317bc49c4d0d22a87cbf8e41cda2ae5440b57e896b739537c346ae09d1e496dd663ebb60bcd9c496de7cf55a68ac47e614457bfb829e7e8e578e78e5ddcb13e50b169ce0ae81ef6d97962fe0d7044211232620c1deab3ad2e588bbf30d10cb5d2dafd0f19aa95a5fb9986728ef23df3db277aaebcf33d87f9530e6e3362e3a8a60f2bf7b59e2d5d99453d3805157535ec3b2607c69d38748dc0b906b03f6de98005dffd1abeedd978544897c8184957428f4612ef0e80b809f7696fe35fe6322924d7b63a07d23f6adb3848ba367fe367272ebefede523130a60e100543bf08ffa93180d18f1c9e7c0ecaedfa7331f1a6ca9a9f54f8610cb9b20a44979a149ffd4788f2c5f2368b5e149c355b7e454674536e8227671f665db085a59b0d4eb9c87ddb280a4a553dca0b14a96f03f2da49e4d031c771bcfa1bcbad1024c72329daefcf6d82424274161b47b2b071eddd5749110e0b51b630a4c1b1e9c564d229c07e542b56bf3ed06f00d9048a40ca81428a98435c83f727464ab6cf1aaa6db2f02c37866f4027cb4018ed7405bfcf3db052ef44954e9a452b6bf733ae0fd8405fb882b5229d8b6160d35fda463c45292bdf2c497e2d4645a1b5360b2dde0a0bfe516db2c5ecce8c029736b8df933c63b26e91502b274a16bb6e33dac4a40a0c0b903430f864c775bdad5f749425339a586322c5fbf20973852965a9683655767025ecb19a8d504e621e5908ee178b58c58c4b0a7b4a340927831a62bc83cc72a4e08bf5c6ca74ec061b75186ebdd13d96f7df51b5de3b1cdfb9e4178965c3ee5c5fb0a5c911b31754501a1a1c3d6cf42d6b5a43ab7d91e1e567ba323e67f20da794382f97a5dcc85e761c673e7c6ff8fb3c8befbc4ef2d4c3fcba2e68371954779b2856fbab2cdcefa802fb51819915779e845b1fa420874311082a5e27d483d91652df1771222d657703eab221e697347a506f8b17ab7ecd4dd4fa646573d0af4ad1c349f06ea4982fd25ce87f2fb13c0131ed339422a7e9921555c663aa20956c6f0d97ed5b6ecdf1ed2d71f2c4b4c78dd1fa3cbd75e86aa7d9168490f61687640ff569cdbb67570a10518883e6623b8d78aed81ebf385dc5abe768e20ddc222d2f7bd71d3827f05bdf2266f3527cbca22de394fa2c23ae5cfa670a0fa4bb7eb6a1ff3e46efe501f74d4ab371a829ff5a97baeb2036388fa8ee2a603ec26c7ea74b2d173bff1e12d335115a83ac1efd09c93e03727ce735536e55c1e20b351f31360ce9a9bd3807980f3a71b6817d3fc82a05619275e87b52cbc0a5e82e7d21f51712e48124a729bd56bba510fe5b7e478a15d1f19816d852efe38d8dbe3bc87970485efe0ed9dd5ca81e71bcfa3a491923f7b7976c2d34ea8072fe9020132d7cf90c53f35806f744738aaf001552d8377ee18dcd3050ca16fb52beca5f4747ed19f576463c03afea61635d97f47161bd87f4abf3703cf69e3f78c36b2616f0f9f7867f396c039403fa109ce8bdb0222e1c04657017aa44ac1054709188c4732f5dc92731d5a96e78b90ce69996aaf1596c64b0be628c6882c6d01165c411390848fe1354d72f79857272d9abcffbc0b6e0221774b3befd19ef7c69b71e03af2648a6da625e706d8e88defd46fc971a214219ebb271bcc4548ce394b1dc46835d8e4b5dd7a0667f5d87cf35dafff31ea3fd964f3a107e94571429089183ece7e893c21444a957f757c59b80020f741de7fa4b5348672eb663e7eebc2693c2ed161a7a80c1ca8544fe6a12fe6628e2c91655f64225af2f915c4b688d921382ddc7dd93e04e277d2d14a2f4aa4ef339d734ce453a8ecfd83776bc2e0f0b1c7254134117f0a18b8173ddb57d960bbfb76d49cc429b86c32cb5c3f5b2792daf1ae89fc7cddbeb1b8c226cd01b76057cb22be030bc30178489611789632eef79c5398a9c9db435692793e008e7c334589c54d2a000c7cbabdfdaaa0418c6907aa163c04650587573a5948c16499fd6bcf145b82f2880a249592cf8d43ab24d12f605100403fac174898632f3c5e437670239be42eb51226cf46ce90e17d5e97012f2dfb0ab1e163a90b4f8549676df92f571ee9337c1ad2de097b558b63f9b7c786e113b9f3e795ec520b8aec63a3ab88b7cdf1327c3b401303f3ff16b932c08d9af6e335cc3b2ff0a8eb153aa9669e57fe544ecbf3ede2f49a646249f928faf122fc6c3e2528a76df1ea475cf63ab6fc91eb46553fe2e8dc660d3f279453a62ae98f966415a365eb98e7469718d0934aa76159c450301aa04efffca3000bff746f54eb0f36cfc314513c75b5e81217fadcdaad57d51e979c6518f997f53bdfae6c7d39b3952a790ba73b7abcfe1b8898c2a26dba537ce7793edd7d63a2ef0919af005c6e0a676194397b848f120601fb43e3ae4543765219890d33f4338ac30de3fbbfc286ea8c965c76f671f8405d812938fbe54b3f0bff9a7dc523e8f66b189a8d7b83b033ea1bf7dd9c2fbcd458a617f25c4731135b14925176aef9d2fa16a23d851d92fef8dfb9aa4a564e8877b73715530aca7dfc81fa345a24342e1444decd77b923e95f9407e137667e2f75c2384d5f341da0e67f00f1ef19567af2bbe152aeeb9bfee06e8a5683921e97c9e078a4153c9de1c717ebbe5645bbd4608a89ec35a1f9d84e87b6211654a1b590b5508dca0c3c600eab6d4e3946ee52de16ae3ba7fbc8f070d6f696f03fe6728161417bf8c4b8ac9f59a2b3923c5c545bfbb7bbdde5026f7603b2869f107b07a8a1df8f76f1f1e5f9b72a3737c0230e6ca757735eace2fd342e7df6010f57387853e79d5e8669fe94921f7568617f97eb18eeaac16573d406fa68a7f2a02d8e28fdf2bd22dbfd77dffccb606456ad5d6b5293e7b9b0c7c8e7a12daf09c151c25c18064a89535a3b67f95469d78209b52e07dba32561394ecaa0c84fc70890f24c176727174a7fa3419d252d296fde27bd2cfbe45a9b52046ddd48d2de8b8bb29b4443ce76e126e73367279dc1334519a2d97e077deecc18c5c93e4378748043a74305baaaa68a790ad8f14a17ab3cb44ada7700f496d7b6128554fbc4e1a346cbf2470e5bf985895f2b43a72c97df3ec7214afec01794060b53e23115dcf9a90a145cab04823e4637347a7d31eceebf880041b0804402574d5178debdd993d2357edf8da7a73f15a2c9f4b675cd1f2dd0b8f3ab9e2e9954af4047ec3df4ab90a707e3e2e6706e0c6a3efa8dc3ef0b488b46b44f3dd3754947c0d71905deb74ecfc185da09b164a493ef307d405bb7350336908faf99f8bfaae83d7fe47074835744159f86438b99db87094026a6cdc38f2e5910bb11c13e838d39703ef0e2dd97998f8a4ec333bdb3cbd0e2d7a99f31d68965aff448b527077369c8686484e1bc8866ab69df766cea7f79d73b8f5be334a3801ccd93c58297986683d5d9c4d33ff69d87cbf64269f7b266298cff35553775b90777fe5833fb3543309e4065f59452d5d8c62aee072f8e8cc5f0efa9d562e7cb9295543037ac60e6163e114620fc7125f1843e2d7c30b0aabdad9f2a1c697fd2cc0712c67de69cd8339757c5fc288aef8b3a259c21e141f10730399c94b7590a523f52c966af82bc774b57cc0ddfe3cc80bc1634247b3395798ab97bbafa443362473d0e1e0f8925795e81ef159dee6cd4bed15bc8bc5bf8c19bfd2ea41eb88e63cf033bce66d1193b6ebebad93b60a0a78c695b8824833d5569e6fa1f5155b8ba6b79ffb3a4999fbda84e73061f4197d68c8089e422599dac190c8c780a270e078df94a4cdb125e7d45e58848552ac17f8c2cc92b6bec23b491af166b5f3a8a5aba09bd5aa660a0c5e79c39f30c72c0277165307e8f6412b799d4d01fd0dbdabbca6400a0fa9cd398ec629f51321198689ee8a7ef6aafd6e1c91a624c5d34268b21dfc65c989a13cf66f622af5d2fecc26d548c980dcf00a2c7a0252c122702a16c22de27d64a342417997cdb1fa7b7a1c559119b886f6c576a8195dd383c391b7cbee6694f00aa48d7d62d58c4dea7f163bfd827649b269d75d9f69aee5c8e56228bd021395fe6f630d378e30608e2445bb75ed969a9e82a5f7110a7d2ff3da43674047e2571a1a70fbb31117d939f11c5d3e6c3b7207faed1dcefddc7a0570e8c4ed6af46a061a12ebc33eae629697f15e563a0b6d3a774d4d302efbf8a03ebf45f0000f7a6a9aa76e21b9ad17d9099219d3c89fef5c935fe7d7b9131f2f363695c8db56fddd85cc29e15202a5abdadd749ede8dd78aa6c20451851df9755aec487ee0b10161388b1fc63103656d13f7638bf955e420d88dc9a8f6622488e70894db7e867256b712f922a944587038cc506e63b838628521281848b83c26b0bc20f1b08b8dc6119c9ec5f48f8239d4e5a23e46559e6fbcf7e9d4cf811a4e6dc661df619ec3e00dedbef497a6e0e8d7e3acc27f2b09d99074b9bbeaf244a38b3ce5b12155b0783caaf686db701c3ede7eae0ed2d04d452a26468fb62a991c63a2344e91ed644048df45eda5dde382ff72642084699a315ba06bfa5ec2797c8adb27178d3b678f7057e8a08afee3422a9947914b4b92cf286f1d965309b6eafd7e72be38f3f099184899fbe7a5b763a8e5bb4b8ce483a85e60559972201639502005c28abfa418c6f72be4efb07ba74c9c7fcc0b35d5bb224e33228d0204a75b578c90b67078449325f5b89aa1fd2402d18aca650a6bb65c0f9322daa28aa678301b157fc6a3fc73efc857aa70de2386eb8aa5e9d89818caa3cdf99eb3b437c38ce1e31e618bbaacff6428b23b7d8401a416f28fc94a1f30a5d2642658f618ef85333919986fa407004b6fcf47d4d1a9de3413c01dac6ce9be85aecce73b4f47113047d755ecb0855f8837d56543f4c76d85f98b59dfbf19c67ec015330b5848fd3a1969180bed71e7fded2b4ee3ddf650a76299ac8c21f67ca8022d72cc0ed117544c937fd4d86e473982b2aa85b1097e2098d20a6e30b76e65200b0b573cca5ab26c9626a04c352c95005f479653969afadc3931d0cae190c3f13da58cb7a4c17ed7a1fd02f2151aa65f268f4bedc7a25f197d75742e580409fce7a91715c437f877da44851cf5491924c1f52f909c6311b866a61133941766f864208168b87265b0ed83a755a0bed45c4c49a082696b98ce4a0ed8f5a552b223d3910099b6716451258b323691dc8cfb55fd8d3818a26245b34cadc210ddff85558b26687c82296ce3c17ac201ef3d303d523aa31b8b2ace096157168f4f53962ce3c1fd5067436dc3d98d4cb97b28edacab30b90603d90ee239acb4f18221a39f193acf4dae74f41a15307f1359a40a2f051163c9b71dffd9d9c1ae0b0da338dfa9e88787d70e4b1dfd2997dd6e0c089cb02eed28df08c68d9bf4449f2e1fed792398743a99f354c34c200c599e460dc9019070ca86561b5038de5cbdf6e8487edf01ec17e16b2826b46399d109aef860ba523543bf2f80d19dfc5ab0e0413d038d12ed3f1d8378fa404ab89291cc0db4914d044aed1acded06a73a6310c9850ed6aa93b1fe6d4f0cbfde5b6bd36554b0ef350d38928d21bdde0bfda8f55057b47f671f144d8099272dfe97b014099ae3823298f61b2252877da6bb7876adf7eab7b31d1a6fdb63411a9b3b3e28b0910dabc7ff5566952297985a4ecf9667b9f787e4832be80650ddf43f8169da305ed0becf110e03cc313984c8029fba52011ea62e980a7aff00b3ac72ab1b06eff68e33421eac22b1d26bf5ae52e6cd96959d590bbe1a62c2045650d7fa5b42db3c59c2ef0fde2f35ee7cd3758177b199ef3e69be891c165767ff7e5fb530c43fe332c54764dc198d37e83549a2dfab0fac41ed4d321ebe361fa9c80620afc520ebc5bdab4b51252b8fae0d4e46b0864e004c2c85536f4724b661ea66275fa3ee27f643324f4141b9c307b180b4f57896d52563ea3e4b3724eebda94ffb55638dfa6a97e14473c13873c08c37aadea2a288e5cdd87781c90463f5d3c653d1cea188d8b3a588365a05be053b5fc16066985deeca06b0737f4e41454531bd7416884b1136bb6b012f8c2c8c7b921b055423326a1f2855d4cd74adc0419e65f18e6e976b7da5c17b5176e74d76433e7d2c9723b3208f4ae57431eccbb64485f03d382f61521adc2cf7e1a4dbe280b38182e0772ed56d0f05570a28aedf99af0c77fad729459c494e0ed352af0f48b90854f167f01f9457a13d983b6cfca50415b54758dc6cece2fd3ea6cdebcefbc55fbdf28798ae8776370b09fce702170816f3abda368f012b799f7c69025b7b5129d6feb496c2dd1592fbe7f64117a76cdd5bfa24079d394c33f82207fdb0dacb8c01277077729ad8adc46daa72120356d489887e0ab21bfd40f3e7f2d52ad0ea792e01784fca3030a30ffa9830b29ba526b35231fdb9097b399bc917418c4b9818be30a672aafb942a0041488db267a9ef01a8289fc1ecda6197802e4962fed08ab8b954c1d0b23cba0a9c99049cb415bb6ddaeb28b43d783a5bcb1e541861bf9f7f3b62bc7ef276cb28db8f0a4f60b35981146660b511d14b4f653a8555c002b5504b18cf4a9372610233784289ad629f73e7df7bbef4d776d4e8d82dc9dbb3569b1728dbb3399ee0e9c5ec658148a2c122c907921efffc20f7b64872fb18f31173d3e637f76374850d99f92088a09597843f4aa7b2a88e086de4cbab86a8253c623223363e393ae66c8625818f7dcacc6fe7615b25c8ba4a9f3fb809df49efb986604058e41f383df629468f5a10ee93889da6e77cc28d34456b2a261c88ca6d8cedd1ee25ca83715382a5252838057597cca87c4ca6305d7ab1d10b375a1b13c58932b655f29012df91b291ceae1b50b67cb05c010b160d16f42da19ac3064b9a7652fbff65129a5222e7861203bac6c619bccd85d8dddc37af41e535a3deefbe8272937d272c0b2d085b88b9739f874c0a450c0e84531ee52ccfa59ebad75d68f99a7dad55e3c093511f71a64802db6c2bd2d0b863f3a66b67436133ce85e268b317a34dc94f49e03cea2cd6379de75a91946468eba0620c948e0bdac121d7fd9051bb0189517aac55068588c8a309a2a840cb3626052ae3606e0f5d4c6089dbccebe1033eaa5fa01844df336e6a20e819a576dcddd546ef1d9e4de654606152491bfc412ce06f1bfb1853513666dab9eaf4e0e53df41f94b2fd959f988a7c1576f01442fed320692ccb029261c7e0b9153aa340c90f5b16ea78ab38a59584671465dc1bfb7de7d6b738f6b6515be40033bbb218e25564b9579561ca4376960092e3edc206e87f27bd344771cb7cdea2201043c1f8d995d4eec2dee8ef225a366b74079f78d90c1b525323fc2bb03596ecddca941f8c9e3c791454818cf692bf0f6aa7dca611fb9f34cf337120dba517ebb16a165ce7462a933c916ce9f4843e19bef93dc44ec4496a9633267a2ade45a0aa3323511e0aed7c0980565ceb878e95a24d2fad9e99142bb57c33e0a7e832005c274dcee188b1a1af4a3d26639d0ffa5c159414a19055962071c4427ce02feb3a20d30c30fd07c856d9a1223f9667d7380c6ffc4e1e600d80a9fa93b5597e2f2e474000f5e7dc2547b14856a7221558cf69bb69dfb6be75b47b9cca9b50bbc1d49850bdb6912fd75fe74bb459b74321bbed9b5113674c98fe82ecbd60f8941ba80699a710470236ae6b1053284e9e4704fe6a0981da5337f2d711978668fc392cc399e45286aba4326f75165e7e41d93a61dce1f28a0a12f357e3cf5749b8a291dc3f1dc17a21490b42aa9cccc0bade27415cb910e3893e56a4ed3d2a607a9a803b1a6739e9ce0f355d13163b441142276d9bf00f8d6caf34dd5603a3265aff51a27aa698202696a2c34341880512431d075156ab33a51030f46d6d0252039f030f24b00f03da75633a7feb742ecc8c14b44b8566430a5485667409d08fd5e9c5ff0e31aa012bf6dc13a1347576a6966fb9a0dc20c84015b0ee4e224292132b2ec9a75df1671d0190972deeadba871defa34b61d65bbd08ea97323b3436c49fcd0759d0f47320c25d01582bc3fe856c6c91fe21f92bc19fc6ede26dc7eda2bac0117355440744540d824461bffbee1d14fc27ec874a2934bd2df2e7cdb04ce79cc66c5b954d6551ab605299db33cb6133f71f0234f177fa45548c2002b5d83facf46a3288da125c48522a631743bb17bf990591e44cf8a2ce66c2ad40f96a95232700cdf18bc976d0ad1ed85b5ae37493ec578824ae2d1e9280287a365d577f550b4d3910cae121ed59e23f2892f0323b3a2b8409793901aad68fcf417719d1f9267c888dabb975dc309b63f580cbed2abc420da6a22493fdb10bd77334923d97feefe37eec74c68e6b4ab13849827e5ce812bd8c5043f78eb10aeaf42e0450e3e04a048999a8c14d5229415700bf1c654b9ac4c644ffcce0042021f2459ab97bda7b3117dbb2aa0a0a4c607db2c18491a3b42851db72abb3739213c13576027e2ce0657b5bc74cfd0e5b31bdf5a462214c9effee2031714163c3dbf1c1682410a66c1dee8fe674358a465d73f1009c0e173a38f3608bc8a8c59303d5f9fc56290b5def2354747c07d41161e62130c2cccdce1235b639b2b045759886bdf98183b874586f67e85a018eb2550ac14b35161697ec2970e7a2e303769f26de6d5322d471320221db3680ca9f1382e26102bf516460183fcebe4f458ddd4a603e9a43ee3a9f9fe2e792497966a247256a49e8a105991d7de02ea3b4b9e34d91ea1a8bd9a7a2e51366ce01acaffc553809e2a66a6e93c35e473bc7edb5c3cc6b00ecf07ba4a8b25658e19bcccbe47c74e0780b826d913b006ec8dedab81f24ab088b7bcce5e0a056c7f963ea64bc90e89efc21d049a65f3e923c4680e2ae6f55be66c3118115f9b63061e56e364d7620a50d8ba670ba8a32410cb630b17b1a2a0e39e2393b9512be59d57c190ca66843c97cf9bdb523dedbde1fe064084759220d0c09799f1e24f2b96ee4652b111730deceea572e0d53372018b8877793b835cac67d0c2b7b79214d1e8c4eead88bf691af99ecdb1f8f652693dc28c856d2c64a55accc59b30ae47d23a884e5a3c3d057a1806d6de2d937925d34f2edc77bec385519a6f9e7e9b31718945a2b0165b37747bdd9404dc1fca6c75ed3d227021b7674767ac7b9bca96fddf1e45b38d8bdf627e0daf748577380c72da53313fcf98c193c996df52b3e5cf9dec3170743b507dd9b0f6cec30359a9a63abadb84300fbf6a27848c13919deaca361b0f89d097d4d937024c53a3ed2c75099cf03a23f26b4febb0adaa3c61a844ac2c931d4842a6bcd8b291269d9db51fc4ae869ebda3140a0a4b082eef7f5ab079e0c04fc9e59d95be47f92893b9e58c49aab29e823125cc1c278b16e1fa58775591a94c1ab56f9128ed951232aeed6c80b064f068a011502b4a860c76cc33c27c1874d5b5459163d25b248d364f2641bfe77be8d46bfb9c75bcb116ba3ea59052a45200918b036231c0b1886ba833c9d5a0c141d6cc062167e26369599ca2c7b202026e6a6917f4b608d3c4c947e80e43393a9257d99994f3e6d9c7b6723ab3e0e93a53a793dc047c72f72e3b74eef4c015827e4a0457a3ae0c868f686d5ea357c74d9f799b68a1f49374fc058f3746765290af30761915d524567798d5f627bfb682bd7503807f9ab0179973b68b866afc33a6aa39ad36355f4c8be3092005f384d2a2857f43c1dd7529f3266c56110612bb4e0948118991b14072d8e2765cd65428551122fc130ab6a281af04309ee642c0157c6ed0d7114c1c8e3ee3a9e85cad2a951bd81ead64fceb7e67be0b7179c04fbe41c6c7f88827d169c3e8135beb869db6fa1efd951411a5873ca80258d05fde4fa9541cf4c9eca2764ecb24594fc3019e5726a35b4894eca426da50b2f41310bb4e280a4c8759c90a659cc0b3c38cb1c5c1ce246ba0512f76fbebe61b809305e1b54b6e2efc99fcf3306e8ed35d073dc7d6bb16d29b6929b7f6d95aa3ca438b3bc13ed645c961dbd20785ce9166731c50cf4ea4aa17e491934fac217a9c2aedbac04647cac3809b629ef08e62a12d5b9093fe6278960cbabfc3a09a9201098628ad3e8f0cf0e6f0c6b5c6cf6d0da29ba999247a1d4ea4eee3ab2c508c161098ea2fa69e955ed006ba94e557c78bca07523bc0671fc1a2986fc81b4437d30c43598cfb64a8e07877804dc568acb966c05c47826b0ec50580d4af38800d540067f7e68724cf1d30b0a6978612bacbd046fea01204b2cceca8454349e96b3b4eef01a363deb1ff4438848024ae752826dedf01adc841e42105e645f1c124e1cca251509a946b304fd8013a3c64c7751da8876dbbfaa28f4f15bbf27821bc640740811a6b531215542d8ee2217ff03fa1f79321dbd5bf7f307b4a56a85b602d83ffe732db7eb7142d26c57ba3a931a26a4f281a8f54053ee929a0fef8e4eaf313a2e710ac9a8785af2c610e497933bba53bb46182f30f65578ab47e8d9b19d9c39a6994de776ec62c312722de6c524369ff1dbad8bac3c0b52538aa983c9659ff21ba43fb8239026177f647c1f24c216a260f6572381403da5fd8489ace25fcb5aac18035674bc601a2bcfadeb4cd321937e2a4504838c487a6a095931425804965dba9d4e6ee749f3414370b14b57fbf3917d1382143a556a9063acba54d60cc32000312ca2088c255d89f7f8e4a5be9af14181cb45f16b0ad5324de19e37e4924cd4b2e740023c07c70caa8c105e28624557ba6e875d66074510750b9af61116c8b348e1f63354014408e80193af34f04d623aa18a289b7cea940ed393c8f910ccadb5c8c00c24220f687671d6c3170c0708820a457aee01b70aa54ed7879f81c7eeba85df496c12eca7fe2c268966cae50624ec274b823c8f98d46f33c5601fff578cfa5686e4b3f6b6a741b6f9f39d5a962a896267a7340333cca33af582a839037f5500b6c50d9ba2b59c4544c28f7848e223e118d548e82495769760a3bee7846c03f706276a54752c981d3d3a178a53301c3c9aa7e664ccd0e94f810676db0533e80eeef30b9c441501dfbeca844605ad0aeb1e704655dea69b52f0ec79bb856718002175178edf29ebe4b13c9e07767f37fab667ce074606201cc1d4c66a00966914d45a960610c232f434327a41c769610fc46090cf31a486af13aa3d388bf466cb6e9bccd6d660fb87163843606d56018e07c837ed6233691a4a491bca3cbc800884de992f568ff248e45eb27f588c1cf0e2727f676cf9b621d571afe421b787f5a3badb1134b05ebb888bcf992f31163363ceec0fe9cdf79412f22a5ad171e1b068bf8a2aec5c8fce0a9633aa3875239894b406c03c60821c4f2354dfb8a0705852a2d2ce11c6a723e0317966b0789c2524d2f7584488fe8adf22381194e86e536f1d1eccc2c693861dfb40a24ad0645915d4c5ce6c79b8919eeeb0d0f980db2602c7d69a697bdfe188db50a500b393a8fbe22b1b5de94deb766ce1663d1a4a26570658c803a1946e6be026b7832acefe27182ba3c86f3b431c0a0381b395c24623a0861e2b82a889b5bf399d221f280af8b4327da9d08a1e5b3e2cd703aadcf7cff575ea1ce0e125000ce7b4939e76ffc8d76b699018f14c158054b12f09c980747fcb244f0d0f749068ef86405075589b52316b6cbca40cc8c7c99e9c6f67cd6a5b88230c06345fac50460188af208","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
