<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"53238d5f1c1b36fa760c13f102b0cc03a459699d1de0086225bf8840299844e908260a80c87cc5b5ad0b6c7915207498c42c6b9021c3e95247fb63b6a306a677911e120f51a2edeafa8c4d2f42623d56c215a3dd38254898895a75a7a511370c31dc95cc46aacd9eb61a7c4e8a70b13ee48e86261639f1264e70d0ad76d0427089035c781ab2051630784f55b85a95b3445a0bc8c81dff51e361649d6ba1a54da2905b041cd1b11bdb5f53cb578ae516f1188c75649a06a1f5feee12035e3371222dbd703ae497396bd893fd85fd55d0c662d3f225025b8bcef4c80f5e9f962b75614a36321fb05bc631df8841f6b65303662b8ea690ec1fa1a5bc7951176db2f6641cc971eefdf04ebabe98ab6e38881f9a03d27a605eb14e3ec4a80dec1fd150cfcf885edad38a6b596e030989f63a60113e15c417c71f3e35e9e89e1b56dbcdcf3a1c7bdbca4150b60692c4fcfa1a7169c6d74a113defe89a73954fc3113f893f79d2811beea37ab522a39734e79fe4c172bc67409a54d9c32c3100a5891ca719158b45473e228646cdc43f577bbbbba26a0e354a83a0484b5381c62553308a43d9b83022ca3850b611c3744e428072800ffdf2479ac91ca09e2525828a3dc52974480f84269d69b4b6714540ae6cb78d6828bf9f03d1ee05f9b3ab9230b1a738898d478dc851ce16c46554895130e003c64258d6e9aae5624b6259dd02696b0e0b9dc14b708fb98186bf103f93c83309f7bc3d1f48bc0e57fed45ef7f0a8099153a559a558faf6b4f879819c7016d8ddaffdb7d2724bff5b3735ed7d371b86a614fed4ee1cfb74c70fc5db00d363df54c552cf36f703c575cfb35f50aab7aa40a76de83bf512723c663747a1d011d334d6e6d293ac06e9a5e7f1ad12ccfdfaa74642a269d985237b274734a1960a4e7eb4e338811f67eaf4b285d8e18350fb064458b5b54ce502b0325452083f989155ca401cef06ad5c8c81dc15f5c5be9fa7ed100f53a048658aeb76e5f22d9062fbb05224024621bb7507961c2a22121c3f67510ab49e96b8fb4a3828e124844027709fecc5d67ca8fb2e2bd0fd559b2e94809cb42f2a5899b3aecc65b9920d27544483e8f6985ade0434c30e2cb095f9601b36ad21f54d589b2268b0b1b185ee57d750be9114b37ebf99d28923b0bac6f6d28e79d28872da40facb05c1a5e9098876dce42861a53ea4297894ea1ed3cd0fdaf6fe8f07ec82960900e788d84aee94b15c541edf11ca60dc3f6992cc213ed4c22b5c897268029cd8ee1aeeae03fe0b596b019c5c5b15c9f9620b31570612c787187c1ceeb42bb6639236fef93197e53c24e04e1881b37400c1d46235b95799955093da75f52cfa31428e9c2194bebfc817b0d6cfd889b78a9aa0aba131dd7afd678fb8f855cf9e33d142c7c3b9a2e2a27b198ef4a1d6cf54044e952d3f76cc99f4c1e0252660434e1fb3ca4732fcc29191d34175f1bb629f5029b4f9cb201842ecfc9dbd6938630c9b000453603da8cc295ed2536dedbd95cd97555301c2f3ce10d9b7c9c82596811663891a8ea1c6d93de80f411cf696ccd8233512191101db426e5ffeb60f9c825d971791632db026979538c1bd72ffa17cd7e2ef42d3054d8045bb22ea11a6ee5db4cab8633ee6dc47bc2ebba57b63df1b1802ed50505adcd965237d12e3e3f53a247746af27a4dbee5472fff635c4c7617313a5f1bf32aeb90a249cb9db569b0baec359bedbd1db251c09034b0feb2e548e512232896371da3c46df152202b1f5318e81b602480a84c3aed4eba6b27a90cc85cb2d727a30d1b93826f0487d6907978178bb3f55cc1a8ce38d4b70f25f0d259f8c19296f0502aa79bc7e59c33b20281c7ede73b3a0d532992ba5e5984699f02b72884f313df126b827dd2516768b2a95515d9fb92071a2c8728a68529d7b49c37795c466a9bb236d3d425792bccbc2d586caa13f86a9987945a47458c61901aab6a8137475b2c166775734bed2da3c6e328b7beb15e6125e9b464fde743413a56457b32e8824d3af6966964bf96f001206693580606f4a01378e4d7bebc174e6576f0c180de93226b9d087d93a696e03d7c25fdb61cf28b2f6e8369925c9e3a1e298a5df904f8f993bbc66b937a1c84992871cd7f210a0c561f45e230d53ae0cec91ee1bd8afa4454711760b7a1e65a66aba9d3c39c641f18fe57f91d4a6610f5c87cc3d0b272e26e3ec23caaecc700b27d19a1b54a528c5c0324435a3d8aa2e8e78b8d1fa99b9473b6b1217d605cfe7ea581719fce2352851e51509e47645e2a0c9f9fbc776d375774667c55c82d52de7f27e950baab17278be8383edb34fae68dada874a3e4951908fa65bc210aaed6883c47c3fa9e789fae53140be833aff84df646dfb53f35c1481d1e6e52c75b1244397e506296d756cff4148e5642f4884300986e186819dd8e1cdc021cb1bf5bd60727cd35cc98e4c49862887614948ad2519cabb7f4f6c95ac2e44e514eaf5dd832995574610edb6be1e791c819db5213e04a14b6b4b8c9909651df742940eb402ddad4fe0410f8f9b7d07b36897ce927f67a3b549fa9348fdf5639759b8b751fceb73561f1c2171ade3ee7c3f6f9b1b596be2cb61d702d168da2fd5179c62f302d63c6cbe9abf82aae3be4bc640cdbff4327379a4c4f0bf99811c4710cd89b1ede86da359d6fda5fcc0bf418719081bae5297e069eca03ec26dd5a57d94106ee8e7e93e3245a0b58cdbad0063a0e3392d9743f95a4833ce062995b8489b00bdc6bafab188a61351b28eaa1c2338041dd1c6750acd4347e535349774ed1673772085771b995d67af22e0fbc41a11352c892336e9c65a0ddcff7be3af6b4e4b843be6f6d26da034042e8635d8bf79097a282d9657a75e1457197143fc833d851694aa1556a33e1c5d71565ff749ed48014c13eb9375c4eb0a8e3d2315f7fdedd902eac37e1950591e66f474e47b068e99d906a3c3b359ef5ee22024627c24bed6ec2775d95d27c7a4d28ba00f31fcc4b19506bf72a6964aef0bd71b02b64a15dddb2a0af4716f854230fa2901a9ad32a66e531010716b18f005b3727989136d0251226bafd6e75f498aad113f3202d2b396449467489f41d016dfe91647e466b8d547aba130f1c29f4954a5531f4699fe6af84041ecac02e830d24839b58c6d63d7e2a5df6225140c9f52e89b0c00be6330e4ff9335fd82f4616d6fc82144f050bc67168a2822064280755607d0cdd94ced2a33c2044a442af281571fbca398284e0baac05a72e927a8786dcfb27c86742038a818db94bb9aa8e973b72d8464748d26319cbb25a44bcae3b4eb3bd34aa9c6359ed78980641c0b119b4c343140079e318ace497867a0abe864f84498e75890fc5b895bf83bc3761abf1c70f50f67be270c7d4f852121df48209519034b852ef515f85302248347e566380f8065f1c4f55ac70ea8a37eac236021c4a95ea57e7b6b1562983a89ab55004ac68b7dc575b721995d2a8019f7e2ad734d279b63da959461f4ea799526e2223ec865da21e3d928784127c2de27be65de3dadeabe68d78fd8fddfa647393ea412b1d029b6de6f0d381589644c59f14b478b7c12cede8ba126100ef9ff13d30dd70f383dfd63db74aeb2532fee6dd246e7949ce49aa121f0a4100608f5eb69feeb63aec230d334ff9211db798303821910946d74f725a4441fecc9789d735cc13904d7d53b690f2f805253a373d46ad22a8fcd3524309d855ebb2d6e248b28251d7452a3d28aab82f06ef687b428798d1ad99271dc7d945ce988b3d1177a256822aa0e47a5511f5ac19c8c2c5dbf69d949f37b313f4185d5474dceac542095cd273274b0fcdacea2356700a23687a32462e7ef6ebe3a33370a92db7880fdddc4d8f45cfb5648c7a831f36437ec7e3318beb90fc8e99fb7b2dcd11363d71f7f5b59b7d9c7c0d0f10aba387b76be5f9766ee8b05d635cd5306374a3ad1bd3ed894a3459ee6a3e58109da1d72a6e8b0751719503b3370abcb11f40dcc05cd1f1aae05c8602454370bdedbc15d13a2fcc4c5aadb187dc6786e03a3feb954297289ffe2e91232bbc35c8baa246f0a1125ec534044bee7251c39fe685fbd0c997a98d11d232b371e123ca9c33eb204d4aaa2662e35439ddc836948a709474783287778b8da5fb071535de8e69700e82eace241ce3ad2dfa62d45195d0d948ab8d75b45826179c7f74fcfb9ecd14c5f94aacc37e45a1619b7ab520655a3149007d6f5d145c8b1fcea3b7286bba23ca424f8e320ca73bce0d6fb875a74e4b49ca021a840fc479a05c94df07bd7599eb9ac9454b003085cfcc489eee355a96688703810389fe849d2cccc84d89c9f992c1f6b3b561aac97cb502b919ad988b1b59d08eb7c122d7160e541c30ff8e5c25b12815c765d05cd69befecff1fde53df4d1d1e0efa797d1777f5f03dcbd565b52f4afeda80f84081693581a1c247fee8d27625bc305e0ab31e8efa18c2bd42dfe323cf429cefdca4a7958c36e92ea2a90fdcfaff7572dd95c059471edee0feaf38a56d4e1e9e6d6195a26cabe3a8cc8d8d96ec838b41bc1d22f4e9c4eb08a99e59513cc48584b09c94856a7645d7eb27129f3154ac6535b77721971ade4ef13a780af17e98258a0d316636cc4429ad783607a36bcd6dec49c0a334884c109635dc90bd381a72aca65fe9496fb43bb794faf0f269d35248c3195dc7ea1caf1fdb4fa4b76b0d79eafa8f54cb3521e312d6ad9af3c1b4b0111fd5f5d1518c91d8bc567631f2f1fbc4e04878d223a82144752fdd64624e003c1025df2f4935794f4643a3159166a14e4e134e16f1daa4c355058ef9d99b7a8c80b18486283ff4ee5d126fe3ad4226d4c2679655806959c18f352c6b722935b1e4553ed3ae9687ea52e670286bca6e007e8b2b62561b75874625001d09bd127a44f0a3b8f0bf75fbe4ee9e25194573d6a3f552d208d9ca7945e4c02bd6975fc5a43861a3d1470370141bd6bede97dfcb072a6d2eb5d8c9771121779b4afac4f0644d1607f74644a48914c305dcc1c4cdf0e19fb2271a59c3901e3392d978051870ed95bb7f60c0f19ae1a5c4647087c70d17523cd85b6c33265ff2b49f2750456b50b1cb2020e7c4796465210f69938c349b3ee37b71b86d3d156f14aa09dda69daa351c041da2686cd55286ee33dfaae0b0e9d22b9958fad286fedadac3bcb352c8e365a33558c16a33a963dfe7d3f0b2d02c36745aa798ec4517e4fbb4b609ede16ecf99aa855f5a8327b6f6cd9653ead849c5beda106cbb423000a976323774830912efb19d782764245c01930d585fa2aab243620ab29da638afcb20e0f51d71776d740a641c3de544737eaac147d4b32fd973c258cc85a0338ea023ae11a39cd7604603400dd2e53a14c45f683bf2d7cd89ccfa4580c4ba13d2dfdc7dc0cdc1b63e64b462e9f4f9fa1da57213f80e625bdb58e1a0304d354aede416df01d3bc997e163528b365b99cd1899ad8276d9e5ff1985478414563589bf56f72a1d289092350f982d17ce190982658e04f409cf32e9c8db58c7a628a3db79c143c4067eae45c1639afe02a3d6586b5edaa84564050859160391afa019460a6e1c2c6eef9ba66e0aead615e43f58d4d218f35ad1dec862ade4816cca12164992857a009a88625d105ab3a9049ca73eedc84e1f5e336f0c3036f548582679b55b9995790ef1a7b6b6b16be6f4ccd9ea5cf74863bfc71dc8e9eae03d5eec8f4503ee3e9b3753ace834148f8ec70f7476e91b45bacb738ad050452a50f6b32e7370f67c6b1e23e01daaa8d940894027b1f8b9aefa59394fd4298613a78528985fb0b71da795eefc85e38f75f2111d528a4334f69b1860e5bd929f4949f4d90cf41f7720a31fe1d00ec184baf4a0d264f9c66fa09ad4850a984118b3ba5ca88ef534edcb7ef34b847208c024ab42184b347f2a3aa13b3fd258522377b44219b480d2aa3e2d6931eaf2f81ca116ac93733081b84ab2ad63eb3b0b2319a87b1e30b10eb5cfb336fff6755dc4c5332cc4b742c237c6829d714f6d77859e68d139428cf3ac40e4851dee47fe9d6eda0c577689b7a7ace3a1d1ba3046662e90c99a7804b16b712c0247ff1aa494be4dbe4ddb5f8b03f99e935d193184b6b077286f8ea26c2c6c30ff8ff30099d70d9b365ba8c29e5d969e2085a5dbcd7aea40b6cb459db280014e8b86731a02411d2dec37a01d4a34b098aff00beef4c31ef189a814f360d3e0d661fa6928d45f675221c3f7cae5058b822da98f43562bf1ab234882a77a864ecad61f98069ef423196c850db5ebbb923fc88a1a038f4f9a581f9f2ed1a0d722da17c712272936135f87653f1da0010d892e5bdc6046d296910ec764604e7e0b5d30983c93a6c6edaad2b0c0895ca8eff388c934e5a969ce44562a7f94214cd5750db97385c4e68e6e50616046799ef55b9e78e16fdcc815cad4732dd05b13c18972c447251ddc95f78107c2123b2bffd0193c96e8712f86a60340f89f7e36fc6c123e0b975723c74e252232dcf214c0b2b52f3077632d823c4cbfa3d35b8167aebd79395015a5f09dfa799aff4b9ea30b893ef262c8c0b8aeb3b3069d5b04913d1622eabdc08ce5501b8d20b6362acf85d2a67890e00fd7634c8f997a461781088fa253908e5bbe1eb749ba25d612ba96ee703d24fb1ef4a784c9abe9034993332c209c9e6c709b0d6dae8c7de19ed3a352d3733f2ced7c77c1a2216995acc0598500aac3d5487901f33f6dda69b2a5218d5357053a25d6f2a09429743f80cb82382792c12b79afd3b5f899d0cfcb99a5c3f5722bd229e540c44983e155ab457d6fd7c585d095762f954e02ed02df055f1a2f4b56524c4ca674ca6b4767af9cbf8ddb7c01e53022f9958dd407cf17c4e9b1b8059b7c9946fb304dfe3ddfcb6a2cc789f059eceedd477046029a46c453e9e911ab0061264152a205f1bc2d8f50d887a1ae2f52a478c80b84e882edb36c667f929d566ae25ffb69e8e6775f200a41dd05bf59297042b1381793b8aa1c120f2150df589f7e2ab3f1dd825da364f0bfc32fffc99f7dabe57adef3a73c88349f9119f56cac9aea9430bcba5fdadf0667c0becd3be78807bf5cd6e32b16ca469007ac2fed18f1513ba2c592bde1d84a6873e18f7ff4d315cc79e0aec062a83eee9bac096a85de009c3d7d998c598fc5e69e62bca4cbe811ed614e61916b1932b14e27db60f8fe0e4fa33e91256dc0477c4dfc09b86756e869a26bfcc5bf0a1f982867b40a72a83575df5e9c48f74e9fff5285482bd47137220197c01f65619d2065d65e0020e4ee2bbe7f76fbf2bcf5070226cc87675ef803218bc05ff5e58f176757526d30f90e53bcf83d901dbf59dad24721966983441dfd9f135f83dc55b61428638bf655e755c7f348e793e4d45712bf9d6acbed50ce49170e689a6c4b179dff337c21d9fe954e7338c619eacb841eb97f38b43ee8c5ed8a181e7cac4f23723236d9fc4cfd2b5193edf2565bd15f22fe97a71ac99db026aff7fcbc84db52186980a2a358c322c8ea73f3792e8782644c235d6641c268ff3fcd31690690e46bcb1b8737d089e1f59ae0e2d31a51dc1593fbcc66670e20fed24dcd3540a09db9f655bb0de9aa22c5fc074c0fa2ccbd071f89025e4227dacf9e3af5c505ec66f0ea6885e249ea31e2f1bab1659ca57db8deb7e5282006d64c3d80dee935e380dec630f287616eece4e1363aa86e00c91c7048d0a09e1f05a5f0a4b4c9a82cd00a22c021350f006e5b3a3c62b94a6960ecd44f921fdfd50ef953a303fd9b4968aa4625f6ebc9f2d650c05175bb09b6a40b9a3502da0ee7cf0a0589e30c789eb303709f948c6ede60df889872f4505786a68d7b1cc9f6229d0d537e7ab80ac4cfdfc1747ab5449595b2145263730bd56240d7e39ba2284dbc78f6297ec6756fdfe5cea57841a33aec0bdc139d397cc3971bfba9036961bfc92191c0fd3aaea0236fe65972158a43624c66db529c42c531e996e0f6016df02ccea16e4eb4714877c792af0c088e425ad18b538e5ccea131d905ec35b74309c85eb09113d4fb7b78a8ad08befaf87a5c6163feacc35b119a847b16b68b48af4757d51aa93abd96f4177500a1fdb32a76d4f1a62530021589357d8b7c2756e6a1d15d866d9783774cd6fdd2baadbe695a1489c86458bd6da89480e1914c47fd244c05a34c545c86ac0820d441267ff4b55dd230b08ce4634e2b9a68b052f17b931c783a7d0320fa087c7d23147fc1a8e617b170b69c5553da1c09a6d13deff7ccafc3029c193cb294d289c633a66aa10fda9d7f48b5bb4e61bf4a1e7591570c017fc9b2e93fa772067be02e14d656ddbe14c46df67d33ed74c9966ffb9d0858e63f167f758e67a8b34041572066eb646158ec073354518c5e69e1bc39b69eca39c88a2838de3f9265b402dde6593469a3aa56d8a14ac3d99793c65c2dec8deae08f158841b280fa5c15fa5addfe82cb1d47d0166f1a3b221f3f4ec9fe1c6989bf5590b5c8f9488717aa3ccb77a0734688d611c7e850cc299f4f6c425b45b81d6f17dccc80782eba28ce11a3165b108d2c4514c674d5ab376ab09d9ffb698a076fa35242881a9743771ae3095ffe912779f08e221d5aa58e54be015e50f8fface13f07bc035a4834d93fe4c873486e26b0d5f380f0fb68f4612120c1e0a125766a5644554edb79025b619df0f1c2bcc8d0b48e2c6bd5ebad7d32ca98c2e13b729ba550bfbfcb74032a37e120d405a2c5e30aeae3fe370c9ce5c84a079fa7ec2fdcf270482e686fc87a9ff24a80703b65fbe43479d9cbdb00aa8865ad689e217479fb156012105a5fa0dec67458e2b1408c997792597257a8d818786bfd4afb236639b996f8e18bc14286b074e30f174c3d7e2967790a9c4afa21846f39d5c87263b91c73c3193f4f40328eefa306f0890d08209daa3250305f3bcdd6244a636be34da386500d22738c603d3bb958bc7e06929d72e7abe75250a8671758035f3b7e88c53eb4667a98bd1a884ec98912719186d5910e254e12ed771680bf956869790df89af85eddf7cecaf14251b46b57a30c91a45e08b09e46e907cbd64233402125bab8a0853005287bc8bf166a47f996f1ee66462a82e07e6a00fc383f9da27617524d133b5a4c11184b4d3ee1af50e03bcabba29ca4cb8bb4b5b05fda67cc465fd4dcc6ad7cdb4680d623571e604e952ea16159b754049e9a37bfba97a5840d487faf47881e9957f2457716a361b1bc9089f44355deabb8fd31d397c4a7d4a4ec86c2094a42aa2fc3bf8e366445a342fad7680c6c8e81c66f9ddeb8a8213a49103453cc63f9afc25ef048bc13757b3815bc25ce75c15a8f2244484d652dc6aeb84be0f031c45a5cd287d630c985ab78a1138904c2344d2670ed9c7cdbfb1ed52dfcbd987fba8dea518e5d4fc67a1e8c9090b2bd3a527e552c4f4741495058c5107a2c5574d45a432764b717341207f06efe78f039372d4daa4883217cf37ffbecde60e48517eb0898835ac6d751d8d90c630be5bf531efec907c89962dcb8cb2307c915e40d1e139cd067f58256586dcb4ef4ec7fb0dc41836fa859b34b8cf8a55af689652b4f061c29c676cde82a765a82a651812ad38b9c970ee7f91f1a605c5e897e728578b3e3f6cad30c05850c62c015136ec3eb3a3a3ec19f10e2ba410a750d43b9538b5f9b0f4ee6e09dfe32123c33d9c6ef46b14fdfaa9b7a0b72e1316b6a66516cb9ff08723baaa66337eab45546d50d01ac57786ab1d00701ff54bd8cf221da4b79c8e382dc97bff09250719dd7b44986fe6e2364b7391586aa1b28e55dbf4cb9da9407b3251e82d49f9361095b06b094ee255ad37fb7a27cdbcd68d7776ffea8843d3ece28f120d8ad0fa15d2f414c2e35379591dd10116a20b91114fc8a48edbe7e7fb73a1eda34e0d1fc83d1ab727a90156b17c0e4ea376ad53768ecb7204e29089a54fd154e014a7a86329ea6b37301a2bff19e05bcb192708d7f6cefa067068cf79590e8c5766a6cb1625a5b78072ac65ce8f43a09970337b05f37cfafde35c53515bf91008ceed9173f7e37c7aa88968e4bf4e9ee6a034eb58c075a7ab574252ed8448f2e2410ba0a9bfc5560d80705cc80217beee10d9667153e48310156d80f6dc1f4d58d547b1f0e9f391077d5409536730c056b8ee436011e11ba341b32d011393ea8a66786cefcf8d1197b25e3ef4144125575fb2f40a57ddac9172743ee9c0921d996e523e38839f51e39ba5458b46f2577e73eb6ef54634a6bc7273d75905f3fdd07899a35510595812c94fd7d1c7b750b030b18e8b8f37a82dbfbccc70bff8968a7fc95e2d4aedae07588e61c926d395077e97df59ace09efe36f1f2e9245de1b73357fe45f059d55b8fa0bf85e3aa5ebe7fe9e91710fcecc538ff38647fe2b40a238a44bb2c7303c4829c6090ff88c70182087c880e6afbe23d15f1959b977f9a2e044e60699fdbe0c24531a521dc4a92e6b0477866afbcfd5e0f1b74598675ad555f4c63ded65e24927f502ac09b87238900a60d43d9dcaa24be9b5f27942899d5204042cead9b323b121234beb87495615a66439877d54312ff3cffe9e6ba92532ab7d6a9b650f22c7808d95e30e341a5c879bca34d0b59929b3d87683a6b38542989853b4a04f1bf67e6a9d8216229d580a16de1235d93a5f699fdbe89d0bec2b5387185ed8645a6987a06db916d3d2761143aa9e3a627e375f88702bae874e74975e00875958bbe51176f9064b1147b6dfb82276f68f901991d6ef6b7e86315e7cc891b3dfe8507ae764a5af27830bc89502b5ad971e2603d3b429a6e1e115a734f696a8484758e5c7f1996ba0fe5f764151022a67a10edf0f8117e94129a8c5003fc3f732dad18772536668226aed6913354995a46c3ee73f25afc289dc277d85ba1c7a4031dc9a19e01e69bd4205cf2a98abe0aca5ada8eccf54ef589c3d8de852760a3e77ca94dd270d99435d7d72052bc4e7d8eeb3c0519e8b5e3c5f1197b5f6f11acad89dd2536cd14e62e3dbfed427dcd3574f6057748c53d91fa2c0a83d936c64edd1c3bf66b3fb2044255fb2245a02510bf53c7d1dff3786aa3c20e5ed5f548ebe8f889de2f7e50a6bbc6662588af98b002a7664565afba7bead2e05550b4129927c5f1ced7a6d8370e5d4efab5b54041fba93773d2a3c964b54435b6c5f981191517054640e1b39350c4046bd834eed6ed8bad1709bb980e1e45c390af0db8e1378a2ec2a787a37c9d8dd746b89adac0d05e48226b19be158882c3738ccb564cdc62735e9e989754f253877ab622627511241d69452f7efeb001398362bce7b2e012d5188d4b29027e95a79d1d9cd363955b64bc351bba08d22a1e4a82faffb4e31a7d55e32f9bb212152bb489c2e72b882a119c2b0d5ca1fdda9f2342e5546850724d476a2f468f4787191ff7f63efd31a5e3ac0cde207a2fe39458b8540af35f597476aa523e13eae02d0e74f90975347c14be1ba08ef6dc16dc86f0ca49f9420d880294d66d2cf49c864fefbb8b6488ec5baebdc5989ab462d4b4e721dd9110ba8272f062bfdeb5e4be946310feb2b851bafb1d432ac2dc0211f1263d6c2f8afa9c906ced86ac1d7ee93d14e1a17104c0e71d921729aa530faf875229c6bf95232c0b2dd7022deabda084021f5e361dc496af89b2e2f05e3384078a606a82d4b4c6428ebc6addd9d1de1363247d727fc68f31a3402b863cffa8c591f47ea4cd976e50ce04d57c3e14a6eab53465eae5f1d5577b815f4ac8463a473963747e9489e5cfe1427d7cb1085620ead1f0a806533ef22a8f35b7b6bf00d4ba963967e83bae5779ceb8111f8c6cd5aee88be346262b76261944c4c022fb1974175ffcbe55bccd5819c2f3a2f0a17eea7d5ab7d8ffa2d83c716425fe07f2963000b8406af6fee0e73541cd436f5f47f64e54f9f668722f83bcf15af69b8b9e717ae22d0cd301cd45ec41f81100e6866bd04698cdcf20c310e05d2df52be689a0b1c2715b64f85542d7a2422483c95d7f29aa3ff5edfbb3df74021d2f90efb027c40ff48524eac69394b05cb5a3f14cf17fc5b9f38586e80d6b4db24760e78ee06a0d0068abfdfc8e73c868602d8f6e588e38cbccfbe22ca625df50e4c7de863dd3aed60427b9db28244a6148288608dd6ec87edfb74630907575908891ac925acb83bc78e9a27eeadb973ca333510a45870605d29952f3353760412808873b253f4b5fc758908f9c6c75125ba5e109e3bd514b888518e8c440ec703a05ab91ce2c8b6bacd8548634c52af41e6d1ba63ff7f43d52e832041de5b876f1105d2a7578c3491fe26383752ab8cb2ea11ac04ece6eb59b6970a8cfb8c33f06274c100cc7ba8a4914a4d306e5c8a17f94b5ea568e0647c61af7332368423fb39a4cb692a506b998d6528aa015d6a04930d03e831c2d338a3e923a15c96a6d2f181b0911a6631c9b5eb87147736dde2da4b7c88462139fcc71596708d7c418024e3d23b2068098a02c15a3da5cf7caac4a3f91264622e533c6629cf1caf5504fff4164ea026675ee85305f7cdfd13de53d057c315e9234b081774c9bcd7a544c21993b0cbd657c1405e92a3831e0088dfbf378b892e5411b8dcc4909f776876a37410d1a80bd1e837e035577da7c94bceb6e85e72439818e8bac780d1d2ecbe94e50ec0926c77697b1b1d112406073ff2289c15ff91882c49b1ed1e2974a44a9bc1a441f0264052fafa439fb467390e5c42afb68aa912506ce2f60c68b8b10049da22ee653ae429d46c999454590608cd608e049223af043fc71cc578182ba2c8bdc53f5a6165dd48a498d80d2d190a6a298b5276de4fff0248c9c4088e6aeeb84682d486d72106af3aab38dac3f98bcecdfe2164559f85797d42b1691a3893be30694cd2dcdfbac5be5895453ac65b8c7400617146508ea2cb34f418b809e7062215e800832032b3c7aa0723b78185c89243f6128e759c32d2caace2eac10f687dd4a11e1843892b408735e34cf1706b4d74dfc9da553f3b6e1787603c9a217ee5d5b2c67f9f03c64b8868ae26785e23d8932a1c8b49a2fabfc39d6d430962b47e3dd2bfd311eefdf16f0392169c88b6393cc1f7f3a6e56414222d69d10b50d45f4bba216dba9c171ebd888b3f5de4cfc973054f528a3356217ace40cf7095353006f149bfd77fbb11dbdd14a4f5fa2018a06f1dc776beeca9dbd7033006ca34e0bb6c1b91130dfa144d6bf1bec26c17577719241683945cb5a3f366e87df2d448cc3897ab96cb0ac4f24fd9562b2dee50c0cbb9e5f01b08d4fc0b1b114dbda45e465d5bcc62f6769dcadf1ab0033cb30cbf61e353e250bc447f472e149b09b333212a643e997b4d88f6f218240542c05ee3b960721ddbf03553fb4e6f29cb4c3402bfa642bab0d3a04fc0597a3ecf740671beee08a09883ad72612f5c9cc54a859be97185c688c4ed90252caf052d8aa07df7a4eb78635b36edf174a1c1b7219269ea68dbf80910b90e1cc9027f8a053d131c0134f88095b890554163593e857d544cf4354dabfc4fb9cf0d4ae2f9022d90c5a8bba0b3ee9aeada4753d161f1c7e79c0137dfe6e0b66013584b108d329f4d53074e9d7d0bbd6e07237d78a8611391f57fc95fe12a0ab4c08c50958e7977bd47924b86403f66d31308610c5cc68145f7ebc775a53bb90cd5f8bfa39ca923a7b20ce7289f5ddd0b9f9a007138f48db7eac0bdba0082d57128b93979c79db72f7bf68ad0e3debbaea480d3f7dc36262d62cbf8f1e7970ef2c7d410c76833ab1cc18972eb522e2f236b84a5800c5db3ce6c160cf1f1e2bb491eaa30068c553764a0a76746dbc3d7cea265be833f873676e96d1f745f86489f47127cf09f2e536af04b694b4ba9e3b778658d34288930bf8300b923e5e1967e5b30f334025014bed232a1d65db406f8aaf651fdefc6500b298b8b3b20f9ede7d6423084f5280f8f40ff37c5f76256705fcc10de2f60411b3342ae11e03ce209547f6ebc9654231644d0679505efb0f5a6da8edba4f49733378665b9412c9c45b7bd7784dab4cfe555c80eac604e6790ebb551b95f045b50e8567c1ff57cf10bc77075ad8b32e69cbbb20f7cda994ff91e883195d0110e734cb5135cd928818cf95565afbb9325c9c083f96b0e20225ebdb8e6b0fed4516250a0725be701e98c82d012ef5c58d34af11cd9c1758e59b6042659b3161c16e13954fbc26a15dc66d61721abb676b580bde13050b39c689de5b3d43e79d86e5e0a73f6759c58e2f9bf2c05a23d1c146629907a6fcc29b0a2dcc744f2f919c2b56619e937cb904d7daeb4dc844060ba349dc1d70276011aa6b0ee40479b43a1b364741d666e394a3f48a740a4e15e88cde3bbfbe6c270f066bd0d8f32578f1d786d854a9dc8093960cb0dd2e61ffc60e7d5f935256c73fee4282ac4a3f29bbee9338682ecaf2725f770f0d745bbe77e82c0bf9726b36f6baa49b7a130f1f05c805608500b5928bf5d1343c376be87902d9bfac5b002d6a6463bbed93fa42df38457290ac72f450ee0623b2546f274ee4d206e498ba124dc529e4c9c059ab9ed15a90d917aaed898b7df6e00153f62cd0538abd1868c16c3c7b66ff32636f392ca4e57711d2830ac8747d648453a9c8e26205eda79da3956de81cb97f690655047ce764fcd8f8abc393064538d47cab5306791150e99cf8e2bd5b19310210ff4bdba44a4d7aeeee6304516585a97fc6de976f8271d87111d0d191ac804cf38e29eee72d83e9ec3afdfa09f6f728336ff086b1e8813190a08ab25cd865299d61e2bd05792e74095f115b9b3079a48d4c269225fabb60d6628d5cecb63a0a0defdcf7e195aff1d917d1576211fc9e701fc4fad1d438c502701c2fd71ce2a1af8f6fbe2f3b5abc4341b4991aaea11a72d0ce8f198f3c9a71cbc174a3c751fce92416bc99b11085f8ac6611a30ae735606734a0faa490db852727c93f01a1b7c2a05fb572ed91204f55db99a4c8c4c2b0c4618a3f6ec4e634846cd6781a1b90ac060c9d34f579a5907062d50134849b76b6159baece4fbccdc0a827f9cdb2266ac3165e17e1b86f0683e8055353595345f377fa6d185be83f4ec633c18cf0bcb69f1efac9527e01035b0dedf500ad37d2ec9f4f642399b2ed7df5d334646ac8af8ffc401c77c350324e370729d46629f3841d03831ae8101039e3d04bea6e5d522b29ed30cdd653b043fd6f51fed2907ac5f713967d86a035e88164593816a42c28ce0f8e72959323f1f6aa026ef0c5b4758e81c8a5b16a9a8d8a96b7fbbe7a8fc9c3c9087397edd04f8f056163ca5106fe7e435bfcb06771fbc05247a704c08df1de42353454579ea85d18538b168fc01dbfebecaf796c1694c6fcd0cdbb074199f62bf940c760188841948bc00f5cd2a99270d9f05f73242de9c09b2a512b74c1eb69486efd7eabdf50c6675f70ed34cd73b64bf4dda21ec0e5bfcaf8c6dcca531ca5a7f03840f69ffa7d0e1ccdaa21a6059aa8b266a8db030ae2d6875d62390be836394f99620affef8c9bc3d7ccbd3400d149fe9c357f8e6009a62656baa1e47884dd5a401923c70852b5e27de4af28bf35f638f6c25c32bed681965e6635f128c6cb5e1f61f4efee0646ae227f8ae8a491351bafa4584efa164f0e4a1b3a684aa836e361f785ac150cfbd1b0def92ef1b126210f559596c012418902ea0de88b6cdc2f68605c33adffb5a9d2faec178f870a6ad34dde64c67ad24890ffb0d2ecd730df368b2b8782a0ac6af2e5ddf464e7562eaea59d79fb392e22b3c0735850c2878dc682b67934b7a97e0402cd7b43fd61c88f5d5fb044e566f8c962cf2d40063f8ae183f1d599b648a4c0f7277909cd014fb4e7ac5342e2d9528943dc338b07a00ada9314d1c6afa387b415adfdb207b3c19a7ddcdedcb13a9ed998d5b9d4fdfac2484715abf6bc4aea8df63c6086940c43d18c877da3adf7667e5a86a0035f88930e458c3028c3257db261c3491b77cb498f4ceae7635b0c3a8014388c64356fed3ba045af683bf8d2b71c5ecedb8e334d29dd8b241bf27a3036b5644a32c2d8f6e620fae34b3e2e0d94ff08f128fe529a6799c4b7e2c18f362b6c14a44766eca55e669cf63ecb8d56260842fdde8230a3a75b4482b3f53e8c7e3fe8fd3aa5dcc2aac5ab125645d679b313db985cba0c6b9d5331a72931dd33c8fe93f972e0e99edc0e528bff112b32e3fabd2355264f76a987e8e0edb1953d73a20dbee711ccc0f86dca50b1a21fee338820727f39793e6743aa27f347c9b58b336188510cda85c932152ecba1befbcd0f08039c04173c4afee20cf6cbf639d4eaddce33b1d6f38cba1c301f371b026c2325322086d68f7b1c7a9b1b4c2cc283ec2f1d3bd7cc2eeb39f27bae791514b3d1a2eac1143c013390e68d9d95f8fd1f881eef740b19e7899bc9e1473e8d04cda00970497340fbfd856a89aed555f0fbbb77e62c59917588ee531b9fe639a24c49af850b5bf97e40b96116d217f7eabc1f6ccf612dc6c4eaaf7cf45e1458aec37286a9c6f8115f6f6924724df61bbbc87cf6c7fbb1dcbfe6121a7bad3cc077430964e9fad76aaec6ea74ca2f3a4734abd3831e003124b614c56de6f533e3b0cdf916abef947767f91c81ea4b29522b75c71cc3e99fb2476867ce63674a9dd6d9facd8df5d2af484f229be91fecb469ef820e163eccc133c1352b2d6fe631d94a46bf5acb6ea1eab7202f3663ba12162702d6865b74101b5bb0fa77aedf230df2a5d4094e6b8269f0c62525d95d1e77621018df6cc9812fcc21592536eabe2c5b080cc925bc45c23d83fd15c13b5b2307261c7338b2f7ced2eb2cd2ebc27205719a56379df76b1e6dafce95422b6ed8df52e8fda7083a98ba1db0025a1e39652ec638d2cec00868637aec1d83002a6fec8ef83cb31b2569fd926da78939b76388bb223432e6a7d31d59856fdb8d83abb7ae516b05f7adc1010b21e7b621d95bdb94fd49ee12d7f2e4d41a2b25d0ce087c495efa8c8c5baade309688bb840a47f7179390e507e7588e291bec7dfab9fd5e1d487e96e51e989bbfb73af9a153a7764221ecd89e4da852b3fbed21574c07cb4c48ac07c89fb2be29523afe36177d8b065dc862b5078be4b7f913302648d0e866303b299f73d7879908ccdeac9cd1962cb1e37fad8ab4910f485f49acb4f613abce3d8bed0b7d33dbd5b3041bc61b44c4a6bb3dee58cebb013831a39365586821ee157d7d70d4314b99138afbf9b3f622d6c9c7a5698baf22a318ae16a40974d47ef0419a1c21b2dd4b61ec60605ba5a35f62510373d50bfe4b847b814a38d1ec3a6583a719f46eb4edbaac33e894c61e48fcd92d72dfc308f78c471d4f39038f3e67ef448b0bd7c5a95ad1aa5b8ccdbe4e2b1baf736d6fa0068131d33b88c0ca403d8ccbf32c7a8fff9aafd876654cf8c6c20f19eb801070c682a857009eb9725c83fc5ac257fb41b3d47973f9ee43bdd86f89254d8d88b29e14329c84204039caa3c2216b1650e8a33fabc94bd30b9030a4b2240725d6c1fa5ce003793252cf8d4cae06261bdfa0a2fd44754e0e09498fea281db8e3485a45c3beebf00c6f0b0ce70b1c12fcc93ada9ba33758333b811f932dcb5aa20cf417f3c067fa8d7cc30fb743644eed1ffceff161d076226f05a1085da05e2c717ea17fb04443422cf01ad3bb69470e9faedc8153d7e724d7f6773ca07a200f7d0f1632d27c92e73b986ea23499e3023d72b6c0a59b3baa4eba035573fb0f0d000d1dc3f5db5855df773eab54562ed2586b776e8a666df69f013dd054a09b4c7f8e85968abb391617d7402731d8e4c5af0dc60de6a93a838c152e179bc2af4e7aace75fe65f9091a26694a89d286f50752937dd329a3dbdd1318b8053af04f87acb05a9d0e384ff24e696a3706d9794dfcc1ec41d21bbb2fdd2d3dde683a47385cc2b4a6fb018a9b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
