<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e7932dc6661175594bece8057951106f227c217eb9bb299eefc8b07f7a8054bdd94d874acfb382552a371b98ca5ae5f1d31e24409d489071b9ccb84db67b4dd3458e31c619a3136df65464cea251f661209261cd43946a3b5fa1bbdffe73e7d40d9a0d75803d492d1b5c043f9563955ad121e80fcb761bb729924e8a17792d1bfae7efe4f3b402d1b2c4535969722cc0df5883dce6edf5f6c8c4af26fc18ac599acf0a9c4aa9e8fa91c8294fe243bfed7572649e41b4e4f05c7fe52c571238f22400886563906a0136f0b346adcf82fefa7c9a5d1139e1e27a404647fb9a71cccd46d105f8de4973ac02ad8e0176fcb8f075957375823c30901ce264ab5aa0581a79eab1bc9fa4c3b7ec7058d12a7ccd552071df666f420dc0fc628045428403e684adb8ed3640e942afa5f0b134b6ee724dd5dd0d5f5d9db8fd60e43dcc4a5155a13d513a303769e1f4064f388a60e15f9ffc6d616ec5d7b250cdbcbfde42da409ab24191f2054a97c01555e4ce0072b412195eeeade0f22ac21ac2f30e2c278d0ba21f4a6580f2901823455b795e437af462f494e06ca7a5be8e2b211b0fbe5d21fdb682564afc483fb97dff70e2e3d122c227bbb4548efd84fae497f2f31a9524378935e2d90668a8e70567a609004c4154f649e9aa731154cb637268cf3e1aff9be1c01c5d5c526b3d8b6a31468872b80f7b25eda8781b21f7bca84f90eefe8affd53eb0053b7d609ca946ad6b3bb95ceafdd955f4206748ec30d76f34c07bf485d7fcfd9a28e5fc152905fa0cf308733d6c9612698720a7d0390db947828e8cd9442a79ebaedd01defb4e649e5c17fbea9c6606d772f4d3fce2130089506e13bf21e43aa474762b396d73a8ee0943d65581d6d56f4ce015de81d0eb4a765c34eb26e849bdc5743b8fd8e9a255144c9d5a75562755a80238c1b3a69c56316e9c14fc9f611fde126ebbdff0d1013520b38c909fd2f6028d696452612965870a916137bb801bddb2827773c0a415f38a582d4356a75fa2abd18978fd1dba54cb8483a467af6b67268372e6f63f029451cd763b82cde21f0399cf66c101ebe00f328e768a2637249536758a5bb20f13ac3ab95fba5723ade15eccfa1d80c1f829e6b4bd1d43b880fc781131a356ea0ad6e3848052057631a4fc290b2f46c16f86f241084d42756c6aeb22be06246841eee8afa967be37b24e8c2a93d74fba0b368bf7d0f8146ca8a63eb76c933634e0a31d692227b5e26cd71f3915c078d3b29fbb9b256f0ac8d589c54dd3a4265f340d9c7ef01654aba2f40540150c3576bc8b8729c92e22adae4d071fe609f453b9a63ddc26e6d3fb118fc3311eaeaacac82bcfc5aa73551ad69aa7e1d5c47759637b264e25908544e8cf06e874cd0c5a7c36f2b3cd69d2b42dcfc555046fce0071c9ced69fa51791baf2e2a234b5a9867bb40bc88737dce91e5b2e18a3ec5b6391f1238908c37992422503d23f17ab4243a987133333ca88f7ec2904387b9c648e29f6d06faaf8e8131f1eee4ef5255de0e5fd0529658c675f1f87fe0d19a091e4640a486e7ffaa8340a792783bc311cd32c8bcb94dc43788a18c891cc9d28098eaa9bcc308e6421610325cc965e85144be8e27ae8b7a35701e1a1d56b75fe5d03f69e25a272477cbff9d3d42f87f64fb39cdd10b1574f5e3f8ae468dacddb5e3eceb18803047786b365daa08613c5b6f6828a4280d60cd692156d2e6d6bea4c9fc42df1c33ed324861f302799e26c7a9cc6a59cb03206fd75ebc72207672fac37c0e2d708484c44697e745ed60c8a4b67ac13f4a10103ea7d5e7ea02d867ed405a48cf5fd2f34613130417aa7427d08e439e4f3976b776db0c5aa168414ac60e3332a2fc6e068a3377413cb12aece079d3f71ca72bf4d9139989035f15a2f01f09fab8828873c0e0b8c5450d3c2470b2ee48122931ac879f115947b81e38dde10bc86ed35024f18793da9024bfbda98b33d25201660455c561aa45686e6a160c62f5fa1f15ab96153be11f473fc9d04c895a6b336ccd5aeb8c3962a4072be1ae2d6661cf49cb6df780342e08efd5a941c0d96e8736e0ef25622c99c2b2959be4e12e8ff119672d4d2fb5c88e3cc6e8c8ca8f27ac8cefa8a82b724d92355ad05c41b51cd8b2acbdb6629ab24c5f14b3d1983d7d69ae5cfdb94d68bd0926d81ce5023ca6637781ce6165bdf2cd79892f4eaf9c2d719aceb19fb92d517b4789f191c021a720fa96840dac564feefbf147fb3c3b219eba07b9c14eb1767e101bec453f9cd94014977cc8719aa297cafcb6b0ac3f0e13866d526a991358a5991b5a5691ed588761c7d8bc90bf38d0bc19afc86e9396c56b34292b929d5a951d18e8085187c0cacab52777db13df4c63f00eadd71ebdd113e896747fb7aaedc1ca2f1616a142bb2781c7aa3360c10f0e8ed688a1b75a431a07b8197413f5f89988f391010f6f6cd3b8f856a8234bb7019d83cfe79d0f41aa3453edd3d9f5a8b42cd917549a8a4a3aebbc096490ea52394f5e0aafe9de181155eeefe629f46f06524e301a31c9c7f22f630e77785bce0617093fc838ea6284ca56887c01e2209a7f23db56516469d103dad27a56382ce7cb7b90cdd5f9984baf151adb09bc24ffe2d6e847dbb1c001b0b13379457ce7c8649aaa809ad2ccdbb3e63571ba9570e6ac420cd47b36d8f6fc2a526f3feddbadc335b29f65aa599ec9a789de0fb0ca4cc33c1abcd0964cb499c1615868e7486be669e59d26e88901d3dd3c97a4922e8790f85a0265f4954ff399668915028cffa8e292569e133c60c7f297ec14e6832ef661f1f4edb935e57e78bc1b82a779af72c4f0a1c2f4a7969de3a13650854011a8109e3699110fd13a84454dd0f2c8166411f5f31f49decaa82e5a46f44a142775253a9d01bc978c19d72cf8da36336f9303861374b34e14cfa1fa69b3dbb6673ace18b63fc26622975c0d9bee3b482f603025fa04ef1ff7532d08bf4a42af0d1882c9c527d3978614e79f331023e463ba9258a8d97880004678385bdead3e3a57479c5e190e7f4885db204e047504730377efd99be8b3b96ed0e4288db55b5dde1d056936bca8b1d8f38add12942bf08a70ab8c2ac61a9278f9de0a31e281a5f8ce0c510a24158ce2d7fd14a5c2f29d4a15f2998ffc3b61c723cd9395f7b53b3ed14b28229744b50391c2396b028622f00908cb93ec65b48f86f0951494be44b7088b356751b3866ba77dd5343cd92dbb7584ee6a3d3bde0951ef8d2241d2700430fdcb7ab4a52137e16cb1645b130f782cc05f18cd8ef2d53ceae42f14a50d49a1a9b742a804140f2ea166bc02750a2008d47d7589613470074cb647de1ff060759bd2e2066f4d3899a6d28cbc6a4d853db08f5c560bbc49c2b56a4ae5c70f5c42b66e2da26bf20b258214d741e913c1545577b50335df64ff0cf1e40facfb3ece2db37cfa372fa173b26896afe682ca93a3f1d1e0b6e5381af7375a1d2203363079e58cb1f305139959939379063239f72613c64043344e0fd14074a43766823ad9eedfc508a23d647a679b70aedf08eab4ea3c56b03a17c622e72e28f6f88b6393a6ac591d4c63dc8cf57e1800dfee65b6ed793ba7b601c8690d804773ee7ee6cb75f1e4c09f15c29bfb7dc30dfb1d65b369c47820cbe3fef1f65c1ebd1c313b9a20277b9ac70856919cb3b841452379e6180d1bc997a4e3c3eb41c58a4345b06908e254dc2694f4cc78a429b6b3b9223087443cc908a7b4d604fccfbb1683dba705a248f05fe336fe69bfd437b06e7d4d60bbc607c6bc9578ac8ee64441ea1051338bdb1cceb396648a445c9cd81c76cdb3084ebd5c9dbd03b627ecad5bd48597bf4a84a0500b497bfce739fb6b3ec080911012eb5ade65f2c9c8d5863df2809553984690243b63a687a08e6c986395755377e52206574b1b08825099a8657e956986aa98e31bf15b37a862c64b7d456956ce472d7c8b6b5f6e4ffaca3c79b1788dbbe14a4d6135678403fc0a6e8b5296b05f77b2b9b6b411eb2613aac35b48540344ff23f4a025a3388fcb2977f0a9683868b25ac8c87af921a3c961764e6a10d14e0fafcd2b217e53f6bfde96abbf4ee04167e19663e83483cf15da2b4b495a6e2a07a98efefeb721f93876755bf33f64e370bb973c4652424de44531833d48c0f8a5feef3d2d38cd478a76a71288d94de340b3726180aaec6e28609cd306856abe9955cdb82eafcdc1e31d5d48693bfb571a36c4d819cc7b42e161ff1d2d751ba81982289530b7ec4a24cbb1fd2001dc5ea00a8afed5468937e9b34a7d24cf4d48cf8a4ebcf651f789c3dc8a597b7884cf8e4603f4954136d35c41ea31d86cd0e2e19510fd7006e3a20a0db3149b31a659b0be1600e5602442fb98a6961e1da9dfbdaa738f196c1cb76f6a72894429a90159e3e4a5e47ddc2b7b2b39948f19b90062a79b797b2b3aa1b4e31816dba224d7e2ba95e59b019960327fc100cc5280c09d75cb4158f2bf0d14831f3476c4a9fc604be720f5a883f5e31b6807297b7116527475e1351982a316a2077720c871dae544350a2cecc3a54588ee2b475e44ff4bbc2db9b81be00eabf62dc7a7ff71416d3851a66f55cc429dcb13ae2fe2957625e15f27964d650c6331ea133c5855d655df22cdefccdb3ed6751af50aadf0dd5b4d324be784e4932edb4e67c834d40109bbe4c7facaca282c5ef124cd8d980cada6fa1a61d7bbeff7d59913fb1bf4958e501f3fa1d9e6c43685ddc9c6e9fa696c6312744ab56d1941b10c1e997f835a30ae624a2a39792dc2cc1ea4dcc12fb25882aaf9892350278dcb70a744d36d7622d777c6e117f00897156f5f22b9b78ef09e9eca35649639b987e979e6eb5b00d83a269c0a4633059c52be4699d707338fe1e026b8441c1649b9ad1b47f025ca184ae65471a14f5ef094f5e79ca5af23c2405f47bad39c4a9bc184765e6300e4451539ac4ebabf98ad9b3673698f239bbcb81cb34551c898dc890ed863d41ca47ffb0ea42df9ad55524668da09510edd0a431693c3d526b0e1d5862a25b11789d30a34d659eff2d67bf32193ccab84bac69118ef3c91843801de26dc39058e99fd5785b072394a0ce07645ef03191a688f9ab64108609a5aea08317bb191afa343844c4cd96af2ced775e727e72b0c72debf47c833aec886e5de7fec7229d0e74e1c9d6b7dfc30020b48f8b03413295222a6eb16a40fa12cda8f9f2e502345c30b3d459fe9246444de51b3123ae2768f5c14b25471b3ec409eea15d6f3f6a507dc4c96a5bb583804284c1034bf6831312c28e24fd061fc1eb5ab5f31063be9511f480ab91b0fdf6b5a3916956ae2049e0686ce92d0f19a219f3e4fa0cb5f714255652ecdfa9c48c135340480b19e30709965373229365214c39f1b1571ec268ea4911a8dcaf72da4e99da2f48727caaff9f505b633cd67c2407f190b894325f7acf65efbc462da13a51532066e29969f47e300180019d32a2aeec2e65667d452efbd04c7a6320f4cdfd83cfc78f0764f9a4b71ae1afd7733dc15469cf0cd68a593f3dde84ee8663405bf6ee89e5f76d1454a9483edf19047b4df228ab4fa5d6a753c8a751424c0348efcf2d1e2f82fecc6c12f2c2fef4ee5b9629f545c02a831accd53b0faa07d38323d73df492f01259f3ded32f9bd1f03b21cb8d529eb2703a9de905fda99420ebfafd57d80ce53c27d3c2b275abe236b3d5a9cdd95ec1bfc4c782733d1d3f8858ff35836a34220c924248f23683173c015aca0fdad7fcbf79d5ca4f90b8d058e1a84c32a20fe4f2fa5c9e34eea8220c799070043c2b8d72617e6158b3ae19b1aaeced72b6d4a6aea406a446e60e8d2eb3d1dccbde6e55d0b28018b0715c33091fa8d58875026debb99d082e33b610a9c220f91343a8cf556f526e95f52e2fe1427247cbf45e946cb94c2a4b6985ca043ae85a0fb02aa47ff96abbcf47a1c3a925de70430492aee1e993545a9bf6e94d0bfb60e57986e1d710fa75639b7c43fdaf1c9e50487ac5c2f550f64b810ca8f95c9f4ad91c9c908c6b271b02f6c1c793743aeaf20b3c39c376c6a3503a8997cb1100de6ccb2134838ae60873d2fb992f91fe395577bc03973512d51532c6ef68f24b8c33f5dfbfd1a671f08c5f1873674c0b07f0cbdce5efcb188cb81cb6b6f1900744441e071d523bef3cb846ab4aaed9c583a01a7571370728a65326a4b4e332d97388a8c9c39f98fd846f33dc7c5cdd323af4eb773001c3d5044e9335cbfb6d548ca8e8ce2f3e815d7a75bdd556a9fb13f9296ce342942a6941ae6f3fed659774290181ff66aaf2dd29b5e415b394d78315e5668f1d5c90648213206a36a7e657b29d07ceef0929e14bcb47a24a434760cbba47853bd624fa75857e7775be70ac5e3604f7ef850d346150d8f1f9c854ce305edfdc0be1a9b752dcd6d9648b29abde2ef46f3b409270b4f4ae4fc1ce19ba9fa16e67406009880c062b6f4494f913289ac5f351289e8a336629d1a27e4753f5a2f13d61486866a45c6937d40dfa52a39be209051f82a3d0537470e566c2dc97f213e651b4a19c7741247f52eeed1c5df7224a7ee9371d1104918dc183428a56141cf08caad800099412a30cbc42ce8b17b7da37573e3ffa06c240390ad8fd912a969807a8987f86ce2a6399d7c80ccb92bd02ba0a6b59288f85b4e903be5feaf43733363fc2e4f502eb891ce6fdb477dd9f45065f1a54b30fde1110bdc1bf49e49469e39f2c663c0c766c9a01b716987874dbc0fd2cf499908f8a81eb5de5fd47e8745700c5b9916855250811d980caeea37a812d9ba214f10a0aa730e2c41402b6c84db82e75bb5e0552d6240c7450950aba2a46117de5c14e949a1611c706be78534596cda76465bfa2d2c0b889d028b22500f60ddc53b36d83d04c495078bc8945ca5208fa6cfc144b9b0a07ffb76b09c748076ce95299d55f6c4fdf1516a75e769b288c821d9cceb373dd2979f9ddc400dcbd3d4ef157d22875c8f4c27641c120687ccc3f7d33159c2d7ba98b5b42c4f9331c0610d79314ae8b825b58ee3b1d246948d8a8b4e961f737591325614dcf34aa1d953c4a40b6831f40b330ffc3b0be9c421d71ab49bbc039d7852c19b4016a70f282e3b1648b0a1d79b1ebad3efe21966c478caad82630f30e5dc0f0d87333a3ed1b2b7f2415b46ef8d397ce52e0c02a85aa0c9ecf8aa7fe4556f0578df415b32703abe006300f38d98196e1e552665501c7ffd0ba481c9a1aa15eddad0d1326a982ba5ac7e8bf4befc7f7d0f8680fbfc1d75e724c36a4dfd19d33e48ff17fee8143e57ee4046b0c9826829574ceebec38bb62ada4be5225bfd7dfd0e0edae5bbebccd10d2ce5e6991e70aa38b87b794e1c60ce359d19102e14ff7bac8472d33be9a969d3ce6719631f2124219b828c8808ab271a91fad9a72496479184e6fc8493a21786d3358161695fc2b9a3830ab7db7ebef704ac073327c1cc39f39cc5f054ff227aa8fcb99f29e076a4d574ccd8f5dbd01df13ef86c80b2b9642d1463cb6006a70cea5408ea2ed075eb06209a43671b0f653e4832500bba6815c3abffc50569e4fa26706a295e5120f22d2f76e9b63cdcc5ede7dac2528ff209f31abfa5c7ed2cfd679efaa605dd180a14cc679460c3ddc520a00c1c2fa967d69494bbf88f17d64ca7c4091e1a7dc9076e44a8f0592b80e143411359a41c2fc0b32e86f00f0a88a1e3d8332716dad21533cc6d96bd96c3603a4fbcba1460be241f71e73251f78c11cfa8847b2a6ec6fa12cada8835cf9c276dc38190bdf28e20808fe0ee0802bcee49f587b7d4a4314dd9195be627b4b1a16c8f029747cd54b5d5f3b9ae835174961abf862c55d7bf57f28f7c3f45836b51034416b54bc7314160dc341a67dab5fb8c23e640708c62d11740092045ebaa09af9fa1939c4f3861020649906cbf68183ad5cadc018af898e9e7efc0cd4d9c5e81f0788c3fd83667caede90a511704ad38f6fb8166e81b6439476ef0cb8bdafe7d517fcb383ce7d15a1d8cc170180352b83318a31f1eecf76aed5f2332847c9718f47ef5c450ff09a1d8e1af433fbc574d8d908cad0ad8a3d6bad78373f57d5c74a95f342cf68839119b1d61ef8e38a0bcfb166c278377385cef092d13238d297b7cd48d03f845a1bc7d04b76047bf283beae2c99322335129acf036e52a04d6ec5455be84d174e5494abb36111fc1fac4a7c332e023fb41e359300e971884243d710cf2171ff7879dc6a253d7cf19f5b251fda12fbcb1b0dadcd0fcf717890ca8b5885b992897bddc22576c93475dbd4e2dd856e4655f4642b4e6710f4cb3072bbcc0e7eb85ac00fd1361f5494098d2afeb6211a4cb533b43cd7a31b37c7eae1522e0ef4d79a77fb839e4c7488b580eefc888bbe8ff9b26c695c591b4768a12e65903ea196f117903bfc374990901e54297b29d84a28e201b36a68d00e3b855951567f6727e99e3ed33ea302fb1cfead95387e0108e53f4f326b8905cdfd702eebbcd10556df1106d1438987273e574b1d8c5a181695b0797138581bed488cce065256ca61021159ee1aa2287880b1cf092216adbb86b257bba82ea2e42e0f9bfe443f3ed05612fa29e302542c471acb9c31ff80b23233709ce00a1929760b1060fe3bbaca5a33a85c8145ab500e5003474f8557f3f2f385fd8ee799fa96685da0eb4361a11f020b25531020dde1bc4508d46f5f2e4b77a874c3373b745855f6263637cfbd59e29467de35d447b7c980341d98f832dac89d3a96a76efe17619797ebe49d0d83815f892394c2ca5cfd809cb8898da69a6772062ac11e0d3d564a330fb1964a1f0105316f39372e0ebf29e89cabef1fddd30f095517b04eeaa5db90ae0298ac21f54d258b0553b5dbc3548ba16494b63f3d1c68cdca344f1bef592cbf7355f2f09e1e8cded1b3f45d94c696bb2a5cce526d18d75a1cef136ab8921b85ca260085c46064ec2894d0f0bf210707f691c56aa01345986bac652c98c28a5fa571e090222909f28d2a35772f3de28619e3bee14401fe5396584c2cf81a35d49263594977c1503473e2d0c3444d5fe472d2db0bea31e9946fc69a9fb58fff2293bb01403c896b5d65ca912613f02187f26537ec05d5a9578acd7de9676697e4bdccba94e703799bfd76f19b53b099e29bcf2cb8ae36c9d2a014873f7d5a3390f7d3ebd0b569ac166c1afb6155ebb65ce8179f3f11d2f913c439a81869308955275e305211815cdeda4675e4e264358c7a96112dfff3f1ff0c31405e7d0c1e5cbc15334734659e9f50052b4d37dc944b3c423f65174e3fc6bd4043330ae93bccb071f26cb7e57b8bc8be1839d4cb6f73159f15a73d53fb419d80e331de77d2571b2e01ff478b77534a202e4df882c22f526344172e279e8d9e0ed159f3faaf7afc4c0a716dec0465804fdb2f8cfbeea4f787986d657bd7231b4da2c4a9107ed4bb92a753f11116614172a69cf0947a49ff202f71574c6807fcb0c3128ba95bb75d25bc3125c936ed760ed97e5e353e3a6f132a64d7c4787038c6c7ed823b8e33d9065308f4d248a94d5200c159c0b5639e1995becf5490b2e5f14b47c2c9489b1c315ec1f93ac9797fa4b4eb35d379a281467c0ba23ea2db068ef48a208c1f74e07af25a684b9c3ca0f72bd7ced544908dbb6363d21771bcb985ad6888d1b03da7a16a1714bef4f50346bf5598c6f5c010d16328ee0d56bed74ab17b4661fcff8aebfa640df3654fafef0fb6c8b6c737c302b013386afb9523ecb022379c2c2bb079ed8173e275675c125083a56d6d079f82da2f1eeb73687244dee6a33492e232810a6f8c44742ea938ba9134904d07c6b37e57157900408e7f14a9280b49e9f4ae46aa378a3c3f884b5e90e16813f1ebd32d0fa16d94528f9092ac91aa18375ff86ccab1552adca76c0d878b37b823c4d6a055cccf317d1f26a91b063539d2eb0e19b621f00a43eb90d16663e0118ace667926ceaa2f0a6f64ff6d6842c3f36a0ca60c0ee8597f43b4f7ec22951b74100203f9dad2c9a5e100f6ae09f4dedee5d232689eb0401e27b1517c66ae78ef2332b5c51c528bd247f20e3bd28b85fddbf118f7c590b2cdd608d62b6b0beac36d7b33efc9b090b2f49ded27172e542e6405acfc4fd7c25b78be0dd153d40070ce94d886cb7a0233599520e08663e028017e57828a46b56b779b075a214e4c216c66ca01132ca3296d1c5958d7d4f16489c2272e73abe70a70e76105100ae98b83d2baa8ffd60407962a30aca5902a6365d42b5e79dac1fcdfe1100923c4e5016f86bb4401349c2c688b50243e6234e9b102c4c567963c56bc0fd7e005899efa3c5c7150ab64ebcfcd4dbadebe258c23f7eadaeef97696e6544c5638a2912bd285ef491a7164fca028cf1f2c8b5eeaea98e3981768f873d5bf7c0901490caeddfb28fa69c01423f16aa48aceece86e1e18f5c62c567ae44d5ca23cfd063da39104a74ee683496fb0eb5a23e26ba4ec0f94155bebc51f45139b6da2d279362787b8ffe94a221c8d4061ae0b831bdcdd57846f36bab90e7986ab6c2ef4e50a867d7d31ecfc945a57866abe2f7404b6e79598a36d9bd117490a5107ff15b8d758a135be1ea8c6757fa40ae818e9265ba6ffe217ea98392e71ba0ddd26397ec5cc9847d41d5d97df9d152f561ec2e5bf52aeb29e702508e0b075d0640339b0840ea121c5cad99c627d4e8732b7ccc363371457eee4c86ad36a740faa69dad0aea05d92df3f96c9bcadb1c9cc322b68e0dca8b1f84e729d78796cdf54fb718afebc63519015a6689e25a9fe66f945f9324c6131ad18eb5889b1bc6ca432ac64306401fe66d32e8d225ec3b00557fc24326230295575c20c15ad3ea414aa3b80fa93b80f15d2d8152beb838eed32c2f87ca9902d13683e95376c9f85d417950a021997da198c09e5fee8ba0910c00899aff359ef25b454528154b21b12bb3f7dc12fe6a2a5188e948a7c71acc46fc5813beddf7bdb20b80ea624f8009fded689654b534b290c209e88f3a13cd6d4587ad9cc4b80dffeab540f94393685ef9acae5ea3ed650eebc3c190686c794bd3fe383617f24380912fbf4c3cebd7de051aac485c4c655c2779b19a60ab1153652ee36baa51a67528877bdf934fe6929607ba4dca8c02c4a759fd72c20989c8dd49ac8a9216ec99a617def0b99a6ea916bcd40bf55d43f5ecff6e754fb2d5e7ab15f1a6ff7b44dd60d64f9429d4e84632a02c4a78671165895840e7d580dc2d1eac88a525df7254de4e66d205c3d1890965b2cf8efa73d28749c1d550eed9f8b958b2ac164046c849d27a8275b5a06eb02ea796aa43d6c9f8e12af8e9ae485f8c4c6e5586917f9393c08767bd3b147ec9fe12682629b8cb4d0bf7b96b5c1cd533fb2be4c198c52f882a7771f2b9c1db5723554f71e3722454208ef6da48772e2e5975ef0e61ea70f6248d5a2312ea9d1d3c95dcaa7789f19ba8417c4203304d230b0f2a474fc89ea25c097357decebfd67e78d2f858c980dd01a4c793c4697b6e2ca86cd7a53b819a3edfbde122f00abbef360b7275fe08c65248492a100989144915bbec76c0ff71c35e254707140321ef0582030265ae22e8a8a01b3591bae0e6a9aeece50198023f1caac7fe4d4247311bf0266bfc3eb030378e2fd7e3275047d3a118c8b7d17bb2366ac420f428cac5d90d8952808c80fde3219932ed587f61cb87963e263b99b2b436c797a2d8eb0d5f3ba39656b252116c99f75f2e95d676cce359d627980f0ca6df560457f5d45289576483a77b6dd6420038fd1ca02c15c80e0f08646a2ed23dd4581049efb85df5a8999f61718189e85a0050da2e5eec8c98aa8a340cfc6bd43a5ff289acfec25cefe027f4e546811ddd312fa7b5fee5f7e9a91133416bbc75bd1875a76e4778d27e4f075bde846a7e5eadf89a66a4a9f20899a8d48515a2a54a6e7a8f15351764020a649c3d8d105edc10b3cbe16f476575df651303c37885f4bca77dd874a29b0b1aea3c17d2ef1fb7f07d6e646d89471e368570e00201afdf49116e69fb97cf805726bdcf52e02d52dfb1943aaef5d384cad50abc921fd84609acf63c23096fbd54e3cd64fd66102efd2beb681d4d154150e31771adae49be5f15949ab7fffa09ca1dd864ab7e4ce986e1ee80d7e9cfb6f4607cf05a5740ad1d6c6bcb12f3e824cc9f3c14c44c2146c4da69ba01e96cee4869324a61732771e92081bce0e2048d09705f2f091c983cbc63b341ea93856a18f54b3c36101fd99f565e8c058fe7ceada4eb7b8a4fb843b93e1f3fd6ecc9f1f1e3f1d9fe70467b00dc1917f4a6606457a500d29e2c4714777523b859441386265c4895fdab380725209b439c904966bb0d6488f47ca072742b355de7c00ca9b220365023b55f8d57cd4091f555463e1a3925f175e8d4a17c768996c66b04f69ec887f25d246cbb5fa060cb4229a24df5a621c5ff505e860bc270a44cf49bf1af9a3b11ee84bb2afd42e83a324a907fa841752b4463cc69a7616b458ef3b4c530754fb2ae06e4b9d063584a1d4b626a68c4ccba501dff24840b9ac5fbc8ca1fbda215995505121dd5768457b01ab5696631a5605fc1073147c8b73308148d8efa8373ca25b0a708280451daae280d486d4a1c7c805a05cfe369da1ecec8689aeabffa7fd858c33490b87ef986d595618db53a9f414e997fcadea3a6d7cc9da4661da7fbeb84e140300a51fe7e5357a213dd7aaac801a01456ef539f5dcc0bfb81640264959d381ed91fa93014fb70a5f2e96769f23065214fe69c1409e24ebe0c02314d6f24fb3d6785510e4ed9837b3844e9f02824a1ba3491c8a75c67c7119ffd8918c4230d07aa412cd723d541e9333f51a13839808f0cc8f9cf51010515f56d3798ce30f23f932350205ed838b0c24d8fb225a956c3dc03f245d1accbe350b7e729548cd5d3087db42f1bd948ab0a944d8ec3a96b8a14778936eb5451b36032667bff36d8326f3413cbe31764794a15ec37849a5bda7dbcd295f85ab481afc564a101e83e112a4a7518954e3d6ef0b5f7e57a0a60775f755b76260501d3c053795ba6c2a02d85c71137c4e44f83286b149b0c76556fe974a9d774811cc57d727b5addce2b1c70754e7bff691ffe27a8398fc799ae96f4691448e9542ef85a60df0044b8dc2bbdcfed1c8816625f2f79306672c7df6de32db6dd81a2b5570d291e3006dfdd0b33a5419c2b68938a66081f6bb532f4709bad5c84b7caeeb0ebe478e31de3f90d5ef795affa3db19ea62794c46bc3f7c04bcaab7e1177dcb271d9767c121b8a9af8350bf566ffa8ed7943059290be38664a3ec1ce42598c32526fc1b415e6b881b3561cf386a035318be224f0f911efd172bedad75458e76b71b03b1f3e110ae6e742d748bb156e2b57510fe646979ebb7d2602f5e583031360cc3a3cd8464bb9c89a745271d7a4f644064c8df0cca6d8d8d99f7e6195c3e92051a5b975ade984e2995ab0523f6757c111fee964309b37c5043d5be0d7c0db2c1bf6f927cff2c8821a10fc9bceb4aa3e7bb35e93d2c17af2af73377c495117a6fd6aaaecc5363a309717520825085bcf3a6e581405eb4f1e271d765c4d20fbd4e8ad71ed99bf5123689d064a28a5f66be53d6281d939355cbaf10b2e7b7c30c9a9ca5acc0c8db1f2ce78ad7d60117291931c6b9fbc3ad9fef087264f71e738b68ef59312b26ed76070236204196e9a342deaade7706646e616415b2a073769ad87aa91d7c5b34aee062a1bc232a5558d7a7e73528de023a1989caae5a5e81b4f7b2ec5d793445f244bfa61f7daf34eeb2ba6188b9bbb98054292b1f71a72d05dcd8361e4b1e25534e335100a38bb225c79c16816890254706d2f57c9a6d6bedc050c78b59984d404dcaea4428f737fb5770a69fbbf37029a8442ec9e571ece95476833b8f130a6adbdee215d10fa20200d44e6cffb569986c9abbd49fd8b31a8fa4fc77a5f79780eeb54012bd10960b20d036ddea376ddc5434ee88c66273cee1bb67b99b3e3b3edcb3b11bd41c13e4972222f8fbb753575db642c9c8f9563e8d6561b11c18163d140df75c57270072800749a8f481901953614e9c4c365a820a67e5e9bf89dc92e11b03cc48baed20521432e9ecd059a4b4629fddfe78a323b42435482ea5bf67504e86fb515e26ecaaa45f9d31f5c1a5abebc4757cc911eaa1904763d5c56200dcaa339e40faf84c732262c9d75ef51e4d69ef3f7bcf5152aa6ff2c9ab8ae16b043cd0ff736adb9eb0bb21f2f377d1b1f2e8c676faafca05a06bd4b15fc47bd488ce1a05452f7ea59cfdfd51b502b0972e94925894735e3be936497ba0e550e6375559b00e232900b82623d34c753789b3d1ffdc16c1c930ab3f0f2152db6086ebe9220b151e26664cd275673176af9206c2022d1084be3ab4ab49d9a5e7419fdad2e4957e6628bdc0d14ff1445329bafba2556af40860374e50bcac601e79980ec6214837fd17e47eeb8361f2b585cdc29a3cba33d05ccb3a8a73d930bef8c3ef5b5972dd24b4d7780b8abbccf2a75fb47bf30f8e4f844f5400a60d7f94cad4548508b1b79a779a8936cd665b3d63996465752c366917488851ac0dd48ec785a32624ba1e56a03a43ac953ecec914ceea8fef4725d308f3dff2dae8ecf1cca5663079056e7de5215c2d693f1595ac9275f3654758546856bb06cd0de1af699190604d0e59a16831e2126682582a29ba57a32d17c60b817d64bbed6f0a91285b413b1871fe0d631e0f2d250a4bd661b240cd1a2e7dcc5603eada6d60eee7bc8d162bb70266c70309bb2a148b770e8a69439bc441418d893e317ee4ff500734b667edcae44f8c301234d42c9be94d5eda6272b72598ffc42a8292699cbbdc4183c0bd7e7f7a04188e39ff6b7db63835048fd5b3e0492e6d73b21c9fb0887f913b7eaac133829f17d48e0efae247e71b1401ee1be87efcabe34e970021a4bd2432d1e35f81d0e456f7ea1e22b47fc90c252c315b888a6a59744f07c183ac8fad86749111bcaefd5518abd500d3182a9debefbebdeda0b049035271d762f31da68edbbe9fd69b8770da9cf7861c646e8da7ff8214ba38e79aeb19f42359cdcc997d11633fd82f776796c7e8ed517808fbd666e28d48da9a7ab3321f24dfd6ba30c762744f1758b483a185c146d19bf11eb3bf2841efc3660451ecc37c43c25d036d03ba93e7290f1a4ec409423ee73dbdfd68a86b729504b52359f83e5187cdf9fb3fb9b869400e1b29b4b23f4b065affbbc051762c7ee8e17b2c97e534370214a6076abca14215f5279c082bb3b00b16c911faf0e97c61937f56b16c95415a66d79bfd3fadab53d4e57841338d75eea16bff98de3e1758b1f2c017ad69089303aed3392636b7ce1ee93234c4fe238031b850f76b83234c938b7f5b52eb9bf9c0cdd00346500e565d03e678fcf109682ca83dbce9b0ce936c9e4ec04c7f3434b65eeb49192f1a386ed4eacf446c66ea57657cd03bdf5808d2b51afd13aab6440150951915c5b5a886e8488db472b64e985a3a7afa959c1552c009a5177e335ff5df0915ba15bed8a92b1f54a4c310f93047f7bd76058d7c1a05c636f02ea31a2214fa73c1fc7ab97d3a208cbac03bb705f9e745e58d1d4d3d970dae241119bbbc2ce0ca1dd6f20f8f62f8927010cd2eb42273413d4b7f40c7daeac9e4a8c456cfec996e9caed5d63021cedf74af763f655328e450b42a141b141f6f689e7b5dc1d2067b3a1a49e1fd85dc642479f363270b0dac1ea00a03f3c617ca6fc7bfba2cfdae492118d5c63b6cbb6181178fea81313b8505ac399797ee3f5f4c6e1e1ed776cfbc16f5248635397beb11dbeb4542239226af7f1db2cb6f423788039e553320e52b804b30d1916a885a59f4d3beb87572d01361c1606253c18e6e365bbd5e39a970a5bc0187f15c6b90d39d3de02555b71e252e888fe174743a71371d1fb82353cdaef37c8490c630e60054fef3149bab37b18bc106390864b94061a11a39249d4f9ae85e3249d8c7f7e16cac3f3583e07d74cfb289734d8cffa2d0a58820bbcacb393fbb5f82dbe15e6b3caadb408a8ddacb0432fa38dd26de815995132d076b0b2c967e1bdea015a33deb6943652185bf2cb28d00f8541c0be6b9f782e79a1234bdd3467acae3d4932d50b4430a6f9864cb9e39c518bc9bab932661e059c083047f4a92fda9c80a5e54483ee6a9d2f0b1fd31a21021c8fe325ac59bd07c28fedb9299920a113d1520288bc6d2fb8f67f4977322c8ecd8a1b54815a3be60bdc75dbedb0033e1469891c826b40a6b88d3ae8f4dd4a5795c85c11e17b621b57aed8b0cd9f4ebb14daca2c09e022a362936593b3271d743f3d413ef9c13528a421678308a6f4a141f9f0870dd11100771fcdb98b79fa5ae799ec45166a46fb3cde4cd1eaaffe680a54237b395b478df0a08e49f5c29c865f1be3b783b112aff09f346ebfa4dad3a1ad3103fc9f16bb6961f215b5ad15e32699dea49927834763fa1ca5a93026f03871ffa04a5cd6bdb49ab9c254f2bd9fc028e19ec5f5c3fdce1d03fe5929f5fe8766fc59ac5b8c06bf1a716a0e5ec412c5dbf15969fefe1522b4c6335c45c2f0a66a587682c17e2a093083f7852bd1b737eb8eda1d1893823831bbf449a566f26c3e097c38865f4addce93ed91fad927cdf79a1299ec708f451c635014e40d2daf587cc143bb0549a474544273ee39719620ab1d3825c6d0a16780a69ba7d920d7ea34d755ce9d0592f9db991a2a9df4eb77e6d1178593cc272ddbe2f4cd9849e620de2ad851306a84965cdb4fade4d105410e5a1337a56213274a1d50130d8392b810309d0014d5cd60af198a3ee91e72139992baea6c7635cc741f2960edd19e0f3c0ec50c8deb6d9ac970137bf2e021f5933ad89ce9c864aea2853af05c22215ff19aa69af2b2f084edd2faabe07c972d4a1f7bd0849d76bd270ad07ec4b6990dfac0a65e0efddcbf5a243dcc7e7051c0034a09e0009d739c3818e1b2a938c0d3bec9b64182ce742021feb3ff1883a9e7c7f8bb572c8e6c2e4a9f83a80fe931654fb3a2bc4dca9224038389ff780add65e3c8545d58edf2621d49918b831b0ddf4df43f13140bda05bf70a06d69f605a78c38407acc2484c6c6f35adcd94ed7d9f60e84150ff82b40c1f854f81fa1d8897578497931c466b7295697b7faba02cb01bb1875dd9f6218f718a39f7cce0bae90c550e32d47013fe4b454bd3c606e9400e13ea511963e0c5a20e9d24e779e0198016e80c83a6a1417f9d0c8fbe498a1e169f4556b3f8384beb40aa7aae33900fe8917f2e6ec52471d6c7b82e3f857afeaffd5776dc7613d966cc0c04fcfdb1fe7177a6b68292fa5cc68555dd49b24dec694ddfb8355ea2dc1d98b9e751b8427e5fa1ee4fafcd52000ef1715e07773b8b7bf17252e3ed3435a6db81ccb763b4ef51fb3666f9447a087e460d9acf230cdaa634bf06011d4000ca3bad8a31e8a445b6b3466c3afe895d2bf6081a19d1c5ac559eba700b3d738f2bdb08c3c665e07a22f612449bfb8dbddaed98a500d20d7ae671d8b26f000529c4aac8612332b0cd211cff1762b6853325780e9217f33990c0735dd7c9d5f838a1611b4936be8daee34e4994a6ef4cd4798304c772b0ff2a8f1cd3834d5dc90f20933d6cbc7bc51b96f7eb78ad2c1d0abfe22a88026ff521b4a8dd4b2504ac8a0311fa6f49043353a8b5438b6e6e58172ba18deee37747340193b09887c9b2e9412a551d2eb6af4bc20411f4b36f1d4015e47190a27159cde77a7c4c88831586c73a04969726269b5ec08c55fb0c5463bd932d6b1834232a39587ec7d73f434967314969c3b100a1bfd262e83da35bcbafbaa912a0672ec08892afa9c224e22057487c27cbbc82b287c09a72883a68165206c9d5e938f40a71cd6f31c30c75e1e5cedf62b982d756a90541d604f8fa8b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
