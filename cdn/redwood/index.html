<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27e7cfb5775d88a98fd015797b3de93ad8a7f7f5d1e79fbe6f0625e1f410a0517d6f3e4b183e038a449ee96e97759cd094396b0935f0a4ed0e9967707164228ea9e50c82fe12daa4d5de1a75c858980ece061460395ea931928f93be1e2bb70dca80297e75a306500e51af7ea791b62d42f02d11bb77b27ea1ec7dfe8c78512d6b00d040749db55da954238c9bdd3e733fa7cdd05a6a62e66534fcb9936f430ff5f1475a6cd165ae3c334a64a9cffafe49c20af67a66d88fe93f7bc79642581bcde60422dc0e162302007e3971a67114a5ce96eb9ee18098a610a4a28418d88c8273ccb97eb7e1b124bb009063171f9b931a81417f44329d570681432ffc62699088899fb66830b6fed22af1022a266243df4a2d37bd0ab201cba0e178a2b286e89ead35896d5a16ef4b9d8223f19038893a6364dfca70d05ee3f7076706cfcdd56281b9bdaf1d91edb8d6659f2d3f15465bb060a72e385081a5c2cfb660aa52ac7cd1b7887459fc5bb2d70dcd6e13ee64cff472284ac647cc8986b474df87bb0ddd0f6d72d4e9390e1f11a77f7e6097e48287d5a7927ed235d009e7ac41aa8f8e602673a219b3e293b1d28f8179ce177bbe8e06b89c016f95173d0ceb0088af5223fd554feaa1059073d578cf165ee134c35aabbc20b2dd3e7741c509d61eab668200910f63ad3fb06ce6792572e8e533206383df08653494bc709f4c121a4524c0fdf2b7c75a030b7e324fe343a273ae78fb90590030eba2357456a2892382fe0c7aaac0499b2cda9622dc996266c944f4ed4dc7b6478472dafc434145134e9cf00fe5de05084669dcaf95895ee3cac6b825a9fb1e36cf07048ade9cda8abb6e688a4e78b862fa7bd894379dccaea182e7ca4931b292a01f376509c8f6e0c10b8d38c0870d9624ce52c808f0b9e90f9a05d4b1f088e8d13da08ee655ca5befcbcdb0f6b7d895765e7319bffd19f5ae9cdddb43812bdafd18a2db99eaa6ad4962bc8cf2f32f53eeffe9a2eae9f6f387e791e244151c265c4b6a6b06b58a565cce44305d018975b78b4d4b84c6322fd6900f6218147d25b8e48f7e2b961126829ee008efbd6cd5cc423caf1c145f30193fee0758802708b2ed2347d9c48b3c5fd550c93456a7d86cf489be5f5f07ec6587613d1fdc65cebdeafc481d95deee5126dcb37f62c07919a34d386e6f900eab168bdd24abf8e2491dae1bb0d2bcc8ca5f97f428631dcb70d9c75d90b5fee46ecc71e6db7dce46af628123c7db091fc6552e978be3f82b2d142690840c149e9bc0d3a90e1371f9992d90dbe2921cacffad6741f3f08d3b2a5c9d4ffcafac8847957760f9a03b26df81ccf03a64e0c83149de4b90ecd1d47c5adf6be9c0bfac4cd24c4df1bca4ce68a4bb20d779e95cb0e18d686ad18757a5a2c21550afc44c5011ca3e19e30bcadecba77a733995a9b8eeea537b362bcc00e6f577d1d5abe43fbd1eeed9fcd06cd0573b4838df46f08e285fb03bfaab4b916b8e1b96fc2fd9a85147720914ff9430447d6e0d60e0023cde91c2ecf572973deb8f2c83095f97ecfeab648aaeca7ca53eeb549041912184448754c4632cc324b1831308c7fca5ca6784505fd255f5c7ba2b3a71b8add39baeaaeb445af1c2946f7bba163e252b70412f61cfa6cfb986a282b4309edafbd3b73113b7287c7b6ce1d84861ef3bc92db1d380152452f9b5015ca7cf64cacc48aa27451f1a1b33128cce5763ad49e29a50d0bbbe06839affddbe9b7f1f5c5b28625aca121da786ae571a98306e6805c2439b2ce33132c5e1b7fcb45f8dae228fc4ec2b37d3cb96a99c0e147feb5376c78bbbceee00ddafe2a738e45ac5078df2aa7442292c32dcb19ecfdcd7e6b638e010bf103f047ef021a51b8dab434e9b41718900b88794e0a2559ec154678b9ec43e97f6a84fac95a18830ae2cc4565bd078715ec11d6686af635a5632338689270ec261cac9f275265dd72caa710354c11ebfbbd142b0a00f393418c86cb59212ffa11f6be652e4ef4828f2ed44edf2cf95f9e30098230c3dcb52fd6bf32e0f6a3e14d2061e38452de639eb1f498d66a384206043e80039cdd940c5a6b3311397e119921588fba62733654cb7033f44b32ac419afd14cce36f911bb01e1cdedcd0213c023bb2083a5185367512ba0477a1d8ac275df3c715175c045e02bae96bf1c7c1b7b529aa375828e2453cb4b83ecb81ef3111607665226bc866166de00eb722e3261407e2b732968a4436e8b5fa59ff10c35fe3e6f329fcc2992086b42dce63b795cf9d4275d88e25fc8f954f99c242dacad742e6af974add655cfec4b583308a82d01936dc1f290bd692ac629af99934f59fe8fc91827ff35df9206b1eae236c7229487a24c180e62e967cfeafb5d7aff9bd3276786a4ddbe30e3678c86598a6c57dc84e459dda2515bcc1a1cb5cd135ee152328d015dcee864b161391572017b9716be9c3b0110e714ca4d69fed4046fde004ddc7aa87d36294f01c0cd9d6de87e29ae11138a1720c77743dc315d388d02f530a816586b905934715253d999b822d8680a56963060b8e6daaa3cda164a5ead420f58eb4b2cc1632bcf823f511de864e61f6af4ae0457eb474dad6f81064923b769a92f247a0002350e7202c94cfd5cbbd8fefade9d9c49ba08bc9cf94778dbf85e9127f3980265ddf5d72221619f0cfa2390337c205a08232c786051c338914c6fb852ce125d0ac25d9c30b740d20ecddfd89a3822b0d79baf2b369cebe36266f2bc6b65f06a87f9d4f807e50ea5fe39496837c753c92c3a36d172a30397d6c10cc609edaaca0071a04f490f74ae18532bfd8ab5b4c1ec66e81bceb62ba552e2e88730ac249546bb85be154ca302b07a958dc58d29ab1a6170ef23cb7eb86e97e732752ad69aad13d99214464c9df98c99e681fa3aa2cb6abc337d3b4ced2eb268b262f9a6ac7d30e5a2a20bb12d2ef02c30963834c571b006f2da66f37df3e6105828955fb355f87c83f3c5b84ba5c9dd3ecc0f1183fa5db6a97a1d07c4720b82d9a74330d1639d548cc1712a84245206d47cbb25a6c0cb4317be81a32d0bfbee08d709aa18d98fae36433dc286c9d815b9711ffcb9b406194b4bda37f5ffe8c8770c45615a55f68ebb1f06530a3f1f89040c1ca4fa0a0fe5e169fca01b89cfe4c8e24cc75e3beaad6d4565c536caa088172ca5fd3843fa657a46a6c82d05fa9bf53406a5ba1271bdf6fcd7bfe713c91fe3d6d8bbefed48fcfab9353a4fb63b31e76a0acc934dc4c6fb5ab465ce4af8ad9174c2176caf8154c5bb1cd2ad6f8422ed02fbbcf495a3db1b104481f846e8323dbe0f75dcdbef68aacabfddbe53eb5b360633b50fce0c408d59b4f241991463d2bb7d7499e6b8249f07be2f93211373923f5d58f29c3dd0e619179baf3708f8d67466228227f264820bc2d1d0a4fcd947e57c2fff94494f7706acb5195e84c74380690f329b1d4e3a974715cfe5b3115d2e9635079b4eab0e293e497f858af00eb99fd0e7a2f5035040bc65ab0c1125c9082e9c6cfb647c33d8eecd27cfcca711ca36f3d39dc3243490d7d04c5be2b473c90a0cb19029ce365a39681f35847ef07b4c1bd0bb783cbbad6cb04e70b5b6603c6dbdd7d9903a2142fb10f5ae376e232a342e1741e1a7bbc225775caf97cb22af168a85f44c0d7582e2b9b03fb6b7272d3e3191918e3fd3e6c42dea2d5b2c432104b9f0094c86e87c68f09e3bf0e01577d5b95eb6202dcf613ce8e1b8410fd5a0f4392861e649b3cb96dfab6a507c7fd676481d3dbd0348e44c429a2d1134719acb299b7ff68f4858245c90642e20c04f5eb1d6d1fda34a2dbe7247cca0596eca04ec9bead8feada381faf78feb86f940b6d69ed1f0ea0925876d32139fa2f419d9f9cda096111ee2377a9ff95656b13e4f38b2c7a3b3d32609f8f3d09bc2a4f7df821f92cbe981a303ebbba1762f9ad4aee368cdd5535c8d34dc27c2ad2b6d713b2dff4130fde80ebb6f27b75652e59b4c34c0dddbe6c23c64df9c4044a1c09c55d12b9c9dcf8ef1e095d9a45ec90943ff13bf0520db973a1f620266d4c75daf5f01c508684229ddcebffae352ea2c0b21e8cc939623845d2977ccd9e60ee0f8abbcfc59d591c8aa4049b00fc1c494b378bc14f03fdf1c77268d8387ad8ef43c877f09c6f056f0712e040551d1f79980f3ea0bcf2287034e96325bb7c9330d9e509257826741ca821ed6bac312e6e3e6c51c089992e5078f1e169fb2ac7564fbc080c1df9d259fb37a12b42a9c2019e4d8608ccd5d27cab39e0a48bb4f06e11b9e1abecd1c60497bd22b43beecf79b9cc102e0cb8d94aea776901bf22ef0515145236d5997ac2cd22497325ec38e14267ccaed3c006e22186e65d0a3b7b922838ec2f1bb43b9d5527210b0d0d0a9ffbbb2559edde61700b155fae1a9549427149d54248d6e1420ed4cbf01084b6e7a9109661ca5957f10829eacfe97562c7d07ce8a3401da53bd6079071b875a88dfbf760d675b28efb8a43cf422b7679f30298804a006b5a61608b554223adde909459334ca19425f326b69298c30da1098e4c07858638f30d414bdfd3643e1fe668de0278c9efd392035d20fa76b40dfabc82f08b36bc0e39165ecaf594591f0f6cb307013fe0d04671bb8e1092c1b1660e2302bdb00720989b39e0373acbd88a8c50f7c848155e96179bb6bf62ff9e8ee5f10a6239261df38fb7129a074ec46cd7ff664a4e2b0798a9746749b30d31709c84047f980fd4d35808c5b242cbb27788b54a526ab99f9f8cf671feaa9ba06ed439e8322d7397e254ca15abb3c219cf8e091baca809b7ad1edecbea026c413d2161aa043acc8356d6fbfda1f562f811dce3184bb8eb73419b567675c021f8e4721deb2a37d32c8e440de7d43da385bb3bd7f89ca1350205d04f78aea301176a217e9f39cc7c2e36d3560bfef2f5dd65cc223fd86e05415b3f4ef1369e3492b55e716ea32ebb9b29021a08d789b561d382fe81b567ba4f4428038eb2a9e445ea9b2fd886d612030ad885bff611d655555ece4bf0c8068fd5fdea0d3ff275a6bc5ba4166ebd842dcf1c59777d8713a3377841cef904d7be0ba3713a4870d12f4ad36a163c6f87772e8a6ecb86d3f5d27e43ddf5cc252f68f2433eb7bb5712f90a0a2674980551c6858c4c8cb813e85aded567718a86e2e8cdd4906b836e8d36f11d8ef2cf3f39d96c246434596a3929304132fc836872601b863ab8ee6200907b9371695c1ca9b041c1a67457aaba231352f96140ce0a466c25b4650ec082c68414c3fcbd0163f75195ef475ec720ac68069e34477587b54736b5a2500c0a795f816525a47a154ef8405924adb6b68ed5af7199aff4880dd12f6ecb8f9b9e116f5f2ddc6e654810a8e2c4ee06749d4706d4c8be651585d2ab20d9553b82346fe60306073cb64287b60726536df5fe2de85707b13802bedf5897b5e797a8b535f00d82ba413d3cd52566fdef43e4868464028924546b1a1639da74b0b0450bbff67a59340086a5df443fe6f280cff6800084f61c0e3fe3208000df2e35c3f1b40667b1c9dec94686344f6e30a0a5fcd458bc302fcf5318814493f91ac90c2a51597c052b7955325985b73d075234694a4e0ba86d61515668b2d37422e5a5f61f26c8cd4d33519e6505c0d5accc3eded64eb442776534330336c4990c6bd63bdf73d79618baf7282439f10891dd6563e1ab64d32e830167ff604e76e2891202f55b6141d7b9afb559a8783715b4f4b0da6adbff88cd9d58dbc03d9221dd1f531251f3793d1dcf6ab86a752d89f08c2810e5affa586ada72060938d24ff0d66a11231a94abdf236a8e656ba83d660c32b9c40d7ec0a96b261c8a244b4b6db7b47f9ae02fc65ec5d647b3e161038a05a4c1c38f0cf4a401d5787c165e410b238c1b8f3aa8ff258791b8fa1347c024c57ec1098bb2127b78a30a021d891dd45c4a86ac5e41cf0afa9a3f8755c68ab67d37cf0306934fe4ae288b48a5e10f76324fcb7588787bbb8ac3b6f9a725d9b64b91da9e7c0a9e2cf775f74ad391bc9cf54bab8428a7fa481cd554fe94572f1b87c5fa8dc889c6d0c6ec03d775b579792a2755babe50543db96e389ff01edc37e66c5b63f1f9d8e1fe3a2c4019631c5baf5e2b140e3681cb06341a1e1924216f80923ffc316a308aca635ea2ed3c077e952f0b45aedc9e92b8de057792a6caed8831ed2cf739036e20d8988072a5f96f7246c09d23029b877b363d6b75903f47bbc389f1e2348dc2d5074e21ad00fa9495c71e96ee2174eaeace4e0d02fd82f4a40f9e3e5f1fef370e9227c6c4828d5f736d3d0f3812ad341a701477b21c79daacc9a6e6578d7bd983cd53f5bddccf1b2e5316e47df49ceac05c102cedceb47c45c1809b519ba4f2df1a0890b46d9170dbe0baa8f949ad1e8e076ebb70ec7b136416a47780f76ceb7046755bc98b9ab04c585f4c4ad770075c44bd187556a90a977264a95e192c17ebe065b9e003a6d98c688f559ec788f1d28a013eca5fde062042cac9e79785ee98022612d82317581b4af68325ffdf0c4c3acc24e61b8c77cdae7febe6bb8e53029dc0732b6bf3e30fc2e0a92f6a46f88e18ebbf150b5528cb3ed24455bac601b2818e1b33e8eb8d2c4d66c6bec893ecdd415ad2abb123eb53d3d712869eaf6bff503c0a8092a17d52e99c8103e303c679bd433a1d4a4c85ef388afaeb755f891bc148678360c48e1c7e392198760f9f2a1b52fe67b7801ab755f5da9d1aea2c818e48ba4a902dfdeaf10a8236defcf5efc4ff969233be5c4403b7856cbf3a677d0e318c40afe96fca8251afce077a9544bdbf9463bfca10293e6edf71036536432ad44a506ee7925ae7a07b940d051da4b3b0cc0344a17ebdf6ff1b84183159d8ff962a66b4440e4d7f5e5253665fad39c3e16c60cfe2796748172ea2919e42e1393a3ea791e9c9603e75749954ecc1b6ba81dc1b9c959a0e1db78fff79db9b363317bcfcdab864cd7912d0639511487ed951aa6b4a7ba0392968156bdf71d2b254e6e0d2b57d18661b401fce9e7623d3e68a8f9a321f86813dc5dcbb53c784d303bca31757a1a21d1bba163cfc7bfa9621fe8188dbea8ce6a1c104ef785790c0c2f8639ecbff64addb5c94cd10109734da3a01570d83f32bee367375264db9b6221fa901ecc4e551d58c33dccd935b782fcbac28c329efe8a6fa41b21d893db84fce0840a33315e8dce6fc1fd38e02febec75f210d40690bab1955ace4cbaa82f57996d627c9c7147b9f3c956e3db103cc8ec70fee817cfb8cb485b9d16ccd53c56cdc181f4c07a2866433df53dbca0c735c896709e85018984dcee6ddfe7e031a59fa77f26f9de3a82cfbd3f6332e3b01ec88ec404df64df56060486cac94a87c27ac22ce68fa5af48ae4a575db868b2cc44600fcc12394f185eb9974c61ece83c12901f0193725d7ab7f426e8fb9f669c80eaa1237336d71f0a13aac418ecc3e8d8899907b7638273ea8bc71e550a4e935ac254ca88e766b1170f2c70600110950b23e9a8e7f2f608d9a958ef97429a760ddb25ed3cbe4eaa13ada47204ad82b5baa68d5f0cfb1d1ec716ad41c9c151ab5f5f9368321c196bf35b110c48ca4fe7685e80c4a928e06dd87c9c9fa32bdc7fc733ad672fcedb2544a39bb8815d377ff4cf8924fd5002a933fe1d878283bb36c4b8d44ae8f2c76511cdf29277c62d087b787168f6b3bea990540d736e93495bd214a3db9f285049603a31a944c2d5f224dab01b3f53c85515ce58fecd86d3a42c0126db07b02a7445d2f943bf3ce5457179ef37704e74674c56d9493af43967c2885f401404471a257eeaf26c5f860ee54173667412416f122dfc94accd97677aa30a101a59377fa6fc709cd4a1b209d485f96a59fdf641abbc40ef8532b5bee33f87dd46f57ceb9e4662ff5f63a0005c7dece42623428c1feb195602b36173b40657cac0d18d0e4a9c85fb8598a25c5c3cd767e5a7fc1a15a819df0b586ba77de46f33d5bd66e9612fce9f98e306b10ea9b49b0b59c6960d3f24b037bfa9d8f99b9caf079fa10931d0606d837fc18600c180b3d04030251b392e32262455cba14ef2c4e6fc3ef715289a7b8dc5c5a5c93edd640313297af2b9e5b4574fb21c6aef118c3bc3aa2d67ec0b112de70d72938689ca18e13d142a5dc3786d74bdd021632c79e4766073f237d310d1b8b0711b4525039ef6a203ed61b7c592a03e411162480ec57745a15e14aa0728f79f13187278f7fa647c81da2d3db4afd9dec258c6820f12afca59629e2b85b0b1fe63c6f47c091e83c34f791e430e5938693cfe4fe49571a62b0511e3b7b5fde97ae9457a93bb98a0bf118322d679a04438f69a0ff059c8f87d1465753c269160ae0776b9c01c6850389dc09054cac025609d10307b2345ff40da7967badc7693325b93859a3d4f9dacd318cddab0b64933d5e69c4704cd093b13f86d2fe163848b781ff32a86e8410481aee4acafe73c8f706c6e2021b424f77863c1c6fa22e38fc19351ab282bd9472bf144a466601f7c31e1bf0038f7473c916bae92b3c645ccafc452bf0fa2a030dd091de0ac05c3753565357640b03aae37443a61a4bb2059f115245f58a9cc0047a2923b857687e666e2b33fceb846f082e648ed36c5e911a4406b85752af68877b66474df632ea6d051be7096b5a79c630a38b373ca04cf64f626cd57b8ba4a1b98f9ff0a5cfdaf02186102ab47e2c26739da8ed52a88b15afeeacbb5ec289faaa0e18616ef7792b4ae10d29a5baa075b81e529d933f34e7861ab60214ebef0bef85a04450e76cca384cd2eec50af3df6d19b7b6e03195146ea67fa88a9703164b8aa99555473e5f9b1f830fb9e51198a52e24c28dc48bec0e767b8a53bbf5afdda051505ff541a4d262b332c4929fce00163141cd6493fefac4bcec213261cd955f83246b94340dd0347d39b4add7ac6b4cb6706aef017eb426da1916be7b9cb1c01547848d8a9f0b6adb7bec22797ba74ba317137be84a91b549c0cecb125e43a997b3e1ea9c57b5bb6367d8edc8ff57e25583377ca3a09ff5acfac360ed220d8e4b6496110487f71ba43e8c6c4a0e56ddd46034499cc8927854d014a9e7ce14cbf1aeab586f7916c77218d75665ced6922d168baea35fbcf81b18a07d397e299c391bce3c968b4f337133245a189b71e6bb3fe12e258d0f8015c76779e56691a5944e9d8a838c059d30a09fdf3a247b501bc91e4a49a5f4e762c68b441ff7c7349d10e0de3da78205e48cea418649a089f249fa378d4197337f2fc62543beb7efd6ae6d04f3b2dcb2070131f124549d6a68eee99171f027f1d72dcafeb909646fed416a3283c35f83729dc7a5d5dc043cf9ddae9303b4fc95d6cdce48846dd8d557d46b9cf600332f2b28fc1384f2e7d870efcddae5c693db53a0a008296fcab4572ea8d72e70f3030a619b0cce42a9af08f5267285f7a15ce5487535df4c956728727af0d721c2e13a0adb3d57eb973638d434157d993dd010cf3df04f37582d2279d0bddda9d6ebbdb2e7de4b3c033d3e10d5dccdecd089f0d7bc37ef9987e7c570cf2bed1732d0da01bf8cd5e89c89b597fb9ed7db8304b5318ebca4cf9f11b67ca6e148de8fd4a1d0ebb8394f15dd5767e2eed62dd0d41f5db5669dedd4a283e0c9f408cc1dfedea2bb4ef9f41e2bb46ad9d81b96a139a77694d6a5708912ccc01f4cd79fd78f594ccbe2463f032d0fb2a2189a47b79b4c98828809bd2b826e12df38ad970866c198eec57153e3ee9001bf8c3b20def8979d23dc1d7af5f09b4423b3081ea7b83ae6a28eb22ab4e6ca973a5481e861559f8a76b1930a32ae3d6b57a007714e22947f071c32677f0be5e0dc7aa4176621a8b25b7e133fb16f6f18d50a52b4bf2c9fcbf1938236f59d6fba75c0360ec9d970ab1db8fc51e6717c7451d3fa349fa98706b519467d25b776c2814775916d8fa5e412aee9c9fa5b9fbf17a6422a1c7f8af64f4f9e4f112771e378f83537a32149122eff4e58503a1a33298e6f96d9662d00dc77a813646e078ace2c310d64cfbc5f88c4fa5284ddeaeddd560e268506faf2b98dcfcb50ea0fd06c8199dc066191692f8f9f89f4afe9dea7b8870533dc62edc888f7d923924d217c8692ada3ea8e78a9d5314900ee6ad209f07468f0967a6a57fb99d3588177d5976b6766756a2a6a0220bab36adbc5d6f72194c07e2d447e46a1e47b1675d137975206fc83fe412d361b4e9636bea6b69de63ea328ba39c1c0a0dd1b3cad58e6d168c87c120c1bf20a81def1e59d4f12f691c416aa99cef7e83aa8951e04e4c2c1ea4eeb57be13f7d2c76a819269c28584e3211554a8c01292cc8d64af5003f4763639eb22d0d0d08c193eea80fd2281fcef98b7233d4868ad0fc18fb26a17304b42dfe8277fb187644a9be196b4b31f02a035840cd99209ca240c87466676b5868f98b0451265ec9c6e842c2ad4c4a2378d779f2e1f2d3ad4b0648f325523052274a6937e52b280ea0a04efa080183457f571e962f405ceb700ebafcfa2164b68b9fde121a5c19be4408ce18443aafc70a73474d0fe7315f9e0efac802b52c69f7b6d39ebcbf9382f59f0ab40c4fb9aeca54ac7cbe769315cbb7e91115531eb202bc02d0471c7b38887ecc53777d20f2cd6d94a3104482445fddb4e4422eeb812c9277bb432fbe0a82a44ea6581be1ddd042259b0379146b932bdad748bd411b2024da537ebe83e1b2177ce6b15ba09363625fca03b3407fb36f650efa2aa43bdb818de786be794e80cc2f3832b253fb70f6818a682706517366e09836fa4ef4e3cb35f2a069d12041368b9d96b6fe64121709bfceba014f342c5eaaa6355d5a926ce0db46c2c5142a919447019836e71ba5b6aad1f0d247a0b15e40b97e1c6bdc005fbd613f9d3296aeda1cd32d43600eecfe3e55630fcb26cc074097427b3c2be2bc1509ed457ed24715e1047f691f062bdcd65d3f6091ac9bccb61345ed2048752942ee526e916b3b38b3d9c1fd59ab7f9377a4a7dfa42c1ec3d31963f6c866e02d572ad7b13f5d5ef23e1908d5c07948e408f5f50b2b7af683b1fe2e44dafa7ce1be45aadb17cc2eceaa7d416a7cc755ca4810b0edbb39fc912880bb2d2802d7807d254dc0e2802c85273c29d69a67a3be2898de06220da6e133caa7859813293dbdc4aa1663bee7ff11b2ad4b7d32701c131803709db7a690f27c99d601f1ef3d8aaa6f26c8bc1f5fb6a2c4bad1dbf4d14c2282997015c30f5548d9c76030709cfda29fbfd897607c719cb5b371658a2d3db9226dc743994f31e3893a3fc510aef8d4c0d7b615c21cdb4c53aac6bdad6351f7c1beb668712c63fb4c49cba9501ae873e717de47c183592dca8e16c8c9ce221cfa303cc71165f57aae278bd36842939f1e6b0bd3ed14f394a085e69f9abf471d9cd912aa133a030c73530d00a19a89182562b949676d7bd05733fa1bf1ed5f2ec75f8295fb43692a1a96f72c74b764b0fcc39444359b85db45f1474617d4fc846bd8bf4be9a5a7099e3aab6a5985833c0165015b2f732e754622351cf3b10e921ab2dcca05fc17c8b08f575ba70f7f19a4cb23994e971b4ebaa7fbddf430de5af1c495f7246902332570f5cdfc0454a6d585150fc21a209853739448f1e8fb509f58090dd9dc4aad9717e464f898c23d47afeadfea4ab565584f21c53b5adb98696d1df2a7ac940057729068d50fe76c844e2fe5a2bbf7c6a51fdf8dac42a2d3dbcbbe021d9a9437523d9d84d5bb5c67fe24a3cb8f2da7c7b37421067bf27440223a2023477c21aeb01a41e2d99330a3bbb9fa97d3ed4e7eeb017abf53821003cd1c34e197d020681d05ae9247cd0ac702d675bebf8b084958b2ae8bb669401f71478261254f6403b3ecb0df4b406cd630187eb69fb8ab0997dc267ead546985f1be02e7cecb194f6738904038595456747b5235e279d30550d19564f18526a342c467e3baa939bd427fae7248be3f5d4ab6b8c5e58f356f81c0e541b3d6f7bf325c79ee88d938020182175f3a3cd5ac066bc1dbcf72234af5a3851e9d1c90a046ffdc242d92800dc1b63838e70c7095f14422756886e7e1f186017a3ea28ba09dfe8eec94524a2340d2d1c53e6bf147b0617b9b9818fe97e59a852152fd984590ae6727ef0b7db17a3ccf128217c5ed44e799a7fa6d33aca6318489520f5a17747d9a873099a4deac23209f31077a3e61e3f53cae08fec060338afe4ce95a2a54a11b7240af8c59bb091ea9dba0d68745f9d77cc9f2efc7417dae5a38c7142c3a31250cfb950b4af3cc79ab0642d7e143ffb6718ab0ec375e9487ade8e878ed27f7d05e42d977761ea9f263bd97b2c50c2ac98f7e97150564a40814996b4c5104cffef597c295951f2a03e74fce13aabc8db1654f985ab324e515019ec9dd6953eea5eabc49e7e10db9a5f402d461242a5444ecd694967101a8022478068647d99272c2bb230fe48478e1057594ef6c53ee2e20e9771424a54b97b0b334658e16c8b7d8568416e199c8a2e2bf82b40adfad1cbb2134e0a1582b1936696b146d7066191716fecdd4892a789d3c6f2e1bed7b506f9c97749748a9cba2fa039fb4517a8078c5b920e5472f2a7f6e2259f2917f3c5856cb332048e8dd87bcfa6690fd327efd17124aaebee058875ee65e6fb96f65d522599b01e7a2a47e4c859b2e6ac499aa616982639d2c9a62d7835bd7fc281d443c7006eaa87c3731264297355e597b37a701419383038fd73753a3f402e118b87af8c3ead962756e6b5a5caa2c1148149b0440365050ed19d4c21af7017f030e204627e6f665c94ed0338dd92b9d178626245d8447ba84de128f7324d8dbcd82d4ebe8ce2e97e281e78b308ce6ffccd917eafca476daaa1fc49906174cfdb25e0afc925d724d4cc8bacccab3748cd7ea0e74fd39dd8256b741fad29fb7a508b6fec3714d0b56bfed19c1790713e89d8003171122f38ee2ece7c1d388f21955588c960abec7f06593113d3b27566890f2e90fc4652d8a1603bc0dcc7a294f252613ee8b7741527bdd121c00d1bcf5fea4639e87c5767d2947ce0448f9d14d576b124244c987c89ab6842a26967fffb64fdef940601669a37f6000b2da41c49d847586d4a85fc7447cc6eb1aeccc22e24355400185da3529a67c33f2f5d5cb0caad064d4bbfde7faf68f84cf9b4c3c199ba281c0dab4a40294473e55b13126c7e44068e335ed63fbed85bf13211718f41c5bd4fbb66fa252369ee31691725c680031bb0aab88c5a7ccefd26b31820c0efdc1d707fbeebcb20ee292722d38a47b8cb5ffd3f39b49c2152450a77991bd849ca2a50fa7effeef9f077ba93ec59fc4abaa84e31f0ce6055eb4c1be54940c37403d27f389de39dffe28ee90e2803751e9986701e358d059cd17eb41436d2c4ef5a7c4cc896e8defd24e5b30e843d9fc8424d4f481ac7f1dcd303aa182f0f824c854ec3960d57d6e25b3aaf7e78d4c92611bba22ea86c4338aefa0e49d9a86b19016bded68b5f294c77a4859b8aef43e66d07bf8cb15329389ec8843c828a7086ab1869d5236deb03e765bf09079d435ceeeaf1e66f5c0ab52665814d158467817f87e8104d52c38e304a5008629cef78e269598aa498d287101cb5588a2e104388c8ae821478b96489ac7589f77d0816221e1bfb70acb07f93f2a7157602a54d042b19c4f689167ab597dc5fe0b8fd1cd12a7b8b096bcbda2b6508bb928a049df456f458f01b355feab53eff32b4fd19bd33007d1145d8c2a1e57255f8ef5f41b46fe2b67352090f90bb7b18a60acb5b8bdc897567d81e9d06049a34f2317cd26e83b2edd5ff99fe5c09df31382b9de6d2199bfeff3e4a85e6f3ca5e83691077529cbcdea3414c4f8bb57bce493d2be01b04e4f9b3f4f39822a79cf2564578036e316c601ad2da13d3188e35926cde2fc9737ffc63fb7ddd7912a7bc55d42528e5020874718874fbd6c00199542f8a9b39c7e2e29d6d5b0931f263f66c9bf092567af8195ba55094678c3fb03161efde1052fd67c8cda8761ab5891c297c3af0a4a3bab3f30a60e3004088859936c82267d87bf507f7e4c1830d3b5c1dd24d57c9a846846e0de4fb50b3fb2b931508e22ac8610e34008228ead19bb06343a636ef8418d6dce56d35fe506dc559f45e7705f4789f295faa34f23fd72a54940a3a210362b4aba4ae4820d22db2ef27ccaefaf1059bafacbf96d77bd7d34327619218e7722d9f32321fd2f6832cd30554762213bc0efc6ae90fcc4e9bd85a6e11486b2ddf817e4bbe6a362459763df585ed10427ae267870f67b5eff34f63862a5e01671f811b16cd6b521e183e6bb089af5e190335aef096160afa0b371f7a81d9dd1a57589b7d9ea50ece84e62922f34e4f02de15ebea6b59570429564a27448e1afd4120e1e126853439b2aab951e898d239679d0e22a2f7a2816bfa5dcd45e5d32a87cab3fd3b6e9a6d710410ef7720ff13a2b4687e1f41607313d6fe03049a7e603977869dfd79ce1e099a04bb444def11fea28164b3a27c453508d8b10c8fd677bb7b30afc50e18a482fb575cb8b7d0c3814f36ba41304360103adba06e196ad8f11364386998ca9ccc1dc4d69de41db3f2a2a67f1764007aa469c0c921d3106ffc2419a12d497ddf853814774ea725a763fa90e483e20b547a66f63e7069e5441ae7a154a0dae02e1f1965428a5353667c571ed3046748bce1fd6941145eccd197e3ae821dfcc7c2b30d949d4f2ecbc5991bfff15ef9d605a31e91a8c69da723d9599f0c09ea8be18b3918503617f86073c4004d24598df092ed91f549b1028f665cbf7269d504fe605f5fd511c0d7a938402eb0e326930b46435e555815d3afd8902fad1446be3d76342ab3556ed9aae8b3052891a8321619e7392053eab4b25d7e5b6bafcc64ac8e7196dd22768f07181fcb4da800f1fda142226735e705f017c1dbfd7828af51e9cf2b2f7278a4f40c96080cc266f5db35f8b3fccac1a279ac030305326eefdcea68ae725f74c76a86b17def18b1624994cf0334bc70dfb4c46e68b0ef1403489c7c7e488840fe56e1e26eec46f50a256c77ebd160ca802868dd10a1ee227fb485e4c2efe9e659ab23c4b9c900b4ba23f211f83950510c2a9d8d415835f57a371d0eefc2be62bf86095630a473f8b43e851d0058cd9fbbb526092b52675da601f5bc329376fe7d7730c482b05d300ee97cdb2d11ebd1ef6fbbb58d52aac839ac2b259c71a3959003c65aedf690c706e32728db1edec090145e29a56a0cc9f077940d4c10bb000d8c2cc6ebea9d276445d2c6e7f9b0f2a4cd841a2f64b31744321063ebb0fbd8d4c4b0f69c919080ad4657ef0ae7dc3cc0d87f0a6f0cf8886ce06582c567b8badbee52365204ab45917330102f8044429f892f8093a90231fd2a0aef192cd0da6d74d05ce843324d738b70a5b6f7d639c42b2f76c840f675295e351fb7d7b832a01c30e8a728d92e72159aa818536e14e7ec2c41c025e3daca922013e5e5d5ef23fce3f46b0be7345168ff5ce1635a027e89883314aa8c8ee76bf5a4486b498a1e58d3b0449848a9fc90426a8f9b9d3553a20049214e63ad65a7c0cbc9af6049f3d2992bc89e60bf3e9d465c770a1a70c21e551fefafba51e4857cf31c5fd661b9576e0a4d9b1627243ea452bc4330574f1f679294e474672d5c4db8c12136c6badedefcd1ef3ad20f838df93a687a1ca517207e57dec0d90588ec688123a7f82fffa3d46a844d2df51c0ef463649eb80b901c3a647ed18e022acca467336ef9dffc0291eccd0f99ea45de3d7f6ef6d69c5a8ece0c165a30907ae4e33029a3118de670fe936b6411e40c1afba6e51807f4ef245da50f0be036110ac656e28cdad47fb27a14d4f434422b5cfba33af42add41ce5053fa76a12ac70913e30889ace3dba804dc8ffe96bb89fba1a49254e7b42baa76413ca296eeb0a4da1e14edc06e2c2f2735a1a5a62fe95c56604e90a2a74c1212a6c9f26196f0a4bb37a69dff679bd00f96ca81f10e27925c302d9860704dd1e9a80f5c7199902e669f48412491c7a0e1def987f1b203862c658dafd99dde649d9c311764293a9f7e45d0a570190648dac79e7755a05532427ad3003e1790e448be4dba124987e860e038b174d7773577717c35c275b0a0b675f6477e2f0541bcb4309083e70d522089139d66b7c5e48f3f1d96ca06ffa086b96f5ad09940af2c45311323766bf5bc3de46f9af1ffc1c9d85db31c5163a76204a512901bbe993ed2c6170b16d1fb596c576f9a5d3d904e0c7389ede7f8532bf55ad72fb34fe3f736d61ec04470a14702f946c637e84983b5357e243d7a7d7ace9911efd1bca19c999618c7d85c572c0426c3c92568a9b581e138083ae2cb89c2760689451a232d68a1381b14952b8e416c52b280812928661c5de57dd86be38344af33c5fea3c11603abc43e5913f45f50e17801f7f0f020a494b9bcea2219237e3ed979a3fc3203ee2c62638511af6f6390dbfb2dc223281bbd77001f5d23111d68ce1d71de7000f6fce217f6c5dfc7c7562b8830bc4f46fd4cd354426fb1bca96a21cab12b2a03422259ee93a55bfda906e73832cdc5825b388d0a0cec17aa68bba47a7fb3097ff394394afac16f31ba2f00953b9fc97c59fb59d8368ec197d36269d6ad5cbece9abf47b74a10a32a4ad8a603efa82015f65714cf94c22fe5d95addcd9f0a2b3cf23e3448a162289ff35cf54c0da2df6c5e2c73fb8e24cec73cc573ae897386b8df7322f54b8f5c8a77a19153d7e3a7d51b8cfaa5505284e39f908412fe8141c99364bba28725943c51550a3fe3a2623b1be9b73ff023f533093b5752133365376bb03c9fc84da363ba69c7877f7497624a5425c2ad5feeba822034c0f967598008455ecb4d8f4ebb318655423960424bf764f2e90d758ebe8f46b95cae813f29967bec4d09d3d184f21c4ff6be691bfaf9f17fe152298ad6ac3fbdccfb9f10434ad54043191962f399015c5ef6b5f8f5342be9884826ee2095ca0311ac862b41658207542a633b43ca441950f7e7aa39ccc74fdc53138c7c731d52f80e2b1b8e6daa3904f18bdebc3e2fd5a6548fbe1508109f247e0306811dc667a0628a23e2a6238112d3f95979ab3dd7273c82ac4543133e6782b9efffc1a2043a120c7ee8da169b0d32da2a3d411e7dda30ad681ef640dafd0ec3b5f8f3ebf9f832c4bb414ce4bb007e1d465e9756bdc77c8337cb4974d92b4f437afd3ba2fc848a9e4bfad404e26f7827b5d576813d5c9f7a50bfdc48dc51e77fe1f3c57a1c53caf68f054009cf4c6991ab15f422d7676cbda51414729146c9bbb9cce6ddf55e277045713e408bcecf09b1e4d0f7b7f40224f295325e4e9b502183b019c5f91167609d3223b20334303cd5609c95874d1fb723dea02fa5a03f9c55a996febbf3a5c1e693540c7785398717eb5661181f10a286e709b73067134954e40c5be0be426c056e5d6d2b7f0b6c0bbd7576daeb18c9e42a923865c2a1fcbed3560507d89e889834ba0f9ec89e1561aebbe849351a5ddd99209850e7118156f9bd48d2374ee5f171e4d4b6af057ee6d0605d96bf67fb63c9408a8b55854439a4ef8e741b96c108b16395a5d22e50ce2e325bc4f65c3b5d75e185bdd2dcb84ba8df7eacc110b4e2b6d50509b17a62b842eff37912032d29b35bb00a5aae006d13253b45973aa90a11c83579f91245b93557b628285a96a55e09dba438a4c67c6e3db5700c69231f7f464b9765a2b61dd903c709b6925ecc3382cd3d0f58370058542d2676858545a44438f32bf5d74464dfd53004169092cc9f897d720bb8ca3f59d3ccf50b58226ee2fbc07d2f40134b2c2f9c49164a1f436db78bca5f46a1c917c2e35f303f679076aa3f64ebc90bf059adeede8751f8dc2999bf657e3d6c9b3ea54c72044f05534f39275d6921a354b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
