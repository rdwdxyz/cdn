<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0411da5fa396d0550a0bde078435f66c7208da1d1574f0ea7ff5fbda77f6a38518f363d0eb08358f226eeb7d6f947ee8bb4c36172f3bb39fa2ceb56a1e47edac9b239fb191fd72d13027454f2f90de6f14a0b40e49bc748a1f93ab5d43f205bd60ab8a16e8be0a4fd6d5e3c1a153cfdca5c319bfa464080124c69e8f13806b401dbc8f93dc4c6febcabf8183bd490e1b5b2181193aee0c9bf8934d4a4a73f9fb723735d2bc3043cbc4868f03d99192998228a8586a498f190b2efe098aac780d1d8e70e82da32941dda38b638027052e58e9e368df5c6a6e305ed0d86189892ba6a908dfe1fcfa5f047275b67915e5e5f6cdcd4748cec6214706eb059f638bc85eb869edd93d35fcdb96ba987b0fc4789b9f0bc8000a254b30c6ddc4948d0b1edea7479859843d4c5fde385b3cd31f671a906dad59fcd79561924edb46392cc9a462c14757c40826f28e438ab2c721d1454c492a87c1648421a70a9cec3e31efebcf1d94a4e273c30d0f929d2340cc376096aafd0778b4e765d02a56bd5d93fd92a6e397a8aacd2bcb38d061d621658d7c23d373e352b25ccb120a1fa56c0b20f1e3f6eed5a605bc364b267fe240971907925abe7c28a1da77d6b883ee549aaacdf745a36a0802cec64494c439a5a5ef5d00534a938b3bce4f45a2fa95ed82d5f93d4ce4a87166eb7881b7035fb75dea13cdd36b3c6d1cd0dc71742a2edb1ac051a3f39ac607fa843cb95e66a724dc6fb3f26f03a411a8677883ed58ab483f78bdb929d06ac154568044fe838262ebb4c7cf67c5e3f79fffc3697a9cb0d3d2587c5c754f265c1bcfe2fa83e91282549d87d7958c09c83e46c8ddc22fbf0025de6268adc6b8f2091f12dc9f7f655c856450b2bda58b490f1d5b9f3ee511b52139a8571b6e374bb2d2b1acc0a3049e2b79cf35667a4cf5e25e83ad5c5bf19e606206f7f0c9fa0769838fe773b3d18d161d940833a3c09629412f3443d08663e535f2ff8f0e217a0689a5907477fbecb586163f5ecf8eedaa39008a43e4f0ff949157b9933eaef8d9d2c169ff605e8672115d81a7b87b82af1d0d3e7f5a6f120e0cd53636aa5a5f946177a1750436b52ac7db2214875e9b198c88e617a8b8f5510b99170890c39c24d6df598f4e4153ae66b1a23fa81dbbcfedec387d5b8c9af46b8aebe217d506fb87535f21e7ee3c3e5f57f7ceed3b78c8bb68ecf65bd972c118348575f9f38320cf0c48280ac73f97e4cf3f7a65cb2bdb005085c786e8a6341bb5e8298b86ef874577eb586f3f6b0c935997823182e4fc0c6f7b4eabdcb2443bb6d4c2498dd3815ed0b1ef6ea5e40012ff32633c47411d9886f2980938ed104cdc47cab7db97e20125a8e378032db8b9fbc384eae88be1612216f97bc56314a6a7247ebea3b347ec4950995e36bdcf9dba061552c4cc83879926348db11dde2b8fbac503115add163e839701f85bf90e04d1ade0f3c8774b3c70a67cb3d3be4e3337f7de033440079f332f51fe4456a8de003ad7e2d610d25ae2b552c72abc12828fac2e66edaa87c157de9f38d55845db8160b9def4fec2dcb93104ed5a16d8bb96c97874ce8dfb46edae1ee3df505ddd1687e681fbdd0806f359db64ca937fc34f8ea37853138104da1d664949c8ed2482bfa0771376b9362f744c92f8973c2c423b5cb948073d4e98546da862580218e003fcbcf39324b354164cff9f3765cbeae95484a9ae59a19372f672d3a086d7b9606b5c3d5cf98ade1cdc36a754296e10969d39d100428e63894fd8e60d1fb3c2cd28cbee60f930dbd03ebcc5a3da654247deb6f9baa6029a64114bfb2a377938cd689e17da228efeb0837a251edbb2e4b8a483376ebc964d7e9f23249e59df09c93f1dde9b22352a3e11b11158b2f93b3d1e86db62efc3d85d392334991d495fd390af7e3b975ecc65de420271c7824e251047187acaefce24d7d79d08ef62a52052db9a0869db7186d96ce4ab9d96006a9d7f48574584cdfc0c20ffff77a9d0be4fbf8cf6a83fb58b26dda5789654243473fd227a04563d88bf267e222a628a3bd0b336df597d565313fb0e8937378db2b60e6dddc73b5fe3f6f783dabab849270526714e63411ce3c1b37313310f60e692f69bcaac5026697369dade27f0be895a7ccafca3759b7fa215566a811391af27130dc7987ea2d3d66df8713393bea53931b112085b250a7f16bd9f0ad8320144a255811910fa4a93984abf59af92edfda3680f56430c702f0aeb150cbfb99cfbee3db5bcfdb29e391123f44142d764b1224d50fd4154a69baad4e6f335ebbf348ee3ece732e0718e454c4b44442998b71eac8aba984145f7ab629b049a006e4bb08e962dfb4b2d6c6bfd47794c8593e423548fed108d0ec8d9435accb219a529dd1af110214ab92aa74705aaa864f391fa25ef3d49007a16410b2068150c43b44158437e628aec89f66e273b7dfff33cdec9194998d60c75be23b3d561df0e5fb988b722c4457b620fc75b58477a375a34fda76bd47c98eaf6f74c949e7bec7826eb9198bb783e0ed950b2fbec7c00ed4478c8e6c563c379a446de721c6e58d1707a0d3d7f2004bae6454aece1368826d2df3b2c88f5aa312fa1b1d63b38d049af64b45733b99aba6a52b768f6ec23ad8b023ae6e22f86db4af83a67b5677bafb85456a2709bd1248c8ce9d38d0d74f99895d1f8660b40836bd5f603cd5de9a39c1c2b0dcc38863a40fd2578f49dd35b3bc13d33d73458894c9099323a5a447bb0db36b484e131310d1667fe8c6bd8d85a505b48b00a575fc82ab0aa1415968bf6a141194dc8613e04981c8a7aa277f2e9dc0c801257a0083299abcc468b61d7c40349d69e90ed1c75c5a82b49ac4dff08d9ba7414fae8d6c72a03633f1a4447af741ff34d5d68d53e3f7158ecee454ecf34122da68f25e42adcb096e4fab773b7118b30038a7fcf8ef6bce171609b6f71acae2eef55351940d87fe7f7f932e300aee4a8f3c7f2f4876f3a27b493f1d9756be83ff9b0bdade419f780cc4ce521b0e0e83825eef68ccfb52baef6186153a2b9a9ee6bd334f166157f589a390c9cd6abeb5be8ec35d16cfa9de66007cb6b6b6d18b6ad314945d454560690ef3f8633e98b527198c34603bc52f0a4b57c7a9f9c1290b582ce5b16fafb8a686e71b37e96436a47af9e37155e9f00e2d240613823ba295fe1ae88e4822f2d70a2140f0106f585ae6d8d122aee63ba32ffd05037b4569139e4bcfb7f46cdb55aed2a0b34641d1a793d4afbad902cf816fbe8be586da2ecbd0d0bf4df96c661deff95bf1858424c84246cb04c3ce23dfbbddbaf0557bdec96acd49f3f41607fafa9cfa320d4a965a54960330394ff35973948ac9090efb68e9c8486eed66a6da892f3b3c4844009887f8c36376081d5b40b079e3c3511aa296c5ed89a73b1e1e83f12d366f1bd3892599dbf934402e65acc43a5769a07093a63f9436f878942fa025977a30daf8a538ab7c91989fe38ae03f6773cecead22186da2db1fd4f7960b3131d7b5ab7a066b295bf2735eab2b3e10ca2becc82960c15e45788d7864c154d494a7f95be4e015362f37b09bdf5dfb3902ba0e285d67c3672ffc11f8668b988b14bc0e3f5944ca185268b95662786782687b14cbd69c38aaf1bc7a154e6a11ef598c72d71351f062f486a6608ea27f5da453315f65c46f01d84da79cb8fca47e7ec432722da2b687779ba997ffa5beef05c3ae3f9cda87a47e9e962831a857b1968fc0696d92a4868567282eaa686535115befdc8c330c26ea21020b8e78d4bb1b8897d5a33c6ee79232788c20a51296f2cf327ac8e08b742319eb9b0c4dbe97455aab037bba1526cc9ede77ee83d3170d697ff2802b03ae63cf055b35a9f0dfb548f5ffd15b8ca3fe33917399a79c004284b852cbd5e3721730caf909da77125ef8a7c7d465354a6712a71ef4cd752aa99585fed86e5e88eef6e06ca459c6cd6d23353ac4dd5d4de541e46aba91350d347f02ad276c57c56ad5507942a9a5daee4a1aca107c9ee359c9231484a47aecbac5dcf056b5edc234d31d99081ba83e77171cc3b6b42c78f819f311e23a0147d1caf99489f7aa03af85deee211a76b5b089b67eed2d29dba2ae67ab81fdecd3584a5c06745973fe645d2ba0c714e89424fbbb498d100c54dfd40c51af4ebc30f70ca14a1b3451dcee8585c5eeddc9d798a8b2dc248dff2523cdc80bf61c81cec42a469f5d76138021f7cc56338585a41f32243bfba29fb2a834db1a096b975068b46cf62caf8330ddbfe86f61f4a802561a42235333c5e8d83505cec5d71d953a32ab8adac8610c291da84f9a3c79cdf7776e6b5722c197a2057b55108140c705736e460c69fe26bbd1c03bb28f17cdb45cf8311485fab68df43d66ed5dccf50144227bb2310fae45f727aeb40b4fa45e5aad363d34aca16ef96c8e8178d3225f0c9d33ab387136253c58832bf3fd3ceffd1e7348b363188f853ef6eb3eec28a26bfebb5b8dff079884fca8ecb1c936b37be47e409760ddec91d3d5625288581d6520be9c96c66eda7d8373bf63d1d1fc3cc0e218409bd9d2d9783a55c6597d762ab3aabd384dc75653160b1b50e40d7c87f4a743bd81b96771bea661cde31c5ab5742237f0f7c39cca6fb814d18bfb55a14c02faa4d6475a5ed5a953e5d52ad1b2f39ecdbb542d849898d8edac3f67a9053c082d6ab2cc7783dc5f2379b371d4452930ed0d747d9c02c33a9a92143db36bbd45f5afc5e6b4077d7779bc6cd4d4968fc190247519c84c76b4498ea616ade61596f00a6c972f6a29e8aad17bf0874ad9a0327317b838c2653c5fa9865d91e81c2ff899c10ce9fd1a45eaa6879af9ab40457254a8eab27bfff63f5ccb8faa463efdd0b8df5e71f634735abd32d345fbfccd2200a888c1a4e90afc0297900a5a186e97dbac58d27a78a5753876aed45c54f9988fe4df6239743680af66114a75e1baa4ba199c3551acaa4c1dd58c81e7ce5f87f1a50c6c2465acd2c0eae64dadbca696033a60c0bcb66d00b7196d4c8654033be165af9c8d3095966b51e7c67220267ad36e06f9192dee4b8c4d794f4b9b5912cfe1b3eedc313b2e96d94c21692c30a484cbdab7f08476bae14ceef2c894de2eec56e60e34b3045380c73e9963e7973a175319b8a2263463eb333efbf22024acfc3b3de0acd8e294eda00b2429a2025c08b4b275010930278a6b24cc09bb58738a1b9cfa1c6494d86825972cb95d1787ed66cc3eeb0ce605ea30a4bc765da9e9228b9b6dd9e5ba33a5a24b9134d40ec85701da4c3df49670c9498ae74101a9c95ed2a9e944bd5a525aa357db89de987e89798d6247f53c7f63f13eb5c51eafa757069c70e32aa70cf25bff0d08c0e7c2c7febd4f03adcb5c9b05fe81328e96eb500cc7abdce4e090fccf31f5542cc824db6b70e75528549d18ab58d1e56370254ccbe95c2bec6a526883cbb52194979633b390feff2e5ff6cb668aa3028762f629f445fa17a99e39539ccb6a1446d8001649639c1a0d1c3a33bcecb997fca6445bb45c6d0e0ea41d3600faf9327c2bfdf07ad225e30d3289efa5b141638c64825722bbe71353b5d69798ee945ff1533454c22b1bd8e611ff87b3f683497b2be418e380eef375e9e0cf202e861c49e1982460c220cb44cd5c5d7b786336d8a4138bf518a289edabf2a697e10141e6fbd07836ec08cbd0df0a59d4ed40b08f14e5eb20fdd08730a032fe6209fd2ff9ad06fef0b7318caeb48f6f8fc2db75d69c62a2947a22967f3ea8b7ee09a9fe8a089b49d30cc771b1a880e6fff5cd5a615d21a34bbaea25ae92d2956d4359eb9178f2096380b849b9d9088321bdc9598f7e6d38b04db3f17dd0ee7eb3637e9d84e2909051243d755f44bb36e6e6c4da1883f231bc7030afd0839240a2f4996fcf7f503634bc8b64b71cc0c63fdcfc22cf5a3ab0b59c394765744d2fecd24047e8cc218610fe20e542973698a3e46e14017dcf7e60aeb7d7509ae3e45b490b0cf74e9045403ed48d11c2c0ac70823547ea6cd3b423725e76b68df76a4594b2e83d11bc1d90cc6fe2a257895979c3834de05d8eb01bdcf22a9aec3b34f2f4a45083bb415908997d380a67ae843df1fe07438bef15c9b6a96ea835c128ae1e756b300dc5c0ae38aac94a62f4fb3a7cbc3c882ee5f3b115b1b71a6876d301423e2f886e2d7ad904a1573db488c9591b519f42422d4510212faa1949e3cff4839836a309e52ba28240849041b4e5e97ec47311e2a3401862af73890da5a2730555a209668bb02177952bb3b14b4580f10f4e23c6ec1a1465290cd6cd0da1ec0193d00ee3b8cbd60c70e5298cb096be4e97dec385aa34f980c1d7df0af71b27d5f513375719bf970fc753466da59f4044953f28c3f8886de004d84d78a8ea1f4dd3e4816f1c8bf7c8b7bd0e32c39114b6d69c546f4c24ac47ae1de0e152f0ee9990f4c6bf4508e166bfeb1dd2041915304f7d144f9bf565b5b67a6be94ade8287d49c5390591552bc3efd8f13afa0abcf453be4287bc4dd9b3d979390248f2bbf76916a6bd012c80667ef5196042904293661eb4e38e46033a98bacc244ac071026df6429eb8baeca489342aeb2ceefb4ddc08d2f0adf6f4b55a9cb58697c86ef4ce68d25407deafd7d7bb770087f8dcf754a366091d706da66b06d683943c3df674b1518940c03882df34f434c03644d3860327ddc457d1d70feab05370e915fb72f10bc10dab0f103e5f86a4bfb4079f0f6d1d520ecb53636524c262f7caffd60cd993a89227182a5a9b0c0d2541d8ce56be0cd4b8eecccf60ce11ad17521bbdd3c4862b78d2a18c286c2ea49a7056c7c8f9e8c30be901c8f43d0b38a58edcde3494afcf50be58018500a86b1ca8a4bd524973ba7606c931e1811c02714c0452b3ce1738e9f1ec5e39de4c02c456e997ac84cbfaad6cfb541736c72dbebc29940e5fdb21ec075a35d5e8438952a5583c039a7b01694f2dd843515e691c5c992ae14eaa77234e03a983eb3274fce9a1fded5af4c2b08bc7aedd924d39d3a2ffff6b77f4842d2679d823710fa72d4df3757d0d2274196c32a903582a749bfd47b6d6c8f0fe51e31d91803c1630ace916390689c6d5ef404e0abca27fb7bef61a5f2b03aa6ff4cc90a27867461aa25183c19e7e1dcbfaa2e394e5c0c351a5ae393fdb21a4a6221fa36808da2554f6120deec92286782e56317ea93c1bd4ff07fb14338ed0e870385f4310c2e7bfd3409d6a451ae70be196e727bdaa4e1169437b1e408a611091588939a90f3fd63e9172b6a52230056451e67d5e1d272d844f976f990352736ed3e6e7d9077c6c88358f8f86b32700ff854c937a53d316a2d36c0bcb32383f1981f379fae9f3dc5a7ded3ae56df7b58eec27b88b321f5eded0805bbcc33742c27d244b18db2a1b1a29cfab59fd2de6f3086cce3147d24cb584977d920d3472e535de3c36e07f95c66d3678680348cdaf06b3bf05c83635c7a8c09ea8e341b75cd688ce928377363354ddce0d4a185da8b890990cb4badcf0bf7625ef514522c27b050099ee3966ca3daeae4b2d69e35a27fc6330bc365364bca6764a18b74989e9617c74a510404d260e01274ca1e6c7c270c8a2b3d2258332c14906610c77dda1d00046866db08c10ded23ced3ee21f0316721dd27a8edf2edd13e4b4559b93253d21db98854cb149a496bcf4e9801c1bbb431195b060bd2ec1aae3680dde87ec33306784d75d03648e6f1c676d2a0d0caaea971fd11d1ac944b59bf1677204c9d8b855f7602b4105fa079a5a21f1d91bf03bcbdd3e839a9ff2b307c64f60316b8506b51f66afb3e6f9e2cc3bbbe6f05e3da8ae9735eee4d809ec2119b607943b2f650a07a55a8d5b9752d0b2ec26190710c24bc0bfd0f291091b67a05d0eb726d308a250b651041406b6476156485eae8721a220e827e8845a1d23d75e045ade00b134ea1ced323c883824ac68600bf78d51a21a8dd3447851f010a85f4f8d106c9ed7d75884ff2c81f9e6e250828521c5f66cf53a3de18ec8fa0c8cf2e179afa613dc3a6323a50967a8ef7555dedb8bb90c4a932374b84ed5c696af9476f1c69a50686232a02e92283d4cf404d9cbe326c567f633a9d2cafa30aa178d8b1723cb90fcb76e446427471fc32d9f1b9f13cc3649ccabcc4c1d19b2e06cee77cec06640d0f97c72f3640cc0637d4c8b9cf2bfe8f62562e3aa385f1cc57d70ea47cbeec40c17438fa13bfeecac26601d9e517527c4497a7a4465ba12878e06180e04d970c924784d87bf76de0787633fc44ee3fb757b6c2e6fadf6d8f57727b8c884334956e6b2231c6a185fd9be884627b179e55d5122f86c9a87e84176e37f67bc69136f4d604dd8fb5436c13c7076db141eb907c4b14729f263e530714ac26bfa52aff12098d9a4f7bed364eb6bc664ff6a7ca3f5d7171effd6e9d5e28a760bd191ee98aa2471839f245b6876f6dd42e806ad795105092609f1ef49bbdff54f8880cde4a7b9b7898b8874ea4ed9a367041ac498fbcdfed40040992df8a0fdaab6e5913d684b76d90cf6b89ab18a647e8edafa12a0e0db18a4e2f3cf0ddd231b4ee632349ed7be4772b319f9473cc6d8ebcc086300cde8afa86c91829c4e56b22f41e972b27850edcc03b0ba948cce9181ecf6fdd04361b0a5385c4959688da09ad0e3e26356184cee5c2969e68afabdef67e129aeaf2033ce72be4db3082121cf2ca60eee701cf8b7f248c7a5672c8f938ecd6affe1140e7753b750e529761dbccf073a030a8730cbefb0c9e0ab2d2c868424a0bebc99ed7d014fde2dcc242b55a6e5a5759faaf46bcb86ffe9e352e6ae694edaa583daef3a16c98e537d7ef70efad23ef5cb75657cd60c2dbb252e48e181f0d621e8a77a850e78b47aa3f5c978b243cf41468207318c30c5fa9331fc25d83f0ea62e722f751b47c5f97185cef54161ab6593ce77c00925847d1ad96dfcc517b281338469198ef3edd23d17b64e22a9d2ea79b2c6ad0c7a15a5f29c268747e1a1213aabfbec58840d195899cae56ead502090dea294da9167b217c7a515e8a949a1d96d6ec9838accd1963ee302f3cc12030625a773b94663003fa1ab1bbb184a5c8d93c0417999dfaebda3d2432ed5a04f96f9998f0cda8ef9a4e67e1e47ec44503b1a16fa3cdbef433e65bbd7278eb2e6708e1f2143e57af9bb8bda715f900971c9bffa013350368a0c26d0ee3091f621cd88a20e2795ab0bc2e8b1bf576bea39422f42408f69adde885d7853688b0e41396afba412314b024a0b83ff424c3167dfa1ac4b1da420922510e3f6d47cf1fca453b42329afb6f3c1c759ae7ae088a7557b676530bc8ddf8324de148ca4af0c84a65b136ea8ee0485eddd088c6dec5ccc375ead486413a8497827f33416fe3c595cc0662d1067d152981e6520cfb34f708612adb962a9fb88897e26b0db17ac5a549b0fea9cdaf95163e17ffa3497eb7c31670ffe1c23956e7e464622fcd42f73fdb544bfc3c6f9786c1eedf25770f0185983415cad5c2ad66810287e7e931931f8313e3ea6a7b7584969ea39ddcdc4eb09330b94c5296461c33c97c6b6617da8d0e843c8bac3b56e3866d3e337374f289ef8e673af70a06dc2f5b91669406131c1ff89a4148fb0cb0fc12ff66311ace242feb22447c9b1ac467f3f719e48bbb6e606a07cea536339a4b31f976a8fa19bdadacdda388d79c5a33050183d1cd31a10ad8b6ec13a3f0f0d190675e8ccae117c38a1492d634eca3ee2cc795f5875aa5c208122980975c127ed0592e445a6cc55db707b31d775788a020ff44b63bb1c30589ae4354a68a1c4148cccfaa2f376c46887dee362322504891cc968c206baf864538651174158ae21d046ec83ed0c492bc4d1318c488d60ba35a61b908deff72cfabe37b875ec03142c2b392735e65ad6d697a227d25e088687f5042507e2df3b315d8489a51d6b06ff0fa0025032f7d857a56c7cc791876aa48de80c3417cc890285e7061e0f76cf52d6d11e9457ff1e8e0e72a95779e8a9412ffd4d042468fb76265494df6cbcfa5f87067f4cd40bb0accff5ef5a53f78f04e8890202cdbb0750f2f174549d11ebcc529ee6d96e36ac7f02c2f57dbd336dcc779e3a75421e487e6be86c48f1abb9e5a37d8299021ef1c7a78527ad8c80de66dd83849a236a27f510223791b5b16744791dc0db9d85fe45a859bbab5f77fd14985b9f8732b704286a40b5153cc8110b9bc62d0f26ed94fff68591f86e315d5c0b0d0fdb44d67be8eb63e9387ebca480efe01e286cc08dfc8899687f63c26d8937bb68865c888cf1402aeaf8151b8fb8caa3bc04573a60","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
