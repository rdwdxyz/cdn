<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"beb91ddab50fdd132ea1e91b04f9ec2123adb8abd0242035c0ce28adccf38f665c8be8e52ee41b9533b167f39b0dd3c66e0a2cb59d1f72050373875f1a81f781b82b571c3be172f8615883abf6cdc73ccf7b94fba5e8896b4e4e3fc89d8419be96baf787a858a820a31d16692bd1e117fe437d9f108f19937c4c9f42b7938808225c805dcecdda903acb5f4dc4225e5ab16740ce37048f29f2ba895344b6de0ab6eb0824125c8330dbcde88c34a67959b512f5b9f4feccdbb902a83a813fb3c832a14edc695be46bfe36816864cc2bc479aa4c3aaa2c1a21f6a7f3f91c67e7e2e8326b97a163d217e1a5f85c27ff43f7c9984a44c21e4e96f4393e11d4b5e8f4d1d7df156f7275ebbee43463ce4e66b727c74af7f937aa01ea5cea4a0e2201dcb243bc06bffe80323a60bf05a224fd08b975711cdef264c81bf22685c33e06d4f975c1a9fa3e1a93a69be38b434cb1c24ca8448748b6605d74f89097c7c69c79151f4066274324c7a3c484996e38b7b6b78734129f9a465620f706ccf50927c4b3794fee1cb43ff99ce687d41f64407a5471ec80d99686db7afa2d0ac3cc618f41e0a141a3f0d71840f2f855070e255152f185001d057841309292bbe53b3fff6796b1f81fbb748bad23a8a48247d83d644f59efdbde216eaaab8645e56b1c4966f7f7fab2aa13cf0668389e674e5e8dc5636ab4dc41d36a7a29121efd30534c9be8bce305b950c19f2aa09b08b4a39c3ae60e9727700335aef2f96d83744e03272d518049a24027d146c7a7f788638154faa72809045712242f9737622e4c0b1caa0b864750876d90d6eda08f5e0fee9826476a22a5bf60ce1ba94cba81148af4f5251a2fa7b89a59ec7b5566caf01cb42b4e2a7806a1c13a7f8bae0053d8f348b1fe8c95b41ad4eb392fde763e082bcdf32c1288261966dcfd35d83a9bef15848f69534b7b7b44043813d53e9841319d5bcee8abafbd155b3fd7c2b8cbceae7737e095d66dac5540954d67c5f0fba7684e4a61854e2523aaad7c85e067f271f9853cae9fda8c5e4e519ab7a14e955adc4776194be00eb02d61665592908a96caff8ec219fc758a5a9f36d9dc81baa7485fb63380fc1bff71f83b774d975f27c1b4ce491fea63626f15302900d54fe5c752fd74c6fe2f6c0ed6d437a8e8925aac30deb1be1258e9e253bbba076d9e6b10c881782c3db57f3573df36a4755686f324738f20dcb18df9ff46ca43c8f5984c115f6244d43135e3b14321593217289871ff544622a80136254b8fadf9954f57a7b18fdaf2020bc2638460061fb480d43acc3443b2b45875e1e5b640003b64e3e991d97afc6a52538672768bb15c0faa633da493eb8885dc28e56d4d3024ce1a2103cf397dd22fad3ac0ed8aa2489c57289bcd4d4e13bfd1b460df24e85be060541366b716458b166b06f0aa470b2628cbc6e75475f86f2bfc6f4deb0d52a4778fd3dc2054c9a5ba66d6168084c8fb8c6be6d7703249b4416bbd3129032d88f53fbce77436b0844768904c83c14a7433127f1b23264c00ace5c8dc06f33aac227d7d9add697f63d596f4d6ecfb2b44e58ea051a0f2b615702c389474117c777bb55b3f07e3ee44c17b657ff11901eac7f1c1d2ca55e445330e29ff2977aa4d54207602e675a4b25c7d25f4603ee855cf97bd019f6c56d2fc702dc61085c37ddb0e9ce939c0d6384943dc3c6197f04647c6bef57bfad20b879ecc6b2c6fe44ae9a03fd96b4edd020441eb7aa533a40970cfefffe04ebfb45089b1c3f66ec1806e1e25b05d5b8999fd0f00eddacaa5babb9f31076ca720e42bda23bb491ffcc1fa49b5d7132f2a9013c52df97ae6e6bab7335108bca9cb1919e492bf49272bbde5531ae4795a037096633a0e527066fb2d03d2dd416b35b9dad171479aff56a0cceb079a1360711ae1558320144a846ad88aa2aa3649f7127fe34a70b8c9ed015d8fc560dba518630547d8c452c58caa5f622b324a1751e931100ce222652bf950f6ce75446b3a6327802f34ba5f821a4f6bbb882856b92cb4f6019561ea9a45c1ed6480544424e10e75b3139303f780a5189b8cce12522a444fee768166358d388b3469e48d7a32ca0c82fc69815d203da53a8eb6364e44b0d5e09555d77b0458e57a85610cac170dd3798358398edc76223563d8b147e8cf1ab1fbff27fa6d9dd35db7153be09334a687cb25617b7c6b942c226e087990332c278f51580e02c9d8880b4ca881fdf9c1d7041ea3fc251a59b2dd443f394e48ecf399a4a91b97eddc9784518a0321a4d701d61127715247a0d3d68ee586422e2ba89c2b6d6adb8e0374b232d2f9775af81fa9023cae83ff628badac47885c0ca74b585ed191dd044e22f958f191798af04c9326886e7824c07119fd5970ae89e9bdb51b054e4a14662b6f7e2cc48bf9eaef3cc793d7b7902062e6b5de398d125dd6f8b071beb072b3f0f214dc0f5a5abdfc0e153915cbe420739e6409aa6178e5c70d8dfccd5fc18fc9ecdddba469a08ededd3e213c5874634a957fb35c951736e0f5cc837b4e8e86b8c32e3716081d390347862288d8bb9973c9693465903e3243dd169d93714a93abcc54cecd3664d28fd7f93e344126dcedb6f49877226795fec8901ed4c4dce028547e89bb2db1c16124556ad552568cd7e2f5ce1cac19ba32513b68ad8d22b732732980f811074c9bc730815fb383595d1a00f3274f78dfcbf3afab9945fa8bbcbf9a2260035c5c2b6753d9188b781350ad0642f4035eb164221649a03d4ca169b9c047f382390b2ad56c8fa716df3ab66cba05ede32b3ff3948e6af9d908398fe5a825a4781a3c14d5cadc5940cf50211f31df540b1dae1376d212189472960ff8117bbfea81c4c3123414ecd9987a60a30515b11a7dc8ac7b2f760f326d362e9ab16e7b65452dff553c333c80d65d8a4cac08965c3b4a60da916519759d1e7673ff752d58ab95c562178da71517f0ec68b5c18b00e23640a8cce069bcbfbd1260da304b9a9d4bc053e37948bf57582895bc8c31d3b58149e0d9265f62fdf86950faf9e8dced4b65e92e845b4d21aa1ed7655b0ede2b8b01980d0ecc06fabefcfa0836ebfb1781230135e6707f7872ff3d87c6c42173e2c5d9196a31cf7339400d4157c419d9ff1e8dccc7774c159a068a8844d8740f423e729055efe4526014b08ae65f5dca1484207563d1c7072aaa007248001563580f69980cb2c434bea036ae4bd5ac06fd2f934a0feaca8890d02a12722da1c00cc67e42391cbde21338e7eb50aa09e9851e3fe8d745511238080172a3ac4378f2c596a79b0c06991b45762c3d455c6d9cdb353f7277984c6d12bcfceab1ad4598e637e5de657f23c17a4137daa385a12d6198fd4d673d5730458627b089f4accff95b88174208fad023170a53a9b27a48d6e920de612d637068d46e48c49c9cae13428a8f9bc658c49510212edb81726399f2b369ea873f11987ccf6b54165033d8067e091cceb25a16074d0b53c0dafd93b3a3c8a6df877ccbdc0074b09754eeda532baf901a762d0f3742a1a0c84ff158a09de487112d8ff1307d5b9dc6b13ae71cd86192d61a36de322d61a17f67085f992c087abb0b311fe6fc6ced513614ea812fedbc0c5debd81b9d9f5816234fd58661b538bdd4cea2dc0e97678996975f3bd7bcaccf0567407d5a4f28a5b9d6ddbbd457ad2426bb44f4cbaad90cc5169464b218c6aa336b12b6eb6893f79093925d0f1fd7584e9c6a4b8207c6990178d8ea41b62d58efb9bf59e300e5f851b2f1db2bc7c9440071460b2efe120d6802ce7bd6b2c4e9429f5ff3f1ea4f10c1d36d127be8e42d77ef09fd7d3cf04c93998043c96cd1d585b7e8fd7916649b4a9ba24d32c8a614fa12a1e4a4eb35f4d642c1c6acfcfbb9e92d45f472dfe6241f235cd7274d3232b0f71381ba07a0635bb3316022c2d9accd708e2ffce427b6d8697721b27b697fcf349c7246a5cfc88b197cf0fc7742b7e8f400c2de209e6cab09abebcba6b34f5766184dcafed9013323d618e3d0a8e4d7825783e9b1ff8384950fdddff8b751978a7e200dec35a4d36f0de98ac85bf6df06da888cad0d7378b816592d5633faab1bf432b090354dacef5b2b7189fbf3fc084f506af8e098e195ca11e76eadc20e482d5d0fc367c193cc83ccea3028d000d48b5304304a16badca93d586c60a744113bd53efb730e256ab67c0ce0dd8bd2abad8b515f0373ad0dcae76788b15524f9ddd7391093b60ac1c8a38a1388b7190ee6770558af8b3489d01b12bcae2ba7d3fe8132669d803fd2a8eb5886a3e2bab1dcedc4a7c8ed320d257e408c15f0b194ba576c03b220f461cc1af942f47c323f15495fd0e6034e24a71cfce0242af61597200eafc07cb4152a6fba41b4522f078fcd09a81808f27815fda093f8fdb480c0c394cfd496e44f3567501a64b4785de9395655bdaddbf1037db0d9a6fc9770ac257887bb57c746b5904e4f078a08c1fdb203cf1b682398d094ef4b5459a22a9fe7a0158b7b88d2a7bba33bc1f21f4aca83def1c10e1da9e7f0288dc7265b5ddee1dd2b65e26997226c44af44002abdac969bf514019e6fe4cc85c0a2b16dc797f729799d7ee8057872b632ba8b32e056e5c1828ef286e1355538e00e6cfeedf24a2229c4f4ee356963da04023e4a959343428a54bf5e483fcff0da7a664064d01bad82edafc5a04eb51e561da3f8236b30b196a63e978ea2a7a1f131fead08777cf73d7e5edbd5d23f624dded0590de2c4363a88c5942ee5fed88d295efc5e0cd50d91b092adf95850440152e9e0ddd02fd275f1aba03fc441c38505e95657700f8bb0ce77400349fec442f44b407551f15715321cc063035c01a15327e64de8674c98ccff03d627b73b1aaa53ce84213390bbb4208b48e5f1c37f37d395cf7b7ca7d79d34d7e1e95a8c4f606da2261c7c51ddfcdc923c3a5378e3e83a91f8efe11de11a2427b870868541bf9328cd6e7f81b9cdd061f0c36ae9450530b26f0b972dca094f5fcd0fecf16772e26f24bfd36a989db25abd855379f68f6678c8f40edd28648496d8c382de40736947046f2d721546e0d059919c4d6b721c7b139ab0e885cedd2d1f38700006bd9b586c9a5d95cb139e093a5b8e38c2cbc7c331cd1ccad141ab3442143575a9b4cda11fff172101040b7d6a5376b655fc68556633ab7e8a3b91a95f6718cf9bc145e52d00d098f75ced5e66bee18dd56c93d0c64e2f5cc6d34d448385032d717dc48c54dfb25dc07a0fcc4d166c33d8740535f3c973bdc4eb75745e1cc5ecf55bc830e2c57fc59b2bec06d8add574194c760b1fa3fbfbed01e3ce397040ddf5d6136e8ea5e07fa7d88852ef1e79aa3a31ccd83f730fa4791fd2a940bd044f52a45b26ccdcb7c8f054d2160682900fa046284fde04aec573913c96e08e2630b9dfa48f7a5c4bd14b296d04f835cfadf05270b2c052109b40cbbb02a4ec5f05e243362e4b38cd6f05b5a8b4866674544fffa291f9738c2b966c601b92fe1f0371479ce75b0c75c63f4591df823c5821086b69d904feb17f840767d888274759877031f928027a28802a2a81b5f40d460f228799e473f2f2bebddf4cb0392eddcfc87e1fca8fae9d77db9e3990bcd631ec5b405a88bbb80cf1677d7a794052cd795cce7328ecc04b6ea9d26c81907b543f569ddfeb1eadff7bf21b6151b4ecdb4f697910c66908bf75fd26f1b9f9391f1fbe6674e8afe19ab81a718ab0494f90655799ae44e9def410a30a8efbfdc7804577dbf46cac49dd5c8a8dfbc027401a4ed0f3abc2fe494c68dd37816b71a5718f8b0066758f7473189ce6f96d813206c4078dc549d0ce6c3e993fc6b58c642f17560408aae78e3b35bdbc296b1fe9c851387e29e72b3f041c7ce43700a5f5b2491586708f473fdcc60c224676b4cb9bc55e727d29ab057eda65e46160b210208b3e59bb5c0c9c4175fa27d346640cf5f5d7acc1cdc84cb59b92d791ac7f4387a7a713827aee24ed13e435004186c3d6323ab6156927f1b2bc6fd140c94ddffa92b5ccbc2f62069a734e661b7c8e04254c55bc31190ec7f5418a9e1fd5c5d9eb5a8c28a386c23ed847bea421fd1fc6d7110039fbc04f3c1c9da3f9590353b2165ca51fec60d43bf36d5fc6b0b357790b49066b81455df877c335c57be41b7b0bb04917126b4ae8fab6b0f45261d0a59444357d04edf3a43326b0ba5de15dd802a118827547291a4d0fdc72f05dc1f0cf59bf080184b248909828e321e577edc8c1704f1ca347a531ed25e247fca7914253e73abbbc47343f76880e3fda10e8c61ec76e0d5a23091c266b1ffa6c1c5a928aa2381cdf1b949d39ce41ccbddd70a500b153e543dd6c03f9ccb13c9e010aa44a26b9137971adaffc208a509b788e593841ecb71d021cf38ed5911d99c2de5a3b9a0081da3bfa4b4a40e755e4f7c9404b67f335bd43cf76cafd072ca3f1423ddabd497ad94fa3ec8ce8d8e494dadce39e18b0ce939a81bc930ee39892c16613f54be24ce39da36c03407b6cb70245c7bc2964ec680bb772dfc2fd9e82dec26b4d9982de87cd591252edadb5a38a3b16776ea44461ec3a16c6e1bd5d35de7400d38c80eaa4d435338f6e90044d7367e5ba63c2160ef5628aed22ed81b8b443ce1824a3b4d7496b4d51a4ae215d9bf2a010aa3947bbc4041cd2f7d64d0b7c537a7f1a1a024ecfb99effab75006b508290660c53a66e9fdbc1cc54d7aa5d283a7a8e100b7d5ba9d4322facc63f24a4ae94c2063e7845fc57ed3d7d2b0f9320f7a478eaf1ad75f52376575ebe60dd4da4b518c5ec5152d0359cd61779de40ee7aa901d9186832c27bef8c54ba04862408dd9d7a3795ab7a296f89d01c064ffb61f275de600dc9d67cbb24e08377b35827c23b54ab6f5bb97239ca20008d070aa393c5ff0acd0a67dd86d1c3c391ef6f7671a22bdc1288fbcdc4158624b64e3d967cd3418dbfb6cbacd6e07fabf68600970f969cbf819991b6831d3be457753f28dc57d5ba24cfcb9837d14606d3bdd05e7a459328109a182beb22e0656255391561334c4113022faab2383dd3dc1df7bab43f0e972fea8427f00e582e21e6b58ae6c44d9efb9bf9775066ca9d83447475efc23b3ad2fe5e48c6cef7af754e46fdf40b7e6f572e9c3142b83b5fcecb86d559a0a8995e388cbc4b177064e6bebbc0e8e108c2af416afcd13c74b4bfb44ffa1b032c90143973f719ce59bfb8064b58e8d0b51a1a28b2b1949107372901dcce6cea881b09b4af03e5f457fdc47cbc80c7e9c5aea60ca89a20d08a2b3b867b5a23802950d2325f708013a2c62b7e5059cd9aff2cf6119eb5bf90df694fa63812a9f84e25c02bcb8eac0d138d02c68e4e1987b51c88097538e8555646bbe584d9ebb8bc4b8357b8ddf8b9a17e93446c8856b401067107a554da1e5325a7924d9a2bcddf8816adcb2f206b6483d550e3e92ab4f9a8945d9f62bc1a3beead687c83d30ca38742de6b2a9e6c8fee66f616f5b796de493b0277a681693beac83e354f9ecd7025d74021139f903bad25cf7a39a1089d4b7f6d5ffc864f12d06b1732624a388fe741adbe62ce7d37fd2b110e2935d1615d354ef3f6fe0e1d90a6bacecb3579bb741445e55a888fcc379fbe30028eae376658f6361799de35f327e1d04ec61dbad636b7450ebc99c3f4d9a23bf191aacac96226881ffb6b73d54f6c7f9cb328f608593cf0246694aa5d009906895a19b94228dd92abd0d7957ffb4c7c75942b6e5a17bd10f3ba670ba32787e70648da3fa8e8c039ecc0264d4e779a1996cf1a145fd6a52c75c697f57bf2917a646e4986ee41c3f6e33e132e88f3a9bdfcf5683990a64d5e3da70a1ff04bc9924493bb824f5541aafa49bd76bc7e52d4012dcd0bfb232b4a93280e8cc1fd122c600dda7ab680f69c9508fe8985ccd6bf79c8554be3b19e36b08226facae74289314ddb773e011da1655a430e75ad8a9df24ebf201657e1f9f2789e2fa594c1ca2f0bf8b45b72dbd976d218c1bf92b0480391098bb6887f9294ca1003cbfd7aa8a6f29e84f573cf0704c1df7e9fd1f889398c31c3e4491affb355f02d1acf3480616a85380bf47df23d1b87ecdf26599220da0e57c00192ef1f61d2bfcc37838d5499b76df3b97c0bc583ba75149d0809e1ff8f59095bb8f4a1f8bde0d159552a2b2849787b3723c6a25d50b03e3bf956045cad67da4d0324c4f597200412d1ff091a8fbfdbc80029bee983a235ccfd3d1e5be2efa21ba42f2d455ca295dc9c9c9e058d5531450fe6768863f6ad75d7daf9fda4a361baa002a5b929d3560716bd7f016e8ea0086584fd9ac3eb3e33f7d52e65af99066079e384a5daaefd6686d7adae9ed9ff1c9b19d9e1a5482f85c238c16e83579c1c0a2a87d3515b99942cd0b303a836569736f29431720aa2b15eeb005d786d5fafcfee691f7177742834e816f4a81712121023c31888ef1a9e08a454c0e22239851867a6a11066de472b853b05ed4991502b4b72f7a89acd9662d170b56ef5e167c15420356fa4fecb5905cb392dd9ccbf5c7f40f10486de5e87faa097830e85c07c2f46069b434f34776bf843ca2e89d1c327e0aa60e71d12920cd77d7dce1b92edf922d4c2bc3bd1503690a83fd3e8e9dc724aec0d4b06a2ec7b76bf2efd33587b8526b974f1f7d7e41116e40085b3e2e30b1ee8b64d49304b1a73ff1c1b72d538c6afbd244dd6b1999baac92aa31c934b1e202acea7a31772be8aa9b54d76e7b987c46f13686a0d02d464ded3f47a57734f76026e28c5da39df36d795cd3bfa9f43effa20864d6a832df92179df4fe0a84efede4777113cc42232ad87efcb09afd54e8baa0a5e06062e8d7533838899be129a2ea27a16cf985ddba133b2e01ca0e63356eeea999a5ef994be8536e104c8d5501014900e19f3e6364bc434c5e5046a8fa7b66b866bb4cc6f3530f08cbf27757b1d07ec71961e188763e2b8808c21f6eccf29fc33d082b411024cce00588dee06305fe065cae0384ab8a4c7c6791e35a4c5fd51051645d902e41016f25d07a6303b6e38925e407b42dffc272b9c7a88b7e57fc36f46cf90a89b2bb70d58e9c97606521258287b0115b1547819b9341f871554c4dc581c76c08edeb33f3c3eb75a9ef2caa84720f38f39abd1a55cfe410a7b7fbaa3e5e3ec07b8a7d132c093b358096e0389e2ef741eeecea21562e64f68598ca10552cceb0e4408de0df26e8a6c97aa1cb5b3e5d74ba1a581dede1bdbdb525886e0e2ec6f819635520fed3cb0c7763a3f33112bdd03bbdf690d53fd47d883241ad130f50d669500d8ce39d2cb13471760ca275e7a63d9237f97a8625360f7732f174bf93a7054f389cb852260c925fb2c27fb20879610dbfeb6f43ee0c8d5c6280219f87074cd9540797be7c66ac28b0578644b10980076d26494943a7b75c5c9d8655f26fb4872c338a9bc8ed702170fefe2701e98981dea313be471a52ca8343348cba4747b1dd47076fbf3c75194266337b7d46f27cf664c030e83d003d7d300220a10314830b7a42f24ef8ab9db070a72b6880283b41bdc71d2d73ca4c4aa683c4e6c2c357ab603f767ae185d60dadb8d46db8482d1473f472f2a6a64698b78aed2c57496b62ebbb3b411207d4eaae7b9d8bb68f64bf25b0e2dddac6b29ce75f344193fa07ef4e491e38442ec9b0b0d3c84bf15fd60aec3027d0734e027bc458429fea6ec2621fcd79d4967b67542aab49be33c837a26ff8be4719d2c563050de360a31201a3e202cf464dd29e12b2f1113c4f5eefedaef135e35ab02ea24598b212d5777e0ef8b3a8a63c7595b7a10bad1a08c24b745b95f5de3ee91f46150c3f147043025fdf60506af512ecae8f004eb921d353535acaf205a2167b2cd3375ca5869b8e8e47bed476d1d61962f69c3da8c76d162e805b245ea307a0fcebc750752177d653e5bfff5da59e7d9b00803e9a57f63957a31136a4b998ba7e3b07a352cccab8e0d267a9d459a877db779c05467a4f9cd8786ece7fc3fb25a222f16989b882e536c6b35d476d95c872f4cb380486b3210a17bf0adf23a17e2492d7d335f74af450e5371befe5c8a7c706d824a228d500ae1e636973f5deb2786bedec96c956c7dc6d31f5277ac0db5a71794e09b45f511cc6a1a1625680bf98333d2a8dd1a48348fb1c3131a91faddde5307d6fced7b2f533b0b21dc85919e78403052ad36ac306bf9abdc1ab8c6246ddc7226b1bd38dd36bb184dd0181fd1d0987942c4666c34f7e3ae9b4aae0c51abd0414d3b5252512e9471c933419a03353138b0e59e897b69b3075b209ac652dd6c4685d9896746200f1ad2798c52ef3dce2f5bfa703c474f7c30db88c2eaca022d523580b810406077407429f289f785e3d29a7523f7a17e6d3618fc1a0ee7445098b653ef38203e9c38fe961f0fbdb4ced3dd176b660e43848b081c952eda73e50641fce6fb67b1f2605c76d60ae866e4cfbabbb660e47d9c9137331aeca41a57856c0112d1cf8310074ab347dfda0b2f5450f0478ff971b4f1921342fab3f52717ffb4d33b5e88ef0ef1a05ece6ecb5d6402c7bc29259a102ebb59251d1e384e763d43f9538609d91da30d56cc2b5fcecc13b04cd016cc63d310b89afca5d01e1ac2e64b83d56f3dcb40b57e28ff008ea4493edf4e7d506ef10377acee2ba24e49f1f86b67bd43a52b50a962261957d3b886875197cf0bd1e6060002201258e1b2a1791f0d3f97c241f15c949d70b373f16f2c229fbdc1f4f1da28c1efe38b5f2fcbda5a6f35572f3b6fab00557f61f3bac224a659b3f45890ff7e2ffdcb887e703b2fed0b3afde7dc2a3268a826d364fa18173247c326d75c8808ca7217a9b93cc3391687dacc7ef8ba754420ac75414f741f61ba26b86208df7f29050e5a8dcd3034f52b90e5f1561485627e9388f34da490e449e80fbd8cab53491213af1e4388acb5548ec7c5632aa1265ec553e01e54f592ec770a13608defb158b63f62ac094d9e74f7c816e030045ebb1b17233eabde3de9eec4c9f96de44459877f8eb23d905e5a871d0d8da29df25b4e0d7018da00bf5243e28ab19a8f1ebdd4918eba4ee86aa17e12bc966aa3f74ad57132dcd5d149c53ac277b6558d7cc845709e420689849bb1e4cb1b43af392698bae0e5cfb95e2bb53b23367b96f47bf9f2cd323d7faccc0d22ed567e44d88e9e86fe540bfacfe21465edac49183c3f6b0b43d6de65ef96272fb3e7df5a384790717cc0783de5a5b7ebe6667d1165a50624a893966b9a4d0a09f5a9ea781f2978f5404ecd29e2103a583667ebab2d54d225fe03ef9fdfaaebb87b929e0577b757e59130046942d20847ae9f55e04dd050d7bb338c378a4a5f64424657062f91a58af807c9304d6a835317d193c21aca14ee70fe3682b0686e9387e104fa39ff2acab327c883e439095dea32de1765125e201f74cd91b6245e386dbb42abc7dd073e5697009b02c314c992fad3c5ce477d5760806017ed7272b8464a30ddc0fe091903dd56181d1bce9d9986692c575bb6a7aaad6d1023162013b71a575addf3d098210c86ed378c4ed608d002c88b25bd90e6c38ce61bb50f0bef15e99a66c4a58bf7594976a98065c0c0a7fb95c917ec1a92ff2736197425122bf249364af3bf283f8bf422218b9bef66b42c646d97c1d620213c2f443f155387211dc4aa6c21cbd3952b14b05472e81ebaa01618fa3795ef9296bc34ea75a8aa12e3b6f8fbe0746647b143ab0ec8b1b42148cf09b73f5b416b2f3dcfc48d0e6c55cac991ad08c68e14922ae786631ed1aa3319e95f48bf6929a1e1fd1e04639678f0b02ae1b74f3fcf99b3a98f7395414ffcbc81845dd2b7da9c8ead6486855a9bda1dfec7bca0ff7b138aa11eb1a337946d4dbf683afd91d21cded85c292ffe08b438ff4b4c8e7ac95cbd5e4093e518abd122d96d84d51f12ac7bfc28375097c9e1bc378cf9d937bffa009f8435226654fddbd370d80e23e00e4d252483f0b370190609499f53a378bd2aaa94c0f80fa3b47d9a04f43b1ae890613e1cb9b20cae3d1e979f40a3a41d0f98045c4ee60ebdeca6f881da7b881b6d25e81de97fefac0732eb4d350263f08362c9927815de58f68835b8d3c6deec2b69860f7f2767532ef4521ea518efd5b002bb7d0ff086fa6d484960172f163276143df6d922f5b58660d237596d50737ef7d9336df18c6a40c04b099e4a7a358487846fdb648ae7bc6ae28fb8b03c1a250fc2a7145a94769e84408f10a2471d55683d811ebd6c04d9251785b7d73430648ccfbf79bd6f333e72b9e7396a11a260f09513b099f434a79bbbb63bddd14ec940fd957ee5933fb7c1782abb05be6e2d29c06df556a0ffbef55749d7349b13cfeb3b3248976226d8ebb644f8df9309b0d0fbe5c23c5078aead27161def9692ec8d24b0854a21bdbf9c9fd33006e4b6f1d3cb634c25994e57f811ee097619fd494c2912be3354323e2eb73e6a683a3832d440604b5281a554cca13cd56195291e96c62491a37ebf6b302db1f56a4b8d0984ef0c991bd070e596335e0bd04f32322b7a0052c2e8ac983a597878b27cbad60149db9ec77e2da01b6344850305c133c260f5342687afeccd7ddd9a8061ab72d7957840ae8b281c1ea21dd4b72fdf5f6489fb99728622d536ee821fc2172a4f33f4f45acf709c881881541cf90eed5240fe58dc6a8c83cfe07dc2f5b3b36f081c8891b2ae7c8b6ee9d09f3f01c9b265b1338a4d93c959493387c615e4f1a4822dc41af7b96e7572f323f07ee9eaf6ba7f1012e1a23f34bd3591f004da985f0fc3af79dedacf618e3daf9cb41cf90fa66cae90162f8fb5977ecddcc1b260d67480240f7ef3e27ff541197d6bd273b7d71e4f8d76f12ab1b38271ad14d0c8bca1ee354ff85e33233705f0faed399b55db202b5c1ffee881d7c9c7a0a80d14e9a5806e35eadaf79c4fc2ba391824370f98997043230c20f46eefba254f46cfac6e9ef45f921d758f36b02971a5d1c95362475da8a61a8838a12844a02427b4e4a90eb5b3155ad027a822e09aec5759f1e00381e5d45aa9a7c887e15aae6808bb02f7fc243e42e160aa1eace10cc1d52099d28ccdc87e3ce873beece72c5dbfa7b43e64b0cebef7c579c4c89cc58b4fece0799baf01177787f3e3e17cfe5ff75e81c29122939925634d871b92e80b3ff47a406f1386ba73a3d5682baef7e1c59de3c224145dfd6168ced9514bf1e869b83b725b6c06d4e2619f1f79dc904596bb61d521fffbccc6606c85606c64392aac2773dd51fa195fe877302612d0e1d73bc9ea211b9717be51a77929a4bdf1a8c3d703980c891a656e6e0ce3826b35c29d087320c3d644e49917642b8738b39eb7db3a59a2e8e6588e8e273416b5a0abae374b5f586b1bf72eb4488532790b0f288a9d329cd1e9d70ee817a6b8469b5120ad08788430064b2601aec6cdb280f1b14c99a9ff38a53757d3a6be6f182a1e091fa4e348ceffc4bc25f852ddd60a86f4cf4c79266130375ebb5820412bec5e02484781778fcf9a3240101a80f6424850e53d6162426e6fa3a676fc2ab2126c7daf1180f7e3888c51e459b5b28c46dcb57e619559367e44718e5a516cbeb42aea9cdeea21a6460e160fb77700ffb5710b0677b1ea7656db56d3c3456f20c7c46b3046a30469ff75ef409b1f53f5bd4d3300f1bc02b17c9ce6578d8d5181ba90d5b8f48c96c40e4022ac6548bc01d7082b4477df390b5357861b31c3f924504b39fc3499c7fc3571a13b2f60e8110ef969f329cb91d948f65bf0c8b7904c96a6347d5b17dc6ba938c1d9a5e16f46965e7ed2b02a4dcd27fce6cafdc34f1b86a82534643d873d11374c1a93aa7179aed3fee8e340129ea275bc16e5dc91e2a6014f34f14fb1978fe1167e90b97ec1d0d09e635ec3d07338d64391025dea6e82520e081d38f720dbe5e3239ed72cc6f85cc5063698bb3f10021f6d68e6b6e845eeb442f02aaa8e8a73a18187275d991127f2845afceb0833aa9d2ecac39828df6356d0675c70252341815904b67e5c5404396048e05debe71c23c28cbd54d7f0552a01e07d5bf8dbf4957b88425da091bb8f343122ed025cca1ed9088d8ce6340220f3501ffc2ab7928812834a59019cebd4861cb3ee27dd058ddb7ac21fd01de94432b458df56621b3e245b3fda9c85ae0af18534055611749f19040c73de7d176d5d3ec466fd5c63783c04875f724b7d08a9907f5d904f55188257182eb1d7d37f09993b07a2fca22141faa5d65bffc9eefb37d879557c0fd720c15974af3acbb74c241ea2bd51db7e5a62a65a864f95088ea206a5381a12704054cced494b11d33587062da3ff98ba602e599b5201a6966c060f4ef83147d034992d9ffb382db3338f7c08efbcc1d2516d88a1764d153c1e396e24861dc41bbb29e79ba1bc4cfe94a1518c08d88d3b44ebb8938d290cd72c6894459fd821b1ca20079aa2bf25cf076a8b1de5a8493a82044ba173e27b316473945eb2baec82c7f3bce3ff13ecb73b1b75e71b3182e7460d8fc2e92e84503c7a3fd466aef306182104f3e8b763cb9bd190ac6289a25a2ecb08b8c902f9cfc49c3814ef7786283ec1431fc1a5a6901dc135da4a422b22f138ea4e618ec80695d3e05c7f3e99cf261e9c3b80f92128d27d3fefbd98eed9c8156c78a6bc179efbc1ae1a11c7de6ffabbb2d8b6871f44463c1e9e6fdee0778f23b0d23d3912d228bbed2686139781875c5e01a63716d2bbbd96f55cd4520734633dad6f3dbb2a0d6de3a5023910bc060559ea02f9d1441d80b7dbd27a5aebfb54cab626edb19942d28a96ae6deb63be4c0b22846c656131354bae99bd776de509dda7282663f98c63ef684cecbc3d9757877fbc3d24afa7d14a1ccbc3c337a21dbec4f83f0fde4dae61eceea0731986197ee4937b7b99af5d5e3f6ffb6c86ef6bc7ea8ad30e4f299d06b59e76790674fb1391f811fb0936584e7cd6fbf0d9f8ab38058727eb7b901703bba465db144f617fb1a635f297750833115a265eb21ef1136f0b7dd58554e1c302efb08fada8802f40008b718055e53a8858497f8eb1a4b7d17b835cc767fac2fa42a6ed332762f8ba054cd4cb4ad21996d02409109d4f71c2f2a331ec2001903d7e17d8a790c88192443b68b93be427daec487e8f04aa578192da33be83199e7207cf78eff2e4587b3909d480ca9293f993a0a2d1e50d9fb8de58718a5f03c0c3ce247dd24f29693c48cda661a2c87bc2aa94b08eff464b501cebb1810e1a731ce1b431b068bd94f333938f173430ddfbe02793deb1b7c39c14b066ccc01f55092064215893f2461f45c5bccba6534d9464ce214d660f9bb62de5ce0c011c43eae8fbf9451f89ea102dac04d7daa707344271e4de3c04409af775c82f583a396533c501ad8f3132f04cfad6e6afeed31765d8e257ed3820239016a06339b2178bdaa170d73891b97d247a3b9c032a2b750b0f09dee858eac2ca3c90f0e6dc6569fee35fe06a3faa54efc2c8cc864627fb97aad7192be6f520636fb152169d3412eec121d9e03ef434d95db487fff327424162c5eeba5029dbada9a349cbe069f8dc79f263fee20320590c579e760482da8f48fe45825342e9bfc1d27bdfcba049ce2532c29b28eb8b4a46134cef000fd2cfa92386c5d832422b60da76f67d39b8bfc733e40fa397b92028e37d69078d9da4df9d290798d64e4e1f7ecb92a22592bacd9c0eae6d1b929c8947dbabf5727d0b0b11095b08fdd1fa4854fa75fbe9d67c2a5b9f32fb81590b6fd0b5636d41735149840c1ddea90f8a53f45b3a619ecad4116a4a865d775dae05e799ee9304448c793617bd461ac2294dea011065fa73348f10189a31087d76db65210a717658ca788ed092fb869adc8912baa69bc64336df57432ff19e12e7ea8266f4ad77f37184e8a7bce246292eaea13e030c4c258cb42654979432dca6e1720f6ccf1486f3e62854d897cf2448fb41513f1621010c1d3f3f4d8f6754c4cebe91da0acc4171a003e02af6f996bf33644f7361b0c339c2aca6d0964617866ec3c0be88c0233ac42ae13cb5d690cc403bc3a5618d18942ecdca4e1b2d93b7633c69eb26b24f8cf5fb4839090af7c663a37307556f8f948d894459c33ef268be737024b4b244f7de9d01f443c84b324f05e5c90863a0f9ea509ad329570089d1fcee315193fb5523271224fdcac121e5de409a51b99a6de75807d7fc748da8e5a4c7317b095762698d86c9cfe3ceacdf4ffc39975703aad15cdfcec139091460492d4a0818190805b0ec899f49228026fb1432450705c1e5cb51ad809365fe2a9bd3c720c9affc3a6bd1e02670bfeaa73488c60b18807b3b22332324eafef9376d4fa418084a898448d468297ffd638fdf990ebf2674a356eb89f8b9042d8580d7cff989703628d6df5c579e1bf75734b26f60c1037682d76e5dafe6f1d4bb29d902bf8a5400b5e64086794ba185e04558661f5f23162b1f6185532e3da7c21ea29287704a2d0625822aa5eab41054a2ef7ef87650f3c0b880a250dcd247dd9c95a5ddd46ec3f381d3831c8dc34e57d46b5a863d8e4bc508998b0a277be8d93fd6c2168526d738a5dfd4fbe2b3149789b76d42f72bc003d2d84322615ed4bdb5ac1307de14f0af775f61a6e5e6a4f754ec3989b0cf40ca3e1e475c27e127826abf592b85c53d9631b1e158bd2a9773dd1e7dc41ee474e4501261000c601001af64f4615e9a7d9404ad55b93b021af8136e6c955098e4aa85e5ab58b924a96f797b99176d0747d6921de4b73757fb74f230397850b17fb1d24b74790ff58bd3cefa5ad0fe1a3404cb8d8152da65a392f14f4c87f81b3346325cc5dcc8fc4b3430cb4a675e7651fbb95aac36ca3c725ce377e5ec409ad839c2b93cd738a21c1f89985476fb2d0a12b7f7e6f0835099ffe42b48debc96388e38e6a0ddac2e117069d8ffb56c5a3071e897fd86a15256ad86244c080bd2ec98e38b51cc9752bb9116624589d952904d17323d569cafdc0c2b740828c180f0d3741d7ef213e39e3403d1ce489e7f8f92a3274c8896bc945fe434a17c05b93b0e950590a4d6711f652e6e9eb7802fbf95d6a69f08d740f4e04f06a01331adeab4c0c8cef802388820b982ef640fde70f36c0e381303963500a7f1385fc21aa22c6eee2ced7e20456c2d6627cae491783e04d313a4da00119f14e99e4c9dc2ce4741a40a37d627b019fb0eee63f903b95d453f8ade0b6e01f962c47a9a00f18a479ec1f6ab90b0468b97696993c4de878a33822781a7882e657d894db4ec77140261f0f29a3d02da229cf8b06a8f9f09c8ab5d23e0ea6a75bd2eb836079fbfc8b87bf03896a2c22578d909d44aefe7f3d54f2ec5c4f27c72e98ee7945513e0e7cdc3b79aedbbd3e1451b356e3d95ad98bf328f0a160a28a12213d0a9305626418264617e01f924cf87163b360ed1cd094fbe01950830d3ff3ed3433a67b0b44755e457eb3e4f084dc67d3280bbfe1a7beba2bb70d379bd7c6dd041e3f06524fd3e3af7c644e990cbda79c6026db1d801efdb0a1fd1385757b60d3e1fbddae31767a525bae91f725e85faedfd4cc1bb9ef602566ccad6fc221e25e4f047bc3fd237715821dc448d03eda6e97a28da60f4cd7408062acca63a72066ca06f3022e7b3f8010f1b329d3c3404b9187e60110c49cb34ff3d3b76ff569e5a9281b56b099e3dd85187d4f279e197b39cf312375293f982aa13332a81235c36a82fb194fde2009493a956f7c7b28d441be2410060c5ef5d1b9a656892a2a4a61e25036c2ed015a4af683300ef4371a98713a407674443ff74bb51f74343c0f47fe299a9502a87e659901be5649b436304363f6ec03c2d5dd992d56e53ba4f93917c15590083ccc4af8d3c3d7210ff5dedee9e5d28682cd5f77c7dcc0b0715ce7dc0fa038ee23792c684dbb4e0b82b8434de013a3a680989","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
