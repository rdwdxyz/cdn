<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2098fb0787d5f7af7d7d8f887addd4700a0f14d4d1e40cb2818dbfd8ee33aca9519139a4979600a8162768c5fed045bcfeeac55e3607911b9dd4a68637ef8bb540c8d932223f46bea08c8a73daee4970b59e6a08ef6ddacc1b8c80753beffd25640fc884294145daee056c642673be5b825aa3f25d766091bf70c4537bb46ebbc9710233ebe0b941cdf62dec8603e2a3aa0ecdf9c76de89cc49f5ec09ebb479a4a82e975655b298806e6eacca7ea1a1c273f499e87646434e198164e87b54b3b38009e43a9dcb1d1c5f7b1f2fd15619e4ec98a776343a370e85e6dae1901035157193cc9b130227b680f6ebf71e51694029fc3d763a4deed8c8ae7e8d7fae290da4f5bfd09fff79626214b5c32195c3dea4beef57e4cd835db033c000f4d3afca6aa16b997e870ee79addc0843852eaa05ecf333264dae000a58365050acdd55b712cd5d25cafc5ea72e7f2a1d3f7b99620cd4af3e4b872f7f890eee8606e36f60269a69c5fe1b26b9741b696b24c0456a28a195fa62b327486901aa6273a9c2507fe30a5150c6ce7232e681999cab4ea450bbccb484a0848ede4d949ef2a81b61cfb3f67f370c16792dc7dc89af1f382059671d7d30a971b6ad849b1cdb26d4018e4315f6c48db623cab8fb046dea4a9b0716a2e10bfc4d7188b1f27c0da9636a4f120d75dc2d278ab1128b83053820ed374be0be8167c18cf0d8051159c430545381962e839f2c66d7c4b4bb04dc5f65211c121a247795cef9b493636a552c0e1027a00cdbe0aa98bf07969e9075d6323d35034ed201cc6889dba6a17d00820fe8d8601a210ea789f6da157ae9145f2a9545e4a9a62b91b23ee4d89c8cefec8d90d37bdb01620d8dc0d89ccbd457ac416d2d4125ba21d3ea3bb5d6fe311566cc488524a9700bfb1486bce737f9ebf5392dff199edd3f6efcc16d7609e879b1cd844c5c98603e8576060b50b82416f9ffd50755dbc8cb85812cbfd06d512c722be0f7a0ded0a23be1994c607bad55c0c7c63a5e53814cd9577b68927b076ee7d6bca6e761796fe831fe25115f7bf5f6991b1001d7998063f3676fabbd93678ad0c6bdf22477103f2899aaf96e7ec72d9852574a0e77d7fbc363e22be885b6d6688394d5cab5e5cd771ee749ba8233f75ed40e8e248f0c9f73eea3667bb5052f19a6252d5415944a29670964f6fbe0cff96cbf18a795f06f8aea91d28c4176448bcdcfd6b7429873f7a7fc041e40356fccc67e5f2ddc1be43ff2e08cc78c034c270a0021f959a915b56462bd54f71b09e0c62f181c027ab53d241380eea0ca287e8ab23ec1032cddf7616892f708258e6a9882144071750f7fb7c7e230bff40d2a1e05828285d6e3b2076bed705344436fab218ce4c68223f7db9a192e5e5e340eb1dcf1a9c5644f7367868097ece89f50508e9dddb91958d813f5d4916a40ff481484986deefdefd3a8f73586ceaa94f4169b75c7b801df0103509c4315e03fba06828c3415d3cb9f750ce9be88598a5ffde05655ec1abf62c212ae353ea3cb6915e5fa9152f4710f38940dca81d810142a966da879c82d9f213168c2940b7693bab860cc2f7b3fcf0d2c4c08a6f9a6966b41775b7259cb1b095f052d3e2d932d683d2603243c490a09a595c6ae536ef1e70e9dc8591f81b910548b97368f796996246e51ef81385d22c4e7942b04315c1349ed5202ea4a0c9a3eb62c4a27c752e9a7f382f951ab2c06b66d0ab4f0aa54941f58b88c91591864763d407ee4315aaba1cead5ed2a0f0d2572e1444cb7508a87f616e73d11a2dc375bc560975b78878802c9e4303854fde98849ff02c8276acbceb92a0f6a7b34fb06a7bb8c063684f4b01498dcd1164e2a2377a2d2d1481b13d2164e0493ad8ab708d5a05046eb4ea587b33a95d2b5e2bd2e3ef0695a96549c6a011822d0ad635b13b36453aacb0758b9ba8170f5324b62416fa4d9121d20cda4ee250652f4396e703d3cf595f9df09ec31c18aad0e4cfe5c3b7cc4ebd37d32a00a224752cad220430bffecb218096c34b3ba227139122cccbd522995c27b5a5abac26efef195f0e85abed816242d8bd09b017e898a58d033ec6fa6f42473205a64d4b0d799bfe33c5d4aff4a0de2fdcf64988a3fe4be07d569418149cccccf8f64bbb865f7031a2dc870822a068eec7b70d114fa3dfa292bfecb2c4cc4bc576c7d5918029a5b25fef0fb4d8191a9a63aeea50866f50045779b061c22f4204359c69b996de25096f4955d351aba15df68902307ce0a88677a091c0fabe9a73342d042a9e8d22936450caeb9d506f0dcc948382c3d9b3629fd72f1fba1cbd3f561978bbaeec9aba19c2afda971e2a18943c1a6ae7ca1ebc5cd5483ed381b3344894a4f689f3e0818bb3784d4449f33581246c2f24cd3efed58f5b897cf1a6c112637acd1cf26130a5d2cf868dbe3a5ab159eca2a860c64a16d63e597cff97cf918cfeaa8c77271092e02e614f8fc3100b8076128f60111bfba2d66312c445741cbb3d068ecf33d9fd7b456e4fa5c92224bf323b595307bb4f9d09718f95cd5974f3c96cd7699be9f4e50a2d48feb99f9c29663050251322781d88eaf59c9bcf47daff01b5ccf72198a91514d8bf61951278cd807b9103b04d761c391bd5406066e230514e0d09fd83ff2ecf3351a4d88f425efc1388d06551c72dc720d9c57e76a4602d095bb4a810ad906c62a7dec6820b2e3f84eaa19f04ecdd3f1c44908c7677ee91de9223238e5432ee9e4738ee6388506984024af4836497c5b41db260d6eadf185a919aead7ae2bd29acaa6fef90f17c27674bcc9c8cd07e55a7696499261c0881282850176ce0ab56819b27017415e50cabf66e6997fdbdc8a15c05465a9f7b98e1fae026412d430f4a87a59f150e2fd6fff0cb77dc75468efd1d0613e6f8ae3ede6682cd6b0acb25ab7bb848f7b0e4a6f51ed7d96da0a76a13ee4c167208cdae59ce1d491cf45e571d28c90b1dbf0c0d2604900226b9c8e64862e8330def8077cc9797a4ef203aa496bda6550ec5db072483992d19260ab878d88238df708df6851a6b0f613d8331a174e8c4b8faa4ceddd68233537fa7d7db9e70e69019dd21008a917cae59e48d44f61dbca1b918d309185ed1a43ab5b6e7465eb504f93fda679159e00f3fcbe87e7ac7488eae433b6bff84f811ad0484a22005b07f5f9862d7682814a3a1f6d1c07e1bf824f9645e8a8e40a51a0e7c227557b3cadc3ddaf1a3e2c7e52ae5ee07f7454e80bb93f707d150def3235b497d0f161220483c5c8697327a33a01c2b5c2ba947f0d54308d3216d0d59a83516bb3e62ef64c753d642971fe14a11d5cc9536975c74ea2f917c9ca529f170add6e014450c978e0e8dafb425293029eebf3bbe816c2461ad92b354e321bb06606a64c89a65139d92a48c49369c24fe5bab2bf643395d0949b139dd3a721988cbfbc9c41141fc6e7f627dbe88ae8ba33c09a01e2e10032e25a80002b8d9fdc92dd78b15c1148befae7166466584c98123a1a94e89ccad9c576da53dc1f05a64aed1e6886fe5dd7aaf3daccc503c7691fd4c818310bdaa50394047e358ab5fe51bb4477949ca6d021bc20bde4f400f02aab4bc1f933a22c823a19e0dab4477cea4b742adb6994cb9d584362217031f5018d3ff9789170c41af5fa07d3982c2c62737c482eeca9d1b8c7e7e565ea44c4c805dc8c5cc463263ef1c6873a175516275dc47bf37b656836cadf4341ba2a26cbadce7bb7687e335f93400984b0a7acc398665422fb549b445119cb2b5b8abfe2d0ee2f57a780eff88ed500884a09b4794c1ba141970b60847a550557d585d2a125d7e1f01004fd7dbcb0fd8980a526ad978b5e07378cf7bed348f44b54a0b80e440761dcdb096b753d30e83eaf3f056e6ddd1a7c3905b974a3ab50f1b6afaa5da0a4d4a39c20898e87c65440baa7afd13d5701abef4df2734d4b7387d244d167354d4ec883372963d0daaff19b21e1a735e057410a379ab07106a5bc0e39227e82e26dedcffc899c0bc4027e121b0d986d4f63f8688031700b2c07f381738f14f5947c90846a5620e658febed4116d32813adcb84fca057b7629e2f6c17775b1c8d95c6d96e31ca02404c22e7fba099afaca3e4675a8e2c400620ba467abd9199f2eef5bf08969e1465f83436c6c3729fa0d55873e49c25b134dc90db4d4bf87efebcae50053392a33c6d30449f5a96f43196b1096fb525ca22ddbd49a7341d52155fa7ab1c3670b1c4e81a5a5b73b02119566ecbde3bf4c4376c121df53a893a3068d5ea0fdc6c910c44c9819028417396ead9c4d16772633d4258b65f783c2acfcf3ebb9c1a1fcc3335a3476a7092c69ecd087f1871cd79a632370d5e4c77c15f10e87f4dcb13ba5a31adcd6cea6bcf6542e790e3459f34d7f549860e4513b42e078ac59be3cbc4d3600b0d68a82f332a2e229dcadff1ce6352459dfc4cb2c61da844ebf61f8bc1b32c43c28a1831f88a8d55313c340006b2ab58a43521701699a9f9d6ab5c7454007b9039c1879cb605a925f30a965c7b1721c26677fc53323e2bb9b23c71ba7e2bff93db9f60d8685c1ebb2bc703f0592c0de9fb38f0986f52fabc81c0291c6b49041c3c0be07391337b0b98f70b69a702550f83588fd5779a2e624020ffe4961fbaaa5bab84cb6d45eb14fb0e3acd4651d5dd543f550c5e0e788d93b68042451b3c32628d0868f9d56deb7086e16c12e7716ec72ce0f43a2a9c20968839f2f6c7c839215c99f3eda251f0fceea9588b73c9083deafde743746d5f4b45045a32c5cac1dc68f6a38b1dca38b5f572bde3186a30232e77b8ca8ca4d2f0396173d68be9d29a9a7ae78358e1d1de62c423d284b119a1909aa0bc79e27dc0810602f1d610ab813882f9a9c674d0e638a9dc2f1eedf4b36352892e5a8baf767850a8cc1375e77c14fb25cbe173906b2a884d1c812bc191219772f24617ac43e894b5fb234fa8b0e145ab952425da2163b27be019dcb73d563830eae874301df648284003da20ae806d3ae68bdd91e7dad7cea0f85550a9d5b9a1ff9c400ee7dfd2a521f8aee7bbbdda26df7a8fde78e166a3271225ad50ef03de704b81ed897170dbac5b9d1102a21ec4408c68be753ca91c0d1de7998798cc2ae42c5efb80f70b4eec9e0ea210f3f2425aa5519d6498cfda241511f103c81a14900420a84eba3236ae5ca7272dc0d0885d9a2819d83a6e3c51184f7365b5afa14abf58ea82a8ee6458e6a69faad529f55a14efcdf38b44c2fb3f2bd8a325b075a602479790360e51782a2719320e07be2f37de8acdc6007b7d89e2a7eadde36e06aac35a534b56c2b08801826708fddb885f0a150d270ddc40cd925ff5743f060ed1c07e2a0d8003d26e64c16a84a6a1f0fb82aa61228ae6971c80b4189fe37cf89c129b35a3260e648f340b33a55a076367361134bc2eee4dba521a458b61fba9b76fe070edbd823b1225d947a8f69a11109915864c443d16650d687cdcc450489b0529a121ff460e54f2891d39eb0b0db242bf2375252ccd3b3d2237784e10e3b229ce19bd4c51b5a4d5047c76d1374b0e95109daae22554b542a29d1cc82e100f19c0b696984d3983e1ff3a0da315bbe0383d25c27d00afbc48564ed9910ef204510a7a4fac9d3c86dc8e54ecd7bae24dab1cc5dcea110ed66cea1d06142292fdd223c5a4d9f89ddf1a1c4cc16b45bfea89e55acfa5f13274d1e61260435b253da8ab5e6e91310136b2a4bce93720d044725e1d4edd37300eb848176a3c6373d18a5161eb6a38c8e4e2475f4f0a7fd5a198327662e45157b623235db79d70e1380973e76e4363d7797afdb646999935f8cedad5598e12198d85bdc861a6fd2a393dfa3af7539d0bef3810c2c0741fa1455b3613be1426a9095e5fdfa042ca8762a02a7997b77b10f32b95743c15b9cecbb6a2a2800b4d5d510d4ab4b256060cf1291778e84b3be0161ec530b8aa607b3ddc13014ea7c3ac500004d36847289bd4510c6bef12a13a24b5d35b7269d2a6d826bcc71842330b00add60058f6da00d1bbbbf02cd5bf885b16becf9df1a851dbadb67ad44d82a0d011a8d9f112f9fab2eeee4408e3a9c076bdb10b12170149337acf1d6044f02ca96aa411099245f197b2b8c8a6a72201b8a205dbfe96d0b0553a09601e756f868be987eb49d15293dc9d2774102ca3340ec382ddd0f52e7218d35583b19582c170d649105fc512a24fee630716a9a34c9cbe1fe34645fa58db1cf2e6b012527b922dd445f1fd8d725f44fcf930543447267b288d48fad0fcba1fd7ef42c9630fcdceede4cf7764962b6fa91f3ddcca272b47b4e71275e7f4b6f22ba1a64e93acfe5c9b50a34b7848cdc173efc7a1ab3c8cd7204f601b6651bb7fc1ec51ba78a4ccf978e1e1ad5e4b184983b5c36f30b5912dc7b22180faa29d098c461b645dbbbe2a41bdced8037ed28f724b80628b6a01e9ab007bb7448cc88b10b91627cf8b3eb45d4398a6571375f2e61405aa6bc316871b14af2adf9befc4ab579c59e9732c30f435bde60fed7c277ad89ca382efa27e9e013419c9fc71792f94297542a90513b716bb523f7b4a3c3a052041012808d85662d7c718b6320072a8b21d63c6778877e217601c9c6215a0222c4cae49a80818cade96ccfb0cb1ca0bf587a4864ac134c796c3de574a5dc51f0c701cf59462c402e0ab83301626374866d13a7a0a69d57072e73abc5d60c0aaedf6c89c1912be1ed18f065e721eeefb3af9fcd5de458b1c0bb609cd82c74503d71d71e190cd999859b2d2ff4ba47ed650522b4869ab09eaaf62639d810fa3c943fbe95d3e0c9ed9b5289ad2b828ba8776981c8fc20f054954dd9513854fb4fa8f9997f9e6c4ead14ab623713ced20b05face97f6afa2cb8ac3f8d2b1e4740f83f145a37d1a4850cfd72dc1c20c8578b3cd32f3bbd029305ac7169632bd26ca08d79d5307f0d5c45c588cde8ae4fdc3f21a48a7d10854a4012e0b3b62fb2052b60708c3a6719cdab85a81df1673006b6dd6c59cdf67dd9c11ce8b95ad6e861864eaa8499abde4bc39d381b0a7caaea4a42c2e8a4acce1a51dbbe005ce79c0b12c5335e3eb9fee177c14539271bb1cef59f440ef7703943b3428f945ee06a761c5cb8b73df5938f38666ecebe8c5477f4272a74791f8a98586938921fc2ee274bed58f04227ca21ac5d72ad7d3789b5c11b5256ce9bd1ccc2a252360f9330cd721432f67ce7c6b8b988cb0dda64d3ff67b4d2a9414cbcd811058daa1ddc4374d0f383bc632a0f1f784f2aeb5279b267f7d79f9af4173ee9927b23f936d8a1ee2280cf45fb7c56ce78022489be5acb0eca812f6431012d82c2f49312264d53bd4b20a804864cd4a7346d82728288fd08bd01cfc08a910754cff12a91aada3c09c26f16064643dd3f5c1de905f988c1e7c8899bba3987da0305f5d76ac44254afef840869e7c4760e0b1b5b5c8d0fb83de8f6a67b5f5368bde5ac3a9901583536ea289fc2dbcf62bb98e02fb8367c763ec8dff5cf79f3ca3f385e55df947882cfbad33520a63068bd83c988915f22815b22aa42b2bd208c88fc11649fb39ba54e6d1cd5263acb6cb9605a3ae6aa329fb0b29585927e87e6025fdc692b04d9b54a432f229fde01f4bcd9f2a713473056229ea9efcb2abefd6040c4254db1932d2f49835ad2e75724378d96999b0ebb3d72c3407c1b76667d3be0770d46a20d94aa14144c50f18e5535aa8afe985fbcfd9c08e805f4c33e405ff8f115c9a992dbe8584ed6a4635660a507ae654ee740fb2a33adb744c9ac09924996a3a417a6f0460ffb87f232610fe3d169a47dd8bf35f437fc6bdf312eb59da96ebf21fd263ce5cac61a14f4429d6bc6ebf64b6103d9a739061a578c1e5fb91b1334c40c735cb6afa8779ed10665587354df033a9a4be8250f36152a044d66ca477fd066dc2428cc713587eea1279d877dcd9cb2473fcbd0fe6b9a06e98f23e860a35ad7e099f87d6e0eeb720ab0c9fbfd03c05271cb1fbd34263894663f60845f8f94d2c9f94a2e7404712fd1c1e7c9ed3f3ba93ed0df54c0ee0052eb422c5f7cea0f43fc631c7f8ec3390d364196909ac5a928e8795f70f4b3ab2a330fd2800f4e802310c92756e91209bf3ab27c12fae314304231c8833aa55300666239ef89db2bf085ab17f5303d529b50d15a4db6f6839e58a140c4fea6096fcfead18eb00e6c3f87c85e0862bb9e858fb98f7ad2e603e529c752b0abad61e9c1f525657e953eba80a85458c0730ed0ca7cc4d1555a10685aa82d08c32de21f45684f702c1f33097475de5f2aa6f69dd5531d77c91c53de91d7c750c70ab5b25a518c6e583178399688eb864badbb83c5da6b07ed3b2d25dfadf3ec2f53a86fa5853789adc5a5a2ff4378fdc2133669d29537511d3a622393da87db817fe5af2ad2ba5f7730a36d0a103da766b4b36a3a0aa480335d2cd2a433ff5edca46aa272cb76b9cc4f8af6897a51afacaf51f90cd12b0c689d9fd092a08589d1ef8cf202252ad5b46b3cf0987bca78aef9a24791cab64916cfd198334ca75e3fe89dd61d96cec77e63a1e7e1d327020b411f5048030ee0a8671560f28560a7816fa95e295722f03b0a9a32bb417e8f393c2c9928550731a25373aa4db6d6d78a4be286658ad600f6c188aa161f9ada3f2076d0fc11f91d25875b3cc9f7aad8a09007ad150ea865d7a7c4d954172bedcdb4c33cf2c4afe08b6813055b9a9aabedbdbd889df4edfee0ff3d5b077ce64f025f2002cd451001a4f9a4be098d6270b26dfedf8223356752c3b5ce7e96cb8a860c6441f86e81fb3e92cd59d9b973b39d0beb348f415179d6abce5a5f056a2e6f8477beb673f3506e999616b958ed38e74a600ef3982cb414262dd59d7c98189be6c91d73c4ce366f9ab01c1a184360b49d567916003c8ed20baf04d965ae6c216ac3d348230eb756a2a3b233802089470527bcfe1b12667d0a5932715a002345e292aaef5bdca41d1f3e5b8f5a41e7ed6245b4393f7b51d88806228e92634f738f28ed45e0aa831851649ba2d8dc428ffe489f96f0dd314a6f149477fa72493bc0c85435d6022acc9ce9b741c70b6d42762c591566146cb0965336c603f2cbed723cf8dc5112744fd8a8b2e81d0f478bcb7e09708083af7a5f7bc07a3d9d6b7175bda62bd60810573373902212751abf3cd18430c8991513c0db2c357ad86e40b25169c53f01226328ee31a1d36bb08d42b635789acf574083319474220c2deddffc3ad0a573b081efdaa9d36ed830ef0bdcf862ca4bbed1698d95fe3b1b5cea86f3c8f24103e156db54525a46e55bd3ee6ba32359935795c466d247b0a4fae6487ace49043e9e87a9a2dc23e53b73a03de607c51acd2e71f65a2a7472dc44da3716883d21af973133f0a05c061d2f52d3ec61d6253e717ab3a31a9b90e6b9a465260b970051f10ac9b93519ba065ea4bd7938caf9e1c2fda64dcf42f36359ab8dc0cdc786d14240b1c21a55000021d28df1ede215ac70120ffd08c6a2a07f860df47bf09931af9956d5a879b24846b20397351abe7e2a5d611e2b78e5f251574c4b6dded8317a7f6e60f0d9bd2bdb1737bc0b06995c2062b28bb62ff63e68068cc40c95da9b08ec3a93890dda4f0fb2597e71105b933684b2b12fc5f00badc281ed4045093b54d248d0b465239dc77888ff30ec4ebc4c3097e055de2c89282e5684cce71b4a033499d43ff60d334e5bed754b88c36f53253280abe3df19b4052c60119ba67612cc66b8897c79e3d0567fbf9368696c70bb2b1964eee60c2aa219888d03399df5cf19269a063534b503c739e78b0a9ff3d41144a8ac06f2bb26c34c2a4b64a1f3430e449bd6bbde468e9ffdd580efcccd613907e535097790fd4df7a79128700ae546613019b7692d0381556bc61fc088b9860c441f3ee84dc40c4cc753e4da783ad15a862ba862380785732d7ad6ea6a8ac1962cd529bca236a290cc18d71215db1ec49fb36239dbb131edd4a5890d909f8ff6bc9b98ad913a11dedc7eb67b80484f9b6fcebc004e190655596e5d95a8e475b4aa1f4c9a5fcad1bdfb961908348a2d0be496b90967f4c69e02c8aff9392973b7e7853c5230b2414995ceec45da4f9c108163b340cfbcd7809ee833b4650442d7fe25f00844856ed483c55b22d03d3db643ac96391d47d81e5e2d8e4bafb331da4a7624f30a8cf6eaba1155eddc35f61897fd9c90726a0196fbac9cfd4e9530110332164bf2381b7f88a211e5ea107b46edd1951dfea1af15dc7dad73381ab7b1e49d62d20528391d8d67077bc4ce2795df2eb2882b7b1c3bc4e9596dc842ffe834c49dd9d2e1843e8d0ba986906d7809c635ec59c6198789213bebf70a92a6c2b9f79d3a8509626003d7f74a9dea7fb2cb3b2a541956cdf0c29d106d75ac57c9834d33bf4bb84d11393f59a79ea05581fcc597d964262deb2367bfc7c800029c03f08bac45559ee75f5bc8eb3d70244d1b54bfc2038e8d72411aec7dbc93cfb4bc1daad8f92144bc61568168339392fa01756d1e3f09cf2234fd26311b2818c544c9fbd91a7a2ba7143cdcd9fec3f860797383a2daaf47e26993d5c97b5e164168f069390ab18f49f92497c9ce75694816f0f6055d22ce2e2d2959c45c58ed7d9868198e8a7531274e336b51bc7f4b3ca5e215289b75ee37b541efcb678277addb52e564c45f918b22bc161ac5e0c6855b50a618d27274378e108a1125e6e6a5d57e5213e0d6ce1dc3c5c9f81c20d4a4642ab24fd5cd0451ec49e4a4cea15628f0142a10df17de5f056cd21d6ec36c1567077d9814546aeac2a5dbeafbda9862515de7fd134fd60957e08ea895b7885a9b8126ae9d5c99b7f85a7812ca7b71e9a1a165e8c2fba6426c5d4edaceed0740df290cf31ae8f978e49af9f0da94646d2a66ae0a0f9dc5efffdb9201b27aed2231d52e23ef02056f175bae4e86e31f177a7e931123e80f48c3e3b2c011d9b7dc4c0fd094054e1de4b8371cfb251800d69ef8eb7cc0ae693575fbe761430a09ca952ef8f1d459dc36db7d4f21f6fdf3dc033d0a673c00a5f54879cc4c917a0ffec2918efd3f5d4880ac9dbc4ca4fbceef14600c7addf4baa1106eb7d8f0b0670c72d6dedd381e903cb1221675c7c86cf308f0ef6ece56a105b07f9d067503705dc0b74965c4b7745b6537336945601883a32d16483bb862c751a9ea16a9d2b6e48881395cc052ae9f10a28ac7b8119b8299dc47210581de43fb3897c0792bc610fcefa2be664277e4e0f72ace708ca4809f7d907dc98732bdee5b7aa4a8a2172d3f1b4df18b7274fa8a515b77f283ac2caec48a6ef06406b6fc34eb58592a57aa8e808b15c7761fbe217b8b3615170eb6c3bb7d1d62278d9860857c39e0b53cc0c2a774a18035ce7b02a169bb9fd11cbf01af77f53aeb552bb07049feb98b0589ab39402e81b81bdf7ff3ad3b9c7ee73958e58158b1eb625075868eef2d64fa12ddc2d6960a736db897100d999101f76fce5f90d8fd95dce0c2280228608a4388e9167455508b298cfd055b870a03e765a70bc8585929d4db971fbd56884390e55ed921ddd312456b1247c69b262dc7d63458db6e8af6c3d5eff70d38aa9b6be1697634aa8c38a691ad34ac2dd7a433c6874cfa87851a0ae7bb9c674703f5507bc22ae0d048bf2c3286fb3e6465b78433fdeb1be543895767d0e82c87fcadd19872d0201f58303bc261d55bdf6e63c66d4edeaf69933ca7957db2e5426ce247c22052d760ccaef12eb919fd53bff68ded6aab55c9870d2139790a6ab75bba4ffe62fd3c662b0b3f43aeb1c05bc579f3bff8d3540638ca96e82429aa931371ae1e0c54f229cbd9acaa114ce7709e0716fad5c8a823405659a797955382930644a30599d2ea0384a4227ab694cda49bf7f6402718e1077bf6c0edb255c8d13b7abcb4a8ef593a17617739703c86a1879c43b24353d42fe324e6170bba55ce3aba63af434743967a03d0533f65e3fc7f3ad12d9b387ff5f927f0b1479c244fbb5700f0d5f67415b11c6f6658cfe1c0d6c8a66d4eb4c5aae73cff75dedc0d7a93bfb0f7db21161b6e8039de6b8411e641859be10ab825998a5ef75664790963c44642c71db62cb5b4aacb376906851493e7f31a34e551a7d50566638809ab8b0cd538a28235930e84c8094434bf00c57d3a9ddf1dc22e4be7e7567fcd091276530646ec2e54d24f001e8cab4a3e9cc308babef433d8422e24186ca3eb607dac8cbdc9346946cc1076403036e3c41e13817cdcc07594ccf1f92dfae5ab89974be3254386a33ff0fe9471940e153b1f9d47ab79b8f939fc325f4f282976e1d1bd442338e407f3939c134a7bc100e88e7e82a764a494496a0c06fa96c14d6bc3037b961c8ae1f3a618d5cde30e2a82ff1a944555f0d3763424d06b05884571dedb65697793be002051664c01cb252b4b9c91ed46fcc341d25b22ddc1386f5a23153ee544dc444ae48966b55b64e86610a335315fbde962c5905194be2c102b990db3c494ac695fc79622d566c4d2048daeebf43a67f949dc9b2fec96e33667e3febdccc2e948a063e3603c41afb00b57ee40ca07774d7241f22dad267fe74069957bac721ff6fe412bf1738bbd0379745d4ada69c01883d372bfce101826f24914d66684455fefead3c8c9aba27449909d3ff56ea7f59517898142c541068decaf2295c1146e2e7e7696bd9ad5a49a73bd2717a45bbfc82074138470ea2201cd9b1f5e7f1b15885d0c2a78329aaf74248f7c79a5c67f3b3058c886622ee88710226790b3e6020b8b639e51ac3cc504f4e72792cbc3bc622b0f63dd70222af7eafd6a9fbbcabb3fbfd8ddb0b05eea8d08fb1c7b75056e7dcd522dc72e153f26721729e9f430cacd3d6d209ae0b908ddac7029fd0050ebedd860a91a37538f3ef157d96013a6b8bf97f307c6194f0f21f39d8d7b6083ea052eefa90137ebea2abd33cc4f0e3e6283f33830b0afb282d4276a01889b488df6f495747dca4597fa0f68c98390d2a3c0ab46ca32289111656d25406e120ac6e6abd897fcb286bc248ba1b24b280ab5610083f8cb25153aaa6e52e896ef13a290e23284b1ae5138cdb0af48e5a70452d76960796817e4a2520f1b1635a2e3acdcbab95d1c50519261849bc29d5bcbb07c0a16df4b36d37e02189aa0c50017af2e3eec1d73ab70e55ca7e631a5a4f3ccb3301ad89306cb66b0b336c4415042f81c0c9e4b43a74503ecf2fdee8b5e41ff14c63dbd46da7ba92286ce313695f5b1b826e1479a9c11f0663d98afa0249c78a03e07d836748c3350701b08b55e03cf181183037877c2e3566ed8c2c60f5275c039ce4724504c11dd6cce84d0c4777fbadbc39c6482f2852e4fea6e1ee8ee9b18936fa870f93d3f31bb4b96936d96299c2d7f5d012bd75075f5c15d4f8f34bb562991b767a758a13c9d8b80f230acf49b52553237bbaf2ff49327492a8fc34a1994d0f2fdc0e65dd1c498556a1b6afe177367090196092097eb22b36bac4376463fbf6371aadaae3cdd3a572f884cb86c0855a1eae5442223bd608f8e6f03c8d06e9bc25ae9c0d43c47195f1a6d7a002ad32c6979737924119e765461500b2dae15e88435e290cf4da2e09f8b0f08491f701e08e9541efdf58b982c84e2a551b8ca427ef6adc6365fbe22b7ecaa0a969b4522fb6114fcb8e9d3cfc35eb86d918ddf2d9c6026f597297733be5facaf663083fdac68639ab9c1eb28e0b2928e1592e56e0f70b9d43e3fa096e72a495fd3d560d6fe2313fa7caa337e95a5fed3903ad6ae8f298730131f876039c1fc1e2e65f3102cccc66c942f6c862518194da231d097635e2dc5e0acad7572854816cf15b5a71ce60ce7451dace8992accd17a9da084164ed0bea91c8b0bf6a289198e822cf6a2f980a12530e4ad45b61e858277f216267d00a8bccc2dadf0ba1bc9bfbc11fd387b4d12349f28c445f84c6a7f6a730062ec34a672db0b5c63ba1af4e0a49f93496f26edaa31d88aefa6908f0fac5bb23cb3564ff2c236ce85d53b9743ffbd84901cd5ef7babacf51b4146dda31e9a0bcd4db4a3c7d6781b9b5d9776a765c107fe9a28c12140794da98f30cfa2c80c4caaecc301a8395bba203c37121a26824e459fee6a6e785fd28d43b04e22b2b38e0ba000dc3d69df469527852de6c88a53362dc3145c521d4418fc590da061fc0ebcc0b449524134fa151502da4db96f441da9349ba31771f58c457edcf80f6c3d2ed01e85d023c466698541ee63984e48136c79a59ebd3f797d13c5e3cbd342176589e33b171a94b408585f9faa4bca87d1971b1a5c91757255af08f752a576a0c549ccea402d2f3ff4a25bf77d12c415bf0b7919d5d52f47e52dde22a10d5b7f29d6f4c07ce39fda21b635d07deba6d814c96de243cdcbd21d8fb40274cc340a50c917ef4ef0979705cb991569ccd197c3d4b5cb418a518082096987fb8b533f0181312e5f7cad0fc5e639ee815368686074d7c649e9496607671367ef0eff73f64ff7d742a21f4d950a4aadbb6325911b98854e380ff05ae5e684c5931195afef42dd41ade6110added9032ddfcb0bd33a09e58d215743cf784e9112d0bf74f043577500264fc84e83ace72e4a0ced5f76ba09963b384fe00ce15be14b24841066d3c3babe7f7d9fb7090cfc3c0a5f0a26768eeca01ae1fa1b3185be166812f2b44369a350439beebf1a29647813c0e23064bb14a07c8011daacc716283e240f0b2c1c2859b149385a5b880b76cdcca40b8d1a327054be5e64b4a5d55600410f24b9f0b16c1b0de8fdef647ecefac985dd596e6a3fb006ad4b02386e473be1498ec357cc972f841d805e1675f4eb2b16e76c086e8e0261d323d713433893938dbca67e46f7ed24a925711f03677440bba4e1420c834d865160d3d03667892061a7ac4dddd1f8ba92a2877459e291e71c9b16f6575e8d1d69f8e6d3b47e14c40ca1f562856d3e2722f3c25067f27615b6a4757865bccfbef799576f42ebafde5c98186eabcac82bfcafe61e8cdc23d578d86a62ce706d4118ea0cfb05dfe6810c63ab08fac982e320950e53e6f476033e6121a02a650908ec1ff1acb42517274ea218fdbc87a93d9d10e6062776db5ead06dffdb5218de6af0786090846ba6782784ead29c9280645a94b6e6c0e34ae2e2459c0cbbd4a7102a81989fcb1340b80e3c299525cede79d322418f2e88cfa4ca2a81d85e0c33789a223a3cfe83f839c665d75619992fe7c4a7278413a9839fcf28c47df457a5effd4a9e49a27c6d110e8a31cd83cf0ca1f1e0010c90c197d3bd39613d410d037f0215f75ab8fbcb7bace6df2a42420169d8c63824f90ec4c36cfd43e0370dd1dfa7bab6a625a290be4e9bd58fdc263a1ff83f23c10a8c653f21a68eb7865ecc17a3ba2c5328b47c41740dc5f6494eb8d21fe8609a9cbca0fd475b5fbc822e3a357717561260018f50ba9e4c82a25e16c8d4246ac4fab05c7383f13ebcd30b628d8a846f4fa3bfda9c533b69df05cc0de95cb6fae2025c78cecca1e26d56829eb465cd15b57d6e0a376ea81234ba835bf390884a13cc70b2fa6a36107d1a200359fc60687c7ba04ac6e56ca9d325a4b26c19828e941c0187c04aa53af3eac480e6a9f946763c71523b010f86babc6c5d9653b7eaab1b3a9e8b32ec240e2b69d9d2fc148764cd76f5ac0c77af5c17ab19507ff996f20f11c29740f71e36378c988783c3331311e8115bcb75ec198d011084cc4553bf3f9d39bf3b7d4f97c18a5dbb53bf69cc43acde6defb2220721a3ea51ef1e19f840a7a6b2da269e368546db64eff89874be2ed04d93cbddf507b3634c98e46a13f6a8d99003d2f3d3a4e8aca46edddf6d1ab657dc663c59da4f6b206ae9c9a361e3f62e31c4ab1515bc22c89660ee867874aca58e5f7dae1a5d28f3959475c9bd8f2f84c7b6c8bcf69330d18c31579102f726e5b344f4f312d52cd6522c4d679f464236160e4fe07d95e6a285b07676390393e631a91f10f91f27f3a50f5ae21f8a990f1492418f07459e56837146381cd3b83547fd4ffa9143fb49d730c77ef1e1df5debcc294f35a2ca860b48ab49305d874d1352a58594e1143eb797c8f6183e7c2075ab508e8b2835826515263c6f12b3385808304a850d34866107199dc08398a1845f3467b69e0c9a6988728ca6df9faae55b263b3d9dc69b7b74c3484a5cc9d7ec78041d0c068f531d8bf81efaf7baf7dce952e95d17f66464cfce8436660e9a89745166125604022b042b9f0e795f93042cc27a5ba395493acd30aa592333815843c435087826d83052feea8704e86badba09f5897d50f43be6696337dded40890f61d29c29ecea8a8ca5c2612f8e50690eb72345485421c43d45ba6abfb952d77ae0d6ad55c0128ad1ccff3e79b42e4775961f2ca63b43bbc4706b96f224f2f477d13a09cb5d9c87704866b1700fd3910aa36cd287ea6bf73cd834f64baef901402a7e363430dca0c281fac545fb42b17afa29fad7ebdb674529a55eb4b89f7d1eaac3946ec1c6751fb7a50993a35c19de50bf4daad114dca69fe96480213c94d45ab31632389bb88b2942393b7561abf2de93a94d97b3038b9b46cec41a531d6b8e5d6a317969a51d30ed7f583f1b7252bdd44082ab037f94bc8d75818c981242889b6b3175b1aff2a085628116c190b561a24c6a923839e1ba6dc9c57e23e6395b301f3059b79f695e14b4673a5c503ad3e8f8e157cc87f0a1137063ed469a306775f9a8856a7ca863fa57c17c3351a6e016a2ce83dee61f315534c36b82139d2455c67bbf657bccac9fe506a5dba4ffb99937757a9d3d3330f7764f5c8fdafc831da40523b411d3b4743b823e1486a39ca6c5738d512c557b2239d05e6e2cc853b4cfd6b001aec9eae10f1aa3fd832027e3a53ccf84cbb0d3a8962899f98a7020348c834d83049d7f74db9988aaa92c1cc7bf198eee467f777bb9337a7b6d861317ef8a0eac03d456978022da425ba06613b70e40d72229673a304aaf4f058e364f301d4174b0e3a9fed693efd06c608ff46abf6eb85419d8ac22cad259614c4c34be31f340014098317983a09c54a2da3aea50f7f029d69fe020b57e0fda829506d596136e18a45d616e46d8aaaa81f7ddcd86e395caba4e95e232a07ceb6d7744d6147b278901253a46232174f0abc10e0b20a462b36b8ba7d12b3a30cad368ed293c47bc530a9092511db45ff841c15e98889c9312b145c5a5d4a1c6bf9b756f3eee18aa708ab451d76b91083ca637af72a074728cda2ad97b5b7b757c0265f41f7692c0ff5eba9188e1d16aa7a99786d6ef46035c5cb827e503b21d895ca88a2f378b1daa489e63d4380597dfdbf4d7524186e5286dd2dd7be16f3af4d0369309ce1d58b8477cc1167f755639859ce715bc5724209a309b0c80b575f4d7bf87e8b2626ca9b77d85e55adb75650d857826b2ed598b42cc8626d7c38c347f295c40c899fe9bdd7cf425ce91243832933251706d3368749b16e20b207d8c0d04a2deab1a7a304add1bb72c87f62dc99bccf667a3bf8d36128cf0993c2e36e70218fff71a2653307d62b4fdc1863ff6c070ba4380a8356c7786648380ebac29d1c084f653fff8dbd5508ae9e8f5fb9b0fbcdf427552286295c1a5a50a252e739d6f2307c692dc24a72a402eb99d9b77b362a167ce5b5f64b14a37239e55a4d34a74b375a3460c1ed90e5c87351896f1927b8b3cc8e800ba2f47c4054a2d4ecfa230001e038d3d5b0803227abbd192bfbd4d9ad93ca199f37f30ed839ffee36edadacaf4772f23c08c174f221255c3420a91174044eb5fdf0b5d246e5c99a5681d4f7cc742d93f541fb1011d5c3f8145387fd2cb784b0032f90cfe1a5fcc226d7db5c30c89966cb910c4f91880dafa959fa98497b6434d307176f1f7d87380f01225e2a13e6cb3bf13ee6db4a8656b146b2676e32c3b1008b4daf069c91b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
