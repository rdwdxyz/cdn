<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0faf90cf8d5bedaea756bfe495768ed0241a13f092206dee29968a426a7a496f471450bf458109cd5c185825dd3a6cc580d041a31697945d85049e46eea7f10c92672eb7c75d9f9cdb665fe4a1dff80357dd1d3dfed4a19e6c80a2b81fa6ebdf202a3b49125c707ac840083cb9d7caa210efa67651580cc4f9d33b576b21aa6cc0474c2a8a6d9a04e69b047d8c05729a04b713b3b9fbebc6ac1703e62131f0a427214129f5f05b02690a1addb25fbe4171799455ba40ed9179b0c219d54a1d7bb2004ab3992a85caac774af35c7d0976f57d5b48a8c2ecba4d0b8f98f42889226a0f4304d34f1f98d693a347e2f9e752e11ad3aafdfca9a25f38674020faa2b9f5a10ffff6ca2d0a19b7fff5c079ce3bedaa3a12a0b95dfb0b820ed8ecc7a2b985833bd77784979153b3b4822bcbfaf0edc6a90307628e09d6f0e88d58ff1092d3a7fbe6e60d6a65ff8d542425e427ad5476cb95123e03d92c983a5f89ed977a77c3d70dcb2ede97696664b17936729e7a6790fe53869857fc648aad7c6cb70c7d0f966589e7af881cadd39af44e32d08097802c47c5c68206fc986ed784581eb051df9e1eca4d9eade4bcde420df97bd681edfa0bdf156265b60e09c240f5c06504b69eda02db387831f5b2f34a01d6b2816e1a7054971c925699115a2d6fb8c8eb1615739bb3a6687cc5ffe02bee2435eb3ec1ec801532c8c8d214d4669152c15539fd9c4cb0e665fdeeb2f2ccface6b63fd0e36e86e1a49d3ed9324a1e85db15881f8f5c965ca41f27985a2beb33dd486560a8936f9d7831338767460ad7c1a77a55f7dbcb8bb76ee3ecb63f9772a645f9f3afa010764a76a4e7304bdab55b9e6969dd35d0ba28791ae95eea7cd64ded6a42628e7c1f1a0e35297481b8456312e3a04ce69acfe94a50da1daefd005796302114068c5520a7788370bf5b01501cb9da4cb39ab94c5c8db859eb8cfeedd8a87d56840487d9989e196ff415eb041680f6b0f2b3b6c321f6afa859873ea9afc5e686a79d9d0a5a212748a5320dd74b118ffef8e277e01ca218d49219899453fe2e294f739ef298426f02ba70021388aafa3911f68fb325b580fc13ecbbd609f6ed5000c82c0054be48b6e1653ee268e84e317989b8aebc4a8f49933f61921699a5fc7ffffb6756d95c079be97e90ca680d0cdcb7e9102555e6e8f55ffdc3916b7cfe2406991f17c6886da580f5136ca232d3dcbe68da7ee69fb6aa23abb550b5721d12ede441c511d4de162883a8d800c6a00858044af197a0760c53342411fea2bb6ef6066d28fe0bff780d09bf702a29ed49a5b24974d84c8fd525a0a96cbe018eab68fc6696fa8370b9fd84b4f7cb199f0bd4fa136cc43d7a32637b449a313cacc7b2e9fcb88a31e93680b1de6068648a674a8f42cc9a33972787a0c016bee7e6213f3ab53b83fe0998142fc5a602738c084e96e8e29b1c121fae404961c152ce2a130776fc08833dcc660d1cdca5f914c911505b033d9b8cc543bfec7241aca35a8e82a4adc6bfbb07d9972aa4bb4be480391a890fc398cbf066c6cf1181a3a10a9939140bf7c5148effc07119db908fe2a6af601bd008675052b686c94bfae2d24a07ed1e40d3e3f7f93f7a5dd0fc057ec43a1b2732090cfb542d723cc1aac57d4c2bfe09f0005d82268f236736fe22b3fedcf9394406c0ba9f816028033a29bc8bdf12628dff5881671889ec50de6e195848d5d817f79b2f6210d63dac056da026c998a4c7e3ccd3472d880eb350a3e52a4c15e9b69f009487a292ebaf0c66dfe3d0feed790404ceace363fe7e8d263e39204c38e7470e6d1ed35cf85174cb8965bcabb6b24aafa96e188a026e08c85e55bd00cc73c1804fc6b8ce7f10c07e5185781e6ca407ba3772213be8303f7e9b4e6f847b6df8566d2fb29b88e878151628b60251fce4249330d83e771749150418a392f7df2467fc9148d8875f04f8932affc7626bfbd4d80bc24058ea892e7bbaa02f159a908b873cd321b80c70808e303c3f4dbb7e5422fb1b1e717de937835a230a3774dd849861c05253a2d3a9e7fe96ac040589f2e5c5cdca639f04b3412962dcf3f4545322c1e31e6f559188556a7ec31aaeeb6b6ce658a4a52206ffb57b9018b8049f1057e24da066b2b7c57d42a58892b9c3f7a6a0c066eb33cde94b10842fa7a596f2e6f40abacad4a0a97152500c99f2f7e30e5d41a3185957f54b788f0af66ed9c92b60c9e96f62e8ca4b5cfc1fbbd5236bd76f2cbd3a148ec2c7aeb68acf228dbab7b1c0aeda230f624493172c53cd84bc47b379eb868a6522b50779df816ec0860a639c3622a401e21958f597d0eaddd3629cf5986a7436ea437e23a85cdd90b4fe9b5c380f9f82416bd64541a33936d5308d5b803e1681cd9ef4f0d0745e5e1e2b214dbb3d76e3de584aea523e1639e563c1574684533f667f705bbeb2eea0bc4a7e8e64001d3a9bb3e903337ef8773befa07a7809ae1ebef2e6fcdabf6e17054954a45002baec842c1595414a93e12c7ae19481fa747386dc4c3458c4c9776e07abb0e13b13557eaeb91cfab4dfd7462ad3ec31e6dad0eb4c5ce1c4ae1a1a45f753a797c6f61f88e389badf67c39d19383bb24eb21ed22dca8ef5c0f61fbcd78b959a628cb48a7c53e1611847280071918669c99c9c2be47f4d01b2bfe15d9a51d8727f92899843e554c88960023f5d3effdbddccb2f1d385416147642ea2c3c247c94774e7f0cd492cdc80c096014107402c9918c2411cd45a93505c00112285436c7eacf00225e88779960b4ad8142deb5a80c0c6c5a580f9fbdaf5e3da611427f93aeafb1198a482b8e180edcac56645a0f229b51b30dddd142f56faae359aed8206d982d518777a4a13728ee796cc43327e4d78713e31a1abd06a15d2646ef0c69ef16b3acfa81dc58af500a6dff7b921053f4ffb209ce58241a22283d67484c10c52f6c05604eda69f0a0e1454ab2c669df872a898ea805ee09dc45d42b59e19acb755a0689b193035b9093033480a5665c52301094ca54dde85194cfb47d480944b28ac0e6a7850bdf8106a256d0add4ac4b39c25bbb77c5d0cad5c944e2721e0017c9fb4d591c3c6c113bb774ec55c06ee98168327b289bb5bf2c088b6cd4673013128919d90ae8a1b1c4de40da1718347c1d8b0f9555b9f2cd86eb0c3ed756a5284970dcd5cbe9d168ffa2f0bf38805b9edfcab62e4769723903fc926a5958f549273813d8a57eda14cb5cc13165013bae113aa7a6ae1148312218b6653abcc3278d95d92df3341f4adee35a73239bfe0d40bf4dc9072c7a2aa321fc701cb6bd4e610934ca36bbe296d5087dbc4168621e221f72bf7c16675f68b396990e1156630ccba5dd620ebc16bf5ed151ce3b7ee09f7d01a730b31452880be71c6a91504bf09685c3839842e8fbdd913a5ffa0d57a01b4487afcb3788ff65adea6fc1589b018c1c700609b21a0016d03f48834e61c2d5309b53139119fe6b73bf4193083241da69f74a81ca046f1fc389edeb5b38b1cca58f19e4b7ba7c0d1ffdbc1a3a62c636652e179da0e80fa741342d0000278b5e9e08bad337b073ab78ecb56783b9f854fb3116513f40302bf889263d4be7c7caec4cae4b5e079832563c6dab5a0ee79b4463332326c883f1f3403edb6f3749a334d43eee5e44f6d48285c7b9eee9f39c0723ef7009a28b159bbb00a101e18b80e10a80db091df8bfee72529538c666f69cf19d646ccc8ef437c6c39830bc563ebc313d1bbac878be8bb1d25cf77fb4d8b482d9c99b601374b450a22f83846e70b6fc677acbeae1eb50aeb53ebfe41a0b9d25a49e9dcdee61b25e3c9946c982a2efddb90ac84a6f40ac883c10299173439850e49ba24fefbc66cb2da1b727922202bee28b4f5b12f51f99b3a08465d622eef602bcc0935ac70be6a5d51053cc606b01f753610cfb63edad6ba4edb6abf87dc45f91e1f4ed0944f22525704bf59b72ec9b56d74ce4e88ace85f56a6f817f6bfe656cba221d10c5b3f06cf6b05a67a50e8470abf6325b6fe7784a7219d7b1a4f779e3b5190d97135690eaafab2721f63b028e84a695e7306e978980c57e979e2e10c49734d1b9b11e5dabab75f606131c8a5cc5bbaefcf01ea4c3875f5f1b89e1459b06c251a2bd022459f2730b5fc787bced168b3435e755159d871751539ada10efe2439a0a93d1d8374a9a952422da9e4c5744d6baff67efdca8f93b17ccc0e2b40ff01ca86ab81f07369b485493389480bb6e150f782a59c62d7951644ab0f2c92eacbc1243d5f17ac8f7a51672655d5521ffb9463f9e62c10f45e0db09a6503d489d478373c3116a89410f514802624fe682566726fd943f29609a05b64a31f07651a546203bda4067ff6a0c218edd06a725a41f32b2008dd01067e35028c77522677e824f4aa2b2f56ac8501aa2dda561d22cffedb9a73d4faaeea31f899dbac7cdb8233e4b0c98b5b30ae56f76c486ad0889df90f47f05f11bbef64982ddd7e942bb18d52fd45b1d0557c2d0686b7f38ad9e9ebde39c62218cdea74cc653c22f15816f2ab2c75c6345ea90502613264d8ff6fa66dbacb2582f85b41af86903b45f1fe918686266f55c810657b68a02806627fdf231a21c3b05ddaafa57e6e2db01d26f8641023d2b2ca7874657f6ee03a9f80b63e8010ffcd7e652782a553280b4e78d495c84e253ddff3c767aeca6d9ad293e2270d2108ea93c1c028cc8535d578e0d3bed7b98ae75d6efa1a5f2aa15ed02f20275d0737dd15978acf956bf2cb69f154446c14ca08fbb9cedd4965e77d5838286d20a7939c11644a8fb31832bf126fd46157ed9eede7fe53e956b7c5685a70c358806430cce06f0d46238fb663c58eed20fa138f19d8ad23e59e702b18e06b27e717ffd607781ffc993ebb0e4285b36041c256d99d7663f6fe151b586b5753dc8e10d592ffbedbc2a4d1b3bbebe983231288694c7f3fcdb36696ac8da5426bb050e00226f812defbdb75609a1713d8726fbfd2be61204c6d071bf537ee238f9c7c67b0da794747b69f1a5d3deec8dbf56b029cfe75ed1999e3b6610eab4c50d7f50fc260b1be09818692b6f886cff14d0d378064736cdfad77c784e8f6d84bd4c449dcb305c3bc0e719503f4ff14f7fd1d19c0a165bac681df5d35cf2f88770bc6ad1a6ef5d605cf5712c62bd7c8bf095fbf3c858d435ed84e29847571729ddf51d2a217f90445c7a41d39d74af1c69e52832e2155f97be963c665b076eb5fd8972f89067a7a8b322c3d9505b48f68283d8e754e0942dc40f3face0b5919ccaff6bf88d1e05a80a5aff6b30f8c8fadaa6a5c229ac21513da0e6d8045176b51c2dfdfa7de763cda4b362fbffab4520122205975d5f25e1cf038402aed1a68ba729728f69b51651bb2660f18802d39be5a02b4ffc4849f030b1fe6150423b6dea2e2a5fd3a65a26bc309018b65758a4240191e011b3e0f5d9da0f3423951f12ff9eb8c32ed7e429781529cd50e44cbeeaae450ccfcac0cc4a37dfb5452a3e01ac171b5006ac5f5bb68b9d330bbcb5bc4799c446e975269df25ac6ef20194ed7a9a4204a29e9d95ea9ff1a6bd75fdc7e9502d82eb137aaeefbac6a0b51502ffdc8dbf0bccf4135096101663c1a63c7b3f5be2b17b2ac0c5db32ddf7ce5508772a22132414351c5c5af9dce673b90f7cb3543812dc3b728fcaf0eb18f85eb73988ecb24ef1cc8cc50d2db7037765f88222f19b3fb61ede572353fadada821a8cf264c46940727448db3be70c5baf3098d5a11f93cc714cdb04fc53fb83af0a865fad4ffcdda4315efc885378e7b1b10044fa49ac5a33630ce806468f7aae6d14d69a819bb3d4c15b0116fb5f4f26acd70d7224c8f74519fbf8c11d7664b6d6aa6ccae6d3343d35ab11b84e2ad13a02cd69987bcdaaf2c55b4d103251b2312f699cf82c85317fc4d7f571aa0b582e4167e1555613f14abc58c0b40d4cae57302bca75f5514e4ebc18b92edca8922864975440f02f6b389145760898bf4bc55689c5c0d7d98a1d28e3699d43ef3c7e09791c706e59aedf8b6b1e32a1f7ecbd5033cc0aa45c14630e7d720cbcbed6b61ec7a6ddb1121cccab125747fa3511be68114acd4228bb612971be7750463111ace3ea248979e1819003cbea72a1784af6dbe83d6acf5954201044ec01a8cdbf196d3dad53be029cae59de4b7fdf9e10d2775527bb3f7ad872ffef761915cd79766255ddd873ec969bb1c8f0e05e6e04c750e8f55e6eec9acea43911d12eb7d7d5b6811daa17607f1026535f3e9bdf41dfe72c248891c0e8c16d0576e04f696609681b62b8309c1f4b05ae908de38525c627826d7433d72f9d58e7d4eac81641b7f0a37462bc45c2f3ac2f32cdfbb925ad5a7bbf93078717ad904b9a2b4c303884f68d8948a476d4c6bf6c12909f3968cf4fd96d6a576a52e7f2577193a19eec33cc414f23e755514f3bb522d428785b4d72874deec993591de722d652246ff3d36ae3f5630342c15e337363e62c03f7b6cb47e370a6a99bd05edc0a51bf182004817de018e9160b63749867d6159e87a5291922ef71b649e4f38f2b2122e95302515b0feb7e890ac5b62d8e9a95442c407ffed92af223234de2adbfe16df6882817831fc1c5af81f7bf26d969b7d8b3b1f00258baf453ead28d4bacd528308c861cea383e210b172ac5c88808559eece12ccf29ab1acdbb03b593cd2c6488d1db2b7913ca354b00993a06229c6ba124e5b24bc444c10083f1b82633bafc4d4f5abdb6fad5fa968c6d04ed4295c2a7d263d08fd367f0a9ec35f94fdf6121a35c1767fdd1bd0de75e708018bb995ae77c78fef5a2aef61eaca03980cb6c0f0cafdb689aed65145311a2cbb5fc94ea65aebb7cb2900caa70e7d66937404e6ce0efa5047138b34765fdb2d1b2e5186cf18ec1660ac647cd458eb143a31f86d8faaa0ff0a9ab54d9237bb16383fc3f13e28bf65701942e849fc101fa1a47a8c7c44dd7c55a21e4d5cdb408ff0893643c74d5cbce6188d5483feb04bda90663dce38a56a814025f02ba66ec1ef05d17e6ab2418047e954f24c971616dccb7b17ec0fc8d89ee5960ae107494f314dd4fa4fe746b6ff2d456508d20de8b962351dfc454834c511251785732a809f5d4bbd05c6ee2f2e69aaf60a4acc67cf326ecc2dcb3034b66ace46597ed57a1728e4525d3b4387306480c101c46a31e6f142cf96d43b157ba404d493efc3706df16f16f584eb360cb11650bab9af56accf5fefb428a712f391a1de343b646ce52364f4191a89a76d695b64c873af3a587acafc8363275c4e701d7fef372c94a8ff2292bffa0af0fb4412219ac0d7fddb4f229dfc59a2359e66b1bfba9c6cdbcecf6de8f5875b35a052670620dab7a903de5d5a41f52454bdbad0431509f55b6dbff5736c7fedb370f198bd804e55949e2363690442d8cf4889ce36bf240b565dd6ed5a28fef667c3719bfcb30701d4bede11b72cdff58ed51c8e67a1087914a3ff44a28146b4212253dd6b0c7ee0abd512a50b2f504c3518fda05f0667c37bac806af12a71a5fbf26781cae395832e1495bfdb0e5882fdc364ab8d67a792fb7ddcd6f3a13cc72021acf37170f14247cacac1d76577de5f16db573b847040590c894986c81055f61a4c0cb0ab84239f5d2c9ad6cdbf556f922e0378b2032c424b2cffeb245e5b32aaf52016fc9951ae0f989d66aef5f1b7a2137de61e0d60165b1341a8cca1d8a38593209e066804fe33ca6df026d15391c360bf798551d5a2694fcbc69f303c85de006168c940a8e045faa9722709176df524168ccdb88827a235109e07d3594389febaf31dc5345148a232fdbca8d10438844801909d8e825f05292fd188ecfba1abf0f471fd2a3f1904d8bf1b657be4c764b077c47f34fab0fbb36b72b4ef6ddf239a802814000e064f6fec9378f9922529f8be0d9dcbfcb2b9981bb3cf12329cb2fa22368e90f47ac90ee99e412b7fdd8daa8decbb046764a3955bdcbefdef2878b0498e121952e726dc8e9f2cd265e1f523503f0a521d8d87d3b795ed7c884bb18e21e187942a90128e54df0e6cff00519b7e1d19516b77b7e58ef9a7c9604b1be5c5d5b69220a71a637087c6ee25d31f6d6e33e2b23e7d56ed79072c60a0bbbc2a850ae062fea5836fba5f0d7e34d6d97903f6ec6ee8d5363663ae7ceeb25d29d4e33f648869ef43c0e66c6d2b4fdf323f186239aa72bf57664e3b219275059887aa6fc8d98c59c25b32f2eb8fd16a08e69992db70b1e1b59542130320691a9896f2ed8e2832408ae1ef67bd82e949b05b4992d5ff040309a156cb187da1a97a6ccfb13b81f487756de06c6fb4bb3eb7ff83697f5ff609bb3358eba97125860cbd105c345049b82802815f849747c14ccb2944377803701640fceeb5880df59a31ed9943fb2fb8083baf64f09460bfe10cd372b43957743870e277184330ffed46435edc76433ff73dcf7771d493896777d42b9fa895de2feb02fcd2e9e07c4924c13cb79a1f9f6a59ae118dbf389f02ce2a76d7d142091bb1db4064ef80113d08f119da943035517f71e8191c1bb6c1e6a8e308e2d0ea50359228de65cd33d7e28286e10c4ddba7feb4b62e4f8a1b35c447893137db3e921937042387bebef3099a8e3d4ae31ef2d0b3633fd2d107faa1d0788dceb15c34e9e183aad31f967bea082affcb166abb496cf53da7080b5d929d5a7c179db2bbe656dbdcbab31c354c0f41a2d7a09220170b2a0fcb23c136f84162484ffe2bab535bb805c97b16a6db80841d83f0de04b3a06391bf9fa71ca8818c1f846a6cde4de7c700f8c051714b7c22e4e0744bca72bce31cbc6f3736bc794c9e4ef3f0fa598157e70bd188f67566b6123c9f5069511c100fb5f2d6c0082b3c7102ca16a5c0fea639e27104d70681e106281b1ccc419bd6f2d751682c15c29f1f63960bf4dc7fc841c2629657d56402cc3c0bbc6fef9a70e8375487ee01fb898e8546d62e1d4f6b0dfefdb16712e8f4bac6373e3ba81b843f8ae86dcf83c11aff3a8ff87306c4b2beed362b7380bd87217fd86401ef67a35c8826e4413613051cff074b7ac18f520d2b2534ff33d7f15399afabcf0a4c22c066a2e0e683933c687ed7e8d7442ecd5e9d783181f9557177e4e97a6adefbc756103c58b63b292c6a82268f7231cf2150de3d1c6a6aa225e0084d0294e33cea74fba39f174155837181bb165e3bf97998d402ce8216f9b2d98f211d20333935bbb62358d8fc4bb561e3a07971d98a544045885e98ca106be8b994f7f86933095b760fe23faddca1324bb256ae1eb99efd396330b15253ee8589ba129af1000359f10fc647a2e5d99f9d1ab9b40829a60f38f8a9bc1d85b44f623d14478baef1f09f85c31378739315ea5523c6cd9e43c2015665ada18ab6f3b78fd6d845adf87fe18a944a5f7ef3279e0af9b2bb63ce1ab9ba62c3611d9eba721e814be769b7cdb9631d238be39a3cabef07262ebaf8b03f16dc96a37e9d0d394f53adf70027cd8d7d74f0ad8a74356147e8c6b42696e734ac772933b48c955f0dbbbcfd461d0af13b1e53bb7f02f3b34fff7dcf6cb73be7f577b519a1293ef1d253663ad6ade2867229cbbb340b8614b3d72ec8210efdeff604eeb1ce58593dc790be0b5c17409d95a8d04d99dbeb7a9f2aa59d6abe22fe9a97aa8acb4d5b79fb8345960ee2f859aa255242964875b4cd27851fe29db5fef1886e5a184bc1b8ce3d34c8810336eb2129fcd081b74375e0574ad5abbdf50dcf07feab283d40011769c43e113cedc576e6b71c39a731edffe27945b011f4a75e5e8b48187da26a2fb2f5e632f4855d6495013cf84623851567f9177084368314cc6e3ea4a578942b633b97fce3493a04566e8bdbf0dfd9779bcb117f33ab27131a14c4744a60c2b28ea65cdabb2e0fa6ce1a71a73cec09cb0406317e5b03b1b35609cb129035a2b4eb0403f3401f71ef4fca3ab8bb993e9ec09952f4b3930a5b98d69cdb9e689b47a2cf9e6665df1a98e5be93b0fea5e81a0195ce150ec3e041b4b4767798bb939053ecad6d23a454d057d60ca4f62fdd690c19bbf2d086f02c061b221741e075be010ef49a094742ef0300b483bc9a6aeb971ccdce2407b091e16db21f0e57c02b72d97ec2633c2ec932683b316199ed8637f6b1212285b9de41f41b8238ee251ebdb360f0c55d6a774d14e604ab4064b6e2318eea9068768af7ed137973141c3882d1286bfc26ceaedc8c325b823b694ecde0265935bd4bd03f29f26f89929b7c2d23141ffe8606fdc682553e163b60cc9f1035a5c9e3a6d0741d4b737564edb40b4e394e07d4a13315acb2d59042c79be8e4e82ac05a75a943d12bb168bb6bb028704968600a82a7a4267c13b88177f90adeac99fff02d74b4414ab865141c9fa7ed28cff1aec01d32f15c43631efd8cf4fc12a5374982225f592f0677beca23e804e8967c3c3873dff72a73f8a23d736952542ae44f59887adbce3636c3913965ae51fab0e2d6a8fd5d8a9134724e86690a333341ec188d82857168cf48d33bbfddabb8932ddd05bf39d959c0ab2a882379c5b00c098bdea8795de529bc98f6eb676a47f79191b6f42e8955de44e8fdc13f3f5bc798656edc6a33606266cb9e616a264b92b4ab7ba9ed11404c46f66ce1c5aba0cf98db4f1ffc26053310aeac264179f5a6f7b6ca561312e0490f271f1e313a766c9012efeec18a6152ac5f88c4fc8af8572d12702526db4b512c5e87560f502828806b45456d9684a8fef5eea7539c78903f3f067c6d83295444fecd4f7a6f0a8764b3014c6fee813904e673692112413782379dd9207501bceca8b832f1db300fa5a309b4e43d71a00466c835bd21705c68393db3d06bf42f56f4288c7d6e198177338ce6fab4cbcc3a75a9fc44305e2bdc663d5e8a78ac47ce7703eb3b3dcbeaf5520886b002ce5bef6c1b764602490481f77b70bc6a0d40822c075049538a4b4650ba2b5333de67b5c47cc7f5d12b068a217d6a22bca3a90f56433efd92e0a3642fc5f2f2f004d8cec9a91a9d336c4f4166a0cd0afd28b1ab36c09186aafcc27f22a8d2fde1d03a1ec5a52dca08c831703d37737dffd3328abb432531a1262f307d60a1d9775b03309a7e1c0a79fb2873bf02e8e4af507d8b28aef932dc0855d24beb4462041998dfcdc3cb32ab355c59273bb1c1ae60e5402ed833eb232f85d8dba7fd97f11ab3bdcd2d7d8a092920e4eb99e3fa60d006b50b741c323d514c131704c9378d747008b7843758d603637a808c87c45d826e2bce2bd9bff5100e1d5922f9b0073f96ac704f054e24c3abf7e21b22010db595f8104c5c8993cd31607fcefcc6bfe360b1d5aaba63b3aedce6625fc29c1c4953d9b039ba2b635326d97d329dfa94b0f138c34daf07ae7f0cfa9b5e2c9a73636ce3a03e5a1c09f8190e1d67df1939859faa7ec022f2d339a8cf70ffada423540ce5529af1ac173ce349811dd9762838ab264c87640123424033c30d196dd3b344baefe6364fe183f9ffdcfeda8b9634b26b0fd17fad2d424e7b64dcb6cbffb12a27e2248cc94dc065af42b0657c71d83ef88e46dd9e373ace361033f5016b977c3131076d23a536f6c6bdd2f64381a37d13bd05ad7ec715befb55afe4f90ca64784ff69470c13a2215e9e50f4932204eb6cefcc46f5501fb98e9c7d6eda8546cbc5b6ead800bcd193591a6e7628db3f9e0f7a1c5c4b0cd3834dc4a9e8a1d8e1cd107e232a30013220dccb7dc7f0e2fe22a8557e62cce1fad732695f7ddbb0217ffa0f5f6082b7727aa985af56e5b7ffe37eb1da6ebf4444627a6b0a23e857bfa033e5693da954dcfeeb626f3adc8911d8e4624784d4abd7461243256e5a5f271dea945b1b89b829cfc426de21ac422f80ebff6f18677ea32d464af21d863af888e714ce637d20d1c82096a77877c2f3d4acb303dcb3ec75603ed91afdca2f8f438362fa52b26b36c0e6c69d7758f9fa1a9fc4a9688b0f092f05d39bab0baec9f27dddb2c2c6bb25cfae9f4059aed71cdee241b775c95b48f62dce017a52e70777aeb37d71b5fb06b11e18d8056a29547859a8dae37f54ddabd713c8bb50d13260906944c0c582a6b702ab5f07372b9a639d61166759ac7680fd361372818345b58d0e585b9435464f018b16f272283f4fbeb69957cce4cfc9e45e8f97bbc049db7cabeab25c9fb962d994b2a8bfef6a815d297b436aa985491329748d93f395b9421b2a583f05233c53bc02454edc95385e775b6f63f8972e4e3f2d00fefeb208ffaa813e5f7cc6ea2aee4f43138e606a75ba0f7463b85401bee884a99a162d110127ee857260c57f7139d5a8dcd8039e59caae3b67a1ca834509db69b2fff906a51bf26717aff1aa878fc67b064bce7100e79469cd614f3e61199c117beb9264ca6763c107cc85dce75bdb7c3b57eedac0b1f7b0aeb22bd8ddd231cabc7a7ab4a86101dff8903837884fa4180f372c3ba9031d949ba7aa815bc6c503cc8015fb21271c142320f5d6c6da1a624439758e182e3e77d2b11306bd41f8506618a517187b8ee313ab92f09e1074aed83e6d8d5a4eb9e4358780ea961f4a8cd87edcbe0166e2729cf4685011c85997c1ab76d00c859fe93d302e62f90c042edc462f80c96ccab44c32295cae1456e3314eb7899c95145689fb4ada510f16d987f08fa0e3c2387abefd08442da325792d5762e9574ca30cbb3e52902fb29f3840a10017e19e3644ae12c50b7de4df874686536e566ce487629028d39b1e6f7d06d525cc71cc2cfec756089f7cd7a1692d4883f9143d7c65f1e6981c196f661d076ac224a59bd491459bd1e3dc7ef766f8e60d7717b98b4afef796affb7be7afef19452dca6a9b98839c5493ad0b1ec1c0c9eb83df972407bf62bb05f1a42f1da036c82fb5cbac6f2287aaa93c468eaa7f299dfb16c97d59f56865d78358dd320bf0856deaa1b89484a5f93daa016c09cea45b094f9777334e91671530604af8c303fcd8c30100d170941a125460e2a2dc9797674941d54a8d0cc53f97281931d7d6fe12ee802d890ec4e3db7fda4c413beb4e76eaf93b886940da047cd4113d3ab9455ff52cc76dbdbfa62af4671950d5c7ef1dcbe72738f8a11b2483f92c7d57fd1afaba5e99da0c6cf53a28658976f19b39acdd5a88e6465fe72193cb2683dd4ff8178b8a7461884c087c9db03d6b59facac070be53f16177e9b88eab63cd7b2376236c5e5489a585ee538d130cd3a710f68e3fb6d27dba9d405f9d14754c0d37c81082092bc265bcd8d383a211abe7e2f3b1cd2273d8f50936fc1a68d6a54e599d0da7e8ab2d60ef92a8a44bec58fdbced02155a7e9d7ef9c1ce1d9323ccf74f6425e8a98ca47aa1cd2531af2c8180e9dce5a5886c7dbb687e91443ad3a972a17d9936cf2d11d21c7a96fd7585720322701e32a41a8c9149c756b693646bc04acf1e5761b90c19f0d2b3ad5585ab042a3954951a79047c13c24121794e72835861421347754393ed018a8cd12a0f43a98029424c7fc58c9155cfc0c1b117595766d29e68ef1e3713e9701ea137e6bb55c02d244144b1f00a90cb038bd4a9c1ff34cb9f92ba76a1fd541a31fb1d3ee00f7f139af562511949b76691488f0cee653abb8abfcc2cabc1b43d9533ddb725183a5ebb3788fdec872363c991ffe2c0683d229ded394780d04e03f78b8633f58a9e8f3aa2566ac532907481a4ec7bd4a51f680eee149866881d61d4b6f0b8bff6f321416d0036aded60b650de18b167e03d5d26dff1b9d7959b8b1ae4dcf01a9818b02f26c42f54bd2ee244810e7c919852bcf3df1feeb33fa60e5a24655fc72ec7fb4e3777bb11fa38a99e613660c841146dbb5ec07254345d1eeb28072b61d4bae7f6238ea48e80ffe0adaeba39fa02429d5d88004fbb427a7e3c7c8a5e9d75a8bdfab6edba695c769d1a16aadbdaa2f1506615abab0826e340f0fccf4e26050693989cced77599503ff6a7d4e6aa495f27beeb7007bde900491f869cc7d8f7af3892533f6eb712d05829e1d50919493792936e449d561704146f2a2b2d2b93412b12eb30db3e242fe09afddb68acc92615b3de3398635b0d830fedd081ccbb25c11be107789f4144f7f01c33b5bd4f9f25db8b5ce6555fede2e8d1f4acf1aed237bcb66ab7c5fb292fe5ad73dd6bf5b42d38c0e46d601e43c625ecf461e97fba1161f27e60e99591b8bf27353008833abcbdd4fc0e38dd1f08b4b9e55588883971ef7c413c80e90d9e3478e995e016139388831554070b98ce125d6f222353052ea51761c3097193f9a0d755e0f70c4036879588b598b18994d00c2f7bcd809ea5a287d5e80e9c3d8d1a086d5c9c9a195298409b9c2307ad0f61b52d1f5b7e1180c4a07a74c48f1a7cbdf82177faadc547419df4bdcc289e959a45abf9761b13fc6d16a1497f905ca29c196e017767a7d2fcf0ea2eeb1e2968d328af5ceda59cb29af71c2080cd6d3d834f27b80af4d1509cc81deee195436735753787b245695bdbe322be474d1806284b451fbb05495093e91c8355774404115bbc0a971ba0a610bcd912f22226572bccbda05429bd3a8b0ec5b5800fca1f8f7774525725a9ecdeb586b16c75636f1c68504f4b17aa1e2748c56cab8d04db461685d11e0f17b29cc6d2b01ba222018974d1efc94d0bce59fc41975be607308e72de89b9506cc926b9371a1a04ea367999542910f94acac7cea0e1990230fa145af3cb7dd4d8dd0398173492f23f13fac68e78c893b5229aa5a7f0bb785864eb24fdd1f6c59055f41886dbf160ae346c85ac8dd036950e359858947871bd18fc361226ec3e42e9f25cc38de6c3422a476e697cbfcb26195489bfa9182b0030660c0acf95b5476d12553e06c953af79f7cf896ae0da3feec70820dc6ae8a3e1b4d131805948dd0902933b666450261e75aa35d7798b78e448b452af67238dd54438579ce9e239b814615fc36b4ad3ca4b71aae2f7c5ae75240252c908ac59705f090c02901185eedde6ab498d93632a61c2030f4e59b1c8043d7836a8bcb19156f2dc87e56362bde282cb686ab847ae8b778be9b20a6214674e99f993c3b674b5633c6d82daa664765062bdccc7aa79dad89cc29eacbbeaf21885991433019f2d3cbfacd53d8bb114d5dfe0ae280cd89934db50891d689d346413bfbcef9dac8096b0b6dfe64bfa41a410aad9083f6842528cfd9e972cce3098b805fa3552696c2af81251ab0b1f3345076aceb692e188796d2b83adc5820e34596f41494074cdd92dcaa3b55c72c9c738c39dab6fd156a5ab68b01f3539350c3465c4ad21304f67de10429972970cc5f300904dbf9920ddcdbd19e92e6b63c6ecc5ecb27b6d8a08849492cab034ed6a6594ae303e513f26018a146ef276b00049fed6702e6abd47a05966794fed882b1ba96f86e03ddf83c8896cf498d0d992a2971e588fee7e8d37e9a814bb56b464d5d63bd0e17c5c79b4a7f1cc46d7535fc90b87870dcc38361be27e759df62dba786387337a951025de51f902fa99d37c51c5f919e84a07e30766592e657a615411792a107f059165d6ef6f1ada2454d82ede68cabcc69a2b405c7d16c660564dfe94f8ea51c0330438c29984f0e5b571b3084097f9183a6d048ea295a8a17928797393a4cab696f2b5d5aa68ba0e5db91957b4f25f088ab9813cd818dd735a44cf8f53acbffa1b31ac23a4077cc6a03c9718c02564045e415d31353f7461c33941cfd88cfa34aab28cf013c245d278e67e07ffad9d047513a42ae799baa37800ead9ffae92a64240053614c875c1976a16a5b1e4712f673b47591615d84257581e8ec074b24b1032f7c933e89777171f10de3c34e2ddd37387ea047e836528300a06084604fa64300219450531a83985b866dd92b1fd04ebafa7ae6ef3f08396c340343a306fefc739623e05f20768eb8282f46fd9bc11572c68109688eb7582d22558a74a3569e9efa361adcc18b0a572674ae2fdcfdd280f47f116ddc1315c0357ab31c20dca9d8beac89ffb18672334c90328008bb72dfc08256139b79ffd1d8ec4cdbd675197731d55fb8182f68ea558b9e421b33772b8d9ca37521b03c75b88a3d83c608700cfbe010d023ef2b4ea83d0984c25645e6446bc339930e184b6efb92ad391359360d16f5df53569e8b7758cce5601b9107cfb5e64c8b7ef83e8e08b8ca819912051eec165b25e59b3a6a3bfc709d5a9b74f8b76bca716ee3c08fba1cd90b23e23ebda718e5eda0afd6104cd5381b1ad2da3c341c1c62a0bd90d291562a3b60f55e09f6640c53f68ce940346c59118f8b78a4cf41ddd286aac5638781de4bc3d031563e5723d0c72ed66284802cdcf77a288782b69bb7ce8f62ef9252e62910319d83e7144359f319744e810aec4c137b5c46a84a80c26b085995950f539dcdc2bf739208e4b7393a8c2bf6e247e0cec4a234f956225319116c9132d81f186347917ae0b6ec61e9931e49e3fc42381711b11a7467bd3dd80cb03f69ef58ba11079b8b65f92f8112500a9202bc8676b8c2c0b9e26a23328e13e69b2dedef931fb4550189a2e41bb30016951e016ba81598ee001371b0324bd541b2b7994b0fc9a1e402fb44b6723c8c7cdf907b40987c5e6f6386246919ce8849482bcf4bb1860db6b17eedcef88493f8d95f02349ada61f6e6d4cfe8211c3d26d6b399686ec48ae877b8c825ab71429aa0c9b33e7212c10558894910845c20325e524da8d648ac406b420c935399d8b8d841aab5a0d35536606952d936ab19cec09c21d5f5d546c93586cf531c89f5c5ff7c9dd88532758f573eb2a266154745dec167a3b511131281f1b018fd3c64f9ce0bc060f1768182f3a558883fe6edd2e499be728c36857e95e7fa3ff526a6a8d38d73455d6e9899e0e8ffeeac9602d70fc5522ebb21de132922173ddc696e53b861f41fd1ba3a6a8fd6346d088474452be074504f6872de6fe1f6cee8cbf57e3e9e42db357744ddcf2da5c0866b18d971118534971304c0b48bcda6e77bc142e521c2b88757f1ea12bf6267d0e7306571fe1e9aa41a2132a8f04145b0d00595e60bb581bdf11d8444c722c84c5ab0e4d4b128e244e17998d549ad71117c7d6e03f82058c858aa019151ee78b489d09fc0050187a0954d21ec3e66cbd539aec20d83b54b95c7f7f0a19200e7eebb11908620e5b58f36791d283db28e12115a4a75a02125041b23a170bef59fd24150015f735c4c36dd3ee28a1348fc5a1fee64d0b73b11f8e330483e6dce4b615bb9fe0ac0037fc8c76492a80afa4bc1441059ccb830eb6c4b054cb703b09261eccce1abd0c898647db8e0bd3763feacc8991657ed4e2f4d3721875d2c3726483b1562bb5d5c563ebaf5145a7599f0bb044971c828078c724dcf3496b5485de32ecba9a2e7957e250dc0f40a1a0cc6b3425ae01835b08e6bc11fb3d4e0b591b52053ddd672e401d7ee963cbe28f2b649f11c376265324979ec96257b31394656fb2fe23c714c3da376b078f7a49f0e848d79adc2608284aafc94a4ddcd26c02b77b2aa2cbec8f627559d8ddad8cd37361edd286fc09eb9ecd58b05e2464274045196ee15e25e60bf2910d867d0fc0a8e3df9a881acf2370c93e9afeb88399f44901343842436bf09a3e5ef9aa8074ecbaf56a9125a1bc69c464d2cde42978d953d0f7cc3a4e3008458e3587cf77b2d592da95b6dda0eb73721b11d2960b36c35d8e78da0081b04f3c41e728deddc409e75d808b6e95424ac776ac19df2ce51f0f5c081c22192c51bfcda0bda6e0d16d638ebbe077785d9e99d273f0b38eb578f89f3cf7abdaae8a23659f7d96ecffcef946bb4e03c0737a74b5833db0b5b629ebe22933c1d240dc80fd45cf86668a0912de98cb87716964b65a59c4eadcd14d116f564e49fcee910f9d8972b56c709ce69e81c3cec96300239d4e9a78d88b1172b77e979bc4105eb32cbf96d18768ff17a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
