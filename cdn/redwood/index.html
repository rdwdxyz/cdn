<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"964a7cc010c5f20d865dc516f9b0b850666d5e972045a77c2e79bfd605c177b779e8012685011159802914bffce1b463e8d948d57d464e1498bdd04ae566e13ed714aaf316c5ad6b6572819df085a49db6daeabb69344d0746e3fa5d7ac24e9f55ae5adcc482636a4b27c79bd454580b6fcab70fe9127513213a8a2314752e62c625607149a6f44a615ad8642a7642c5e9b0f38f12fc08d6e4361eacc9a9c1c2f62c8ee4462c02d6375735ddab38eb4b07562e54691402379c1389fd58b2735b7878f39ba8535fce7c641bfc6e721c508b1de460b08ed7362b49994d0488a58944e1a63f0dd5f743e93c0fb9b56e1616355903553271621c85fd19b0541b3e7025bcaa46aa3ef8172b9f5a2c1bc288741aa6054f32615987eceb564dbda818f669ec7036e439b1f649101c225ea46c555018a9d87b7eaf755ca65736c3ef05b0b768bbdbbaf77c601a2609796775bbfdd5879f72464df625e6b7c28fda5334f13532af4e1b5ebb3cfa45da02e719c7ce5c10c7d987645ad5a6027996922df42d44597757cb342361fbdde3e8e114fe9e9c1aff80569222d744c8a89082b84ccf0832cc67cb169cdacaff6db46cf3829cbf884d8c12ccfd3410e293a877b3ec969b7ed0631242011b7881cad78a608c0a6b987420d9c92bc19d66230c6342a98befd9c832745e5972c0c172c95eee1abaf87b066cdb8a9dbf558574a3203d530c7e044d7342977fdc075ae580c3585a286ddfff236ed9fad2fd1bd76634f35bf240c7f8d272493e28c387361f9d2842f8112aae43eed85217489981a7b128f69b43438f8f02aa1f00f23f04ece8c5e9bd92d444180f423d0776c80cf00094baa66640ea5d455a30b073ab5585b5034f72a6b09911475276dd866ed1eee227a67433524967bfa151fdc7c2b73f50635afbc7bd495fe7e0ff0cb3f2fd2cb2acc920dcca6dc50667933067ed9ae292b7e38e9179cc100fb4dea0e84d5ff17b3354a1a9b0fedb7b498214f7c30faa123ae1f6f4e40d818c139a089b54cd4cecd7e5059d29473c46f3a4eb5932bd8613eeebd25ea2b4440b92150bb15954f5b287956ba35f5e7a13cdcb45b3a0c5f791803c3c3b089182d2507aa2252315421cc6e5861c60fb97b0a0e86e09be6ba2807fd1e9dfbbbd851d770b81a9e746b7e79efcaa2e7ad06d6964e24de064d14557c2c961ab3b16e9effc50b6b22e40ebb961a1136aace6e8c4b0be7f7e11d5643e4660efedb03c84220c1c8441fb3ac64b09b7f130f4301d1b5d9c55f9599551d97a9aab48aa524ca6a3e31ae600107cf212f0abb73c6fc2f01f23b20de8fbf760ed038c50bb9aa897cd067f73ae448a8d414ca13ea65c31cf5c29be53ac3e25389671c1d8494063e3e86d5f08a837fd6eed9611d317a5279dfa9bff2edd8eccc1fcf8f382879a9b6c9f9446407552a62cae0fb0a01f622630e2b318ecdc94fe5be2a44cae548cbc839d3c1fd1d63b77293fa6f9ff9c78baa28bfe9e5f2a0419f595046d2f7cf2c64b4166824166c65708ebe44241b4e8a0e9bbe1c2b6fc7cf49655061e7459090f593253f2944fd4b5fbd8dd69eeda44895d3bdc7205b9561f298a16956b9f1459125a9465b6ee9f0fe544a91d572f8094a11599a81cc03999d47d9242848c88ba2ec5f86389e65279ba1031dede5e2995a9a3942d815c80face0ed515a4b6c97c0f30604767dba2f2acbbe020ff54091a6d8af5f020f27166121e2ec868d91d005373b9ae6faf6e96d04ea328d6d74c7a918922cf227f0800bb3bc3c719d23d36d76326a47c129a6a0f8e48d58ff0cfcb96b54a083c6ec9e8f6bbc49d5fae01d00d04623df162a7a4a5f46a9050581cfc620d5ab1a9ff0dd6aa8f95987ae84cf7a60fbf568ff8efc9446c00e90d8eb71ce4eb69dd1c32405f72e885e79d1ab94d0aee3feb8a0d56eb1266c1646e0d74228c6e5e16caadcf74dfe679448f44f6bca336884cc9aef6db216b92c0f4448ff758cf39c10dbee6917f3687dbf36a4128993ac26d6f61f9e60b05082df98d9bf6889f11c266636de11ba679a8ff58f9502d13a0a755bf858e6fc8093212c1bf84b945a8042ec4733e31bee8b2b9fab42d31e401cb7d7af948af04c7acf8c0df654363fc6e1c87c11e8fb6ef41898088b091490332771f05ed1541f8a421b2b2fd55e8328ec406c39ddb59a7d41ac50fb97b31f3d239bbd057b4fb7f7bb73e710134fafd2807b90be72a07c3929f6a269a62ba6501ea9904366c30b4013ba2d81f85811fa135e582261ad3f9be49b759ee0b0ccb1b651dfeedb93b09dfb142b81d31183fe4405caad6546b0ecd76a27211a089976db7ee1c7b28a93f9c8fa9158545e8e6e6323d06e18a918cc9779d47ea5c6219dcf11fbd7938095dd00b2017b79b184326d76b64b951740221ca954c696360fac5a9daa87ffc208d4bdfff213a5785cfed81c5e193be6043bdc4b3279b911a19a00bb1adec0d68ff213dace852b4c94f949599252d2ea2217c7d2f005c162f20760101a5eb845b200f4c1028c547e413028ef32b3cda2c8deb8c327727ba7a74e27dc7db2b8928cbf83c9f0ec83e1ac0f71ba15792998e8b7fb263cbf887649750c1d27bdf61bbc451ba524ff3db661dbed793c7c9ec1c18e5dace5e9b2939c3c1350d422c6de9620f01b7b9e9611bed5f62e098ed21c97f3d1372727b82705ffdbd3aeaff9a6d7bd86950a9911d0846aa5484a2b3076911d58c54bfaa4759ecac8c12273f06103fa6b53fac9ba6ab14b5082f6e481d3491671e134a79b6be8147e2c4e7f19e79417d79584657c6beb175e72bab3f40d77552a889ac3c0285aa37bab83d50d4a1eba89ad439681fc63d0453df8d6e5958d9a4db00c748be6ff4dfe9f9f5d35c2cccde890a419b6a38a09728e4f8f587543a2ea9d37a6c8ad14a9f126d78877443f45accb325a1e8d6df345a2fb8827905db2ca0b85dcffa2ad41fa3168810ed742ff309f4e0b53fb6e62169cee8ab7870ef7d882413bac53c73cefaff7738041c23437b20d75a12fec64338a9d49454116dcc4d5e34efafd4dddb5a79b1eaeb9a9bac563059b2a185ea7aa2684347b86a14680833d6cdffd261ed63efb8604e1ef21b83db9cbefa81b998058e1c093e63d36e7f3212a680a13122a668fa2480aaf1fa3d9857f8eec1159b450db9d29539d793ff0729d36f701ad4b17c03bd46f58db9a194cfd18f49b3bc79165e59742609824245dc5079b34bd7ececa002a139bb5afe80a7f28d49bd98e85f6c066a58680372f5885e00a6d60a7d04b4ac5e8456f8dcc56e6471ea5d5df85e8636a2fb1c23ba2aafdc5f4ea72302eb40f3baf113de004d2d65a8af67db1e91c089f6673c68552e61e52ab4e772204bb1887ecf861b23059efd2537eb0d3bc72d970ac9fb6dc0d6e47d96273556d29207bda7528ba2298a4ae0b3066f018bb7ad8afc06451cfedadf4e1aa21d95b19773a88695f6f031ec28b48c2cc9bc514c67bbf72c4a9d176e7707068b7e33794db995151a6c8680ab05ae4313967448a616f59631798ae63fafb3d6a70e54fcd1f5b931dd0ed568126f468bd9f66f1363e41074e616eba3287dfa76641f40e0552bc8c181abb2f99668398625bc1a58a11d259e2fe618abf0311206cab6333f8433627553b7bc48b50e5cc95e1f33009f3679018510f216a596a6479dec464eb86c87126bf09584d7c68f9ae717ff043e7176e4bbcc8123a4031c0470d52f5f5a439705b939b30305c09909eda39dae753ff5ee0877f21b0bee9d7e4885015c42339d1e2eccdd271c453770ddba3378117ff9e69d8c16914813472893a6223442e350e27871080c20bb4f62a31296d3daa439bccc82b10494b240e3dc2f8488697d1ac14aa1e75bd0c3e6c027c4611aeff91fb3b41f251aefcde576cb15cf98bfcb6f4ebb457d922d2a330c5dcb0b1002fccc4ba2060a2dc701c3af54c3ba7580b1b51bc0e5391e0b944d5306acd69ddfca631e60a24afcf3b542abd51298644025bf8d7bd4e9d4ce9e63056fce59c3f52bd7d1831b373bc81c15efe4919eb27dc820e1de0de607ed618ad2deefe977f97c8dab01020b02be5d47bc66d6b401ae88b5e0e732327ec3c942313da404364236d695a54180401e6a25edf0251d78e74ad39cdad55fa8050cca6259defeae3000d1830828b879b504cb64dafec2e98e4302279edef2cce0074c4aec0d9fcef6f1962342d21f13431f6f8fe8104278ef17cc69bae903e8f83d0bceb6d41dece8faa43926b20b84be60393ddd338ee0f4884fac76dbb955f4cd1b61cd40c1b6b169497f76b4eaf15e7b456029ab62a7ece28ab118bb34d5f02f1fca8e87b4c75a5fdc5a4a10d6f469083f3563a42e4c86464a37db45380fcc93c2bd0e5ff10e21ed65b899656783ff1f9bf63afcd59851e826531dc7d661d7006087314e85b67c4829a0a12d67e82be1bcb3c88aead9e8a8ca7384d9a3d329b177c1062b0b658ba3bd83275fb4966dd04d6f01154ae4128aca8a17b6fea2640e0d0b2b9dd7eb3da87a26eb6a17cec2e8d449ca6451e22c42f6cec66471521a250179bd82f116014068e373a023fcff9f39f08c44d5c7562317950eba4d19cd6d0ec55a6a63239d234963ca232705a0c278e83bd67a604b6b84788beb4894246d6bbcda17de24cf68c0485c9570f09af27beccd6277cafae11a33733c96b77e865bbcc9af2a86c9b9ecf42e20533b03b514606b3b40fb4c0b7d54e4312174162488913795096afab0b76b7a92db642f23510d653ced906197ce29b684292ad8d6d5bb934d776d9343ec1bc08c31fec1aa2586c1b43ab1d5eae217536ca0eba5990819f6a69b078f71327a705d3b0a8da6f9f9177a617d83e771a418cca2a19ef3f71bf72ba6548c13da06217a264689f1ff50cb828a493f455b06abf25ba7108c1b379cfe8d9d0cd4d15812bd64b81d2863ff02254e0c3f8a9a0b6539d94e6d6ac96f1c8be7ed547234d4614a2661ee508ac7f90c48b4e701d8b5dabeff83987883025277e05deccf8a70f36e571f5c4ff8fb94c0ead27056decbf48c09631e74fcb68289613f28e188845c83c49bdd8a22e5a890ed1707c52c3e18fc978154897b9c7a246bcbe1d29be5f826993f8bbb4c7c6f956a10f0ae573e19f1a80d17841141ad3626d7e7d31983e1898c2b0652fa2be93c9a8a43d01fb439bf196b9cd4a0dff5ec83a2705c9de26449fcf19b9b40f0a2cc0c6377b661458fe8bbe546fa2c0596b504c33c48e961cc2aad1d4ed9dc590cd670ac810e765081341ed28abad355b3fd35fd91110291710bcf5bac46b4a1553079d39ec3059d01af3ebdce5030acb99200b4ecc6b7f56f2c4853085264b340254e7a662fd82c112faaf30aaf6bdc84bb06f754f2afd66519548401c76b6d089c648dc328993aa24a1fe5966984f469a5e60102bdcd2a5e54f90e3cfb60ba27ab1864255a66d461c9e4a9cdd46af64dec06f013fc640968cb8e3a2f75b0b73d0ac0f527c360f0843dcf482759fc586a1f71b7158e8b07639361f32999aff5e00ec1ef77cdd8c30140293ab196359b6d3df319e8ae5f91289ad0e4556424e050681d494a032171d4d0c7b54faf264f3febcb8eeb4fdc4d756c177b770b71b307ef695bc282acb19bf2593db05d82debf607e603818970e2ab20e2db323f02957f3bbad93d9926c51b66b538572d455b2d5015424e022b3b7add05db7d17245dc92ecfec27b2536f47d25d9d9b9e5973497aafe9457aaf1dab60b7690f2eac1a725fe1cbce97c4494f02819a816c8237338737bed9b80bd4e1186d3f10a2f36e6c8ac38a9435c1120e3fb7d72344a5d89cedd673ab9eb0690924bbdb118bd6cc6c1c28787e9e52d4a4f85293cc6c02445b59c9e111d56976914a9510b879e34b0632715ec6d771ce42ad2261808d7086f82d2389d068e6a5980970d2257ba90d66eafb95f33d086af64749ac096cdef2d666718ee489e1fef58d6fc85d03477a9458165ae66c640e24333caf6ddb8ed95a35631ef3bfeaa81d532f17f08727d25f1d3cb6b893ae481b9685ad4c531a8cb1df43020d1c3b4072a42f810fef3fc65bb13963139199290b22796bef1169ae52b42b607297a6e7e7842213bc4fb2aab734b42643bd22fc4501daa704a2d27dc8783913300ebff00f4ded3705bcea18affcf8c5d692c7247db23387b92e428262de6450743c7575de1225504ecdc1bf837af545095c13483303a274b47056d6789900b19a0ccadba360af30a6e9fbc4631ab7f95bd9639da59bbef82a47d448695b39c1c895a2d1987b4857f15459a9c053c335a10d46eb22243aba0bc3a132b3c7100bf787bcb58f2b3a73a695f1d1aea0a7d663519b6465d0cb2d3a880b232a6de32fc6c1bbf623104d5d400aa4510a734b864cf3983f6f54791ccddfd020996c7fcf7526c05267d057a5ddb75575ae1b347f0501cb4a8c42d8bfe5707a360fff460c4cb99ace4d20056723be2b43b61a64c1c68721983a2d4a75b68df179c6fc266247a7acb30dc4ab8519b60ab7237262d92b0a1ff394c8568c4e249a7a6f2ed5d29bdf2f673638d7d685bf693a431045b658a4f7e2db48286382aa4f5e96924f74562a1b885288a8a1f369b627c41444d5389e389073c3159c128e6ae216f956ce6ceabcaad8c6e574c076b81cf1e50f8d330acc22f96139b229312cc08dcf8a33d507d29d57ce5341947fa30d7b117f9ae65cca64aa7a1db69e01d2ee288296828ce9a0c32a9927cd09773488e372daf03cdb3113b09a6dd49a0263bbf951c9a86aaec9782fbe758e635a47d82d40e6198495ce34de504e36f18609a25e3e5625850548d2b18256291ee660a9ab5abcbf538518404133ebd7336e6aa526d913471ec23e488c4f52f5c317288e46a7f4ff95780a6a6a45cbf44a4661c9d6dfb3cb70183846fa94aac78c7b7864e888abb9fae21ead0bd14f140cc733806a741de0324e1c0ec62840d3a1f340b170853242a3b6d1ba724e13fca2f991dd611ad78e25104fcc2b33e1c0e8730d1a3221f168f8876fe569b63024401512247b21116a38132334e51656b34eaffe5367a96242ea55d571caa64d180398d1808b230c9541c4359591975fa53bc595876328d77ab148cb82e0121422233636ce2cd341c936284d39451f747d4fa8842928b51d1b32a2a58b32d82ceace7eb3947f254b6b8a1e3dc2632550c9d0789db8a40d5665985ae055e108c9f2ddad1bdfd9085ade9be85db73eeacb48d13a8dab67e7aa80433c8f2d33c0ab6b545aa1511c5cb085c3429eb6351e054c6b716c6cfd40a4edb84119cd0d22cbd3b4b3a95a6b69cce9223c97b919ba8526ef8a18fe5f039b78e5a5331793962cce45ef4aee3668f5a7d318722d3a9703fb021d5d8bfff8dc16bc6a100741e4cecf91d3b49a00b5dfe576af66e44d23c7dc4976a97a6a6e78a10425503e343a44c093335ae42a80583da8b29b8cd9092e78d82e0ae18b65df4144e846a40786e52c47d04a0ceac4937d1f97eb903bd3baa1a056c6cee8dc62d06c9d89886f595cf60e83421b82509a190338f306ee14bb64a580d14eaf4e716e9a5445410faa62338308d9c246cf524b5afd861b2caf85fd1940d800c2f7e10047312e5cb5ad172fe353c1ef6325377513702c6034373dc1d505d300df82c68174e7ba1a55d2bb40a2cbb72fe7423fd6933a744d5fe4b4e93fe62cad54b1c9228142103e788ffeef186b17604c8aa4e916b1342977d051fd053de0bf71c3a07f5466e2c782c1e960f7328ba2dfd97f7ca54a81c539ece41af550bcea37462f4468ade333a41d5f885b970c54f6218034d8572f6bf146bef6049fc49b1a1aa1bcd16fecdfb3fadfeef0d83f0292129f4330022b675948b5da6a66365c52b6ce186b13e5f8117251700aeab232a146f192d52f7eb1fafa73b802410d2a963b401c1ebf4e25f3107197041a4eefe34ac5417dc2a4dbf26b98f3a6f4bd25c15abd2a489bcee99a306e2eabd083d270b7250eeb9b65a0845e0317cf4a0b025e2fef477681a5c690c837cbdc67ae1bb7335754e71abefa78b410a806775f618317acf16a90b4f6023c602842a7608a015c0561ccd0d9a84c754de9d097de04b39acfab9d0aac2243b3cabc7b9ed99f64c6ecd6f1e12c5c3c64e3548319bf8caac3a47754d938a5105e304b1a6fe402bc8aa97dcbeabb90de0d8065d02b646d54fda513a21c7d79c675cd5da0c2947874ebfeebef5a74f2992740d8514bad0c9c2ba28736c8de06276f3aef51e8d070d89f6ed93214b7c8496a6127f999229934ac87a140c50f55c00917575092074d40fa5120933f21b83ec78b6676d0cd04a3a571f3dd504f8b6eef5699fbe790d9d8c1d2bf178edff51ebebb6972ca3792f00c382ce5593fdef12d98941c59fc5a16d180bc9630eb471566c7dfb6be6c95d7551cf92826283163798a862271188ede4a86f9ee41664a37b81318ff6c481186bda4ff0d5d37cb76b6b06d9f7f3ac063ca501615a65d9c05b4a005c5744132d5d34d2826dc112fa66f639d1ace2c049170def9edeba918073bf2ae55b98d81b1b1d35eeed79f984e5a77c7c6a1a6181e8b5d298952ea1d9f6e74cb50bca20499b1f4e4ac062e9c0ffa9228185b249dca4824692a11f6839d6a0d7bcb5eb9ea1b5dea7d9461e69cf26b60c940e349b76111b58ffde6ef7b9aafb1e279f8f74d76dfd4120258f74fd65f501a530c8598a895db366c3c9e6d157112c715dae3e519394e5027641c4fc47f7ab75ad2b867e317edf46c6f530bce1dd1cb0eee9c6db53c9adb6fd088334212126b58cec6125df2499352fbcd8be0f41f31e9d908b90a141dd85afcadb1833137aa140f38878d78986b2593bdf9d0be6587ed51a975f5d95ff00abe863a8b0997eebdea460f6ec9399f13d4472218630fcae484ac5fd03d09d7d054727b51ca3237ec8a8608ec30cacbea7b6ece0d23e3632889088c1cb20c92949953215ccf0dd9c15a1687742713c56a8791074304f858ab7cfbcee5ea997554f5c2daafd471b982e0cf0bd75df3e159137df64665fa74f07b831a23ed39342e5014d929d896ed16df48628f6a731c0be4816ebd3d0e8acb1152165a2e7758c8d526e380480663ca5f30b9aa3a9e4a4b32f0bb8227537f9cdebba98ab44683cae99133e1f22d83caaaf3c6f1115a0f0c9213631dcac023e8f479b06daf8579930fe735c5f65520748d6955a38fbf2b9e51749e27a8e36141b7cbef7cbf7f3d31aedab3a00f3b0c439f484d5bcf173d90e3fa22b1748a94e28d103068ceded91a9aaf1a973c8d8e84ac836a0d389d7ecff6df13e89a61a2045a8060ca1ac76ed126155b039e55aa47283d080e681f8b8778dcdf02f1036228ec05bd3d6cdd08642f015fe0cbbcf698eb9b67905297ddbdc675b326df9ff9bcac95156b476c99048c22fff63697cb416b5e72f5c2430d33552d55e4f6ca39983f0bec426224a14050da57a49bbb6490366db7018b0df5a0f824afc2095b0b7d6b6e8ff18e1e12a1a0c6cf575dd0f52b0ca3e7fb380f94042d0a57de3f15409da6d2a2fa130b375c0f3488e41ad09fa92d62781a974917fe345885a31d52babaf6f3a4f826e8fe35c9c7b05d5fb1087ceb878dfb255cfbf1aa945c8efda3102171d7de7bfe78006f0396e8124c25ad866b7b9bb45887d158935d8f50c9ee1c36565b4527e15d970eef3cd5c9dca1954f09945af2e5b762fb112cb871f02a9d41875854cf4145cd927b47900b9b1e04700aca68a3a668c9e035443c11e988ff4995e5406446851e1f32420d4172572a0571ec613dd9e999fc859ddbf9c75782de0a063f6b6e7233fa8824b603468b8371cc5e37e04627499c2252427eef182fb11482b798f13aef035e8264236998bcf2e8489448852b9fc6160a6c62ce099ba1bd7df189546f6e41d6ed797f203fa88fe8756969a251ac1512f35a3a142e733ee9b7ef3af7882e74ea0cfdb4134f19d45af4b5cf4392bd929eef4ce53d52ed633654a356c51dbf4578c307be1359e0f7e6753c057bdae6098c872fcdd39dc16c6ee5c9431cd672cf4fd756e26bfc8b6561505f74ccbb863bed5d9855dbf29108a8d9bf7aaa50f38cb9fc1e518c87a8ba097aff948ae9743c8a70be0a3ba0416637597704d1c3fa94ff04f82250aacfc3e54239a22a9d9e01acb1af64f1971bc13101d1cf68325ee1f2040c041e01c5ad1059f56d329a0b80e5e4f4af07460b9548495662246d4466208e30d103be0fc42c16e70fec64a0b11d1b1ef2bc3ed575ae40fe1d5b776556d1ae404abb50a985b7d1b549253f6cb891d071c0ee903536a5df0e55dcd68ebcdf4c301ea2d7e2e38d1cd712cc71f95069756ed13fe1e2b6cebd48790a1d3ef39ec7ea855ea5636ede8484e92781c8d61cad42f8ee3a43581d00154688b081ff2b60e2775e1d1863142c693a85da724e0ff16f90a657a86f1083ad5297ef69363ad50baca1be32e258117b258ba0165499ae47e4cea0d3a7b88f1c3cac3e61130864f0dcb990cba9d9407f64b38e2547f874d658c8c500451e3131a730f78166336cbf6b60757c9ba6e0e5a16a7da7d9ead687d4d52690d82105092e10885a09a9d1c2c1852833beb63c9b58ccc5535435fb409eb9d9b2990604ba48ae362c29c0acf7682488f1868962b45cdfaeb784282de8068ed985ef24c14b5c388e04ce9754f90cac5a73e5674f7f775b661211147f7dfa8c45391f9ce57062c4e37ff878d1722533a4fe56e98d4e521da012ba22f24e7b84602c36c97aa28dc5e654032630007e72247bf290357aa1aa6f9db19924c0d6d1d35e06366e5458fd522e5dc502a94f5775ee71be32da4f64734ce76a5cb909f34f653647941715ffbed78ecb2a75594db3b0df2ce4c07bdf191ba79322405ebff4604041034f3b6b288680b58e6994f6285893fa4a8e3ec4889ad90e51d6270b3e1f0acca42841d4d3456c3c557e8fbd96f2cf6c4b616d30d4a69ffb8688810e91ad7d4418a6e2be98cb5e8a8c4e67484ba2f4531e6074d73843ed5ceceec8f8904eef9e35a99a30bea2fcb92346de609e81842b7a3fac7313db151da40a15409b5d33f9b3ec009c216f7930c2cdf4f147ce2f1d546e075ff0d5fe2b405a796f4d181c7d9ef82139d93d55b0012481b155f19b73e5bf02f3603f9a43124c2fece1a9d9c1b84ac9b9df97b0176150db22ed576b48aa8cb0ff4079e07818fa2595d0084184f9bcb3ed4f5f8a29bdb398d753c09bbb535771fc86ca15e88222eadbdc82c184b4b461dd85022afbfeb994ec0f68a9e37dd21bd8dd45740c121872d505ceb2725ea41b55acdfb8fe7ab74e9bfcb126a134b6e45e18667b06f940429ce3e0a03ba8736f4b25f6188a06351e2c9d3b62d6ccfa409cd0922700786c8776038fbc090f3e887dc1a16da4ec26187b04614739499f44850f0707d42e0910e20961ee8bd95429376f50c1a486247d93c299e45719dc97cdcd5b7c9fd103f649a06c5468dd53c55c051d855d672d1538394646d251c5d696155697c98d9778a491e75168d602530513def3de7d4637c156e6600373d2052e0df9442bcbdd7fd36ab544ef5b6d4988e3f6991a3aa534627b52702b66e99a6256d2d706145519b29acc54fb4862ddccc48a95afe984b254545d6d2b1d81f1bb99b5fe59f6768b7dbc4a200d10e62faf746aecf598e80ac9eef30c8a058bdf91faf22b02d1f0e6ec6a760b60d4584ea683caadad94b1e869fcd01a1017c88862f467ff2fa4ce341e011cc5d9448e6d88a5be33d4b90d521a92ce45e66818d63c6bc810fd996cde7e9201178f8184023d67d7bd67add738880a3d2e54a9f8518ae5ca579365b866b5d5893cdda32a2112d04de446c31b2391d1ce2058507749060393b40a347944e7054738e5cc6436c255eed0d3a27863c2d4d55fc4d50743a4c13bd12bf0c17c05510fd1c30c241067acff11b377104b44c0c8ce6f7c3445f7827eb73c7c58c76c73937bc35dfba9ee456bcc418389b82618e053b6b3bbc79469dea1d8eca55eca2a5e2ff5240a6bf0a4a522d5811394e1cffcde000c6a4fea48b24998b3e6eea8379730588ee0a4d2387fc77e98cac56e04988e3381346f66618d22e401a49eca54d7fd1ed5d10f2f60f80202079588d8effc19b07742823814424f77320a7ba7f39440c225a6e12369b761c919ed6d88981a7a7215d6df7807b59746491a2a4de37050abef5af633f82d2839d0226e18b52f541a81dee25b453c3063be6aaa068b445a9271b28ff16a32b59542bab75073ba2c3d00f5956411a0be5aeb5706685fe5e825c34425080c389863ab5127cb96ea553da33f30f8ac21c8f90b7bd64a3b22890d2f67c5fa6f892a70f033453687368c503c22f66236c86e2c49c0e2af5e7212c72efb996f592db02502e4ce620cb5a7ded22eb8df99e39ab6f8aeaf01f02dd6d04ddcebdfa099f71a443ac25c6ac66928da8b94ecabd662955a0281b19eed36594f13feb1e7599ccad36110a5df311bb263573a4af1861d5531f601fdfae94df4989b6d897e8ff89e695e408981930539ed12ec5d54ef9aa1cb5ce6caff96a8484a04bb61753f26ede24b03f068ef5198bfd1007fdaeb6be6b715075d37401c36bf2fe1e2fe91670d3ad86779027af3676eda555a077d76b74fe029e40039448cd66cd75343905e3a9517841773bf7051757fc5266ccd4988e62d16804998354cde722d487592173973235e0fa37a7c1aa66395147b79c06574ea9cef2d1ca0365d53334305b3ec2c7d9e4976b6bde86287b579caab56bca022733947705682165c70383e43a21d840ebc0cade00acf95f4fa760d308e08da121d1381ccb3f8d2d5acfe6cc7061de36bd6a8e80a15dd218a9328e60d7609b1a59c998b3472acc1944bedda7654def865cf550202dbd07f8fd8da3b842efec455a5f833638cbccfb7b45c1a4caa378904db902c3dd46aa086c175a0d7acc88cfccb33a869525b6ab3209c24579a4c6cd65395916a08d3a2b2842b96c13f013d11e044b32495e69614be9349683308dc5863aa93015113b0067e906e848f48f2eba89291e8137bc8ac0a45f48852695f645301486cfbfe7245302a212b97e056f0ec857213bdc25e1081a4a19db8a1bb3a6a96b0081a2e14f0e39ccba70584bc0af3aeedfc279df3b2a043031e742e1f28b3a9427106bf069561fa21044f4e0e38a4479b0c30b9b809faac71daa9313f890d7e3878ee21621c8807bfd6b56660f9aa1d8442c84d8fa611962e95359dcc157c5ee4e2e3e8f63d04ab740361c4ab740eae7e17a3abf6a81090b8e396c3cf9aa596a450e7056a2fd05c7d2a3810416d1222216a834e499ec84d4b88686dda65fb5eec50e78b456c009cd65320fc6601f1d03cba7ae9f326172b0ab42018fd24ede33b5cf33800bf15a0c99e2cd41ac78c5a7d85a0ac70a1aff74f386682247f0c3fb3d5f3863dbadc6a89d5d704265a9770f06e5867b2017c174818eceb2a02dcafcd16e0b153f638f758a8b5f8addaa313d057a1bfc10fa580b4d60db10b00d123236a65a3cad63cf97708404b0d4180ea0f43ee28b555dafbdb303e82a342d8b3423b823a49e7fbedcf835c7b3186764230b7d154d28433ce882077d0137cd5ad148c8472b269a69a9fc8199d8752ba5196e30f4286a55840d6aa72442a0c06ace63d2d450d83d6f58e8b06a3fa6d0f92707c9729e4da8dbabd373c8d6a92f7c070973d9dfd7ccf4a6411440d71bad2a423d73c81b33f16b1d30ed290b94f572db07cdbd51125067d4a44d7e457eb92e4048239a2a360d2a986d306ead6c6f8ddb2ef5657304666f792a16796eabdd15c461786ba01b45f9b64ec3f5d1c4abd3607d06db0d070b89dce68982b9194087bc5ae4905f7547e285fb92df9685f478bb2a3d56b39030892c146f864b6511bacb336974e3d592b778b5203c63e03ede9c0c0b72b7c74cb07835754fa81e810d78bb15b2518eac265776fce33bafb99c0a44222cfcd8cf4fa8b3cfee482e7a597dfb621efd22d1f441ca67fc18fc839e940f4683d51f540461a042a247f7f612d36571dca4fe6e0d7758cc91b1359f840c795618fb65ea08abae0dd45b3e400dd29b8829f96ab1dd195e0b35549dbbb9ab32be8e150a38cfccc15eb6813b30ad4f47e4ce42f528fd0c9457679f65d4d46a6a3cdff0d4e76415dd1e702859425ef8e895d06a94b0698995f03f07a28f954bd72d40e909436298a642d716456e0feaa1200dc57b6ab0d00f4653511e82695afd917647c3b2eadcaf85ac56946928fa1b262bef85cff07cc7b895c976704ff6fe4e6637aceb77b79646942f79556ef99193980c86b96b125fed2146ba1883548f6eaeaba63deb1f6a5782b29332d52b4fdbd2726c6308ae8adc710b2b9f39ecc48bf4059ab54bb6c2653be11d7d8ccb817cdbc1ca3e50dab4ea4b9e0894b702cae2212e6eb6bcbae238327740a7a74e29153e58409b511e24df11bff2f3acb1d2c9565c61e65f9e5c0c738fab2881d2c0c183ee305d6298c7d1c8f40fabaefe9bc41029fe42c3c157a8eeb6685a1c735eaf330876736a1882ec00bbc6b9d15be530ff4d2e2f3ec0a83672c88129dbc652a6feebb539cbd77d769c7104ec7b5c66af6757f990b7161355597b0279556cf6e0ae7c111b9afdedfb127439202b5eda0f0e48f17fa05d331b4f82302679331a85b173c08c6a3b6adc69f3b7908d0a50db2ab2d2ee625258362d8acc891df29980a59208a957e9fd286253375bb4fe307d39ba54ac10927693d1149cceb288edd73cc19ddf93d4da4c7e83aef0a50819a3d8b469dfb9d17753e1a413b8d677599dc35f920ac034442e871335a5a80919315cf3e32e62df78a68bfd215d1eb361fac4dd8c4f005a7b37d277d59bdeec811196288941dbffa65d80fd1264f895c6f99c827975ad01adb0ee00245c74b14d5132eb313cc5e758dd7aa092308ca0bfe693f0789dcf4c07b6b01598521bb76ceefbb0a1addc781d49d4f32fa2c213ccbc4d4bae9e4d80587a80868eb21949d71195e53cda2da12a49d64c172d7547cfcbd7cd2ae831c1fa317c477a3bc4db916838e11c98a18e84d7c8afb83f03c41262824c756905a75c12daa5062299d0500174443f3cd64fc99f7a7b9c8f554442e7977c88b65bdc318af67274815e2fa58baaad17ba069133b058076252ba174d2c46033c7caf138fd7f6959bf3643c6f0c558a1d40358db52d7d0cfb02aa8e888afe9696cea8348e22ca63f7fafb297d40a9b623342c40524c733c977e351a0c4c73f2bec073118b1aaa984a9ab573247a6d5b3a3bb827b42a3b82d6d898918a0b52d447e7c3757aab860aaca743cd0a61efbe989b745841d96baaab08afb9350c1ff5cbd174eb5616bd14e6731cf0618b90a0839835edf5416d7ee1df4f18078cb6beb9820a5b4383e4816a897af0446d1f0a20e6d3497820365a7ede2d114d5975b08fc6a6edb299fd755b170525d413cdd1dc0c9da3c39a70a380020f2fc19ce4d3d0e9966d08a2e12df7bf0a038800af44cde86669bdad961832898b75d0970025cdbc400504c559ddac60fdfe2e0f7cbfca34cc4479023b076467bedbab81b7d7996809fa08f574effad9e8ce2c6b4345378d8b5980201b2fc89eea2813aca7e21bc057d8e864222bc977aaea6534b9ca6580537bb27051f244b903bee6c12a2ebfe5d72b1f547a5e340cff3ede36e062a470dbfa83656ec8d17706289c5a1eb49da86aadfd5eec2e6fcf1923857fb229dad13c0f339a2098b3899a68a409efbcbb1b6f47cd5e4dc7ac79f0275fb768b8a3e23a3d9f15a53b5625dcc204538020e8de20fdd59bab288245e33284f5be169b1579d5b7169c47a90304e3a7a2683b5687c3ff870eb4f3d69a45c73e69a960bdf0a5b0ab01f5811fd219255f40ca84049bb0e83d4fb7f1f98be3554ff9dd7a22a73b9a0f97a3a280c548e07a0c1e5360060baf0362da53ec013a5f625dfeab45cae34f18d7b3bde56157bf48e189f7adb9fc2953c6a53a7f0207fd844a45039f0fb3b548076db122ad8abe3353c0327f971b493cfd9d6208deab0a35ee45257a0b71010863b437f7e1ff8e1cbf034678e7631d7ca57d25497c0b158d1f9c6542a5472991f28f7537ce3a309cd460e31d4598fca01a0ca35b4d1e89c885e3fee6029c05ad8ce8e344fdefde156a94f44d08061bd04f0c507e37602b51be1b7474240d22390dcd196e7a98b1dc99b49c100d7aae2ed71b62a8b74a5789b4bdc94aa2b0aaa49d923d581490fbfb5ca959ee0041d1adc4910a86f5182216cbf9d1418febefb305634365ff1af025d430cbbd46ec66dad02fe79dd6d47c6536e37ab53aef03aa52fd8dea230df6099fa51872220ba44293552fb70f0c99ab174e8b55a8dafdd8254c8cd1e4271ba6c40a5a6ef319df1fd7c181dd72a13161342d60174e131cda6ca9a57e51742386b273565f371e42ebbcf79aca5e8a37abbaf8899d3f066d36e0c6d5d1a1e9377aa4762bed36419a64ea65f8398a0c1e75ffce7c84b22d1b7948a65d32d8d68bd2672676e9c47172e365f7aa00e43ac5bdc0e769ed9537fb49e2529f6052fff617874c66a205dbe8d2a8534cb3b24849413675c46f712549edc6f28d20f515e8bc7c9b6673b539fdd4d9a0aeffae5b8615ec019a963624e6d149e7e25909e66db9da75af4f5bf40e6182132d9bc86880850054ab8b6a052f0d5b4a6358a52746804c863e6415d4baf87aceae47c266b5dbbe901af326915717b135e3ed5d30a78af2d219b63441ee3589155d46374b08f00c5630076ef803082d0badf8d6d20c8600ff3bf238f96d1656168fdc16356f9ec18052838b4be3eb5193b93b46c7fee9044df857c317de8014d9b3c155eb435f1a0bd255d52b96e0c2d8c79da8fedf6599ff532fc526f62edeb7bd7aca6e9cd08d2a366e224b09f7068a7f263d5b26a19a0afc9ad4a1148dfa928ed9f2d99ba245016db6f3f312aa2cfb0005cf6de6e882a16050b5b42fa44dbea476a222d3a979805e625e8074cbece25096b412d622e58697d220e930441098f30e12ce2c6566cba3053185325682fd9ace4f9ebbbcb6d4b0fbf355e342dd6f082cc53fa1241e28fa659a6335f39544779e18a52ccb5ed5a036c34a025105ad16ccfb0c4f3a5d9aa97d86d74ca8116dcbc78a45d0c9ab2ce495fa7ffcf55d9d48f1e020c05afc085d1c928a1ac223551f9b32ff85ac632e193ddf539eb7049d3cfc0bdd1682fe87716be2275a31e7fbd113a7d88685f080af67c461b0c340e6c27d2c6a7f1bb22f85332fa98a58d9706a36fc4d2626b5d0bdc33479f5f1ed4eda9bf660e93ceb102c4433d7d52ce013f3912f3be5ae72ba06bd33757d7cb09070d2e92f481be69b3e0e1c5029033202283e3605100ff5de2b0a4e905fd132e13b747b124b35ef8edc60345645723ad6078175cfc5ba117e8d99058fdac5af135975a6925b873aa5432924fe5ae035eee6acdc25f9e58073bceb76d6e29646c9f1c2fbca09bde443b4c521359c007bf492334239ff7a881665bca90839ec698944892b190484dcb301d808387897ce300635ab968dc753cb8687ccbbeea95822919d9ec4a33fcc4cd876a58ae97a81c7fc2fed2950b4c65dda3bd024ec55ceeecdc8cecbd9f9bbb33bb5cc4bc80060e70c921d9e00428cce07af20aad5d1afa58fdab85b4f3a247e0a3b5821c10949b9122285adcd35d15c19f3a166555b1b60fe97ef39df7c0b45ab73ead2a7fd61bbba6e0cc9c7241c2e7b826dacd7358074fd1f0356ac8ebff85d54d1654f0b046715a769d880c7208609d63269f2163afe8d3b818461cf2d1683a3eea8f17d50066de3d90f3f3a163bee78bd6b8d19ca2d205945882b688230d085305c263eae2173bda08ad1e08e06bf27eac9084e7b17139857f6951eeee74e3b0e42476b881fe0b6bb920665fdf1b2b628e5d3065828a2d36a459505","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
