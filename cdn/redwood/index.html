<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16ed9cd51e8027cf7133d301ac6e695c34e10d184aa483af11a0c07dc5772a21c0d16e3a9856d4bde090a6659962ba55b942d0236d239bff502dfb780ba68fd25f95362fa40229de46a76c9b78b5bcd65c5c99b2b380a59fd98b5534e30ab96828fa6103b170ace3c79ed0808ec04b6ecd6918d0519a6a8203c990fb0f31caa74f682341121e2c27b9c22aacd2a836902b8b84b2f93a79f5798081413f496ed441b15a65f15596d453e5a644434387e164b53e3b74072e90737bcc86ff12510eaeb620f42a784de5cf9c44fed777d49862c2f66acbc08936bacbf5b9328e228be79780562c471d66e5386dd0fd694c126d00e6f1505d46898f63bccdf79f560951f2981eadf0e740396056773b7738e748cef1cea4abd92626072f88d142306d08e27b452ae5236a826fc88008eecd1cd48ba306fc220a42604681f46048338de17e468c74e2c54a7393521df345756274b1c1b884bb5fb4ca26f2f053b4982de056b6b218ebb7309d714a131798201b0040e49775bf21945d29a053a2fbece62877e439671a00a3b5316a60828894081db6db7390d5ccbfe7ea05c3536e244ec8c3fbcf7f8b1296d9d49cb9b354d01172ae0c2a563f4be811e65f01f0ffd6f0b02f0ff3ce71add89e051e20d5bf1597aad17ce52bdcc091c2810bccf306a614e5d6ed8a6cafb3ffb6270613bca635d234ce8136216390407a22197bca475eca94ca55e4e47fa24de482b564a8f78857e52e65f5bdee6f90ad944813ab2ef3cebb92a51bdd0edefdea9c8e52daa52fa43df29bc916e9c1b4160ec062ffda925557764769219d169d88f8623bb5ef89ea36f296db7e62c3ffbf733f25250c982d00da0911126d3a02c3c3c8efd58330bdf1494259714d3b3c1a6c6879d6fac32686ed564f815415543cc753ac9b73e2ad0ab4800a63ff02c21fcc327ae1eeb42510d75e9ee94172968f8215f4a26903d2d9b0a1d5244be9f966d31bd8512ec710fa66b4dc895a2585564c555682cf16c297299d7e3211793fd2ce1ed8dc00c1cd130f6bc9ba24c2b4a8a3f76617d9c2cbe95a5ce96d3deb3b760f21c9a7f006139a2e420293e426347610b16f442690b7b9f968acafd6f22f762c06443b6a6bfb32c29c0c2311886b37bfd24afa7e43775726886cebf3b80c22ca01a66034d2e167f748b3cfa6e58ff9c038274d700f14c20d131b3f443bb430e633acbfb1266c571656cef889603d988541e5feb4cab9163a7533609d6a6057f70cd17218965790285134137237f873507d9d6eb081b625a3d5456caa9f380e3e0c903710ede422f95796c68ad8f6a91a89a228f6a47b76acfc5d73da7134b7f9718d613bdaae7c1d76ca41b836caf6a15afece7d6302f5dd3d06d8a0eac9c7fd4f07a0507417c68654a1792b4f4df54f5cdd38dcb57ca37d63f2a9e111c34742abc025acd9b7a88d415ad8190fe8e4f39f1331222221920670c350a40e9f1057b8ed187ec5c7fb9c69dfef23352d271c4c7face9356adf4cd188d777ae2d43e33eb688d55405097c27df5b75809228c8adb9f92ad20d3cce09f1f6b5288ac7449ad039101805c7e37d770aa49d9aea6c9a49b527b05d0d14fc210a540c3761d60b2d169ef024e509d04c1cf79d9877e19eb951b1cad4541e3ab48396ca7b865ddd2b025c1f875778aa2b88307e8c7db3b593849ae8109acc1891acdb2ecb1d00b98618a84e3557872e6e3f88323c3482c911eba65bf10f400f71de974876c9d3f0e4b97e1b9b74ac4b24913c4b6955fb13db44eee9957e512d3710b5ad2632c7e45813bff031eeff0857c6ef429376d280f868b06a6ac0ad70af6c7105dc1118e41578ab861b77ab514c41e35a237a08311e593c76bf93e5bea105bb73abad9ead2db322394729967a018baedccdd2ac06119c8c16d25214851185cfee94d1bec8d08d776c67d4935e470f2dbada47ac76d20c2231074ef141c560a3021fab9869d988a09a4fa00d94b430c82d91d584e7aa78a3f721ff4f569705a5a870c5188ba0165ac9f079cbf41ddf7da2d0a6e28fa32c7ec8abc84d68796a0f12f864525b64fe580699a9e97a61eb4b586f22850ab548a3df78d5ed75fae050bb4facd6570d1b59c1fc62156f08d7b21210e421653d2ba3d02285b6491566009fbb63f85067592da7b7451480d012d250c7cadbd34fd4b3f61d0a77345e5c9a9738353a577628c3e15d9536efd31c033947f4e8ef9fe3cf08622a17697014c70343dec253f31317fb7d1464ed9017e06c18491b7b33f171daad4657f787b2cf6ac3facffd33006165789c41bca74c18ff58cc55f02999bbb6d99d77c1bbdb7588b33bb24c60aa7c6267cdb300c90c9372a10886e9f03a71adade20a8502bb69f260ef9ece7bbc258a2b6ac5681f58e125e0fb33ff5308cbd2841bf8123881a01ecad27e00e51dc8b3a945713cbee3e9db1cb9f0b5739e298cb90345b5eb62902fdaf28ae4fbb286892f4935071058fa4341eaa0bdcfcf5c033a0ec67db303068e090e5f600b360ed87d947bd648364ae294c06aa11af9aa7aed1b6cae76b1aadcea412a16f2c49ae37538a8f07c6ce565515bab2016729596c207a03817a2bb144acc69eaef9f3e29e1b70356e6559194b8e083b57d118a435db88f9c3f9eaab3c7584cf08bc001d4f44c32b3f116b52016ffd36f185f7af7273bca3b0449a2db5f9bbdb57d143391a2cedb10e154914e89ca8c8979cb5cef43abbcf1db1be87b4c33947ba733b67f2175ccceb6d3a63298e2d5107195ba9c366fb7d8a7d8356d703cc3dc9fc6221cac177ce1c8e11042a956fd96777e7b88572b90f9b31aea5a75665dcdb041436cb0275ad78ef8796af659e998b0152c1469d7755d1ee34353292bfafa28fdeefb08081d0cfc0e6f971a4848da9fbc4623e32def0a0c2a27c1a2d599b717485be754109cc2d8b48796a077b4172d9a0d39472c27bb826170b080433ec01295dd302357d3bcb69477306099b30f983bdc235f6c30dc84ce73e7ce9bf5d795774c0e13132f95a59f9b819fe54c4413760e14700d852db84d2a430f0392f3da554dbd7285c7e4e5fdc205ed1313e64c5dccac1702303ec49bcf4e65a9963fe0f92b89ec64eddf7d158b380731f1fba64e7fc8ffa9985508c1b0e81e5d39c3ff459c283a0fb986bcbfd5721565323ec8cdc8b5c13eb9c580d4848ebdd41eb2b0d66b83178463dad966dcc0b09245adb92e220e0cb48ec5521e324488e122436adf596d60ce15739e2c93d828ff604db2f6170a5b576dc19d6574828e031ad2c3d0bee4c314fdb2a99b61043cec453ca1f6f796e38dae4473435eb7da3351ad18148b6317fee2d27077b3d1784e9b9f21b65a1ec20edeb766bc0467507f8a5bd7e4ad374811b44d6a31b3cf37d625ecea39c86c0db18ef01e029939dad0ff70d9e58c0b37882174dc9330a25f01daf80852ccda09be6f6ed54275c21e6a33b93445ed514ac8f4d5a0a1b1cc997134e9c388e817099d0fdcc51f08375f9ba02345ffc0ede0faf817e39e121bd753439b03a967df28cd87ebae7307cb179d0dd3fafc9a8de5ad93f08d8baab35135b13a6268c1692ed91b718f6c8426010aa71ddb1d7207c5265194bda4541081d339b786c032d7a87ac1df50e98cbebf29cda36315183a527d683140762fffe991388778e34468d4e0ec50a2693715f7e53270934b46f4f4b9d10cef80cc5104d377a382867edc67ec840a305c680499c3644212bb005a6e4ef400d1ad437354920359c558b93d75ae4512071b7031e96a5747d5a4a8ff1a9b9afaa569224e71cacb521f619883c5cb0d78486cfab2a46148e48b4b2503fa08229d4f9523d0b315e8dd92f0646a5af103fcd9beb70458836ef29c48c3a92a71473a4428b919fa10e550a9e308b898ca864c90d9d81ee10aa8abd0b960b876a1a7ce00525dc5514eefb5a971ba2465ee07dda600cf283f77d9a7e717b496d9f5e427a8359bdce3340d33244a7beae2de9b27d4a99a6705d76f1483720218bf1c8428ead47e00d374759ec57b60ee55e8a8af45fca2faea2191fe4b6b810f107eb7c61813f578663197f30d73391ee1cf6868339c935a457c3b9026506916a6410d61df41a454b5f280ad8631d163eb63f0a21e3d30c78205d8fe253b9f326dae2c6145e69c14b4c78e34fc09e901d528dcdf92aeffd01ed0503ea90c68f9e5dc05569e8ba5e36bdb0da407bacecbb5f610481a773563f4d87d97a1e7266d9eb96fa3337b46f7dcf90f929c483f2e1c26051519d8bcc99fe66d62b139968f896e4937f8873413c3c72c02c66515c80e508bba208291db5096cd40edd41ffa677edbfc2029701ffd22f0ceea5e844e7823b1fcd8c963dc6fe112196c1e303da1efc8f51e0f560c3ecb8e72534e6624deab34ba7de65c012de0ab21455a398e5b2cbf09d88eaea18df56e46d59aec903fcfa61611bc74d80e94754d7631a4b0e1053641fca641f2fab3ceb9c15556dbbcb3929d02149f61eaf918c6d4266b015f419f4f82d5a36bee0a10f15cb56099d69e328e3a52f3f22132480c271ee06cffcc741b0ed2364b75780a3e15492c8a41d9cdf492610fbf70f77f1ad4e03594471912cf0c14055c839cbaef473c7a4e7495335f4c066e07990eb1fb65dcc39131464d68ef60bc818795adc9738163c9f950d3382b4f04544776f9291d9906336e1838bc1d0c217131428760c6284d5a67967b7d3c8f4db425037058217b28c6bebbac7e6b3016c3c21c05f6d5dd63acdcb21f2d709dca3c1d8f51e681d1807d86d68f01882258f920c35e5cb8707abd0a27474556e1c04260f409569d3607dd846b048a82803227e51427eebbe59f33773863299ad09d0f4314d418bfc0b1d4d4cf383b93bb8a04991fb5487bef6b10dc76a142e26a515f05e4c7a0bc66dc575a427e15dbf852e50ed00707e2afb19c8e73c787533b7d42041286904aa49a0ede24e79057ea39dd64989a2e4da8bd0cf1c09817cac1fe9f5f6d9f0667a1bc648df689453c384d6586bc50add90269f0b9c5c355fd395078e85be6e62798011b6e55f54b49aa028c4507298a8a923199729399b445343351031e081ebb864437dbd250026549fde20b51eedac818be01cc0f6e058075b4d7d55e489c40df2bc065a544c570eb8bb5445a1dda49445b7c70f84ea4b728428e5a439b6159a337c90324809e009039fa286e0634ba9cc2a399f12a17aa61d3032275c6053d8666e38682e6749e0c67121a0b44f8a4dfdeb4a78d736c9ad38bcaae4de118f9ad70d4ef974931b5305edc87febbbd86fa0a72e18eacf60de8026c043454092eb9eebb2037f332631cd2da29fcab4af1d3761615e6584ddee99bf1f419a8ad92e427ef5bdea91d19dc88be3313e4431b35d03c0d66c93052dd29346bc4751da4b1117ec2b48a3f0fe890274cbce6b0db5e7c8620625b4bf9c0e88e8b8159d44a35d92741695535a0fcf2c10c837d35170d5d545063c4647090b5bbf2edaeb349c8832f5615120381c25340897a61d79a747aa4cedff01c7909d82ae5abd3dbd660b9a84c59691c87ad221bd37229ccdc78c21b702de8ad2d1643eb286d3e760e5edb92bd2688ad1e9cc4c7770bb03ca8fa3ca4d130576a76cb5daeee528bd6189d0060f0cce7c3838cd3dc6cf33361df5fac06162201cbb2dcaa4f61b93b0ddd8c74133f7cd983f4c82375f3b7f279fc8bc629a38ec85aeceba68ac3fc4b55e6db1dce5a3153bfbe9b052f0a248c8b968a64e3df619217bf585568c7744b217962ee5290f090b646983a6c7be7d0de09bd8e71ba137f2d838e5ecce34c94081ab61c3e6f63549b99f1149f97c11a89c878907da5d8159b5290fbcaef3c552ebd5dd12f9dee6459d4b061c5937dc2c61fa39cc414f2d5e260c4559eb0508265023df0f9d82052e7b7fc115b0334f5c9e0e6f144a182d4c921ef1afc2c1d8161734d666481de82ea4b3a1b6b5437fadef006492a6c1249697f7747b31b82fc054f8bf07b41a08e2b5ce168f99e440a59fce5b11dd09fc9846b98c9ac9e832752e4d8cb86eec9eed2a31dd593e8db24dee97a157bc81358fb01df80898c597d1ad55692eb6281084aac1442fd7b77aab3c2014163cd91cbf4c0a3589019fb6f7242955f2089b235d84b70e7adaf97c703ea2d9b9e6ef4ebb6a2c4a176563159f401cedbdff0b6b197f1877835442b5d4a033f635e56f6ad28e574f4318be2c03bb84a9e17e21e231f4bfb8209421e0e4783a6e2772758cd7f3f1c7b304236f38e6cb1dd7dc638252393fd1d0d7d600b1261aa2d06bf531706c37bc277b738be229862a6bdbb5f586f1033dbf0630f12d08f382db53b5c33223236f818734481eac8d7250dc17760e75960bc64d62f08c6213c41f6f251c3a63515c8058a3b291bc4eb2972806132497afea748c409ff744ea7205085f9a8a38926364c7c7a3e118cd87e0841bb986c469269074116f0fff7a43f4b15323a89421b54d433418bfd411ec8230b57dc7e04ad225a7a4eebf400f22da31aac7cae3068a54aa0172746df28c62a8a3096c960362ddd477659d7c35905692dcde6cbdab8097d32d0198ef299dda7dd051ebfe7c619eef591ea80d8ea6623a0602e0aed38b621a6a67efac6966a700133a93e1edaea28aa0750da81ff664da8daad42cde157bd65c17520c4ea83053ac8ed9b9a735337ea414484895bd749c41c64d8bae554e5d07b9c8949279020b554cbc9d261f47c08bdafccff35c2f3dbcf0f53d5807a27ddca9cb16264b0dfd87e87efdd8a8e37800ed3b154901499d39ae5c31d45dfcae97d41fd950cb055dc1702e5c52fd56a3b09de4bdd2f88892cc5bf108b36c271aecdba96459a16cf4577b0333924c25e7d90061407b0dbb9444a4807d5273aa5773323ad7d42f3390f0b6a9ef3024ed9b152cd288d49366db390e761240429612a964eb9c6b195e5b19cf23011db1c3ad3ba06bcee03554f4e576c018197426b627653b22666438ced9307de0c5b09313b405372c11e6e0dd348251dba8b9fe10d972021e998b9c1a66412639161703bddc943f1d75022accbe93be88adef62e74be3346c6ab641ceb4254162958ea5437e51e48a9d75b929d03faad4e5da558e684fb1771d377ae291ae1715466fa2829957056e24d59e2d17fef1e183435e527d0fbba1237f88b0e875a9ad9e59898198a3ea125ed6b57eac2683aa6ec612de63b43875cd51f2b4ec6559d6c0a34cb9e3915fd9b51f9d5fc290bbae15f063bbdb54f32b30c91ea79ffddc67a50d104d9e4bdc5bcb2bb519da94640f16a813d68ba2d95d8f7566be650fd3d2990d2238783501a5aa3555e984926c8e657c43e6f10a3394ce445c5011c04b927ec18615410cf303fcbcbf943c73046f0d861aa46c8dd063f3117a427b327c5c2c56d1bd0c94e5cdac946ab3f76b193283eb266eeced3253f94eaffdc571e1039ca4669d0709ee3d42ffc4e4301143603475d08614a40327157377f57c1c57de6dd451dbcbafce8b51c0926c0903baa0c15bad56ead996c04800f31ec64a3af923e0863ffa72e47faa18562909c5d3945167b33b084f47bbf1ddcb2af70dbe004b573699147586195ffe2103b486462b421f8c205396cdc504dcb00d03a04a9a07e6ddba5fec335fa813258ecf81f7b009d2caa7f228bf8fb24e00e42733a4b6cca776cca8e096686f0f58ec30d0bad0d6c996f4f0e37e066ee3e988f3c47933a9a6ea09e5e615c829e62dd027720a6631151695d4504094a47dc2c77cdf1ac152f588a03134bca1e9220152fa75edcfa85dc571817f2b5384272d27099f5d437a059b94cab5078dba846c7196f94855d129d83f19ccaee3e0ba08862ed49c8b58a58431e62d490960e5544bbb7dd78eaa4149325ae19b22e9e8595fe30e021cac4158ccff3b9a1c51682fb94b0f9c30b20823f53e89e71e0284e06b1a502d941143a27ace6e7ff1b13a5ab548f642282f2967b58c7195d74fcdbea5f08687465273a81fd32489380289d83b2af53c5195f7b12e40a2eedd5e4825194aa5a48afd19ae09644d16145f79f8408b469ec9dfdb0a0c5e00da298b3d78d499d2aa34f62eb9f3647cdccf253bbef890a446fbec220210cc023279e4796d61cecf79aa0a32674ec1e08b983d36602464fb65ec8aeb4402f1da0ffe3e0ef19c69e989d2ccf24a2cfd4276baab11b70fdb32b0c4c7525b6f125aa24b3d91c3cf1db49a68bf55d1931de51e5c2640ffb368ccc4bb76dafbdbd0efc8afe046eae91a6beae4c0a2f93927e8a700fa3fd7a141cb8dd1d8c7f512c220d92dc203add7d1ef79eaddb9378c288e164aa7d42c30f157313fa83c6f7fe741cd8e188b61adb0789856e5261586075690b8ce0d52f36e4c84392bcfe6fa57f135d8b2aa6e48df6f63c8739d4b22e4e30634788c2ad990a8b1709121df494aa309401fa15c2cb2b24c40931690e1d3aefb1642809c773039957cd78bc5e9a17037ba8834f7d15eeb8a4646cf3dae44025800740c7b707dfe445a815326f66dcd50a30da0b871f79cde056f4762d32275571ac3be3b8613ced9b00e5016c3486b8399fa237bd049db319de7077a5ea0639a824e718e639c8da371b13ca869def12545210cca81a4cd61da19a4f7e6036531a9d992d1347db648d6a322cd68a01815a935d8c61e4204de6b039680f83be17f03c870437716d6f42b58fc39f45ff3c6e69163dd1d7bfc69e72fe53336aa15550dce6a4d2a92e79b25c37c3a0f62cc9ffe825176c5e69ed0a06acbc0f883b4199d08ab71fa9f7ff7ca7966192f37fd980c6e0eab456afa970c5f9beaab6b616fd97229225d9fe317fee147416a73c47cc2029052c87e33bbe89edb435c785cc2ad2232443d16d36b00ebc3c163c0039fc5c77a597111eb6fc839c3ecc30543368b422a660217530dcabd6010e0a90cf38f75f0a9380ef15269d499684e3f4c7e019c869d5e881565c508278527aef66b0a76ba1ad59de7fb0acf0625ea4c43aed2a779cc253806a133a3fe8fa51c06db4e90211f5c2479b5a35400ea2e3c16829bdedda9e8bcb175b2e5c96abc8760cb502ac151881a16f5ba9fc01c17527addd5557ec3cc82bd498c9ec32f97f23922179e25329af5ae165eb5468b66a4649e356d7d6c5409604c3467e2e9433dbf7ee96fd083f4a424463a493956e83795c2ad5a750f7f652f73adc20f76d7480bcd44c2eb31c3201761dfd39777a666146b48003bfb14a49640742153ed90818d69f652819727b5755c72e3e76bf0ce8683c63a946bc11a6560fa1984039a8f4a8e769b6b5baf85330807589b7f87423f39ba37782f086583d91bc768600b36a7351c57f46a863b0cf5c9547da92fa8cd3e7d6314d3590e80302795542a7f5f9b5756a45ab9dbefda5367a5da11543c7452ebe4ef9333e402c3ac150c1fc10b396bd977d0a54b4b64ef58c04078cfa06d20f8282cebd557657f942746d08e7ea54104caf2756a858b6df33ae8088a9772546b85417300c8aa96d8494f39b18181d7e827dc0ed78bc02ceeb265bb620c73eabe304b3caba5d5c714063ace901f37cc65d7416fcd8311341740e734889c31fba5e3807d940cc8d76012f977b345e1fddb31fd5e6a9f2ffa23941b14c5cc1b487f3aa637f18b90944c4a8104902baff4f270afce9ada532462288c9a5e4709d32d3394e4ba3d62f9b53bffd7acf1c1ae44053c2738d37d9eb1902c189065d5f269956c291fe3285998afcfa1c6b667717f804db9bbcf91ddb7ead55b58e4f955c2c2f79cc16cc0e168a18697f7d1927327916993e3f8b94e7cb0d8187af653ced0260342ab647737968a35768ed6515647802b270a6e2c24ddbde84b159d50a817a2fe18dff6b4a10a97e8684bb08269534ce66c82463d034a0291b06b0d6f314f0fef159f573cf813c81e055c4e290b6d21c93cd3fec52318f28eaebc18fcfd623a9feeb0536e6e1cbf90ca4d95ebd32ad3368ba34201f85bc5d9df039465de45cfd286e995f3d119d901997b665ec2b05849214a93b6d9f4e4c7e50f62cf05f36b8af1f2e7f147f9a1c6748c5d978425e3e168f647399cacb2a32e7b98a561e7891082ab25181d1aa52d77977e746d2f7def2afd1cce49d82ddbe20dff457e9ab56864f5a4490bb80be3f526673f01565f0a078f6133f41c6c81786db41600346bfaf40f24a2d8a48be62cb8305a215aa63fbfaf6a67a2534a4930ba13580108f499cbad75a965fc4c895c947cd63555904a0b3c9f5cb7b2a02a2933aa994484cc20fbee50782862cabebcf72076eb8b40b73bbc82da4517e1abce88437264e20041db723df9fe6907bfbdc358a1781ed8006c135c1e9e22179df56c2c716d0b06961f2d36276322031d1185e5d1eca98f93e3fa60d673a6b48f6a96f36b5ab248b152d4d46052290fba19e1da412593470e16b26b518c2d1e678e0fc6200c7a4de33d505a91a3fcbd1e4efba3b9ae0b8fca9b667b3ea75fafb0cc2b231833245c58c0caf4051b1ead4f3f97db43bcec37348049cc43fe47441f0fc202c3bda76d74940535c3b9cecbd109ba7180a985ebcf1c8a33a8a97defd3192613eb24ae0ab68dc1b9ccf0eda0b224d385bf8e8400ccec08e7f419ce7ad7a9f021b713be752bf727f4a0c249cc827ed54138d12cf9a51d27e12f48092e3c7dec4ba504124da6fbb7906bb4c7d64884f57e134daeed1ff8e3e8cd2256eedd304fd8f8b73bb17bac085c1ed5c21de482093ac56bd856014ac023e4eb09ed33a6a51720ea3368bc34f2449d75fca5b0529fc72e2f41406b6356d374cc3509ce0f962800e92fd3da77237830622b3070dc4a335a7ecd58bb39fa37fbd4f557a3d1e38db4218ff74d6bd147ad5ce97fefce55d5d9521dab60478c10cb7ce0d8ce54bf946fc84e6f6abf52db4b2fd1ee5b53e195ba6d1c36daff2b3c75f90b0f3aa6c1a27c4ec6793dcd129acfea735ecbbca978996968c104d3999eb25780a400e24472e26f0b78a4f42eb31bf4782df17cdbdf0ef0e52a151f837079d7f32693ceeed9a8cc8209e71d37f14130407c24a0093b86975471cc53ffcc8fbacdb981434edad59f15c6bd07b63b9380724f9378b55635780f7577b7106587fef037251a91c7f7d0413900bd1d630394b9ad58c46c456ed73c65598635a3454b88aacfc70c7257f6b015dfb9ee98ac5a440fe565a7e1692a05349565bfcef45215821e1988155d50d3df4a1a84fce5d058aafb056a67c35a0d9df20eefd8315e3cdc5bd37a39bb2b7fb3f7e13556c93f2b25c7fbb5a235095e4a79c5d152a371785f2c1d58112f8b0f373ef48e505fb073d14b1f8893f1410809e51d6d9ca02bb6e538e313f62508f12950e8630ab4f8ccf36be79aa5929904bc8399207ccd79db7b22f1b359a44e5db5bd7d1d2d08ef490c5f6516b7d26b7077223c94ae2be6cda8b43f93835af806ca294fd7d7b23e5ecbec5b0dadff31979d4d43d959d9d09bafad6276b2f6ed37a02cec375364bd9f998315ed04e912a62d73c2e3165d016b627731e5b5af91298531c9ee3a8d675df6a7a45ce45e15269719a1ef130f3e02e33853324bb76562acbbada4b71cf631dc420ddea0ca3e77f92340345f448e72733f731520cb6093b5bacb0291871d041a78cff9dfc67a7f447d5f42077197258f04415aa58e69caa445871b7b27f33311868a8b7c8da6e07777dc292ec5a351aee4c4ffb67d2a166963150dd4e34740d0476c254e3f787cbc4b8a39758e3283c41186973b1f38f1db43b12381a232ca1556c4560add3742117d7dc7617998a3eaae41c24281e2d2ac4b9c15c01e879da95856b03b8ac5b974bad0aec5150d248b32cfdd1c38697d44b5775083364f9ddab9d00db26a1684d31cbbdd9915f04fc2fe9c556ce989ffe4c09ab16e5ae1a2ba765bacb8840aa89711884cb81bf98a51df303e5ebe253a7538e904c483074f8a8250a5e5b061c4e1af2fee8fbe5260da93bb962c30321f7e2956249f541af7a887d32510977051c05a40c2a902c1d464c372db869fe519ff3e9265e2afb7a658e55562d9e4c36efa102cc71648ef6a1a038c65aec414f96db2937057d3cda8699b18c06107b648033173dd269f5b0555e93f7fe560cc3e98b459a3a70b59e4857157555615937a8df84c8b27e8d2d86c1a583942d3f61b082bbe2521cb0db428aec92c5e4f18d86b099ef9ead0efacaadb5ede06cba8d70e438756691db050ed01c116949e4c866b7378f89a8d7c36ed1572eeee629c7480e4a030deea4927e4ceab900031fc06d89ab34c285b14c1c4858bd822728e88ca0e49a5d1777581b249e8ccabe779acec0c75f6a5d6b0b4ca874eac1b3fbe6e3be6aa79291351dd3b7a9a344dd717d407fcd2d791d45c875bc3bcea11a80208c9c294508d3045d0a600e18ea16979bf3fde336e8a9dfff3906c702c0ad199caaae9f99f95bcbcd3f4ec44a374f14f8b59aabbebcb0f8e9585238c992810bd43f12130c1c692afdc7e8f9f648f62385a9e6dc637d9ab30630e96bd859a68900855923bb0b15fb0e99a78aaac71d2f2dcef9ccbe261ce0f61b40f74087b046121572010cfe48fc1ad7a76df21d2817d944260ecef1d7862ea0d6547cee321c9f5bf2f01dab50db86f74ba9d3131f24aefd6bf08f7366bd1ddce68f048aa4b83813eaba82e2d1e09d492083fb311e5723d749b1f149f79c9725b709cbffa282c325f7b015b790ed933313923a71bd16b202bf8ef6881157ba376094cde78a4fa1b58571ccf2dcaf18998095cd76b7f100493899a7c10cd8811d26f3c1dcf813ab1916b01d0e8b34dcc6c3107292341266762d25007e2150e590b41fa1b4d94195c63a9920dc5ba9463bc31497a22245f1d9e1b1e10844f04258cb5b0ddfe32b1873d79ec8776b2db2263edf79215a91f9b4bfc2fa6036055f8a40e9387df00273491d9e0a25093c5fa45bbc80abdc2ff9adddbc81883974fe4b75de2fb2d6d977f5cb0deb082df063d47d4a1b119ac2469d68eb52d74850b72d6f89342f4b2d8d1fba71f54693c84c741102138243691c3df3340450c59856d5c2e8645dfe094d71a8ecae94ef3f000fdfd9a50402709bce3fe4b043afce18a9474c05a161ea23200f87dab018cd7c6422f74b3cfcee65ebc5b41a598299ef01277b2ba81822e1adf6563dc49f0d17934566999029214987b2268ccb825afb31a50554c83acb75fbea88b87bc4ba86938cd1ca4cca44366c6332771adf63210d5606f7b4a08f5bbde85a4801b9b12046a848056f5421a981bb448cae2949e99ec9a36970f04154339c7d75f64cc647ea91f87031ed9d3b4bd87aab59523f0b6349f59d6708148aebb51fb77156b194e0e3064a66cdf2987b981ff21ec09706c316d8135cd7c724b79bc260f99711307af29dcbf3c194fa8bf9da2eae6211131e0385cac16dad4620ba1e2e96dc4b4b85c8223603b8c327a4e58912dee22067f6edb4b85c706b9d07154e7ffe7332c1ed3dae6642cbd436df91bee95df3af30366ed95365c13cf2ef05d1721b47630624f649dbb7fda1ac0696def0290b6133965bf37bd5935b7ee8545b70c0e49d195c1b24cf91ccbee31c1e8cd19214bc14500f279743365ee30b485fe9629ffa60ec820a2a1f604338a6ab20b19ab52bf629fc1ed0844bf06b197b71a7bcbddee55d7d7e141e44f42a74052f80f57cca28f16313a4ddd9b7e9f6964659aeb308f515a6a57431cd47b790309916e8bd42f8f914680c12d07970b81ada209a5cbca9fb8d92f59c13b821b520086ccb8b043fee5f61854356abdc25d5e9f6b298203b8065c9804a1a4c38b1c006a09d90c2953275e15ce214624057a82a1354af209357003bce77235dac86f10c7f66e15b8ab2bd62a999c415e344e8097d039a71837bc822f3903ffc453bec5f2a1a66372aed73b64af93f9b6d675b66389ab8f8b75534eb2947601b9930f77062b8a0b44446dc71c214f63c9a05f31d12d6aaef757a5dc14d7968924c1e63478fdc52a8dc834d97a266ec68f178ebfb0aaea2db129483d98d16e7542ecc00cbf35da64f47259ceefe946777e01935c1ac06dd1ffb0d0ceabae5d2169515a8ad8aa8b05d9496b3c87e09871fb5534ba546bc2754af00412128d945498fc90d8dd9dd43ab2bd494c43ee3756cf92a496e32e1c2293d1e1eda207781c4d920cb2ce038b22cc7fd8eca4e7aa92404c3f6200e94ef8712136c1fbbe73f5c2baa88f76ac4259d27be5b1c84001a84fdae7c3c502b6a7a3e1d412978a197e67c9dddc999381f1bd141f7e4e5bd797a990c6b41cee9656215bf74c3f00545e3ecfabba12d70e2b52f60997dccd5000a0867f84294b6c677f303db28c93722800b179f3812db332caee512bf5444a718f9a09cf955dfda0c5a36c66c82b7ed2e9a27817ed90d22f626465bca9d188ea9a2a70ea58b81f6ea9d43d1a1caf1d5fd7003dc88a8d6405a06b585dd3732055a0499f8d88783cc94131aa7202b1bd36bb9280025bd2abf8eeeea8cadce1536a4e7c4836fec7c5aa8f294815e7e6655a789643db41dccb01e97d3c27d90cbcdfb8f2fd8c665e821681e751a1cadc28c64adc19147aa578db4e88919f0a5eabd489da189057323b76640d2e947284196341c97314ff7d5e54737099f70cbce2f8e77f4db0430b14dbeb95d153963575090af8c9abb0fe248073e272320f2257e23eac7432402c44914e9d78a19ab743dc1ec812bc30771bffd120f8d76cfa018732df00007b3e437b942d3b9423d3d857e08281fff54fd1cb212f4523841d13e5a4a1716aa87a0e6d6ac28a3dae3c6f9fd1d46de68ca5b1bd71257f2b9b994d081d1d6935b93b505560cf0f53e3ef450a3e4fb97da71c19bff4534ed0e7f373279b257bfddcf387db51baef307f090844b79601587966a2073b0d7d400c8d441e38d1c6962aac598e1822b51cd777ab41d0c7624ef5f6166027a5308e109b872026c8328dd5e60a722f5a31937e17de66a9795544441fd9b7db8328a9ccde0649e8af407143195e404d354af3facb820c134d07a7d6c081471876134031d00d9a494bc04b984e25c6ccaddc7a19dcdc7345db09ac05732adf90e284efe4cb31103d3b9cc3e798efa0dc69b4d094bae5e26be7499565d7ce0baf2b8e137644300d8cb571c19bcbe306076efebebc80463c171bcc967b61c9c014cd15e4f6e2e6e24bc8f5a65e8593c09449626147ccaadd209c2e7a3da5119b305ecd1c0701020b74f81a529cb1b6cc936f2fd5a0ad7cfa5ee4ac444ccda67df772ed863de8f773f67cee472ffa7d2d87029ebbd4d038f2bf667da69e78504a7317ebab48e6a280a6e1eeb9a56e11f7909056f886e21bb7eac3a916c969452ce9df8f6f6327aafd1b94aa5adc7146878088f685a54041401d791f3f9bdab6272229e62a4d09797171e6fa5c2123630c29f894e78c8cddbe1302ee4dcfa2582c6cebeee5456c2eea7f709105eaa1e1332b7e00fbfd039f6f31f57db81742503da36163d090c0c7187b879f2279d5a3547e2618b6e905476f57b0780de9531fb4896312f18a0ff87ff786ac2ba09e305698adbc8f22a3942f3ccc09852e5ac913a7afd3a7c5982bd882807f7162005a463cf8eb4de976db3ad2797001c87e4bac3c695e0b435b3422eb724a9521f884f9eb0044c86eb20ffe4f9045fda708f675fabb9c5795ac49d12d0d310b5b9dc0fbbd94734a7382daf8a0d9cb36bcb7e58fed0ad1477c0260d498a30219cf95c4b79a810cc41124c2adedb0d68cc599952dac4e1146390199e050d870df03c84db7c18c5c7c8203cb1df953d233237c0d0b817982c6794c2e6120fa5903dfa4d980aeec3906d9b1e58fa3e603df122dd89d87b35451eae7c5d7cecfdcd639138bb67723bd1bc4da143255b437965b2411982ff7e3016febc80ea38da415cab59de4c8e6733dee447a6cbc39f8139211766b210bec5be6ec9baa8990b6e9be48fe2d14e586fdbff0b26187eb4b0fda55fdd66c85d740d9299176b95e44145066c09dd24aae8bed74ac6010447a798141666a56c737979bf8314629184befd974e747ed7396bf7e2ce1efa82e665c9c010f06ba24f11c20b54728b8be3bf82dcddb38d2f2ae9e38f635ac958d00bdadd56d5957c01d4e5a0f5d1f01c0a7ae2eb96329690e7021a221be5839cfe9604feeba00f97db825d36b4a6ac220575291d8c137340a7b9ce46e367550025ae5e52dd596a6502249f72dbd4cabcee8f7cca0bec504f67d3480b9506b709cee6c9c2bc2cd87f3554e89ad797052508837097158baaa2fbab0b77e9efecf0868c3a0604d4f16cb0b58ef9575891dae6b1ee8f48569dc8fee23fb26ba564cd4eecd05d6718720c1bb9351514156ea72e89f3f77b8b8e16bff9e36fd123b27ad648430796c74dbf4d8dde80946ceb44ef2d7c553bf12043f54570f2e0a5914b1d12878a620f63416a69ab97f40ffacfbbb5f156170c00a002ec93c611a9ce643109753c881aa347e8e23c247082c1d850458d1011e6a18d12e8dc1feb8155845dd67f6e1ed53d79edfd2bd3035745efb98b9a9ec74b6bce46cae3aa5b1b636e19b2bc28ba2c8bfa67bc7ef875b51ef4e261d8e246583b550c9d2bfa1aebe22294b66709783fcfb42ec5221033e10b87a32680fd3cc81ba246b98c280b36532ea12b8ce0987774fe13eb79ffe45f00bbb9c5d875a70be65ddaeb0189ac6c3d7dcca2dc52b4a28b35aff9abe9e37b4697a47e7e1f45a061c8eeb6b09014bba57b23763ead7cb44295e897b8c45df21893f89d26fc80f65259f884be2f41d1ad0367a36ec1aad118c5eef783bfcc91d7fea8f1b9e7c5ea65e45aa10320b23cdddd773137367510760509aea5c35c912b2cfad1b28104f1d713aab794e6dbc649534537f3e322bbc56859e217afbcc1fb96c1cf76a091b83a0839a19e34e766923c687b8661d322d8145cf30a4ce861f50bafc2c8f5b1274cf574e09bb5709f624686ca7c8d306832be48244187167790107814d0a4ecca483e8d51245bdf2fa475bb0bd2cf684cad8ef7ce0a2f0064d91c0973e45f2916137ba2f28af6cb2452612bcbb7b338df22cf73986d1eeabe686bc0856771c25a4ca74213e0c9f51cdbd7332ccfd57a14a9f1730dbd302eb755c677db8f1296a51cacc2037aa2cef31540fa9bff8bd7427e432bfb772f66e2f9f6e32b3f98463622ff61a71e1d5c456096f2966c279a5c016ba5c681c785ff30839e55d04e48dd7e59be05302ef921f45e4a529ff1d24861f72023758a8f0e4ae916a2b0cd07d795ae62042344d1703180dc461a3f72a1974314ba37fcdfdcef8792b4bf656d4c9fa74029bd5e54af423b14587ce4e106836dfadda29108bf92f1b34f757b0d6becc6ec48fba8d06e51c342aa2fb988fef51c71e0c35c09a1a7326d39c7210ee328dc787646fcb218024827e936dacac18e893780177cad42759eba8a073c801fbc2f05360b8d01efe8efb6c2d8d9e354569d287272d7a5cbb37efb50ac9be857b27cba2a943ef3c9abe5a5ac44448291fc9462ca13d4cab1a49278e9ab1dc219eef6583d418665b312365df76da71c2d6362bcc3f669232cc7e2ce6fbd37aea7ee29cc4e381fb09dcc6c1342cb41aac2dd8ab9b6f97e4a02809d0df37eb6290e2f99b84022fc307e9131b93c7652d02701df9d37b9ae78fdebd17df9c2293834d66044fdf96e8d46927fa38609c28fff344aa2eae3eda157c82842f7dfb80888009ad9b9c93aecd28fb598645ea4a3320a1f7966fa4d7940ac558f58615a44c73fdf0c4690c93a8610a82533c62a209d92f2bd1d828a710f654e9b25b431d2a9ae8d0df7a059ecd0e8f08c1b15425183a50d107164145983d5fff368f8bd4ab65baaa9ebb6ded196c29cfdef6c137ff38b8b69c1a348360fecae25652b8d6a2b64f435075e7356132078583b2ef4e3c553b51852ce9ec1b96e26648903f3e6515951ea501245a5c0ca9b77e694fff2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
