<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a0b42ecd088f412373ac18eb645305ed0aac1383d2e3f334900be0981530c6fa6abacdbc9a80c91ed34e1972e25d844b0a83cf9b30c3801fe516695332e1c1efd7287477160d941338c3c30c88a624addac95e70936b61a0c93a4bef74eb3a55b23f9b34a1e6f384ee196844f9f4965e557c70c3c838a915e5d4d3d0efa33b5e889a969e641100cbead77070cb9c5786b1293ff16dec3f29f80f7c26e17a72cce0c584eab2231931ab7e397dd639fd1b319204c12d5d943e581c857b94b8d4fa51dac186b949ed2a291484fbf2a1ded42f8156ec609aa52a69f10a725bae03063fd2f65881fbb01db0c879ee0d9e6ec1901fd8d507c53400700edecb5e4826f62f90858a94284b461cff843d15a8166b3449f502d4698f099611fb2e485c8bff1aa1f79a530bc5186aa14050fcfd0d33248645aff0cd78a95e9aec79f6e8f06090c4e666427d4f2ca58b6ca6d3465078f8d85ce32d401ae87030673411d07040315171c3e1dc8f301334f647c9068a3c21dcda37274175307a9ddc6954d73772ab0243db7d860c7773a7f2650359e439c7b294b9eeb8fba1cc60822354ab15a5a90d31693867ca9622868dca6d17894db01e546c1aa57f460ae29cd34d6c637ef4b3ed6475f7e1408dc910c7f4d27e9e2f08c02332a044aa755062a3004dbffee811fe21d931c420866a71b5a8b6720a8bf83adddb093711580c3dcc76da856c51eed1ccc43a45fd26d9d2f99759fa312bf25e64dda0c7b2a4474c88e0026092b6130e13d1d1641100eb6dff34bf9a00f4401623ad0f2e9e7629b94f25e70a3e2a4adff71d12dfe953ec2fab244ddeb8401d73d08cf1a7a10112fe2c51008b6568ddb2dc470e7cecd80e0cc32bb876232d8752cba11f7776d174312194d41c57ce959628eddbcebecd772dc5c0235b5b2d2f1e82494a6d5d753ef375631c6c62f35fac707c9bdd89c74b7bf0aa0111afca7a95c9b9aa21c6098d6c0ef36fd757c292a44a6279462ad9086376389d14080ac1c52cf9c2f3565c2b939e9b8057abd049cf036a15189a3dc3840619a88a736f724f025a9d8dfd147e2c17968da94a6e513ba30a2645555f1621916c52d2bb90b5dd9338ae4ab2251708e45f38766e35df1c0f00d73cefddf751f24b548784aa652523d6b13d4833ed75004f808689f34f94415c40aec497045a095f9e2a629167562d7dfb53df684c0f5576c4398476f19da5447b2bd653aea3f8c0da906646a9772f00ea4975bfa740088cee264da1091038d646e5552a7af49b51f230fd717e8b0101c119a98efd9e7a4cae9b01a10863e01e0918022817b389ef76cbe639dd7d6d2fea9ddd898d4c39ddae8a9143391ef2ed2bcbc5ce51e05ab3ce94d2846cc098c15fa389ad2246ef7dca8746cedba24fba843647c02a9c351ac485c159cca1088fa7a4963dc7c0c47f94a8e66f27753c5997a494ae23387fb92602ef915c53f13548d7e7e261fe03055bf25bb4703f84a95cb72796a8bc543ae8cbb25528eaaf939f2f62f2530c0a41312fc0fc7851dad57d48606d786d7c2bf10db35fe705f6e1167174be33d783dfd48a759a1a0425006c4bbbeb5a78c1ddad88bbb84d5f43f3412d9f850914c78fb62c4bda03fc451ab4e3206a4db7311ce33186119ca96068f877700d8631687191293c1755bb511ce332951a6349059ccc6bc285e9a36b0a2f0521bf5da87d482dcf542d4fd281fde3cd3dad68bdd4fbe80c1c5d6d870fffe69e3fe88313b0bd387e1cfdcdafeabc1b34162b056843fa8783f100becbc36d37cf7c32a458fbdcccb70489b6951affacfba6f5bbf7bfcfc92dc20ed68a6fa8bddcb9a42c3e500e92e3b7d125feca183cc4f1720a1f2d885e52161947de7ecec93bd84b8e2b9f92a6011304490c8bb0a26f080eab1cbdb32082114bc685409957995a671aacf5e9ec4fc2891ef6516041eec46b3c643d1a71ab1af214af34886bd372199094155ec6a9f727e586149fba057a277ddfa7cd7d40e55e951e7e0114e1cf744c12fc5a26c67bde812bcd600f7ebad6ac86ff24c503ce283bf5f95347c3401be708039156f7d4145b3fbb11069cfbecdd19cb3ee672fc656f274524023ec7de2a705cb7d054f725de457812802b5ceed004fa948139e6160d5757241654d5b74063ea98b1f06aa99c33ed821249a65ba7f599c5fd6702728f170af5ff4d17b893544ee0927be424e149632b87134b64e0f821a976a8aca9fc0c2d39ea510f32f4af1c27af299aca5f87a65a69285c779dcf2639366d0fe1ee61883836afc62b6bc2fcc06efc3530a7f28f8055b758f1269c50be609140586491bd0ecd172253737d67d6d944805c454d0b3d93efd15a3a7a04d365bc0d7a707869682fde0bbd29276187ea9db1f446bb63665b3071c2a475b3ae6e2ee042e856d63cbada4ede4b8341b6ccfaee2343c98c5ab97b13608500df0fc03f2ed021a74d65fa70e7fce7a94db4b09461b096a215924d17d3196a37743b176c6d34f96d94417387bd35773101d9317b99935a4155531cc9f476003b3d368cd024b32f94bc401e2e33eba94895a93ea0bd0f65e480e1b1dde93e5e82633e597605f5ff98d4915c88800bdac1d5986565762e3ca2605159a297e176573a41ef94ac81a7e8664c3291142f909727642999e88878d0e8b31e22644ba73a608b62d2aac616d27c435a1b9af26b227e8a5643e9bd657958a4dcfe79f2cf85d8694d2458faa4b460d37b5b67119f7986e05bbc6d866b3cb3c52ee93be3f8a6a92ad4c03f3204305b3fd3be5815eda1de74712a3af8243e5026340c968155812fe77f65db4b7734a0bed509951249a1ca8fb16bf88ad2bbded1418b710bd8da42713e7f3f5a6ff89f49dbe6b506efba12d8ba4064837b790c2e20c3acecab179f76749f2958769401c02000f8d4769c68f5fb9d77abb9eccf45dafdb968e03a11b038b5ac6cdde4cb81373591f519667876bd89846fae82a1218410e5f64db1ef31effd9d193b0d4659c1f6a50143c7879243bbeb67dfd7456bd7b0b1896e03dbac6fbe611b09ef8feddb8c419eb29e3ffe8e6a2c24fb84a32afbfb80954e24bb13b8493c7e0cbdcc1fb768a0a8389d5116f596aa00ab53e023ec074969db9bca7889af9ea009724b416fc35aa5380dbf77186f810989352934c5c2a74c17fea1c2d8e66d4a5fe8d77c5a6649f06236d3fe4c0fbfbb6f1fda89def68b658d8ce8f129fbada6cc7e4ca02e0102df4385e87d7d99aee744f9ba4f3e6eae647d23ccc79d79a8471ae81b4957cbc3bd64aa08098bcb9e003a5a7139343fb5f5249bdba3941817b7b2a151e91dfc3ebfdb665bc6761c02a4149833c89d3a839f9b1f4a3ef9ee89bc7ca0234421b5991d0bc2947380d646313c5491b95387ac9c364cdd2fc05dcd5d27843a80b67803f2db54d206549ba770a0d2afc4cf01e0805a0e3b538a73c4073911443473b61031ac2ab7cd6377108b05c6d975c38968c9a7d966f2afa260d1353947c1b64e854a5fb72d602a09ce5c18850d35c7bf0ac127512707023844e4a8420200e1d19095202383e351be86921f12aa989bcd3cd87ba956e2afd8017092c731efd1520c78058c1ede330da8299f398cc36f1305f27566bb4bb451aa1114d0179a89ac210d0a310f3f39d1f205c0daac8ff9b578ce00a02dfbbcc43270fd3c7b556c9b4286f18beb3c854a5c187de892c05396a37585b21c13955cea1069925c527395e5af004af64d3163d4a7a5fcc46e80c88e647f029e948c9f6106b2ca5d2c04c1493530da4020a92730d3b5b127a9de9e8589b49d26f68d8b417e17446b0c45c376f312c705dd86da39fa15172d37c751413dc186189b6939a14845a28f21eb9841a3c8070de58ed8a40e71d29fc13517097c3c3c1e9c3253bfe4acf53c1b0fc3a214c07f6acb81586fc9589a3248f9be769d8d87e0590d6128c229be02ffeb7d292d75e12a203b2097798851dfbe59175ee8abfd2c92243c5ec698d0f5513f721e6ca58f6ca9526998f39cd1b314ef44e291d772b2a5b4b51ad770d4852f81d784cdb994e77d15e896fc5bf2dc21a265ffe096d9bd4ceb4251fae0b381935c9c2b053801819c51efbd0aabffcf9bac11eca30cb62df606e63853407c33ee894a875954fae6818103fdd83196553df559234622cea78f5cf57b6f1d9b80532af81b0c610036a67d59fdae1f534da6c5f7dd81bcd09050b573028cc99dc4e352f8946df6b4562aeeb8a199abcac510f694d7cca1540f422df68213b5de1b17c9577d4887f86ffbe0bddf242de657d7fb92239f75ec1df3e6baca35d04321faf4b1fd062083e0b72bf10f5d6c2d879505e83946f71e57978994b015555ffe324744685fd4f485b0ab9604c6e5bcb9a4975ccfa2d0bb2df22a4ee58cbe5408577eff171804c2deec72caecd1a0e2b7a7b06ef4d3cd1124b8d584d058d086e5f7d42c1a94481a22be94bbc52c3ddd23f14aa61a59e6f4362aa097bd0fe2ce4fcc67c5a6b9ab705239dd9f3b47376c24e30d5fc520deeac204d1de63e66e02dbd16850077fc85b0b54c32ea662dbc52190de5072c8a46385447a151e739e1ffa8eda37ffda1907b4d60e307c4ffeeedb3b60a8fca17a46ac3465c4fe951466d596c2baba90b477ec95554aaa39605424c471e9b4ecbb694aac9c6df3fdbdcdf2a6da8289ef3ac7fd0f45e88593a9302c1b0759f56c24fd5c70e7205526f712f639364dab2a19e6ac454cca9bb1c33c7e1515a2fcbc7b3a841957340313ae3ac59ec49b44be93a122a204bd314451e91fabb0b3ec88ded40b771d3df20fda8c855441d4fe6a590d87cff84bdc9dac4986e75782f32f683ae85fd7e4ea3ed8c157e66a9f64c4b02520334e024d66aad604a7f999828658ef37705cb0085c900ed094795cd258b296cfb8980878fd2f7bf6ff77ed9a252d211878078c1ae4ee9b7530d1675ec571e9519c02810967dbc353cd740be3a3fe0beba0d66380a91ded316aad18a6f096817edfcf39d6285b3d89ba10e969ce6bb465a0f95d8dfe23dcc2e4eaedfd5cfc7dfc8a7609050369e9831692bf8af4eedbd2933cf33403ea92d25d71c0ea6fe49ad687f5b2411602f3a4a4c7a3c6880b5b5c3b18b69a8e7ce8baac803cdc34190e44513c7bad3c9e9477096b926be74e16376d858a9603df76b7a96f1753e8bb3c332b872985494ccfc654b3e0d0e48e4159c66c7d0992a391085e41c2729c7eb949673e791a1bac691710a05b05aa85b88cb9d88ff9e0e60f02ad9ff6df5bb87ff05b35db2fd5fb4975cf6936475b4dde73e4a9b1b720b92c8726baff711aeb4f86ace9857d7f6307fbbebdbc26ceeebf160511bb96257ac497e2fd4da9e010657449c76be5e6a7628ad21c02ab72ddf141b653d08b154840c85a5aedf977e7384beefa7f1d6af6fcf5875a7d651ba11d3db2eb93c61882dcc159d648e453c7100d3e2dcff70d16709001cd9cc87c6b33b8170b43ef891a783639e7944dcaac3038483f461caf6297c0d9d9705a214b86174126ca667f16f9cf7a8cd3ddafede1834cb3b754874d7b58a19faeec0716101a9658492e687553eba84ed9ca95797f438cdb5ca64bc129d26344da3202b5805c109271dec0e84a7f00c99f4f5f4cf9dc73f03a85a10449e5a0235ab5340d035678823653f2a30b9f12975a807d06c5bc629d93d4dbf767ef136a3b24bfb51037d5d4bad15cb0af1bbed794ebb1a2edd16d43a321d04b04e5a21c08cb14a876ca748b3a64310c33088c6ae7937c1601234b5ddcd9c7bc3699a548b89f2e9ce144e538dd767f690492578270a4c4276b69934de9286cb0ed5ce589e063923b59df7c9f8cfd9c696e48befba258b2715d45577b6571cfdcce8cbcbd96cf238753f14147e3d3a9f6df4700639888c99d988e903982653110f6f601ddad31abff194d0d85c2e4edabe6f79141cf7c4cfc1323f8d3f64c63b530f34637efc1b8ad3fd65a890f49b24459a92d9f2f164ec064efbf3457b23dc74defab46734243fb5b653fc49d8659fdbb011b58dfbc91fdd320ffbd4e6f72ae9b43c0165c59a8da2e6cc7d26348856c4e0b0297ed1938b50c83f493da4a5d99279c20dcef99398f5adf1de7dd243ceb1bbe10c078b4a08fa7a3f4eb49ad3a6bfcdfe3ef1fafc0a4faddc0c6b4c776e848b6cc3af7ba94d86861d93d15499447e9618ee3bdd79a30eef3cdce8d4ff2412d8a23750f57662c55dbd5a80f10acc504774a007fc785dbfe310681fb5cd5ef394d3ed61c17598ef8bdaac87ef75c014817f398578a186338cb80b63146d6984b1f77eb159d7cb10c9aee4b70ff48987a62ac1f98333b3e61d6a9207765beb2b3498232c989c3eef331966cffd1f49588d9d91aafb91303fa8f710e3c9eb4a89663bda29c5108c6b57afa1d24e69852d076f32c57be1b9a70bdae8f1d26ffc892a314b6ca2d47bd1005949423bfeefcc94255ffc47237862daf295127903511addb8ef60641f45ec610ce753dc39ebfbcfb93255214b418b69663a06866f8245e44af115bd2b92c95c67b844bc7f1eb2e101cc0d61dd5ad7a53980a867c1d32da79d9a9825ec04d0947b14e267599ac444118e21cc7b6d45a28f9977972628a727a594d518ffe64fa42f47e8cbecf033995fb5e208b935cc99ae915f06d23b5dc92e62dcd5acdb044a4757315ffa6843ccf479869db0de2653108131fdfefa8fe9c420da87db11aa64bd4643fbb2deb237e4a6f4ee451114aba47c5eded1a16d139044f8d6b0d370cefd60af1317556f7e2f36e2201a2ca9fe869231da71523be1bbad00cb96146c00898e6b0ca8f87464f951a64af4ba3269bdfbffcb357b0630c2682d3fd625ebd18315a262de0de05649b8aff5ba959158d82728f58affd5ce68548d3fbcb646b7154036e2fc405c8fc54ff98ec5788a78cb8d560864f34eaef86f998a82cac0f2107e9531ed17bf8bb9014281008e1a3ea17d40e240e08a34a0daccfd836ce9232ef8c2bfbb9c0403851014cff591e20e116c63a5e1e4d0e474cb0cd0293de324d06a048cdd3a97646a66ffa0223b3f02b6ba59f36123476c3855bcea6f0bb016f5a37e188388d4ec2bfcdb1903b0954d6b775fb408bd72986f1a5abf3f25c8c28ee48967b891cbe4e0029c1f895c230f6eab740c2ab6607ec64f8b7e5d5c12392dd4335e196f6755d2d19e01cbb7764915ee93ea415095f1fc78fa48f9713e575a8198c8a791257ee5468b9535770a2d36f4515b271083cb852367d08956007bacfccaf1dbecb1047e92a9a04e64280cae7499d42a54cf11c517d5dd4a4bcb5d0f46876377b15609c9cb442128614f4310157f28600f5286f76dedbd2c081122279836d0b9f454b2d7e1585f36a6aeb648d4f5f93145f269b0c278a280dd3d3c17be0eff123368bf3774049edffd23eaec96bf68cddf3a9ac04ce9e053a82add3db7a87fe713cf2cfb831d57812b715e52ad9f287a3cea51924c678d794658f60d791b57f39f33ce0a24ecb165f54853cc5ba1a9eb0e30a247cee378c89f21af7c872191ba095f511032c8675cd95b30aef1a4309cd3b3355714fe53f1a6735fa4fdc54e1d9ac3922fd60bd2d449c9548d2bea7c2a5152edb35ea867f46eadced0cb66e33106096f06f108548c803303d5754aac65b5117b9da97f04b161dc3d9347e762e7309320cd27db06b55363a83f94039cd15a24443e9ef36a8ab614e3a8006da6ea15eeaaf2935c92155e807cefeeeb4dd8dc48266a46bd7aa3df723534b82fadb2681ee2a5f1f3608c6a8d4bf838097174baf8197663c1cd7086334787550ace443d6acddc5b117202d0efc72091f5a61b9c54386018a132c2ccc4875cf763e74839df88d1196c91cfd43759cef041ee43b8467b668247d4389c30b2ea67a399bbe71c02a0eb3b8c7148d93614329b8ab742ec6deed651621f0846aedce4727a13cef0b4ccdde2a7697ec7c102509a0a8cf3fe95afc2189961d3fd6b14b1a29c37939736517c5fc81311de2b70cfdd3398a1fd3d0f6649e9702dd7791e77b8c518c65db3b2ffd1ce330065c5e6c3518062d54adccbe2d685f124afee8fa4f8ecc715b8a0e846aa7c6e0e5ef9ea5e0a933380e64350b1e3e7fad2be08a9c5363b869422cafa3c2dc49041a3eef93b73afac3f529193e77e3180ad6e10b5fa6a7836238161dbc0735d9e9e7aa17023f5e42ab10579be84bebe0b87763b03ff211e2eb3bada87f810a06412455ddb8b4a24ec80c53eace8f9b573b65fce422ef12068d6cec25bb80d0f7c9f50dd83eef18714a2167f708d3bd9323b9973aa13b6b187b28473ac151804b307ddef656a3d91b9482ab746a578640c4782d11551e9d8946ddf3f7d89b4ba4d09395257d2b1f69151e487f536a322e8f8b0cd98579ad339eb844250b6cdd48b053e508349a73e4dbe4e1cbf8b42fdb7f1d4062ad8f6d51ab4cee0f5e126edd9878707df71695ffc13de24b1af22bd9b2889a10ae6d6a4815df562e764322121eb96fc7f738fa3aeaa60300154b1ca1d796e20e7084546f4e7c5b8a146b5609e7f88a369c74a7dc716ee731a3965f663bf12bd7ec76db3d2262e4515e7c532e9134edf5b3b1b41e9b34bd2cc34fb4097c55727d079fdf0d1f7548317ddef376530689d03bcbb3390fed055657b4efa13e93a0db9e9e17bd3d45b32ce27c2565161d7128f3e62f8b64b4300850e5f7ff0dc429a45c45a7d7e8754d467480399ffc54ec5e8ef2f9e679f0ca8a24d065659c24fd4184364131b95027ae8b652d277792bed461e17f77f10c49a026454013c638267e4a974302280c79427afa1948611504e9272676f53397ad4e1bfc191119853df3b4a6a57bfeb84e9fb4bd359c963a7f5189b02673e0cd0774be4e9bacac1eda1ded143a6526c763220ee25d069c2ceea6f463f9c9884efbe82456a6639e5517cc22e59cfc20f6e9080c6ac069b3c7fd2b7ca667f6336202c3a3ed6a05c2007114ae30b588845fd14a1110eddb585592a08552e07b0b7853f57752f7bae6690204f080adec831c9d2f3400f63f0bfafa8f2ff7bbe12a06c511443050469e34c499b4f72d92acdffa87857dedbb1648425b9262c8c6ead14e560791d8d108803b9bf4ae022e20646147ef2a7fb9840eb56d94e0ce9ae3a4a085a4fe9bef36476d37ab67dcc1a1eb803e5693e78bc1bb9313ddfbbc38a0a0c858a68d20bea4b8767cb039f2cb19fa861d53f8f3aa6837008421ea96184d5c85e789f3f4e5fc56107b2d8bf78fab9f1c703045d904721b54ab2e07f7c7fb32f92179f69dab67e7814cd40707965b92a0ce84ed27e7839f169ace07245882df4fc82ac2d4b1d16d126c8eeb729c6767ae7262248b510e62ee4901c4440887e7e7e1818b4a0c1389289a5d361d62b00cdd0dec5485eef43a2a9bcaf96c0582190e97eb37ce1ac47cd125652e748556320aff9d3e48cc7e9720d3d466aeca85b0490abf6f1da043e5c5a0f11bf6c487a8b76a51fbf9df5a7e28650b8c21ac6456ae4d9527173ce5e94a8d26270a6aa9b3af36f9b016df667b1a79c2e1c333fa7cba09983c53bdf0e5a8cbfff25b7d472656a3562fa08299566cb9a68e51656c64665ef61315b793d6cb8195c3728599b8eb480cdb4c62ea4584f5119fa61f75676e6d8bf655c8b29e3067abec941d7011e02ed599177aa208c6b8225f35ee58237bccdcfd9f3fbeedee567b40751f47749ef5fbd0848789c0885b9b8028551af9111b89f6b0940235f78d703975603207b51561565efa51f11cf278b734e5bcf86c40e010a8a7f3c32b33c1ae92d1994a889a05114b2e52467bc774e91f4a4e0a0bcd0463158f4412cd9643a70049e711ef846b1c963c72bc9da65ec40e69e7b021cb49dc148f07ddfe7ec0e58af2af41bcbc59d990a405d68edd3033dbba0d9aea32d1e918e40f192c4d450088a647ed14d47122812ec4860466263f7cfae7a7bf853376eb39b286bae75820270337296482c0fd784666b814e4e5a3af2e59ccea7eb66f176f93f3459065dc3bd5df122286f0e022464a9b2409689bc02c6d3027827f35518515025069203c6150549c3a91ed0e805725ed5bb1e0585f869927ae45dbda7e7fb072851ef969d636718fa5fe25759d5c6ae90b2a600547c5d3ab36005bc51ea8d94f56e52eb7a70e15ee3d28347d8e0aad213b20935bd34ed7829df9fe4239c5273b78f870ad45cd2436f550aad7575eb1074b3d44499a1463203de17e5d75eaba083e8059b1d8bd3e0c0a474121aadf2a42b30c88d98b44483409f8a153dc38c284ac62e3c24dc751cc5663c33903125dcb008dcf564bef2e6f357ce2b67c2abc6bc379150c55430130f8b497b2a5b8bbc4873b492591d6d3b8dd273b3f8e9963a6557649582b0dd0d6e47cb32ff134e88cab281d99ffcdb048f46f0231ac60bf5c324117da3578808c15544a258d6d64e25dcf0d26303120d9f4613f9c4c9c52e13347a3004b77b6553175034d1509c8eb8fb6f80199457be8e55944b5549f09eefd983930176810563b58a2f8584e3edf28f2c18fd1be2e8a54af020599b86d0f054be3b56bb8825798b74fa727ea05e5346eb22e52a7ec463bcdf1a8110cb2f40041ca14d04e60677eb3b277d21fd05016d1918c9334a9222d023fec20c9589b1b80e168ec3fe6f8faf0fe102b7e8190ccca6e2d5a292b8c6799cd7e1ea367b669db0fb0a9527176cd1fb9d88119a86ca23583900ba6a8ea7f93c611498b39379650a95b756778c7e447136163c22ed9074f2a2a3eeae162cc2af1d9370fb82ab2969c886247e5be4e7649ed96d917485441852ffee0ccb99a2712b869d2378de83f39392bd6ffaafe19fddc742316af18a94e3a5f632cfb97c9955b5566dc0cb7f868d9ce95e9e6c49839d522ac733cced8e8ce7968f9089fa1b1a4e33b978ed447a0dbf9319a16d75548683f82d574c64fb645022a78d54846085770476c634bc6b44993ce53aba4d56fb04d2779409adc057e9dfc7ce7bb625f52794c01e2c8ea3ce7eac5ebccba78efde5a78e53c92af02ed5f5f8ea15554d2b1022b31f78a902167e67d51a13dc1fdefb8826046b346a59a4c113e2c4a6ac4eb51c1ff4674474f34ac4e3cf0cf83570167630d84aff3e2232b14c06b5c92e48bcc9a7b3951715c7c31a1ca355f3a2b53160108f1529eeaa629b2218ebe8c961b0a46c502c5d13785c98f81e39a214939521269cd2c2e3f1fcb266b79323676c297f7b44bb996e86cc415a252d3e1b2aefd1d358d1d6fab4b7ad8e81fdd844c4c566cf1fefc6dc062fb5b378faeccce641f00204446d73df81c794c0c5c223571650782751d2af61704ce123b0eb4e599eac7015c80471c1375baf63563021da2c83ce2d369e09d882192b30d536c7b7514f477cda5a308266475696bed202d5a380e4d5ec6e47c96370ffcbba5b2841d8ee88f6c7a6d9c93ee3070951f8a75477be2af8416837ae9b80384822d8cc774090b90fe653c2700c2c4893f3a9e7d03701107d3f4567d9adac5ebbd319554f69f4c6a7b22a1d4cb1b352a107560de21532ab1f31119cdd742ed25a6a25f36e51441a25354867904a6d10f3141d289d52155c34ff3d85b1b4d0abb916bf38d524118bba7d55e1f9816ae2848b5c6adf912c03f316b7d9436d2dec58fff43a3fdd7b996d9af6e61d1f83a89860c536a4bef31071c45195626013ec1681f0451c8c1730f2f719d8136a2313163d5a6514ed45cc7b0b6074b5c948686a01ee3cce86356c7d1ecdacbf2ac2cdcb1b8311b42a3bc140575434fd24f440006df146a5dcbbe5524feb049a283b99ee1af9b43a20fc1ed67c32d0277da7e89ad5c06df128bf9ba9913a8dc49abbf3ad9c7492134cd0fc2b968cf651a84498015f12fee65c74bcf95257aa47c9c98b25625a8da7909fd2e29d05aea1e853728416a7ce47d64d199e8582077c8e3ec10f86a385bb362ec813d87476ff0041c0736ece88efe84d3a53959ee6e4622a4f72bbbf90f0e3781130c07eefdae3544d259d0897645eba3b5aa9795ad34f8e01b7239734adc671e8163fe5155d3dbc6bd0c10633f172809a0914c199469ea5a778ecbea311223bdcb641a0202ed42ff28485adbabce784a384b4917001cd1802adaa4d6c9da1886f8dc190c2ae971e3720e5da7335ef89332013222a3802ece82c2a91260be83ec6de2bd056e78e2906942be2a675edaec91e0763db7855ac69ed383e74eef4e3b1f0fab16c0a47d1ef12cbf27cafe16a5a40f9ed7f49e752cdbbd6bf0274e3013b573fa1b06338ab4ea57fd2d261341210248be13f14651744d1f96420c45de55571421f3b796d8afe063023c1159f019f37e2aef95dd5f61a769accf1e4bb181dd4445c6296600aed5687f2a109c8195e25518539210e185ce0908a861ce88077c82b55e15137a928cc6265965220ecd66ac5785cfeccb397998361c656488b2e714261e7bfacb49564a76c502c2519cfe6ce37bb7495ae84978116d42fe392f85cdd1631ead0188823a2dca7299832dadf18d6572dd07ba72b3df457805e97cea4cfe2ea963fb9fbfd9739b2d6b8400a8d57f45a5aaebef8c7e8598e2e980c386c0d307216f29aec2d38c6bc7c8aab20ef5f4662df4ad0d4f5932b47471abdb3f24f1bdc988cbe767e8466a8ac253d171fc29839be751441c51b1ed22163028d904d90e224a53bcf504ade62ab5142aee1d33cd12f2f90db3e7fdcdecb494e97917657eb238d2f723b4eba4c48b218a9a5a64ebbfd015744ff1531488db1f438b2a1b5117bd6b75e4efabe9d518302ad90d3fa31e53e651a00ae9454b8cad5c670605fa7c30a95881e9637b764ee1610eeddb37bc7a1f22144d883f788889353bdabcf0a2e5c2c222875420c38f460bc7a59885d9a73b92925ae72a25d32405771f1ded31c5e2f9777833503d624b468af86f0f132257e5132dd945172e4cfa1acd2012cfd3139f8025af447f030d4f07e77f40dbe34570aa8030c1c7959e8d765ef3b9eedd881b739af7bbc30ba766bcee0304a440d545189f8b74b412ae5da061580dc196df34353922efe8672807782159cdbd0bbedda492a3a679f6873ede75e503e808f2688ae8e0cfead98d2d9ffcd08d21acaaa8b988cfa2b305f3197a9655e6cfbceeeb6290be7c3b79e93f024f402039a4226c3ca87fa609aa86955d4aa105dd8e9eea30b8ab41ec33ec1850b9c7dd948cabf761a7abdd96534884678ae120efced8bcd528f183c47519f3d2055ddd9a8e3556c071564a1b8ab05c33a66689412f38dfd6ef1b7a45f9155fde85be09684f49f24891bd411b4b592c4a60d32b1e4dd7cff9535ca45a255bc04a2647a91ee09a48f4e99faf67753934793cc691fdd94de9c82132e5d7fa741d242f97354aaf8f7d85609b29a0f90aae8ea915c928b44ea591ad05a2007e92b77a184e6c3a498ad01718c99eaee8c5194d7eaa3d18e77a6f22719dfdf5f928dfdd585e2361ac045259b579ae87c3a43ec8ef57e0d3c0676e520d596b1386181edd75abaa2b868118207180e8a3f9dca6dc4ad1325d73919546f7fdd87241329dd854cf3be606b6e970e3b2a45d27f26d226dec98b6d6bfc7008874275e12f3bb3d4bae8526e8465b35d4ba85116c0d16f888e4302a46bb7fb1070c44646b30b580c121b8b1f53bfd237337b33a7a81a495a84144431da57c6ddb5fc50a37c96b9b0247b8b0d4f5959593a9a7454d39b30ffa6650dabb5e3ed5b596e408bc6596ebafb90b01ed1c7df1649729c6336463f655c7fb8fb47aa2f17f73b69206a06d7d47af4d02a481a4abb0c766b121d6f58ea183039a4f61b7edb0b68bf34d762436adb11af8fe3b560899645c87d71e16d717b0d2d7f7303e4a6a9ef75a39d3039ecce65b32dcb0c58dee9d90423308c5c950cd87c465097c82fe325e7ff21222f2da4c2f9c0de595ef3664fa2e3a8024742c85963092c0118271bbe294854661085a5d9018bb4f1e874fda44af242ab7ef97a49163584b9c029187cf099107fac2b40e5b9eefdfb2e29e163af461cba7cd4966733183dcbeac333b60ad57833ce7581755f1bcb8117d56d4999b086a8de0af0b586fd16debd71fcc1c605b86d563a1ecfd7cb561f2e48f7b9289dc4f7c5a50bb914f04734964a70f9e5f7592e44f05d2af5dbd8fa6504d0c8ba86bcf97cb5771a76cf2da77a3c234ae8663c334508b0362452f34889cba42138b38811f34ad0ba9b15f7a81e91f63448ac39d667cd344f58b7bcb70a1eb1909a79170636b6b51540eab74e9be338d03f149b9d1112184ce55b6cfce63de9ab6f1a81b65a49de9f717e0ffd4d46751d78c3c5bcafaac47c2cb1c555dddeb1402e8dd9c5a678381b7f316ecdaff136307e27258f08b90ce22adaf35b199fb51f7b48da589994d0cf206affb9f02792a3e7c34fe786211b7be2e6b481a38307199534f671e3999d7099654a792c0e02cbcb2e021990fd261dd5275028bd4127163f230b4d630e6c48338bf986370e421481f6d7eedf976c9c3abef2d4a2065371a2273c9775828d3f8c5b3fcdf5266d37d2abf5d71a8db4689bd1ca310b2545926aed6cac5e909c4c7b767350750a5188b35f611801e1328d51f156e7782980dc7c0d3e65ce51c0f0e491ca442f7f93b6c95f7b58f4109133fcaf26d8f8286fba05cc27b5566266ab808fa3aedbdce2694c9d5b23a13aa3c9120122dcf542f5696f595ec365d9839c7e1f46dde5baa27ee3895c20266e5d861e410f57988dcf4eeebfbaa82d8720eee20acb4e48579ae122912cf31379129ac8fc63f4a2e7a213a6c0f402e28e0917d6f70bec1e5065e908c1e37aa30c95d7d86952cd26a379b7180d795d297f3cbeadcc3f201ab0785b5a44f4593c46eec9d1b3b04534fb642e8661681d9aae93d092a2453bb9a15eea728381c67d1e13c66845a86f9db86057ca584527361a8a16063363c673812f88411feba81e5b12ff3da91930d7bc3a993bfd65ae403cf842f9b64e46cc1aad4e40507addba6c01c7ee881791b5c12b0fd27be26d13022b42e68c31efbdacdf22b66e7cc590ee973a27dfa21185d999c893b715260458cee2d55e59d07e1f243c6bc1e9a6ba3cc43ec826f56470712f366349ce3e7b93bc9867203bbb9fc2af825b087550d01cb4cc85784306d1d415664c9200ef180b6ce4f7cc43b786d501ba56ecfd7b3313f9a8f7222f1f249e310cdd453e3fa57fbfa1967958fc240080dc88b5b00cc7cd4e66521648628883df043fe343690435a3f5b6c721778b7ed0e668b050151c624e5ecadd785fd44ccf70e23e11764ab799f7da63dda11552d37fe18b4fc97915c55a36189f33feb21b7c76f3aad797a98c892c8ae090ebd631aa34ad3a4fd5ed9e9f358992ebefb1c67442a2ffb6773decd85c460ef26673c5cb892e2aff6ff66d52b43eace413b65b1b138f31cf49567b23715de18410b2e7391f30676fd0467d92bc9a4ff18e28b5b260b56a9ec2516ea6da48782c1c1e4c36b8c892894dda3edc8bba347bbed56303cf1640f6fa85630e1eea2581f770dca9c79d0527c448cbdb45d640ab0a1f92653f436cdb21a0d85108e8afeacf26d2951065eaee97fc39d155c82a7c04ee4a5e1c70b92369220a4daad130bf112e27ea602235eeac4cbb73336ffde360fb396e8a9b6b75598134b7687f74cd53f7affcd92a98141ac906f376e55cd7097155e2598a7f5193a73867c368c9658d0a4f5c5658f17cb7111ce9e6b5bf729cedf6444b47a26bba22c8ba61c1a270970e393d23eabc04d2894c73ebfe259f118647828d08cc163536225ab6adb0b9b9cac2a61267dbb987465eb9190dc7e1f5fa34d0cad859b25abc6e87e90a1db8c14997a505f3b189c4387add8fd668f3b9b9a33b3e2e42678211f9c98536579ef76454cfe3304b6d1de10e9c2e880549081d31fe44a5a17d28379622361c8e9eeea1faf22a283a5c0250d62959c5c899d83610de5ba6d9312835d5f2c38de938336efc3ee4551bd3dc6a11ceeb9dca5364a9deff8b4efedfe685e2128d51a18de649c7a838168817f0bc1566a4d09e29628a5751b7d4cd93c326f25287c4d392786540e118aca5882fa8ae4752c278e951a2895f7a0d37e3bd61f381899ebac3ec8830bcc5f16819690351ea9c33898695ec939da14f6e56a8bac806adb821f77972c4ec1acc294992ee69b73b8c8e7fcf5c617df365d3b6bf51d203ce11fd2c275de9d9a11835998d282f3ef25ab4a0828de9ab78f7112a731a6ba8d770d6cfab6c552c67ddfcedeff1cc2de5117d15e2f277e461e84ace3aea3807d3101dc3d95c72c9323ff6e63344ca7442e9c93a247bb75824bdbb23162de4769c0b5e7b85a97957e0751e78d762741c32a85259e9b56d3c9a0a1f09180d58f07bb1ae2cb983b0134a328766245d0e6a11a3de477d3d47063398abdee226d09977067e69c1dde223c48442dc784ab5b0c46f39cb510fe18da37d8870ad0761fbc7621bb3c407e4ad9d13e0790d236dc6db79f9d114191ad23969b959919412932fe13b61b02ef1ccdf19fa198af8873cd5053517e7aca63b7cc8194137019ab7b770280ac0010c9cd0a50462f093af770b32f6ad38907adffb5c13591e1ecd04bb4fe2e78cd97c0ce5b45a70f91164029369ddc02d443145174b0b30f5493dd5fe6993658e71e3f87bdbf062977d31e0b6458668b9df6e9a043de7a04e7ad98169a322b06a369898ce23f1cf61db255cf9c58d682696e1afa828f01b2e39b7489d82461663ed8c13ea0bb8cb1176732ae097f30a730c4d104fc9414c963f2ed8e5f55b3048be1814c7b4362b50594a357b0a5d3bfe54ebfec86304108411e8185a9e700591b254999e2fc8c95714708d4b5b440710dea2cbd8f7d0de3f879e1fcf6c2aaec6640c01fde4966cc1e4b365ebc0b1a0049a891ba85f7ba3d0576c86ef28d52276cc15d614cc67c684f9960f2b05a2cb03c98c9cf6a211d3b051e6c97ab24672059a7da2e2c25ce8129e1f2b5cc924e7a138941592d2c56881fc1badf81c98cd628faf9b5b2176473f6b36341dfe6b30dbc0077b861cf02451471d94f5f8aa001280eeb7a6396205033c2ba13d2e663c72e4b03ab455baa9754cda6bce2d01b27bfb8d30753e990bf0150b43459e390512989b16956e2fd1f58074256b8ebcf1030286919af227c2c91725dc4b4ddc387333a7f5d75b416fe6934c6286c3a4e8a350bb9f71ad0a8c4c6fb69cd60c0dc9c4ddff0538548337686c46cf6a27bf705bf35d46a37ec301739962c3cae68821b6dc3539db80a28cd48f45f4575d30f7865f8eeb10f20d3ff3bead3c3cbbd8c40f6dbfec80a02cfa1d47d320053d4dafddfadd56f24bf7d5f95557d01ea0e06790854f10a80a57baf9b3be72ad054526d1eb0db436844fa357008b8fdc97451220adf175634f6aecafed0c6529a011bb30dee21ec0903bcbcc3ca6771b00f654a9a1ffb71ec920466fb60d34688129f66979638461f79d524332927512688ab940d431d70dba98dd54bd73383bc9493e90846af698d7611e90cb5fb74f2c2f47212a3eacec302d2952258be04b1e5e7885de46232e9896b9c7e426c6984c1b87edb43272633b9964fb49a52ad2a3655fad958d93702cc4cd109e6bfa4383ef144749a2f81eac60b5cadcd17d4698dd2288d6e343e030faf72ceed2e2c5c0542f138cac15630b348d5c37975f10f19337bd7b7bfb2dfa7aead4f1e6761819714c28933ce158840a827a60a6e6297864cebb0cd44891f09bb9a78987f0fbf2cc462f5a74e6dfe11c667794276217569662087ba53423d521793b6b6dd67e6febec2e3d6ddbff85cb7b67a7e4ba48ec0348a61b9134beef88ec6924c1d71bd3d29058317e710a97bd2e5c4e343c6b5e91152e30ec0bf0b7dc6dc953c836a5dc3dda07da6f8962b7be82709ea6ef7ba45321fc50b2ee96fcea723d95a9df3c98f500882189fbd7902320acae032dfd2fd05a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
