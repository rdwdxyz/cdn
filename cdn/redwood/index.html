<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3fa0f55081bf8f1263fee6ddba4b44e317d1ddbbdd91d296674cf7176d6cc02ac7fa0eca7e06c91bddb724d91452a2175dac068d06dab189ad915e46a81d5cc09129527d0b5b6d3f3a8e1b2a223340c3a5bcb3dfee3e81042f85d98a28820d0a3358d4f267e450ebc7db0b5bb7d10e146848948dfb23d6aa02e359c00764fbb108c7487c020459b41d8544809445e7f4c6b71adac7af383c94456ac8886820782fda2b8e44316fec9865da54285b928d8e13f6d71a9279bf01b63be63ab9df40556f9de55979adc214117523d2a1a5224a8b05306c07cdfd3975ad56fd96b90dc67a3c3dcf8b2b2ecdab07a4d29761e25be486d32c4d03ca912a40cb677b02b4513f7081f4ada80cce67e8344168f5f088c450bc11d37c62a6e27bb50a8c17e53b77583cbad564720b6355cb646ef858db0bd24d6e4762cd004b2f812f4971004da95c5d58301267186697fb604d1ce0cba8fc62ba3820152ca806000a1b5f6ac72cf66ffe1d3a28b4910200fde4ca16029451ee1fb557b06fc517d153574487879a3d01d5536784f618394235ab9e91c70bb7573efde439bce45e2454ef702b615efcf67c095dfabbdf5028ae958a3da66168ac4a645522477542193c04c2c64d2a350177d65575073cd42cd7f7de54f66f13498dc934f47ecb349e0220b305f28e853e8128a5e182204d7a320839b66de0d48bd4f345831cb1580f736a45031d3b36fb20301f3963754ca0a9f180a203d17d05142c1ae90a6f76f2523dc49faa926f8976975d990d54d27f68ebc32ba9a5d16095f91e3eafab83b2b8e18de7a7b3358b144d4b8143ac4af23438c2dc69a1e4ed5385cdf57863ca2e6e4a4c3dd099b35cb0a7712bdb37b4b9375af5a7cdaa9ef945a3491a4d38f8a9dfcd32f98329af5ff6276c584ab27782df331fc8c8c8450b53cdbc0de445b5439d044c5928ee1cf02fedb089d6c6b8581dc1b3e7f91d74ef976a355077b1edff66b79c1adcb97555ba764f785a155065eb779ae005c32fd5be055a3b06bfa4f3bb7793e2fdb6b06e9d8edf22cd76fb5019471aa5add86c160a08a343d02c36cd18889cd5d1a043ddb355a84911ce7b7b561a3de3965f164b1db4e13272ba9c906f3d84abc12c977405b9144f96f058c4e8dd08814d6c5b45d2cd18eb2f9c7c82edf9777d92ad2b0876b1d9dbb65af3df0ddf19714969d05c06eb90fbb6150c9a7cde9dd03d6bef2235f865931e509758283789f66b152c6d72602603396dc9174f19fb1974b3de6dde971f4c8ef67202da209c4d41a53ba3b494b103ea636af3d036b91d46c85c9419299661ab9b8bb5d5be624517f2a275c3482578bfc83c2807e8dd573746111e288e029de4ea1933e8b6433deeea409b6590c4f2c285a685085bab19617be1708d08ac5d09cd6ca48bd7d85dd20663e52ad2c9b062b9ffd21a88c1f4caf7b882b6c456f5bee45665d9a8237766d90d2a30da0fdb377eaf76f35c10dd183d7e2f5549daff0b7dbcc5fa6456bcc535356d29cf7c68e62d0145665b06505f9f7af38145db2362331560cfbe1b160faed4e20fad7b92f1f6f7f7774c879c8f7deeebd18d5211668f15851eabf273955b336b7b53a67e642c193fe255910284a3b3114cfa05623b08fd158656430c2a8b21c8e7dc58fefd9150ea8c50ec9aa19735463b46c77810aa4506ee316bbd8d0f1a06ce5cf44ac7571f1b8e18090ecf19baf77fb877b691e574b5e5fd6c72d662140265531ab826f445de426ddf8943a1009f914ecbec368d896734bcfa6c29f228cf0d60a6d2840c6e184aec943ceea5f7f27a8c905ea01a035c06844a68c93e9670e1d6cc34ca2dba9ce4d6e03ad5fbd0aab4375e8c9546807acb3f5341c785e47ae23f9513c2fd7964d48ef563835b4b06948284ab3010d228a42b6e188de372a0f2a7926de3cde549b3adc22d21249dd420d0670237213e59c87415d3e1e86f8866b453d8ce52b551fd002a7f8908833c397f425317a685e5c2cabeb72923070e444db9b0d0e7660e53928b75080c5f23e822d7e6e6d399ae03718e3de4b840e44de2967e60db25cf66bffc0dcdc558c8cfe2d59440fbcb26f0120f7dce5035fea21b7a0f5091efad0e3146c186936b530a152d8decf2a3597a29fe4bfe7b40d747084c996ee76ab9bbe90fa20f0f4c6e15ce1b3ecc246960a5abc067cde535937e98dc67931e25e5f12bbc3020729fc81883eb5443a3aadc18c60a0717c09676d76fabd5ec42a3abf95c93b6038857682a08c3266d69265b2c8561a2f9ad8456466a77b4225e52c85d5c63da5431f54ffdd950a0662c3a6f097c56d5a785cc9339554308a2c18bbc855ddc20b4ff40e56902a729b5de95099fc786c1c976a54e613b1973fc4876502f69cc56a04c01a681d200c8dff371ccba54cda2ddbd7a6542bccde61d000ac2596d580c76714b27cafc00c7534045ce77f934bf14186af2adf642e6d2f17faf2a3955eab3f36d0294e6f3566bc0b8669152ed5e1dad1b54171ebbe15dbefc106a13d2d7b7f6b2477800fc0fae61902aa920f68ff5fa526d15c721922882ab93f173adbd6d81107b664057976fd1399668ad263d862ffebb9b8fc4cf287d5b23487abac43b4cf0a1305d78760e6561f0c29f676589c873f3bd1301e05189a4b34d0d063c837ee92b318a2995ab36bd319c7cc682d08683725d1c37549429b2da8373d2073d7857f1d2626a06c12c217822034b10b32f5f68d5df977207b53a96514ab1709e2c9a203d5efa331f5c70221abf724893af74c469ef3a651506fc5e95ea11d852d981a1cb8f1d0b8c93f47682fa9c3fd55241b4779e99fb44330e927e8484fcd3db29d77deafe66fb83f6a195710ec82cdd2a4e45df03c2f829dabc9168049d46d39c7c553744d26f9b77368121c228f1444c3c416311c1cdc5b5f81f7db190dfbc868754d8b546839a628c439911bed8ae3109eff6a19c258e92b6e1d6262400f72588749fc8e4b0c6ee758fcc2f922d6e3750c5b28701e1cc5bd04a6e7002a40343c2bbd6d8cc7e351c359079978c8255d58fe3a14f70c157ff09e8bc6dbe250743f5e642c22cb6bfee3aa564049404885e3ae13bcc099c24af09993e11aad0c0fededfd10b2597599fa8ecbec4aa470be937caa4d4f18ee2e76d30bcbc3bb65f92d082b01ae346ccc49273a49afaf2d5a83194e6fb1ebec9952b51ea907829d9e5b995dd11dc2223d1fce50208cf1ecaf796e76157a676f3b1d6d4f54929d32620d4090af451cb0f19c1d41f3f837485b0a69f4c1577f6460c6398dac4802a3ca069f3f12fd5c512b789e286b0b65e3d354f609931d23799bdfa79d62e51f9d68135e961896630034977dc06c025839dd90f46b75bab763a4913fa28466240a6d331935a17cd71628a320af2443454fb37878329d4466f7c3eb1a693dbb2334637a9dd42e5752f57a2a2cef68d6165075f1ba42a414c65c2d7739a7c1348441811c50a249fdcd3e01c6dfdf89e5fa3a91a7e8e45e32c0df849fdc81b0f4a6b5b05fdb8a798c8451de85618a82623a3f4742d09b473d7ed76f13ab0cb15b050dbdaa092adf1413f5ddc2a45b1d5364ec001dc75ac83081cb0714fa70c93cb1a09917de41a6305ef95af1fc53731386014ab009ed14b4e4e6a993d1424ba51cfc3fb567779c5be044eeea93eeaa8c2ec9e2e00be7967b146b902b49a15cfc21edf33c111381032db64715773ef3358a6a635ffb2becbd4e4f01695d67f235ed7aeb47d344a82445397e19643cdef9fe1fc278447a8a0abe9947d1a49d3ea4cccf3163f075693fe1aba9adbec21debf8058fdba0e1ba88f5e32b48b6b45dcb18bcb03aac9b259b87e7ae7c032a24499b00335f78f2c692b93ba0fde24465233be3629821294aea96e31e1edfd5f8382db59c62b4f37d9871de892f44e09166bee1b8097db0b438d3ff5d7ce4058dddcc3ce2689afccc68dced019c9fba0e3b063eff52e9b35075d371a50362b47884bf614336294f752e9c811138a92f9270a711d772716e5544efa3d2fa00c5103014e0abedd81a59ea6e4039496fe7967130df049a08d0932c2ae10c5263a09283b6e04b1b77f35b5e054fcb233cde3946bada85282b12f41a8472079bafc806f9353008f145ac3f1d5cb680785b77882f98c8be354b7057fb0a7e24b582fe9c66368bcb7f98a3002a914650e7542bfb098fbd35cb898e8e21f7e6ec53fb44a73c9d5c462bcc54bbe8b9376e28c1bd6d40dc5b9c1bce13a3562b2a084cf7efc5c48a040cce7f2ccb1da8ff7524ae9ddf2a5ae77cbcf48bbaf8186b3221cda456c7da5365589c6e99aff79278e8c41b14fcb25bc4b6d39aee9218225b0e6e8c4823599640bd6328e2245009c16354110da1220338d29f17b209809405103589c634a01180762dff3c30b512df04e84497036448d16b6c9f63848f8b5d614ddd92c9095452ce39945781afec4c21d2a6ee743716103af60ca99a778f34bcaa47c97e7975146676e2f1300e0ca6107587e5edf9daf519c3d67309c90c375f598080c24b8214397c23875a54c0eb3753a4b4b4728c4c17a9313e95cd8cba5028f08b7a6f1eff635cbdbec0c79dc3a02e1a0fa79cb5d322046425aaa3e8c62d871bbefcdbaf776f6dab628c518238116f15929eecdf803cfa092c26e21fac7081f147aa222a36fa3ec8d643edfcdbe25c806d0f6f7442b239e66249929babed531d658955bf21c3458ad3728ea47cbb6435807b4bc1d121f28ebcb11fed8e0324cf9bea52da8f5a0f2ba5039177ef6c0ce1ab5e30a218a0fdbd851718639fd69363abed6bbf6e12f68c9a0c9c055748f656142a9e9b02c8ddd8426922455b0dd9b2f6f798cc14665db6338804e4990ad911625fe479b566013617dce7eca20d5f144c38ccc3a0e0b99986f4df20e38afda1f4980dcc90c74f6e49654a52be6b74e9294e32234a91f34db5135af549d3137d1b179af903b10ab6b9bbfd1f156cc532160d5069d5ed6f2e040c3f03b3afa7876d3f189b96ce841adf3aab29e86e88ffd1da25d86372d4177af9d5d47047eba3eca7731204c24a21e8c0569cc4d77a8150f2ca9236bda8dce13a1c1e35101baec460a550381f1fc93b7bdaa7f7f58118266859078e33ffe43ddb5aa147c051aeb1c5a218a4eecb011f1f4f3c0ffe8228d75339483ebc497c8e6a6377fb40bd9e54fcb10ae45948e4ce9b66a06f089528d3ee4a1dd86a478e4e8e3196cc9f66cdc9e58ebd0da07d5f7ddb8012c999f1b9382d8d7819ad6f94eeacda9ded83e1e8ebe2092629bb83d218fae6f6246ecef0bd7456d144fd16af5d80558d073db6bc9d7d50de064d49c69cbe2717e95856bc9cce66066bd2af84ab471857a97dd5db9c27e10703e722fd29b90df96a3a0d8cf912745b2856f02db993746817690fd6f41e94480dd35a57b819a77c710c9bbdac9bd47d4ad39fe7476bc89ce4e7107e0b38d2df77c3f561318ea883e89790ae8fa76b501433ae483fe0793156fa3b62e4c615b37edc82909edd3837b2c6d43704f48b00faf952a76633e64dec0e0bb815f23c03a4bf54010386aaf3443232e43f350edbc983275cb58a0c421b61d0882d80e6778b58cde2f18584adcdfa0c375ffd01b29f20c0feabc143c3934793c6588027ca7a19b88c8b43edd548da1835c6f34466ecd7280f9e1e7db0555fc3a094c5e408a3e0d04f4ed659a59ef319078387446c8c9273805d1c7f8cedd5a76c0b4073b401bff806f664b604ff02db94e4b19ef201105f4ba079378b068b1392200d21fcbb0b846da588f4cc77d230a1d6565adcd48c16aa7a92a8c86bb87387760a566900c4714faee7fec3fb4c5e86e4d75d5f402f11fa7f090d1517bb729f0bf512500313dabbe86c1bf0ece1c46f5d97efc413ea96c5dbd8fabf6789fb44b5ca998251c8e8c363a90d08a7d15be52610de32000cdb6508f1af3b860d6f2d1748c56f2c51ae936acea992ed34915ef76492abc4f6c147b86cdc7d3a4919fd7364b935eb05a6ba8b9b1cd63f51dd2bdb88b2b52511ce58d9d3f7d4ec6755e1527b2408b6b78f3c86d3f3cc3e15a08a594b59624f0c0c9bae58c81a65202aafbb1d136e87b2d87640b02fb37b549f701de279b5a3fc59a41ffe085650abe40d8905371e0106ce171e192d8d49f4e51697634a64bd7cba1263bced0113881c6cbeddee8b4c71e38cfd96ac38afa1b2cde8923e3e30b9b14503f91770e93fbc6c9e2b09ae7814ab0c666399cffda22c935ac7eac32f169d7ee949d913db7e3461828fd23632d253de2f6c66c7016dcca44e658e07c1fabbf6bb86a9edf3f1e378fcc69d5781f313572f395e16ad8d8afd1ebe59639f854bd4701a0a38ee8cab8b1862abd32ba60278681c20c5dc9bd998c9a00a28cbdb7590a43874a3f601afaebe14929079751e229e8854189443005c67c90c3defd0168479202353025de9ade5b784a08f1a3e34186e5a5830251ded3563039a3c3219d2c8c8fdfa0fea7775a127583938be446a1f7b99ff97865de067c35007bc006173e240128a8375c2501b708c444e39f9576d2b1784853ec18ac53fea9246d30259d5f11f27d6646def0a7c316d7f40db13eea27a46081472b92a229ab0ea1306b8fcbb76bb414db09ab4b77bf30313935fc48a670987da1aae53a8e1515baa3409362926ab26f0b8789986626d4a942bdac20ec61b3346a91ee6cf647af47e2f8985650f367f5424e95ba23d9c80652c4e0a2a637885626ee073606c599540828b1be298675adb4b972f4851bf3dd0c19e717cfbc81d4adddc9683a46717a49c7f8688419dca876ec33ea4dabcdde708808147286ad1e68bf1a536f116cd93954f2a73482e896ca392b0b9c18a9edd3f20f9366ffdecd14c5fc3067ba4a5c3df3de784d42f70981baa7f52c00148763e448d61d65523d3c5e4ad76938ffe6d390adc6a7fc0b8514892c68d3ca5a81495c4662fb8b9e61f6e5d0518369bebec3bad7114b88752dd70e6d4651330b55ecb45f6153794f833a6e1b78504fc9c975ec8d5308bd9199ca1d094add27ae890d8ad2cb27e22002dba6d1799f39c63c3fe4c0c25f00edc638debf79adebd0ebf38c4f704399487999cf32d86c7ddf671bd16a193598802d7e55775b009fc3b59030fff33288193245aee7089f80e34670facf8ccd49e661025f06a40e7511013898b52351477628b4bab246ba618a0b566c5dbb144d00025f24f2a05aa57c83541b16451f3571ed9299fabdabd6662e7b9fe854951619cf6b9646e1db9bddeb4e3c2708096818c10549d3220129049f16878547380351230e102417e4f665b86b7c56b2f1d370a79b92f99ab3a5b1612888f005815a6c3b7d33b03f4b337182fe7db6ece64e67f920dfb68026e51ab210b3cada68eafcec3bbd2c2582808997d052c8bc02221ea70e4820012ee8864bcc2fd60400356492f6029f69797640a4ef092b9f29899fa0fa35f6c697059c369693ccbc55c8a3e32f9e12316c63d18555497d76e6461cbe6b27fb747c873d6875c8f3c267b40f0e396a51254bebdd3138b222738452855f2ddc953629cd21095a89738301de26dc4b745ae6be543cb08d647f84d30b5cd8a3054a8b5fec06b43f8b1eee4be6c31fc8dce6e5d98d9e25a7df52ca88dd1207efbf0f5f12865b919273faee2899078291702830f0fa7aa3f45a1c441eaa99f074a13b90ac16f719b0aa4ddfc7c17c0e8c525e1c19ccdf3345b645e3f0b904217129d795959858e82f7ab48f9f0268c4ea81dccf439776c46333f437ec0faf59315f88a15cfd285ca67214dba424cd0844372a74cf55bdb1d34b25f1957639b1ec784203bea5198a3a32a9e00acaf1d18f8956d7d1ab1e372b7b93133626577d1fae949598ecc564b313e0ee99d1de4d6b5dea1cbfc22aa02e3003613484b5decebf942068e7cffc6580f2b33007741aa74a5901d89650ecfc9815b6f5ddaf392624f02287448e481d83482a30b81ceaa6feff744da91a11d4a50b6a328d58940c09a3180d063d42ecced5c49a4641836772481131848c99741af33c824fe2499602338791fe879b7e88499e58c27137e88c1d020f795e5b6b36d8131baa25ddf33dab780af7db5a7477f3df9321c8df23ecec7a16ecec1452f45aadebe905ca5a54d1421d575e8db5a0fe03d31b4c286d8f4e6adaf10a8aff42b25a96422becd35380a933351a26b3572faca1e813b12f8493a1d78e9e899c35d50b913e93527a138a9f7b7316c1981a69850d4febe0f386212b28925017a7b03ae298297db1a6768241da4339ecc04b2a95c2932e8e6490948693b83baf03d69572232c9cc15bc3044300df950ce631053897a2a1b4f18e6305563c27304930ac2f369373f678817dc99c5fd6750d3d9cb7689dad78b15d561594ec3c33e33efce39bab244110f677d6c565091335001a9967ac6ed513a8b460725b28803a4dabd7a8c77a469002ff57549a15d574a55105bf14794a728b5d16965c293e03be80f5cc25179537d504cebfedca797d5f39ba99ab004346d0b2a0142ebdf66ea60449497b2372bbc66f3896fe03caf9abf756b69efe7e18b702c4b9b34bd308598e1648efa1079929a8fee54e32a8e7739f788083033780d4ddc67bec2a1e96eed366717d69f65ae47f23f1ebdbe3ea53c462867f6e85a10db25cac16e2463e54547b99a5c5b46790254027750a0214c07d710ec328d4edbcb1876642a5e30f30d487b85d349ed77b7b3ca05394699fa7b973e4588901b0aea34d729858287019eb9196a4140363165ce89857a2a06e2fc9e5399654c6df72b7be6b59a123263c51edbe089e5753c93e7297bff1807d6cdfe07aba0abccd3831d57104620ca67e3990dc8416ccee5abbfbcb4fac5fea602d0aa9b3598fe5070f141ea86d5469ecdb2bee7cc86cdc0bd97b83f62aa73c7ef44d429018a94eb24c609b5604fa57eef1857ba1b030b52c16827dcd4e76865389708f08ed1a84c993e7af561b9e0916c108a0c2fbc78b5fc3ea1720c76893abcb4d5521bf2253bbdeae41ed581f24720539a8b59ffde07c219d5a5e9f52dc263a4d2832b7869af85249ee1ceec2bba5dae1621890ad5fdcb2634ef4f6cf8829c6ad9ca385da6025a2a2065f1181bd152211a3a64dfa3cdc8a8ef47b7d166276b03a0ad2373bfb6b5d6226bb0669f3a1a8f689c2cb40ca7b76703af856759308673ec47d5471a3c060d74682f6461fd15317dc3b4384e2d539696da57a9701799cb2ac7de74633fc8a0612450a1c4094314aca9165e8bfaaabb75bb045f7712a20a9fae5ee1d171f5649fa79bcd243eb5709c5cba99702a87349faad50594d57190e137c03645b5f1ab98af42257c4f76e93f839b88aa18a50d89ecb872e82a7ef59ee1b44ff61d103f81a9e889aa8b7e6ef3f320c139be6378dc2626bc0284a2e0d7101e5b007a12fb2ce4ea75de82145977084e31746efe8bf8a639fc482ca96dfcd5d6f480796af675a78e67fbcedbd41e88bfb7e8be74bd16c13efb77afe3b0edfaa080f134614ac86a66b27b00018c4dd5fc0865403ea3e8df1e6da51844aba301d9f9d04aed72163b0903c3784e30c215c4ea97effe9f8af8a2c41cccade84e6b23a23d3c548e2c6f49dcae191ba9c1483238c93e24b050160ef27362cb70e0eaf4f5d5b5fcf898f7d02f6163d5dc1a6996be0875071d3d018bc7dfb427cd1ece6e02065aa0b02ef1e55f500be9fcc226f5db94a27206064ac043d1c61b61804e6b6619d132a7a0dacaba85a2172894a0cf16c698a7432744419dae6d0fc88b0fc9a95c5371bb1b7dbc28d4b4287785ed86518d86fd2787c7a148a6800ef3aa6edaf525824a3d7a56ce8b8185c19dc4e9c8f5681e8f897cf61a01a568bf56b25e2e78bd47fcdefc31587958d1180144c31acbf52ecc447ca47a5b901c35f0b5f3b99ebcb49b85a4029ce2e5c78267a123567dd5f2b5402e337b138054998e759ee39c7aa77aeb7af0aaf8c199eb24b034bb77f50a8ebe2ecd85e127b2bd62a678694971dc407f25b0ec2b82f2534a92315b34a724934d78b3a00f9a9bdb258999066bd9c1d767edca316724268f91504df7367b44e1837b9e6f5a21394bc02e8138946b72c29a93121cfe14b6b1303f66ad0c25ae314184bb065a34da1c2fa7f1eef3525942a680292afcd7ca631529eeb677865817e7a087a1e520b6b99c8d18c7d3b8bee7c39531d5ec765f6fcdc81ca64703b617ba397026bcf078712402c68d7ed8933c98801222b32937f76ce490986eccb6ad6bb0d8f4c276df75569161249794f105fdac014bcc85dfcac77068c9f86b9f06ffc2fafb443917b608eed31d02e9bfc8ee8eb249ca773c9f4ce0c8f1609f2f27bcd40c3afdf02bec78f20554febb4f1d6f25c4fa90830210db8b51bea872be8ad5513a39c489cea96af7b6c2697d31961d06c03952c85f84fee7ac3a83b4af66d5a64a90f2c3da395ad8fad66588dade2678a639fc32a53af9b270c5114406a417256a4ed0478f908bec67eb52e90118af567268f06f513f59ca404d6160cc5b4195f6173933129c71d65190838725ce2fefb7f0fcf04af34cd6516fc94bc60aeaf7e82d3cb033b4c6bd09a3f90406656f15c24b5e69380cc3c7afabe108af9260b744197f79171d6640cb36543ea52980cc5dd1eae1f070d0678092886d923991d948341445e9df1de41c23492ad7a53a889a8e461098612b79a34d2af8bf1db4ec8270b5cb506fc8a7e87faa584d0ff8583ffb5bc0df8f5f9530a6bfc8b5aa9d32b241a8df22f3e2d40f5b8e82cb473f10c77caa3dfe0a8e6388650c801c4c32dad7109c3480d4128a153be866479b86ff9c8b0fd8542e4cfd5a431539175e60adff0a9de4b2a7f59f13cd1ff16112bedb42453056e6ff598a38e25365cc391c9b48f8a9f83c5d0702f4413c33d1cda0f43bed62752dab1efcb49a240cc8c7899d4af9b9fe74052850c74f4b8fe5b6d8ee364528709ef26543327d30b85286a709dbc43606b5432f27bc58f40febbce6663b3a6935a73abe6c40ff795fc624359569fad0744b683b5ab0a4b1879ab81f0797c32bc68e87a143d37fe1105e633c75d55c02838ab54cda276361ed6e0828bf213fee219949fb92dd1fcc5b730e94c1299197acb05cc08291f493d5dfc679f27c5d780480eb6b01be7086290024113beaaf84ad0c30cb68d940354538a16ed0b4427d1ec80651f1d07d256c7899fc8c05b4538e7af1b37f485cf34df6e59d02cabd8dcd54717184d627391a8694f4e9c863956ba7f7aad512df0e52dc2bacee17dd45fbbcb58065e924882ca147eaca58cbde25d7634b6b7c782f77b2097231b43dc803f9d2408abebd936102a50876c722d65c2e9b2b9acd2f5c7e9fced0567672364919bd8a448a1b8a065006ea1bb069197e33927c0a39ccca03177e2af0cc8b9b9d79e7dc1b79a6f9749c18616d3958112708c0cba981f8efdf2ac704afecb4aa95c312242d1effc37081d1f2b0b868ab53160c8d1df90da0198615546c07809b3194798e3ae45fba7153e5cfac0fbe843ff56ae9c5c05e0c0d9120a8fff6863b6819e3e5da9e12bc6429db8a4100b2d1bb8e2e9a9a51158e149222774698a3c702dbf765781e15cea6bc163a17831c4cad29b901fc0e8c81020e12901e966bb2af80831b052ee3c43954df8e41b8355836c403bb79d4af524518c1aeb122d6046c1bf250cd9fcf7ea86f9e9dc7455fbc2f517687b8e29db382a01e75e32bbebfddda2a0b2c74940b9dbd1266f192575dafbc34ee9441b59ed0759ee8eb128b15fcbb614a973cb1afadc1ddc2ea2412ad957afa4b2cce92122f2d086900d930a9b61b8a323687c31b795dffbc9bbceda817bf50ded36f1d615b45e66731d1f699aff9030e409119e83a50c1186e36ccee6502c359fbc421009e0f19d693ac7f0131bb127a0b341ced5aac3a0cf48e274535e5a66468fc0f4d815844943d137aacbcb12cea5dc2a4309cc235d43387b7484e131df845f29d1cee462d82a6eea9350163b95b2d7b8c8f196bc7d3a5aed15706119a617caf72ff3692eb1e6e4d5c8912bc218c87f8ddf330e82763a372cc252a2b3a86712f1a3c6679d73a402d6e47bf5f7bf94d217ceb4faf6a66002c1bfe1def69a70b8fbce4bef1f147c2ef88484385f6c29288518508e4a591bca009c35f7e97fccfabc5e4005a7b84205ec5085c12b8faa13bca3dce8a83621cefcb86118fc0bad450eb75b76fe0dcc6cf1f925a7390b75310f8e28472dfcb7f7c1100019897f5930e775613f77286e260102b44cfc26d10ff5e21003d9a77df120d08300ad17d64736fa885709d20218945a76e027cd426a7ce73af75520aaeb080e72552a608aac29d2123b27ab8b10859435635ff293102dd7437f13da7bd5fbe88238467ab9fd949a8f3a95ad40756818d3eac2f07da422dccae19dd01b23bf5a0d0635266b37c0fbcbf7568b26718312e3b5b2c9d5729ee8a79369671d574e4505cd9bee4f864779668f9314f1d91c3603656b71bbc7ba43db26339ce29d0427965aee9ccdb3ca8f3d155a48181687ca8f7bf5b5f6a49374a46b810fd22a592b78b53c42145a5482c1975f64aa11f3e5c19a8899d0c16bbfa977a1399b368f2c58ad8649e712eec070ff190098a6f170aeb8fe01fcbbc6121f764cd545a6d2bad200b51d4b5b3c5dee9e84b295eff48f5a74d571847b07df32ec829657a2cb66eebbd845d107383714f678d9ec2382301f3f5ce3e15fc02f584a7c9cfd77e8384eaeb57aec217838136da44bd9256c0fa6945576abaaa16b199314f12dcc4c14d5462b054fae16a51050c967e04e4c3cf6c0a5f0e68a2d0a8fad66c0e638c2814b7f4d77af91ae7ba860438dfc808b8ffa614de4420806a96dd8c59302a39899cbb7a5eb9129f34f842945c99bf1976d7bef2f4a1d42484f0c78f9d3d7568673ec9479474dca18480c40f63b1320d3a54a5ac2cce2189fbb599fc635b26ae868bbec78c296dc51321e501b12062908014c3ea30e268730dc2dfefec7f966db52e999beddf5ef2c2efc04da9bf240f6fbfce0517288521b52be77b6ab2b71168282bd3a37a076d95e4617141a41f514407ea57704bf82263ac4e240eaee07e28d114fde55c31b9576a267cb703a76bdb033967775c2790708bb7caf151fefe0d87acf97235a96b08ea49c013eecd1d1f6421da0256cd60889d8e9e269fdf6da5e901db31256521f179d95a2ce55cc60e1c3d42aacf3cc4be72d0c29aab1a9b5cca21308cb10d2be873953d54e2780ee63a299b31b3d32eee357871e4bd9321775213a89112b7ccc53629820c21a08b5c45715e88b020b389ea0b0fac34c5a8df7a43ad2138005d16b523e248e2b2fe6a4555e9662b29768cd3bb51090278eb1200c4960834192408794d7a1e7118dd97800be7f412b1b0ceda106ae754b86738deca8197549b853d76be2df5aec39d9ba04e13f18b687af6a66aafc7c2ee259e8555687126cb4a2dde58bb1224fea76e1433e61dbc1b9c7473d0b966b17035f16f7a337f0b9203c2b614b355e09b97e3573cc14bee9a3d4012368f7fc7391cfc408710438fb53986a684961fec17e80842e221cfddc5eadb17e8858529c3cabf92e2e1003ecc8cd7fc8f8bf3b49c76c2bf02306e65ae402921f704a01b89cb2828a1feee651e461fd9ed0c6569521c8344b4f0efc2fc1b8c513e403536b97de873792632478efb3250831a8d6ae0f238624fbf0915872ccc34091dba63fbc1a3e43e958b8f42cd6514a02e46ab0c02f8bc67c40d8d6060644d874abb897ac2b1c7b4eb3a4c85df80b74614ec607cae3ebca4598740e4bc40b494cfc84eafc788ba1eb81f965164f9cab000b7edda51ed7d074641903fc31ee0e95c727616bd39fb36a05e4d0ed91669b21cb1f263ea94e1751a42fea14111ea74993bfe11e62665140bcb0e9b8dd68d495ec5d7e9bf640d9ec27016211abc124714abcb30efe353292ef00750ff4b755fcc20e8e88e1fe443226cfe0ce4bd06a5f0178c0e819c43fb97826118a33c4892694c16f1212ea66b2559e6d254e49e896c88f94bc404fd76ec55c3030feabd582fb418966b7acf4ddaf57105843b4e8f461695e4f8809e3dc1d02791d7d2542393edf794c49346e1d55a922740cd91d3295200215b22635c60a7c9b101df506fe71f67757e058cf8d8f7cf5cbdfb36ee866874f8b1989c83394dab42d8a239c71aa52f5a7eafdbc75f2c29c9cc184d4467bf600bb0206ffacf6dd84c7442ec5388040155d55ae8beeb048ad6fff079384557df5621065342f6befb3640918e941fd46f6f0451245a8b378a67fcb917abc041a30b4aae8f86db6465b2897012ef2b295efafd133fd1e1129c0662bd61ff3701890a791e86736ab5cecf30faf08b1a951fb6802a305a4897d99dffa92f931467c67b50fd87e1270e6de97f429ffb1323e8735ef50243b72a939b39ba97971224290f224f5e101bd1024ae0b60a54c27c349557fc0227c33f5320d45cdb095a7979d036dcd9997a1c5e4a1cd5fbaba2d7580d0a19b6a72712308f26c9cdc8e0e3fbd20cba18937b6a66cddeeb02a976e52316699ec6a8a75d8a745a6d671fce425631a13898e11e3098b90f5ba41a83918bcefee0c3579dd564ee86c93bcbc67dd1d2e9438c305e2d962652b079ba66bde75f68a04b97a5a1f629361715a4169bb7a2c0a1725b23ede5b7e5afcaf49e2f3180043751e69892dc6a45c7833fdfe6b217b776930660e1af9c39ad9930eec07a9a69c4f49d30f2e00efe9ba0aef9f64712ebe488632849ceaf9818de617539af1f7069688045fd6a2bd2d53fc6bdaf94a7cb44908f532c6034230a45b5354dd10a1ef2bffda4e930f65e534ba34e2528a118f76f3e1c71c7c6f6d35b135f1fd63ad6052e7dd9937bedffa2d07b089e09d34608cc2ec7fd4941a8c05968d7acfc0d1e4f2aa346150ab9c351e4aa6437d3366194eb3517d9012fef27de05268439e307b6bf734014c965c8e7bdc42e6704eac548ccd1d0a99d60919795a3eb9192a7d71811698eec4f9f1a1c2d2211ff3e2912f4edbffc57d765f65b38f6b11d63063d7df504e81619123c290a9aaffbbdf76fcefa94bab10211751631ebeeefb6d3f3a7900a7104a99dfba097b0bde81e6da36f8b7824e0560ad79c3b2bfe691dfd7800ceade30c76e47e114fe389330fdeac3d653d2b893ed76d46724e7313c42cc26b4f1c2f6f5926fffb4f41a733d06568a1d1736e234d280d64fd74d71e77ebc6ed6c762c13072f20f34b9f24eee6d731138860b110a5d1e1024a582246f90e2c60920c5b80c8e2637df563c67814ff9db3a3becc40b65feb02ce5c4c207e8de252673f206878d4df884e72b5d16a76f6ad160cb665e6bc635b1e177db0c8721c295682acf801a7ee9307398d4b787037331666011c65bbe59ef40a34d915a382012322abdef4eecf08e8b609bbfbbdc49f6e042a3b419f0fa19f19140bf11444321af621cf92a5b3ae41651d3828583b3ff9ec475473a996ad2f652fcc4a8c0648391a4d1c0af19e796bfdb64580b7e321c8ef5c94fc372198e98396a15f9874894d52197bc1e6e71a3dced44e13146a4e24f3c7384ac54ae1fa9bde638274ad40843a83ff9dd46c565a331e12d47ac97a1581a72d5a0457e8e57cc11524ae1c54f30a426fd5d9c7bbb0ecc6a003e0a8cd6b347acda980df7571984a64e419ca518a3c18b06a7765ed7c405146c57134972a479d56c12ce8f3e6bbdfe2fa4734fce01bb12a774733d4ec7638795626a95099947ebb1487a78d56cc9bce45f093352e41bd9727ca96a27d7b597a2bbdaaa007d2a3810ac8d259d23f56dc1d51683069fcaeb9171e7c305ec5f0e5ea1b5f277f8e6d575bc0b402dc93f17ebddbfb34e3c314f10042d44d218a0f2eac35cf800aaa5db22629a59debe3cf3bcf571b06aefd3cb010a08e139afdd3eb047e8df27210470ae87d09a4cac3fe015f24c828225e437f2c303bb39bec14d8334318d42f19d20bfcdf8fbfd749e8f229b80caad31186163db8b8fad8f72443028af2d75a151f07c943eea5c1749b4040f5c214fd8bb437677eb278fffd9ea8ce7ec355a70cc15ba3201b21465697237356297a3c0bab746212cdceaab6c06865b88d6560b4ad940fd077147cc6b2a72af76603aeedeae055b500859539e3b7e8f5bcf4aa58588e837c50f16cb372d1794143519e7d0fa3ce0dccd72e1392935291ba87fad252074f22db168e424b4c155f8cca6d6c1925e7962dec2b52fe06add57e327860fa96e241ee3a87f859c64e6fe86104b5cb81a644a1c66844d94072cfefb39f8a70664b1dd2a6659594bc41128e9bb961e8404e7d8a18641b644fe7f6d4dd0462d93b115f77d4c871c0cde3f40f8b9845394c00a6e66a04d8812c1efbfa318d89f71cc0df453402ac847afcf1241dce1abc574d1068cdad39aaeac996de97ca8ff4b5ff1d2b8164374357eb3779514567397b34bf18e47067c9c4fd070769b2f272de294bc784a94423eb8b01bed03573b7b45aaee5c1c212941a68b30a32f6b925bc9387bc5cf0ff0f7a999d82a09f61ce08a051cce244d735225ec44c2fe1d511f6e318744d6cf5d9a1b3c3df705844b0be871dc88381a1ef8c4c354edb6380a46207fef92a5a146d22e02727c1c8273320b80b394a08cd5ca317a1db5720ad069b3fb2d2e76ae9af4b725a179a9bf8801b75c688946cf273c78309bd209b790b477733e6a6027ea86f9c32551c4e34ca8f69fd6b6e7198597e38f919831914336109571df56b262034f20a6a120bb5faed90d00597842b0a09d0899a73b285314d53900909c180afc7cb00cdbb247b042f4d91654af74a93e556629ff8246597bce1dcd3dd1f477aaf98cbe1b8747807bdac60c5aa640ce2dee4fc45b04a5148ef5beb94ca168fe3f835eb340f28d9155600eb0cc4a46f40832c297820314c72bdcdb35674e365b5fb6fb3839c310cf612c6333f37331d8a60e3068bfda552fc08d16bc734f9b64d519603ae978879f08aa136ea4f405d60d2ea307206b19c3e373f3ab95cfb1d92f7cbe299e469a6e4a6eb1909cf2027b67907b62ba70fde5bf3e02aea8e6490a01222fba75ec7edc6db6f59afc28b5703327a5ee5aff1a71c31ffba7b54ba398cbaea5888a8501d83d82a678ccfa73efc518793bbb9052c80554321f4d11cc33c809a43dd0838a08e4789edb7781e768d1d2b38dc7f9a5b6a30972e034290b3982aab605404b98c530984e3c5c306d2efe312b9dfe4d6aac3f3eb6540a89b836f02df099c904f8f2d4a7be71c931079f52127191f5b31f111d5103be2a4e166008cd98eb67a3ac5a1be5e7bba731ea4a5f151dcf887ddc162ed07ee4237687f4f71f032022a4598cc1ef438185a0dfeeb4577cf19c958cc852ddd5a63b7af04445b5e3fa5aac1e6f5a6f6913bd6b29fcdea7f91162c8b1e8fbaaae991da640b1661ae41035693ac87379d880e9d4e01b52c4d91fef0fcd971cac4b5d1da6e0f222ca6353f142ac3165c73d7b78739a992d9a7ab87dcb526761398cca90b73e570a4c9f8044492b7e009c6d205af9eb6b4dfda2412b652bd7bcbd2116c772781570a0a52e68de0594d6466ceefc8e0abec04bb95279b48a2acc1fe9303a95fbb4d81f07986b346cb5471133a0935c0cdfb42825752be17730a460753c49ed4a3adc30ac0a2356583061790d08c42111e56ced4076fab2f79f3e3dd1c428ea87a4dfb9f0ffdd7accb6f4d2be6ea9395bb37d7af04e6d7f26084024871a16a6a1c56bba7b4b1427a1c1deb2bab25a70b725ae02214c00ade105f95daa3e138d3426f798864719ff3675b5574f10c307112b70e8bdae888bd64968de59353da989fb47a61633002df0728f654024271a7acb071383419a4833f9584dbc776b34da61d6b6fe1c312580a1bb3bef57a95efb68db087b233d840b134f13bce21fe1b75f10a72f1f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
