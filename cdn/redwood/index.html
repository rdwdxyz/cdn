<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22cf158d1ec94c483c3d64fd7a44a2e2ea241ca17e00c39b2bd42fb1c964e03be2b2a23786378f99e4a7691db13db8e3f1092407b84ead6a0d541de36569ca0a6204d2d43e7d2c5a0cbce870ed2af4d2e2440bcb364116aa4e4ef86938f1fb69848bf4daab85129e296924ee7435d9dfcc0cd39392d4a759dee148c8ca5ae9bd872f10338bf2d3f7751ab1890b91b970ff5a1dfef06ed97edd563ff45f70d075e58892e1599c6b447e23dd5f905d07cc9e2793fb8ddf931aa3259094478f5183037c77fb3505517ccf5ccd17245c9ade65c3fd74d5419a157af0b66b473c4d9a5259e89fb74ef2d97addab6c93ef56db3880202e2cf14cf737767c835f2f84fa387f703114c3849163a64f17e939667245658f6fbf57843bda94cdd6ba37a86bd67a8816bbf96aac2ffbdb99c8a0bf00269e263713b8301fa1f92f1e503be4fa6f37be8d47409a0ba1b3dfd3252c9e84bb4cef6654b36b8526a67758743fd98889ed36c9395104214257bd44497b995cb042cf96c0c8c5691efca6bda8cc991357cd590bcc9b6ee9a61d9696dcaae7f0030548f0775cf9dfc79b4b3a44e97d2af235c6540680dd7a4e3e7b52c04123e544dc82fe33d9dbb042a0937a206b880b9dfcbd3dff453dfdc5c0ae4850f750e4fc2b81b700c33fc87e40a699f8c4f6ab11e55c495cfa888a28d5ac19bfc16dfaafa3b270c3f7e4d900bb56a60241dd7d2084c7bec32b3560c84db9594b0e69a191eb29b36f9553bed66ee02a5ef07301b6f5d9b8ce231346a685f41e10e9ec76c898b9c7a774573ff835a51936fb5a12ded18bd3a5e4800e9b79a893feeb6491de8065d0d4c7a07e974555ef0303fc9aa3fe41785f96f862715f4e33f607eada2a71f9fda6bbe81704d798c5ac5a6f7d5adb9b9b168757888cd46a15cfcdc4cb69aa2c3caf66ab76bf1953f30b7bae8617af3e642f202e19704dd5877b3bba61f85e66e6f0c472e7e71afd71aea82b257cca700e56b7cc5f14683cbb65f838acc57cdd311486ab680c2afad6052a620a0ec86738ef20015192b40474b6983d340b4e3d6111c7200af48fcb06954142cb506019975ee023871fd3e3104cef1e20dc4ba7ea51605415148da5d52382534f89d176d91d417badbc69a28339dcc118ed8e711d2570ed077761d4954e161d8cd3121d848fe7fed534ed119a10da4c9bc14694ddaaeab3f66f22976baca6baa91298b5701cb93ef79ebabe43d7e5122d4c3dff3ad43d81b1ea6e78a5ce1665bf6d17e1f08ceb8741c2397cc283c905c0601b32849260fa0211420c04ae0d4f5dd5dd8fded49df45431a9d4608d655e3ad61725c95c044d025006e76cb0dadaffc1fabc1d67d284f71e22b570f83f035ba744b4d62ed703614f19d84b116bc2e7f3eed2adb3c20efef58f6cc043223b9699ce4ab29cb238491dbde04d6a7b8ea66523802178827b395f5f581fc9a3f27aaf18eb447a7b97c78d11407bba2140a590643982d7924453f24699dcf0567e72a19008a633712da208684b40de48d0325eab64b7ef0ea7bfa20de3c9d85e2069aaaa0d2fd46e4ba0b27bf8121475a56bd16d990823404012a811ac836f894cd2027b83e0502929a52fa0596f61c121b3219887fc27638e9b5db7eddd9f59b0556fbb8f1e688844fe2e25c2105ebb16966b367704e28e54b8b55f6e579faae34f7d40b59904e2dedf53bc9e2b7ccdecd1d2531a19d5086f092b21b76c00fe93917290d4921025726a2b007c6187c7c94bdf8aeeeb832455480f5194902ad9e53efc6381b325407a3538394ce703d36a3dff87580bfbfa646604e86787fdc8f5ef0b549a8599821f497549bfae4efd106c157c7d290162cee0d48f3b72f1c4131eada59e10004b4ae01bd0f732abd41d10293c13eb5551ffe0bfb897ea3335bce9131bf537843f7790ee48c51d21114a5098acaa44b1706d3a17043d13ea1366fc2e2c2f342e15ad68c0c7bcb9bc42b2415e7314731664104e8d7088d9b1a3892cf312643d3014661cffda3881843689d2c1f1bc7ac7441e2f2a44cbd51e7cf6873fba8d0fbee6faacdb6cdef8c668c1cebe62d1b7b1156e7dab9ba15177200c1ec8c03a256132f4f1a12b308cc07ba40bd2ccb3fd4345d269521f34035adaf9e251341b1fa3b4d2c7eaa11c9069fcdc7c0869f1a892917c1119e503a51c331bd690b574bb94d28cc5a39b1fe86158c9e17eb3f49d4c000eb4a2557395ebf59ea9091021d55e561941ba83a2f15064f9269c99083a7946920165e4c6ac7bb607b576f98c2088c7c82cc90af6ce341bda462b22c2effa70afdd7642e4bd6e28a3853bc2264fd1fb66b0a46a6595ba50fb955cd9b3782641e2750e74a0fba42a6104474bb58df2d6a8e775490f071dbdce51d287f7a243657031071f6d956ff0c36fd7b47966ea2189a4724efc8bec5ceab561d01b1cc33b006bd47b006a88bfe0a1888e53adb351f763c76090d49ac3f43f28118d5c0cbf20b43c63aa4148aff21775d494ca4cd7ea3aa79c59a55ac5825afeb1158ebdf8df92640d3bfc68c94f989550cc049480c185f932a7c4fefd013c3ecdc12e42104ba784d93719a7c15ee99f88b5c5fd7248b7b63d19e015dcd361cb015491ba70be02a136ac0248e60b86c464d7e6383a5a868098c1f1d59f31297cb2e16d3b6ddd6d730fe8d8e7fd0a69bbf2adb34efc4d5d2e7bd63da6108b62e5de8a1c7dc19f54e807f18e2830ae38b48ada37027ce148fd211862db0533740796e62110ad99924080a282b03a672617474775767d21505433c5eb835684279ff99b310f5592f11de37ce48ebb243d37506392eeaf0b9f42a361ed9fef5269fbaa223d1f1b34f735d4a2e381038d0e2e0cd57e6b309493b0e54dacad268c76de8d18c591bfac270c1432962f0a247e54c41e95873cd76d8861b14c7cdeeab9e97d2f4c4c38f2d2e2301773808a4f39a3f9d9b92b1e3b7bd5863d768233b6f206aaffb77133ec359f6c98e0be9c868ff2c1c56e60239790cb8a05c93003202f33d6a695e3c684cc202089d0b519c61d775e5ea384ffb11faab500504390a662b8ba103e7b363cf2773334abd14caba85c15816b12a49626dc1814b030262fee70be7cb267a12d70c23390c67e5313984eaa1ce4686a423bfdf133ec43d52165e22de7e786da3fed4452c1dec35e9432b54aacf9638525815289654a97a35d947561105b1c99a8ab7cd699952e8aa5d5f56dbee34ff3e81bfd2898994699a8ac846e92fb53d658ca5facf91cd9e649afead7e7992091f2a7601ecab749b27cb33936bd72902d907d55570b4aed856f97c7efbc8aa4a7662855ddad432b1f80a107bdb3ae7e3912da3474441a6910fea71d3fdd59898efcaa9323d82f427c72fa90047566cbae8ce0376016118011395c1aa3d44d28921950a61fa8581e5b9ccc2ef4e2b963341321a23f9883fe49a9967221e45b47d50aea058dcfeba2fa7de834e2abb296ccbbbc126ea8c7bea186d3390172814130344def53a65c982c26d061b442e501c4317f96ae88a75693d1f61f6e3af0c132bc1c2fe1a18cb7e09da3b47168986fc4453137d1149e9863867a4c0243b21c5f5d5db11bf4df8d989885480f1dcb76b0fb333b6799c2d77d96286aa8992956a4fe6c8426194feb1bd82fe91bf3b1e8174ae173e260ee825458e4532a1895e825c65c7ed2e17931f421bb8dc1dac103b4a70eff2ec4c0a80c66ef9d34c2db08d387d0effc65bf5fdee77c3c1c776be96ae8dd23350e19052358874fb26db4858ce2cfae637ad87da810b41f73302525cd8ebd6ae660e9effb43408a70d530bbb613ee621aa6931b0fb7ab55f2b9713a5faf2fbf1ba6d612bfbc495fe6ad0491dd14edaa06cad83b2f769e16ffc146ac2f6701559f77eefeca5f862d91fc60e2aef893ec39c445d4f063be8c94eda4b946c83cc7d579567218d1cf2f25d3db3ded7c3ef5511ef908bdca134fccd298142a2bb2b4ae89bc4dd36f528fa6d7e933be669a892bed67211426761c2b1a2c3b9f9ae841898d17824cf1d317a52c6f6d0002416afd6e00dcee13495e52e921341e694e10f7f543c4c52a1f8c4eec4ec194c1e6007328b954ccfecf62ccb5b669fd00a89544f675ca2cd41600f3fb2bb4797469116fb25653bf0657ebf1c06ba6935bc33b67a3b6101406f804306166b866a436ca239a0d28576c7e95804d9a3ad08156f8f2493ff5a0ab946f4211226222453e53e1c41bad15e1c1e0cb2420d9602ebcada2ecd8376a0dcaf21ac4c9356d238791800bf307a382e3e6d73ebeb564dc6ca3eb8945ad23f8c3cc22d3ea4f648262e192d3057bc04d7b8fe12770cb99409f4f5993efc1ba5ecef53e8270af32dfeb93aeaddbbe75443edd260484c7b4582d55280336c3ff41ff5d8a04b3873f18ceceeebf5bbbfd3a14ca5a0ce327f9ec1e96897291fd5025c8d3ca64006110b9b4fa78d299dc931e0879ce8a136af8c85f705f033209d7f2b48c4022d8d28bbdb7e2befdc01b5315ca852162ced2255f3ea0e4e0e00584ffff512b5baf2064348f6e9e63140b610395c73618f3aef128d8295450e180d99e3f2e8f84891ee899e2b9d1312ad5cd496e6ef47f9437b5c4a6c8cf87c393dd8b74de9047e11ff41b977ecb4a5e59508e6d10d4cf2dbe105cce869f27aa30fddb3387e5ab94144f71f98cad2448349de3b0f20b7633b28e66fa9e54c0988bd2dc752953e49cb15a143b222cd203c2fa2352a40af93db504c9cc05ef0482e08cc1f3222b00453af6a62a8df10ddeee54106d8e09277a24cd77f784ee0cf226da1438821ece4eaa1abd33d1720be87d780a11329fd8c8f4c370f26a6d2408055d2db1538935a8a123b6c30bd6c38109b5748bab25d4589ae01c53bcd1bc72f2578420f9a90ceffd46d96083ac8f12b2e8930ac2743fc9581013e1c14462940edad53506fbffdd84ff7c6f1eb4329cac34f7f20eaee98f14f38e24c34ac3755796ab9d571055fac6c47b17c467c05e466b94363078d4caf669e3196e23ec9e9dedeb9e4ecef2bff6f4a2137c97b287552070a5904085ac874c848e41581476d93cc122d5ea83f299781a81fa81531fe289c9a4dc935683a2dc0434a7102d1eb6bb4b60759c5775caf6ee579a6ba25103450d8350e9c4f1ee649f1e5dfe8f955c0fefff85f0126a12ddafdd2af194a181c623230aa900c096d5abf8dde8185e3d7d491c2959d5d267670ed3a287043849238724fe64eae7ac19961826da9325d4b385e46f0759ad45eb2dc70774f3861fdfca1cfce49e4e6202efd94d685bc299a200a38ee48a92964c5115a10561ca39392b526fd04bb9947b6780fbb311f81899cd85adee8ff6823973b07cf93625dcc039772a8b2c53c2745467565631b02876dc6fcf0aab1e4c8af0c4512b40190071975e23014c4ca9a96536ee5fb3282c93d1c171651db11435e7122e7dafeb94c9561cbab56b437f4ec8833166c605e492e152591c56aafad4157a161600e40b1eda13925500eebb2546309c57a9b5fd146e46a365e7f554279cf92353314d837895eca79e6da32741a19b5a59cf7683c5835691a8e3fc228e60f9a906b1429573d3210624a1761d45047b5607e1847828e1d83dc6e832cb1acd26a3f19b7992e2392891223ab01dce74c98acacb7626c3035cb61872d46b770efd8cb63fde6481b75f4beeb46f91bdd33aebc319b0ec6a76e8840f6c800601a34a5c020c90656f7e11d4ff12f8fcc72df085d84ce8116de47f1f93349960de06408d67d1dd6cefe3f3516e78cad7a618d497b40bf788e5a05217bc942e577ccd4045dbc450ac25ac4cd0a3767790d849e4980b91c4ca712c9a775ad20a90fbc1a68d4f17eb351a5506fa6ce5694a85accbb2bca8ada4308fb8ed254400cbcbcfe255271682f6d11caaa126edd21ebb35e7578bcc7c94396a08db7e67e2560880b5f8d5e124863ef74adf5195f1f649bcde8f7e39f491be16a3e6de6a6709821c737528e7ba15602ad44df7d260e2b2aa8ba8527c8776cc49109fd8463e0d194d29a95ca06c0e8dd97393017fffacd191d11864593cf68610bef87d635d0b1210ad1b363bb4ea0cb52068b72f6923d8f651f9ad54b23d711a4b785679340350124ab142a9b60b323f847653b7fa97b6006879bf0a6a0646dbe21bb29f22d3b4a4d71bb3b859480b8e6def7f73d984c77ad873fe92d52697c12a4f2c87a6bdfc320a42c226d198fd1cf86edd19e2d414c5da0dd8e6412af23e9a883c68a4a50bcde9365d3521492b08d539502c00bc3e52cdea30675b63eefc7b192de7e099ce46f4598cff92ff329927d6335246fe9f3b62eb9cd91873a08d69492733c7188dc546ece9f6574998bb40de6e172fed2eea52f5b92b8f9030566bacb189ca18a5fcd95fa862a4f38343a9327821538a7a3fd5a1a9f5585e173d41d7f07280a51ee5998b3cec153e0bb1becdafbc8e38aec74d3b845ce9e9a657ee205e687949443dcb8adaceb2651e2faf60945a42f48e8b6e349424643d9334abd0cded0639d6af1009c73e0b35de3384b611d18629fea9745cde692e8d2d658f2cec4b65b00050508fc22ea6c64a8d82c91305150041b1d5e180ffb3ce3b07d911fcd4f0ad7fada4610780bf634fdfed9fd1ecaf29ba2076154062ef214967ad59a330bf31847a066b9af3e03eb8873f20ceed785e3d58cbf8e1ba409e9581dcd78ec8983eab986e8a2ec1c938e3e3c0b03f8de915892cac9e3ae0da7cc62486d650e78376f9c59d4335284728b8f5805e122a9043f9912728aaeb7d5efb216afbf099a3fa7658a5e778fe9083f0a75519542d37142fc4c428fba7673b5dbe3ab04dd9d2fce319ee3f2d177b20006bdb8d889d5bd27d707bf980051bd8e2340325a9463348ccbfbee60c110971d0dc5033e6d37bc15efbaec3aae6ddc59c9013095ba04c7e3f24d43b5afec065e29ca5909e08fcbb605abe44dd7927824104e5a54f45612ea3a378f4d2683b3ce2e77e4e8805cd2796a9ce71d5d721911e3266d89146cf51b9e18f37f9aca8b8a320a8cbeb41982fd635f40920cb0966a0ca7d005b9782837bab44fc3f9949117a04ba077db32fbd401a0407756f53b9c72f7bb6b0bb748caf0787686449f67fef512d0951e2c9335c9abf55ff2e863a3b189c79768f72f49f66a9ecb6481d56343bea879073bb74228a3db7ad14f9ebd4eb8b7ee20d534ad0f967ffeda5233d3a25981ae51fccb0eba58068009de7e0e22860f844f8901d3be38a12aff4a5b3b5c4336a0fb18ae18fd9d9d89a1c90014186eb91822cca1cb1e8bd81ef55a9db9ab698ea9ccbc4d6b741f8b9fb89eb64839e4f030b9acb8f94d2ec751a912db1663e72b0d2b10fac3cbc1e740dac98035f5980bb6c0a69c94d09e91c79d9fc3a1c9b4a486a7522a4a1c6edc953f1ccb7886b719f4dbe5b9f1e21abe0891c2e5a6585b48d08d0a8e2809e47b99350d3fdb9ce0a017fa2c72db10e2a19f73033e367fb8511acecd4c85ac6e5a783d29c73383f1f96c7f3751f2ca6ca0ac5fc2f705a038464eb29012fa85065b49c41ccefc7015571c0ec0815561b21b03e9807d54918476bdd5bd3ac33076a42d8a90397ed64dcc7acee51049ff5c937b173080f1798a9db9faf6ad1623f32ec6da144806c62c054c32087e124a96dd37069f0c9c421b03455dea12ebc8bd9991aaee7a3185b5f2b185b08c6675b3df021229b9213aead11cf607b56c5698d645778ee20a454102613b386ab29ea960f801f8c589c0dbd0c340e83c13a71386d9d1231a1ab7b6b4e00394844b91ed5fa2451c35b1596d089c344a70387215d6743c1c721a048d3c32c378d141a78c4dea6c9b8da3eef082f400b484969f00b975c81538d256e56797034b1c494b1b135ca401b5fc59901b822f51e044cc6201ba65b18e3c1a468a1c0998deb8d17415d44e93b61e28c0d8752e26d3618a650262b12958f3dfdac4964fb1f2869c8a9faea96d63cc8d297b37966e08ae69234809a537556e9e03f40ff27cf42c5bfdf7016af7f84afd208e3a8617520e18d942e79a6b72d7afd1e9bbb62bd63a503ec7c7ad215c167cdd125b5f2482dfa2dd31b32dd09ef4d44ebd1ae596105516f51e33df04dff69696984b080922f7f8d560e17e7fa87d60dc23924bcec333fba47e5f6414705abafc487c9ae04762519c5727847ff62e81f25ee3f7848dcecfee1a7b69353da0786a76c29abf7dbcb54c649f3f46b8177a7232f20be1f7883cf48b7bfdd7d7738563e1c9d9f49396a0e230115c9adb9ab4ece8a0bb1fac3e17d50b0d4057fc694324888e45d81afb09144e6deb652bd6c0696c2c603569765ed6f739729c3136b770ef6a33679e6c340da4b7e11123b327524189ede4efab2de390dedf6d2f3d015c9c8881bbee526cddf3a2a5134657b982c5f0a52a1b1992610edd5e4dce218517593df9f222c5191fc10ca4f10bba57cfefacf2ddb3c6322bec2de9fcce2cc682f0a3cbfd4d5bb722f549afaee626bd6cdf800fed1174c48ecd1aa9c1cd7b06a1a15e763fa4af1cef49562363a0559d3d774942981f2ab7c30a467a7f6619dace8254f4dca1eb11cc49ce47933dbbdf6e30d4a77d5915831380003ae0eb9c30abc43cbd83328192da1dba93adc11ef620b9df0ec3a7291c6e44f6fe85e91f98c8077d15d2dcd2820d5cea7fa748e44e1cfdb45571da1369477fb164dfd70189e8da9f70d0d47b71e10a69638fb175d46040de675286dfe9bbb72b02ed4c2318648fad4f6d0188356475c20315eec67168fb4a4f2775476ea3d8bdf861bc6888cb5c6a011eebd769ae41e2e301f8acfd1673c9e1bbf851ade80d32b645fa8f04ce249df346986c2e1cbfbb0911a08fb986a39bf8738e94b4d1dbaa8d9f975a9d01ad9ab83c970c0c02da1b52b0b7b17520d3716858d447c771b549537b6eb830064abe14d5115108877e8220527147cfd3b5a39e2095afaa8e68a4e6a4ad4d30c2a9b1a455ff9c20733148365a4d55037cf1e64a8b23a9c6fa8d56d99cd3bdc0e8c0ce21343947fbe040faba2044fb534f778932750791baeecbc0752948076399d38310ac8a8c0d344f1f770a832997a7d1412293224fb044c49bf0c041bf68e0283ee8958448bafff453fcdd05052cdfb80393c678cf3928a01e3244415eaac08ccb5484943654ba8933c0218204262d1669f7579978b1c7c549418db77db73ed65999c33e9e3eb0d02cea81ac3c8c41df190a6fe49a4a2d157dae41be85e3fb16587faa2b7dff402812630d33717f3abce11bf6a8565bdce7db5257a380e38abd404149bb1c4869967ade76fe3c6ecdaaed13c6a1945071fa509ae05d70e224eaf9e07d6c50d3bdb44ee5fb9094a80f58fabdfaf1239a4f0d800085d36eb5b25f026e5275cce30828cfd74e7bdf71f954c20ee92aa382ba4765389b9a467a449e50433eeea001c6a60e2e748189241e44db7a449e01892c407064012f1aa7e49333bcd2d19bc8c3eddb5fc4cd90177d6a322bf295f0fe9bdea7e5e083ec3fb2f4df9adda0ddaddb245b24fb7fa02465adc7819472f2f84499fe428406b6f66442948a39e353026f4648e4bde9e3850a9b412020177887827c9ca868e60c0365e7fff2146254577aa1406e597c0779a8074a4f91f1bf8c9fad86f55766cef658837a9b0e6454a8078d3fda1bec32773ee92a522a29d312242100e3be5b02c8dc2f22221714ee183daba3c73c23ee010fa19a1ea2c209f068a247d0d9074235698a8a3908c8fcd3d2d5ab12723e225270500e998675233c7d50c942e6c41a761cf8cbf7ca687a64c68d7d375342e749fa330a54c8ecc72ee15c0b7ed3e234cb1feac1b1dc4c17c23894981b5788b7f4751b6706137fd75bcb65fae70f3fd9e28986b2f4d67ec2ac8f1583f997e4e868ad9127397dbabe35ee28f00f06fe8f57defd281ef837221581c50ed97a6a4a9092e350e0f95ac33c3e8171fd5e0a15c7c63e449cf77c446823d0d6a324005c297074396a28f57063befe27d13dfe2ac2c0c7b58a2323f3dba5e3bc0871f22be55ccf4de2c2d46b7fa53d4c85a45c23e4949536fd0b75d456c14ef7bea777dc5058f8fe068f445df72a0103e21fa52a0828f556dda7cc3736ec5102154520ee604595b6441a7ad8976843dd7352c196bf33cfea609eda9830bde4715a66372089ed009f4ed7be995eb1b306d667a3edba5ed835c2c9d5cfc6af0b371931ddfe01e32f141cf49891d699e49515d566412d28977bf7a9f37cb9e952cee6018ff6ca3a36079b210fcc319fabd2eeb69acca2fe6ea86999de609e6cdf24d5c5d0840f447a9ca2b6a3d59bc3b0594f29bace3fbd90d54ac016a37b0a3533abdd6a9c3a1b0fec59282b434e7d795e1fe4fd5cd37a7ec762bf978383292ccc97e8acfbcdc54a65880ed52751e8a80adcc2fd35bacc056d657e1a5e8401b31989327991a4c6a49660e24023a88d5e7422a4130f0fe855a69423026582937ce57ca86704cd99621bb707537c14718639adf813aaa7569b366efc1d3a6505e3985bfc20d4aa2e1f6cfd0914df4f2a3469d5c2c349687fcda198cbffd952e9988edfbcce8557f8308ee9755e5f259717af0160d62a822413a3577623c9e7fbb3873d652cfb59311454cba89a56863779f55c804dfa7a1a1ffccde351d5b547370ef2ef0d782410b187053c472293d77ca1dd909b6141f8540eb91c4dac567d5770b79722f5e853f85d55f691f409b49fe0349da6b7bce24271df68c7af7160f39139e6704d65d027183df5508c2456bc018b43e183da1660aeb42920c21d0731e9adc0befd587f4be48549446b57dee23c816ebbfeee2c3536d123db75667b5839dd9626156cf9682cd1b1e467e694ceca7aa5038b5a5ecfc6ba40d3655e6f0c5a7c6c8cedafa99ce95f0f4b230cb788cce789e74d7bcfbd3c191e9fcc7586aae4fa214701aaa80018819fe78eda15dad3f0728241a5c07dbad45c0bcfe1e8633f76977d42219e69a0b83a3fb24733da6b8112ea2ddd872f8207c5594f423864cc03966c7b2d9ebb35358e10f7fd6010da31c7eda772566c7028a45f30f3e39b46d4a6137d0b2bffa3f00d5ed85d88155e8676697610a986106f674d80356cb032f04517e41dd995a16268179188f7250242af004bb40489d711744c0ebc6c0c45979db4c991dfaec6eb07a11d8463e959939ff40cb63a5bd96f294f0b37df1fee0c1b3f386ca89cd50953dedd2fefca36d3faf9b465bcc1b4a945d3f1b7a1c64b4ceded85f23205fdb83633c0d9fe5eff0dec4f4a197a1274325f7af227763b5c1c8001f7d5a03d151edddbed1cea1673b814c9d848991758d58d050c8dba0853ed392041befe9e756d4fe2759fb612e0ca871debf918da7806060994801bca323b8e04efefd9093327e3c492201f1b6e244e5a953aa56f0dd99110f1df59f5a4059d22ffdcaad7e0df1dcffe2f2b226fb31701e5a4bfded4736416f5558aa0921de2ed57fc004b913f264b65fc16c0ebadcfa0bcc7e7be2dd8588ec9a12d57abfd924efe2fab605d92cdafff0c03ec23f0535a25a72af54f87197db673d39f2e0679fce7f5ca339893d014f5366aac5f3b609d8c2d61f0ad8e98e8070edba53743ab2bc598948b418c817bd0108766c20009bcd26a5966b33ffc448dedbd162b396993bd1cd827aa69ed44801002a16eab36cec2617844de7dee28251fb8f1ebaff650ba210ed4fe27c7c83f7b672118cc48fd5edfbc195dc70db1ec037d5f06a33d93a8c05da1ed8f3447dccb9645e6b58f0011ad29268dc0ad2f4feee0d828ae709dd0230cbadf8c398a8ab808475471d9b56d14964fe46a675f4a051c2b762cd3da8cb5ffaad499ed720d807197a5d8ba025ca6cc1c8014d4732fa3424b2a48bd23304815a66c745b499b2db67f5d1e0e3fe22d039363c131d9271cd2ade52c94aeb308a957f80742569f176734f849a481909de254f5282a7e6e786ac8f97830685847d125a19ed0ff3de3bdfda29b1be2ac1cbf84c64fa5230203017d6fdc820d27169d7b3d5dce291d6484978e8d8ea706805c4553fff092cc998539ac8b637a8238e5d09b3551836527b5ce8a00c043f71b4f20cb4bbebaf7f25e993672234a8835ce3de85c46be0bdb89ce8cfa761817a15ed526af30a90ad2e9a4d231520622f96a399882876ef361dc848830763b12b8563403832c95522ab36560d897bcc1786266274c7620b05a9f222545f4cfc46038a10da0615139bbb644265dfa7a0df1c6dc7a94d687e6ddfa227d72c24bc9f18a26aeb7944f1549c056cc8c37504390f0082d45805f84c2d2fc0966ab7f0469d09e5bfd0e81f51bc5c8ebb575eb13938378d2ebc77755e6b13ca88e6b7350f701b41457ef98749863e4920d217af634a636c1faa7be894f823e429263a9a7de26eb9c1da07040351e0ab7aaa5636cc4be4919ebf9ffa4b8dccfb277d2be16152216a90dabd99dc7446143bd8c9d948700e2fc2760f5239124436056ef63d7ab6524fb3f74cab84200ee4a66c5ebb565bb304dbf694a8eec712de193035fc6a914f72b2e425e6db9bc0536f8b2eb0c7e6357d8ed8e9630f8334e2e7238e4de928c48ad2f6dcaa6bdf24f4fc70c9cb5a7a756b7c184e6699a12381242666071bfab11a0691def7b2eacc1dbf7ed68696142c686fedc45ac3d628bf00371ee7e8b5451483b163691621e00ae5781817ad248e29cc55a702f99930905dd6ef1423b164d7bfa2ce6bde7e4c30c9590192b1d8724a62f441cba8c0a428dce911070dbb913ac02f0b1d264bc0b379a27b5600ebb93957b4cda0a2612642b1c23189a71fd002b1f830865ecabd70a92c2903521e98ce1b17298f1db3eee4fc12e32a0b9842d3a398029013fd72773236c8b692ceabead681db568173a57686941cc7417951de2b397abdbb781594214e34d07a9bb8045afec6f64a238bfe8c16737b3da80bd3193f9ec50b20cdb224a9c255f346172f040e52457844451e6dd56b97807b6087dc43941d2905c5b3322ad7fad8345742f1ab8da389d7ba7f8402cd0559cf7629cc544795f722ed2d123627a805c12fe5225fa1d4a8044ce23ee1944d4dfe2e37c77f8aa992b6cc3f9f850f7b33c5bba4cc2464bb992ef91a6d21fab3860f61bcb5643bc36cd95bee59e64dd389c264697975328f97f47994727de565d70af8a9191221f95d5544792925861a9c5acff920944669eca49ed870efeeb598b928c9b37d379e09639198fdc2a68aec373acfe64c9412907d405947727f964e144e85e865728686534b117be481ef5f0b1c911baeef862dea593c607d544847d0ea72a92d78291567cfdcb0a97346d84e6cb44c6c3f0408fd30be9f07ad304c075504c2c72b549b8d2e19424f26bdfa54f7df44190e5f127fd6c8d1b4aada4df9269e8116b2cbbee31d69de47a30be774d1c423f917c39d3a705f8582182355ea1ccc9601ad42ffe1d6e61e95bf88d3d322f233cb76821c4159dc86b515a7f5a4bc08583b10871ef5705824d2de260edd9f11b8bba77a1e0fc7278c8111d25ed938c7090b3f2ecaa51377f57ede559452eb868ef33b2e51e709b4170c22927a1c08a8bf4302aa7b19846abb848d8c4bef3b35a60a57a72440c34d4a05454ca971e7e54d71d0fb87fbc756fe9abc41bed3bff67098e268edaeefe77feb3ac4379ffb525fa8acb2a273b9c2141afec1f14f0b4ee5e641666c5a36ec0c8f1875499a33038d97dcde0b9d40cd0406ab4c4183bcb08b4aa3733d76a523446464c78fc62b40cf121585805d05acc7f387eca7dd3f0deb652e305f322fcf249f6f3cbf1e9cb14f05ee7637b663949b5753a9cdc676f23604046fecda26db5fdb6c200a4c42666f46ea642dea5a552e6a5135c3a7816b2dd976bd5ba4363b05a0ee6ee64c45eeef622334b16b7ff995ad997c5d1f977b3c77be5e095a950a674b28ce68d622ce76e71329c0282ecc7f840d9e0bbc64002d538f7c5bc7f2b3845dc87ccdbaffee028d660a438580e7bd02fa162abd29bdf518130b2932f1d71f7aafaabfc0f7226be2fbe0ccd20e18dbabc68c7b746b1eca1624b101d2ff732554a6daa33f1696428fb05681178edb12cd4740ae297f605c183615af877f79b6b3a6f14b144e6da78c8b44140df4b0c34d625910c357a16ba38ca697a233b97a002927c0cd57b3c8baed1caeda0e53ecc68d7c9b67ef13136f6c883e29008ef4352ab4c594ba0570fad26b599c5445ec3909b19e65f3ca422390c9def4cef87663ee8b7ebcef7d1882af9666371adc3ef7531040344b7f49158f0e1c10ba3a56eb446d9888d6bf2df884ce91f2682c83a3f369f631f5097e7c82dfcaab1fd3e79ca34843bfe8a6e339f4b2fae7fff3a05067f15afee129bebee44805db8db0c0c8c45844e8670287ee20440bdfb3179b5518f23c46b7a52941e4ead1a058c8ced20e7717a302f2ab668793dfbd40c46f3eb70ced65d52375d005ff9506ccbd148b8a4bb52f090b9f1b4a3f0140f02f25db3cf04246a74b0bb5cdf90a0a3027bca96f8b107bb5ead8e7103d4052fc2cf829584e4dc1d678d01d50e420887e28f2f1400bee7693ea5af537a8a6e4c9bbad1cee630433e472ebad2a1d53c42985e3b79b646cd7d7a88b0905510be419658328eb79570c222a6175db4ae5c9a24775c25ca5d26f33f07bae929aeb92aef01a906f1d0791a53e4040e27ccca34e5dc9bf46eadb32478bdc85c76b1ff85df02e7729028aea69489d448b541bff8ff484e197ed1bd29c938b31e79301c3ec0c215d7d24988181ae55f0feda4cb395dd1f8c67582b3f272d7806013f12e70fc18fe68034070e93594cdb7860fcfdd5b7938c46bd84cba452f6d52d524e83f67129685d2155eb5477c56197deca60cc67b7d88c8faf80c3420a604584bd809ee1385d9c36ad0b3c75a0692b7fd620e6d5b1cdf84172db1e8506725eee26ae2f1b05510f2a1df9113514b485dc4d891e05650b4e8b51cfb50ea4c321624a8c015b36ad7a6239f77ad1f241354bf5b594d36a82d8f8ce070b0d05bff5243e224401e3309919c727d5168f51e00b4993ae8da52131848427e2e51c65201770ab25fe4f411a3b95ca30454579ecceee8ee5f43bbb1abbdddc7b4da3fe3af9453a2b4e89cee4043f8bc951b0515628cd1b1eec694abc4c49dbb6135837e5840a092c07bc7467b84498dce42d72d4483b6b9a0545146de21c143b8144ddd4cadd62c625c7b7e1e99c7072bea3bd9c090e18bc2e071e54597bf479dc8dd997acc5b5c8367da2007f9fcdfc0bc1a75bdce41bfd586ac41b03c6e4433c466ff0713861a5f40d9d9674b2b86a20c676ff1b6bf47904ed74fbe3ba0070d12ec04b7dc6a3331ba25f8811fbcf422cce053ff0178a18502e897a56c12a19cdb6a43b275867ced8991a9bb6cc2f7658ac2f16c43480e023b1964ea4a8b69f6754668354ba10738d1a0d3ae050d06378611873f10118c75801df260f4c559ca5c13b2dfc4be632e62996c1c5ad2e30386f2a50c2754f8ae315796351fa70a8b756b63caa4d05d82519ce09dbaf05df99023e1e957a4d295d11027f0e92f220655fedcff5f2ce8b0f0ca4a99c6eae11276eeca0aa183f7902024e9ec739808ddff1720abb2bd79ee705429281a052345cccd6e86f5be8ec618115c21e5125cbcadd08c7bec6b5fdef459583f8348966e609850288b3adfe2542ef51692c4fa9e8022c47fa1328f7c55daee745958e611df284f22e3b54e42f4d2a5fb82274dda71fa0dd14357859854a956d2ff14937defad35750ce9c17ff85d0a193946c5bf348a79da0da79f14ae97adda4ec50f22b253a1b82352651ac911cc8fbaa33777d15eeaf841ff86d245618369b3c16b029cb5c6f7f8e5b7c43d2af49084c3f535d1b7168839f77e9a55f3903e0fe2072c451ed6f8d77f1e9314c2ae43f6edde896424b44622cc44cf1cb2bc473e297fee01ffcb461642484ae04be521ab9ba39aee59a33079a08c7e4eea7cba4d1faa98d7cbdecd3e32e3e74fe8b91b3ad313134c8e1a46e9e2aba7d3b99678d193a1929c7e344f01da12bf3451f31ead259ead3ce6d9aa256ecba922d1c65203e16b6d0f157788f06561302e1f6bd88e19042e8a8795ec22d93f58db3021c82336d1099f5b2489d75e4d81953626b6f8bc8cc7e9048f584e787b9e426d1deaf0d2ca8accd265b61077781b78defcd97ca2c26a2ddcc61f33d3796ba094982da9482d46c2ddca59481d675c07aa52bb41612cfc159adb10e33576b85edfd676c47e414dc1b9b3e3f35d89dd854ec9611a710c7866a08e3b2bcfff71c58e2fdb874e10bdf2b8e4af9d1fb60607183c1b5d6294711d24079df47ad95971c54478e01cb779ccdd50c4d072e399af8ea58c48d9f4719c714f2e776789a54068942621b7d63874561dc01dc47ec78f1ef8763267eb9f5075f2b7488c39dff0401efba6885076e0afcc878eff9262fcf43d85770e7cf5fb89685389c60f216f69bd2cb60e70febabace0460aad41e34c695c1cdb1b4a384cb45c6ddbebb8982b64d879080b54b578cf7ebc8e44836b7271f65a10213ed6e0f832a8c6fca7052758032fc8a0ef11bc435feef1fd61abc83bd8b8c20dc2f284803cc889a4ce3440cefb01e2c30dbf700c06d1f9fd8c3d01f9b2236dcd9290a034f5329800c069aee019776296502a5c8456c7648b0f444f228d0554809d162b70bd1f8a0acb9be7c7a7bda8e10714a2c6f732b6fb21a8341531e113db92e8044bd77b57e4235ae7ce2c14bbf9bb63a8365b9c8c6b4ec716a3c5f0cbd4e727e0a04fde02ba7dc4adf9b8e0258a7dc652fcb6d92849e7615e6be6e4ee069d3e5610e52e2c3b0621bf800b80abcca37308faa4a096a2e2a9aa9393fb4390fb4d1f9292251112616f26f862aa7d8a570a5c1e00462127c6597ee250476bda2baa5bca070be8e6710342eb7de878d0981ed73298442bf03f7df5b2156a18d54e2ea2b33082a53441f26b57693a32024c0896cb956073b7b5ee41adb051ac783a6b2c9c2326af488781c1fde01187109731c068e18f92546440ef266dcb1fede0797ab522dbd224e12153b374a65e120fa0c530ed5c41b320df9610b9cb85359041ed2a1ead802cc6ae0dee738e12d4c38228cff144350f441b7e48d72c41b781a083e7b2b5b451b982b749e964b93caad3c91965203e0eae3f5c4446881125d618c771e78f9f07c99cfd54f034c271a19eb89ee48191b704e76086ba431494fcf996c88148f2bb8da17275693102fddbc22824b9e9ce8d342873f0ccf0f86461536c97351ffcad342e4c7fdb4c6488531e0006c71a005d757b6022a6eee29dd3ceb8af61101a5e089f14661b36977a7f6515e8efd7d8a00eb34a01fa5245c1cbb2053e319df7ee82c5461a8b639aef3dda719557839e21ad9b4faef66604406c8fd9161a5e04367487419bbc8b4d7f49e98f02110b1a8209fe12612d4796efaef17cbcd13c578df772f4ca026c68ed071513d4daffab21f4c19a131e236cdf8c0c3e71b6fa126ec6c91764fdffb1e50a0e243a6bf54fc6e131dc180f0f6c778f19734f3eaa6f8f99469b4fea293faffdf4076fe13bfcf4adb7e96cd56aaf95f16af15811cc2ec9a212584bfccf47bd6bd7982296bd356ab7052d691214b66be011f91345ef85a7e91b4fb96116f5c16498821e16027b9ea83fe01f0392c77873c35c1d954ebf89b2a1ada9e5ec254e659a80c180893851ec7ce48f72923fb9d9bb56cce134282a4190cc374f748fadb6703d8985b92f18045cf207cc77f8b86d83d54cbbb91ddf48369d355ebb797a4bc612a70aff4ca1e4b351c6d41edd34b7c03d90178b9350a0ba57b881312bd683289199938d97861bb1ac26ac6f78156ca26f74fed703e88d8f60949147ac8a066c8085c7a07ff640a56ee07d36c0edfb0c8c80ee75fa708e8b3b4f9770420a53a7e8200007a54766eb3b92319857e5ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
