<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a26a41c18a84486d8b38662749daac0e42ee939a1894aed1d24041605ca8d7f2088fb248004653ae6b479fe86a723a5b09de4bf400e2040fc2e1f1f77ea66a233290aa54991226504b1294d1021c704f6a056300417f76c04de6d4da45fc18d45b3a1f34b15ac8f087f022da36658def7180d9d2f4c19b79775e4403239a1e8cdd82cb3ef21235632902b9f91d7eb7bb29c2bc12449be93f23c0a003ed305545ca1cbecdc7d264f8c500c283d93c3e80f0b9c6db89810fe9eb924be654ad73b82790e88e6a98be2ee60b26c648c8e21e2fb7a1f2eb66f5cd16418eb3997f89dabd3bf0ff20acb0f27eff7aed611964e22f255395fdfb13c120c01688a101f3645661ed2283987c6712783cd4f63c4541dfdd32c1f23e33bcdec8ed84701fc059a3df20f36f25afadbb73bcfc2c1338de1b34e958a30a2d621f8a945589e5779758e602c7a50a22cf1d6ccb2f47a32f4a54ef50f41cf63f58f789a2772d10aaee06f679959f900e380c1a860494aa71f8fdacf1f94d7b04d6e8a4ed86bdbc3528f81c7341f89e66d30df752bd6691b526402f10acd5c8c352ff51bae03faf22468d1d1287eee64de7beb90ba0275be1a2404329875e448f71d82c50222a47505c254ee0e7ccffae1f5eb4e0317d90ac7e87ac36acd2121ac43dc2c0f68892ea455f9780634a7b598ca6e674cb2ad9f4e09912184cb03af322b85aa47fa4317a030f266eaf8e836b54abb6a6547baefe9f5a8910f30afda7db18dd70f9564082ee394111e051a75bf5ffd56d322736b258b71fc47e4eda4a2aa6490ed17969fcb9a01dea969624f8f8c5ebdc7908091fc0e8667a2e434f392214c63e552a823bf2af1321c15d44d375521e9caeb4dcf5b327bdbb68acd2c252769101722f3c9b6f7ec4f54cdec88a2527b6f4e79c16a2db7da0518fe3cc5a112413ef020618f86b5f09b65b24e2a07723b0b2ccc9618a6c350d811b75a584f63a6024e10907c67a333d06f13b7b602742a1bde69317136c0e49a24d9bb4e3995ccf3f82d450a3d21fba08cfaf83718f6dce786a7bb07b01d232ee71ff58ae4d2da7f4bbc3479ec33a4d864abdbd79c97c2bc9ff5a1f48e5d018eafa9e62d26ff85fedc3a81e54dd3bb32396f4fafafedb1fc2037fb8cd619a4869180dcf8fae5d90899a63b2a8eb216e34633fff41d02ea5e73520c97bb6c62c167f6d23588b57e1a49a547b7c19ab4b537563d7bbebd12f535e9f5b5eaed373cbc4e9c7aeb14a83bd3ad87c46d12135be293f04d3e12d39b7b2b29545fdd5c50ee0a21eb5b9e774abf0896a1ce86068816ab289289f0598ccbcda3bf6846cba7fdaebee6e0e5bac5fbdb4eb9a22432aec775c9a2965384f3901f77aba767ff34f646d425c214ea904683b4988f8ba1781e0e55d89f27a4836d0d80cc2d6533dee7f0c0db4dc3e15c9eb39e00fad8ba7a6db4ae45532fd4f664dff21bb3e7d142ec6f35d4ccdc30689ef546f5fa3988580912858d7c0f53632d74755b67eb21c3f15197b02b66a990aed8b48197306b0fdaa74c3507c874b342ebd20ed5364085f5c672b3056932dc218af3178995617d86e11b3a2019f2dcf347290473d766753f0d39d32dfc7656a8e24e0852c022efacca2e81384e9392c3d5d562e00e9df93cc001c76b5303233d5c27f96ff351e996f3504ff6e6e85b16320ae5d47ffcea16fe611588270b7e6f923edefdaa20d06351db65cdb2ae100dc3dedfeeb2e96ac1448af7bb34ce3495a7d20ed766473f8c948ee99d381dea37024b7a97af87b6fc411ac016632db3caddd2d2bd032decfc4098c05f3ecf2972400df4031b69bbe215f1f93b965bdbda6484f1a5dfad81c4a2d4373b51be94d9b0a143843b25e3e797411a9e3fc4d438a9c33e95da845f73c4adfb3f67d5213248b07731e73e89565f3e92257e534db6ab1a917c14682a0d28402835936254def77a7d512a26dc05012d50430cab3af06ecc05b3ecb9881e25c423d9b76dd6363a0fd813627108d5b06145546cbcce1c35e27396b2c1cf1c8038f84b67c4cb31f2d16bf9b1bce29201f71f140a6b6727d34a2d54d9515750f8ee7df64091d3015bd1397729e6b9e2408a3fef38c8b6aeeebd0af8382e9974c39a898e04dcdceb8dbb14c6790db6f7093da5bf9574dcd56e91c88579e83fbec14ba55e43bb08cf4189029d7788c8f745b0c6658beadff94c1b8e1b7a477434111f8d857844904ad05dc2dea4adb7f8cf9a435f84247015fe4a394fdf03d0845e60663c19ff01d1c3d1e646571b0564660dbf940a9af25c6f4d1ea0bce895b9b0d4603b1e83b435f4c746f5b4ed47cc7bb1250204aa6cec3b5ab5f407846692eeb7d35c090325744fb14b613ce50cfdfd2de5464b4d0b5789d0bbb4b1277efcdbca559896a559c1633df39aea61575da87976a016519c5a10697b696c15ab43c3bda13296228833ea7f2760b51092935027acdf0aaae4d4c8b20ae4effb4fb9d7ad47e8ca803f47a5613f9fa3e40586fb28ca1b158eae7fd9e028a11f6a678213ba191583ccf886afb48538d533e83bda639f093db05f5c3822171bdc84ce7bb417bbe3007bab3b8318cb424a4cc2c7c5fe8cfdf44cffc8052fbc200e315f720f510b8358b02bbc13ca4a068651c10e0c56094d047b4c9accbe4c0ae0b27d96a290314bf5d2ca589eb4de6519430166f56086971242ab787f982171679ca49f7372500bd81d97cbeaa1a1c5cfdefa572b9202776ef271dc32b39c366063a59e6b51881d5f06f0f592c50ae6225f66f8fefc6748b1bbefd8be310a3d5fe82993ad93ee5cfec95c31c2100067e5397c94c5a32b5a2930b93efc7492653f548e97454a6c0091e6e750c092c9bd5b38bc47157bf6ec8bec03c6f7c4ec10533ef86bab7b11c4d689c1ec68fd628052956b4abd5b8b361e33d7f5e43230a5797f113613009898a785d5d7919d8524207b63a5ce7df3452806effc9c81fe74d66d792ae680b58250ec423bca6cd343aadf1168be0055a55a3bfca6b8173a4fa6d32b2a7faa6c070ffc8c3f496e177ec4cc651be067f131eca3f30f9a7a668a4e082724a383bc62ceb1379c797a4ef073d04b0bbe0905b02b4e5f164e2dfe02b350a6f414e48b877173c1bbf3c5c4610222304599bcaf1f538a7ce317979d0d7c686fdc2dbd58ebfd4889955e0fc72fb01ff128f7cc35894f86f436ff874d3a08ca1d58c3dc06aff0614374d15501f6eb1c2f14bf6e262985ff03d756a8f47eca38ddd5dbc82543342a07cb81c5b6bf4ed0f3a2959f438deeb194d6f96631105e85ea76c8580ebe7503dd62866532ebfe864219a91c57e8fc7f1e44e1ed43bdc403c0a33861e8b3f95e1e9f5d7f348b34cb3fc1e5f51052340e732cc9125a335293d843e590e56f404fd1c22610c8b78c5f6393bee93716980d94ca9909228fbc8473a982ee0ced1dff12b7052c561b97cab0cdf4991b091f2d274e98c247ea0924451759594678331a5c9c60dcc893382e9e9fe34e15e615679eefb041b934817da7a3f31fdc2cfb74495cce5e711cfc2a1e6ae7a709e721898f1ce47fd1cbe9e320855b09a4eb9ab150b5409731519e7b553311dbc60617bae442d25f96576bf72b9bb0466ec2a728c440de6937470f845dee7b2958f9ecccf303506fd7bc90e13c8d320d7ea7a4de5abf95ba2161228b9bb04a33a264131e66f4f78b52ff773931ba4a357b1db290e1f3ac696226cfc7c4f8a2eb2b4a120ac7f6d65496af9851414c330954eeaa5ab00f6b423a2804b17f70d58fb5a1dd138d474621ba756c0905de1d78c56112f488bb38f23e54fa81a85b3074499ec57396bc91171eec7a05e95dbf69426d3565b96a76eb3a6c19481860220e38aa7306c7beaeab50f386d3a644a8cdb116194c6ebeaf035c1664d74883dfe15efa1c29479400bba6f21db86be82e31ca36b1a3b468a1a38b938b27d6db05839104d0717bcc44679ceb2d3e721f95deb07fd56988032fc1b7a1e047eaac46fb0050b281009b58984e8a44ce790314c694c9052f62021bf8a21b5109cdea33d5dd1c4202d3c52d1e0bd5683604cf7c09405130ffca8a537286ab3e854110695c8dd6357737f314111059ccf1085434f66918beb2e3adfffd4a11a5d1fd37dc9be5d1b7dad8219c1573af44cfe081f92e4987b1bb7c6cde094cb76878ee2e5b78aa81c4dd486059718329d201b6767b0ccce1c95b4eaab808c3c6d44210bccab189afb6a39a2c923f386bbf55e353fd78fba46380755aee7ac4c82c67a4c39eaf2d09e652fc7c1398db092d6899122152f5fbba53f02cd6ad57891f0730c6c5b013e221f23434f72baf3c09341e3284be7a5e8cab097d37c5975a4440ff07d2c9de502043d77ceb547d9784af3cd1662836ddb32fe1830e48c9d9583e2974460bee75861cc76a5f02a4d3bc3503e4a2e9c99266bff0fb0f08157cfac10dfef6e25aeddb5849ee31911f631eb8dea226d561bb33c65aa293c3f5ec833dc05f24bf32309ddb87083c0b2d1d7bb1ed28c138b0dd74aa171fa408c7d1b3bb4e2746288a5011bace593e20f0cfeb70daae2810919a3ad06202978f3053cef18152f3cfa4730bc27ea6694d68f0fa5360b9ee92efda6214443af4fcdfb03d9b7b9a3dbc5f9d1b3ed1cc1efac32165b257c4900e28ecaa20e5f02d9c291377748cb0137150597fb0c6e8a8d989428afb636e0657b3f255fc3b487d4e5609a94a428519e201c49217fd462814411b081ef192f9d2f794339f3dca8c15fdc7558e36351424f4e7bb55a615635dc6bef51359cdebbfb1ab54567e8c50b95115a244f7751ec9547fad6afd0f9e1eb838511a478de11fcf7413b99a29b25c7c957241cd5c8359cd73313866703603e43d0a2c60e9390cc7a48d05425318713f59e15d5347b0380b07cc409a4e54826bdfb528d8b558258bed34547bd21f8af1303de7cb0f8146dc887f6c18f4ac4eee197da456990d4b527bb368c536e95a408bbce0e16d8f4968d2b3569e56f00b2394982dce827c17ab124f8d1fd97e424aeee754dec7374d7930c635bc229f80e0f37798001e10b6257dddb95c22bdd3f0045f2b534e9b7c74df23171d251ae2e62f2ae11e1a3df8322cc39cfa5fa975a58730f7324c1d533762fdb2d1c8c6dc784c098eb32a54d43736b663672e78e1dcc1f56c77d3445bd3134aaaf898f2b7815041a245e5ee59cf296f18ab467898c18ccc70e441f4ca5840fb1419c852a96f74436cd1cf47bf967ef3c08d63f0f292ae185f491f9af8da17c6200c6de8b507ff62fff016e349f5e35e73daf13c5e026ef7a62549f248649d3d7bb32165a13dff0aeb2e5610629ad321eee62fbdb595b29b83f4cfcd4901b8feefab84d3608487d000fca5f3f9c685e7c1a5e77e5e2ea635ce8fc412732a009659fb697f2e62f0e3eab9bb766f9266385694fa6a0d247a0e4135ac529791ea571c3b2c7db3fc4290c09b2b067b1f42c8432313189c0c6f4b1d132ec5ee4591440f5f6835319d5e5399e30213fb53c5cc9a8fae021714188cee69d47dee81378079c763ff412a95671b17df3ba7646e70c3dbe55243cacf43a2543cace0ed88e96404579a517306fe4a4e64815aaad1ba2e9eaecad69c901eb9c436b777fd21932a78e16c2e5f4288867706dc65416487f49490428d88a513fb46165fce5ccd8592d926ffa43aeb9386bddbba86ad44dbd3450f5741875a687780f132d2f067c773004fe069dfba4d0f2835471f032ca42ffa04b4c27a6a4ded675b44d75e8b870a79a92768b19aea9849d690f2335ddc08cbe6d67a39c42a5d2446831d75d393cd9bcee63d60965a51c01d2a930736b3996682acac0816797ea3a257200a7a6c0fffe5e0de72005e4104136b28ec8dd667fc508f085100a4a722fe2a891f27008696566d6157c41e8b935174edc8f63a28a4bc45d0c2bccdce15e800ad6b8db787d6d15935ffec8c7ceecd7c5f9c19792060ec82b09eafc383761baa6fcdcd05f200d0baafe0f52b019e52dfd042750370c04989694ac01c881891f72f47538c8d32b5bd4cc07813441d2c43eb9f6607cedf991cd6fbdd785cece3ad50263b92494cea8824d7e31d6262fe664107d60696fdb5580747d83135b129f72c1fc77847384ff04ad66c945239d2f5d0acb2d69222730d2cc33a2017463751cf14aadc10d5c6355e59c7c14655c2c90b3c1f1811c5c9f7605ae8c6ce1972ce88f1fbd45ff5b5d6c35780859eeba2c114b373fb4e936b9c079f5363deddc7c9cdee90c449cbe52ee6545f7ae315298f927c32f6d154dfad255daf539022c3c9e6b95ab4f54ad8900431e483ab48dd327fa5a50eafe826ee3d3e9a28e508b92cc2fa9c58264441296e8a3d69937f8f56a82364f654e5fb0375c6dc182c233f27085f3805afea6c778e78e138cd3ab806238e0474117ee2590b0633d325a63b665fa15d4b3ae04e3f88d8e653ce98a00b1c196f1b993be1a15ca533c25c4ff221ed240a34aab9a9cc381024c57849dbce025347769fe0b24e49e386f7bb899f4137e58e9bfb9280c302df1fc6fa55c6d28ed2db8ba9b6a0ca81203a9f8e96ebd057b53d96adb0434ac11103b69b97a46abcf2af84bdfcabb3f5fd99da2b337b5e04204ab2a16baafa94d98bcab4f91ed8d13f29c98aaff2b7c06b9ddad86ad5e3973a8084aff6317e6171b6617325ee498bf79fc1f67a880117dfe5956049dedcba436a7bcc8c90cf1d94f0666f6b6ce0838144b9a565a968266c8a9bb7c09f5b37ccee515bef23d7168b3ed58ed983de332adfa5a949ad1979714637e7b0c73becf64027d07e5409c0c5cd47f196844bffb941c446dfbcf295d438bcc87c147203dcc2231350b838df4b92bc4aea379378fbb659c47880edd528f07b64f9f6d556ab3a9c2fbd7982317a7787b93ec33ef45e4421a0a9d8bf33607922f7f62e42ea68b52ca2c789847cf2f5e57cb83caf7d603679b491ecc94dd3458360b5bf51394b73d3797c5ac6e3dd537f206d6afc433be1b1c3218a40c92ed565d7edc1d1439dc6d05a29c1128a922d1a7a39246c94e829293150259988d102ff4f57a5d14f1594a0bca2f78213eb3e84c7ed5296c90963a4d37d3d67c20c9b0cc21dc223837529e27761de6e408f8b0b44bcb052d9e3bdef1c15efe0dcc32a04622e9b8880f408c327aef02808181b605e2693b29aecfbeca355eab30945db71315e7a68f69c859cc5fb65ebc259f22d003bf1b2902ed57949235fed33fa4bbc4c0a6a8bf240d1489e1610a98ec74dbd180b167f4e1cd794cb2fc02d7447036ee0efe6c5947e3707bb6a3d46f678ecbb4b3233d271137b3a0b5267ba3e1b944e6d365e7061ddae4ba71e4c276ea92838ac0c6b8b92dc1536286c4546114c9859c355ef063dd05a27503e69e8c8a01c050887aa33ce9c7f60097cad3306034cc6e657dfcdafbe33005406d1ed48e2ad7d90e6077a9abd36437b31ac1f3151068c019730ae0e824126b9f8cb2d4f68e9ec687e0620af16871e82179f4e588ba44125ea1091b7a9d242007b5adfeb4d4d1d61b012f693bc9be6062c1d18395fd168554eb5a38d6567baa14d6db771ea93ae09e293fd369e13372895fafc22bf994900ed106e22221fc40ac13098f64dc43687e213937bacfcdf9e7184d12ae6ff3cae4bdc1715649093a5497ba6334b08c468791c81dca17a262d6700a06eb34a1e1af424a5717f1ce13787f52529e6d4584faa9693d50439f8bd6077c212d1dda729df6ffe28e87dffbb79ba3afb2145467b509165dcafb6852464a6378eaed01a646e7871cae23e10632e055272a748c191b85746a88b4ee663121475d34d2bb8c204512b2bc642120ff02f124faef356c5d266dd63c394c7e66fb1f2579837558893c10c4b94be54f07d9fe5599f205fa170392982b8fa225e839cc727d45a412fa019921a77baab12e052b39a9bf4267396b57726ee3a14f8cb6891b257992dff34fc2c08d3a15d07636fee74f78b76eab01c033dfab432b4feb3bf9b8d6a4213a5724669eec1afea4f7d2b14666ae200848c543344496dbe3769f82fa4cb863ee87a183a4d8b5ece945e6d524b66d1285f883a41e3c3a94c5c8bf254312763b670b9c80fa502f15269067c9fe0982777a984b219d056d3f4e100b2d679c4a467f49718170aab257cc182b01d2cac7d2b2c604840949e57678666987c16f2dd411aac3e683f6873d123ec411919748d3de9d13dc18f7e57ef644d18e2bb3b548fb2a111a97634de212c16d4b0ec0fc92e849bdec988262c51a5eb5acb9dbd8b88cca50f8b2fda14271204f0d9e5c79455a529c95fe57fea0459d0a801b40872a136b1bf07a40d2760cd7a6e9be80b0107c739ccdf17184070ea343e9812c91f9a26f99975fc7581ac4d2e1061b0a509f77ce1852039d7138b46d6d640b1f7dc7c200c9c3692d3c301f786401c91ec8499d8bba20e6648911ac71a9a4a34f26b72c95991865d2a1e07acf59cc94b7d8321d3794e31e2f8ea03a9c612d7230c72a9c5fca54a297effdb7ad8c0f70115002b123d965f46b683181e8c74d85b028bf267cdd0cd92feb3f22d2b01ee2d29b51808e91713befeb59b645607288e8164fe49232b760ae5131c182d179729ad116d96cf300089252ee30f586c3f707f0f689ca37bee60717d6a5d3a61b3a0748034db1abcb613d4ac1be7feeb726edb97407ae00010233b5565676f9c477a6969edede91fdd8a567f2b9b54c87d1eab3d2839d8c3d34a3150d17c911d25e11a07da17c333680e317dd98f0869f028d909f64f0a709c3f0e4dd4e53c6d5fdaa085e50083d578e80733ba52d92563bc427fc521718fd297adebe8e82f6c610b9c73f946c34ab7ba49a91c746ebe371b2570c4cab7dbf908754f0f729d9bd7bd883b6a1caf0d7dcc288ea67cd92c83378ef80570fc5cb3d73d5fee128935f41906d7882db26de24ece350d72d00950fecc35ab0b97b686bd1207ea73c60dee2a2c7a4398decb84390c370af27ac93914e1a63d286ffedd69415a84bacf3ff2cab500bd98f5e54365d30661d1552d9b9cc5b8ca0ade5f937a9adfda6782d5f2472caf529685c227fbe42610f0bbb0ea0d981d5cc2a48890a0e2bcaf57c00494dbfcf95861c9a30ccb91eda898bb21e3ed1b68d9019c635b8a880448f94aa9ab77796b48845ed36577e0643395cc16273a0c35c28cdae0275b1f90d38645c45880dc2e368b17d75b7958959725e08994524da1efd8a9c4debf2ebe8cf0417959865eff444d2258d6c125bf890b6a719558e118285562c2fdb44b884b613d76098e3aaeb8073759974f3b685c6a688907fd2bc83e5a885798a26fd57145df5d60f184387f6064559aa3ffdfff3a6da6b8f5c2dcf75f6dd8866059880ea23c57077592c5586f0df5de92cebe8bc1466d50094d9d2cd87851b16fbe6df7cf272936f1add76b0635e23383cc750d9c3e80e4ccb8e01ed3dc2556ad64676d3bbda3068be5755f6dfa71bb17aedd5dcb4a112b9f04d72209b5c9bcbb92e71025c49f2e3eff29b5f53d5c37b6c632e96b7601d6b548b403f67ba623c0a85488c590e0f0c3fc46dabd7afe22e7bf4dbf95134a68b9ef1a00011f29993b769cee572d3dedc0245af82b4aa2a7658687573c4fc4349360edf8aa922107fe9fcbd85beb1fabef61909514f5ad4eaeaf0587381cc0d8925ed86e527db0d49f0c9b6ac2c165c939ea0ce644ab8a853d660205b69b2217ce8743b1dec8d8dc0b0d4345abdf1ef2df7a4fdb26c2482f43cccc7fbc09f47988fee85a1fb598aa6e1e817d0af7e339f58d1a1b80a20111a4f38ecdf85c641ba822d3a89de9bf709a8e7b60b7045ca056c2c8f5ec485abf34a960a6982c0d2265ff6264cdfb8b68f8a2486c2d7896fad47c6913bc0410af34717623bdeb9267182fa442652e0ad176f6cf49fcf872a62c71538aec3efd1cf1123d899e7131f886fce0e6172af3967e2d713bb986d3e77d1b5456ff1b684cf62fec333d2d704e72051986972812866b3513faac93cd90ef758297d09b6987b00e3482fec2978252d48109c2abb9eb6142eafe5df1923fbae635ef708e740b03921f284b6915b21e28b6cb5f70b1f55f34bf19f7d95274e238de4cf41938d11f12a05d2da8de0bb885e50de0f948b4354217913f28092c432d7de97b77cd443f50b58d12536e9486cd9706b35ec37064db2293deb956e6f97a7721706d5953c967d7831d5a26de1d9a1aed86b2a9bd89be65a5df66ff444badc7a1d323812f73f4ed488c377ce2e59e9edf9da43b23f95079e3be6d6d8d33bd6cebdb3f2870c027dfcc6aee5226025ebc4fca325a9cb3afdcef38f69b5ded1ccc43c6d2b9c2b439d259f5acfa0635b3dccc6fc0fb8088e4c2ff0029a5b2ee0482addd7f7f52ae561ad3d7af58ceca15878495f333fe3c71e2e00907a401ed843028a48e56b2a42822aed716efb4b0f9ba862a627517ab31fcc7e836780d1e825bd7973bc5e77692d0629ed3f7d5477727316712851390e03e1e9e05c886e55804233c946e7987c4b6827ac4f411aaf85840d433eee93bbd60c58309a62f5b556535a86530b4468c8950c5913452a8d45c598d125eb02a9ae18818ddd4bc5cc5e5c16299f97a538506c12ccc4a792d7b8697668cd72d52f5e7409d06e93fb4f5ed267896d712b158ee9f2ffe9e71315f823fa4aeb4b8dc395adeef23bfb434c31c42f9e31b4442fcf500e09a9c8f3becad16e68521952d0a27244a7f9f89730e02c3fcdd89261283d86796824c56141c7902849aa4321086922f6aa663a317087c70d657c59e64663766fd1704ad372bc3a6c5d76da30de8257b05e25c3728c5673a34d134a9563c3a8f4055f5412b2846a47e36c1c0a65ee17edc1a698f712f5dea9f2829885ec44fe4041cd48361d34191c7ac78f59b00f86d2cb22e624f53ad903d6d5971c76beca0b3be319b69d35ede118e732ff7d20ec20ef21be54e1c7d9b7060468f52fea9db34411ea2802121f06d8108af88a10f17f0c7bc360239b768ee8d8134af53931bae92106a283d26a605336a82c967fee34374e81dfd05608cd863c0dc6ea4b11afa2309efecc37d36de400c0c2f7df213f7620d83dc6a49776d5d3978e296321ebcfc557cea68a9608987e7c0c0da42366afdf9d01dff37f4be686ad1286b85f13c4f8dbbdc360f9efd3d937231f5eadedaca6b52765c645b50daaf54b5d2e4e5d44045513859e1f50396123f6ea12213f1e24c858a2c5d3a1c042d1187c6d995361d2a4df4686d75df55493c0e2bf93764fb8860df8271f56130554eb0b054b355c5faabcdf5f092af67addb240c77895d70e3e4cd6e1d7283998d9ec2b4f1e1b7a11d462d0133aab908cb994b2ad2fb89649dbbb7a1fd9d4c9918eac3ad062922b830871b86ef033f8b94df281d92def768450b75a89dc5b1fa3640210e6d61bf9713c5c38149b6a5d915018d00c6e1c4f270dd1c23560967bf5d862448fc2066dbc1e90229275e2d91afd56c67f560773c7bea154ec680312b88bbddd0351ccce8927d7011a0b36f8721e6b52f9459f0c26a04ad9d898b2fcc668f9c4a40363af4a03037e337c990fe875d6c6c87655ae03431eb93e5bf7d70ef016e399f4dcc6f3cd72cb07ad746863d43d89e70e06a197438d929f14d9ac204535f991e097f10efef9ec1e1ab7b43035e221d38b3c26821b25b206473e4210d35de0bebd8e8cde1beaa3f7aadb83375ba95f5235136004dbf627465587e5141395ae93211fe771904e16b6f908f18ef30a2cde92098665b61ee400a81ea5f3db6c5ccbdd75a8c630c6836cbc778bb27456131a004661fc8e947b1bfa40a53b5ed6992783b614f4fdd4251abcb8644beb6cf780f7b9835d5fdb808efd675912e8beaa1b333a0499dcb0f059ad61229d8288758883f045132c6e664f40097227c0068f6481cb7e7e77ea29489f79bd128c72fa6ddfedcd5e6de481aa93064b36e780b1154d2f4dcef780e23a461074408481721682c513b1b19a0edccb70b9ac23700984e9002cf4b2846c132189906b88594ae735230370e4c2fbfeb1ef25a0c19d7680b9beaea5ec815bc8e1c4632e71eba99019c630708d033845a3d28e7ff24ee45e77a5e259d1ce71769615a5e1a02596444a170977d8c4a3c841843603d44405300e53742924c858440ce3c23d97a5d86a9e2df42988f77b114143ee298e0367e4c9f31ed5263b109f3a4bd556efed4bbd9567c139e3705e5e7398ad1868dfc3120e5f14c7845f28b80d4f50de87182ba60dbf5647143ee7f53c4979b296b8dcf501af7b1632ac427a2f5c27ddcc01c6e3cf207ce08d50606ce50a577ceb773fc8a42a9a2b138a3c1c228a6eef91d7301973ddc2d03fb134c9aeb398f26cf51dccee91cb225bfcf71ba26e66de3e0a09b8a8bf397555abc7e10170177616fc55715d9f7c62d8a3e79b3a337923f68472d52bb1cb6aac950b7b3e07be1bdc24ea424abf6dc16892099b7488f410191725a528e4edd989a87ecaada6a5b158b2fbddf7fe96173d3a6e3964b7b41e8108d3c444b9a36cb7924132df2faf4a9e342a8d036aace4c73a0cf18dd2364bf6deddb6ff63576bf4711c5a73f79383677d9c21227b27a70980937429f29e49a1621457a7d66cee726aefbbc3a50742692ebe46f402ef5870a6747d3f33a3e76788bfaa7ba835c25dd6875c0c82635932c0577c45858c471f930df9e08ced016a2bafd724b00b3cea8b08ea6a043cc2ba7db671a3deb8b91a47a257ab9c165e7ecfb4df7fcd4803d227d1b6e830ec61e796a75f36405464a3d2db76cfa5299991a82cff500c1cf26bb580feb8796bd4d28c1805fe9df9dcb79a8fc1a5c5eed25cccbf4c82782dad759a84f066f7215532d7068eadfdbbcfae920d46fc6bbb6d2de918c8e42f8fb0a2ad544b0aef27aa45492f260c7c2251b3adcafc0bb87a21d099f4c6e279f4fc3785981ed90eb87ee15994f777f902b79f21a743dc4f15efa14cf82b532a0b013cc5a6308f3a5b6ac38f7c396ec92191a5b665abb282b0549e468b66f054c539d91e92e43647c00357b599c2131e40d3d9948c9f6b4eb2ee49f9bed62a07c87dcafd282519a8e75faed6f318efc02c96076407b35586ca287ac8e4d4d3d9f1d8898b51b28148d71cfac8ea25254f5fbe8475a5ca95f50f03a4d586de579d31c73dc448457029d0f33e78cbce430bb43e4570a8e3d440f89551d132ab40a43189e5e79fd2bda651150d28bd6ea82ebc335648bc3404432a0579c4a9d860af5c8ee17ec1158646e8f4a9c1db65af28b3a5735967417ab7ecdaca8c1ceac3ba321baa35ede6bf6edead724cad539840bebf7983213f900ede8bdfe856fc52de5dd7949ea834ea4b5206b6813fc0d99b4f62594e463669b7dd3e547568d509d89a8c7c7555647968c1370ee7912a8e576b0bd6597be9655d51b9ac056ec1a5754f74a90aeea000358c1c1874c49a8685d80296eb968021c4fdb5a1c85ff9a9e15a95fc28d2b0bd584a43d92e2d6f611e9d39d464be3c683998bc012c41a2a1ea07555843e6034ead0a758b89dad3adf7c6e6890170c5d4c57be8e39e991341817f950e5a9d0d53612811d2295fe55013f3017984f0c8ffc39527c239a2c0919ebae39db8b4a04a915e8c0ae1553386fcdab47510a38e94bc8d8f77f661caf4dbddbe58e4cfd6847a068bc52e58f017379f2bf3c9a20a9b23f81de6570399e889f36a1dedc12f4b46bdc92e38568d3a5258383c771cb3dc030f99bbb742e66dc3794b0741828d85cd16c4194a072647d8a7ffa38db59869415b43b79e389b11f7ee43b07579faaa1a06d7e434deaa881844b3dcf2d3e245022672f172b144c37b43f457b19448c4b801e2e25b0330c25e3533686746ee08b6538700d4196a59717f339f6ed6c0f3e4b8715f193df4746f3f54ef8249eb503f4650d13b582a741040f164306acd60569dfb387a77c48b2577c20f4dc8a73590e8be490f9eef15d5d1958cae566d5ee1e2ad8ad8410c815d7881555a1861222528da1873aa8b870f7843fb808a057c4d113b8771b5feaf4ad29f568517ac0bdaef97621c4393f350d0840b46f93648a473f8d6ec30a2f46fe4c2c2aaf970e0544e34d34b17b6ee9934204e44a354807e046be28ae889bf2dda499b1457372f878b3aa812c91b98381408bfd2af381729a25d615c99d0a211e7c98755785e06a316da1c6b94f780e6bf9262744e3f10164b62037a566866816687b6a3f0122a220dbcc91d3cbabe28916bf2b9f64f8d866f1e9b3325bba88104a2a2a6e82db7c7d634d92ac033ee57889f351e4a1be1bc5ea9af82f06433dfab03103da77843c3ed2cb1d7c926f40e3a6ec5d0e2a2f19c01d1534b2383012059fe1f1996aa1f6afd0068f81e6e39f334846db4b3df1fba8021854f93c7e56b9f644e4fbf4046be2ac5e107b7bd10ebe562fded2f3071d5c5299e88faa1d89f947d1aa2d699b7d9ec4196b68b0b44776568e95d282b3dc56810a399af1474f28173ff0900ce69015604fbc2bcc7ef80660d00a15d3b90f27715f69fd471b2cfad5d95d9f7a7d9b7e2ceecb9e33978644df787e6ef9c427dd7b04141ebc5349811cd432106ea22f2b4f968571d3644687f9465bdfea55c877612689d787130a43f702dee424a867ee5e22d7f39ae2bcc65c112f128570bb1c1bdeb08fe89851be60c4c308be8900f6a2331b206de9082cd07d5e4543a66314bdf970b25b0dbeed0209a971cb7f937fa9a835cab034bc077cbb3aee70a0be67ea3847efb6eebcf7ce13bb74b3c174d5b6cb5e151427c42990a717d64521e911c81c244049eb2ae73cbfa849a5256b337d4f396fabba352e6cdb5a5333ec53ad460d43bd4b446f8502d35226a1e2c0205cca6c58930b5e10b95fb9a058029a2ea3ebe2f278919679768afd74ea010f7fc8489dd68a84bc3a521b4b9f8ff5d43870956ad50a41c7d72d01e3c11e71d75de338b88a6020033a99174a7bc3650de0a8adf7b392c052f258c051a78d2517543c9b09c871c04dc239ecf4f846911ff97c96638c28ea126cd90bcc004e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
