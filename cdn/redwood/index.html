<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0147f516a7437bff759f3f4bc9e1e05b7cc3b379a90b13a699a8be73cc04c5440c8da861e0aba4ae8ef3961495cc473bfee58a25c1a268ee862cf1dd2f3b7818b4fa3f852aea0e8fdf4f69f7093ba90e1a0d31036c7ccbd74f90408cbf9ee5ce993c2d7923e047bf39731ecb5472b5ef2c286a12ad93784201e29e9ba99a39de162f0ed632cdc48b54a5f14da26090736ef489d8c27aa098d11a3f5a50547ff38b9ab7f037d7e868f637d2418f9068746e076bfd3d39890303eb7e84e24d29990d3a74508c5d2c71309fdef4c9835fb8f9d5f2fd05a70c9433b564b31d0ace01846cfa15b1c083953ece1938412cf4fda9dcdedd4a57ee646d974a23a98d0eb70a812f5f81e7192fa18dc23ed7c7c9b3116bbbccfd794cace874236a9c90f3da3f7ae57e70c87efdb47125e7751f7d1f1aba0780b919d0a94cd6299e84d75a80c49b91c2872ed74d6684afaa60d9538426454e312ea8a4a293e3dad615e55fafa164368cc4c5cc327e4ead637671dd3daa5db6d56903cf92da2f79825cc7b5c67c791e60e6aaa2330fb6bb5ed223e5d4467c5d00b1a9d04a7f341152f057b7bb5567084df7ecdbffe306b0fcaeffbef8e19c9af028ef4d264946e835f96420d4c7b6c8522902b9caaf118160267504d429833f54a2fd8ba868ca91fbb9495db93d8006e3a07b58b69e688c7c2741f953d6080a005f2026171f66bf71db001bb2cf4b25ace9559a80af2e60b064483bbf951833477cbc564b2ae59d16e0c726f9bdbb3fb36a2f3fc19bb28129a744acdaa418a45f8239af4297b77adc3fefa8e63ce5a133909a99d9ab3f1aeb3a73c4cd83111aa6cdc149f863374f8032b7c6e7d19b0f90ac6455c2fa5dab74863f0e5ee95298c4c046d1725ec0e4fb1dbb3a1c3c5fc94114952af34fff29061560a9b3a75f4c112880ba788e7e5c83da24558678e2cc95935c5c0b1ad9b6ff89f9775c7572dcd3a1b08b190a900e107dd89611bfc4977d2a302a0a09bcf95be07717b3e60ae18b72b6c18aa352da2db11ef8e55dcc6acde298c3477f079002f1387afb8d39cb1bc9db1ef414f81169b1e3081651948e46aa271ff8dc4ec5ffa93c82f0d1b5a25039f518faae5e3e795a890ef0e5dec43d77a47c9f0146fcfc1145862ac75381cecd8e50c36059cae148b89dbd23d23a0b29fc49d14b7a5facf12002ff99759e95ef88dad542b77524e867fdb95ca34054379596803044ab378c693e52ded773ac349858750da0b699539431015bd71524106d17c6d1d68831b270d16d425d861bec56624961461e80cfa8c5d191d0376928d2ad677ac4f716e010aa4985c1cadaca6074d4d03242067ce0759052b3a3f4695e51f8873281a53eb72492f869310f5364195fc6d0938da494ba607cb6500e6cdf66d82d0dad1673177399f96edf606f591b0ed3c66bfc73ece99622be3294afa54e9a17bf74a6b9c55c00188e2653ba28199c85fddf04b1bf953161709938c0ebe9004f97483281b5fa71c366f7138629c82cc358c89e0c62cef67fddf33bd698f5bd30cced6b1e3bcaf6d4c16d369733da5828bc9518b48eb588b8ec6a59b142ca5183abe4615cb114fe8ea2955d71600b3af20c2c6ed240bf892d2e4fceb92f4dbb7478dfbd201639f7b3d20087c832234f7f9815c221e59ae3817d591be43eb7065cdf162bc7f3f979872934aae308c9666052e3e92e66cdd3977861a26878b45f60f60ed3b7327da1947e888f69f60e3076fc59bfae9a96e74d00a10cbc0b1f1081fe6c2a5ec6638a48ea768a58e21d140e6c0313aa8cca218f3112529a6f9daa5071e7237f8fcf3263c0c8101fb9c5e2ae8f885b1a60ac3de20b4ac989c50a8d01489c3a1664f1e1a8f5aa626ce33d21abd0849904de386a6fd77eaf68dcdeccc4b3d899dc6dc38ed872357bba373bec21ce1da0c62272a418bbb8c709b83bb1f24cdd1f96e1e18d44b78b893b218b32e1af64898ec07139d7250ad6dcd65b3ad34dbea13ac973af1e41f4d45e1bc9eeafc61f2a1fca46c09783b485f136edec947be7c49b51a751f59b3219da7d7c1096c5d000cd9b6dc8e4f0d34909c0e2d2cee17937616921874970de4d623e5a1c5a112459e8ecb17604b1c70bd6b43786be5f3445bb95201c246f3dd342216c2451765940b4a3cc38903b9955e37ea2cf626214cff75bf9b6e0a7b49032d570e4184d808896417210ea14cd75844781fd051e4bbdc00291ef086dd266e2db3c960753d8ade96321f38b9112152227b3f2d0a240a41a438ed385792bc0683701925aa863e7fa709eb248b230d9150074588602f938b62d0c8328f4f8f9284b1f2230c587733cce8e3ac78ef18ece566ee6db842995f742dea70fa329a4e1e95831b27c56b1909a61f716a03702a5de7aa3d304080be3d1f6c317d60eaeb0511c89eb273cd7d8b8efbc423f891eb8a14563264db0758a9d7a8cf9a5ae2d7bf2bc72b45ef0f551cb153604b1c2f414edf95dbf7274ae7cdcd295dbcaf551c58a5b4cd1cc3c2c7607a14efe5132e39b817eefb72c7947279d5d11deb9251f30f8168167123b657b73667a770b3b6f9100e5928b79ced9de958afa466223e6ebd4cc54d07079bdfa35e3c29d2b763681dcd9729ef61171af8b07d73bbb07be9e15194dbbcbfba91c6810918434cba1b1d7bb3bfcddd88402efad43944c9cba9ca6db2416bcd0ad4a63e14088b6fe877ae2c1c4dd60e0bf45b2d07f026a4beab6a8e15d0e3f98a1ddf446f242f3a1239094483e7fbc4028e0b38649e81dd23b799d3d0eee2d16b048c9945d53818edddc4f62d179dc1030bdef6d8b8b16ca473b50d37a5d49c164e9d5dcf68accb047e909c91c2fd49c809db7e83426e385d9588e974e929a6720837a0f1bb7be5dc0bd70b563de44db6dd93469bdf2b09fba6124d717832828d707c60c3aefca69d6d8a5900e9e5db8dfc658f17baf5a93a8b86dac9e182ccab76fe3a6a021eb7d8a2b7d5dc510685e882049910dbb0c206b55232bee7e59637b7ca18cb51186e1e3cb1bbde8b535204999a6eb0357e1e003e380d1d871a54cf8d819aaaa7e43dfb185cd0834259aec20913cb2a6c7f0ed33f26249d96a57325b3b1691c16969ed0e3df2e5c7509a33b371855617613130ef6a4b35a94cacb0b923b4c1c52693183cb8c9fd8ed5841bebe51bf97f1980671f799e77297a79da154df4e650559e1acae776dfbb621f23f2fe6ca3dbbb558256bc7af6bf465932f1ac788afc042cfc30d6d3eb2a7481f852d3d5c98eaefc1eaae7af84de6fec00121bff4d575b6db33973ba7c0f4be4d0255db8d66fccf52f00595d479da2605d57cc7eeb7427fe42b60b81f12741d1e23fa76db8bdaca483c6cab99720a339bc88b3dae918d3d97b880b8987d0e8b36fd92c439a2c2b5730752105e76c8d6e3c79a594a5df1b4f9bf30e830547e79819a8f5c3b7eee14921e9adaeefec93d34282a6d9bd199265e6801b5a5a89d1b7e7cf18208b2b26799c8f5632eb787840ead33eeb5fd469f3c618fb588750a507814658249eb45c25364a96d52e4431c977c5a62b2cbd3480beb530f3c7c9257ee2ff1a7e26323dc1e4d7eba9acfaef953d23eebdfb34a97b9c618bfe9efdc62740ffb7e875b19c3af92112bd3d048a53395af652b82d621c0fe40d31ae8a65e1cc3416af021cfd53d461282a49390fa14639df05dafa8d79a84e39d01c1661c45f42b6d69448ba20e2efb8027dd9a1933ce0c8d1a7edd7a924dc309a78ecbc7bd1f5f4ffabf85f4f6a52f66afbe6d11afbeb0fba6ee3c92b2045fdb7850d80e21d19b530798346ad62cf1eda0b7cc9918f27471c77cb3a4e15e4bb211eef99206b4994e8c3f6049b4de761069dd930616830973012479cb54fd4607c0ba6092677157061372ad603e4734130293c19e3b6c4c00333156cd954c1422faff925c9b70923b7b2822bca213a8265924dc3ed8ff63b00c8d3e0c5eb2d54cc46d7879a969bd1429a2352a097dddedb1ab75a92c0eeda37e6748152c02afd70519e14c0c1286b8f2e1ec681af87c898d8e44b7fd5d7f4d27db323fa6fd91d33cc368c553d7490dc79dff17a68f18123806533f56b6f34833f5072342c3b22257c393cb5d79919c0206c47a8b16a019cf8d640d5da36e1e439918e80ad15838e4ff1fe8fbfb7e8bf9395dae7c23c25de459f7e8503a382cc127d1bbed94926fa7f869ef37cb1234ca517349150dd1d268f5dee7dc6602c1162146a2680650f819a41c57b5426e22e6cf268c54426cc350c50bd339ce83f798c1e972a98dc5a5dd823af549a698690d455a8045a7e0b9bd8fd3536871d0c3cb0179b223bf7b8296990deacfa7f4a3c826d392d3703941d7475e859358930fe1d120b2f7c7bdc74ac17a18f67607796334128aa7255f40451b6983b71a1a31a835a09fa2c96b023e0a3511138e3669f7d524d2d2e4aa11c1176c1aa74c36096c850c14b74ebf6c2d0d6c7552477b882b8900b891edd4490572b37e1b85c509542da93565ce47553dd7f579e4b104f8a0aeaf0e2bc0c70822eaa356b9c65bc13bfd430ea5359ab4cde8fdbeea63549d486099f3fea4c541fd549f23efec3fe4bb963b5c60e5a7b43eff4ea0947f3acfd6427b47cc0c2d33150ba6ad19205cd29ee8b3c057f97e4a1047535ae4e8a3930e4c8d543d37f3d1a281ec05b4834bcf7d5ac0a5ba64fd57bfea33309a1579542a99e891fdb73535fc2432e40f8e0e6b190eec691e3178115823e7af7c2afc1ed50522a2e7b455dc983023652d9cc46f859dee1f8e55e151614d6d499e46834ceff05e8e534ab7cfbf6fee6c6509dcf93edbb31ab7af4b29b932a466a7ab3b6ec220676ffcd506d7112c62354723582bd7deb760c7ddcbc5b60aeab49649d783fb8c590fa94e1725782b73c3fb79c8b5cc6e553dc5b4b1faa99c557555b6a9d122a4d180e761ff3c4689deba49185423d42a04fcb4f4d87bafa261d6acc15978710c6e7aa4e2451408c8047fef45db2bc46defd6b1f8dfcf1819c2dde00db195206ad851a15f0deb46d9cefce1b24abcf09c8b89f6048d05f53282d041a3fe7a17633d6f462036b7d4eff80d787de3bc06c6f6da39a4db97567b6e29dcbbdd2d4a831432c59ffcee0d6459bc94f6c5f7d790f1f5c5237cd89dd22f59b274ffb86cd03353a66934a4480fbed8aa053fb04fd2938eaec293487273809bc6789a6e009613d6cd6bfff8c35b863d92e15b304ca268c18aa6340d15a37fe1df32cf89ff707f0e893056cf71b66668fcb777b5f7aec0f3fcc998537b6969d9c6337c1465b1a47329b826de817660323dcce3ee2bc3d80f74764cf47f72583d07271cfeb3d8a484cbcedc97bfa269bf23115c66cedc8ad482591efd5b270673bf6e2b23f93b9520d4c77d8ad0cf67d8b315c37d19da7c81fdce7be18ad346715c70c6b193b487fb60a8f12bb28998881aeca690d7024eb69fd94421e9b852919ce3fc47a881756d740f18ca753a7fea4fde0a0c3f090b87e25a4e66170ff69b065e02801dcdd7649a2970ecd4fb63c0b985384f925950f23b7a4ac9414cdd19f0525c63c0c549d8968e50645eb79c689cf0bd819d871c4c23d1b18915540e04db518ec1d917e8791ddf75b323541aaddefc69137f0ff9e587502f8437cdc8db62e35cfa0011fd58d7d2e67c7cf57d13315db4f66683e79f9228ef58603597ea899b7d028739b7d812b384cd76a57041438f96d40b4e3e53a3ec88d667c11ff1d55d13197322d3f577807429cf41686b5b2dc401ce9d02a91b70c354f8703a44a57f5bdc3818daada5c66571f22bfb6e194a7c6d3c2175d5949ab05e829ae57b00100e32c0691f69aaa04ab3ff41700c42bb4e03a6192c1d2924bf1788e779361f1765d25817a3d2eee98cbd1e8b6708349ee8ad1835da10f6edaf7d5f6319db971f9c2dcc7a398af07dda26856c774657754b31c99049bcafcab004a9432f46289f27b00a9a46028d79c21e4912df9a6e5c0753d51301dd923a9099cf6dfdc82c261f25a93d8e1ae784953c815945ccb389e535f0d2484c9ff92dec5e4594a91885677f249743224f11b8d57e9445950994559a17c596069cd0c027e6ffcf8e8f5b79dece407c34193b8c22a1f7cfbabb5e2bb81ccbe31af17582196ed3152a1be21c45abd841915ee01b1f2bcb8d4eaeb6e2007647cd519827e309fb8a1a6622f2eb9f9c3cb82558fad84170faf18189a76eebaca5b179f35b9a9f28bf071eb0ccc54e42be67d3a4231c2ae41157f748c5d0beb9353c134a7f0873b06ad45ff884ed5496bf49cea59b3f09db217cea921da15714b4e4b2be91f3907ca493ca0f9098f3ebe09503a4125d07c75851003d43c424e0be60067f9cf448747b6af25aee9fd01fc834b8234e556a9d07ab1e30458bc62b965109efe3d253d4fdfb94ec979e02d144dd6f475abb8d1f2f1e545e181be02a97ff1977bfadb2ce93961de665fc93f51bbf14e210da9acbdda31db1a64709a408f7fbcc6869edd747628efbb68d056e98566502df72ef5df880e222929a4ce8b6719d760f6d0fd63903e02aaf2473718c4177944632e8b662d4ffe4a09e2059d504c4095c4d2fa7a3b643caef786acc6cdebfd886d47ecd74fda6fd1c1a679f46d2214e76599471d1201dbf17a4c5fa483f2f68635ce0ad7e515763d1830547aac555d459cedf54a005df82da37c144f97d09e58adc4236d788f62290ce459f2c93de99471766f92df02062d7e9c5847f218069c742e4e9090a3179654ed42745e9d8289a110fd84422ad9880c9fd9574f8607e44bc858d4ff391ccea7b1c89b292ce7d20f1add9305eb8d3e4e2d1278878767ee3220d85fea02101ca0abd2b92c913b455b0baff841348e12fd0a29a456e8a760d57ebedb1e06b8fa91dac2421c6b4de2495dbb1df58891d2d3728b36aad8e82e664d2b9bcd536b6bca7aba0c2c8d4f328ee9692108672ad63e8019510a63dae2d01a37a9e3c931aa4f5aaa9fc9870cc1ecf6d38c1974bccd38305fed482f2135fe1c0ed78f23dc8d8fac86ac32fe6010eb379af7b5aadd195cf8214a586cf41d72ad87a4c3aff21641cbd7fc6d4b1f0c8dd6ff7cc44ad7b656fe2ed179eaef39bc558d2a0031401aa55e7d15fe5d03b730459c59df11a9f38b6270ed8c4b0c570f51e2c7ce0ae596e95f6b352b85705223f52e0c601b1ec1cf51fc33124407b1ba297cb4975fa7049e7644e1f0fc7060fcaa01ce021c2850c9dd9446114ea2326a9a5a1f82354b72ecc79102ed1051538943b3b2c8dee327a0a8d45a570b5dd7c7336bc8c2a806d841ba05da045f2f8031360dc249ca8886691aa1eb44d2b127442119905e3e6962915ba8bef4882781e2171b2f3416f9aed82be165d9d483387c38d56ea6eb264a7774ba2874edcc875c7c95f5b3fc2aeccc92d8abdef43ee218c183a930ecf9e2fcce67871059408d668a3ebf54aa50b187eca82e978b971bc9adbd6384f01b17e7e4c71313ed888590b4e905682970f137161170bf1517241dde9aa707791d964c5b3d60f938f86f86a1d450194cf0e7baf020a31898d5426e9046a6a2de61f8208d72b2be264eceadc04d991706e8c64732721b19008fa4079c4d4bb1923164f5470dcf636d4e3b149760d1c44be1c18b70f8b9bfefbba0f81c7da1c7ec5ea9fc347d84582e8f840c391743cbcd5aeb5832c37ccb26b626090e27a2cf50e107a8335e38cc9dc0d81b955f17fdd910f0d62dc2bc5023c6bcb762fd16ff0376ad4e7d5935a444381c88c7454ed6da60624df926eb27c975e2b3c7c6093172e23c3fc335c00ff787fbc8553b9bbbe91847625798875ac1a5da58d01442d7146cef8adef9c4a35e79e0f8eabf7445c8f905f3d6385b1a5ee32943148ac1b2f0bbe1a5b10090bc5052cfd954784d3c0d49a801902dc5e57693c18fbbcbd243131f80b300ed614532ff2595e88257caffcca3aba014328a18c238e0b2659a40622f55fa547545f413341523503fc6a001e5c5f7f01f99e2c7d105259af292503780451746f67901674fd674b442b648a93261c6ecb7d2c587c5e22439e4c6e1d881640521d3c5d595fa6c1528b83f630fdbe9070a2be09b51af0a8518cf067ebe5c80b3e70394b8f6db8a106340af4cc1b28fe1ce0cbf9b81199c3065a2f53fec7f3a1fcfece41658a050f847915b6e00f56a8af96130cbf3a777faedc8da23a679845566f5350d1baafbbe607563dddebc08957584e90de72673b044ee14729292959cdab5dd40a857edbc4522c389f1dd62474ee1dd2c91d1e2ffb74a70df9b6207a16924f04843d730164ec725e9b36342f00b157556320419515b3d0266e6e0ccbb89f53c298d600cef3a2ec5c24497b3c9d9007c104db96306d67977546976a825ea4036fa1609cedf39f4b53897c78e247514292ceef1085e6454bde16ee207530d5263e5aa850e3435acd929c0fa8bee315fa8d20236a30f7e9d8fc2ad01568b097a20e89f00c811b0ceafd46250222e5c2ab309e621f6f683073037a347857463c78840985bd796198ae74d70592c772a52948252e06f45e1155fb87c00f5ddf014f1ba4e1f6b4b53ba944fa8156be7ba56ed21dbbc08fd878cf85cf8cadc376c8f7206c9d7cb8b6e54ff118efe672b555946b6a27d2454c769425588cbf280482ca0cf54ea4ad4c94c6157e356c077474312f2350c71f1c35633d7fe07671db38959cec6d47c1d4edac42274dd631463c7e9c44544575ef50f0672e74a579a8292f41e1a2f58d67b5e2e977426edb4d3c8d268b3c10b9683852efd696c111d7778668d4496ffd82a633d959ee908e941f28ec067d140562831f4c47e090dafab562de1de5b3596ead3b93c42611788d1434400f07678e230ce10d1c926983bc1fbbc5832b47ddfde64d36155af7c0f55859d07f98f031ab1cef157efaeb43ae2754a6ff3397cff4d7dc5a64d889f20a62063a60887c2eb01ffcc9ad8f3489c2eb68c0dd285fc8b89c932f8641b60d34246c4f1e9f2874e0f1f9b53a8df5824184c7423167c02e4410708244a8d093d16bdb37d2dca80bfd6ab2524e96a471b92682349852737dee371b83dd981625faa7c86a3576d09887c7e1eb9d9643f0b375d76ddd14af5457f3e6c6fc6d48c24f0a47de2ad8f7678fc94f10ec0f3c8c72cf466227c6cd66995b168869e08aa9ca02ff0957a6eb88b8be37f9b795bc621e0fb6d58f2165872497cc119e1f15d6df93ddca608fa6e14fdcd8b01b00274b4902024288c3802128eb588b400fe4f64f087e4bbc1dcbca8a2328be4be37cf72059601e2c73c91d42beabf7db350e4ea09002edfcb819b472a3f99fdeb9556cde85e943bf175af60df1c51ac9f0a9ae0e7190a004b47dd610cf36fa6ed06d6aea67c040b6526ae66263c6e013b8f90cd8e2d944a57beb6debf2be7a96fcf6e34eb8350ec90ee2b89d1a51482e2970bdbe4d6446b71f6d1ecd7151bf7b898d7299fe53db70120ea67c25fc48ad22bf8d8a6ff6bcfab1495257a1e1ca15856dca0df0e3888bf74d2d53522c7553c82ecb6977b2d5b95cee4e37ce6bfdf98a1dcb546035c30475a71ea18e37278341e29817591ed5a9f93f347c38af60f6d88d805422ec65eb6363ee3272031cf5e047bac8d2fc3ab7e548db4655b160b26fa2eb0c901fd66fe52aed4dc22b71265bd9410e225cb95180e45c69be393818215a58bcce225910e5bf9ccdd8a416aa42e948e2b2e050124851441d452cfabd2154162ba86697befdc0616be2c983ffe757c9b2b2248acf60a1d1f140a0ecc347d7746fb87aaa36728132e1b743975339f40c9c5097a73df1ee1ce07e8469fcd51bf05086f5f348676f988ff6225e065041a848558d9e099be8b51386a8420cc28a157d5c0d0d598a006068b56327fc112617d5cae0d6a7a2faf257276a7491300eaef36e9ec0db7a7e6cbefb70f8b1bcda2b1cc91afcf1dbef005976847ff5a9722e8e1122e9b11e922456fd1683416faf0279d5004ab3da476331540edbc377a781b9507b1ac2cba4ecd3fc2747a535c58484f347e1d20acdcad50d47833357892936d404ffde3a3b93b50c0873575e6768e1ccc3249f08e7f4abaf4e598542d53c6fbc84d0d467d67bf4f82c1c0699c3fc8ef98b791c1a7e4c8969f2cab05321e54f86150dbf612646b35b7cae4e1c9b540dd1413f41dbd2335e7ebb0bac69b396343e4945d9ab07896fd322ffade542e58a7cfc229c8b12311d0d93bb828fe7c413da9b5998903feae05b26c95690add46baf39074d1440069e017867ed2f32ff5c38488f272bfe532ea4ccf082f54812bef69a211b5d7ee690bea59d9e1e5b4d64774e028d08971d7f2619db7cd144de8da3348b48ad065c75e4da2bbf4f6a8f3f89f893bbad2e209e1b93669f0f4d46e545f813269d4ee0d32414718b1d894c5935fa7a051ef121c199ad1af55efa7a6ca191d9f118e1ef65f442bbd5e30ab5bf96cdf72b923f7e7545f5901e1d1c003a5eb6a2cdf66e0ee80243d34954d9fcd46bcba83d581ab0ec6a7217c2c866b20c9e8d56a6f3caa4bb623fe47d465fd6b78afff7c60c61560b9f95597f2f6779e44968c71977e4dcb54f4f67ec04283d771f4e310bf95421dba6cb90cbd1affca634a44b5541414ce3f5979a788dac1d049532a3166c82325bba8081305e1c831e06be27cfbadf9852b7627b2cadef7cb6ff18b1a6aa8e8c4d3a34e86714502fb530c0caffb17eec7c15676e0575926450fe0bc063bb12ce0fa3444aac5c55128d7f94acad0971b11375b39b0f23ef47a311c84f86b4ba7483c4a1765e2ae3e972f00a01aad31731cdc849ef9724b5c51daefb6e548dccdcac255657c52d79723df8edcabaf4c1d7260c6003d10497321696cafe773d7338f80a2f2486b967f45bfc8f06e7cf1cb1f75567a907c97c310579dbdb80938e054db519e8270d70cbeefd69bc5c0d4a4627440c0d57402ed3a578abca7ce5ba8bf352824bc18644d32e95266efd19449a0a5ae5f00847247a5cdba3763adda4011a3f15f6f580e677114b9714b9d6f667692987ce6e4c5620ba38b21adefb0ff0748a81a2a94a9d6358838b6a654b65d5d364995e759243909dec8278565f47dcc776e42615b1bfd589e1e51099f153288718473479b89b64978dc7f07d1515715f25a0f010705bc2ec7917b7e4e0676f53e8a23313e60c345ef7fb300b4d5342165f9be698db6aeb49ca705e29fc75f704d0204fb34f45f08b82a8c90e0473be3bfac1b2c016cb812de74252a01566c7c79d1264817b230e7cfda0941e89a93913dde81ecfff75ed0c9e6101b1673e5e56a7a5fec27d8cb175eac9a59a10afcdaacb19f8f8dc6a0acdac7ff3080ddef565cdd05c7263a27c44509e859715a29e4870329e822f5132ddaf17ddbc9fa25c49788e6b883d259a315a37da550865307f05f691bd4260fac7f34af3202cf3463e18eb9d21663883b45bdac967de3296df31789e7a847d292f43aa212ccfc4a757dc2614d554f87b615745efbf27590720c1052f928144518b0988273ec99442237e70343f85cfa43d1931ebb61ad75b1f89b19066bb7dcd155b84deda63dbb8ff17a275370e53086c21f901546907ca64e71862f11588d172092f68d465e68026f8522c48a4cf36bc79adacd600cba496909e1d8e4bd661c41e5412336b17129dafa961461fde4c5e2526283a375edab1904a0cc87e4c8e4f50805625d1df4448443057ef49edbda84484701da2d1254296f4e706ae2ae3a1bbe2171c81e24a0783ac97b4e7461cf6ee739c9ffe18a50962635b3fdb23652a60d1409a1ec3d1e846af9e1f96855ef6b218f3eb509ca026364e12f1a784202ecc104a63819e14036e7e4c26debf0f17cb31b039d496e050fd7e8c88eff9e3c79850295541a75101cfea3d793a5b0faa37d1b3b38e829205cd8a4be5c2c812f88729f6a81164b31e5e770b5bf689073b5f5301a5a991bfb66d061a5e1d4ec0aed98a56e6e0995c9be7708c5fe7686e5e2fbe7cf7e5385a5dbc463620fe9f15276b411e0e8279304b0e24962941f1da4ee01fb8f1697fb0dca1782a51e13b26a11e44ca1c1065ce18c1eaa5142a735292776b02eac85b7645cb3ffddcc82b74697b72143ac3c60ca4aa3ad9aba1d2d20271a57cbf3406bb089496dbf546c617b62f194ff48f8426152c0e9ab014ea30ecbaeeabeca3714739d3dfd6ddded07b697b7ef05d20b7413271f14991cce0926074ad6b9dfac07c93442175125b071b7beeec7c26e897e29b4e745fedeacbf1a2853692ed86ea3ac87200646cef23b18c49d7f94c0d7071cc1a6c44f126ae782eac8eab5d77e87cac051ef0b0d62bcd5e69a8037989f25ff919f2984a48d02f81b0549bbc9b3b82f782ece7cb8742ceb6bbd2281bdb86124f85c2ec30eb6c0d3176d072f368ec9587f046d1e6eb58f7c7ce984b361dd10ad1a8f3c49bd34aad10aeda14b5c3003e57fc8c3a357a82ac159389cffef6ed0ae96fe3d5d4e893bacbd8c6f27faa11ac57be61a6bba82194a74bdead994b8805f65abd25f0ae48d3835d66de7337b9541bae55e28441b45096968f48e05dcc18d15de632e4519163db91f519b41049d8f14946d38ca8f08058efed43cbb46f763bf21d63e22c27d1d507fc6c303c104d0c9b8bc4d997d852f06cd983fcff0b87cf5d69f12cd2596ed46b69cff4f8bcdd317b75c0e52a910a454db8396dee7de8d9792f1b8a0dd32811aeb133118c3b0fa004bb57f528697f99e27beaa053cccb03095d4c2178645e19ca32d1191ed00c550f2446decad797376d4c988b8bbffffe0ea7532405ab6ed12a3bb63f08c7c52f3db77a7bc925421948cf97c6754aa2975c4c788ee0d699e811448f22887e570720ba839d2231865f137fb85984611b09b8ff39e074b83df9aa199eb74ce0128fa804fd95e006c593afe1bae895cb53248d34c47a10d1b95398aae7f5eca524853bec7604c0f60162179044b533415463d8a835a4eb3a2a4d608162a82eb07340b7c1d6c024a35f74ebca60de74878b02a59f76aa310a972f4c91287434249f7757eb157adf2bad72dc27ca25f8c85f22dcf08e8be95de34bc436d8f676cdd88fd4d6fd1b99cf8b4d53c600a3eac4f6350046e817437a2c624c95b8a7740248525399ff94ef53df4eff5a8d9dd63fb9d72470a17ded77e9f92ea588e340e506e3d71385a5bd729e63f911deefbc1ab6a0591a784a6dcc711902cf778bb21d4aa13e5cf0fceaac2134d44776c243df7fee3afbd93250624f23a24e25c37e86162529a706479209f2d523820eb92f3238dea944f1cce203f5d1aa213f2ed993b0df3d809afcc800455aa7058d08809be648d3ab0990b9b9860000db9efaada738e8cc1db1099338452046c768c198c10efcfb40ad12a766a525ccbe473f2524b0d72505bd6d1cfb3b870e115488301a42008c6e6a3c2f41b62c9c1c878a923b0ee18aa265477bd7562b351f912a345ab0568b6d840285816fca9dbb33b2749a1bb447dc6cbaf7a6d68d4cd79f742339e080305d832b4a1cb64ef411a7f4503985723795c0f18b42b4ed8b24d696a7bf05cddf276fef509e6ee8885289aa6084b5c98cc6413659cd60460aa28af5b26ba49b25b05f97253646fa8ef7b90d41765c76aa91633b78e8051ac180971c7392798dbfcc1b6909eb8ff74419aa6be3c579c0e912517b808750f18477ece2afdabef8541f36f899ba99c7dee652974b16f653cd5cd8646c50777b53f9593a3e805655efaf29907879ef1f89a45bdc0e98045bde01d4467e3faa878abebda3c068db3df032fecf531e625ca8b0fed3dda05dfa50657bda0b9656c84ea0846c87072883090ac3e278ac4108306d38684eb317b1487c9e27e15be35f66c58f286796b59c4c6345b79d9a23381bdcc11efeda3f4289f40c3253730335cbb1a8f7e1f7ba550d04e063f0233e16e7829e13d2c2ebf5b5969aa80236b168d0a95c715e071b1be0f13f0dd6b257cd9c643e2fdc0b66b95f64eb9dacac404dbac87156c6933f0ddd47e89b29646619a94d87c35d913f4b612e44ce2ad4532736704c39f82f0ae9cc68cb7a357f1992bd538ee8b4771b82122183d81b6e46b091f94f09512152b72ab190e70174b83c56a12aa4056e578043821414480056746032a494bcb1ec14119ef52c2ac63dcd830fa36bd2f3ae17cc89e21cedb772ad73641d902c4163f0f1f62eea0497411f7d766a4237c126bced08637f91cdcaf26da923b64336655824e395a16e3c45b061c76d0f60e0e11418b09acea071fba267bae834c84408a265baf55f1fce2d704e08a28d7644836ac2254ec4fc9548af352b1e22e9a41f4ffe6723bcf83acf55891cfe5f14930020aa5f4dc58e8e5c77884c811b685c2f08eea52a117262093d27f673fb374c02b66a7e82679e2f1d74607debe832c08baa5b8832bee731cfec3eb78f8115feb188e69ba3da99202abf9cd4a8cbefdee9ef5b2f02beedb6f63453162e603c499894ddf8a4a7cce8557ba0201f0b0758117ed8175a1733e4430225614429c188f73a832d8d214c082466115e093f660701d3a9326f6cf128a923c537124248a9b9e62fbcdb1e661687d6cc553fd9ed2095066d59b8d15879bcf11af9254f85a9e226de538b97fc213584de78d17ca9816021f15782988ffa9434d412cfaff590548a2cad87bd5d15c748ffcfe095cb913f5180f56154550994c0076221d00b710f57958ec73d25623f5f70e52d06a165d9127e96d2e7095980a69e532b256fc8aa69f33f9aba02e201c8a1fa51113f3139bdbdd4f1137d7a730b27e9f2ebc6f4ded010ba173a2b71072d60a78d3124d85002524db8bd0df87e4748becdf071ab40affeab5c6ff5375c585b0601e4c26d38b19560a78540c5d25b25895830ce339f5b8dee19075e99f8729a0473c48e1c1e87182b873823c5b8ebf25f42d33a15ab4bae89e281c2fd4f0e5012c7b424d4228697d2df474a24f9873c1e517301c92b5922e99d43021c723e0e9b0a739747c9c0e7527c1adb13843dabc1dab3306baa8c1010cfa9c2e1f111de49830290edf0c510092ad5bf7a51a43388783aaafbb64d6658f6e26b9c46da59de9974865b74b1abf419e3fc8e71f791a09245d28eff427553df4b7c4b2d4e0318d4dd2feaaaec3d89f8598b7fcc3b61d37aefd99e4054e00a03de33f041f967cd18c2930497ac73aa68422f7f17a86c16dd0531f65834488bb4a649fa217d8d5458e36cfa4957af412f0eba4d3d6e5341d7d54b77861921265060298f13c952cb8669b9b1d1a915a3a200084738d232ff43906ffb9656cc44fae190d1ab5198b7c669ac46f6f636a29077bb0d349af062ea7b9fb58dea875175d847c3ff4e7193e6bb3d373be58f53071f4b110b3bfaa40ffb314f8ca3583966a769f9235904c8471ce5b58cade929427688f23d941fd130146062604a3698305bb73257112977871df59a12ee76813d527f6df500385f22612d5e8347865521b4c86f0aca5bef23eb1ac553132a3d52c4d95319fce19101dd0437dcbb21f897816b95392df1588e270761cd21aabbe2adc2483b123f707cd8cf45b97d12a5c914898ff57fcb741146006d0c8281b2ccf3bdbbbd4f951010780fbbe2ee19c670a5d522be4c359f33377eba5282153531fe4cf54a79ea500aecc4925881f36f5de291a9ff329964c996d990c89f7a447f8e3196a6971c782c628a83cca0b4f4bddf20919a68c02f1e8eff28453a5ad611852c3831ed5290d4ad0744d969b6accc28525ae884af295d86de9db4fcae20f1f877fa197c77432667a8da5277529f51ecb23cf20a0adbe469ec2cf9aca7360207d55378acdd0c40a80f4d6eb323fc991688c51de8057ced09710c0c1c96bc00813dd46602f163159455cb23c926757dbf3587bed0062ea27e69f2b33518900df0423731210236994d0d48af33bc1ea52b8a94291f6ec9d5b309e207596bc9b284e9e245374050537a27bfd28d05870d19d55ba7ae35bd2fc4bd51b8d944508ce20582cb182d6484029969c8b166c7c639c7aacae97d3ab0d7ea3704edfe5b7b3a5ec5ccdf12d97a9af4190873c509b9caee66bd1235107c736a31abdb498421224b9d4d2ad0f02d00f3c4bbd78a599c19f73e5dfbfc3c7bb0157c8dbe4d44d6b224849017b83beb779126d257e6f1941ec662d771a24ea3d520cbc49a8fd8f29596bf572352f992d550624d648a5908520a2a1caf13fd72ab45c112f8df38bc456f610b78661433bbf71ad8343895daa8756daa43920948089e69bfa99f685d153f893953ba80dfb47af48022f8b1737a465c5e0e2bac618955c1e47bb7df386d8e8c2ff36a9f66fda29a987eb2328cc083417a5c61366a35fe8483a772e0b60a5594b48f728bc7e3c3e306890f45024534fdc55df0268a158408806b0419aba28e93e2a157e062b26e62f67b83a6172dde990d77475a0c9d48b219b1a2743232452589330270396d33408883e94de68e2ae2d86fabb7ae4ef9ca0193e37992fd71552e348ef7281331a6b9020483f91d80df0d507c9741a07ee3985181555127122c0f3c84813433a39a4c48845e283f43c6ac1f2d5871cc4df3269f6bbc91fc260768856ee0fd8ce901f391e40b92b54ad4d62356d521204f854cc04361cd8072cdaa427a629e0356a15cefdbeb52b13bd95305f4e5e18b73230651534b10b9efb845e90d84c929b8575251270d49f0f89a72869d1034b7991d3df4e522cb4364450aa347dd911f14e619967a5f4f9c74e1dde0bdb584e9621306bc05ef8a53b396864182505756b23dd71424c08c4734e319cdf89bc0586339ca8ba8142b202f0bbd9c0259f2706c6cd92b34491295ad06095de5044b17cff8c6ac133aa4de8c7d811f8ca92f8823ccb1843dad429d443a153c25c013f0e120d1da572790182a8fb26c001767323e97d56e25c836f928fc4dc63d2ac844801d726fe5835f1db10f86993a4afbf83b8f03255add7090b1a4096401c0d50a9b9599668363f23d2e2cbc7afdbf27a56ebd65b2e63e6038637835dd30f2dedccb6a138a1fd5cd4443be1cd776ea750c512816b4cc10f3584727db760702e855b61cedef4fd8a53545d9c9166e4b8d5846d061d3487b9c11771613d60db16abcb68c838d6afe08a00ac1fafe4d30c7b8abe886aec9235aa13d40f0b17125ab06a2e8d368220b83dbf3c423c0f1cd3223b5138381484a768ca3c7dcdd39b4862f0b4d353907fd5fa3515dd22d0988d2a2a02af7e6c58f5dc0374fb471fd669ae17f4e5efaf32e3f1a3b5508dd4f119031a375d8ec25e05e9510c2cf686a9c213b4437215a178e206842a9a39c1a5acc2e79744aac3c1cbf05c16983231fa90e29091d3bb4b551ac3b3cdaef9dd8372ab4f94d147c8c3ef8236adbb121f623d25414a4bb575a863acbda4376abb1df254d8655c205cc6f6565eee315e6c581087768ee65c8c3ab5a248c91c09935281db524ea293385863ec6bec515e40bfb7a234d96c600e85bcedd5b0d9532f780cb8f61c1035ded1d80de0df7c134d83cf114f11aafb8a6bb2b25952224af1fed08104a7dc82a0ceee8c2b5f8c1139b6c3f777a6595f33446f71e23964dbe2ab5f9119af56c9d01500aed57c9f653e86c2f4de25aec8051edbb8552091ed2142ce2d3bb0d184ff9a15e51b6436b33616321ad95b72cf6ab3cea15f5e3b7a2530459ee517606becb5ca70c312438d9772bd18050e402e3c89e18e273d7d81c1b7eeb50e5bf5af64a3986d097dfc2f8f126f94c41fca1baa300e3c47810b5b69d3f88b173748cd42de61ce5f165105c23f42e222d5683250841884de27060cf1a85ecdc092694342f771ea62ad4c9855773656bc1a665de45bf6c5c0e5fa47eb04459ea25f168808ebe3a601bfbfaf56e0f69491cb57453be3895627270e0a331be92369075a564968c8b60ef13b70532addf7f422ca575755d0cdbb0a766afce377f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
