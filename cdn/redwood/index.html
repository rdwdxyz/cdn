<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bda9b84ee09b6b6fff15547e8d18bcddf1b0ca6bfae6a5e1f9811791ddc20cbb06e26721bb9b36ea3078c09b60862b694377248dfc5bdb2af7b6b8a1ee796216fbae5d6143d18aa9f2ca487c37bc53e5fb809d42ed83a554f20cd6022684cb9eb4acffc5855ab4d5e6c3b68ba91e2a648d7338552115907cfc032da488c577b41d5683569562c5f500826188a3ef817345a3515a43f797823341cf818ab10c7a5c93659cace9a4dbdcfab285794bad3778b4c2875abb3e09216a2135ac2cb504c3606df0e347907e4b2697dd7f1ef0e6acd3d1663fc3b3bb5b6cc2e04ea34a18df9e034ad4eda2a8fdfa51ec449b54790d6448e48907f9f86428b30fa35735a36039e8c6f13fa3b085292d8b8f09e8cf1477ac2a5d089253a3d65234d08dd32e206d29c949814e7600fba9a22507ccfb2b1368bf583ef01b5df0cdde329a92b4b1925a7707c461a2cd1fd6cd4beab1f4631a2d60aa50d98effe4f586337646bd7677974f03de20de40eadf6c6a697cd073ce17800bb8d2262efa4d5034ca0c99495c9339f8e54b5a09764f97770964a67e3585453f244ebfe6617fac6aeb4c6c322d5012a9404f78438645c891d89a824ab862286052f0a0697ca073bc0f4ea3fcfb475a675ff7a9d6f0cdfac519f7fc2ab2b496d27ad6091f3409b29541afe6b82442b6fbff20e9b4cc0deaa70cd0acadde7d39c586022f280b89cfb0ef3e19d7deddd9794735df71fbab1ec6dd8fda345a29c1921dfce7e624d2a461eec78a9dae30ae304bebf5aaeb0a89e4ee843d89900bdd159f9e8282e95207c230ac75b683b461fe353c75aaab735d9aac43f51f74f25342f2218eba8fdf5147b068f7c0a184a377a5c487825ce8597317586c322299cfdb532ba99e30eb9e4a15e257db0c491c7353705d7cf6d8e312ed42980a62518cb44ef44c58fb2255e4b1289d1fb1552c91baad94fa5182196f8fe112b3915b6044dfbb57e95ee73e8bed1331d844763ee2044dc313d2a47a68038c276d2ee718b5e2c5c880ebdcb6e03907c18abb8e84cbec05c1895c9b26ca102d9b49edfdb40d425bc6a28f8be8e63a225959f96c94e41df8fef0125a419954e24d2917555090ad6c8b6b59dc9a6c76b1cd3d82a8968aa532b3d9c3d285e1ee2191ff14fde651c8e644352fc8a9d7ba5b2b40986f1fafbfbd7f7c05a0941fef290813605375894370abc0da031bbeae0975c1b8033ce9de2a3df7a71fdd861b1fddc2e6c75eaf6ec8f2581c005ee424bd6bf99c1fea99b5abc2f48024f72b298a93e491dcb65661bc00bfab8461931fb562d623775e6149205bc7643d2ef850b369a9d54262202be3cee050e17d3e0e5f4acd04e5cfdde804944d0ac2658169725a0663b66a8e1ac659bac20ae05407bc1f5265061f3c61db5ce57d592cea67e956a5a8cabe2a9bb0c9daf80700fa49f888db4e311d1e566f11756760a8b80d1183e3c4cc4541746b953fb985bb1faaf712030618dbee71c83857fdd93dc851d173a7262f8b7348adb599c5d8b1e816807b3b434fc3838f600ad68a3c83c361aa3f1beebf09617a3c3be8afca6609e2a717b64f12789f4985286c897b4e025cdffab955b929779df2e688362c1c9d3b1da06f62750794a748b8021d05992ed0ddb5bacc05cf4adcab26ebb693f8a85aae32b9e86676d5053f027cc6700e53a223e71249ce3a2d4dfe9dc58eeb71d87e4ac0ad61602078725623f1ad7ca5fa0c9f0107c40eed20a9c9ea93fc7ea2c1b56f41e9fd3a23ed4a11a430cffdcba1fabfd17c378126f1b90bfa3b4d87ec643b3f7213df460e22482bc92f9fbecad1029f7298b8235b45214aa9cbb251c9a854fe965e8d2fc903f394cafb17905ce467b1fb0d790ad9474dd21c3f8cf0d75d84d4de5b22cdb57849ef5afec8eb3f089633591ee99b7a2355e8a897a6fcfde0e558b9bc64fb15244b7efe4c714b177e7a828b324d4de697b7e3ca69bc3fdfcb0835ea7810fe4c2e3e90adb7ae54eaec584f3564bf443b092cbbaed78e940d0ef0f5f51e50c3457cb1b19cdc554f4f5aab4f27704062f77e15d9755af678898ec170f55c9f22e228ef15c429802a0d3fd94aaa3f1b30e6b58e0ca8ec5f8ad0df727ca0b6509e525a0a40ee01884f09d46485eef528b6ab684a46dcbb460540150730d5aff01dbed659e9cfe29f87e1742362ab2575b129dbb193e6031a7a1e65cef55bf2f0fdf16d8148bbac965309cf20a865b0bcd740ab893e4684eb7f87ba90182ccd70ae0e34322f5ed4af881bd4cd3cc104fd32ec7c37da210decdde8de67e1496f279ba4099f52fda662b275439678d2d1aeff87ec0eeaa8fa4b1627bbcaa4ca64b02bd8e1a4936ae22c738e94fdecccf7c14cade05587430d75f0e68e29db5fc2e2a8c1b9aa0440a850cae8784f8c0a3f97d667cc5a5d6f70376f2d8d6798f6282cc515caab09d4b7cd88ae0f6d300c3d829163a4e37a2a311e374da432214c0b9590d822302aebacf535fde1e0104343df8b87f2c5d4dace1b9730c09c44551964a3137cc28f94e446b535aa4c543f7f575be4d7c4986878fe478c3537f179b3e8577ed26615d289acaf2a6c96a20afe8086306d9a74869db1de62fc62ce55c695a7e0c361ad318fc1d67f3d3d392cdf28ba621231c8846995f28cac570012e3afc4bbdc02a766112e2cdcfc24568a4127f8a4055336af087a8d5825e58075f9eb50199cc74d2be77f8640186983696def4ef4c03b5f93db0b61c97ec5d1767ca16c29768be1e96d2bc78ef32835ec28ab3750e6e7bb8a90e7030831d42b56d368a68753f00e27edddad4e67fa62e7d0aa5f96a820fe9a9dbb10b3076c17252afdd6234b144b670874e2cd9b4effb4217a68c5192a376f145e58613a2104568c529cef289f47f46a9bda7129e166f027b2bd043c8a5cc67473dde181ad5a7be8d55bbd7ab71cb284e082ae271e2f91f87b48c4cef2e25bc5f589cd3647cf74e5c6596716372dea00b2349575dc483c33741b6778a457a4f9c6683918ccc91c14d43a278a410c958d8fab134d608cd63a43a8ca8e75c38b38b848e8af427d57683e0e89de11a13a59337dbb71ec13a40aa8cbc0fa47509ebd87ac5988f3cec6b2d136eb72bc0d41494b3209c968774f84c17e1130b87dcd0e481dc1c2dd539fd3b982ce65eace24b12920d03f90dd7af3acbecfc29910698d4a0f7788f190828b3b9c9a4c47e09d841506d16f40e3d1228392d98361d389ab71b6189b3a819d850fb96bd47c97c2bdc272727a5ac1d300b16288212b857d1ba9b4f83a7e78f5dec473680eec90f4790f7bca9c18027bfa49422661496c8142413b7e3ebacef2c42dca5ca2dcc74c9661c5a799712bce26fdb4267e9677ba090c523486f1a23c3245181942e265f1ed6705b4136db3263d20f03feb546ee2589cd3b869735d60c8e14e46919d5c0b5c5ee2a60dddf15493390d2f4b33ab907a5b6303939b455bd779d4b602b2c86b17d395c76f120f3f73c389e3b567fab815d04fd689289b418b559c52b57c9b55dfaaeac81b3124e05bba984c2b558dcf1b91ebc7e257aca57370eb315fa02f1f63977524e8e2437b0b139a4702167ce06e4a3091f895ae8db594e256f2d50dc648794bda1ec07725b6b1799b268bec8532af8b4377295d29310fa310040a06c99e248a7f56027a9c024fcf649f4f75a7009ea97272cd817076f61d0eae744b99d6dbdc7cad1a1521c69fab484a9e9d6782a31a334bdafb39e952ba10051db15609ee7d0be8826f9bdad8c695bc25d6538908398c31e1e03e54d1ff7e041905f4ea659e751a6aaef4fcfff141a5721bd379e1021c5ccc774fae2340570ef66412d2927074ff732386411b53685967bc87656ea27bae8c21e27f95b640d817761568c0d003f1a1dfce09e007182fb581abc8ad1684a5eec2c230719368e10f675455f2ca293cf4036a764753ec393378e1754b51f8815e43e417ffdb6d8df3f1981af826c6e0ffaa954521793d7f80b36a50d2ad02fdde1b1a3b09973a423831971d47bdd37060d763039cc42d80d61180f347be230be971857aaca3950b9911e15548f706e6d6cc1851ca703a44c95bf7f47e0332a4bd0d164a3e3b1c7926f4ad6b16e4385959ba86bb884fd657dbf9caad2abf1fe130a4c8c44d7be8c5876d05d79e3f024514f7b56ace3950153e932052375b8468e6f59e154c48ae3dc1dd0c360f4f37c1f06370d9cc3b5f5bfc25700c74333f6e146f077ac63dfc29c591807027bf77d9dcce92780e39dfac1c1fb387ffa4900da1e815be8309a7d4400465e96f83b24f991964266b34b897f804280878f9e10fc926b107822361f08d887d5aeae07cd53209d9de8a611df3a9b44ff2ca9b47dd19fb1703dd3ab10e961e32bd868623c732730d35a732e98b03f766cc8f354fde5425c7896c9181b93d8a2cd4fb3e7cf4b74e6ba47da4f53a5e630ff6dd8e5707c3251517c109fea834b786d8ccc6f4e2b7b44ee7a50edb05f3a934ff00c216e14db871c0ed4c56b16b778aaa00d9a1f35a7b63fb863c5fe4d40ff3d8fe8a1919bf04d033467eb44275d7b3219debc81a1eeaa1903a2c9006b4a8b59061176dacd63f1cb253537eb19b2a61fd3b19000f530187d696ee7594da0a0121920d7b3eca9c03c895cba771b73ade89d766285e8926d9902b6d0e054316132f974179a65ab806a05bfcc8b8263eb8d41ff8cfc5b20037c9f850e0b029c67ac6f2310a1cf7cb2583208db99efb59631c083d4e278b10b15643bb1834e185e747899d4466d8f1d47739e050c17f74ed5dc9808c8545a728e94e4c5688c87abd10a323583528dbf034da6a9bc2d3769fbb9de54fe70da9650fc1f1eb71dbadfa3086130c83c45cdcf4397ded1ef5b7ff1d5e056dc8ba8a9dd332c6cf81c99032b5ff9c371d6b990f71300c4e2a8a24542004a9cece818cebce834519fe868168aa6f097298078ccae5a7f66affb86fbfc40057f2af02999eab72dccb125e963b7a88991939d491932343d6652e083965e2b3734dfd56a1f4aeb82b3832f0c8463468dd5d443e93a8f82a38187719ae1116ed12bc5e2a269cafbbe1b39fcb078d081b88f9c9e8ae8b77d1d4e267608f44bf221c4c04521d1016d84201e82428e057189b0fc6c30c180f6145934cc45010ac534678fe7e6528db3557583f978626dd5c4d5459a2708e858be8b57fdadbf10015730e5c9f41680a5f856c3533584bc51389703a2c5be8968aa7b9e05bdbedf7e51aef98be4a778ef9ad53334754d92c51a5a07ce42e855ff6ffd286f50deb7144b8843c3698c5f06c4f239e442b4f237f8d33f4966d49cc2f23f02aae4cc0be8e40f484649b55c79087fa7b10cbab10810339ef74ecdab0a7e760cfca64e9cd900815ed963f9a24af8b33c2c69116d9fcc448f3d3a7a0d5ea2098903ecffba484da77d7a925566797e8f9689c760e656265a2a88d8e22603850121f53140211f1179dd303dd5d53cca157586641d2836d9ae04558af09b1ec3fea472efcb518142b0c48603352edb75c6d522d48716b51ac19709fb5b4f6fc1d9ee7d6512563e5d94fd732eaf2f1afcc9c45520524b5d62f8f9b1b28acfc0881c7437bf51d3b03aab4e02600ff7aec44dfc66dd681e9d5bb677d4619b94b69a0d13689cc1d52159c0049d5537a1f2469ef5d1f4306d74034d7209c8dc18229120a999a6ef4aef6cefa00035b5717a52856075a785f5a16cce165d98a9c67ebdbb72d938108fa4a95817731c78979c66407bb0909d694a52e80b9fdac572a985ae42e81ffe17ecd698ba9ccc3f06d63efe16120357259ee8af2a8cec71e608a4e5526849733565d508eecc5a1a58881a885c9d17341ef46a7ba8cd1746ce21ca8c0c2b3b0aa152350a89715974a0309aa2a6d86bd41da7481cc2be5ee3f1d553d3e5613dcfc31c23c581a6ab1a7697bfcc928818a709cf02d2ca525c4c169951e7d5c3cfe6152e56ae4d97df8b1eb536d85f2527a884c640864a77a7c319606820cd5db332e20ff067ad6f29d9530124b4fcf0b541926dc7f0a10475e93c0c70884febaa8a5bcbcf7958e707fe9186b26bbab3c7e218754dbe19499bcd0d8fdd2de0916c32c7093a8d5de164f9f8269b202feb891b6686120aa82c92506c8f8b8bcffda585b65dd8ee00f4226358ab99cb4e1fce82b5e77865b8f8c338b96c42e59e8843914e5ebae0b0474d56da2c3e8c870c6a7a7161ca4a0ae23ad3365b7eb2ba7c52d07c322bb5c9a0e76541e1081fc26cdbd28080d179f0dbe24ef945456c164bfdbf544b409cc753a443f4124bc084528efdbbd1877362dcb84368d77fe99af57b46176eede7e7baa8f115d009e2b9f932ef59e9749c12b6753e18b60a5464aac527e565ee96f1e3bf3fec22978af9c2867b24bda74fb4bc708bd248226c4467f07e60f9c21812be6220a974377326dec15f0aaa1d3debd4e633ae6ee8f44fc1826d12f75374188fa79d9e418059c86e3fc927ce8c82f3b94da8d1844c5cacc7fc0de2934ade46f6a7b66c236c48b574e35ed51b1b31a9b7624175ce828593a7e0fe326e5e095a800d21bdec9f7c4c218a73d176aa6855a7168c04ad9c4ba21f9167be2960d901b9fa67de9381999f20d98744e90ff47cd6b56adfaad136947e18a71f1d2b8e477231775d8c8c1da60a3c6d2633bc374e1a0ae89814d894c5046dcce609824197efb19dd4593deb1f08511aacdd391725b4d679177cc2997699221c862c3c2cbdbc312a2fa91ed10876fdb4b3f46935d754608c333503cc5d2e3a3b4194e040dd10852374cf7506419ff68b4fbf300ecd8e16c4ec0e5c79ad5507df8bfad6de8987feb7a30749d592b7f540f2186a6064be798f51bda79d2d192162aa82aec69c8c6601a6362b27e2fc4728316dfce53104f980d04770602218eb4d3286dd5dbf045fb3366b38e06164badd313c80d3a342ba08bf9e16680d03bcce6c185a797f221e50d7ba396c7c0896175f095dddab8972083717f42ebc54ddb4504be29d6ba6d331d34d6c4de4a899ccb65affa29bc02b63f723859ca4736739f0db11b0b95863b4652f398c38621f1f94aab7a10e36201d190e1d18518379cf2e67087a515c3a037ca722b71356ecdc2219ca2c3d0f71026ebdc58557360f6c5416672449dcd54ebf6481671b0ab03d4d9aeac45fc8c2438ea059a4471f833375a7a283f9b1754720834a65ce1b712adff6a53543b91548eb5ca11f22554b6481c8044e2d8f1f1054710673f41dfe72e5043f61a806ff232e7d8aa7fde6aeadd400c4a61f4f9032e0c55eaa9b784edee4340098a59953e872ba992327055cb9d1cf610f8187e62ccb9dd4798f3897843e6f36c0d70dee3a65d56bf3dfb353a420551c257253a60a1fbea113b93369413258f0e3ab3500dec3eed5f6f5ebf571ec2bd742ddcefdfca9f4f0cdd347d19a893b519c27e6db50c8a7f5536a73c7b5095e061a2a504d556de570e0c6179c4452f585cc75bf62f2fdad09ee72ca41f80f790ccd61e95bacbb39351545b108c0b70379997e8c706ad0058960ea56a79a047fc9842cdd45e81e93af22f0119dc36d2259dbd6c40e1f078de825a46af3c4a77c64ef34b988e3e9e61a43a10c1a8e6077783379f805aaf089dce1c7a03a780ee75c04bfb27dd80cb3fa9387af47e185ae016d52c52f5561f4ea4ea62c5a01492066a3342267a2930fecdecfd12004ee5cb86e2873e27506f1b96f3dd4ad5f1a86a4c0b607a6db92006f7a1342214a22f2bd7eb6a4910a89cb41377ff818e804f7df61defd41d2aeb055be55af0ca13c462a2a3c6237b5321e909dc57c23bdf0329bb13f2dff1ea73d7606265ffbb2e4e04818e4f14779473d05c2f27cfd6489f7492e2bdfe54e2257dc9cc7d42e22d3716ff8ce2e2bce9218060cd5864a30511f04cb604047fab7ec614ac1a98e40aefba40a0748ad9e32209eced125ae78093f215a74ecc8242e86576706bc94beadda2a2e09a448b8442b723f45a7eebabe5a618c61cbb14fa90a10a0908b0f7a317988a8a3d1435e7e5e4aa93ea72142193870f89b94bc36a7dbe5a6562678035f7e4309dbbb02677f0de0af2ade6982fb9398ce958cc23d5a8024518d30796a5f8dcd1366e86cb221abc0d59282896206d8992ee6afdbdfedb64c48caee171f842428c534b285d6930d9f7c9095d43f8f55c7191bd818f1d5d786179d59dc8f91bbe9f06b66902e6fe5f2209b47b51c4518b50d51e5fde96b940cbc6fceb6209f6950efe2360d4d276b48dd2189697410dbcc4a5cfc5dd525b93f438d05dce42a619425ddf9580a887f4d631d25ad61db375028f89bb53071dd79479e98642580684d294dac6789ff1eb4a3e76d3466262f0e9060c7b0f8fcc5b63c00d733c7bc6e95a891d0c9174739f11e0e2af5568c891c5e2ef045cf8c66b48e0428bc5cac076c64ff077736efd9a92837fee3c1dceb9bebbb2250a8ce02b749c4ae8e6643acef3a01995764160fb03c9368d0f2b95fddc0916c95416559876d712744a061698873a8613602e97dd86182dfa2d0c92eed981fc990ce7e8d2d08139e7b9c18d871531d6eade9ccaae53d30c40a128b6e1f31fdbf53453df922eb2c061018772af1e4e802560e98f045b349ec476fc271a908c9c6fdedca66064d789cfd6216e1ee3dc3f14ddf314fc1ae7de2f7bf64ffced8229c80c1bd9c4e7475d6a0cc1168fa121730562c745dcffbf37f3aa99fade0cf2f819cff2e33c4e4199e068be4e5759f000ef21d37191b79ed748858a658ca5a0602385ff52975a0c62963119db37646e05f10c1bbd596c96e64bafdc607bac009f49011ddc79cb0bc93a62eebfd4fcab5c8260f54e129d18bc01dd5e576603c24f3274b8f58f2c60a3a712617d420ebdfd58f976848f858400e472d8ab0870be6646a9104dbbe870fb799b72f42e073cadcff622dfa0b61faf7deac0aeb408bb7833396875fcfc4eed6f1b209c7dfd6467fe300b2926f6b02ef69d7f9f452451261a6d1c87010869417deaa297ec0878c340d90ab60266898f0c4d886f13f78f27470eb73472299e89187ac1ae6f8e2bbb80f9bdc449f030f85c52623144b7cca39a196e0454bd9a11bf836a48b43e390efe8a6fa24025d5958bf795a56b36443f53d600366dabc02748b4647695bd7ce6acddd4e02f046787f66d1863eccdf2975b779d324d17a9245f12cf339b9b3a3240aa3d19cc10023016311f41647c08137c751074a7a08cb4fe5d2deb0d72bde597c53b9241807c54b55b21a9be5b1bc4a519cbbb94bf843fa4504138480fb0d23a5417083ae28a1d540889aac714fab7538f5239351683ab44e2e4365f180803880466639aa016d4969f9a1f9a537e8f9cd8decd63ed5fa555f8f34ac0c8190dfb6e41c47d2c6d6e7a0a8cff36a5bf4cefdd08716a8f53dd0e0b4b67c36c10b349ef4ad8b9fb4f0c4617ace4d904be4b207356f585b7f31e6cbf483fb1e584e00ba1e73b86f8bb0d8f49f2ae5c9f284e2c4b094d68e1039d2dc569043425d6b287da85f63306afd25a2bd5671f9d8acdd2c2facedff8ba3a18becb4e8e1f05447ad405539d90cecc0403345b9bebff65380c0967b72bb86e56c2a03b76fc0c815abe21d5f394cae7f3d02b57fc496edf55d5d31e6c827f4fb0aaccb34dcf46084d97ffefc9ceae61d701e701e95c1ad2cf81d6d7d92b14c65243f24d59c669fcee33662863c0d01dc05b15c21668d829b9e14ba6cb79a4500bef2ac0e914691e182bc57f39b9c842dab3786bb8421eca7102d0c1401ab82780cb792785e10508c5e344891b0242adf6c9ff650fe9b92debf05c18c19731d1c83dfd13bec03984be6ecd98e2e93b2f8e7abea3a8a9914e1828b055e5b1a2930dfb2bfffebf427ce3a3db3a9800949a512ce6d72483d22ae6705be4a5ae59e12f4aadf74652db48ba8f3528880d5e9f4ec78e50f70fe19c93349232fbe379e7a1d42a542ea8fbb22ec312ba53738270ecebb95df340ee56cccfce9574c6067be1b2bd0d9876191716cc06e6bbf52c6bd021e19a57313d3be1c20b4900c472f22f0b0e358fb998d1cb4d69148121ed9ba22bf5687835548309cce07e710204b2de0200fd696948dff788e9bbd930ba639ba3bf03fcb5c9800fbc9eb5d3652e31ed6673f2904dee0c73ef3c0ba985e984f8a0df8c07e9076196b2a257bed29a10a78e68fb4e4c91feaf4d8fa16ecf383b2883c6ed0604ed1a51951daa15a5a84b564557e09d6e11589ba0f2e3168059be2923e614a3216130d880d1a69a87a42191f0d1e621fb16c77d45cffac0d46d22915a25a89f150813a33a9c3b9419a7fe7a0ac201aec1e07c0484fa7b9b5ddf33e27d2be47a352c8f9a2f86d66e679823a43221daa953a3eac7d299b826168359243a6b79e2a8b63b846951904f440c799ed0c3ac21746cbd0dcdea22605d3bca659a3be8489074a9de2d9db1a96b6717c0806ff01a1cf78c6e4685a39f14609283b84a207eb2a27cdbaf1f0457ecba859090a046343cdf6cd5475d434bf0278b6eda30f0a643cf133868633a30f671d235b873d2e72bf73667bbec267869b8ed6e435a266f59bd901747b2c9f4607d7e5ca34c2e3977198a4ae659e0af2bed0d8bd3ee537b5b617566aea9aa184644bd81ecaa9bae5b4614f7d99f3c25b1240798f1eff17d431946fbfd865e6015b25269502974439f63915728bdce77c4fe5917a2bb36ed9bee3f5c04363fe75496380c5bb4f6a790cb96ebe05a17e12946d68367df3ae35bdb08ef6231faccc5f9a029063e30e420f1f886d406a8f90fca09ad34117b91add931f43c40f039b1b17325b78dd6bc951a83032bbae4b06e546cae648112ac996c6175a9c479f3adb023b3f2c332478b3750723e67e241df7b102fc0b347e2db7491e15b1b4ae276a11ab5a42234cf37d7d5de54aef0272bf05b3d0ca270c0b9278df5f1cc45c6bd645cf45dce7d3a4676e5146866aac16f459fed6bae76c0939883c96575543f638bff501a497a6ec7d82edd0918698c173ffd3e434a970da6d6abd40fe50fd8bc6b5ab29dfdd92a83d306120e49c065c8fd6cb8df1f721913a935f06f6db39ebdb858b7ecde18582eee49b21c85f75518fda207c9ea71c088ff0231e4a8037f9d5282e7dad653d396a3d022e462a2cc395b587021967e72b9bd12b1745429aa52acb7e460a8e1dfbcd59fa0be3f932f148ee66a756f4425aa3681c9720d603a4d7a1b4b7648efbafbe0a03175ef7ddc71a8009c6dbc130820f2f28e4815da5d13ae27a79fb71d1d36b6fecb21a9677d0a0b0a200779d787c4a3ef324641e8c7231bb9cadd01d6ae0ff5fb2f1f8baa4bed44603a8b4645439702af51a222d570070892f20a092ba4813e3813bcb6ca0c0174062ba0cd4277895b2bb85840e3570cc8dba2cf71436f10a35d9e2d8f9146b0f398cf63c8a67545ff95d9f60af7f748da19097a83f77062ce7eb0312a3c642cfa670f3223b8a53492d21270b3622600d6e0eb18370f26e4cdd60aaa250010e054e3ed7eb0a84589134cab3a8c4261a2b736d769eda2eb46a00f299d3b05f45cdb6ebe78259c452a14d32b83f723b3daf0f08a688e437981c4ca4fbe3d5bac76325f5a04cca5fd5ad57e38ed2ef66a298d82bb0ee8fa1ee08dd890b1b860680c8d25c3e832c26c07e3a5d39219604e1f640f7512f1b52c49e58fef6c5bb716588610fc21a78f33af9045f96eff182efe27d55a130635a576499c7c905575cf44dccad5ab3589a12f9121b8f1ee93838b489c6144431c0582f6bb02a5240ea663779d8601225b590e602de7415abb47a1562086c7003da6987c7fdfacc6511575aa9ad179e455601d37b37bcfb50874a6939e3ceea624b8db4e3d70fc134b5300c1682104deb999ae62ef71b16b70e066e3d23ca4982019b1b669feda0af6239b65168ff4d4d6728d2c95c90d0ed0ac4479b1b6e66c2e6eecfb129a69c7674400d7d84ed838cff73323d87e9910de03c25e296440ce6f770373484302fd0e97d6a3f51e3bb27ea249125683d72117fe2bf1946d21829c97904f13339ef78e56d5bcefbcaacf1d3c519bf1dd14956f6ec8e325fc9a62062bde532873b2253de2eddf38cb8959129e78ae429604a4942a6957d11ee1eda8e60b40e09f1e688e8a54afd82de875a460f972903b0524f89d8651e267d53214c49511a8aa6c58113695b84d6150c4dd15267f82109fd5c2e0c13af8d84c8688dbd6b0f711be6323500cd6529007bf95fd4075dad3be7b98f2e00bdd74e8f9131f47a7f3aab10858660e555fda111cb8d32db7fdcb35034100716d0911d41ccf7e3aa724a410fb723ab036a895c3805a69a7e43d46b5277b6bc2588b6d87f6244e2beb7f188cb4ac37b6d12c32d5d7e68bf5404b20ec758b02a793053839a9956b6ca5ceea688ef70b29caee1372bbea8b1e647b773bfa7d57c75c2766ea399867dab2ad398012608f8f71903ba82519b086ca8b39891a4d7872a8664720857db4069a62c7be14f38208ee07e548ff5d8914f87b3d851d86c0daa6f7b5a57cc2bc2252b74075a289274165b4e28d09dc138a06954799643ba5ff4dca5b29acf53a3e33d41ee11f5b3ea923bf73e6dd852820833377e6a14fec2f0046347439166018e1465f48e745cd9091accbdcab3d3066d1af2b2b0d9436fce9988f35d58b7498a908cd9967b90e2832ea3f953d2f626dd7cc06e0f1f4385b6f22380c142d05ec99894d626c1f36178b5f08d030ab476f424e878cc9fe3cecdc8930f0429f5a41cee7d330849e91ec0b187a80b4360da946a355f2d67b737969e1faed228b9cc7112efcc626568fbd76a2ae3be9fb5cedc159454869182f46e4f717c8b9c62fc21f6cfea6373d79ae9d5e624c0b057578407c2de548331178587cc5f462c00271b68f52bf4b0b30e2563c50f5f32ff497344ef9e3548ae5e1b047ab11857e827286fdb79beb7aa20cb9be604cfb7aa5f255a84f0f561cbd353e6c96d01dc267156a687a8e6483c1b9fd5615f829c3d7fe2ac0338357efad742a2abaa31178833063368230d727660f93ce520fced8d61ad6a80f1c2efe7c58a53ea3e2b0985e3dd10dbfe0f00f649900e6640b102df5197c9503153876e4b701c6bb693179521283a435e203630f05cb2e4d3bbbee84208851ade301e9fd733bb420e8ec035692feb9a619b2dc29cf344abb8239d6ae07613df50551276b85f7ae9cbef5d18ea4954bbe347e652ef0b489481ab80668a427a91f6d1528755677fba7e441e9e944278a613fda8a14f20219848f0f0361c7c0c97630484e4e5cedf34060f0ee17439f8507dd04b0ecfcbf803ca5d9465c3a01b3f63c3cd6bdb8d0d930085785d57a93ac6e4ae4c8dad4c6bc314cdbb0a3ea59258d3198aec0e81004db9e62e7a612c6f05953032409468a25bcb3cfa2246f7e043184ab4cb457746712f7cf8ed027afb4f6d0cbb861c35409cedecc4da0934f16ac1acd69256d12b587fdb275418ab8defc624037fec438db597310456f408814bc15bc1aa4fa97f1e1e0d356c6ef7c326054c1f7782b1334dd183ce4c6afcc6511cb639fc226609a5df4b8d3ede4cb1ac11de1980577d1e0a89466e8a1f9848b86c16dc9d96c17715ffe1d759c1c65db7eb72e37e557a27ff224fef8a59102757b53c628e9cc3240447f38d64ccc7996ec79623f107c2a1452b30fcb0db466b185c142ab20a5a8c3f2c40e5f1a81637c736a3d84d02eb9d35909fe1c6d25a6d88d5aaa17eb9a63a344aa253f7a7f560160046181d7408e0be01b85ba9e1d714d4ed6895e3d3641b110e6eb4d9a553f4e7717d9b53cdc36b0ce811d60974d73fcdf2e849c4fe2bf63eabb413a234a01042a667390f816a1654bf88f347ecb1f879f12c42db934d22cc25d002b68d980c1d22ab993f3dfa26bec590b28c9c0cc37e58c25a0575e94c7141183f00bc268e4d35b5ed9ceb6066ab3fa54fa1b2d2c0eea0b3e351ee32ae1eaa3aa9c1e3bff35ca7fc6cc04dcb745220e7a0f5ca3227a0bc52cc63de0435a0f5d97600f8a20e84645fb0ec0efa670fdea45069b0ab796d7c54b24aa8488e757f2702c347153a7316d9879679e341740ab502c725c2c706fdfb232660433fe3d5b23b8dfa65ea9303ad84beb7564c286fcfe877280f51fe657cf7f70d5d4b5bad1c6e94d1bb6b1dce55059017e29cb10897dad529468de0ba04fbd60a40289bed4db2e1c719da53ae50b6889809fd0422a3af109edeeffea2bf5f72bbb3db605f3e99567426b80dbda805371113ad588609c5d7c0109c4d262cb2fb2013792a2ff03f492990932d134464584abd8f0b9198ea7908d437be83fc747f04d811adaecd0deab787fce8674c4285ccba93fa5772e6372e2b48e28add5df94ddd9cf0f77db6fab3eb5cbf2f008efb382887698f409aad4c6fc12b3d9d0001853f0a7288382ea513217ab497740896509e0593bbe492f2f3e6fd3f4c3e233f89def9183ba352dafeb46180a209a8371741562299ef1f9329e209cc5307543c8c37dc17861e7a958c002fa4f88e11c6ab697537d4148a447d89472f698b5a01b93808169a3560a9dff866f04716426e485e7a1eed71b2297a6aec601f688037453d915225077cfbfabece61d487b28b2001fe8990915d29ea062552ab090730b444b595ddad728b3a0cecee20f48bc42f216ea1e2f3ec3504a9e89a8fe2e4469f34d74621ef41d8dddb3aa05716cab779cf836587e243f8045407356b4de058384ee7073a655542524f38e1f4b07fb03210b5174a369431784e28b66ba8b22120fda0e90aff8882c5c43c6b9ce336fe3a5687761c71bd426a7b1ef033933fec3e13acd605a87a44973a6a69af1693f41bdb824a1b0698a7660b6f19f58cdb43f255018992d19a65195478d53e09605bc0000562d2ffe7cfabc60a311ef755eee7ca977850a013df5bedabaf8bf05920e61b3dbddcf875feb0049bda240621989c13c3650b4f6f43720ae0d30da6ba973c405ed67c1f8555b9563a6afa798122f579723de8fd9c842ea8f3dd3e1140b8f7f4891cedf6f94d34bfe96ae6a9b9f77289f17020bba12b7d9a3e889c4a0870eff3edf5db1c43f83a29875db3199a0889a6badd84f94d3b0f39373b9741a84d2447f70db27d8d45a5119e7d2bea4997b73aea10cbf0c149ad5c13deb877f4914b3d4e1ecc563ce6d9858971c21c448e080a178284ee4bec2d9d5b762763a4d83bf6e1c0b4c561e465b4601a21b4c813503f924c63a6ee7a6888678ea24ed62250cd9451aa5fc2f50b57ee47f587a192ceef5cf766b0696f8099c67af37fae72d5b91636dbe84dba7c41f791ae557f9f3c7667d4e76e1a8754e839ab471a23e9181291eb3a3f8f71f82be858ed89eec31056627cbaa117c19847a69c599305bf5c7d0cd1f771e16d40824ab8ca9f8b71558629bb33f42000d65082d23c3bf0b8c377d65ef0962ae999e0937002b73351797fa6dc66022d306862cbbcdf4f228c5fdb1750e20864616d3e76843a96c87e907160907401f0724efae6b48b4b0c4d67fccbf343559e57e0b0892cb95593c81ca7679b0e8abd14efeed1fc0d0a2bfb1394b2f1bec57c4f6b6deafb20eb0f4ae495df68fcfebcae3c6a566b023c10a9d0504930b7cd02649050d41d06d19a809970a3c7bfdd69574ec02c4bd43a02ab385363a4d8013bb474b9cab4895d76f2dcdbe3d0d179bd296ab1d8cf9e7a558e32eea68bb5c4c73238da82086c6539f1237ae788ec530efcd1be8e1b15c09e5bda0f93ae66f5049aa222353fb441704aa952a77e7a52ca164cf10030c766eef0232778edb19d77591a3171b8686d97d240d0a59fde8ac8173271d062cb77b787792329525d8ed1efaaae271bb29f63ad073288308945e16fb108bdaf36fa43aa9725510651fa22256481d063f81f5d6b34a10880c4c122f6494ad72c4f78c85b9c9d3b062cca7f8843fa2880bd21199484bac1a807653477548f813b424af6467b570f28ae4f5dfcd0187d2279f0b5e294f88d35ba4f127c9b35c903d3bdc852c1adb1d7efd5474d90a24f0784c084b8de9861e543ef043ec3e17b3e1bafc2fdeb227570dcf5a70043864e7d22d13c4f33d9bdd6e9cc55f96b38566b69563790d463d2166b1050d7100a51fd178cd8c3ad1cac800d7236ba469418f2b3e6c737b0329dd1849b7c14eb614c7ab93169a9f2ec5b791a53338fae23e1ec50d60514c0c9d80c13e8c3cf80fd215f16d129c9589ad54b857824695119669ed451841ca2f57f48016e7432a38729a199bdf4903abd4f1978fe4f96987ea3566e5c8c6a6f88faf601c98636aa4d6f79b660da0aeb5732cbae30e6f8d6fe6b3e20454a66425e38f968f6ac0929a00e30f16038ead29fbd667ac7ba51b5df690430dd6e22ec3217259ba268ce5bf7d7c06f7137a79444bc0f34569d4cedb64c35a4fbf5dca947daf8a00be5e77aee4d2b420744119749eb2aa34616aaebcb5b4f513f56cbbc5aded78c3e34228b8fe75802f6162c5266cd0512f5eb6ec6ca771d6d0879ee6dac4448b015322171cd615a95049cc693f437b737d3f5827b701a51a513ef0b375e39d500f6b849661671708c8984d3bde6b68750c475f805f947dd350d6d64c6651930d26c88b6e7fcd3fa811653e329579b1260885d327afdc2dd5819b564e8a4048d31cb93877f3c81ce71953ba7f8f4781c81f21aefb89c1c36d0b433febc30667623e49966f00286c7eba6c8e2bf2e19c97ec840d9645cd146106e3a9e88f5e92dd4086c25a7a70748cbeffa8b4151ad3f08ba6831611669e97f50b5129c9a59cbd0d1a474469509d1280f077903b62802e8466ebc5ae6f342dc44fbd09946f40b815f2d30d01a70c25e066263061ccef49ee2b1508fdfd49a7c72596ef5e5e528de14087323adf832f48603c12b63c6c9f01a8504e4abb2ff51181b5975591c23ea6c1b690f88dfe9b993020e1f755e844ee072db877ba7f87d0fc933c419a76f88d746016da95d69c08408a5597363a63ab8139b7dec8d93d5d06f496205c63702bb542ccd04d342d5805859e23a514f27e895399f54573ac53600c49b6c684287ca16b61cba9e86cfab86bce2ae4c6a661f6ca61b18c853e8cbabc567392cfad6fb48b41219c737af7e2e4fb93c7032c7c585bf78de13c34f49482946702dac6efc6def142c404523bebfe46152691f667f0034dafe7bdd0b819db4109e23ca337fe777c37131cfe0edd8025acefb8e23e4174d3cebd39b14426e1c5854f4042a3a1672dbbdaa6a35033878d915afc72f7795d32867bfcc2c32c5f5b51b7486541c8659e92327033e704a1e9d18398a47d7b3a8604800be0a93f857ee9482a65439b2b2238b203080338378bf74422ec0ac253fd4a224f3f755db4093f8fd2ebf9f4922dcbbcfa736f08a3ec51697a33d6b6bd93909977846a1f62d74ce77a49865a08fc099b4c3d4880c47ad15a69ae00598eb36ec10e2dfc45eabc2b640d8a440a475046dc06d26c790865e575c45fcdee31cbcd1a580c25ba324423977d50c5d3661449fa7c9d9fcdb2a6f5372727c6e13216d69be2590169fcae2c09162eb2b7be881f23351ac94682d543bc7df955a972b88e1d0ae6ea8537c7b6362f55b253f96df284de1bf8c3c8959c8458f8e2b4d5642210b5b0082cee608d340390cca8b496f2eebccc7a73b72dd316fd593fc48afc13c3400cb02ab2cd3b2a2c8799e4239ebe7d7b4b80e9dcbda031ae5143f54d79c7920175cc869acb06a41112552b43abb2ae03b421889df83b9710d503b18856e5aec3a7efead7d6e0d5fa9be669da011f13da89ae5768fe9d3e9fd793ac916881b09f190e8e18747687f5b9b2158a87f567508a9ae3bf5f1b046027e76bd8b297d20ea631d62ca5a3f8cceb5b6d9040ed1d374403f8986a6dfff92b8b07e710e7c8be14d93acb90b7c3d35d327dde93e99a8d0ff0410cd1152006a1a222b70f6d278ce1d107","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
