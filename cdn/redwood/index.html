<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"751b4b1b6c09a5fa30a503232f8a208ebface2ca648f51c131ef5abb472e19a4ba432801fcbe25806081c51e031301600bcc17405ff3801c8865814478999d4e45ba63f26a04add9119aacf6ff3be9b8cd167af50c122b5da82c213d7c66df2687b7dd36d7ddb965f78bba0254de1bd20c068f25c021b2cb2e41ac032206e5bdc4b8a85dfc4016d2ca06e5d9103c4e17da27bc57c94ee1f30678de2fafd85da52eed0f83fd5abac4064b04f59773459a7210514726b19d5e1783ad15a398e052299772301ae2c2aefe508c98ab8a8a6623d08df486b1c75c0a96e66020b9c75cd52a71e9ae7865b6fb85b78d516e0913da99c07e34b2ce7b61504e3797d99892aff7dc21354a2ac82ce2bc4ba852b62d9c66e6531d66f9e208111e261b33af31d12f7e5817a768956de5f43cc11e665e661d79748122a55d65edf10cf41d57a0a3739ff9328293ad45e231bf9ca353882cd9a9d883ee9cbb451e23e428eaf3a0eb66b58ea045121bc1112f228ef37ff8625c4f6b3e885718400e2c9824cfd682fea3690db987b370173c8a73cfc9bfa2d730695051d061cf125a274fb2585b8a9686bb1d2b37e5a17bf7ee530ea35d79bf66472eabab7ba34430552f46f86e7ba3433a690fc58f6614acbfcf627f011275cf9397450aea0b6d37f43d40932f9e1b3617e79220019b3c01b5a23ca73cd83c415c86d431a69e9d643cbf72b34b56e2b1c1a5fe02ba51a27431d4cd73d2d458654c7808169d29d8d51277498f6f13bebf036719df3c501603c7b2d2d477f80a2a599f5790fae41564ec5352f8ecad17f82777ba7b4e56dc968dbba412912fe4b99f8ac7f4ef41c4c7c8e7ab4eded28f1776269c83242e2b89143844aa8800146479912c4b34f233bb57263f2d6ccd41fc5b36f47210e347e21b6e0a35f953616e94f85050a90a10ff7297b7c81692bc43e626d5d9bc218061508ae7364f66627c4f2d7fe7ac9b109086051e99142aaaf0e513c0bf3f9bb02de57c070b9a93fd567b3861fe6b8cf148beb601d4996f96f4dd4109e70f61a1bc2aef9b84c5bba1b4cb00e3e0920e49ae2000a0f01eba5a3a3b2d463a3be4218aa37ad9e81f9057a10f2566b9887d4c391448582daa1fe305c734f8b2f5f8bcbcdfdfbb71c96871ba763f756783e6154b40b223dddd5a70001011402d6a3d866871db19ca371becb4da33166fcebb948922e656cef22aea4b6d5113297f2fd470265897b4aa3b797de2a778b56207658216abd949f5d7ca8c4a9c051d47106063a2bedeb28274f9c09a490c87fdc252d22556a7aeca795f0e44a8086517cdfc8e421b55d93a5e23d87cd165df865c5d79f48a29bdfb1f8638eb96850c91e059acd82d1edfe34c684ec1199db5cb5642a7251b27d1633c568c8d40539497ea6d4efa239116cb30032ed16b1b5d42d120db25b8d102accf23736814c2ab0d524522751059429515c09c1aad91f1a24ef44dca5688e8855f5f68b3063230c44c8ac8f1ed3c79b1ebcd9883d2ccea5fd7857a227b5f7dda483f503bfe66bd381dade8fbd5fa4d05161621e643419e41481aea03fc5dba92d36bc181f60da0d6b6cf7bb646dee893e8c011804a4e66ac9e82580864180b1f835e773537e7e11c58d40d487c30702a13037b7e6ca20a8134bab509bd9391b6238647a4541bacc38fd80449fe8e6f91afad5f13ba2ca421c23d96b7a7dc193f7b6b00a44c780a1793303c5e028f7f4b0064e758fcd5075c76d2cd1ee068885dd526a978612a07aa51e31c5aa66bc7de7bb54c86731cebbcbcd56e176246a824e6881db19798b65d7418469e743ff4f406cf8c203ce57fa15852af424b624ef49cac17f761f807c3ddce933536158e05dd91713cc28fd1d9c29cd5531be936c99daece3db7c24db1337d76143703c9289693864c64b446e9d6b53b038538bf7130d860792af9ef4d62228d2ac279f061659f5c93c3656af32de7183370ae78c17be392f345b372ec708fdc23cd3a088d6555fab61471714197e18aa97807889814eaeea4ab7af24a8fcf642b80ca062215b8b8f4e4433cb27337bdf170776797c53e76c767c27129e58d37e43cf8647cf50464d67094ab2835d9d7d250cc466fc8aa234a7636f85d541e039fadc389abc0c2efb356a0c762e9c6039fad783fb941bebf8f5250909c0c74b3bb38d81046d6388f604060f7bbb08928a231b3b4e2e458058c3b3653ed8b237447c912f8f88ad2d0d827c06eb4a087a9dbc3a6db6ea1ed1e9f6db5e33e6be3a81d8c7ca43e77e69742a16d01ea5246583362effe7a905b433964e3eb96c333c11997f922e215be0d4992234179fba5b46e824377b22f7dab5783d904ae97988ebbf5e262d9000abd1f5b32b4b9c5b169fbf12b65e559b44e2b23ff5ae06bf25a12795ae4fa32c7e92ee0d0950a3af5bef0e693fe7738cc84099676cccccae67a92e376cb5bc8adf14f5326ef66487951a5265ffa5572bba57f2619008c313788ca68a25eb0a320f2cff6a1f3a9708e71fafd508cc3010d25d23067c40f2d9174e7bbfbc43f0ebc9e71390332fdf4aa8719b3600c87361d195a6e9214c9ae73a14e2121b8002dbb6ddfd80e028b208267fd50b041a277112ac18b157aee7520eba03226f21b176201d033a4256d02f65b368b01bc71010851ff4a1c348376cc15ca31a396b417eba4a141190f8838339177a0b02096c35de908b67b3659e9ba284a034a5cca64252ab52d8c1b6774564385797d14fac43518e37597a91a7a4d29e59150833895f543fb4c26aad08492521e9c9a91cb597c96a3b39524e806cd5706d4a25e4912d6609310445d863b008c633baebe591240bb7da4e5bee3d5cf9f42734f3a618a2104a52d8eedd499c5175788cb7c8ae56f12b77ecb5cab3b9f76abc5d0aaa9139ed3adf90659fe4c33895c52aaad161b76702426177c3f606fb9a82e030034dca3e1e62e1edec093e98156267a7da3d71f4815cd9661fe7cd3c0721d3aae29df872a4c3f1f6f1be8f2260d56e9f37076f5d5d46fd303401f56d39ce96b2c33c95f9d2e51c5b0a803ba5f185b2496539435b0d9a0fa314e9dd0809b1ea6b125a80d9b99bd6d95bbd061e03c5b3af5dae48ded6fd3fdf4d7a3b69bcb893bba64d6245accda272923c7bed9474ee2a2893e03e1194e40a2450bed7c0aaee890dd185675ab41e600a264a5bba84d2c410335951109ec4e7c48356746d93dbdf657acb9a40968fe7fde1eb0c497d9df84d0a7c434b5a3b200c5bbacf184bc75825d1441a10084feaca8413786ad6128bfa20f6a641d339c55fd3b9da4d1957483ebb52f53311f368698035cdcd3d1a3561d7e55ab729f7482ff7d98a27da886dbd8200536ee16c225fb1f090ab115a20e6e9aef0d6edc7961fbf5a203f633c2673bc70f78942d4df1140a0c830a9de71d601243bc3fc6544ca364339c528a2a503664cf2be21892edfc1ce14b727f037b13f7bf2ddfbebdb69f3720ebad9c998c2597535bb72a7cbefe383d993ae37883c99865cdc39073919d8c3e10686d217ee710d285f184458b743fb98710eb4bee7de5a8cb67b143720f960e80a50039a902d6623ff8a0a1ee7a35511452211dd7a6226108790f197527559e4566ec97204c59d959b67649bd30cafdbee18d14b29abeee0424780f7c87255869385c4ad731d7a3332074418a17179f3157f9b0065d20e0410d2031d0ee881486415d177aee9f4921a367106a510ab1e7018d694d73bedb6872cdc3f39a2cf75564847469005093196b45abdafd1f1c847d2ce5be9c968009c108a9439ffadead83fe5972c909a38ee9f3a07daf4950ff045de6a5cfad4e0cf0a3f06c1f1c14ae605d233924df8d825c7578e40392b9ed1a4286864c5aebb935de90f355d32b75d6d39b3d955c0b0552771d4a9867f998738f8b21ee45fe9fca0c5dd5d3ee985accfae83861a45d82fab2319fd7c5ffe2ac4aa49ab576f814c8f0a2a4122add38307cd984d6ae8c64227a3fe586c95e7f571b015f81fdf486fedc07aedc4d895f5b360ad1ff592ac02dfeb6cb961a6ee7547d3c5f12f8f31e31f9b26f430fedf155fc389d5e9ca54ed4427756e30df5e4e85ef6f440ac6e59c8a39a4ba55b2aab6381d0bd8dc9fb2ce51b5ec2b4c2f26a1a03fab0243ee11ab1b07393092566c3bf6e2aff7f01fdecaf3f38db0ce35615f24362a5eee8b87aacb73acfab58bdcba2172b55f0d6a6a07b54c850787e1f8f06e5013d36152ecc9bfc7344fbdb46de8bfd2e7fd99982c4a0eaa43ce9c81fa6374c5da146ea1a1f93f4f14c862ab3f6aa6cda8d4b86adf5a24ff9a779e24cd342f1459eea7d363714a7d6c5f2929ea3132e244818b258dc9d32fd646158cdcd879d10007188d9361a2a03eb3d267e643270651122452a1e0f1fb0b755cfbe6e11685aa69a2fa9c4f0bb1a46d88fcf76a910b4d55d1bbfdae4a7185d88aae1082a060b211ec050da0c30f6f9fd58a8e8dadca8fef923c0f510ebf4da29ca1bd775b0fda451fba7f0ce5ab7e3448154f8ddb0c17e93cafc8ab50d6dd23a53cec22fc3902d52c9b51c69f3d2a288c1160eabe59f9fddb5505ad53c40455063b4d23fc63c365e188c2194943a72f1248ca5f178a41c5c7fd85fd67d9aea33037f9bed7da211fce0bd9f3e05e3fad23595773881322f16a49d41e75c0ccbb2766c3791001025216dca1276c8e86a711f40ba15f43c4facaa7d3af998b8e55a2c5b5400a9a472eaaeb1c2ef4ccbb9475d41e7fdd09a829f0a0ae6885a1f7eeb9f80d75229eeac12dd230edd1c8d8271b6c450806402bfea159b158722b9b8a42d27303e2b0d653cff4e211d8d0de3af818260c79b4fb0ac34933a4005d37d3ae0e1c91ab71238960ac3ed19fc5aa43f2fd86b1006d863f32c791f4413c3035a32eb58ed56a4338f218459a373d3e76687469881c5060714076c90eb8b906e92a71ce4ee90f48808e65d6b87a5cbcb5e4202ab798b36a05946af6b83791e59e90dbde16fa20b9d4ab8ce45110fc6b4f41f5a1ae6dceb662f48eca8f44b979fc8f8d43786ce60c766cc94eab11c34a7426ee25ddd761aa092fdcc37511fcc84310c03057d9d3dba0a4f5a24b419dc3e25f664e2983345fc0bf77fba728e26225245eddd7dc8148db50b13238c4d3ebae59e7f7ec8da176f91d7aca8e05a35459b68d9c6ce48af1fbdf7d667f7c2d04fc5a63a61e68041cb26595092478a1113f957945c063aa67fece686414e3ec6ff49ac386940cd55ab2d101471975d253222a0ebefca65921d27feba01db57f10e4e993aee93cc319cc1d9f0ca44b3b1d71156df44b97b99b29505257e61d7923254d9514360d774209cba3e94b505fce148840a69edf86dcfc3c4974e94bd274c5e3717bd07fd63289027ca557c42334fe5e46e50b7cd378f2358b9f4e60424e3437bce0abc19225c462fd82e92301c37790840d2070f3e7707f795f86a8b6c05214abb942844b1b1149cfca6fab6c60d82c5755e5f4b5c83704849f698fadb584590a10048a7ef798669eeac4605c150e1872f963e68ea0d6a836d7fc405a4a7efe1b3f225f1ce9bbceb4035efd7ec1a48a68d39f37b59981dbc2c926356fa56cdc5e9afa1a8d8f8bac1b6c1680d922fe568253445c3a64f8dd64720345736af5fba86ce30580705a11fbf6e788dab425aceaa805df91a295a0a785b92a0d4bf16a360b21c92bcdedb00118ab82054b7c50c48d4d5ffb1d503c02f5d39d4929a08381d53735a992316532f33465da3516ccde6346b5fec5326be60e8693dd99887dddf33fe2add3e56124ae4d1344d321ebd75e776bd00447af143e68ec7da0ca0ae817d588287941a5c31f0ec287f4c41df7d1bb5effb92d2aa721c514b984fc6405a7dfa832b72c496e432d1c38d6434a50881fd2ff4be57298e32bb2da0ffc96eaf463e113e8888b64eaa1c9de93f7b44c30fb100a7e6368154c3cf0e812fc5a22114a4dc1c61d43e535375f4a6744cd8bc1c2c50026fb93549f3060ed90d170497843d528d39c9e0ebef71b177053bc6672dac64abf955b0f5bd550f91fc3ce47229db913a809f16e3c36e3896d39a7ee78049f091f7d76dfca95bfde384f603eb5f7c8692973b5506c0ab7bfbd2f7698fd6ab51de08314012182d122f5effd5c7b288354953e5ec5d60d9c9efb8edbf14ddaec4bae48f1309e5f3b33f7bb64181317533dd8bcb1c87e0ce6c7d540e438c626de9939f5b16e7305f64635980412c3838fbbd1f13565f2a04ce41b848363cdb1d2005e573c1389321b0ef0c5bb39ff9427c65b76b1b5a1ea944b615a6e72674b36c8c426d3af7b6806450b1dd75dc2212b579db12849a5957ab7d31fa5332207a6747718e0a2a85b9545f859487c1b2c5ae3dc1b3b080494d8c346fd96da000573d62bec9d2ca073017057683d689eb4dcb6b037f01155aa785ec9c9dd6bafef9df5d2946a41d93d8f90095fff86908e6469ac107f3899812eb6af7b4ae972b58b7a0f6d6d7051078a93ad06360ef8c31e7a02fe89da5bc81a3e695f04484494725642bd400c447b132ff5104792e36725a479fd13cc692bfa6a4fe4e9466c480cc360930fcca2fbc31bcdfea955e9bb2213fcfda29124cca89d0f872cf396eb85ad6bef275fda9aeb25485c0d62cb9311b4b43846518a3ef3a084b02a969958ad43584cae408f99153eaff8dd2215c02fd19bb783adcfc0a10923c75bb809dee968c01e4c98957e76b68ed684fe0cfa1bd0f566d701efd9a6b78b1232a62525f4a46503df5ef5277e4386af14867aac5c14564675f42f47217ee849d65e314fe43f05a4fee622ffddc327c3bcf2179d2a74f0b8a332e4b1257cd05b9e0b9ea3b03c6a2ac4a5393822691c81d829c93f6d452324d17fdeaad6aeda3ec7e4556118f417a13887f02b99e2c88ccf6d8e7878eeb40340be71e6bb98710cb66aa81f5af89304f430714f750cbc07da7573ed60661d008a146d32f8f13766cb3a0ef2dd48272a55dbb7eb75b9f44f7831bce3de5a70c089dccf5dd2df5252793b83cb8f29b96ac9d25f64473056c965541a35f7ee4b4cf38c9b5e2a4e7a7227fca00f4b76cabdf81ec674aa21fc7b4e22ed38fd78d299b7687878f66f21c73262e9c0f78886896a5dd819289b29244615a323ef9579947041cf8ad258ac502d27253529d7aca40716f46d56abf5b8837759adf2e5bad74af6d18f92d14c4f274e65e59fbfe099c79f0271e3e3fa7ab115d25ec45987bd2af2e081ffadbbf69d9bcf823d233495091fa2e6f27a00c4a6fb71ba9948fab997b2f498f28eab0d965f899862c7a551895a4a31e4abb72ea48b8f7ed159f843f3e42fa7520370f5c97f9b55ce41a42e4efae0f24cb9961261f605077e52db8af268198e0cd31509f362c2dea6feab29db138f010193b6e95e91f81cbb6771a21bf5121ca34d688b38babaa34b278569eb4a7b4602e57cb8a2cda24766a4c2f72e96449b94c80bdf6719aa89e0dfa921decea6d4a2a53be1a1fb0d483410a988cbca3ee60e432a6d3cd0465f437ed608a3310777c94098bd741bd608bc4f358eba16228ceacf4c9235313f44af525515dac8c34e2c79daedd3bb428f80686128df1c7d7472efd4499390d1783be76258bf87be6b152c7c1718d17662abef9eeca3270887b9387ff5216973ced11c0a075f480399c3fa8bab8160144ce3eb08fd2396d6caba3b653c3148b3958d98924769e244aeb6ba97ffbe902a03e410d7f620d92e61a5ddf7e79300fa6b0d29be60e663133f33c09d87bc476f63a5eb26e06ef1e9a1a0eb72a8b53f1299db412e466cfdb6e85905184631dc5e1ee11ba0db069aba7c46e5e3fd3a71c96bd18f526813c4fab4f036bcb8c28c0d0c01954a1bd186bffc88066bba9e1c25403c3f6f87d120a4d12ceb258d89b0ea333196fa43db408ae28194f51eec19f1241bba80cef3f14e93f517f123aa6e9ea76e60137f6a0f0a8839799ca8ba1488ea349da12e7f7a9cc6e3448cf166e94cc637a5bc44ecb8554d20a35a65540b57a8a4dd643ad7a932cb5c2b2a95c530b43e3c02016518363fdfebbb36cd121e6edad093db8f46e7192d23f1f0fc3dc3aae6f70d552d7c771366b7ed7e841bafd46ddb90e17452faba626a1e963ec23cadbdd03daec10dc04965eaf36380c0257f0db862b108775cad0d1e79a595a88b59bee4f2015ebfa42fd9d3e2c6c6b0a0449e3310009d958fc62b98df98379d30912f845e3ea0446601f93913c4834d7c7b8770059ce9f3ab7c8d8724e16a25403d1599d89595d292a5607e33e46371e87d6a980a6e39e74917a18fe886dcc5a15f604e1335c4976c9c20802df61293d9a3c3ce302de2ecc3f8366649000706bff22ecec9a3ed133f95c4c5bb0d3e4f1f5a6eaa10b4dbe7f294166b90e3b4e4deed45aee2408546e594fa60d7ed245cbba1608434e9050aed530e6853d9f39e8c09c5ed0532dfddf197df393a59146e847a5bfec89bdf3e4bf76d077a7801cf618c02e78f6298a1a15f6b202971c0f5ad0c484ba36505d8592a6848e210f52ece05b773dd7f320338f757425ca8347dc5b92f8bbd171558709b7a7e3ef2b2ad896802ef40ca4085418ce74ced388f274680b97cdee1a5164121564e7b607f128af214782bba287406d8c155e1e129b8336acf3d4cb650861b339eeab5a8cce212776b656460e60f96d22474e45861726cc895054faa80980c5e2ff764abdf339f4eb36271a04fde521f8f706c242f99e56e90dc4b5543ed7d8136b2d53441b577c85eb661aedf6a9ab38a17547e694722bd2858a4b78111f1d2499ce3e10af41b7c260dbed360c85f17865df93cef6081f72208cfb79153bb1ede00f71a5a06a9a554697a874309eacf3cb5d20887817d8e6e06748ccc4c2959b36b16ff7579b11a05788d69f1386b36063984fc1904da44d3742dfc0a62f9c6ff23c5ba28ccee8b20c9a81cd88e2c3436a650b4de7f53f83a867a8da69a23a968b2dda66d4af1b5a0d1c60048d3e2f5ebd7c7bf25ed9565c26d04a4ba28ed2fe1390988df3e0e52d0c0367309638faab2c68e3c4ae2f35eea608656c1ff5023cc30ca552cd1d84e195bf34b218d9389e43525d0f5c9957ac57f16bd2f78d7c4f5fd5f5a69f67c056f86b672915aaec16e47fb1c13ad8b3a1061b2580ac52940016c0fe1b148c1c78683e3bac6625ac0c675283e587f14aa9d2056f07cdccf5384905a2cca2d7ad848e58ad706bc16b4e6b7c5cb3f9da7d903eff51705071d18fa87cbb886154ca7fe02a88e135ba6fa6e7b401b10a4b5cd77bb007eb43b89cea84b9d7322e804a528e12f2117d0ef71235bfc38a3d03ad9755927406fdb099f2643ce1c383e5f814ab24d05c5bd934d5ad70734f7be7d1f48d1c17496807ba0ab263b2a824977ec8930415bd52d2c7adac216418701707ae039290de3938b0b2708bd04aa88bd66a7162740f1ae3ad0542bc0a0a3d7322468ed847962195fde2d1f678dd2cf9aa13fed0232d3e0f8c7e7bfe55733f58158bb6956fe9a059d32c6bb3d5e3023e1bea1772b689c2fb7b0ebf30adc31bb149bdafbceae93be7b04cecbcaa07ffad4cb2de12080b03d8c6c17e38155f33b4ab6d9ecce22fce581653f698fcfc94e66d4a98897e67c8f071240387c6a1590f74b2e4f48937648f6a7da804a6373e4c39d948faa9e242caa270206a358ba58cfac56b8809f9e7913cad7217eb147e9df67cc686dc93ebf69378279e9d5ea2ed36994b2a585c7b4f9b4048b263bca9096ad1b21f482a6cc64b05490ea5ff947d9f04d4a344929aef59626f9df447426c7f033ed714ea975deb8d935f35122aabf9b8b56da1e6d76626b0d1516929b8fcf1a10048dfa8aaad2360f7b7284daf9f40ed13478a039dab967b3a3a1afb528c18888d94c3b689776783682f7c5cdb30636bfbc492eedffe5eea835c3d747408aa4e333db2eb6240a2e7ab68397f7c332eab77a05af438da7ba337979e4ccb5d5d22d196611d77b3c0f756eed9dfc79e8267d2f5e4923cb4df695761e033005d30dee9381f7775b7436bc57776a1187ea40ac8fb197077a581b75bb80e4d6939cc64924adaf9acb594cc5b322d0340a34a3abed062a77193d064383220816a97a5c43312642cfd43b1b5349845caf34ea1143eabb989d07530c82664456402c3c791fda3499a66ea6ad5025dd05f0a903d365aef253495178956ea15c984f2475514902c5eeda9570e70f96c1947668e37acd88ff22acc097b776c6b7a55b20ac9742b4fb3123a39c84f0dfcb621f9a0a7875868e2bd92dffa1f881362d77d3b0cfe6244442c4a38d9a2fbe7118fd051b35dbe2b1fc43f13be83b60303e72d02e8b6188f0f4511107550eda37c4ba74c287b1e3ba4a21bbe713f8efcb75f8cbd5ddbfd623690129e335f4848092e5f99bae4d231e2dc856d204ae74f6d8c1e51f093f2683297eda702b00afb29cf5c9e87d3b80155d69a68dd7a7e57fe1829a2b5ce8c831ea56dc5cef126a734aa6d5f046f960a99a82cc6053b3955020a8ea13bc5cd6fb312ced957add42b477f99c509872168f34d5ecfcc649a4d31118b5627c9a03e756e1209396df08f68ab0fa9d5447582349dc41a3d0b298374514a99eb645884dfc224ce55dbd9f6fc10921f7f4775fd0f4be5188b5490040885a1bf7369c6aff613b51d9f270d5a2153a57bba3c1a2ae482951e4f49fed9aac51b8888427846b91840e703e658b3065cfce0e21a5a20743cfc62155ae80fc936a06eddb16305c87637345cd0a2b1ad6ede31b997d9b39b6bca1c7c03c07561e68aa7c1d53cf99c3190513eaf0a3cb7d4d982431243711c81bd17a5d394e4d4cefadc2576d3e55bc1214858ac682fcf8bec16937cd2ec27eb09a1f13d9f883ec43320f2cfce012e0e82c81bb6dd44413d50c91b712516f3045f0509accf30c4fa277969dc8aabba57c506c402ab0b0cb8ba488dd158470ff19225313c9b257f251e085bef578c03ca26b6b304bd05f779f39538a1336b866717a6cb3c8ea00bf5c9a5b1ff13ac752980bbd363f33b68b37cb26a948574e9c7be80095fb280139550af9c0f5b156988ba2643894101d84f5e6ff7dd355af3f87d2eef3511785485f0e95eec587fe5c1ac21e7721a154a8d7acaeabf3b656aebf0c135a937f4067e0f1f460022301a30de6f1ee6a20c4f123c25edb9e1f4bd688517425115b911030c20d6da5c8c6bca0982e7d5d4de03012a4f56808161cd9e5c7be670d026b04fc78d37b6f0b85d8c12bca780394f325a1c45a2d8b277ee19b1b89982f189cef0cd4f037e7a0680277021b26eb8c8ad4a41c6b2135bc63a2332195cce5e0d5768b2aaf0057b2ebf0f3ce702238fccecbebe7ce1c11b03e678892e3ad4578d1ea6cdf335f631da10d2c88356b4658be709f1d9ed0075d16b78d3421aa68c62baa531a2a25a5ef8c9b722f3162733ca282bed4c41384eeeeab90698564b739c17469cb1c2b61dd445f03e6bb1797d999fabddfee96a9a276f9bf6e6a152b240693c10f7c42b61e88e1c9d1ddf02dac64b7f87cd6e07492f5be544999d9ae74f3f44e14a5798adee6392d795d6d78030617a9053d37bdbe043b180d38868409c610043a7ff690f88fc1363678cc6ea369295e4a076f7c8476f00c2bc39e2f92e895578370efb795bc0e8696ce7fb432155a1b5618b4f83e9be16b77233fd02de936656fec64207101b0962edbcdd9ed2e7c750e71759b502be81926432a67d114e21e5cc270e7ead6bcdc6222813a619060cb6769fa470590519b52090fe0606555a2515a7b77e74b64b8bd9a51f7c5a4ff4bd54eecaf51952a4788e1055f753308af13cb3a614b48aff99f224fb19ef6baef802e73ec2f6e64896a0a7e79016aa19bfe2959ab4ebaa171159f893062df01eea402d72bc112a2eb13ade4cf7df7ba90c01f95e9f2cbab5e2caa1f3d5f1871b83b7a87825b810d0612e537762063db11eecc7ea6e8895f7ccaa54eb3c88124b3994e365ac75fc95ba4e8e23f94f9c3abb0a845945ecfdf4644d8d824c6d535db42daf35120d25b25823eba9ef15da888737897752601832680886c89e887924082ea2c86f7e004c5b63c437c0e9359293aee0916dd24f33e4a8b8d4f16a7bf38104b1c96c8b427b9b27eba1a67af755466728dd3406af383e7944dd466e9d696aa36c2af5d0c14a3cea8065ee61c973bf528938362e1c5f3e7198bd3e058d9f7dbd2c95ae94d68bd92ab14efb9203fff672952bd34cc1cc71d799fd2dc25aeb572f57e33bac08b4017b5b067a9ebcd7673bac3f7f7dd2adf1460e1bc1a001c65aa788129c27d1ca3a3401d7025aeba563a6061e0ca76b31cb1228feb102f641d301ee1178f38da5551304ab8a01b9e55b6b067ff3b6a1cfa9337487a1af0bad03fa95df5ef77a7fafa8ed4f6f88b85a57415d133d265af95a40ef0e1fda226f34eef5f1959217be0af6a320ad1605012656661e3acfec4c7de22b74718d6882016dbb801bda0f52aa64636e7c9556cf527339f07a19c5443c61d9235298cb02c93bbc6afe8835601333b5e6af6d47db23f104afe2e67dbfbda5a9ac1388d07a208e9ceca60391df98ee698ce72eacb4747bf6414b7f4909b5778565b5db7ea22de2edc705ce250885666433ef89110e6896cc4d86ec9a5c45ece9c9c9d02f7bbd6271273c54c3f80a4a509c3bb3a169076473c25b569fbf4949fa06c0ae74d1515ce64ff90543de8463da27a23ca7671d9eeb2f4200e66e2a66819b3a1f64e9e72b6093ff14bf3b939a493c6895054ec153eec621872cd2ab9d77570d1492ac6d9fa3b089636239d102aa17f26663e8abd44f7c938df8ac25c5a94f3e5ae2828aaa1f14f7ed405539ac301f0c509a121de8ddabbd55eaa4df3a8f805af2489a71c50f0705d06b44485911433bf9717dcfaef21d7c66fa6c2297a1184e2b41b4ba2744c428e4da0e43a6f929f812e773e78258e0aede1ff6aa15f754b908be5d1c77e922ea2fcbd87ea4323793abb4976958934cbf78d954bf538f71b4185ed0c75e731f9825907e990d1554db9d7f885037a5339a6b7074e55690b1b30d5d7b92db71c9f02b445711eb1a992afcf95ac4502a18a6e3baa90607470ab975a796db55df21d7625a11e283597e2cbd330b2bf5c6c16214184bb1754eeb5a6f94850e5610ff0858996f6e4eb6430a239e9c6438d5c97cbd3715a1544c59a0c3a035f8716bf651960d4a8a0ba3f6ac4f24f98c8ea84aac49298e30449aa7a61712676b098f78c7b45feb88cad60173958a401a72e47f3e8fc4a81e7b921a9fa6f20e1c00a5708aea6cecf4108a5c263607a2567b2e43bef818bac8210dc623950e9271f6b6ac7c77bd78f14f2bec9844a84e3f0632ffb654985ab9a65d4894901d9b36d494d9fb178808b4b504ccbb830a02eedabdbc1f064bdfa5304dab9551aac161583b5bf86946734f239486c53a70bd8d79875b8bf0440846146b930db15ec48ea537cb790d8cd08e1aebd4b38a63316e4dcd1b850f1f6e7eb205b307c0ac7b17bc4da94dcf6d345a190b460af659ba7c6a8900175b65e93d735ea3ad8fd0b03414d95746d7609d52f57e4e3908ed94c2ac0cd4b5507512dda4ae741a5e2e574cf8ca8d1663926b7b74c36855d06401f3d0416c646d24d9b91e11433093d588f068282f15cb165c2d2e77ffb434ac962dd5d90c93bb610f946f48d474d62289e1e7c1b96ee7035b571207691c31ad6ec84d2fbb728c73a3285faae93a1952197293c0aed4e01ffd0f457a5aa931c5075d033971b3a76c55b0c4d3c47821e3f9b17b1db9c9dfd716277e304b2a326a36d2dec156d63fc4a9980dd2314bfa41d0acafefc2a39ba4ba36c95e28148bc904f9ded327a6e8044f09c8a011f70021caa315eca0c67545f4d9730b290874fc63555c5fd47267ed0b74796c55ebbf8a17dea543d5e22964bd7de09fb9e0d34874f3099c4ed294f44e2c3dea8d4ea59cbb4ea6d82aa69fb59c3dba743cc19c7108ff7f709303b068fb8f3fe19deb42a87e7b20295686fc2090dc73617cd11c46955d921d89c8c85dc1f9dabe8914bc5725ee9164274263c693d92f2eff6de88c4c87f54dbfce6c8e4d46e9a718eebb5f7a8cf7a8a6b17dc00bac2201928d0e2950083686b93def8143907ba26ccd2a2e1bc4cbc28c5ac4a336022fb8dea4a34c06314bf6d947bb8f2c0a51ecdb640ff2810733498c92a6193b8470286e7b01087afcee2325bc5d358e2f55fd70d9309a4ea46b6331f8d62f2b4b65cf6f5652302362c8ae30a8dd4d4ca180f3645a340b55d43dfd7175c42ab9e530584022e2bec105d4b265e8b2e9430e24d582f8c4c6486a1e890e48d578761403243775defca93f76b11c2be0442c4da0a233bd758a93b40c91129aace0d36cdd24db650a3949b3cbc5e19e21ad8202bad308916a6178c5a142c90ce182f8bebbca5b781587585ed1dc293fef99f73863d40cddceb2ba66016b0ec43306f03dfee242a1761fe9480e9e15320e86395d30dc230f4cd8dfb9847dc5427184df41149dbe81511f59e666b4625d027ee6f2bd69fb86bd9b57966571c0a81805627facd2ee09c4423173942fd99b8e1462932fef956e43fd700a61f140197e02797bd6f9566cb8732027de7ebd8f3008326a139bc727a76ee1a8306b30e9fe738b145f75915c2429cf7e0c7e4306414836df98c1ddd4c95944e508eb9f895a67cb2ebc5f208041fa39485df8f4aba79f516b1d7a0ff467178300dd1cb585d60ce545731232848a682f5b0716721abf05b3c78f84addc437088f420b258c56def8fe72a725d58d4f2b6852c714d61a87a9b8a949421fb8cd43efa0e041afda48fd5edf6b48a7e92429257d6288e31749f59a89cd164c019db9a12a39def94a3d0649fa8c787df5e8be616eebbff0f675c874b18e1680fb9e6755fabda7135a8c1a22e25940acf0c54a644ed4ed3c02e94415fe8457a190d94aa69cbd036b723776217409cac9647f5f03f704455940d92cb90bd79ca767791901a009de54cb95ec261b583a4484017a9e837cddc66b1095d93e812b66faf975d2debacfaca6826cb6695c37e9d0b76b64d2a68acb67f85668b06adc39267a4df61098c93a0307b0546ee06cf45b230fdee7453345a36a19374340be316a6e36c088310f406dfa706f01d87fba174787dff4bf5535723f11b8539ae1bbd8015d507185c2ff835a4c6e9fab0c025ce7d64da09911caf715a67263d7b6cd4de8fa7095c912eff85355d9b6712a81a0dfb4963fd3c2012b8ff69987636de0c5812d33fc05b68991f4f1dd8f43a08d53eac70ad5f574ff6d431553bc3c8cdf426e10711e9a5ec661552464e71ec3e0499a200a1cc5b6f30166575b017f6416fbf0d8470bca4dbf784d852e599067e1662ea12ef8430aed7cace2b037d13cd297e03e50b11e4a89faf26458304173fee15c1f1b65040d82be4e612f089c5997631a0a1ab848004d4272c4e263bf9628825bc730985b49e5320052ea19eee957a9eb3f4f63b5ffbc7ce97da9acf727fed3fd6092b824f34cee87bdd09c35cfcdc24ddc37aab93fa30b0b564cabf3c6c0ea827a054aef285bd23e7686a8e4b7cb7584e3b08277ca49e4fccc5ee5a840c4409d7f136e58bfee1476e297739672be3ee9e82dba6822c37a1f8ed701660aea323113b9b6d6aeed62e4098c0b96ed91408953b2ed15ce5cde56645399d0ea2c420db3e476acab89d26e89904fa7e8e0dd461e4e861b91355f6fb15d870921249c9748ce59b093ca21bb05e1eef7edef492a08d0629874d6c9e1872f09c48e10f794e28d6e7cc97a4ad1d6158617a4884012fc79ad27a977fc070a473294ca28bdd1886c6d449ada76ccdcf2908c8ff93d2c349050e31337f1e59d75618120cfcfbe6aa881c128b57c8ac48461c02b067f3738f0b14c00a5a077828134ed8f05d67b6109f59169b68e7650ffde5fe1a9d395bfbaf3a551f0af21151b0088b05470a4ff601abd7bcc5fcd09e9bcd32448d7a799ff5145c3a6636599d55129ddc527df1a9a9937d0d64327c0fab902d94f78506cde60425833e554c62bbf68daca0dbbe41d710a49139c4ef57c1761b89a820e6d0c66e77cf559c7f59654f15b2fd782193716334091dc8f2755d4244f2015ad86e502cdca701654e9d6cb4c081f711d887d5c9129670b318bcb719cfeddff46d92c99eca5895e8aeddd269cfe75e5f102531e5eaa162d1726bfe0697801e97d054af485c39cc16ad9fa54ca13ba8a747aa5eabeb6d1f607d2f348c4b9e2de96e6f3395749ee7bfa277de28c8d23eb05847b7cc129e0e632f79cf8c51db1499698a38e69e03faba52d25ac7d87157cb7e8fa7a5ce12a814d789c250dfea55851a5f270b2065f05fce9094d1344c8a645342f5732edad79a40b31cff3dd6c5a0b77464802427f95b5ef35dbad401788845a1b15081bd79520a9ac366ac9973f3cdf4c0c440219c2fd0460dee19537ed0b3a1f343a695e6f25e4d31332b83ab2843839a7cca2480c148cd7a1083d9712e409d054e21f2025428b6e387935267c8ed8fb4ddf727b100e7624aefea550159f0d3479faf0f73ca9238f9fc5b80ebd2a402be790954a25b873daf97f47f800003be5ace4faf4c6c45f44a14ffda228b62726a3fe6949cdacd62060755525a3260124f9a411089bbb592be77350902c3369dd030cf186a090e7ec5eee9193c5771983c039e0294a69bc722d2458f035664e69ba759680661af72fe5ef0350a3460a45bea262987d302211556e15708e81d8b57ad10b4a1762055f3c9b23b8c3d73dbcca2e9b309b99bf9a671d18e95b59aad06fdffef63f46c1b6de2088dff0d05ab8030a204740b7b13a6e51b1103e8f0a31b86a92a08304cc9046d57fa1cd9ff74332a5c926ed4c1b7ee00af31e1b72eae16dc9bf594998021b9b0417c81833c384914209bb841d68110aee4cff0c44d4a84653af9e2f86421efef7fbde8a4c925455083340346ed2e03da2143c797ebf11520ea2768152d93841f0dd02471825daac8bb65eb6fcae213bd45a0f67327d16365a54d475de0c470ae52efa425c02b2514915e2143c44aad791165d366b61598026843cdd65ec17c5c2ac8f67a76f1a6b10eb6ab9a51df783dd4340dfc514dd55ff97b0407bd0a1671d685e8dd7e9cdef9c4f1f8242fdfe1de253a8c371a4c040a44a9683183c9c88a667780ebd9612ba651dcdf7c1ffccb37e28f9e12700ddd9fa4610e9745b8ef705fd79f9d382871bd17fd57a50670806333e07a28f933e2c7ba88b1d48bf47df07eee7beb75739ea9167c465e42bb2c18e035b63723ae97d4f0263894737458f5b2d3c08843eec62443d5f6a8d70f1962b158dd16d28ddd839fbfad0bf9b04e8f2a09bf3b4c53c2be42bf661600ab2fc5c4e6b468406de2584176bebb08e909ba3ff9b30db3e48022405ebe34c7ea57ad01e2f6b908213599ce1f4f6adbb397401ec5c6074e4ab97e63557eea87bfb47b0bc35c23714ef81fb6f4dc577c24ef93ac39e3add06b35c14571737ef79d1f1e58b4ac1cf3b8143941636c8d5ca07fec2ffdc5d7a4e08bcabd83067b795f30e1572e6b3b2d27feef06e72695f9ea254c777c820f81e5102f11bb7a87f1bb81e12d1263378c795b10c739e9e16b8994afe3d9e3c7bc3fac8fb109b9ada4c37c7df08f689472acc50992f1ecacbb44a170a9b22e51b42d215787cd20a923f77370f1bc586981a8a0ff7b9db73caa4d1f07a6c30d58442f2ab176e166093cfe692601ee447c65e36fe5be9c532a763680c2109ee055c31f36d23d9d3c493a0b7ee6472e1473eda6ae62c08ab4c05fc9e9d661767c3faff15891d2990801187a69d45a75849cd3935988f796d665054c22d98d78c8ad756845daa1049764e1991ccb9dc16e18e6d2a47197480c0d5a17d12a7c3223e8e1047cc40760679e68fbfc0a569950f936cc6b0fc8f5c4c28ffa6c85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
