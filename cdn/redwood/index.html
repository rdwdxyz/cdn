<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57a6ecc3a8755eebf13427d419135924342cfaf75c4c5c4dee142638922bd2dc520dd3d3332c5d9be38c472102de2b95e21eb741db196064b0472b3b9c02f3c8d2c8ab8a7ce37b584fb549af0293968078ca00e07895cdb1cb11694628063306fc98a512e38319e507273f5c97bfba47c3c7aa2d830309d4e02d572064f00b03701bccb435e1ed9520dd0755c1b1e2d6d0b07ffc642461a079558259506182b07cec2905099df4b156a440b883e75d3de2e2d284f7362fa92df0866ade6fdb4dc182860d0235df255f13a04361d5379aec95288938b0102b3d5cc471cb0c4b99db77e3441cb4ec280ab160877d6ceabdc3b054e09c30e58b5d5e20610867ac3aacd08ded257d97a8145c82e41e7bc4197fd1f47a65509573dba50072b887ef96022c9bf6af85c4e2b7fcf811ff2d70d13f96adcd10da62d01fdcc469244560d48a48b1c761796de8751f69aea13f9783fbb43025eac11e3e00614d5a00123c90344823e8b18f5e7cf4a4cf9b5cb15c1c275ed377ba44189a1437d91422c795615d28892c73495f4ed3a126644d8bb733dd3790e774b3ebe2d1f0c351a42318a8abd0cff57bee0e51b7a8a175309cabed62b21e808cb9aceec9a62130e427de8bb99e9f0e4e968810a617ee47f4f051943ea4b58a7cc08a92b6b2e32287366ab7bd194e1df2206f767b2b39dea4f7b3c2b515d78c581f8f03bde98f97667289bad0885f68d972eff1ef01943d4a660f1d2f2a66f45008f5e0f9aee9be044617cff357a7ea3c0b569cf8b59c6b372044b9bacfc4ba9d9b57459488939e039a00ed1dc69c79fcfdb2518b438de5233b81232717827a305fbcab739d6ff42ce98d67a3b112df32defb3dfb40911782cf7fc1d98da1361b9e0edb57024dbe2cf36ce2a02facd59dbbdb5b92048a2b6f15cb641a1ae0ce1912790e53605d48c162b8401318f685e4347223f10feefd3ca80320269863830ade168c77a7717e245eb1c20e23943c7638876548fa519e556cfb6501c9d0d8667bf1c450da134f8bb3de6b1af525a81cf4f722a1109fd33f0793edd65a711aa53fc4c69b03800400fa7273c3e7bb5bb7f6a4faeae59ddc95f5fd62b9d68c3be8dad8fe068d6992b9956d4b7d85fd6ee680c2bd94307d8216f3ebbab4478589d65de7b7ceb14eb5c9d0a28251ee2a84085fb7454390c2ba803ed14611e017ad6603c1cb6c042f2b3d978a801e33accb69d1d1498f7f1ad6594cefb881fa27ffdea63523e903ebeb44ecd38f731edd2e6e182ef024bee8cdd0ad426dd2d6009f96e5345f160a6be6571b807ab861fad436e4084ab82657e9e9d6fd43dd3886704ccd81d2e8b4f0ae026b61a66a16283c803514d985c6929bc13b00a9cb5a4b57b4c660eb21fb32b931eed6524e864c65e4bbf8e1a5c1c4e2f8caf7e74a8d4849b2023c78f8474adadd239ff8c0dd1cabfb32714c33d0428b1afe7ec9b59b3aab1e0b2fbc3332c7e1d4a18a5f306989292b4ed6afa7173586d6d9a2aebea929469a663251e890f546112f25223d28d787f677ebb1a1731c77d125278414adb85d7f2fe406944a2b747256766ce8348b3d4e8bf9401b653ac3d485ca0f678aa02f4364e67c3044ca6c1cfaa0cd4977755db6f47e3c0df66ba086a02de16cca6b1e5857558ed811a43d5a66ff7d9e12fbca9d8e8117d65fb97d5290b59607445aacea23011bf701dbb175a66baa4cdfd74f744ac0b051f5f0eeff6ac1dc815554c3b940599f194ad20d89c9b5c597f692a37eec82d17ada82f52abe9bcb26b49ce9db79f8a01adcaabee06f7665f4a56807d32bead0ef53bc0cd7a1020ed2fcebce649b319d57248c515b9c4c23363670b376b4f00045e5018305ad4a9b2db536f46bcc788011507684ad18ad6882f586b586ea665a1c365fa96ac32e155865de3a4c47451a60b8cf3f8ebc445683ff99d8cb88644069c3131aeb877a35a779292ed0d32980d8de7d30654e60de07e8895fc022922a587c1de77859a2f80f930089dcdd3396f383acf42c0396d9cd47ff64c50c77883725745eb3dbbf34f411c523f24579586c82632d4357d8d6be7d8f283d0498588b1e2a1564d2f1b1ccc50005a5fd13f3485746e40746683b125eddf9658599091e8548cdde5cccb0f4bef7f7ee9ca4a39a2c830be9392f1ce91a504fdcf64f11aef258ef872a9be87f36b60c6dbac8e9d1c6b34ebad0827fa8a56933bebb733b6c183d145acee9251faefe8baffecf544d6b2a2db65f0e121e575ccd488d0fc572018ad6e36cf37610c6b20ba1bd984a6b3f48709e01ee758465a925c2a7d6b90adb93a0436aa104fb9636d3305dcc2e5c69c6ca58edb39cef93e4386f157caed6619f00d474fceed1b854368fbe21430de9f705df3fa6c48e76d0d4d86d4fb29779accab57b6819cdbc29eb66bf31b365daa8df886828d23c8e53b08066be65a49b9e636c55800c264e131261a9e41afe603558f18d358a7a79886b5ac7acbb12c45c72412133903da72fdd4fe5f190e77be0a361f0e006a3dc91b5f78b6f601491cd5b9e48e450e781499fe3a4350f4d0116dc4c43a9e365ce1825a34ea1e773219644082c59f245409b69dd0629e390a220eb8a9219e7de4b94f133975b69dbf9c26648bfc051a9097d700fd9c0c95c59781d9e15da5a2ab35be665d749b2d7b1551bec8f37b9b2d67ec2e33b06e3a1b85497cfd90beaea852fbf2fde6091ce196d1059a036eba9bbc9db1452af284dc9d30036a9d6d8c0a12188821a312439ffa7a3d4e71c76e7560ae2c09e4434cbb473e3a0d2c9024015e147b199d0072eec11346497ecc3530501fc39213560dd84976a177a14be1a537ffd8690c7c4958b58833d067ea75a56ed25178f4b4d9c1620c7f584d4f256afabe9d42c6e7d260ecdcf57f01701aa7a882b896b82d6b6b1bc1eb1d7c794ac496dd88e81e9baea9d202cb99b6894753ca47a0ba1f607cce77c0a4d5d3cbfb43790ef0bc5c04c4a21bf3978b2b0267fa34aafe5bc6626640c11212b93a66740bced4b9589687f4854d2b540af409c4baa52ff4f8dbb37ff16472aad7ab5d9cd158413121dede54cc28b39ec8554d26c059b0ece033e4102f5c36809962c89956f79bb55fad19573bfa5246eff92ebe003dd13af4d35e97de391b2cb03df23581d91f751c30b8f3cd9fd1b15f2a5848d351119420d4f7567081a7c1b0284fa3a9420178d924fb1a2fe40e22af27845c454005b5bd0f907fdbe7491b652bd8847eb0d06b5f3e2dc739bebcf63b2567231984062a3f2d7dadc8005484b249987a20a3e3b600706e0e598d93bbb564ba98dc9341fe3c101722e67afd910db4746803d613781846726d659288e6123180fbffc81431d7db5fa9ff538f4a6487e7de03a10405cb6dfa08fde171d114f04dd66d80528c05581330014ed9ca1aadb17f06ac8ff49ca73338c9176d6dbdfe6437c843121ad708f452dc1f5eb96e26f232764041996ec25592d207ffb8eab99509cfba1fd1c8dacd5310c774ef1892d5f25374c9c49c4c4a35c175af6de916bffc3823769a6821f8288f03826acde9184fa155286c8f63afe4b09cef3aeb3d4232050ae175c42bde3d1b10eadc66e25a2b3d757405e0bfb3de02ccd40ae82cf42e9deab6bcd0c9f84acd64dce3d907f80e9e05ae9dc4680539f2327ba7888479a73c79a0cc1812069f3aa6f980f61fdc74efb54aed0e0ce76b58c33bd50b2786af214764990355516330d2c8b547f5dbc0fea56abdaebf9eb52007a14fc032049f0a1841fc712cf9404b69ce6d2f0c3987e5dc3417497247b182a0a93c1f7eb891273b31b61f72d6529b062e029b352bdafb421609c12099369a0d38995d02342df920c6f89c682aaa7bbe487269101811d075dd938abdb7dc5cff27b3afd7b2ba71adba366ad8890c2415a65c767e52d0383c43629b7a24c4c2c677ab7d31cf07498ea257d7c43a88d40aa16f4aa4a3af198e0d193796b44f49d9cbff8940bf56f337423a623d11df80f8a272701129709e5457502a28f0a053fe1573796f68a88869f8ef5bc8c72ab34e5321a27d565d4aaf3b272c7f2743572e238df22a78f6ad68f774b443b30fb587343d12b4745cb1579b1f3329995805c592f48d84e91d1ee7162aa5c7592a1c166ea484ab32b0609c9b3d75fe581c28ad1e1600b5b8b635ac4bb842dc8c5ceef7ad1a5c54087f52aba4728956c3fd1eb8f2c2f8e971ef8c3036c6181c96c35cad59bbea511c723a278eb33b281925c3234eb6a474819b034a5241afd3f13bbc01566b1541becfefe08b1039c3f8ef95d6b73588df0dc17b2f1f8abd0b1cdc63d2f640a8c794521f272c3b938e15c225a96c78f267258ce49f67137162cd4a997f3c1574b65525d6c3dbb3cf9e7ccc27a8cff12d7b420883c61dc632bb27fa110694084c2701ad523ed96d6928f10b57a1141d82126d51475eb969fd4a21969085b1956dde5240aebd15bbb0fb438b753734d32d4e56243f14fd2bad32c8abe8597f086ae78fe2a240a88cc42b7efca5dec9d4da87d4e47f2c856d0ad763743479764d7cc9d1d8eb855158c401aa6ea88f25301e7df5180c9dadbb54ca04488e56ac830f14208b020891fba370d1a3aad69ecbed7930198eac31746f07478827a89459df0898518caac491ec78054cea3c92968fb947e839dbb40118ccda8f608faf9b32cc6055714948ccb4cfd1ca2fed955239afc92f15d87e05676755140c459a7fc6cf228288313715d802aad987c3785de23ca3496490cb4f861ded81f91b7b86ce120ba0c80ab05b5fa9a83cc619560fec593512386776135aed24d1e6e526a2911a46d3fe91eb58b07f0775d5d228fd065f0ecd52b6135ce390df5cc6ce8573fc365b26ada5ab38c18ca9b9a9d49b8b2223705541345d3247929c9c0302535186fd0d2117b3541ed4e78d8e022f398130e86039d59da8154f49228ce64f7af0a9753da8fc5a0aba3b83fb30917f3aa2fe0daa43187fd9e8ae3253e33cdb8f2568b632546fec6883c45e6b823a4cf28852497741f7a0cb3bad896fd43bca4b220b61fb580f84a1a1db311b6b8f4d6986424e28e8309fdb51a71841d8e56e77d0e34bfa3d2591e1360456c388c03350c912ac4a2937797583cd60d1023578bfbcb5b902673a91942f9e78c8a9c5183ccf17f3a32b7b568bd1aff0c96f04b1dbfb79db6be02a7f6be33afc193924ee975099454e0b703055b9fdd6a98c955964cd7bd8ddf3c01a098464f85a906f64014c872dd59d3393237fba13aab5f27b3f140fade11518774f3b2285f7115eed507ee23030dba29a1fbdcc90205e0c2cc518bc838f9f92b5119be909865a6c25ccfcbf7dae19b8d6ccde598baa27bcb7690a7f58819d07b296266a183fe6b6cd0e0ed853b3d8cfe4b1aaead17dd6368b7df772eda12a825d7d203c4c9ef12b4f6e00087d3d31fce2bfe0ace737666e2a3d963f44c090ae7521303166a4b0fd27878e79878438fef58f91f7017474a6b1409424aa15d8a74a3cc3184ad0fd96b663f02d2907f2d7374c27555bbf1d1f5a8e0c4ea521c8364ce8e59ed0b71b919118ddd71dc79cc423231e4028cc996117f560a9c260708762cac53725e8134c33d27f93c3603dd4b87b9a7b4aac9c9a9f0f16f0a8e12d0b473386e42591b5c15051521317547e038b88a99fc7b2668b19f3ea6606b1c1dd5146c6d8f7e845c511a78fe8a607fafb63dc1efb5e69722c0abf1f6612e4f61f051f7021c3e97d2ffedb0c41d5eecfe7e7e8e2869e84341f4baac6ff051e7b76904a509699ed426cfdbc84ffbdbc7740581f1ba130dac02b9084d78295c90f21b506e6ad0fc46a049a61509074f863262dae19a2066978f439adf8d05df6995d2a223a16c3267bccc78e7bd44e82e419dc213045d2ac1a151c108664d5c8f2650c217d103313fad514c3ce74734ba15336c047b50b7e99aa2e6735fd0d10223702f3eef7cf50d35eaafa59f4fa3e224b13904b994f473b7cda20b663ec5574b5deb9cede1f92b6320e1ba5efe277f6fec6431321f2915aae8ed6f6d7be4a60e8185a9d097f6a92fa5b79d1a7feb127c64971eaa1b8beb4579be2af3951bcc1894f8c0df4ddd5f45757525cc35c88fe085f8258752992667e7566524b908557384b55fdf62fceec01fd5dcaf40a794c4461d3ebfe0113d36dd42c4ba5225d7f36fe2e58056b6af324a2f0f4aa580278fcae8c5dff3e4866be6c67cfdbc79f24e8203751fbcf3ae940afd3ea050bd8998e2ca8a13ca1436c21827fc1617ddb90cffbfb002c4f1a345c7101233efbf6c54a9531dad7db759b4e185f3a729326fcc21fd582145a7ca0428a3036dd3925249ae258b42ac5b0cee9c3e08f30204ab404956a2700475b64430d6f6b8b3dfbf500da8f1a6c0103373fd884c9d8a5652ac542d6ce618a9b6ce84a1564ac4edcd11640b1424c9ae4e1f5654ffe00c20ee694ebbded4297694875fe90d0f3d634cad20663e1d60b11d05fe5221b2713ff04d4bacbb468d33a324121b54f61b6483ab8f9b13912140603a4d24b816f4e855ea9898f76aee51c3714c791a6f5422512d0d7f93afbe516ae8f0b32dbbc9d26a87b5fdddf70f79c692c699218d7d311e852a2f6a70e7de7bd6bced8c6b398dbb1f12dd2f4b35d836a28cef0aa1c479d2ac3509c459f6ee6acc731403f3190f3c4f11199aa218b664ae2f03252ae65853022badec0d94403c775c48395db81e98c52e08df563c6f35406961ec4ed6b1b3c927444107ab637dd3b8422c3e8c1ed55377c241839741daf6dac651760d950f36271988e70f488785b79d383d462a8d8ab8c06f0a0b1ee8e97c161e4c7403a707d93fa380dbf8258b89b67975a013a7093d2e34685a874c21cddea44ddddd4225eb948aa703eb41f7b7065b6dca8da78bd4282e1fa2ce5477d526f4712ddb5ffb2b835353bf45b0bc56d3a4dfe5e094d05d322b2e3342d96d0cb085157cb084d70d14b18e06f3e2dc83f013faeeeb6a348cc85b4bb745e8c9daf260183a3c637f6bdd6578809fbbd07986721b8f2c59e9c9ac5ead9b8748a175f389e2b908657bc14ca5ee03a797f265cd26da311b11683bbdabe200443c26ddcc20c9a8a1660d5e6d640ace5f7fd2a0d9b433d859c9ac1f53722829d3e62f1794f31c69c5891cb8901b913fdf38ca28e0effcb865d5e9ba99ba5f50b4276d64073145d661283c519a1e3a8d8a09ec0d746fa906d16ca07f561d390076a0f0eb23eda36b880c361efe818dcb46faeb6c2b38c7d177bba647444e565184b326fd0d3c297fd8834a69692388c3b3100114032991fecb1f2eef64a59fee211d8948d807d3f376f36f47de2d09e23f44a1c8d904d13aed8844762d99ab6d683ca576f8aa7d2488b5765e75da7f1b60e947cae1540e3d0928dca3d5a9d850de0c832b65e3fb4d2d918a475b9fc6a3fb785dbd1b90f8d178c63b6bd0bbf2c3dd1e09463145d6d7b692fc74cce8e424b4987d74a6f1a8d41e15015ac67e008e401af68697a22bdbc50c68fdd32e55a2125d53db5cd6b155b17b54a5aca182db760e214242f7c5f11f12e6cfd8d6e79ba0a85ad1eac12283bfc1ff94f4da9b81f78ae1a33a9fad86697602c87fe0cf079226361c67977e24d35f38f634cc7190bb030312a081c8f187284406ba6ba08b42ce105420da8a00ad2b950561329f0cc960c48bc8c9777a6b674a20886fa702fb4ee729f42ad05c8613693e4251926f898e35875bfa7d6aae754916d1bf8510aa2e8575e80098d9606ba97f935b31114bd3a76fa0b479ba4bb878f8c26f07d377af78364592d8501c340ddd93d95223ccf22e794013d6ae8fecac030b7ccd4e0acc243bb4457573e975c473455f25cca79e2438c6efeb133030132430dd3cc496fc6ed3a80df80176915b17c438a6334775786681d0820a44d64517b68527cfd54e3de40929b733f5bd7180ec32b90b3cbb1725fde54e4bdc99935842eda3bb44abfb9fd671e2d3f3880abf3139acc5b83eb0676780a038ff15cfd556285e4b4dc7d042867d3a29e2a22a2a1ea224f9ddcbfcca91d58e941750e9e4c7d5753ac0608d85e8096a4b034f978b251e9632bb1e8f428686abbabaed9237d9cf03bd57ee7c0c80bc2e03676cac6a0d0652a98b84dd2cd2b01c2b358b62cc79a766f6805d38b9f2bf912b4a35530234158917105c628eca9e1eed0cb860133ebbd750c305d88de7157e625ce767b95828a40c852262b75b1933886aaceb58f55702c5313991f675cf61f7dcdf6ad7daa4e326ecc985a81d15a7fb6dad26e48030e74512b5c22b40835d56a8d315c38b42b4af0c7d66dda68462705f9bb369a5a65de46e58d46a8fdbc2acde5df0f9e811b006ea94649b710c50f209c3fe995201518e7610730396b3dec1eef6ae0deb131d915820a4ffe3d96264e6cb1f8f0ffe3477dde74e91b338ec04c6834d397b5e8fdba0f9c8adb5bdf040e52dba4afa408964dcd5c966307ce84e7447debd5ea580673e82e4d97164666472746115dffad34607df9b32b041aa7938c8aa7d77c31743bc7eed2bb118a639b4d860570221fb68f071a057602e55631fecfcdc66504b233ee59358e21fb479da6471915df7fb1fd8f8869d5d265de251113c0b9a59e1ae455c17aa974879a80586324a7197223fca115a7b9e3b136b5861173ec485e11d63fac18609914d5b796187611490e67180d52f72cdc00bbdc726e1f9eb1fccbaa5c046d8ec44a486126e5fd25f8aa48a8d551f7f9ae99f4d1954f1fdcc44d21b2d5210f0b32e31356c86c4fcc713b69d23c63eb21d9b28ceb192a096abcd7fb4729bf0a800b82890731ac66a113fa3ff500b9b539a455890dbcb3da0d90b000df6cd0f1a51abdf4e6a222bb18a3ba7bdd13ff059119e3cb7ae8acc021c0f2ace22ad5c6ed7131afc9a778e636884f2135086905278cd62e558f9157c3f4fb6fee3abcf5c65e34588c4d6a7c1c62aa6b5fdbf6a460f4608074822a283efbf043f2679470c7286ecfd86326bfde2c12146517f1d1985f056f20c0cdb1f1fad52ecc24be0edbbfe87fcd6ef08a47302e94517d9d554178a3ce5a2608c071bd9dd8ac772ed435dcf4395b4304121c2480323d8986ca01c286675c9b0fcd15fc2c57a74b0b05ed1ba68eb0015d93f472b06f08adff5c7383f520632509d74fdfc51e71c2dd5b1c62cdb470deb0061e1f6e87c2a3815fa6677247c9f1f2b135a9b4e29a9855389f24e58c033290a16346a4cf651639fe3cc73aa24cc4c9836a30abbb8465664b2f7937e53cee0098ad165d02eba7dbf9bc1de6a14c57a15b8eafbc28852df5ddd187ae8f60cb7634de7f61d3f718377411d524ef610fbf54e1a8815c79dffb6cc3269bb3d17ec5e48a02c4414a6014950d8f21a9b6f711dcf84baab124298d47c14552a676907fb45ece4a460fbf90d69960970e2a054eb97d1efcda51724715157c6333de50663315fdb3799a5293350f7bf432d3e6398ef9bb47ffffe75882679345f3619230be574ead156a99776d6a4c3eed64a9934b87e3b2c162c764a997c1485cf7a00c9f2bc20d8ef9ce25a10b041c5190404573ac3bafadd7b5328e857c02ba354faf472be44e0a2a6474437584b69a384866db6204d026958ad1b5c610d138a4981c0dcf41ab3d3c093568e8727116e27159b7ffc6d40490d13b3ebe310c5351b8590db1d2c9addc2b02e844276dd45ed4e176f86cb175c850a8f196715225fd0147860feb9cd99be027f4bf3ba03194ea106764e28aa98981d617dabe9c2bb7eeb737785664002e9d4481d947ba8e7f4d073f957de8f8f52a6d226555fa9cc96bf1822371be321249fbe8e17a64baeab4ee1efa9444594d2a784c72c4cc0af48001aa95a97fa8b218921f3df44f44e10caae7fbc69afd00e0ccccc6198bfd9b94132ef91f7c5ca52856bc756829b156cdaac998f1704c2b0483ea09290ac7307002e2f76f504ad62ab272b42501da84bf0ea301e2fd56e650696c4afab4f01e7ab1253605d30f43247cacac5e001321d2ebd5710e951abfe46f3b2a5b7fecef18e3441250e630d466e667f4fad7fd98a23f4dbfda0f9c6823dd3de361310392566eda5920a49f8c761963526f1331dcc7eaff46e191fb597ba79a86dba78c0e7ebc3f3fab0200c38952c9b7825815ea7389fa769e4e034b902b6a6c9f751014a0de28c610742772f8ad194cc8b6e49b5d1ce924396b31914f574d2e24060b9a130c1eadccbb54f5aa3db00f059d78ee2f4e6a546ad63097406e5293287b2aeacee9cfa2ea8fe9c8fd7c6b328d81dffef5efa68d193e75d2c70141b92dc7655ae7ce98eb11fb5e5f8cca0218e8548e2f6082f096bb636d3e6e9023f5baa7f027b51d256dda55f5c036b2c085f9c7abf6e60516b195b2c7f5b3c8417e69ab1f00e2cdab23b66e8c817299500dfddf86fc52b3d5ec9aac874cbfc7968f05503ecc7cc683e2bbf8ba5055daf59bdeee115a0e15ac7821cf64a979972eb260ad0605dc85ac658f427c676ed36b042736da642f27a66d8e5652dfff7ee12192e304eec2842e03f83378207abd33ae0e49fd3b7aa6cc502364eedad18066e68a9ed7dd6e1dd20ff1be3b5c2185c9c3dd390d5347ab7b7c10c4ca9bfd2cef12e83fc4d261cb4b26e7a5cdfc57e2b4670fcdd5ef1cfd942760d866e1c6f8e16cba8720ef16979680c88e438ade9bac51f2ea8fe7aa8dc0fbba7980d493c2e6eee17f5d7de1d1846f08bd8181c6a13aa81720cad4ab810b0ff363ee2a26fdb8b22a11147cecb370b6b23721d97e97616d3a1f34dab90ad7151b80394b3b2fc31b2592e7ccb86797692b07740d407e3d54679c7ddc79f4461896af241dd550c64841796457b1654fe9cd9347e4d5f02f5da6faff081e61378fc5b3848721bf21b655374950b26416ccbb45d5f78076137de01bed5c3b51bcd2d23aafa358f3334a33b8a0aa788ebbeb0a9fd21749e9629e86a1b5dcc54868ed5d1e78cf9697adefa5ceda2d3eb8cc3de3e9cee5eb7a71f8aecd1a9cb84ee35982120e0931d9e8cb82bf5b9a6bd9bb7903483cb8885eaba637655cb6796abfa43625cb3d6d51a3228a96638fa556a1cf9c16fddfecf56e601d3e8705cd7e399ce98cf192e7468f5516f2719f71f2f2159e1d2e8ab86b27270684551bbb5eaad141a40ba03189b28a84cd93ec4903e7ebecee4c6b5a2bed68da15bb5ddbda57300b8c7f9e364f45b2c36ff562f9018d6e69fdb2aa85ad4234242c6f2e7c561ad1af10f8a66f80280139f60a0ea05c8a3b3370f1be8f9656417efb14e17bf30e5b6c93c50de5388958287833447ec4157ca490a63741c170fd8275bbb645212b6436043b645d227833fe4e5252ca197999930baf2c578ff4e7f78d14fd0d350dc5d358e5c922257000e53aeff6dfb707d292dcaf959c02a823c205024293e049696946ee532238629b13f96b88c40ac85df178d3d29810a1cfa50e1ca55ec4472c4d1d246eb60d89712b324ad0449a3b009236ec4e9f223e267fe64e5294d6f782920141bbf27280ea393c98ca0aca3830b626dfb5239170d9d4027a62d1bd0a041b213b395d02978b95546326c54c4f0a12b9fd430226319d7aca8af78149730470f8dbbe2eb8fe81cc8af35be3d5f3da155f7a7857745879e55e6fa2a11172cc4fe3f92e9c201e81688f8b56f4195bd2a0ba71bfbc3cf09e72dbffb285642fba1ab1eb629a46d321a9ded1ebe2d72534d3dcdda53c8a30fa392809adf9926c3ea362d5919daa167b8e97f0c013b40251b18b0be9634066d9e39c64d8acceba59835cb9ea5026cd173d7b06698abc930f984340fab90c4db6c26b24a30158b5321ef960c12f411ec9c40320a6deba46d8acf771590cda7e6433bd6335a4daff053199825a6cb65d424f5661390d46e84a822c2e30cb742376aa16a3e86124c118424fd157a0e915404fcd7aaac4cf5842300960b3f0fcfad277f47d880f7ba2b4d732a86b8fc9fc7d9ad1c894c6ee75a5a2634de124dcd1b55fdb4a7faccab0e7c455382089a4baa49ab6d84429e31761d2ac79bcb6ec8785b2dbb32e4ac55d56088efbc61c593be6652e0373479635d07fc80e05c5254a46c3298aa51180e04c91825e0140b9f8b48a220b74a05120029024c05f767ef857bce9764373c7bfa45c9b712e219a962fe7d32deabce3c7b3299ae6a34abaa235ce86ab97122fdea3450ba1b63daf024f17c17f1e04488c432b459c37a0bf5b20b92309dfcf485aef7991f27c54a81a459002cc34f6abf65cd9b88e97dd21da842e7d2127941ad4967aba014517e19791969b33bf7e2ee9244bd89202463faa6e9548fc0381d05b885f90465a7498ab7fcaf198917d7a1f9420301d400a7c178bc36ee646bb2cf87008fa90dde361e8bf0864e4fb4e5765b53da89c0749fe2c29dd4b11a3fef97a184f00d538b12689970beea8a612efa56d1c7233a0dc45f0391161a8fc554052db8ab92d90587fa6773b656f4a4883d1f9330dc75024088764065c51f8ea42215e83b5bc6db649bbf18367e3d69007a9e7c417b50d24b9f37a9cf197bee9e09ada7eb2b3cae76e4f99b75e1fadad4ea9e7c18688173dbd7e75ee040e8f96da621078a98be75b64317b3b4ab20b60e7a93161b05b4000cf33fdff27ed8637bf2e251bb358e212c27b25aea066dfda7fd4bd169f9b12f9a42484838cdc051f6d10813ac2ba02977913a35de53d61d2052f24894ae8aaa1f9f05c4bc5fcc7b6d059e7198ffe3eeda09449be6e99184863dcf19d5fc9e4a166140c55e2f679935938ff72b395e5f426567646ea57efbb5bb05f939ac18e5678484830a93321dff694932dcbb15b7f93f89be920125da875f834980a479640e41a3306701fddccf2fbb141fcb19d8bc54b56edb9b059e409ae63b2ce38de51ae6e8f026d7bcff42a468422c43c5b29a91c80ab388529eaa8032c5aa366a354d774bd8615f290c76576542d15302a5f25b89d89301c821d1a0dd0a397e9282f86f5a41a3ad2f64d5b04ed1fd5ce52bf9b2371725720905655ecc45932c97258960caadaa773d38c47854545bc5721f81f3fc686bd4e67bc3c73a03685bd4f26392f4051a1a4e6eca97a23e49c23e756e00cf839a62ca8a735bd9f1ecc2a9d5393effa44740767fed374d542d55eb141fef58212248d9eb4b4a61b612e34518d158c5c087533233d0b0ee2afdd71ea904d516be608f907c8c204c59d836e0aed4c68f3a98098895b555524ef67674153bd3adf783bec54a7cb2f13284b1ac3dae12090d172870616fa22ee3dee73aae0f530da3c94a727284d1cc0a507cd470e6165e8afc22d50e875d4672cf680eea8fa004fb7a7e0b991f5b53bde13f213a3785e1714ea80a95f4cf246ed61f52ff46848a45723bdd1f4bfb71e380297d89090142936b4a82b2a69c869bcb026a53f576144e472ec0997202f209a56a64b32ff250716f66ed9671fc2a2475fc86c98faecd35fa55d9bba05c0ab9a91b252848d9bfde1b105b43540cf2fccf93e9cf56b63f3c2c40b9ed5c65a444ebbf4587ccf75f7cf52148ee200915293a675db7c4df829079f67b25692255e56f673cd2936ac630566ba45bbe1f0439a0b0e3329b54df15c8022eef10eeaf8e111614f67e5fdc0c90e63eed0d902a5ecff91142f10528518030afe64bdcfd84420778729f0c4129ed46ce1be214d18c28576f108b40d9f34527ae2154bf2462866dad3786e3cd73d705c33a08b5089afb10fee4ff1a3bfd8c3a7fe98421ccdda8b83ef2c6d49d44af35cc33f96e1cf9078961b87f6fceabc6807d92b584eb49c3146895f5d9adf25e8f3f0fdc835c61235dac586a256520ed5a53deb5456d1180a74b56db4d7a4a3d5e9b1b283141433508520cc8c263bd6f48f7fb3c3a15b6ec9aad8dd6db41d2b59e5d563a7a4e17c0eb246e163699d5820a3d0a942f29d12600d3459b3e9e327882b1cbe586389c76c52c15f6e52c53b7d58358626b5233f00a4dad5ee294f38b41b0592d444439598cf2a1bcb8111bb9298960e2e65b2ac2521d7a1ff9b76cc52632e8257b56b0ac4ef2e49c12bb3b2cf22d8be636f28d1ca8489d77218a26f7a326d9e527f2127a38b088ae4eaf44be66eb42753f1f8cb84a6a52668f858da197be203e97652abf5435adc43af3e0ec32436bcdae8fd5dbb7ed3de85c310077f1ea5cb39cba71d18b5702658b35ef8936d21aaad28fef91d0dc1cabbcbaab6a664235a83f3c20297dd2c275cc0409fbf78ca20814fd57a6517a7ac5efcdeb2601136bc846e5a2ca6aa00f54ad891aba604c7cebaf7e60ed517dd733b9b3432b174f8a8735c89a4de1d76d3ace7789b72abde90a39b567110f1ae581d1f68dc4463ddc99f80e8005ada4367d9e5d797f25ca0cf902c735682c3717fabec7638758e56afae564f751d42381c1c05fc2bf2c2444f974b050318b52ad6111d34ebcc5f889393354ff0f4e6a5598e1df9a852260928c5043aca441505c0df2925e5b9c2172cec7dc81364551aa30f49f4c86ec330f15a62c2544edc7cb4931e3554450972bc876115f1087bb9628d14cf1d2cdc6ca13ee6a6772a24acf952da5ca460e1880b4b6a03d72f178b69b74cf93bb8fb60801a6d925942249223e6926a220ebe9159ebe14f302f7e002341f2fd516347424bfdc217d47eef3a808bff5dcca04583665b5d75732f4125f07f3cbd242e599f6dbabe8796cca2995955047b7f5e94d775853a8bfc7fc272b0d224e4b300c0701f35b92060687a97f90d40394be809606f541dd9b0bba3271e1346df7a4fb7820e73377821e7327b817bd5b3c6333a4c97c950d4e9d9cf032b90ca2318803e0567afe20bf1ab223e1e43f92374f9c0bfdd8a00ea6da2e2e12b67b5968457f3ca6f1d331d4f0fbb4e8c5cd30bafafb13f23103f2582f709881572ca81c5ccf141a3491a809472d715289b3736718b69c687c4bf720352527df815a90ae0bc57a6c5892d6b87654b9d23f8955f8e97ee280285bf7cd2172ed1c47357979666b6d12f82e1794c353592f891bbb105639eae89b0e83fafe4c66360012547445aa596798","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
