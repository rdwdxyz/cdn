<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9c75847f49f30294d64c744a326a4e170446957bdb3cd74fdc01d25fcf6b644a3a445980789a7456ccbfd147163f0dfeea05f222e1629f1cb620d2bda5decbba4c14389465c4e98d9fd9d704fe99ae927adccf332c668f4265b71fc0c2bd5f546254a2e1fe6a169577d33923989e1a1ba9d4fa5ae92663593c43e275bed6cc9da782fc2b78f8a4c496534e91715722ed56fe60578e985eada82a5d001b9cd9a47582a01bbefa014d877142660fc833f0198668953095b1b433e0b9c7a6cd39cf34c90018c4197754923cf7365136f3fd984a46539e057b0c423df4152580705cd91be13fbf53f6411e394c53d1630ba7850f880797386b78eedc64ebf9d5974069d5d5178507c862c89449cdcb78d29e2e86eca826e643fde78e17a85da0108e89dfd210c6af28564ff3d0a7fea5f23b913f8278d79bb2d3af1cda920ee8b906668022a1cb6919e6d9feb5b9b43d15382d48cb1dd13e28a4adf29a7fab0b001600450286f06cea17cb5da738e0a4ee64b46d2b5b3357796d57346bb373ae68f73c9586e763400ce954894981c7b964569754eb11aa4b9bfbe7b0242c76e998deecc453b87d13b40a182f179e4ae110099dee3037fe82b0e9d6def7c4bf8791b677cd1c56d0e538146840d128acec6cc850b3f692ba3af58c6101108db244b72fd574656e51499dcc74325c7f81a93f3a58b5e5b76eb832ed7a7f8c4e30bd5045b1c1c9b71f0a8e8054bc232b2deec174ccfcf679e5534c2b1681b31e4c6f4171b5db0dd8cbf9ca0753c31ea4a986276b659f8bbd7f168c9cd39f277f73611011dc4b39b8998536f09834cb5719879399bdddb888497157f861343d89dc313c16f93a1ab6e05f84cdd48d23719fb531df57cdaf73e991c2bc0710c0f452edefb60dcdd67bf6523ea1e0f7585472ca9ade2fb86de42f8d830f1e4da2a4acd85ad2244a51be33bfce3908ec4ffcb7c885b4d6548dee8a1424ed2acc11c972aef9503127637978e0656dcde1849d858298e5dc93e560eda78ab527f379375388984ef4e4526b3d00e6047727aed13e51d43ac32cb13ea6a9eff246c541908c63a22fb914f26322f235e739d338033af407e77c5b68b276e6320e0779b78afbf98591a3b817906b056bb55a62b833d4cc95c201b17524638dda06bb3a9b5d302f1d04d6a80f35802175ea9a6407892ba9974d744b26dcd589602bc46c5bbda226d308b3557c4deca5fcac3bc16234e8fbdab7ce2abca1840931a8e3da4f19850cac432f278c589126e1d566c86e6b5fe4d7cdbdd13052ec7ae66a2dac251266700d0fb007091a9548a3a9f594bf15d9fc5ebeaf54418b249d9d003857ce576c6de7fa4bbcc6928cbe1c7e63df4169d78aa2d99537f646bc5030922abc1be97f0f1ee51f13eac2dbdd87cf83b9108d182130e422b79c29d744b439a022094f93b1e3f69cafa3de31468c84abdc2fb077c195e4a24aadaf3eed2c069b140601ca16ec5b23b13d7788b3215f0e6ce46a96881f1067c019389f49bec6f91213e97929fe72f2486e2ae1024fefb39b4cd2e60cba21e9f1bdb7594db0695cf87b8b549615db84f7896f4db118262448aac1bc2dae9ba72c1fa7b599193cb55193408203d94cde7e91436737fd62652fb88368d24e283e0928b3c2b8955686cb5fbdfb8c2eaa476d5e75bad56bac9b20832a7974672bda2a69423b418320231e71ce558f1dc469a4dcbbb7a9d00f267d9a4c7c59872ffc10b1166efbaa36172ea4ec425fef510b2c0dae8ba509fc82d2f9bb45ba30346e790582ae339ff1dc448b5c5e7526622c93697ad97ba3fa1ba2c1195a68b8fe9451ae40f6572d4bb45c1f2c87752f4a2bd2db800be121a9bf75c14d8ae10766f0fe57c3e55edf25bcf73f199dd9b8985e9c7e71f4cb68697ec91c16b417353ab3ae70ffe4807e1020e6f6caf0746ddade463e75f87958d62616b659ccb2480b838c302bca7b80143fa192459f86c792e32f4a33f0e6539e76e62eba0e67029733acb514cc13a106cf89047c576df3a33da1487699c616767a59c7eebed7184cb8178f0d82cf33fec666b6a14b07df532bd34a0fa93564275c513adfe96f4034396c1ee5ac3f27c4266646af3833b53b76fdf594d14982a7a1acaa64fd4ffc4438c5287365bb943eac4a4c7ec4ed4d848618b181156ecf03471f017465ab1afb6d81e1c134cbb99cf8d1e49d2f75be711fe02fd50b273582d1a60245b9ac2d870612b83e169912c342b3c862d61e4378ecc96cfb764f849d011d321d5ed45208727bb80fc5a41617f2b5c4701d9faf284ff92bee8e9480864b7a0d0aad9ab337f3845a7652ddceb7ca04d58b27b8206d8cb12f6d6a66367d7bccec75090144813015524ed1b5762a10eee6fd587b13fda4bdaf9fd76e15240e9a9d9e4646657195d65f501fafbfea32feab9be91892582571ae554dfead7a56c6362bbedaa0459ac62fda605722488604c1eb7921cacafe41f6172a95132b2a358389f143ac2d8f293bb41bef3f60fd5d9beee7ef4075b1bdb9276de3bb93d339abc8c12fdc31cf89afd1e0eb0987775c3c1244afd42c8298dc36936d03ef466d2f1ba30cb0a84a7a9cf52473d01b73a6e95c974c851e1b589ab323fb74a9f2897e0c2e4e1e6f2c52be256d9422098d8698d1d1bfcc6c5994cb560da9182714d4b6725c39024a25ce9e50e2e1c1668cc269efd140dab70629aa8b2cb95803665df3ddb85e2c7d6fde3820d94b139face470622b9f8eb6bc764b3d90fe6aa6b0f818e79fd88aa91bc007cbc76771423ca0e84ec8066b83053433a90bd08bfa172a520b00ba19ad11b4c2f22a24a190c27cea893a3db30c0d784a3fd7907c9048ef916dc19d30ecc4c8ce442b5d5fc130df7ea738ac5fb9b6fcbfb9f5a652ea9657bef8e23607a0452bb317a32c722bc49755537dd7e79add1539a3f6e414fdddb527b1dda8f80bbe6e1cd0a06ce345ca42d0c3ca858ba5ee63e8cc557c9a8841817c3a1a4dcaf60d92089eca62bd34aaad3a0a4b1a462a5bceeb08fc5d4a56c50278c41d63aaf36ec137d2fd20589bc883dcfaf116a6c10be9299f2d42f15a51489da54999c1db61ffe12b24cbf9923347083f4dc675ba3021b40c9bf1e2645a3ef3f530ba3c487590c44923545b7f16ce2f4a944b6dc4b6955ed85ebb57a957f2af5fa828e5117e2953302d4385a1f15a0fd2ae9ae0b86548894b724cc4c4285f0584443e2d59b379341ba4599f5b008dbb5dd06de2025379d2f646c1175d2f3d5c508caf3da182e8df0a5c52324fb926356317f0e21018ca91261096880887f214c6c33601c45a3af438cd182a5fce9695ac0bdf486860a60f824f6f5db215f3486c41ff279b2477c14cec8ea5c2bf910943396ad4109f626bd88e4b2fc9b5b1293eccc99ebe4336567a1905aea3737352d2859c6fb9cef3731a14cd190d5b0371cd6edc3b55e92cdbc8286dca86fbf2e037a8dda2774fe4d31fb0cc85c6839453bdf38697f0ab442f32f2e173326c2ca8b1ee915a6d36d561544ea39ddc04bef4018057b7ad6403d2520d00c63239cbdc1faae07b948d57a586da3b5acb234c6628213abbd408d4d90fddde6a6d148fcf06d467c4d5c2828caee5c3557af0cf6f1e14aaed21a1674389b9242f0568a63887de950d6a684aab36b411575a398bcbd7955a71f1152d3ba71c2bc7ad4bcb10a4ca4dd7d315937caacbf27e51567957fb3681406290b5810bdbfb5749c3fc5809f42b4402fc612fce95e03ff55b64a28248902554469031fc47ebe1557e76066ceef1b6676b6ce95e42d86484e6c43f0d63c1798dc2ed652dbca4608586a82fb1b353a5cd2aa5f8a43afa9cd1a8e03be014718acc25e605a813f0f3778000a3361b614229c75d0fa9abd9ba4a24d711ce7075a5b0ad9f6fd5e5d808c1ff50523238aaf2ffea4c3f4f7c0f5f854455b83b7500eb087e52be7ca1234c90d6ba0256dbc1fd0ee613cea253258015c420f9717919d3a2f5803a4f6b1878d0b92a7a604f74e72f2a1ebb6f1da653be7f6951be236fe34950600856e8c5b0f077efc93679744fa95539d2296dfbbb022eaa3f369c3b21fdeb409e01473ab1325f8171e11bc7b7c5726fd05f88d064104ef32f5047d8aa22ae3bec1341145a70538bda04f3faacdad0227b8d265dd57fc6cd6bf00acbbc81055522ab5cb3404f845a72153ba21605f29d14f36da21da6518901506a85689a2ca600040c84c14f2a7a3eb38fb3a2e9b81347ff2a014cc25596ca35d48f5486e3c236f3e09c580bf3a3fc54ff14211f8e84df2a9112b4cf40eb8637efdf7cf664ccf95430daacbe33bb614c6cf438cd5efdd57d5e68ea398fe19226c6ff16250018c1a7ae01247343873e91dc598f4464048c6b70d3b46b8ad0b3a62ebf0b9689c55c16ea2a44b9aa787b7230afe59db98d9b15ff7c59d3ab3bf2ce3a1cf783720321a9058f21a15396a15ad35fde0ce3c65d0934e0664a8bc7a3d262477b01ab62528f9edd80ce77ef73bb48b67830b0d6c5397099c676b7e26e632fd85225c212eeb3c962d649750254a8252d0136eed2482740758d70412b6b3977ecc5c754fe56d95187b1e43c6cb0e282f5fbe3a5db17672a7e9aedefec0142ad84faf0bdacc66a16082c433534420b91828fd6e3df9991a419bbd3c0f8f727971279d2d865dd99a243b62f1420470848edc927698d22188dd38c82f55d958317640772ca2a8b34c2714afdff6a4105fb1512fc4a66a037fec0b4e56c51097a23b59ea4fd9a9ab9631d2ad51f4259acba25b16bc4166bec911cf7f9eb76607f69cf9658e83acb7ad97544ea9bfdb9c1e755fc1ea8f35dce7c6e6df033f8fcfad03d83a549a8a73b980bafaae3cf5562bfa42f4230537addd613529a01faa669579add4f5790d1a477c6d9228447d871459f839f2af483f9748bf8e7a7a75c0fca87bf940edeb5126363acb1776d93625f72ee8f8da793633a2776b09f4a523436eb66dc56457b594fe9917266b315a7d90defe132e474cc89a082201aefc8099d632bdb73fae31f10ad5015deceaec88319f9de41855183cd4e67b43b16d5715cba209aa5af5969836901bfdb38c51f02fe5943fac94a82711e2a176f375a474de5be765ec1b6a58c51368eecb14f34130df1a15cbac94bfda932e1818b4e3b4d47aa0f8cac50338e4f57ea700019004987bcbeb99a099b130f4c4054b0ae222195c18f68e434207520f5b61653e0dc54210a06ca90b5217c55acfce6da21ea34e1e950609c7fa7936f1f3049d4befd90d2deae399eb4ec2c7f20ccce369a1ac80554ad74a89e21d7bfc6656681cee39b170a2c3830526c554a47c365440348c77ef45da67485e6d6ae22152874b9d056ad59e6c0dac9ccd5a52bf913f6817bde868dd4377e193c0c8a8f3333e61f0efdadd2dbef3615795d5318f2958d2370835e7b3f281f5601bda0da381aec3d6844913d35e9186ee7582b859b24fe0e1c17999e35a188eebe0c2502de415da30262cee9d937367fe52075f10a03c0d258662a8dcf44a30a1b6f40a8c352e2a90e6ccd74c6adf3c182157cc6e8b6fafc7c3aa7a0264269e59f47d7afab13ffafe59a4ed3261cb462881c91b834cbced3b30af4ef1cc2274f037d0169840ec7610e4624f7bf4b071d3dbed4b10ed6ee1aa0ae7ab6be4f7ab4678f694647bdfd8aa9f884826a7456fa779223e028577e1e9227175a078aa66735c0bb62446e7c6a2c57d8ed6aa967f02057e7e347dfe74a8a2da76b47093564744e96f015b3ee9ba42fc82f1b7928259472b415666d6576324b3bc475b279ca0c06c98e4afe9a43b86cc6dd3bfeb974fc7e99eea811d0d62c65e81cb4d919c7b01887fab9be28af0a6550c662de078c3af63e0d4eaca11d31d1daad2574cc39c84ba89beeecf53ec026c15a7e7bb265144d2ada07b78dba8d32cc2aedbc9a01ce5f37c4d87204dce7154740376ed69fbdd366d88995d7b49b2ef0e9e10ef2a541d69aa3ba182e341f3a7600a951750a7c3d0f285acd2a43d76d0dcbd8e0bf7ea68e3acfed41ba685ceb20036dae1375abee51d5ded0e084c97ee3b8d1228dbe1667dfe3dde250451546dc54353d9b5adad12892d4f3fe75d53e263aa4c00f94ca571421f49e7ed2d0f737cfb27260657ea146a4db09c30135442c2dd59127e0ea196985d500e0c234bd5bcd611cb239e14c211cd66bedd4fe036c2f49d6a9e0cb3c13dd5829392c305c2afd6dcf24386909d6b5befc898ad8929c5ee1805a15d8bc537af16117cae2da00545dd222461a49018ce740e75a2f9c75cbd89b379860a95bad178301f0477d32aac8a9f24bc3dbe8b98c2b267d0ab26b3fd8a46fb78b599d94089d2d7b81abccf39679eabfa7aea3370497a609c657f42dc0790c4dd0a65190fde0a249ed8abc1a3486f99a2763d40b179fe1709e42eb8ced6dc730ee5e61d79fe616c7bd09ebbb77309d276576fafc4febe2c530f45859a9376810b6d1fc10a42166b8875015528e216ae606292cbac555bb9da6584f4cb108b89bf2f2a77821a3fe8a3e8d71f306ee526d4c34f50495570b27e1f3f19d165f29f36a1ae2c3f9e4127ba89580329e3d27cf86db4f3ecc00760be06844b4054d6d969995f3a12985d4d8dad2b6de15290cc155f7ab7d34212a5a7283ddbc8844c1ee477b58dded679c82d547314e41e6cc3c5251c4dd28f235b3f0185def6f9ceb078a00b8f2c41b3ae74210ed3ebde0b0e7bda716589c1788a6d3ae86d4863bfb080589b69e57b767575b905337e68fe91fb30f14c1c0cc869609489142a18b97dd43bef0f95a0ab0b7ca2d28233e61a9ed029e10356c0f3cc06ce5c7a0da10bc813e3ff5139cfa9c70a72d53770a2c9257539fed454265e2706f2a5201c207cf66d49abb39637f18b5cc391b108a6a587a6c906c7bd060cc16ba31481e89201c3239bcc45118ddfe68c22196bcffa08b6e5bcf046c10bb994697caf430ee3468f1c7beb63ad299e4e8401510d07ba55639bd5dfac9d45ce47ac798ac17d550235b9e0a67f4b0c292cc175fa38f1675878bc6e8268147e0da5902eadf0ae0067c2446e3c17faca4ed1c7c6fb5529fd93f345a890803ec66e17133e1f80b00ec36c62b21aa3781dc9cc89630eb4c81f638da6ca1299598c77d83dd781012abb68e7ddd24bfc052f3d9eb555bdf9a7bc6d83ecf66ebe2b2d7cbaa3f1b7a5b1fe716dd349713fe0a82900b42eaa65146510550f910452a39c6ad15a34700b924b3370f5e1b10f58f05d0c1dc64c40eafcd53594fa0813108fd0d2589517ac17195dbcb3240b88cf6c36df775e603829576077b957e422104ba0b219215c46e73a45d402ad1aee5db59710036c545e40077c06dcc12cc17549041230babe0770f0ad6f53d054e3746bec4feed2de0a57d1a149fb992a57bff7d42f2285c2cc51115575eeb024aea3e05f8ef89f312d85602a0abe2618f4cfd4e0387e2ca851571613a99107c8570348b11727548749ae7d15c744eb3bca73867848ac5889da09de0039b3ab93239014aac7efc4d0d3f79c9d2d6570ded0f27cc4ee6db698ab3ec35f89dc3564e47bcfec812b04e7c1dae2803c1ac8b642c441c8bc559d8ca22efba46ac2091c2fc0125ad2c9befaa9b637dba7200e1c2e5dd976f463b0e1d8ba5b04ceb683fae665fc69ca6057fb3a0273b7d425d325c1507977c552ec108d62af9b9b1eb4c6342dc7ddb1a17624a7c0b749beaede2186a8cca32899c7e09f8683fdb6313583431fff8968ec50d294e462665c479df08c58bc2bb600c00daa8824c4907a7234c1cd4852808c844702c4f1f0339e73d251f528727dc8996d871a146f253fd284cff63598f6f1102c226d83c84fedc91d85f13e66362d6b2993ba0e0a66a8b9692be741adc253a31d9faef498dab3635c0051c2ac5eb316603e457b849879bad282d921466361c39801f3bcf02830f4c442817a096052e8a329d8cef7380c9a3cfec2fffb8997c178c39e1415bad3650d7d6e789415424ce6495a0e728c086d4f5f77cad03400c2c53869f3dd0e967053d319b58051df4b32a2b7be3571388d7e03dbc69f33ca75ebd49bb76810e586e0285fb917a78f781595de7192e808d91965c0fd9262351a3363db788b7094dc09f5ca5b5c10a7a23191f0046a7863fc748442ef0c4dbf109cf5d9f3af6e0a85fb375fe70aca5365a937d84fb32316c1aa76fbfbb3e34be8856d91d29b51990b989bf4f960020e4c243fa78ca2615ed5b9fe00f205dde99e2a0935e3c8ff5560f7a786cf19a4a78ae511825b3d2bce0ff90164aedf113cbf0a65b207e803d72ac2468ab3ce78628710cf50efd6f44642887a741ff59d5f0d73aea80eab20b7e30824f825e141f6dc6ffc499038d8213998441bdaf79f9229a9ddd0bc316f34f0484746492dc1e6332c7bdae5fb18a5e7887a79b59512c14902215c7456b88638bc2c11dd7e92ffe0bc5a993b5226355084fa90d3c3c6aa08824f2b6da7399287661c800c42de5a44d4e4b34b6f36f4511d256c555596422c5100a982954e29e80783a76e9e8bec02c6f7b943efe4be9fa1751599f1bcbfef52dbd7f222739365faad9d6510f97a44a33edb988cc40affce37ada68579d4a07e25e33163f1915208d8cea30efa28c18982bdea28b25f0d4b96bb4589ee2f85d4744f017502cc8725453a9abd2746578532e4d587ee99d055bdd6ca9b9b3aa74af6bffdf9b4e6b7a2544fd5bb77b9cc96768117351c653a34312c331748cc73f3d45ccaa75eecd532476ecd87b2b1de5ad6663e727b664b4fd676cacb36ab644b3df84b120ff453299dfb1ef29c0486211f9342f21c2fabac4bc9f5d1967b1b7649303c22ff6f4e0c57ca84383a289c42ed965179b096833c08f7cfc1d077267a49863d8c8db268c981681e52c4e35f455967e35a3c600cb51f24c62cdf4603a73f5a0e67da106dd015fed80fbff2085667adb1f9bfb17f79c1e5d47bea2b654cb9eb3d4a90376db6980e9d3ef970676e12619b7c094e05f7281af3e872f701e90d735ace21f79224af218cdac2205ca6bef40fcee38e2907b3481bc3108b3c48ef84ec01843eb94797050aee35ca439d8777ca7702aa7f6d75c4016ec04e5b9eb8c30ec6d6651e8576d1c643a1d29e9900fd64e30493341ab67bc7f8d8e27bed45de3773cf9c4dc0da846454c4338f5dd4b1cbbc35046fe09e0fde9130cc9587bb41da9286e0f38c9b3aa65d7ebee55ff7749895b65c6c969efc761dc4faf1f92497980ffae36eceef50f55137852613738c4edef05f059ebcbeb993b75ffbeffc5fc5f3a547f78c73303f21eafcbc1fd5c066ace5d360e383382152f12050d359eacf736f29b18df68880e2a2104cd20b4d1b4da3916d26830e2b82f80f712b3e64064ac190c068f8ec77270ef79155b4276bdb05863ee052559875d0661b20ffde4aba07e0c721577a4e1030f0da9cb0767bdb6712bbb405e89cc405092bd26f7857a844ef8092ea162eac9bc5b152c54b3705d8d88a7085bb9fd1307641c3c33e4387a1ac30f699687a220e1e2c6e0616f88eba7d8e537f966bbe8072952e83c4613f356d365dfce305882b233ec2a39b73bdde7b452af6e55c00f6268b869b89c0deb7eb3b18f43ea9cad89f60f20ae549fec52986fdfdfb2253e0b5fc810f9eb1b688c5d8408de5a7a1621841733f8319c14b10642a135d88da98fa092095d7dcff0b75c1d5567fc807b2e0ba4f7eb30f94ba6fc1779350a35fbcc73f4adb71165d24c4e03f067b8783bde5511db14ca3ce18076d81a1a58607b216070d1e922ac227683ffe380b32ada608b4626de9912da5da537989392bfb5f2f991a7c801d033fa417cb2dbf720b5dd949554a8fffcc7aa218a1e05aefce62eb0a25965ab5d726235760ca132a2bed542c5a519b87b1fbb3e9560707222b3a3a61c256f2d35ca36f7c33cba89b6a874efe2cb9b6a6e4a5b0e22fae97640e7a589bb21bfbc6928090fc486a704db7f6a6ffc41f5160e487bedfe2df1945fd7206b6ee9620b43d4e5cd9d69c33516df0b9a9f08cf4fd941727faba1b65ff0ce0d662aa6f2480ece61ac0da958b47ce5a870ce2866a09080435c3f7717a15b6e107d460ecc205a63e0d5915141a6d0e3de8fed868356ddcd30f51fa9de3bc0f1111223560836d1c56035fabd83eb41149b07b96c76fa3a4c7030018997d8639df7557ea1dbfbbb278593784ce05b80526be061d7b247fd53de6250a3616f4d1fa71e332168fd5f5398c4ba4db34a849664501b9d442faf0e07b69a0bbb466bd81fa40c8a137781b615b5b5faf43e022f94d77bdb388ec748a52eeb2ee350bdecb9f1b225bd190b5c8c4d4935112add54095c116045ce8eda1a133f107e67e90ae42e38923ad826fd72e0702f50bbbd9544ac7df37c716139478de900979e227b9b6f1fe5b8f5e049a563ff1387596f40e8c1e6131069b44ec75a7f12911cbe49a78b1c8c3ae350aae2a3c320b1118161cf60bbd0a20c9a3ceaafb632bfbfafc15c77e728df98f86bbaaafe06d57527218eee2bc778cf24177cbf217e388ccf0783180f725b81be557bccc4a3c9c0bb91dd67c8125389110c12b422de47be3b9a051e221f2666fb0949dda377baa71a618f613f314be29adcc02985beadac31fce0bd22b8e09fb5e245575fe91c6151895f694b98b55c94638c0b143ff416caecda6a61bcc4c505b098332809b28524619b1c3904491ca7d070da5ce4db605d89073db0c7e608b116edd017beaa52a8633a2643518fc4f1205e782b0d8438494c251dd04c971328e8ce19e15de2cd0ba6ed19af14893a8e04ea275fc1ad29d96efaec045a2f1d24ad903f3d257da1599504d3b64eda1bc4e1e77ea484b03d8b576b85b0e4adce260893f8933e3c6a822da3c4fed2f4dda6e39d2b849bff24b7950ecb353469a33a38684d11c5fc5324501cb798b7128eb3542acaad5293deb8dc808964d9a956c9bd7a61bdda54fde72bf1cae11932983ba420427dc65c274e0f03e6cd9b214812113a990a4fbf3d8ebeae8d0d1fc8bc78fba1ae02d8932d7a5ae21d61e5335c70e5850488af9aaed0df0808d6f613b1a70cb195144738b50656f80eb8a62d58889587e3f8ae3d653022f8f45eaede6ca95204c453c5a1b565cdb9f0a2b94ee4d0f9b819b3586d947e8e14d2191dc23fc387bc191bf4307e5d2a27e8f49cfe478e02c5d4e1a6297871b7a87f49be44cce4dffe65aa6c72bf307a96704fba4219a934936ddbd156d2106067cd54348a9de7322e3ddb7c8f95533561535b7ea7104be3cdc4d40aa787ec0b22a64ba26e9bbf4a6fa4e07bdbe0346d32e571db834225ce3de97959c106652416f1dcc1efbf31f6559a635913a4a1a6f8c2eff3603b6c812cfad50c4f28d9eaadde4644735c2c7ee9cf6a6bcd391087a3b026eac62e3f543c1d625eea5e7d9abcaa6efac4972decd203b3878ecb9dcba065f0ec02fe987df60f88703c438474c096c1674e3f18b38931d3f2f468894f81570fa19c5e072e881a13975595793e6eba9b94efa9727f980cf29c0baf51513dc59b496c021f52424c7706bbd7b0646c8b260cc589cd9ae35bac3d0ebbd7d8ae3e8f004e15e2a5c439febb5db7e95e2cdd2525742330d33b5bfe55fae839c253de3501b02c24a3efd9560e266cf8d6c60864f2665944ef8f586ab59d3f1a31ab43d296e1a6ec185f942ac986f03fbc09ef959bae663596f46cca003b85f8021ec036f672b227b0886a998926e962e963ecdf6c6d43ac3937109343df581f69513c07186ff05228249ed03c04b1bedb4d1cf093a6373d305c7657dfe415fa512f42ee819e3d547a066ed9468c6023314a5648b508369ec8becddb17fb41d8798414095e7bfc9e2e7762bb81299535d8055be0fc5969246725aab362dca5a23884f23a17ed5b0345c31dd37120a095758516da4d0df17b771700d9a15804f68fd50ba18182740b6c3cceed98767bb755207d1807841dca4390ed2f6d58671fac64444a37d77fd0a50432f69e196d5d2fbc96d485da52b2fc67efb5b2ee4d3afa3bfc867b2badf51eea2c95167895e69e48bb915d32dcb5304b16004ef9e306f8af9a250f8c0d6b56f2ca66afb5a857388c1177de7ebf14147bea4b5eacb72a234bb7ee7d204f7afcc80563efed51ff7659896598dfd7f313fb8256f4d17363b28f5c753e0775f646f811da1c0850a1161eaf790779b04f79652059d060c29bd8a8ed847526e5ac504620803572d717f9cba0126bfbf5e369ee235e344b53abab426be670ef132fbdf668a5e564a9249da1e2c7cc69482fa749aa3ea9f037e24a9b1e0cde9d2b4468fc4cdc5d1711a7fda724ae20f47b8b9ccd5e6a5f212533fdd13ec41ef25dfbc07b4f7d678a3b9efc188568c6f6d1d87d9f260c8947d23f6a30336903bc69c6d47bbdde61914e65ed8cccec4c2a4270c6aba5e756a8f60747e638ea4596b1c2a29ab01dbad6fbac5e0f68c305eb93c10ceaf1b412e2845302b6c937ac4091979b595d4f235f1824b92d407e84515889bea019f09c18555e2a1b4103dbbbaf14ae8cd695ff97b667e1f71cd87d9671f2fc4cb2422143685705b67a0be47035327f2197c2daf5876beb8336c383d39d76fb694fdfa2ff84f1144c918dc6b74bdb99ee0039ce0ebab46fd92e00c7bcd72cb20264441338a12680c06d6adfda82479c37200c79ce9758117ec088a21ee64dab7bd3c544823fd84f938208b1e1df86757f5b185d61a69f5a7b5b818e9e2d297ed054709784b8cae62e58dc184c02b39bd6d9c969437d849d3956da671b2bcc3988eb863ef21e990261f449530fb33340f53f8843d5edcd73b2318b10c2397fddd62d5687625ec365da541009940c1b53deb630558b4c88cb6bc9e11c9af5d5df02e1440f8308eff53ae9d76502a0000e39fb78cd821b24fd01d87a83589e5af0f91a0c2893cf957602fe958b25fa0efbb3fe07fb59a5b4a80c540df21b5b24c80c0637e6ed060625e3260adba8575bd196203ca8d4e2be870a5368c8d68449827c7d00d9ddc0343a46824a374c46f4be97fd177f1f6b40e04afa20480452ea69411fe24bacf1220f9fca707311e76dfa01e48aab4d0c9d89465fc090600e029fc75fb040806e6b204fcb7db055fae9784ca7e899d59fc619fcb2198d01f719f300071ed008e2357621d5c0cf9d2eb64910cbb0d83a3942f997075fcb39704bb79d96126a300ecdcb6773364eeba79d4d2e3df20ef952cb101b8f141c19f03ee6a36b436940d2487466c214b66bfc95971ac1deb5be526dcd07af0177ec86c6fedec58c5cb2e8cf2c644d0d2f8249677fb29539e00237aa46c54e3b6da4cb39cf44c0a7a1e764a0f877b3417676335c66299141f8078ab4633a074386602c704e69433c638c822570d5cc2e3f24c8c653d9e1579017201e55e099c028e4f1414c8d7a99576b152fd6a807de6d301a4ed04b00b9ca41c2cd19c9082cc6b4bbaaff38faa0a08a7f2975cdf58446283676884679c20a6a4957abe92e3e47e009f287c3bf2b2ffca859deee4057340611fc2e9dccae8add1882d387087182419c492163137cbb1ee96b1bc2b94af2526fac7545e01a17dcff2c60a60d589f22d03bc904f32b6d93d179d8d753758607cbc8d1ec44eca3a7d05bbef653f680ebe4473acfa02bfaf5f45f1f9816de44f4a43638070bafb06529c59f8a12352760ac0a831c156def23f77de986c22d3677c512dc6bbb16bc924f0edd6ad851b70b123c61ff739b80cb429426ba0defb416423fb0c3cd425e6259098c74e08d9e32b6f0da422f87d29276034552d3b8c79d8e497fb17d233c7f383e253a547845ad7f9f55013d9c189840849d7da8587defdf222f585c357b8f8224fc8fda8fb1f7b9e83113191a1ae35dcea4e08e6379a55b27f14b6d84244a22fd6823d6b0359077a8b36c708b434be995f21cd506ecb29ef1327f977116940aa5ece243ae12796703babec538c1926d2a2b1ada837a5a30a26a0a6538dc84f8bf928078f32a7432f5e89f22e27bcf9263a13657868d0a71466a59258693869f42e5d22c834026b67422c9584eca1778a17ff4f011824ee7b1a232f99b91c6e05cf170413920adf54d2356769b9c6010b3bbec022274050ae4c6854f52251a266ca6f75671af5bdce724ea8c65d012a89e05a7a2b36734ced540fbb14641a6552a592491cf297cc3964af6cc476aa3e208e0ab043db738221c9b6748483a719c4445ce7305e80ef64f4081b692d68adc9d35114c0468a588b5ac787984649be6e183e58b135b2f517c3c1510f29cd7d24e7ad2e7f812cdc58a876f06f8276e308d2ff80794b46fb4f5fe3ac4ec6839cdeabb27f6eefdeaa0868decbc1ae20aab1d9091947b0a7d68f78fcb93f320979b6418d3f5220c65e0ed21e32d1299f66b0595f1a5bd90c79c97e57e011722a2dafe1744afc353a3f517c163dbd44ba6c2daf059839e4999d5863bca57f96a2f76c894e79bf32c10c7610fa2c428c54b4df4c6a985b2cb2c1c74540615413e11b07a25e7e10d59bafcd8b074bc1803f002682a17b4a6e74a8fbe4d870ef02825b6828bfc4f83b2060f9928494a5dfba256c2d4797cd53f4195c5ffb318d04813e9ec17590f66ea7651c1e5d27c55044889bbcd9f4ad95b659e93e884f594649bc0ca61106881cb76c9c2b9f7a944ce202a1fb9a3f21e0813033d651f233b64434925ba895d700e171c485e573c4e22b914aad53310cecb38cf29655292c7c5d37f7f470d77dad85a6b5a591868e2f3a25cd1c877f7bf75cb3a7069bb175963e2ea40c148a6365976aa21d7a40ee33f94822a53fdfeffa56c9479cd9ccb2d913e6557fdd1dafe1940649efbe08f5c7b975949fa1cfbe445416f3954445a5951be606135911655f01b00043b2340722a1d48259267bb7e1efa9166428eaea98ce8fa6aebc106eaf27bb9fbb9e9b38125660cccc9377c4011b02cec7821238b9c144fda1b2a5274137e90fc0234e756c8df33acbb1c41b17fe5cc7b2347bbf905d6477b24e9b621dcff60db048bb77578d95d8897175b5e3c71009131f11703ad1a8c2970ae96051611f052211e1981ff633cc82170dcbf2f593b1bed51a9d7ff3943fe7cfa5958a860cd067e774394833801866c5b0ce5456309837c8c65302d352dac1373165268d57013478d2b004e036dedf9323fd9b9e75a125ff7add443e1a253feca3fa36eb8de38210de6f52d3ba1168085a7bfd2c6516f713be8f40249ac5350ebcbb9315abdeb38f5c727d133c1f2ff068d064461d4724808594ab1bf14f7099b4464db3b4a7cee645f3b72ab11797c4a24d39211e72a2d49136e2bf76e35a0ca49ba3dcb6281515120dcdfd47e82fb7c4b90f8170731759056313ae8be49041bc1e2ffa2d7f3e3a4af04fa64582088afb42bcf657bd2d516b4b13371827e75b53841b7a6c8281987de70faac268871d51022ee943e5953b55c2753f00bd76c6ee77c00932c660e30dc653146fa7e5e94c03079a5be9a8e2b2ece7d6905f08181e2c4045fe940f243af56defd3c12cc39eb6bd9cdc2a7fdd9ab4ba6c869a4c2196df4c259de78a8b9d9f1149d33e7cb4bd145c0426aca4feec7258d3eba3e54409e45959f03e4a080083601834a06a00deea32e16268ff20e72443d1a41b888e71af2db9ffb6a0e19ac1311e2ddb011277ae9ec5afd52b3169d2f64d25822b26f0add96d631e148fe83bfbd11652e5f1771c37e58d09c20225fe65d75945d232254ee401e4207f0fe6680c190f5864474560517d19faad4a7b026f7e0199af814e77cb2b8d4e5aefedfb614a896fa5e110558c306406b5eb579ae7a49d9ee0139637f1aca469caa4d3b53c7fff0ee80d1354bc97fe148552c3b4ed99536b2a29256a01a6401245749712d5a0085d7bdb4ec332d9697797527edd260c5299474ec3b24c5894cc3cb27505ce633c9cf1d2a0cda540b2dd2a652cb271a3f4b11591fd41072ac3e23e4c312ed12303a113d57c7b652f3bfba4431c4532d23c059c57067ddd3a59b2909a5ef6618b159387f3ab49084569e08079042cca50c64e09a50f982e77a21e9579e5177a31ffd6a84044d29ac7a2eb164407d9a39a47ed7484ac2baccf95adf05ddca8e6b9fa9868dd9db9e4777dbdf419454b6ee19c8b85b9d6f7d38006c57654f3d8aeb058c4550718d271ab05baeba44af9cac8640875a61ce57ef91e8ed33d5fb5fa5d9044b80ab61f29de36f3d84f6ba20e0f77486ab87c5c53b11caf77f0c623851b4755aa77a483be5586220091c981b10d25c84d2c188ea89fa1af0b58b31f4e0123abd59be05cbbcff15db2f3592ca3b7226b9e4b6af58fb92a92d2c20c2b6be1cf1aa5f2ed92daefcece5e48eb2eeb0e69cbf15d3edd30b07525db05551784447e827c2f9533504408a4d3ea18d9d5141df08383e6d7a0fc3d8767761189b0d37b0bfa51a8c682d8eb332c1fbf36f0d67ba1b1475c902b93a4dc85917e579c1de813de1de2a35b51df13c6b90bd062830bbaaa3e5eb6690d8c0a1a77f50d8b17c9acaec7e65d6923c7984d1700653b7bc11ecfd7c76edb7111bdc2bec9a854c2ce2a6322ebb6f42daa04f2f6202a236ebe3cd6eff318d83056f47a50d71dd664adb1e2f9566fcc6e9c3160f9e3fd92aafd0f443e499d6dbffdc02f72359fcd16f9e8bbd03d220228b795acd91ee5686b20e196b52caaf7344fcc8b4c8111a471a56456d278965dbc068437628f6a531e2f79160c845dab3223f090e8a61477b26a6c1c224fa24a4e5259acc47bc6d966a74b3ad6bf2838a7a861b7d94b830fcdac4f41171bddbfa7bad763680e85a67d90674b3f25f9eae712069cf7c31f478b9069fdeedcce83746ec9b78bf0ce851ec968657aeb3568a73d27eec5b7d7eea68aebf02efc6def37bfb193756b6c114d42e9a2dd4d2710f6fa7c78316e49548402f7fa7beaf558fef7a4bd250e4d4fa7c9ac1ed98222034f744cf00ff7a65ae35c26c39cbbd0a2d77196ec3ca348cd9d31c4ba6ac2028336bb4f4a12dae773feee172ad9095c535f8b6bb94fe9d1829d5e76cbeaf9c0d3df6dc50c13ba39f33b359c6a876c6af3aa6d11f04b9426c57bf188ec45994539a25aff2689eacb8efe05181f9aab23d653a6536e7f227cb0bfe74332e54e9f97e0fc62fb696762ae5d6093f66f921ebb20444c54cb3a45ad5982e7bc2ff0b61df15e3f86d7fbd97eaf662a6e7689b25a2b7f4a5b2f784225a9340a602efbc91824170aee2653f51937905e8afc744a75fc998806539ede556fa5ecb8fa38f5564dde4bfafb9ebd57d45b69e8d522153fef5a8cb3211fcdc1436eb62363bf29fd0e6d531c5074c38aba6401fb20e5801df3aa28a8cd4d686e91e11343a349157aafe4a51484f8a5650ba0df2241fc4df61757be5263b3334ada0404555e747fc8a75890358cdc15416bb983744f162a079b468b0a39e4a06bebd9acd45dc6e12f97f29626fd91c4d459d11810fd0877754046ff9d1ece6d5a434fd9ab8d8a12b71b3f1635a72837988c56455bd9b350a8d1522e155128eaee62660de58e2c1fdf1418c989ad522a8b416d8480891ecf881a991e559df01ffa88fc82d0559c894f7bb5655267b1fad253da80969d98e4b802e9708f5de0872f9e8047adbe09f6db4cefc3a5a1bcd8aeb30352f8d3ff24798e1c2614e6aeae076cc7442f2c67ca7e7536d6117992ad130fdc527ef1966e85adf3c29be74d1255968e0cddae83fb83464f926a497e843826da9d24aac5ee6632dfb66c3fb05632fca7bc1f070ea7bfa3e37660603e2f976a1b1a21923345a841207e2234325b16b1d2d68f76d78e5819fd8ba89fe853788eb14dab048bfa4e4927a40a554c3aa5d6a96073cf83400812d01dfd49c754a9705af0c57f6e0dbe0c9f02a4ccad40e5fa6716f4e5f232894e999e6c449f475b5e7f6ba41abca20bbf2567930f90ec06e62db74b9b2d3d716cb1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
