<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"341485f8325ea4875553a205d2faa9e4352f1248a027188799ad4b1b48f8e796cc91693629914b4654d78fd411ebe1ca9c0f76de5b5c1acdfcf094c5549ae6afd79d5999c4375dc699d424c0aa93e0bf4b363167888ebb635cbe83d49367400e5a9cc5163b184f9589c8f992d5248e69976f69b4b89bb1f669803cd690769f9581be21041652d6b6e7c12eb9b028fdc2240d9f30e7115fb9d7417826e1492a17c6eaad438c78a47782a5899ed981293f69d3b68e4c11511e592871f243cd40b44cc53ea7fce066aa805b4f9d8edae5eec8f63b761c6bf19d30627b4282277326a0b7f4986838172fd154945cf2879c8d76147a2e43ca1dadd7cb806463877efc304f04ec590baac42461c21a6ff62c0e1059d16055b335dae09357fe3aad52dc5be90cd29f6d86385231654f9fbd39441d5cabe0bd6222325d629b40c1f2c96cf69b08458250f74ca9a7f82c6e1406d2748aae1e1c03df23da46344391d29fa99c142f70bc4ee8cd8fce69602afac157cc9771f5ef650a262648570964085542ba9b9635343a155aa5dde9176d925039eafd1c0a00ad384253ab0f2cefee357663cb0f96a6b0d712140e97a7298774bbe3a683f0cf0252f08d56fe9208b7499f29d9aed37950d11a583082e6e641053f24c3f2972b565d86fc83ef6d64b1013fd22f839670b2d4c95c15d513bd93897ce9900765cf9913071cf232612db95c0e0872fe8c64eb6a8090b83c9433e7aa32a8554084880b6399c773640c3cdd89a345d8d256bfa9fdffd6103457c9031e7d8715c4aedf3bf255c9c8065bbf7998525c5529caca1a04e6e001358b9b89064fb98afbb3281b10f6475fea5e95491d5122c04ad11fd02287b686490f0e2a59ab5550ad868b9890d62d8c39eaf9eaf94f0dbb90921d5c0d1994dcaaeb28ba4bda16775795196d0f0a11ccc4348b074f7f04ce103f8f19f87c8227fe73b7f5e117f62031c908d27a477c52e0cd7c6315a6603f1e58ec4f0e7fbb07fa97a7c43b33723cfdb4a7fad918c06192e508a1de41b5e92c0f199319002a875780da37b022dd7424c0571362ad900c9a546de90672614529fa336cddad3bcf251cd42e76f1a31c344742675ef244cd8bf1f6f7737a9379972e020d30c9b9e20f4effa7c77557eb59146cd6bd74340a7c4025a2f0de7c310a442b8ebeaf33e41b597fdd2267ff4663ee695f4efba914e36648dae940892f8df3ce93949dad5c2136b87a22a4909e55be7b5942ba2056dea90005e3f134086b1b970440b57718b6186290b674a35103926c2e58ffe3649b84c21d21fc8dddeabc1d2d78aa2535746d21454b444a098b648b9e7a0e8a1731ff14a8c5a8523db03d3f189e57a09b7172a57e44bccfc463b9c249a1723fea82b56ef9173452ade67f5e5b0344abe6f17731dd0648673cccb91b5d943adb45e5d24c2dafe760f82ee79558015f16e51189322edd48361f93dc70ea32029b532d88061234147b3be19dae36ca3874afba81bf1f6807a0dee3ddef60b05f1bb50f7684b31114d47019af36eb0dcd376c71ff1de73080c92e1481f767e51b29ced02aa49698e86e19a5492d667bde582baaa147a16a438fd17668b8b16d4ecb83ff6bd01320e049ab500423e626dbc6b5de0b8892237910063e08de06376871ddbd23fc87cc71835e8424c3446621eb99c70d9a1ccd37cd3171cb3fcf95daf45a4e143d8f595684942f97e75ca21d5979b08012155a9ed94c6a0c3d375813f3a62804d0bf88236892a827e344ec42c484315620587bc88fb87d670fc55032745067a4e322892121d15649817b4418eda64735c7c9a0508b4a43b13e092430f3f142084921fe4c577ca3d8a61ce75db8ad6c2a6ff817c11672b5c9d77714e763bde351144a18aa37f617aa84ed32af9a0cda43cebef927db13bf132896bb9ab2892fee1da3e1a2d1cacac33a90248c9e6e9d3c7434335bf2f4e582dc1b44b9091b635f79f938d6a030ce220dad1cded4807befe9217ddfa7ba40cc16e008fa47a3b8fb6c2010dfeefadd06b4620f8775159e90c6c22f35d21d1b226c37f340f695eee23400f85e4be84e00900ff50789d68115440d9a75ff98af4cbbd21cb2d0f1d2fd4343b469c0b8a924f7838e5b37c553e67b29fbe3e83d7574d365968525f8726e4cffd31d2f1a15099e88cb2ba1c37d569554d9680727dc6820a36480860444531fa339a5fc86513bfd36c670605ed328a6eb1b043325bd5f698208ba52d367d6001d47d66fb83e5d9302009d4c3718618af87187f64e493bae7c75c596fbd8df71b613a27075229168956ba7c36a58b9673f1a818f646ef95c40a20781b27acb2cda2e730b77ddd04147725cd90c921e04ac20bdf6601e70f2493e5d8a3e86c7c1f6e8d3bc723fe90d0d027962eef8a1bd7c5ec02578f3869a6956248ab4f2e2a82def5136c56d5390000595bdb7e877d9220b458278de32e258c29a90b7ca0993058cf35f79ba44915be7456e693f28db211a02d04d1f5c0cce4e183ebc90a0532ad639ce6ee53b1da6f8c81a613fc4ec71925ee68c097228c4f9fef3aae82b40d0ba6ed96709b0e9016889d57aaf8563068d172c8ac6b10e6e5095e3a7cb1751b60ea8f15465884a014b7e294aa62c3d8fff9c148d6fad604cb796fd569d71dbca7d8a7dafad3816b6fbfdb10635010386a742b8e0aa4329e213d715e56b9b1aaab0a35582c494207e10a94cbb9e7fcc49bba0d556379f422a678520a45c09745850b3b50c11ff15e17cc737f8d6b38f57a645dd3b2abd0fd5eae34e649470552390098baaa4f6276c8daf265d63835d92c7c0cd2c9eb8a8159c7c6d52f531409643db79efb848bdd733c4851f076fc4adbda814987fc0493879ab274655c549a5bac5adbb78b6f58ea6875bf69a6e58f164f83c58092fa0b52cb11d13907f148506a430eb869f710bacac6201e368717e425fdd850b3f054a507086d62683a40c608ca1bf3791ecd72264eeda74019cde928ea726abd7e87db09a342002a1ea0862df6b42eea6783c5f407a3963a4991a1079a013d15daef09bab412d46247b6ba1d66fd183063dda7c0ff09a5e833c26a10cf60d317bafefe7c3dea7892776c5df6649b31beacf829f3d34e3b0e977b45c20abf6d7abcf8b36117b3fc2df91efde00fd2c697d16310e58ac31bba47b28c8682eb7d07cc7e6e15cee48eb8575f8409a92e3de11661c651d80f6c5f4e77fc7bb9a4266475b64df6b8d7f768add89b21cc7489cf8a074e629063befb85d343b6034bab88f02267b52a93f9d003c73dda9b75b594057b7625e77c475479b4118ad40896acd2131b92cc87445a20a8b3bbfc77e4a2f82f47e49c769263f7d139f5113a2c5ad9808875a4c8bd0be2044e4fec8ecff374f5d54c02aeaa32ae918d3aa697d463b360f24b74bf6f5b02a393db36e6907089703157861b102e00190f0d65f87123e31311277e466d50a904cc548002cdd9d760f6371909969a432861aadcdae2fb4346a17cb362aa5e7ba66735857a06743440e267f64b172cd8d42175182872bc47d9c56d35d83ae9c93635ee1e18ef10b2b2b754a3eee294c9d94402a13e50127e192fada638b7f0689d294f0ef7646aed745031386ad54cbe54a824181e2c156b307907ec83ed28a0a26d364e4e6718466a1c217a53a14683f5596399f586bd962e0267edbc383e93c267f301ef5720c72d8580b35fdaddc2fe7527df881f9006815674c63f3630f13321af27ee709580b7fe60cb2c08d1a7dc58570cb53fc181cc995178950101b263e1c854c3ad2f3269665010e9f3e35003ea0af91786e909798287bb6bc6d705b159435cbb26da85b55d02d8fe24f0c969e851b5fe5c4aaa50c1918678c163ccb24552e3f4cb1cdde301833e504b2b82ffd2f37471c3c5c8fa3db23390f87cb5df7d07ea255bd661550cafe6a7e4cc625da789920c116bcee67c119c01dfcd86c5e6906a1d754b0a7107b1149062711f3dc6e6413f302a7060ce5f91874259752f3201f94cf35bc517e0fea6bab27a6016e1305c88451ed529a42c1ca28bab3bb87ea835f51186b8ab6a574a187bee68cdad463aee6a16a21cc24e0db0bf2eb4b6710a58016f1a5d846646c765a422fc6b4b128c8faed3c7960f0378a568d075c8c6810b7f174bf83d9dd0f401aa36d66f5aa0348e682bb6b964a57a2348de8b45ce8da446857c3dd0989b18e9b8d8ba7e1e4c1f984ba47362e47e799065b7aae8ab181bb5ce75e48dd7e8ec401bd0941bc5f6e2f50554208ec28a356aa1e76478ef5b1e3ce08a3493c4a08a88a0f370679e4707c609ce85ecfa9240cb0f60db3848bfdbab860f53c91d1de6858c03acee93454da340bfbbc0f98429a75e110ed15c4f6bdd05c4abcc7b1b9029eeb96b0dc77c2a001e84bf33cff1f736025a15a3d575f2e3820808a6f56fb0e71314b15fe547fdf2f2974da8106bb0d168df0ac04afa61dbebd627962bc2736fc4079a8f5044971bf8cc378eed6afc1725c7b4c0c4e85f50a0b7714131936eb1b88b03565c221542443991c831ee539d04da4791cf7661d968b31164ac7958422362fba5a5b90c3dd27eb836554583e70a8a8d1cce34c0b29b5c009326a4ac7d9feb99ef1f141d33aec8bae9af0860d687b93efee54ea7dd90d999387a9885a363b62aa3d73292fab8aefe8ed65a9dea5b45276d391877e06b47bf7c88e2b945cf0b1d8abfec0b777412a2db4dc320e052c240f9b8c421961874e901a56cd792ff68ba3eb4ddafbda8276241b920ce23fac3d424dca2f728a7da162a5c126e771aebd71484613f202ddce318a5436f9045ce5ab8ab878a7ed96c6131e52e6b75610637855d498b02c9475abe3dca42b4bfc0cd4421cbfac82976e4b4f1130c3a50a1a71872f5c54c80406db5e19f9694a38940f989c00588e17778919f4f9b16f64332ced3d66746482491706235932e7075ce002978d37e0ea8f729246f8cc2ef317f25c7e93840a3bdf0902629870ec0ce99bfa6a32431b8b26f56e1d2267da4b79742d7cb9199e4670795d5b61840eb2f1e3cc6f57ff5552983716bf1633f40dde7a644e76f394cbbf8b331ae8ee4b8def254d0b44000e895617cec460d1b87e259fc31fabc1e6677ddb42f4dc0ee7c2248a812c27a779e421260224db3ba62138e07476ae1a29d3de6d90ec70a647aa28027b92e93ca998ae93f0ced39c20864eee0ab3e8a5b353ecfea9a2a12401dbe9b85c20c9afa81f472e132f1772b6e2b6f896ba2a1d763296ae818f0c99619942891be109f6600661583764b6a6d337d8424edc7814c1eff3b1981aa7a691a3dd0574be95f28344d6954cb97c4ed360788a738bbffee2e2720329d752d89deeefee13157e322270448a63429713d6343d8c71dcbf31442510d7f4a77fd6a50b8c7c3cdb48c327b3bd60eb9263e977dee49695ebadccde4b36c4721402e3ee28be1bdab08718cac030d988952a3edbb2ef0ee1799e3c997c8a8614ca166f79c7edc53bb40959c50318d6b057b4f867fea1b5b3018d2463df24cb1359e9c67ad15c0ea390b0be3ac69d28e85937db899b4e0bf24b606a308f66b5dd288957523ec7c808be4f06b353111a57cfdc50872b587b89f2f69646835c78c4b9b94cbab31c90a631555d7d2a095286651ad2c8315f2e686f7de3dbc374361cd7c1cc98a9c647edaeced27bd81d6ed52a7e1a183caa2f3ca6068eebb58ccfe210b6b4535545e50c2618d198d687fe51868cef5e0724bb5eee46f79993ce31b85d3c25323c9a26433a98f3bd015c85958bfc6cfe846cff449270a8db9e448b20a6deb8e85c4bea51fcea0cdd5e979c9bb8ca7335efc70a5ca909a287700f967caa071aeb4496a038c5b38ba71f17cdb846eee45a6b23d63bb9424acd41d0ee0c4608b6573e51782f5f6950dccc15db166beedaba1ceff49cc213071530349c16bf1f659252e9ad488886bb01638fcc912c46d3bf7a031ee263dcca39ead6e7217269484a876719a65637797d51aba6fdad0106b436422622fffa4a8827b710a83264a356f840ce90e28194a1009cd91c57ee74d52f111bf86d34d85e19cb009b95915b3ab3455451857e23325a9f338144bb080c132ff6e0479bf935ed1fb9e61546e6336f85b857b5a03406269ff431755b89af9a91681480d4c251ad30c597f847dbac95d9b699b258353031c65ba392423e6c68a448a1783962d5ba4e334b83513c9664ca1e1fe36fed77cb8c6562987c8e742b62c63ed2035bd534ff94e5eef3b0f0b3dfb56569654a605a8ec33a302aaab598ac4f037e8e1f8c833b6f860c5fe3e6e1814249cb33c34759a3041ce4172d8dca552c9b420cc660929870753684f5100dfe375f1187175d5971b67b132f8438e308c0e12a08660edeb9cecd477fbc7204e69f6a52a25079ed6e24d393a99114a94ad39dafa1a08374e3e5bc664ce12b8d8eec39b1a58097620a8b629cf33c99928908cfa17aa367af312eebb3da08d999c50cc9ccf39f60567cc6d5dee5069add04584661db9ba8c7191397039767dc4cb7bec878a5c24e2636a4271741f1dd687b8f751f4d422f2c20080bdf0ea3fef6c84360667ec8b3e31d5b9bf7a050fe870f0d2baa00545800958d032b60ea7de1518ee0edd42e77338be8750398d3108925568088ea2254ce953d0134fb0074fdb0433448b0caabe37a3cdabcff888d19acc1776f5b44b989a10a0221d19aeb209a8cd87196e7157caa91d8c9076e812c3185b74e9b0efa4229a65e1b289ce8766062b7737e039bf4da221b721c7707a785ebdaf0bb9e6f00e67cd4ada35a9bcaade073e990c2ca4fa01c22186b36e6e52ab640182c1c0f82014d8fd0ca8885fff7440ce6be6fd996fd41a3204cb5163a7315acd1139ddff92f9b947dd06a815b1ec4e10398f269ed49123a57967294f00af2a7aee890f957905639a08ab1eab2c8aea3b8a0f17bcd392025a9d8cc52d63a822bb9c0958a30c9db59f46f27038ad8b4afbf9d000b1adcc34c6f8a7c5480263aed9fdb1024ae7e94f088f2c5191b2d27c6dec3723937e78c62602ac0cfaeb449c92ca3a02c08005e2d944364ebd6b29c1ddb7abe7297c840b999c58998652e67bbf312ba7c0313e381f761eac7c31a8e765766d391f760be9ee354bb07c6bdff9f4521c81bd8245179463e5222d7f1d8e10bc01aa8837b0fd9cc0d4c84727b9af55a0a48f6d36adeca6cc8caa7b2449ca58303151c4c3a42b383c00fc842126a7152f1ca6b017ac4bc1530591fb1511595eee5bee8aa437da7610bf13a4324e540fbba52a0eba871a9c9eb85e9f9f9f8140c13cfef1a47e8fdeb833e184b2d753164ae77a04b13cf457422cb3c3179f644fd460213ba0fe2c05ff0be5dfb6de6eac2db018df15322bca21ff2d1ee107061885c6f202e11e5cd29d7669fb2dafbd107d6e8e704a137c4cd7c7df63c70f0f757a50fdc39491435f5325ea4fe67da8d00f1fe0067812629e1be7e97a04abe8670c575aaf923ee63ef7278377c6f17436ba36451de16443266924bd4d760158a02b540a0d49f0bbbf7b04a8437917e9910e62a6d94a40c9266d77ca9ad04a28c461a49876096721c08814d88735225115e14dd2ea3e1bfc01d05c2d252033ad58bee2fe514cdf19f88239626603c5f4367f130ba51cfc0bef1ab60884e3ca67fa5b3b7e1cf2bc4f3f38aac0c0056273246be8d1cf520daaeb156d384b192300f4279727baeebdc93e7ae95200b0c77b3acc95e0f350f537f9d6543956d3703dc340216e907dba5aa2c93432a76a5c3b240b5047d941c59d5984152dc0c5423d5062142f7b3346b049a259b6e89448e704d05310d1a921bbe3f347c6a2877984635aedda5128d07bba5042c9ac83507b075ba99ecb6ac58283f1234022e85ac631578b60410de1245218cf7bf18e947ee7376783acfa3c2f4b2419e0f2cac8c41c42583712b0ad0808a38e42922cda2628efcb883d97cd7bd3fd1cd1e936409e6af36668c0c61993f9611f788eb556155620124b4ac3567b8da1093a27949493ac6e2946a1d4ecc3f9ad1954244387e3ea7ff0ddcb2ce8d2c0bb881f27ca6d52df50927e4205aa7f3b706a8190df2de32bb7afd943e891edb0ff726f093eb3e28df6878880916fa5be8c139011fecc42dd0dad54e98e86afa3e038b6e8bff73de748bdc87a7900c32318457d0031f4fe8802ad54c64a020a731608356f325017b4fd7dc81f8b3c9107ebe312b054b72f7ff2ebdad87b00bb6ed3dfe354c5931006b6c8ee34aa5a1bf93491cac0a3446074c6fbf50b441719aa4e68526d15f84152d2cf7308b9479fbe8a58e6b6d026e1cac94fe6b17655c433313cd53bcdc347b1440d92f4a0be7c4fa9bae844b4dcb7da9b822fbe596c9ab51c884622ec4d0963ad528ee59fa0782e63f90d6057fbe878f5d5cc211e78879c72b00d5d355e8ebd6a82d9b989d6d719dbe40194768ff49b363d24a060c87ed95c452037701f6e8bc9d6ff846b2806cdc0d1d518142e5ec34168180ea001b768a01793660f351909b3b07840206a813ff3f29bb97852617b99d55ef832981e5fc8a0db52a10a4e73189068ad456f26ddd447437ce271e8325e14adcdbcb6eb338b035fbf7e363342135e1bed4f406369174148ed35ecf1e39443ce59a30f8f4d6dcac50be504674ea7bd0600d0380ba870fb0211c0c15b1a940bd31eb7d3915bb80da04f8f1e19728ce4f5ce3ed0e4b95e47b8699f7d312fa9028af811bd47e9afb2986808290c99f61f8223748f5c813f7987f607807e3e86ff385bae53a3b2c39b9237a90da2699304500eada5c40f4968fc5566aebf3eb406050fb246de3ea973285ad9536d4bfcd5edb6d13be73211edd892b63a8c48f57b414af9dc1b42c5da55740496ac05441b3643409336d89e3845dbbe86dd73ba383efbe678e4ffa178cf96b1cd172d677e8c9d4b847bc1243b5267d8a37a2680fa9fa994dfe900f8fa5934424c4f63fc8bd10f352dc8913f4ab7000692d3fc2131cd17eae66e2cd9d71bd6e222b1aab7b4f05341c3a8c48a63f672528eedb0ec042b83e48f02e1280dbae5bfb060080961e728605290b5818ac102bd4da6762eed13ac461479864490ced557794b3f1ef8a477c76496472ad5079cfd08afa08e960c3cf602e321c4c0b7f1c4c573196ca2af0ff7836c9eb530bfe76ecd1c993a7fdfe39bcd87aedf00d3665c10bfc43f02a0c14c11f7aa90cc551f7070ac6780277bf25bd08a77c3987e24424f62888cf866148d7eebf7ed015c8cf32a4055a3e963e0bafe2cce079899ec38e45f8694f96392bd326d53957e0c9c81dd9dae90d79dfd6e4d4858e8ecd3bcd02fd14c8c0c3fa24b35f35664243e062c847b0e34f68eb0d96398ef49ee69199b3529fcc46fab592993c10ce7604e24c48c14d29d985c15e6c1534f0ea1bdb7464ba544775fa077d9311aeff7713e0dfd70059e29290a5787caaa16a8f7672bdc92575a96d85a49838a589265c54b63e52381ed8f53271a11b6566e704aee2cbbb4ac6b76d459a1f63de6ccbea7fabde8983b8efdd9b3b4e461915a36d62749a71f41b92b0ade23f88327e254a2deff2c429e50a6a54977f081012c19c311fe78c203ae9791fcdb9ab621bf9727804fe3eae4b23f9dd3648b105494a2d2854f5791837e33760b7ff69d3beda3ed386c244b0790c492d4e2b65980a905b8c025989cc50c399a00ad6307b31db4ab6cb9ee88a285f06217f73427f85a4a023a950896b699a7ee7f186785edf9f888a85ac06ff95f8878b402ba9e0a05452dd46eb18a0c0e1c91892531c52f2d34fd5b266464d1ffd50545f383a105fd9a43ab9acd05c38f230142daff92c0c20406966c70486fd6c190c1411628fb44802139401661f2f4c9d17ce6398fdbd07b8bf9bfdf709598bf70bb026e0cb229fd4c1c101536635bed6c677d8fa25883652cce420b2f3a9cefc41a2e077f3525b936f20b40f366d82ede5c52903d392fd73172f592ec0cbccb73cda49fc29ee5730045a772fab7ae3007d87d1d1db0c760dab09af6b6b0d26aa8043dc447a71c5d3b168d761583d927a60e24e80c609f8acde53f5c0e1d18fd3be56d23bd9caad1ec60a6fb68bdf526ddf528ad53cb41c567c8905b3af115c02765bf71864009c7acaaf25b30287c890e34d1a684e36aa9c689d9c15d5f48d60ecaadf044767aa43e884f3fc18bf22feb5e66a68b1935c345df810be7d678350542f949329f30a13f448849bd6eecf8e6b513b7281decb036b2112e3b065fe06983fae59d07b422b061bb2ee672a8c4b989197dfd59148861ae9886df9ad716326325e1b60a57e3b1246e010d181f8688226fb91345bc8d83d816145780e5d0887184f2595e33c9f088df1dcdd9424b767901523633220e82717e5319e550292efbb50201c722b021e1bfc77a73c45d85641ab9ff2e243d6068a8b23a952ccf7daeeb36566d55430e93d56d15b1184e39f524e60cfd1d65b409a3b61dd9dd265dd56fd4eab43b359f24e8ee1a6f03daf46f9dd909182c3e1dff7643c291aba98fb4391e9a33ad735a5360ee78575176d5ec0d5bea560161d63b5837c4741f0d95e39d7edf9a4cda08f633bc25daf89a3671c93dbd444d3ea0db571269e23c1a9e63513c98341beeef598f4f2b191157ad28cd631c13312509151cccc5d45bb1be82ea6d999da37113ddbbaaceac99835f4bd1dfc8bc6a633924b6d77e17720e7066300c9b1cb34376ba89fedb4ab2e4921ff1e76403dfca8fa4c26643e695c55b3277c7f9e9308194ee9be24ea7357c508b375740ca0172bf76dfdeca368e5c70091bc210058879c930c3b52c3d42e78ddeb33ed4419316d3e3c0dbc8b30c5ab92401c5f3b105d1c31fbbe346dd8aec72c286de7db5ac450da5dd85eb4f639dc516153d179a5e1f95329bfd6b499a0cfb217810b30cd6d07c229c52b538faab67ba5d8d050548d81d70356d5866aec3ee276ea1d9f23921a6713c5cb180d633f1d81b951bb803ba72332367b523dd29d391a03ec9b889a20992baa94047ade166bf41f358f71d3f0539cd41fd9ea005a8c21a22e7113d468e15b75b89533b23c8013b475f26bbc5e7f5509ca36bef3fb54cfa54c9e0f027a80cd7ef10417979e758137755581c76be3235b00782bf4b15864def40ca4040852a447b91d452a8a084991b2797782a96cc2a622baeffd3a327e1f6ab97678eec8feae994669f5c99fef985b45bcf9029d17f09ab4e03ffa6fb354be30e98d43a468c498d239652622d2c2c1d75f493b3a3b2d9717663f81ab15f4280b0e441aa2d2d151c7c0d87efc503a2aeda634acb22338282b9efe9f31c847688839651aab0aa00b3968ffacc0e2741155bcb2dd20e9e2ab984853f7788e4e5d245b66ffea4b0b392b04b0a472837bc6fc2260f4f8422dbe1c7d4cd462986a16c4429bbbe9d842adcea0183cdecdcbeb6a009fcbf1151b6aa8269b7ac25c1fc6395665833cd10220148699a24d08492b98df8e2e02a7c2ef74621885e731f489ef7f5bd4a305e732b9c563357f8e1ca6eb3d1653ff4ab843f87814494690b38f39bafe54aeb6f2bd57c7b28dcb95612fcd9ff4352e34fec5bfd5019f61f9aee62be4d539cded9e3d602cce215f24ec38b1b582aeab2a9884f7aa9309e69938a833f2cf5db4cf50645f4abb0ca9ab8aa42752ef7827a12c01de4382ba73e035c9d397f22497adc6d71a2b2daec7683eccc9bb4265e8291fdfa2640745bcc9e4d18649b9e10aa52d3d4c1c774c114cb0d8357b6309ae252a5893e37f0d699ed0ee07572f1b5483344c145bb8f4ccb167bf1db0a078b70ce688953b7f782222cb9248fed114455841eec1a8ef58e1eea9aa6c944eae14ab806bf9a80dab68aa33a0b9585c1d16000b945f2a3cd27ac2ff2373641e54a0ce9ef23033f31070e537395bee4d22c191b90d29f04e151f49cdef205641198d62e19177c44032af945ef7d8358ed0da0027659748f48f11004991a291bf860d90d7e8190aa3eac2ff8f10bf0ac554829351a802217a370ecf99fd333320adce15a65517cd9f56564a77b3b8e416a7ebedb99a60a77609b3e36a0b373f66307f19a305c70f54570f7439a6c0861437e8eab786cbe6171d61f3647d4671f6a8a8794a6b1b88fc2c7b63645a8b65a5143c563ed91c66ae0261cc7f6e21fa91acc28d99b3a4754ebf8368ec5f65c6621f4b83482f6605fc2cc74bac166dd0daa251bfb71463dfeb2d39485738e60ec041202828d0905d4e6944f25e17981659ec4958b780ae66cad2f97ccf3e895eb13c262bc832170a7fcedcd9ad513f2eece38f02a26d568ef7e455809fbc7ae2731d9dd362dd6bbdbb3295b5f40b21702c19022d7c36275e86cee61161bf9a746850a54223292a473b6c7f869d42311634e30e1c75256df7fa551171e48bc398c9472f2e83a31b5799667ddcec51781e14b60d19deaf9b96501db1156fffc5a7b5fd664427dab9c3d277084380ddce5a9cdf3190095056b1cb75278ca2c48eff61944b1277ccb76123be750143169a5f2d62dc009b1a6a36a1aa096ab08e2e2170726cb32ca95a887befd8f566eff1ca633ecdeca9439a573a9dd4daa6093c756e61cf58c921372339714a78accf31024dc7da5d205dd2668d73986be3bf35f6d5c0c42a675106caf03fbefa95886b0fefef14006aee4283c0b47c9536b7f8fe6ce2319592b28b659cf256ea2c67c1a9e0d85a20b31c5f932728134618eeb1bc6d8ee15b6dab99aeb213ef6c2f19cff7944006282181e5e6a33808e3775c6304ddb795ff9848ca5665d3426ea91b2ffa2191b3c9ed9382917b2139a05d8002b908cd22b229762d68bf45f4d8554555a417135c28fe69f6170fc39f9f3a1cc3314ebdce41fa48e5fa5810665164af9962f922ad8e8dae50fb7b18289aa7107e5db1aaa43c0dc1be7a0a1f3a30aa1491b9e862db765557b513728ba50e138dfe940dc2e08916a1605c21908fb2430ff60fea7dea9806268aec31a7b6095e3cd0174aa7fb3d059ff37a6ebe09deaec859641cc68a1d4eeacb5d17cfb81c3902be8ff46e42b07d74be4cdc929161f4024e7c72b49a5adfab9acf086b2dfec8c6851983b872cc113ac14b50615090d298453578efa2fe286e3cd2d3af290cd8e408ec692b63d63d8e2b143fd1add8b61d7a716c5ef7a591d8c5cc7362b724ed52b77d196f58629f57ebca98d773ef9484daa1cc7354881706b2ce73ce5edb443754db609001f46aad56eb1a35707ef251d5c2007f06a8db4c39d251a06dbdd8edb245ed930d184514eb576d77ebae5eabec4659c0daba9910991a6a56a7e6577eef95059cf7fa0a32885c0df1cc61a42d5d2bd50c94ede2ff92d3ad8fe4663063d65735f73711d10528fa58ca1ab4f3c7da5cc5cb0a7fb20bace3b51870d6558cb7159bd7b7ecf2ca195ea6f61800af4606dbed7cfb10d741292a6dffeee39d08068268db027257a6497c84554297f3825432cf1764d76b0df06917031b29122f529089a36fe2244658138d6a9aad2e32a6f91affe431a1b9214c6b12a36c16096c189bef12455a97f034c95f8a74cfd02cb0faf1878a0da0351cbdce77ec7d84058fed4b3a351a56028c4abd8af87da83d4a3b4ebc55b009c5c5df39584ff20a05bd3278d25c9b919a759bab6bf8d3195660028b82d7b92334f203937872a64256dae3eec6f79be45681e5e76e777b69093dbe29ffd18e60993a3d91cb1804f7a85982089c0ea2816fd2693c271221e4e688b42b626eb4fae3e98949d343716e9d4bccc43876303995bb4800b8d184950a20d5ac274643e44396b0a14207f1db88ddbaae9d14d668443a9186de2d948fa3cf6a7553db2b5a53229cd22bda2b7e4365621f4c5a616851e2029b57b88eedd618ae72857387f26dab76832ea782c1b71b0b1f6ed76307db8db13d286fc709a1dbf226aa1e2b75dc8ac5ad8cc22e265b8d55b2ee7de878a890977cb2f4b370faece6da6ee12f719dec6f1e97c5145e8ee1b0cc00aa55e21fabbe845e0b31a7f4bce95e86b8e02567d29ef629b056c8bfcd2a2a3327ecdcc3a322bbb813aecc554c40389d51e3d66871fba43816f73395d57faecd6e8c484e49726869bfc12ff5522920091cefdcabc9ab6d9ea1f319d67ecd8bb366f03826d5a7f3668ee72f6b0201d48a801cda17bb4568b219a41b105a5848fc5be20d055dc0b0a6ec110e7b58e218fe01f37c8ccc8bd87ba5f9868a016278e0ecc04b0cc60875f9b3b7ba9e4ea81567643c725d7830da5761667ea7da6b05b9fd08a823ed5c806103504045a0d1901040d4af5a83cbaddd3d2f38b4cf96e765dd47ef4bf8a5fe1d96b963354274a82176cdcab44c049a44e04b02924804f00352617a27acebf8cffcf7596490ab03555d68915adae0ddbf6d585224c7e0aa02c45a599dd78769abe9a67a3485013369682927b5a449ba26f42db06b1a4fcdae19e0ace92ade5760e415a6fd395107e65f067e4be925009cc7325f095342fdeeb57dd264868e4b0ce667bf9cefd0af70ac4113d27e189058cccf33b770b2b16550d704df651f38be9fb65bb136ab4821cdb7daf8178eb383762c8bafb594613c813da6aa156834b026ee4cfb723f56c0041c539ac25c6d1c9687c556f07dc6e7912c38396840a6a6da1171fa6925b0a22b60ac80a62caa66a5c9620ff4d70da2e25e02d913fa5d6d79115a671509c4f9395594f65ec8bd982858dd9cdcfa8bdca68f77b4f761edf90ed04b40f61a36cda69282f8ef83c75cd0f1f3151d3568c6469efa65d50c33cd31a4178fdf2ad043fb8cd924dee384ae8eafe4aa570fb02468530558458caf55f60044c8b0b9c394881a67a852e5b162384a23389deab7ee897021e11f5a451bcc4e1fc3e0c9d35d08d612f8f37a90b12a7358690c7a6d86ee4440dcb07487595bc96e0445d3deb29982bd20d52e56c74311f3dd6921dc6e4ce25467b2b6462dcf3d07bf6948e48075f4df4525bd521f895e6d40b28c3eb2713960c5892a763615b7e15eccd71a416d6d1fe2fb78f527530eb37cbfb100804c1e05b3b5dccbf154a212f135c43cff4986b2ccd8426911caaee4d403abfbae688698b89b3e294d8e8c159371cd5ae1a4544813668446aa8efeb48ab5b59e12194eb164fc51477e3786f9d70f3812008324a7abffc52f609a5a67acbd22fdc0e1da820b2eab0f745494c58c20c897d943d30bd55ec0c008379dfdbdb4b6f6be186fa45b83cf4938d360d506d24f870c1d60bde5e95592b532e3aa8f435441bcb7add9fceeca818be3f81d9a8c17c654b4eea394fdfde4d09a8abf875869cf2f893095811430e7df0b2f828ec2b3a22fec7184b1ca4263af176af37b741e440684efd256500da51a0d2b62a553a7720246d1bfc44ab70b6646f0bb5d92dbfc42089dab74410979bfc684699a336b8b5d2ef3e414e65dec9f005dcaa7a346ac0484d69eb798b86b488144f6e8f87b7e561d8a375a7710e7f136e275e6bdb8d33a142dec4729e7536b69dc7e408cbbce5bdfb3182468e2e61e2d36c82ec45f90dd5c74c4010ee5eb511e213e04f77cb30de1a1ea1e0264959f8e4498c503401abc3ecc8d48c796d654d3339f064f94195cdc8a3f25a952db96b4845aa7a18930f01bfc1009e7270b8f24cbd8953075ff1d2f4e9bdbe9163022734b1b85e0eafdbb645d4426bc0500fd5684ba8ca2cdd1cf5584292d4e66741a4dd651153b1c40c64d44a6a01d1d1ceb290989911af96e3417b5fcb3139f905d6e6bb7b5d65acf93944371cc507f796e45ae585c30c94e7d787d860cd41bee31cc539009e4b70553915edd84760bfca1d02f859e2189f45fb55c116b00474a8b6dff7b926a968c10556e33098da19a1b9872c670206fbf12031076973d2197e3957cfd952a1b5c8777662eaf7e7c31b968007ae968e48fba5d8af6e0b5ca7fac56cbd5eff4c40255d0617d851246c1be0d77a6293cf80f4fa96beb43bac2fa8342f7e9577d54f8ccd416880cdfde59b280f15fa5fd355f996f060948a698556d3837e6beb55bb8f1d3ec26c37781c3cbebf5d6568404da983649842da79a43f515f5a1beb546329375bd9fca80fa988ba8f45aa2e154f2ea8768252755527bc5769deec20a250c5252c14502c6bbae44448d9af9b55412de43cff13a378e0e22f27a171839a761430f48d28969da618a94af983e2549f8ac1b371909d25e1bee734f6004d6717b8986fc5336294075a410679284d78c0593046e4fb9de6aa1d6f8e5269d9f0617875a320e95f5cc453a24b88c4aac70426d5829d09d73d5922734a74855c6e371cb220ea305cb47641e7940adc85d8ada7176d1e58d62a2e8579a81a85b1d9673f9acc42df38c90081f29daba4820186d2a5f11253bbd49a5c9a20deffbc930101b43c87a02d142397bffa2deac38842a5e64c756f75c7f1e9d8ae1ba5f08b8eaf2e1ee0d138fe57863ccb4fbd6b933d2c4006a73a7a9eb6df808a4e4398452b7b8d0728fa92c2643be505b301c87a2629cbb1a9155770354f46f1dbf24eea77d73ae1c8adbea35a85077d036a460eba2b98b55cf109f6067c555f42cc4e26fdaa3f4ee354b192734f48abc4e17bdda6141fa754e577a62a4fad6360f82dbc42b2ea63b1187318341a6a87fda0bd030ced931c993846d6e5012dda69ce38e14e3ade2353c5d9d75c53c5584998cde6fd1e8c28f1f0c1824daba878d6dc2b9c0b4f85f6be36953e778d9a6ce0f129d38e7de396564f8cfdfb25514f5445012a8d8232755ebc245708a108cce97e9b52f75f752a3bd1d5ef0121ca5d78b802d795c6cf4cf247e2097b6c0f5467399a4fd0f7ad79aa555ecd5a6f5dd13ed18973f16081539c45fe8dcb0e364138c95d0bc12da2b1972d6476ebd1644734e8135bda969838049b4ac7f5ae073d7ed06f5ddf9c0bc47b98a99744a4d9f7a1a64a0e9bf7bb2abdc32622ff3ba878c72186ac3e669a220e989741609e3174f34f8a0ce834459518dbfd676037ee33d2d1b978cee140f8be25d4a64e7bf083207c4b98911626a38a3652c7d21780c3f89bfc928f6115e63c3b3d87ed23e24c633b853713f028c980ab477c6089e95e27546090270df2be084551498d9ffbf8eb3cb6b5af5470860e07b3497ee95450f91fbf772ced1b32ffb2c821b98ec558b23097e21ad5998d1304a0b7171a5238fb7505ab4ede9f36a3e0d1fa78c241bac1f1ba877df088b423317dec095b98cee32f53952d57aa65d7a6aedc4da6b72f785666d0f63779929d6062eff85482fd53d6092c1cb11b4f7440a5c12b49d5343db093570efa0764783f4c052968c812f81a8c84e93672a0e58981abebb860fcbca568397892177a68d5b2fe97afbd8b328f9dc99625ae3dd8f33f5ceaf58a8494a790e1f1f648b2f381b0a0c7bb73235049e3775b2b3e3dae1268abcc765b0e97603a261207180f1faf5eb9a3ffcffff30f8f7ebff11a6c56d7281a04aa22008d4dc72e12296c2b6330ec9aef3f302ff61e0c698bd53d0a8800f3bf4aaf0ccc9011a34e8a31ddfe59c9eb040fdedd771f1fdde84db97b347aeb16910d2cdc4b76286dfba8aafca4e573271d203bbc193aa7f7fc949cd082300544d9e0c0da7c7301c4ad8704af67ed78030e492319bf57c9a9fca0ad2810394a05d9e191c1e30ad0ec0c1326a261cf71fbbb85bc9612661679f9d11a4ad0c5f7362c7bd1d742726882b5a29fce32ff205f962ac6e0ff7d4c8afd36fb663136d7f828c3ea3c7d2f16e603a0718368644ba59ba9146d2e986e60512af5c565ad37d82071733fa8e60c08e4262177d871b223dad8de2a78bba4d97c58b673561196b3de9351b58ae87016d59efbecfa791d433c0d6b6f0afc7c2b32f927a4c07cac2039457e774ad707ff45212c1f8c5c430cdb6fd96a2b5c842e4b056ee935c4550b758eece9c43c7a8a4089dbaf853041e1e8d06da5c8d52cbdfb5a77503f433c9840ce8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
