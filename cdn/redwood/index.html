<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ee991279660426454603cad0f571b8c9665763b6ba8030ca2cc9d71e87f81096292477930c636fec065f2e967d438b677effd28505d6c3a6ab5cbc9590e00656d1088ac973516cea156c265496ff4aaf627dfca9feccb2b23d493468ca2fea419c0fb85ea357fcd785d2321bd1820af3a96693195853d7f8b0a66ced44f84101b56f5f433885b6c2332db0b249e4107b911a08cbe549a052958352481a844b2421386ca2a5d373dd499f4f665e6ad7f6801df56d140a4882d489a8e39adecf0c2ec9823751ae2ef4c76df9a321766ca93138e7b8099abd47282f1a43e0f752f775df4fe8baf899a9460ad8af790337294e80e96c2d99c65a2a1886f8f64d7b9586e8104f3922d2142cfe9900dd6fce3abe9db2fc307178e4c6da377996e76a1cffdc7dd10298ed68c23633966a65fe494b4ca841492c952562612b71489675c2aeb3ad7c65675309d03867d5810d6309de6ccd28d63e1a671ba74ae4b6d20ad47e1e76619f813386e0ef1e6385b8903ed48321ef1c1fdfa753afb05fef8d8ab49b8da5fb1ecb5abfb828c7b064b9f89f9a16a54ef30954f3293c1533b1e501a1235e3edcd411ffc4b642f4056d87ff9db870c61cb91dac2a812888a9cefd594ae3d406945e27f9e36b7b82732bb9a2385d3cb97e548a3ebc91a24b50fa3f08c54e9556b7d64ec5038357bc6213a8ce532f5659e17e498b1ffb9b874d6908de73e844e314945ee95445eea4e6a077aed0e0fae8e86a2183309f16d0b3cd82b43dcee0f6eb902d85561a0df64642ccb09134fcb80285e5f66a9bf2d3ebc7afe475926eed76fd5e12828cefca02581dc10e98eea9d9d6fef24faaf8a5dc4dcc507a882d66f1f82f38f812cd0262bca31401a6fc049c9a06f4a64f99f3b5e4a6af701e797b3bca99b8e617354ecd4349d735ca501c0cf1a710b0d5fb6e0bf8aa429c7f428408a1b1ba7d1548447d3730ab8bd8e2d287c81481ef26208328225b9191c9faa162379cd7745368c76a376d226d1b4bcd53049c1ddf206a5b2b6c87a2882cede888667601dcb1cc1564609282733a0c64559a2aa9e45955ff7fcc62b2f9e8cfa970af65f5e0cc3d13c6866aa0f2770e7f67bbc2cd62d258e59202198f576ebe51cdae7d34e5afdb5d08f892d3556ee43a96caf78f50f89916d79caf95465ee1256540a5138f7e7be30ddc4a33fe82c4ccbd3a0a3fb6a8b49831d5a1911abeb692ce5782418c557969ea8a294bc29a89da7cf7be4fc420c30f2f430cda2a8f0dda4c855992ed003dbba942ac449c2fd89c421b64d7ccd10c15879724c863c54c660b854e01f076632007b189281b9c2f26131c0be0a5d6d6b63aaf27de38e8874280b9b23c80481f442781bc76b606fe07ac34c0217d7743340b986468d14f4dc88a90c13393dffd211a9135d28bf96fc96fe58b73dd15012676e62604817173f5044eec0a0eaa455410b7736a4c8de778e8e954fc2f1f62615ce12f2363154b62d59a5b55c7dbcbe9d8d790f55c831762810676f091355fabef1de35055778d1c359bcba8edce9101b69b539c990d4bcd307999332ee29fdd23a5787c4bedd48df9ed57b91f145245cb652f2b77bed7bcbe5ad6192a3e115fd6333fa658eb506885bb30ed52142838facc3892c274a4e5f10d2d4a353787a9bdbcfe581bf5352c4c5f5320eb09aa52139013d2233c16c4ea992bfeee4c0fb386ae4b3326f1489619fed64757ebcd4115bfdd1b4f6b163cea030d5e1c5891a9a84ef6758e49c7de71f7a7b1c9c456f0addf37c56dc771b6902a5c93a9379bbe0e0a875602b54f4ab4cae2c5f31981a5431ef233a4e606cfbf1f648c18718f17b0f6d19ee8a6ee425a0393685758f6b297b5351da50b3d20d9d25143a0daf5723232005b18778e0af00bf7b2cbca507a295609e85b2b4b8820f598348de3828886d1b529b4bc03cdebafcdf53a367d03653536d77039f57c2540e1f2c8d940432d5cbac61e6aa7ba0c3a793de4e803e88d3905d8993087ade67721ba555495bf9e17a2ba2901741104d0934075793b22046cbff58ebba82c3ca49482614882fd904e3418fd8f6e8a44f8e8f99a069ea644decef50325133f05e169ea2e1853479d5a7ba150c275dcfee0d772e87d37460cbc798050a7c4cb6a6998c940d8629234bfe9fcb3d749a5753e67191bf29453597b3acd4ff5ee236b5001dc011fa6dbba2e7f4a77773ae489ab72dcd8044bdac55c230a3b5817116a0278a79d22a9895197ad81f3d4e9eb779792a9b58c1e6470959abe9d32fe93f794cafffa9c8246276e87e54904f66074159ec9c5a06a343726ca3942ce94ee2ecd8038eb68609ed9bb1412e20f757f4d4ff43a1c8c82fa40624a4c18f7bfbf179efae470385bc0ab118a9a006f8cecf9952e6f26d82cd1c76f11596e9a9666130927585609b3c5455dd7d0bba41932817a1a82c2b6837a9220cadfac93f4fa7966169e54069975913d266e23fb7426f5db0245dab3190c4ad118e4acbb671410cc788b6ba18c94c276c2bfc12b5e7c801284660f821b0e2be0bfe3a60c7fc171f0aa19689b74ef596628d92be0c08c5296753b7e18370fef1ee49e40481452a092ba22c8b39b413c2de98e8a04986344ded67f353a8f9413db5ffdfcec07e4152765da335ad45d48f3560e1266b5c87de46d3ed8f6881689df5f04481f7e59da28725c20db1e5f490a7e949b1109b290eff09e425c82f61c1c500c3e7c34dd88c0e58eaf10112830976f53b894edacffe25b45fc20351335319af9a5af2f3ded293f2d99416d7f77dba49f7724f282fba1e4ef1f98481ee8b47e35cdaaa3b693563072788333d4138a6ee98c7589aac0f7996b9607f12fadaf23256b418d391c64097d3db96d8f086a41db58fa878cf356ae195d7f70045d83f234ff864410e68eac69a1cee4ec1ff2fc03cd982895d137e0b45749c46401753290a0d67d5ed9fac73b3b12f866fb0dd57a05f3a247732b52fb7e8c630ee7f219a1c3baf43492abe6eb6860ae419504c989374b65e39e15cd0a72d31149a4d0d3f63d546107487a59e23fe25cb69bfed7a69a66996f5151441bd4de6d808921bb1e5618e9d566894cb9aa9647ceea5e082f5dac654f532ced19ef135d3fcac1f7c87feb550478c411b8fa842f9d065d5ce899866533e0e19f2f2e7c52066e04b88583f1db3ce859cb5581232649ba8287b8e6561111652596ae770808fb6bfda02773249aa9fbfb41f633b7e83c87ce0404b25f7bb1a0b505335d0477814f0a0f465a6dc00408469f7b07303f4a429e35abe2e25cfff6cdc74646ab653d3398d5594fd899e54428b58aacf4f4d7c9a3aad66567629ffcdbc807b8c96852959d9322f0f203f6e726e3f5e16873b2860dd126a1a628ec2dbdc2e340da8e966bb4aef0010b95297ef158ebf5464f2eafb9f3484574cfaa15e73735e5ad5725c8aebd7131c65207249a1f6ce1b14c68ca62366d4a517569bca2ff8142b5e00d9dbe5a042ad91c4427a6647743729d39ce304486392e6d8821de853f328e9fa50613db5ebbc22ce2f22e51f4b774833d89d8926deaf7c37f6aa3fec1ce64db189a42ea35f15a8ae7ee65a2c62507da72d7a4b4e7538513034ff67c39b935b5060c7e4c107ab3999e9b9939f53134a73cb60eb11f3ba44dbe7e7fb4f4d4a5acf5a8e924677f290c931179bdedb7a65ff3f76d1d3399786645590d3b8fd75bab2112b693b9db9ff58139f66040e7e91563b1acb36857e50cb7b1b5cad0722e4ffe07f23090d5d080a4d3e916fdf2bb6ac5cca430bf3b59b18621a30c56615c0ed83b78e44666d77d004b357d365690e160dcb9ab9819cb43cbc86780ea87c64241cc6a3f939d9416d2169a476249b9ae63a9464b36f172a47892855d6efe9fe5aad4edba0304bb272f61f740f497f29d6249a9ff4cf3624fcd5242dc90a398c79c6656dcb83b27d6822cabf0fe9b47d92506d27a474a5c105507223db7e8cbb580ffe8f23346dac63f2f88170002fd95c2e24273c26e52f691bb06d3be9bc161c3b51a9a7714a1f0fdde2dff4429011dcab8341b136a0b45095f2fbc387582255802b3fa81548a42358494afa9b90402e6a98757f4d91bc4a631543ae103e520076de1d81725fbd602b8e31d681b0e154c4c29cb058cdd95d0d8a760739b4b739e57264a56731fb8ef6dd27558f78987bcb51c9c7c160301b0024f08e753454f240c085e26e9612edbfe2fbdfa17e0dcc5edf281255ee43483c95c8e9abfb6793495d4c82218285ba4f5568ae41a8dd357f9c51ea7ee978e826bf8453f1b6f4fd34d82b9b7c1eb9ad064088ec4f88ed3dfe9a8615ee8a08932b789c51ce7c3eb6d39e1000d566e95b62228b9a82a9a8c67ed64bff5be3bc15ee71350afb1b76a6520dedc8116be8b0cd52667bc91c5e7d5af02e3755387f6b77f2d1e1373239eff4679ceb82d3e933b1a573fea245ba00df07049a956e16f8bb45d2aace793fe107aa58067428b8d33acc9636ae3d033eb93a464884d7db376daa012165af524ea9fa2a53fc3276963b2b264476efb7f9e51e12ec23dae11f0dea4e3d979bc99a130ac4bed290dc0a57295ce89bd9ddaeca5e5b1f7f62f612b951528509f1b933904b2eec521a0b3bded6d76c3f881f8c3082e65d241befb8a6bfeb5e466e715c7add8154816bd29abe6e054462be17f5cdae373ec64e2d0d4ce9a3cd6bce8bf3902b8f36593d8986f2b4e2809231e2ee01ffee971efd285172931bd90076f39217d26365657cfb4c472cba9e74595c5e5e355f3c5dc038d6b7b5f06c25607f77bb9f7840f3a33862fb92c40ab006a864c99b085a00216a58f1dfa883f4da3a362e9a8769221fb7b283de79eea028c298a9562c0067eade81158c78740a53569f11adfcdc5e695ec14d3ea08fc9596088c2085361af4bd7d188843a69aabce37259d25c0504d13931f932b341f3b5b4477e91d457eb1671ccfc2620703910aa9aef8a3a3dd50820e0bdf3a163c49a8bc61ea32d6bdbedb206238f08a50a7cc702c29ada04392f92994c0ecefbc227a371630188dbbe404181bde295ed5b96e1dc61537e14e7382cf98f8d215d4d98f799cf2c9a316724cd19cd62eee78c0c847c0456509e9cbe1fbb6dd73a0487e735f9aaaedb76effb6918336f4409785091f2a07b6f94da46b9f7ea91fd0f75fb1ba994e3bc468682fe140fe180ce295989e854e3f67408d7f3a3e73f4aa55f8d1807f5f74e4a2e60d2d7d628e5b0c22ab46e72cb6b0550ee2071b4027c6db33961807bed6b7863db849f89b8cc2457b6f080b3459c614b4c988f0173d5dae29ae41b2266640f3d4f144e3dc19ed1afdac1d00c646ad085a66ca98b1b1308a58b4c3e1a8d8143cc3e6924810350489d66ccf6ebaab4c2043d36062c149de9cd986c9aba9e96d1917401a1f09a97eab489c2c5f2abf5e7355e20a3f7b4d0933146311a647c29d84db6704015378cfabd2840e5ff08e6bd7fd73f285f550a5ed834101731b7b2acbff3bb276a009ca498d5cc3f5bca3cded3fafadd5c2fe9ab7108b5273323897fd5bce3c79b852104c80038180a961cff131dd32b273e5d765e90f09e48b4968e127ed4a1f51c19d6905dc794fdd58fe9e7b820240e7e56de69cf47362bf486f15c363e869a42a4a7e76d87aadd7bc8833604c79519dcc8874a3997eb10b2f00975aa7c1bdb00d23e6dc001540fdb64477aa8627b296abf0b60ec6f75d619d23791b31142ccde4691a34012cf6d3039e2dd6e879ec141d353ee7797022a2a6d0d513727f5ab58dd4a5ba3669eab72416dae0e8f83d69e57255dd1568bee46db67d3f45aeae696b2df80c211778b53f858efe74918532c7c485f4e0a0a5e0e7f9822862b59aaca531ce6937233bf7eb05b7e1fa1499152c6a21ebe14cb38d26045256cef4fe92722186480a25e663a2ed90ae817587df05f6c127739fce2126dfa0d175cd69584e51111940eaf38021711a6eb2bd77ee8e9bca05a854927d81309716d1e794270a9a88a3cab7a1a14a1eb06c0007bb0b70e203941e3997a2e87d4ef6d423ab27a37c34d4358cb79dd1cdd39bb485fcdfe18773f108a16e261634d7f8e69fb95928b6cd97b6323847b981c37086ee0814e3dd0d10eae139928618f831292f0683a9720c80345bc72114815f95b45f720e3702d2c049a29ee53c7a4858ad5db1360ba5f244680de1e75a427567bcd508a3a13f2b73f18501fef6c05576b5a7743e82382349dd0f1f2296773e8d95ea00834c6347d603b3d41cf6c183293d51e8c7ae5546cc52d7d33880bca3ad6120896a9d7df77455d8204b4fb3463c12c53b8b869354062514cfb1bce6ce67cb929f88bcee329cba85d3032384c18d79789bc1ca75542cc05c460995c62bae3718d2a93a5138a99beb6e7a58483d157b34078affba0feadd95ade0df244447e79aacb506ca16c5951be9995784d1da36c74e9d165cecdadfb4d9186cbe83d7d350998a16302eb80bb5573ce292ab4dc9a6ee1fae6b85e2af08a3e33596592fa49f9aca6e6f2c13621ca879465c68ed336d0b537f6def7ad6f67be467e784889c1e6afcbc6bbcd760441ab29b0db57da3c904c39d1e905357b9d2864562f39cf48abceb7c7d100285f206715262f5afebda81567bcc13e97039a9a4c943bb6f0b8bbd41db47a208a64f7290ddaae4095bf3b16b6ba185fb148b583eede6dc4280f7b1df5a635f64a89972cd399938296e4d5a8ea0ba846378776b0f94e140eb0b01dd1149cf8b073c3dcdc2c9a1a02d8578bf01c341c8fe52ea4589aabeb5c55046729078ac9007130654a72ba30d73041701e9c366e40e4bfa2cf6a60af22f97ba5c73e3a37e95473f7534db39b6ce1ef5a4986e9dd01e2900697216c09483ec9a903ac8cab89d13ee42be640187673d72a9d70beae0d34a6184be20439d807ad40aec3fc78c73d443cd728e670f4221831aa6791a0696d8a9e1f00ad2958b8217e56a6dbc44624643613692189022710053316302821896610adddf424a5585c4fa0adca16da951d304fc67b4816f576b06abe6bde774cbdb497f5e0665441bbe496f8d8e7621fc66f19deeb46136055dd6c36bf658a92d53fac25292e9d6b1adf792499f3866162c1f45996a9b51bc2c7431aed6aa5b7cab0e42bda261590e26b4bfe839aa34225e774883d912fa03bd956375f9f3047f746ce28fb77af6f87a8eb0b4b005c0de0aaf86a1a4a724afecbe05e052d5b9fed362d5439bbc666d6aa400936ce4cfc2e7587e0a85a7b19e5d0a942004fc4766bbb8bdd9d23f4c1c9a3c8e99bed427b0910ee7e9b715d5268fc812147401a476837387997e23ee8a7625e0a47d44f56e078da6d023ac8aaed81897fce352bbcd6df9c8673b34e2da2db9579632affdb401db14945f2929b7a8058cdc4938d03cd395dadf654adba1c5b5288e85d7b58405f6e52cf29f0422c84a34b167435c643edd55aeea25ff13e68229b9ccd47ea8f50cc3a699a218241a8bd60b76b32cecad389c3a9995050d79bdc97685ae714cbc16beef0bd40f5f1b4f1edc3210d80bb0a035fbd6217a743d287925415b1620263a6bc1cad7b3d97594e680278b4fa4e7dd883096e644a6965df5c593a09bcc30cd60ad87b758833657ac8f9258e8df310c547cb361c9567412d85e321dce1839b76d29a06a8d3d5a651b274fa8cba302f6c9b85abca3f03dc61fbe61919defc3203746cfde7377f9d97a535e47603f0100b93ecf10fb61d73d7f39c4326048820c869cb715a966fcbd66243eb392b2e58c0c9af2dc9d2f0591bd940d960cd11743df91d2793c8aeaada716c6113cfd5a48ee930f0a8f989d7e6097e47e40b35bf3105faa65803dfe5843b4bc850ff22af313b18ecc845954d9ae7eb3ab89fa09258c979ebc12c19eac103307a2e5c99653a230dc23d1e11841f45d305d0aff81d3cd5a37c737a86d06f7861fd55574c8a9726b01b4cbb4a16969fd062c37b7a5d7579238e2fd4d99c16f0ef24a8c83c639465a703ccf554240ab10856e5159f3af5df6c21d8c99d567916f0356325f02b07065b643caa63f0c777a3dee2c624ff97b0bb249f2163af6132bb6a0027550f75955727c8ba10eddaf04667374db7296436b024d2625ff6a1ffdcb4c605c39ceb7699fb5548425ae90edb79274a06a52d4789e590edc5c8d6ab3b605f61afa90d1af92d96d963113d9bd9c4bd8fb3d6ce5cac125ca5b0f749af3e72134e3c751567b1f6b0e79b0da65eec2bc2e09262d2e30a246017e57f4714273dae65c899a2e8f94cc0115b261b6e34b86ee7449bcfe1dac214d85af1288371c782b95bc5f78deb7b4cfe579ea97f35f6452f08726f527f94564d252d9eca3d75864a4e598c55be781eb7a70a7758b6d4f31145c3f866c8509c564956e44d01e3fa1d7a99b0b85d7694ceb65555c4a1fb7ae9078f798dff076befba0917fc71f4ffa82cbbe43d90887f6d1ca72d0f62a49791f47704c21390b63a726ee458e210852c7ca6894534fc1a2fe04e135306e6bfebf8ab4493aff72978966feb399b6416a9079ae8c5a0e8a3e7d4ee428f386195675bf7fdd0d4b49dd5246e27278ad8698e6b5fcdd0da464abaacee93254f9be1dfc6423671d56e067bdc740ce01991900ce0c61d622419694c53bc9903b22c8f085587288f9a9cac359d4ed81fa6a1ef58bbe56af1ff5384da7303e5a8f02e946dbc514b6d96e301ab891fae0827a784d2564b0a60b192130830fefcf1d8b5168898a1dbb442369993fc192d85ea7480527a8fd2d524715da73366974ec58d57aad25d42dfce7b28b3038384378b9201a0cd8a0f18c702f846362ba7c2fad68c3e3510513916fcc2fede2360e7accf9ca52a8f8a823021d72ea10df753e3718caea871c9adfb28fc937c1b83bd4bcd7122755dc37b6fb76ac8c59ce612f568a5c441dd21fa721b4f2d64543d59d566da0a1187bcc1a9e3225309eff28fb8873106056500a3adfbc75a548af8760b92c7bd717c245815657d693221c2b80c724de9803beeba461490ad04672df0dec1cfe6a3e1f67a6e2cf7ab8d2b01fdbc63b6af5ba6766d8a0f43631e1e8e9621b64407057c0814e2f6c4e909fa630e2c89ee31fc83f1a58ba0dd7fc0b870b479f43aeca7a6ee61ac17e94d4e83bd7d5a66a7796d98d0b520bd7d923e8e99aebd1ef61971dba244310974c9f1a4f87a91d1feb04df5974f1b8d464a4f1c632645bed2096c26923d7a86b02c919ca1f6ee7bef3d86edc1b80d4abf5f8ac937d773cdba2d54123d5d6c14d01d31475dd0b6c9340ad8d46047fd90f072c58c61390fa14104fb533b662d1ceea4fde348a432640c9b5c95a7e9c1a695556ddbf23a1c3c135d466feb190071c80ced15b405930cdbeae89219cafc7e16e50d1908b9b96acfec4f18b5c06655e3b389183d17b582379edc68fee0084b405719eceb5a24d20844c09903f16aa96055f12cce3c4546381ad880bf5f13f04577a17431dc479d0e9aec62dd24949ee8ca3010ff7a10aab7756d9b1d4623bc63d8b04bc930698f06df0728f473fffb7cfbc9cf55a6abac2c0dc1d5543a85c7bf4a4148ef4a790f8d25c857aa849a79a4335761f69c4498b4b79a0c7fb73304406f834d8cc07864d6ebb3e8df5dee48e6a3ac65818d1b0a846b870292f5ace3d8dbeeb0fde68d94f8c28c761e2d5bb3e0921b0fd20e319a7041465dbd07795c4b367036fa67c93d6035b819756eb54b5c861ff3d881a6ca80f391d8ca0a666758bde6804c66fdeef85ccd1cf0d27eae7b47a1723350917daab5142f82bce01bb356a29cba060dae4136a4d6b8024b213eb05a6dd27cf74aa91ae36970f483c578c0931e0e1c02a19af42e377ff3285c528e0ad93638a903c6614c522c45515687f03e29f2abbb1f0c5c3d6629116914f54ca2a00c25e6f5a59f9699d0be92b70d7f34ccf1f96d456560e9e6096e8996cc14f451bc42c3de2143fd7421ab0597eff4319a43a39562383bff8d04756019e91bcd180f81b5675e3e05cb437593d38975468eec2335e59b535815a02ea1563430bccf2c774af5dbab57d90730416d2c6ad2a32221cae7f0544874fcab2d94c7326dd439b345cb5c6b116f4ad577f982235d286dce0acc3905f9305cc369c8eb53e7c464ea3053648b30876f6ec5c2c6591a4d31d5b65fb2d02179f774f05f514cc9597c3d9595f1bd2ecac5d763ccf2fdb8c06e4a130c941407bc4402a49b66ca78f254d2b8453beb45d37f0d09aad9ec6433e118e1af5f4ddfe7d987cac17a6214f2899f2b7f9381c50212a614df4b3ec2f99e5bd4b10b78eda0b3508233bf10b02546f44060b2f23b014c5c7b910cf6a54e6b26cecc66b1c7f1eebea1def7664d885e6d1f2f9c213221665332434970560c0025b5479e94b99bd8af286c081c5eacd716a67c25a8e2552b638b805afca7dae9407dcb9b3c04d4017a829dfa8cedcac5cf39eb4e0708bc70b5e94a255ef12535e6e8bc8565a462e43c13cd715f4316364bced7d1b756498ef7806667aca9f96ced3daebac5128eef009ceb95ba057b98e2068948701bd0f02f14d7db3b65ce5df86745ca8195f0531e929a81454ec364e68bbaf2fc6792016c5631ffe9dd726f81af85b28324456c4be8e7325587fa2c1f85d1a90e3a408f650e3732d24e7a83d1bba0a7bcbb7f336ba438ad29377706f7afc781c34c3bbc8a2d4bc12f617a68a448b42d8bc0cbb8d78a3fa6fa6e8ef4d8bba5a9364579610b4d9d6f06dcc06b80c07af06db7d0d8baa9b3bc05f5d1c1ee37ab529d8058f8ad2b5c96a1e3ccb7a88305bfb80df36e3d14bd14de2c50e30f85ff9d6324632bd2fa15832e0a166cdef773a76c915775879a107de681823663f071db2e44959ea7c47cbbf24b986d2f47ac7971f89eca8faa5e3d0b5f8501eb6a19dd410c02bae70b837c9b01edc6517e071b378476c8411bde86254de0e63dbec285d5f0e41ea2734efd0c6597c3c1622ce0a18ab4f02aac3bd010d4bd8283a9d99267cd2654879eeb859bce0f73d2e176f9055edc0f5fbb41fdca669cf0c8d741e17ff13180bc2fc766ac02b644fbbc17d00382b8eec16e3657ad4b0ff0241c7346d8a585c2f19127f80658c7f965710b465ff40e278b9362423e7974994dcee594160cc6957360fda8c6982cf5af4ce5df2b96b74996b936c34be8ce7e4f746b9dbd1cede08c838dc83a7217e5fb5843655be8e9b4e4f270a280944a96777a5d437b7d2d72608d263e5a7bbbb815636b78ddc9a34ecbc361fe7ebf5766919987ec242d115e00e0897c9ebde6f3825a0d13eae3c781430801dcfd29cc8d50c2f76ac69069ba72c8300ba018cbd4335e15364134f15303d7ba4f531705c52a0d07e6a3241fa8e8772dc25141eb972e7bbde31bd94d679580243913a31e68eb5d6c61753d70d1555959a4b59abb00046755e1939327c6df13dea9929035ec41a1ee1d054b307ef6be1f2674b9b5ad74b64138cc004c9d8e626c45ebc9449f2c521fe4080fe6e88dedf4ca228e1ea39f52a13fb25cf157d4cb72d506d612c3445ae8f7b871efa276e04a84a5856ced2332069811479f856d6e6e12c9726a7d2e4de49a1709ff848f6e5627e55c7828fb27237a10282742154ce082bbc25566fb757ef7e84ac9c48f2776152c7210638b2acf3a96a101e8ccf7def0ff39e7e696eba9dff7722eb43847ae11f459c536ca53beff0e1447076a275fc13c2c5d6f3d691d2d8c53ce14ff52a70988e70bf16d5689aff8b8cc183f9f5be59b250c30eb194773a2563348bad37b530a4e04994fd8b4a1985364bc9c899d6f84c810b912f5ebc00c8471069299ef03307ae2c414a5c897b692484b901a5ae42fbc4ad2e53d19aeaa1be00b378ac27c97fe8ceefaf0892492478403aecda7b13922274b948f7093ae56ef8bb6e840de85f564585a7a82d75c7caae11286d8808e850202fa5d638a84409278f4b0d18b8bf7332b2e29e329f3f175c6ffea1037732f3b0b5b5b83b110a56a9ee75550e76fdb5d437345d99970e67bfe305f7603902177c4ecb55b58b744346a7067ae903c49ba9622f0566171782f47198d734bb2fb602e6ee179f51fb029aa4c944aa5a738c43c57841a742f9c111c7c80d93e18852afeb528ce5607f975d8c7aef1a54cfb6a14cbb195b27c6f1524a69fc8888c5021532a138e9976dad48309e0d2e419bde1e36ac7c75bdb8b0f6537661089d9474af4a431492b65709e49dcef55b9bda5d0211439c76fd8d5e5363afb2828cbb12bcaa55e0200eca958c2e7a759457b3ccc9753ddc1779654b66a3bc28da30a2ae58a5e6104ea551e420369acd3c70bcff90b5dd07c1d47d042f4c2d40cd86e0476fca12f7e5f9a45fb6625aeda5e2390f60bf02f48d4f53434d111b430a0c83f7ff2565f76ac1aaaaaad51d2c701269ff1c4c7d98bfc885c776f55f9d2b97814e1c2c8c0959ef49d2e50f65dfad8c65b38b179903aac0e03c310a7fbfbae51141d8f0aabb20bbe5e86e8be2c4582e781eb2ba2a16384aaabcfa5fc047a5d6477ef1b2ed7f1f6203f9fddc0e8ab61d22dc3d08d6fbd90fdfd0cb36326973adf2fdecd30e3bc2c67a78061f9cb01fa37fc48698f396123aa727171d23600c4ee58a3b8f71e096775b2f7fd05e7b8f22c4f5300b9ce4e65e307274c614b770c748d1db1d1018dbc55641897a15bb6672ac2dad6ec51c55692964252a657f141996249e39f75947706176f24532589d152a216f8da169827a652d7d45467dc7d39115a2eacb23e3accc7678f2949a27b5942e7664c94d8c8cfb04121b9120e9d87c24b063be7610bceed50de027f3fa32426d875e1a80dab68a103079b3aeccecbd3dfe5ed184d5bf2d50eb6bc83c0341d51c89aef3ba14c1e986517016904b42e7087c2094765eacc97cc3ff673c46e9fe51726313fa158f0e608cb7757869191e8f4c6ae4e317d9996e7064f37e9c0907bc764761a192db8c76ec0447de7188f6543299e6f2b29f6824072cc9b9d218b445968713f90066a82e2c71000c1ee75352f9e2338b0ce00e9fb21dda4b8c5ef37ace5a010973fb6dee4f6f53130bae73c5b489c7f5db5fab926a619912cc90c3ce16682e31d97a3306cc27d2efc266ca2f94eeaad2ff641796d07199210603b014b5515090b07f2efe3c288b46c80879e50da43f6bbf05b82c05cbe3b4a5d32b8381832fda8015ef2d20ba5eeb7fdf114b6ecf70c8d4228a4602d1aa66c9e1bf433fdf1e67028bcdfb33be3ff2bc695d819ea5bb33833c95bf38be7bc3c322bbc90599403757c298eb5cfebc06483b00453a3afb7a1910369d00dd17418b22f28fc644665db4eaac2b1ba4dadefd34789d35cd8850924a8445131d1c7dd20237800bf891c8b1be7cd39294e6c71a48a934f3779b928d2c3141a0876842c41441c9ee7c1824b81e79416f997e4cecffd2900ec11c7cbf43947be7dd5e41f73dd162073696b9c9cb38bffedf50b85b9d917040fba55625454ba02c0797543789fa38d078ef88f951745fc356926541a4ccad874ded69d16a199b5677cd71824cac7f22d9aedd9a702f53dba775d6b80a23a877a24a8d28e3c3d9907b5eff4028cb44c538270f4949a455ba1fbc7bf23b4f827c583231cef972547d732af293a98838d45883a88a40d1cf4ff8e7f72958122a03cf608b5fd7be87bcee53cfed5cd4f73d6aebbeaa076661b8d2b24e3c644fe2a1ebe09c11e120c746e7a987402470a3af425613d17b940a4bacecf670ad1c459ad13af88555a184f62ecef352b0ce2c0e086d74bd46117b6757d84560cd7c467e4b694a353e947896f75fbff0e7e7c6bb248e5fe97f086652574d620d4e9a2a85fda5aa513974c3e4755571b5ee2816e63c07993898545de1b691d21d4545f862919df57a751f78256c119353eb507ab8588a157e7d68d3d004e2dc9e9b3bb15cd5746adc8d90e7bf4c09221be9bd7fda981734ba9a49feb04ed5101f2bcd127f4edf0a7f5e0656c98dc3ff3d803e7d94fb3ec12fcaef709e131536e6f29e0f300d9932995a316a92488a8837be0d248bf35611914434036ab014b59804b042b31a6e7658b03aac5c2a77484e3c753ffb39ca29951ca506170d95e31dfc0fe92055ce447240718ccf5629f82e56603a90f5a616a62dc359c24e908c0c2396eb533248dcf6185c0660418bdd1d125e387f8542aaa5ac4c772f1d2737207c67f10ffc7011dc03852344c610ae6c46fe3983b875f3f49e203cd6db23f552d90f7dabee02090f8d16cb0253828fad02344c2c6a0fee42782251305b3dabba8390df0cac4f1040af4f1b1421affeb15733de994f08839d9680b3671b660603332108a49a85799621fa311da2658618239cb9b31ea4d573eed393d7c1df3a660adb14eb700e0af320439b97627f459caf13d7c463437b71bd10085257ab8bcc3a9e8228c52bd0829de93d9ccaa3606c2a2a5955cf6e714105ef1f3ff964185810455593c0be95df8e2653211d1708a6c0428c8f33d31573860325446cd7b348b54852623b4976c3760cc53c057b25326f304f75c4e7b49f704b4c1f85c9eabf776f2ddb43a586a44d8417abc36764a821eb77ed84bf93488f1a6fd48707065ec086abb81c7b263a84bdbb9350c22570f96bd8d018c31a32eadcd3febbd403819fb390d0a43d0d805ff8b9768d36ca72a2b5be3865eb6708c9c31f69885bd15c26e47a38ac321be3c41eeb9f791ab73198f197851d5faa7317719cd2b3a676d9293b6ce1a6c644408a900fab795e96e4aa36de6b3e2587d3c45d6eaee3a7098c69904c899666feb44740e1b348476e509ee30f8359f4c6998cf3ff67dbaddaeb3f99f47fb783a28f6a8db0439ead950360649bd5e772690b8c519d7d30e9ea4e5135d76bf84e496221ba89f9f4fb2fac09fe9126f976cdf7a8a9534ec539ac296b3fcd256166080c543a8f2058b4523255ac04b2cb664f08c3ff78c66d8b48670037c95daa95906fe08ba65ca57f8f1ef7a9f5521723fa2e9f0e048fe6802d7590f7d2ef35f91eb1f1a3a4dad657fb84724fa56706e3cff3406db34ebfda430839d489c6180aebb2a9b162a4f5b0c3fbe585147b45a7f04eaa4b2493dc203be1b1bba8c1726ee4b7e4c3612a56ac9b22fd9bf63c6dff76e6e00d439e73783c8aab30f0ff32822206e31fa3bb8528bd7057ee7934d9eb8df28858d6610f218d46918f6961f9aa84a9ca9bb7f41b7d4cff3ba968ad0ad7ec202c66d6c1fa6b55f75287479a76f9c40177f3e35c75a880345472e2315581838914386c6ecd16b92d1ab3004a73847ddb90d9e1d4a285e1fb474dba4e82210c31caf62e6345b9b55cb552d63e04e57b6a82f0eb42e10f1648f01c7a31bcc2bb17c9fe28e7e2dd74141d213cb4881dba0704b803a460cebbf97686a5714780fd8dafb47baf946517e213481fc777e77abbc5c780fb4aa6e01b656aac74e246a831e34be302feeea2decb5b193895790a52c10c2ce79cf2e1004cd4e9cd89840b455d38b1fd7c48cd37270a06e8b89913df10c954cc4f22e5a8695b4a7f8f8520ed676d96c9579a8dbc0a58a7022ba31231692ddc2b77eb67de2d50425d3138f34666bcda78c683f0ccfaaa66754699b426269838af080c582a37b32eec9e7b5e21ba2b7cab227d89fd1f43b13d2ebb42980ae5150286df2ef06b1c35845052e0d681d1bdad811a7738d1c00d421c81c64db339514d4ebfe4c193b478c3c19988b9e155d127a55b6207586a9288aa2a75f725b8ebbbd171b09d4d0bafc9cbb275f4430903fb42f9e0e17bb559b6ef4f32e94212e1082411fae88d6952f9ccad5a6cd9dd4b2a744846289fc229dec18136d534f1373c35719a6b6a3f669aaa1e75cbd1062e6933b9be9d38648ee8cebbf678b4859b88552de7725958a42362b4047f586bcaace880fba616b4c9e34f38c06d1681e49411e593f2dc1751981a87d1ef5d09fffb46380bcd02ef878ef0a6a59c4b610c703412d7235c80d8e2a1547c4e4acf801aafa2b8d077ec5a04e599357a560a95a3e4a24ac02f23ea5b814c07a79ef1e23cfff1e28e16cdc9ce311a5a22328b3780b755bfd1aab6d230bb8106788468e192cc23c5da0099808ecf3bff54f176a687431aefc0d9005f1ea18f994e54ec5184bc4f06714a0542d49cb88c6f44e042b89d0ec6acf95a2cc550d9896bc4abf2c903f3fd6df54313c0393029d8e73ccdc2ee848129f799d4a9716cb504c6bfffd327d8cd579f1297db3c47b45bd2c8ab4efcddcbfcc640ce73df3ee17909bfea3d0a3dffc0118560b18b7fe19a6166371926f98523339d8c7e5d2cf2261a8c35eb13613ea5c7359202711627272ea14ac486aef11ac4b33604c8f823ddae9a57d9300a8de1b28a9190433a4664179afa498f3fa649fe1660031133a3a0497d5aafe659835241fdbbe1256c28135fe04659d3eeb6d64aa894ef75a8efaa7c2ada4b0afae3e5b0c8db3a012d2f65edef7531b6402c11bd2826933f22e82ba53baa2d6aa73e9b606e97ff0d8bf0f03666b93f6915d0a75a3e0bf0cb29a3654e5a2725fde4f287ea1515f0bcf914da5b246e9b45e90ec58778c8621c9d626311466d7e839f7f4c2160d54e63e061685da8f3037ff905e362484ebb1425606bb1aff0a6743fd23c68b015ef6f52f5e1e085a966399e93ac59cab99f183d58bd9b3faa65771cd49aa99571f4dd5ddc96b3b0b245d9f5e192258cd232aeaf92054421ecce8f6ab21f6478ffd1dcabeafd02d9b33a799979ddf5dfeeb10aecbb4511655bbc07148418df13d61e1a4d2f6ebcb9ff33cc7c54902b69a46506fd5282a9b4ddf9da47c5a0d79c196992dd16c9581e053b594024a84b694b4cdb219041176be41e0a30f6080cd6ee0acf3c5854f5941ea0c59cea9ae608f2daa47dcb70f45ffa989f96479d2b9219abf926e7a061d17e39c287c2d478a4ac0b40c8e32b7726a67dd2612321bcbe829291f5b3199c13190f9a710f6eae86c2c4a74fc4c5e2f4986088cb41b98f77f3e572538dca44d02447dbd87d51c409f64a6d179950cab925dfb2dc6ae35ab9fc5de169971e17b87db395424843cf2834ad237099e5d71069d9102bfc3c0ef07e06c28ff53b996b27c08a04e2af0aee3ca638257e19c31b1487d43bc7248430bb4c19e595b63995db570fdf1da5e4330d8b0f28f265c271749bb6983cdf58a914e5bf04771b31b5b5e0a3ddd2ea1c54edbe28c73d952d25f9b5ab78ae04d845a213c54081049cd3a1a0bfd8c5dd4334cc7df03a28d427d5a3ef6b063153e66cca18c7646ab4da74aec47ee89e92e0fbbae7ffaf9353a308824b3edb6370971d600f531e0e1f92c29b5610b418bd63c8bbbb598fe95a4d1db41987f0f764e3cb9ab8b0d2b9567a8bee50d2af3efdf2df6581f95e3bfcb3638498227d21a81b03676f2e680f5a91cd4a97650ecad0e5f5c9a75cc1e1a4949bf63e1f134c20cd50b8f7ed3073cb897a1576f63cfbfd0ba366276c92e4d3028253ffa54e388fc1b7449abe66225ee0e9156e9798cd6d9a7723c39c4d87151974bf0990fe73f5a2becef0fa23e13ef11221f7f53ce3f36d9c2ab4080a37f54352b3867541bd1a5d2829d3f7ac4f7160d19f4b9e2a897643bef5e6e6123ed13d573b1ad49397ab663cdcde8c515f9ef584fd70a4a3b14133c50f393486755fb6beb48e53523570a48c729d3610d5b23e741f390d69ba0973be103fd266377e4153ea22191b24f579ad497f123795451fcb23aff75940ef2d18005ec4a26a6d3b81365be1ebacbf9fb60b9c9f31c1644fdf7db33a92b9aba7c24bfc1ed06ad84a6c735523b0e87f3eeac7af1bd35e337f8d76003e5cbcb3190a117606e94e7d13f849cf9ab4c0ebf5f865528200a1da0abf7951eea9daedc079b8619a8948618122e3f620deb1f5a10a8ed61602f7fc8abae52706fc2b9005cdda7d3c62eae251a0a20f4ce1b23346e25b56b1d4b11a3a48ad37031fd604f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
