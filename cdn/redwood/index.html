<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3dcbb07a2bba3e30997e4b1d9eff5485e55033aaab8026c9dd74c2a80ead3f9f6c6dad3ddc9db137eac071a37c42b870661b7c3cef7fcd021671fe72eb960207bae5c2114b4a9b2fb697dfe128369460e89817b64874157ec3c662ffad5da78d8640db29d1f8166c828bf7f1d0bea0cf6f3710797093f78a311cf8ce6e3d036f90125f67c2e4ce6e3a2560956bb425c9f4fbb6c0683f64e50697b6f91b10f5233299130d875dd28d4aabf53719fe8bd49ae4b8796c73ace310dd9a99811f1d981d158ab71c9b352251eab8f7db17287b02603e2d5231023ae26b4b19ad3cadec8654dc655a960070de5382a2cc374b96bee7c40d271ea103289397dfc7ca0185e5c20abcdba6b898abd8dd0d78ca04ad7291c57d637abd1e680499b158596b8d745e47456461cae4e71ec8cdae04fb1acc6489f91828ebe4bc38808f68c958100ad3a22f810a11db448bc25f926f07c17adb0d2ed1525346e36c8b56e1d2ab074a59eb01dabc2260c3cb3091e563a98e00cfcab9ec109acd0e207d391cdcf6f3fc4dd7f2dbecaa0d123b4baf058daa26aa13106d2dcd6d7fdc6a38757ef02172dbd2da26b0371c5f6cc336c9e4af7bc056f0baf396f1d9a30b01dd067f10d2b16a4bf2103dc528f8255b670e2bcbb99f848e377e6e77e92dd7816118929b1425b7de7bf7854320272f94067f849b13e38a925d12fe2db1d8411741744456da89da824b144da859fcd6b93f19e2c09820310675177002b34d3340b59b4087be0dfe4e46b3531682e11368b82cbe2242c6c90735feb2405e1cbf6f8372668768665cb137148622a458e0a701fcea5beaf45e1303373215bd64ffb99daa871e0cea0b941efe47c797c9e26c8c16e997cebc2d2523c31f1c626eb221850ab897d7d5c592aab35469edee75eca42ed5ccc69b8f4db51c627c29b8ae6d48240cd5373507dfc07ce33396426cb9c2894a10ab4ffdf495679c7c191ad283b83d1ab1689fcc17a2e6bce97ea505b9eb07f09d9922d7673a27b26f9e0889ec42d120111d0b08aa9311ed6a78e8a0ba98e8d56d32dc887c8e60b21a0cd72b3face6763dd3ab906f3848be96fea37165befa5fc45ebfca90a13f5c2b19ce3994fae34ea9c64c215a9e1cd9f546c0b25b142f6c167c703f346acf73e37fceeaf13b53c400e3e07f77323714158ce061d9bede292d671b12a4186db5bc855325adceb800dfc29e79651d48c0ceb86dd2f762636579e8425261e821fb396878d9016c733aca0201df4b0c00bf789967ea95d7222708a564822a487a5d151d2e1b271cebc9d422f47afec2a3fdbe743e054dfe311a37f10a43576ea987eead99c31cca6b465fe4251512e2a451f2e144be861b363ef864c01ebf2080a604ed28c3d306fdf659949b4e89fd18879ad9294d15c625a4825c4ea13d759b1b3ba3f63b3cd329e11821e38c13b988cf622d3ebaa5cd4b778768c94ebaf440bb270de84ef9da2a20dea4b5e6a25d78ec53653f6d878da4f15530266dc63d4f1fc2d8fa1d13d667d0217952fc74662152e68f9a8e6223082c92ed721fe3b1f4349b033ea9c00404fbde8656c66d6915046cf16f25fe8bd3c22d2834a6bb97da4678ac54ec0058661864664853673c1c4554c3227c1e40a72447929c4641181a32caa40cefafddc5aa2c8ae993d5ff312bd253b1afc2a168d0938f43792536f8d81c937a52d22156ca459976abc5906646488897a1cd85659df77498cdf9075785ef70c140365beccb9aeb70a0334a613007630578bb7a5b8665843f5ee95c532a27a1b081be0a8599dadce29515a843abefcf2e7ed6450430b184bcd9edcca475f471de7aa8c5fcb0056730402c003d4e13dd2b4fba8b0845e72847ae056221c42d53e95aa370b306ab538dbc0ca1ee255a6e6eb1fbb20c2f1e2a7329d051214cb3696adea323fd4500861ac1d9f6f9e040a003a9967a3fc481c61d16f4c9e663fd0a669629d183bffaa2885ea24d8e03a1644319ff00418756e0efbc954e01174b075971202d967e2c13782724fef809f0e4af9272facd7183bc8a4792f78855f4e43c6159ec2dc98a173780ec8d15eff8c911283855fbff11d182f2136d3d9ffc8a5a16e0d16b93367045e8e3ca17cd72fe017dfbcf052cfcdc8fe2f673b417867bbc06f0269670819008ed6205cffc1cf2c3700f9d9f62eb5bd14f3d215abb9bb83b53ac53e8a8679396a10dcedfd1cb7ededaa60864f71227adb2b84e64a07287d9e4b1555cf94b21e752c05e137df658d45b146ed516710506e798a4fb3558ba561821b3cbe0acb4fa18c050bbda8f93ea6f03719a70cc276c3a668744a260f6f26e4544065b068e99018c5805ff677d25ebd741b2e7e82d5c1fd45d0f515adeeba6d3222c541366fe29cb1ad18e7a5946c432d38395ae044e45c2c63c957a1408ae26d01066de1e6920cd9f5d5a5dc4d7f294626b6c56df7ed6518531dd886ef17fe28cd2ca46e34327137af4ef5ad86105cb09cf55f5fcefe6fbdb25d9eacf413378304f499f101af73f48ac7b95ccd843756299ba4d7a8acfab02168115465bdc9117499b905f3e1d624e306a8118fad96dee9ecda2f9cf12dd2e50a54508a596038324c64e9fb9141c72e72c1f4be6f2dffad75d25572cbba09c02065b5ba8f4b253ab92b910db890e130925a9a1f52a14d48e8488371d8da192080462ecdd78aa04ca870aca611c8f6ff0aad4e3171491742174f4b23b470f97de0c62d1bb83f696d2fdc70191f94e7b28057dcc1e144e0a591225653451cf445fb0b6640a4df0543722b17367ba769f3fa3abc6fd5aa1b3936cd6323c36568041c9617697b01b57c16b5578ffb56add3aeae705b2d6b0d4e3a1b549dcc5cdaa36ad561c8f8902982f1116fadab35be2d63cf7ae6904e1d3d2b13a2b742e80d3ab4d906b82979e86ce7ec78dc833621de9d4188de442e316fc14cd70c884246a7539abdcf3eb2903f3172b986c5c578c65c36c7b383f29b32aa3de2d082cb09d1d3cc59c2959d9f13d9b26e485825aa3b78a93adf953259402ece2216821d4806cb738b0ad0f4173a301ec0b7c577d94e1e760c7307dd9b2834779d47c9df8013b0e4eeb29850d44b7a4efdf8f41a0fe1161cb160076ecc6dfa60bb8a918272b9a4c1918c73657a159d55d9309b5e2509fe52d8387d068549511ae249cf462a3a4d66cbf08a1558f6e97c6e52d83b02bdee3d6baa8af5c1a1f95d4cbe478d7a9db130339724fd5750da289a323abad9829ef9663db81144bd7ab11fdc0c4e64db167172696e5e2e694cb751212576c8cc68adc220f97cd006ef9063ef37c7f872ca8e21c4330d9516ddb3609e9e009f1e8cbfcbfbae3a288445c583d2524a0491237d16168a255f41d6b5a7f41dc5bdadb1016dfe664718ba31453b8f20ee2f62a7758e73ab587779690b6e42858a833adce67cba90e9859d5c176e7e4ab9a28bb56d277c75b76586a85c91b1c7fa1104fb46d8331b054a7d74da86097506c30a2e17c41262f554dc46b502071fc2be46caee41c36a84004887ce87fa8d61d485e0d78b0e3c09d50539b9e1bc394e7b85a419ad8d126c2fa3f7808d844b164da5c6ea7a36e3ed7fd5e1f99faa0bcc5e23151aa183a15f8e8f456ad72f0cf72cd40c563cfb1fb7010b879f67a0a1a1fd2d21559cd4b4fb6484f78c8811395ca191172bf9d5f9600b8fd51e3f71bca7398c73390ab9cb15bdc0dcc1bd03d4973d959a80a3a3cd6b68bc090ca0df7c7f8d6b4a6c8f3d3f14f6a9e313bd80874b384d374c5779d0a32b971bbe8e88c76f90528ad216dd482d4533c3f4d99290abd093247aa709dd202613668cb10932414fd7ae343c61741a73f601bc3b70b445535d7275b43adfc3ac7e3d121e2535e7dcb57230da7d16dfc3b80c6abfbfe0c407aa1f87248d8afce9c2e943b9a26407aa15c02397652887aee6874ae05fbf5a7aa3606270d0afa06136731bacbe58d1fb92a869a2fc1cb0acb02a22c5cd0ab354eb69dfadfc31d835e33b66582f40514f8d2706b5bef737faf5e596cd0e51fa219dfd0a3c6b3378f65005dbb7e1e60c495478cf92ffed3c1f895406e8cf9aae99c840955290e0751a06e7207cfef99a8b747a945b4b20f8c2c775f11b4b3fa782ff94ded00a55c4bc849791aaf7460a0d2aa83f03d3a415f715b90a36f3b0c79a821345a5ec869e143b6540d65f59c2dcd15067f85507c9bf7734b0318504122fbb3be2dcbb646a39e89ca82eebca8ada4358e04c71d588a13cebe73575c897025f2f8ad8fb3528313dc05e5e32e798694d448c455940aab95fc2359e1834d69677b1e6a0d5d40ced00f9296873295f9687dfd8bc5ddf041859772ad4342d596195c17ee4e423e3a7af0f6ccf552ccedf68645ff6789e51b920ad94a48ba2a1d52bdf2d3f58a0ad9e1400da1f3e1640ce89b6d8db1bd9ade3d5bce0553f3e237bf4c3fd7bd8a2a6ae101a7e883b0f6fe0492f3bcf2f892d63b898c3e16bcf058397f5827c900ef921b5c65f03ccc8715fc8f12f12b9cbbfbe19ae658dd0de30761362ea567fca5e4c4cd344b88f846dfa6fb8a238d4035df6f64845e15e4837a046f57b3935e87dd7b22bbe21e2a4559d8629882b8cd2fbec0b6cfc8f4e3dfcf0d369ed9468a64411f6c86653c537061833766f48e0ac7fe7e73928c27518c7854bc929146a5edd3ed8183b73ea93f13dda30910b2b42fcfd0943959ee399424be80b0a7dcca6591f03ce5b98ecfa7d3ace053cc6fc7cda031dfbfa6e63fd64a867404af2bf5b7a761ae9b08b22c5cae645a66bf4c1d1e45503920d4bb82bbff1902279f0891683d417fd9900bbe4c9caedc5322bc185e7b1f9210356f3aa4f3aa2e9aa83c70e9a43ef416a57ddba4b4075e4259e65b85eba9a74bf8809f931ff7dde7990d2d3fbcad7264ae7bc06dc5e7dd80687d98e41683cc5dcf7bddf1288ca45e38f09ae57b9241bc72dc4ba5ec7df7d2395f0512d7d226a511b6339ab9ef0354a5839e27048935fe04e9d931df9b61470238fed14d12d839e31c7a8084af951a60285fe645cbf9824be43fa13e93f8ba1541a2ad541bb52f8375f5a3818a5c89e9939c6755e16bf9c3f574df4171780d777fde4ae2d473d3c6a228572c2027ebdca833687d8a7d7c57797eb610a92e40b20a29114f5e6ebd6064436ec10415589f0e88a196c580a72473d330ff16b8e6166795cbefb4ea84242a2d820c0c7b43fe879f86df012637fcb17efeb880fe1e62c1d0be59ab694da7297985e7841ceadaaa0f961060b71a846dd7384215f7d829011306ae825e73a874e367a18711b34e82fc5bacdef0ac49b53bd123f3909f621629cf3404b868d53bce453745f5be309d24ecad0139668fd6c45a928824217a0ca226cb76530341cc91d63c067290767923f35abd5ae1ba37034e6445b464867c234755fba9401583f03a2b9d06870ddabe4f0a3d00150dfe17dab37dc757e5df0d37dbeae7056adfd419cce32be4078c34a0d5fa63a32a599c8477d0e8f2297eb410a1171b24818167d987e1f29be18541db133f933f49acd0c3c586cf5cd2f32aa921e806fce8567c109dfe22ed523eb0aba3307aad000d2583acdf25642eaccef0c9f575ae66cfc3d7df7ba28883900166848cca77b423a7517e28b93ce12e6e481cc401583d2501d4537b391fd8d7b714baa5f2b927dd2c167656fff18231e37cd341f522fa0ec123cdb83693723f5e557af45de704d6591571369c5dd4c45a05e43fd59a1197301fc2ad3b7bd64e381e15b85c7c7e0fb6186bd271185d367945d54193ee01ea8815d130c0c20c38fdef359326dd22bc4c68f6dfab4cf27b6247440f075114784bca9f0cf00eb1638f608839dc29ac923fcc5aea694fcfa6722c1c9374dbfb79b3b1388c9ae1f75ef76b76d18af77b448185a512546cb4e2743c6217f87df99c7aabe8a59a4928ca025f2b1886f0afc90b23efac308dc87baeb38b8e52d92ea9bb05d438206eec552901b4668743cd172b445174ef61311a27ec55b9cca19ef864743422a4ff7f084aefdbace6b185ecbe47391c775c0a012dcd5e1bcdf17e1cfcf1ae6aeece0dece117542f05dfc7c96ec70d351c4e02e25f6acf7be8ecfbaebdb8c618e3a44aed8f8222273b1298140fb67306e8028f82f321c1b718d752578ded74bb89904eb16e4670a026457616946a9b1a343cb692937d8ab43876332fb0e044d595d782054c7b64b6655e628794105ecef5ccc1b5eaa273b04af6f09fdbc7478577abc439653f918f9be27eadc44325a7ee733346db2a371276e60557097626111ecadbdf3a7525764862466e5d0bb87a9614b605ec46dfd6cb9e8f3de6395b98b574fa11ce063d06e33895b1d86f21e6f1e3590ad0cfb493a2108145260a798ed5736cfd76b348329b36b0e61a4b91160c085e840786d895d701305439667de6ea21066c1af20828b7a9b41f87c8d44ecb8301f9c0a80aa434bb5dfe049936a31559e2ec5f71d1c977d97df835f4d0abe11599f8eca6b8a2af7b51ff98bacd31ba9e5af9b56d701e9fa4898229be398c3bdc9dae9d2fcf2a1ee8693b94845a90271bf2d5aa407baac42114b2dc55eaa5a1242b42d50082746800ce6bbda2ae9dc45f6b9f21db33900cc0f354efc78900b2ea034e6e6fbf3d0e577612d2efbc0cf50a520a94f3c79c63f092f3d9e7454fe5e464745f998fbdf563d23d838543c72e9b9ec0e731f57dc3d48ddf631e86e11512811a3223f18a477f01ee671c73cddf0be0ff40c46440228af1347a5aaa7919eb26b0fb3960e392ce5b80cba9523390be965760d8b721771c13f7be29d146351462c3a034a0d84a62f9d8588cdc103d5e3822951fbff40f6fd646cfb13bf37d1591bb40be36cd55380234226bcd1fe88c74707a63d339f4363a3df6d821862d349370854167fed3d4fc533b515483985b58e2e5a54780d9af557ccbcd8872559bf4408989efedad35751a71d3e128e147d98fc423e776656622eb973a13e4d113b03e5927a10e649fb9e86c8bd0f6970780e0febffba3ed44c2b2ec255dd5480c57981e8fa550a2f86edfa6331f1b23ff484478a2eb5122eba146ea3d3d3bc9fd5c78fbbce11fa8b1ff8bdb6940f3086737bcfa200d0d0ca72b622f82f411adb9aedcc45ff857be8cdae76c97e3a664e60c27c4232b6cca3cd051a5c2c1e498e98b87880c3e24b21e95d7a7eebe77a43e22c3eb1de4d08f9047c1347dedd63dd62ad47c4d79fb06f2bf4c2f44ac47c9a71cd47a4c3134bc75dd5e4b9d2848f58a6b41e5cd87874062909d20fe41128c17319fcaac5d9a60dcb30f0ed8767c84b241fe3cefd39b72f071c19b6d23be8351698b54a7645b2597c6b3de106cc0e3ea8b47f62690e00e46ec38ef3c51f51bcb55d5400ccdcd19d1124aea8e3531711e39331d18ab38ce7e50445bf34a38dadad6ad268d4d5f993c7698ba8b49c13a0fa32819695c013e594b7ad9ea944a4898508b2a8b0b53e2cd0855a0a604227594376081eb8567dea594e210cb8fa454b820e624f061d9b4ffb475fe4edd3e3609dd02b2a720a37cb04a8f1bb67ad2dad398248b1eebcd24b14a0b9959add60ca3e354512b87a55863c5297d153002b640bf9ba9264d48509870ba4923c5d7ffe8a23ac940e90120b91fbe476341aef92e447ebcbc458a9fded858b1c8440c850968cdfceb9471ed3e6913e1a848aba59e649e97c4b3a49d6f29d0097b93fb0b67e8d25cbde20ac6849110ffc5e04edf88fc5f936d9aab67b933edc086205a25c753f2382ac890b2dc4ab7b7187cd7153bb35c23aaf4ff91cbdcf48c090b5fb038a94f4728d2d35127c1c575049944d604eb3d57f27821645542965d0157ca7d64d67442e9b1633ee2d1b8344c3ad3e60720a52a426c5bac51e252767d03a206bc3815483c87985b2a96e3739318a01e5cc85648e2c17ddeb7d2ec0eb07d0b0736870a900a385068ee355119fa830a5268cbb56c4209c0ee1e10c39abe672a032e4f31f0f6bbdb4f485a4814cecba8c0c9848d7db795e5ed6dea7e76790dd9776895904d364fad62c14c7afc7b27ecd94b33faf7317a9dc53247fc1af4285dc10c28508e6d66f8b97a493e6b92e29ddb6eb7379d69b2a4559046d045c02172a215d489c328d177a76e507e39d60053d4564b1abc66034b4c8ad89e98ba553238d103c4f0f75e4ea2c80386bb7fd69b55ac20c073442c1acbae67ecd1676ac476a7ece99b2c9553c1f8badaa716f0f1e044b8648d1b12533aa6c75c75b74e0323a7b05722a2e32e46c22221d6624905b9fcc308915cc490fdd5b8192b0eba7c87a99f286fb7c466c2c4a72edf63db808e58f7afc185a228f99622e8f26180967b2a0f50660cddc065a1ae00aaec027de5ddd14882621fe4a11943afe51ac5d591f44517be634fad5e6b7eb593df49ecd4db6a8f29236b892d55d4931d825cd1f38ded4445bf2066d5c6faf2ae4d28ef48a92027ba22196e0c0c418238298d9956afc0e6c4d12a93adcaa79f2970d706a9b238545dbd051daedf7081fdd7e97072d49ed141146d32066c4865c7c856e58c701938c6ae3e85c0626b2a8bb99ff23a8787fbebffe238a23544ae5762cad3d03a74192be22f96fddcc34fdf8d3ae4ee601c0cd1a524362bcbe85e4f2ad2497ad80c3b10d4822311ee5319f1f199d8db4770ee8745517176e7e14ce3cd41e4319549a7cf8c0ddf730b7c026c2f002a3e3cbc49d55aca447b7fb445f47a248351fd1d091fa0b3a9c6f17fc0a28bd228e2dd16f45dd7cd3159ff5007724608be64c2c32cb1ac55fdc654e9561a0ce3d98c78cd9951fd2027e813276ed5feb2ea61ce4b2e81a7a87bb389869ddde0a8cfb311d5b5811fa3b03a5a89cb61244e59d05ee9a343ec4b1c65095dcaf93e62ceb843f5ea0b18891923ae025b684e09957cf07ed3879a5d00c4dd155e9e37ac5d91cbac75520d5dddc48e79839b898085185786a4c186492e10f447f5b4ee5046784b45bea1a1e265cdfd5bab5fbac01d852c96941d59ee6c7e5049e6592c3d0e164c104f7f122b2b74ef0af499deb4dd30318c6177a237ea0b26a0c0301ccca24c3534ca55d7c732d9e9d7ac1709603982d2fa063a80d1f616b87665f4960c65fcf31848fc526cc1a405497c28f64393b7717da612495f7e966c083a4183040687e12f4ac82217c3fa491017f53a75402bcad68139229d4dabd0ae61b0339ba93de95b749443fa298c6f569e5aa5f4a0ff35846c505dd976e205da0a8727292a0a64daaecf006fb89ea387df5ab8e6da2cac23dbde0aa9c31f00eddb49a611ae2405dba50575ff4ad5fb1a4ca0bc2870bd2b718f612a59a7ba2251877ecc4659f79ebd891ff389769584d38aea407a9b245b46c6c846f135f0edc5ce06f1280cfabd9e14be7b6406673947ec56681c6109412b7b68be700c93ae0d4d3c05daf5000f8b23191a184ca849925250a7bf8ca6576cca106ef1b443c2edbb01f18f232ecfdf78e40ee64c05951a209a74c9823acc0f0a5f9a76c210279c5d7d8f4120152857be2ef30e6e4b7ae83bb641c4a30b1acb137a3a6a5d0d32635d8620c83c607c79fa154b7e4592e266f133d8fcdb80477df67af1ec2e6b7c1dcb54e5c6197b866994d9a047f5fb9d3c64a398a06f834deff61d32b89c2d350ec7d378aae7b990b8548aecb165e2c850e5acdc9ce022b726dc7bd87a3ffcaae4c41ba2f59e6baec2d6790f901a7dbbb62b6ad28e6e7ab7ecd404a641c47672e10cf0cc9d28177c69de780d396dd105c7dd77580d19aefd46358501e7c2d74118a13b62e90f3c39bf5e24d491b79bb8549483a805d76c5d27d472137a79f7eadef07877437633689b89ee68c5c95fce8f42b4d1227ebaaf1fb26bde5d701e481b70e955785f29a156263b63199df157b538fbf32d74aca634a798c7e2f01b3e6c0d083f2b08ce5d28110d66d879ff92c15d7bfa4a6f6252d47206e5a7c348650431fbcad5e4c856d666449bb83fac621e933e5838e3745c054d7d497ac7e2483dc6d812b7d4ee137c45343aabea9a130b039b8178c80ba8fedf50158eb4f903adf02c3f419ec52e7252adb2cc8a990f01284af5697a39ab94de4ba2fe0256aa577b62508ed56765dc20a42393cc82452791ad706ccb28af011a8b16426b17c93b0278d6c61a8a2169e45bb4735d4c2200d6d7132965149f3dfd3ee3efd61d51a33ba29a18a6c5539ec24025bc5199487371927d48a05399acddabaf065322ea0a25ef053934dd4a2a68a51012866b0e62770072ea1a9d6b7e08352d68756d53c0490f0fd2d005f688f3e1fb89bfbcbccff1ab022734d41b2d4ece1108330844fe67e8b6b23aa471be9605f4235357415cede4aba9f0865f8de36741da582b11f98946919741c89237db9afa954c038ad434c6157dd644101900d59d50c8b4ba8df88a1255edc40cea5cd6043192ab315180fcea3739908a6803b2bbf69e7fb9dcf8342e66ba25780f65eb6a35ebd8d985070e0c1022f1176ba7a9d072b6b93eaabee8ab05ef8430e234d4070bd6f7c0a63916a0346d13b680f2445c1cc3a19b317c1045517af55ec29361ad274e6077d8efe32fdd57ace917a69de68a7857767d0b1df9bb321b39666de251614e210d1a0ca671ea6232d12e8039c1c8ba51eb841c60ac3ae0f990dca426640bab6031a22f6d9f99187391e8df73eadcfbe23ff6e8f5e4e56b8cccb28651661c13b649939b81aadab0f8640eb180e59e5194341f4462b4c1672851fc84fbb16b5cf06be1bf49452bb238973084b5ebc18e5479ef18fd0a1e528e67d1aff3943ab4e207e0b828968b1c7efcf917a12bd2f857acb2e200d31036febd5cd46f736b8c117bffeeffc928ca310c7b13a8d58edcf3d19ba10457de095508f0466f84b2525c01f71e904451cddfb618574f2ee3c851e9437a1758f9dbacd4a3c2dc597726702d1a2caaf1387b0558b086b75967ddd17152e039b6689ea443f553c7cad2afde8c2eac2bd1e7b553d80b07bb4114427534119520263586d0263c9a9ca1be823c9490c9fae43bb0829df0ecce8eb4ebf2b5e4573de4cfd2edf631ad175d4049c27ae88a3290f1b8b3852a7a4641c9a567cd8b7f42091859281baffc4b22a2e8c7013aa1ee5271107bb61e0e6e52c92a7f82c2fc62f3e387d8cbb344c2ac067694c59073a855a710b4c151d08e317f8b686ef46b9f17b170680827158ad666b3aaf41d7d5135e871094ff41a29e40faadd4e6e32726df11067992adc380d987942f0b70739915294d7333f9487fd5c7415de3a1a8f16691bb955503deb2d26b0f529990b18efb4681f789baf6d7592d748e2b9d49c96346da9d136614ba00ae5c7740bc375a411cc9a6b3a0abf08f85919fcf598c41dd75e43369bc3877ac2ccf1a38fd02cf95a34f95f65e4a4c431e48116aadf9b14883fa5f192694c5197f523227849f70eda0c458d30cdfbee869a1098adbd367220f08b183332500e42dab360f301fbf002bfacd50ea5792dd46a97f32b2bbfedf5fec6c7279a1a192d6ebac91989bd29f2dbb5a5d63f1148ce243fa03e5c11de43dbbac6397f091ac995ba0f97dbcff5d14573e0392177668fef60f0733989086a7d8d83304416940dfb136500a120a651e60372bd471ed7414f63e4e74dbdcd998a6a461134a19f7fd571ebbded357784a333f1b1c72deea48ab590e28a61e08e3799f473382ee0a7f4d5d97179bd8111866c64147cfbc9b12915856b344def94c7cecd67d640520e18130a9570f72b46f64114bf9fb99c36ed35f9ba2a59631ff022df84588eda5194d56f0d58f912127a0bf325d594d44884fab54f9b896d7df1b6b25b847a114f6cd800d25f699622c028697bd6af34108624c26c9a494340ad23e11a3b9c65d212107312a1d571a39c7c1e0b4a1786e2b206e41f712d77d0effa3a943b7d08a2f218a22c8f36e0032ef022844ba63b09af9780df7e4b10bcf7963c51a209d3d1751854dbed6ae924d4f68a8e86ef23a4c203a70d5a593f6f149a9518a89ad99de9c1a586d607c2105445106fde35240340d1713dd8330240c23947acc33fd2a12ba1f0de0833b4a05cdbdd3d19005cb1964c3409c6201fae56527c37e8a4909e2eb51c0f9fab9da3c84ffc4d9a5cecb9426330c1aa7e75d4781166f881ba13e2ff0c3f0a97d819b87a6eb683b909333fe0593db82bcae00362a40a5216c2ef6ac984585fbaaf40c31cbd49b868b6e9042a958a1a52458d60c2df4350a63596e9dfa4961b0385c611ae14b3a6e27c4b0993f6ed8948170035ce62127c50b2e4164321779d346dca507a64ca62eee37125836246910534076b24dbe2aa2b7947e67b8659d625c24e189468ab5cf744d679702188aa1674c8155bd68f474f936f47f957c392adcec33dd118ef93152dfbd2320417d7a9a2f2be6e727d28e8662b7c15151561f1235b8be665d6c99b2ac0f479be64e6fd0ab0b4d22e1dc265c58dd045cb09bbc5da7c4c3e4ad76763c92390e3fe42cb82789d9ee1eed9d517dcac479d69db85f92fea253e12d28a6143f5de0fb0570ba1c181f232e1a0cd38bd6294ba1fed0d43b278863b92a5c3700603ae7e36eea47eea0f1df3fa1be051e24276cc7fd3d52ca12f9a0a71e4f47b5e18bf9a27257801fa69e23bc804e1cb470761d8ca3f957f86656a3693468c0dd3b1d787e86c8791c7214476f43e13859c3b1ff1a57ab86687531e476aa4e92353b98583e983fd42f29e6cbe951bf38ff53b973232b1d692fd9fb26107437c5fb024eed11d502e5aba1b362e9c04a7b1c1e36546f6498d5f1d29956f7ff6265c935a7ed3d538508bff1b7716e4d5f915eeb2c2b1700db108cc5f4af0bfafcd2ff0c4f885a0b60b7cd22f9a61c3fb73839babde125086c34e7cba2d6a3ac31b1950a4c93bab2e46504eb50f9327c959c7b49f5d525d9435cf1c7f270ed3aa10c14e76c37342c66520d6d960c9f61effebca4a7a802d26e31db3d181fc366771492e329242804c860d1add7d835c76b4b370fc28db58f92d9dd7b2dd3b99ded07ea5758013fb8fad77ee73ed7e83b723bac1e9e4f85bd4a00970a641f34c87929e98693d84331616595c16b7e6032db866984e5368bd95639ea6991f0cf4cdbd95b7f86eda2d7d337cb2b5206787f6569d447e96e97c043df91937b31d3103097a82485904d02dbc9849326feefee81d717b03da50a21b12c096f568a9383a68b25abbf2a75abcafa6a31a9ce55d150458d9bdb2b40bac5a5d7ddb1def7e9d0fe0c9daead71de609413397ea9e1283bd4e995f1a9fe5dac0555b0ebfc03c2d00e8f43b7c3b33fd5310c0cf5e656662d6ba880ab04489dbdb49baf0f7be403d11bad8d1d9d40717d82483c42d8b3ad71bb5bf8f3809320c8228138ff90a0c2d60ec747c8f5c9d2f1e7a1fb1174e085062b33c22cc379e1d64910eb79bc39dc8bd369c7192038aa49862588b4afe9d1a10f894efc6b14352ce557185f0562a7651e216f98e948232d434a75ade7c38d8189f07879d5ee2d224a704609c0ffa280b1544d31c4f347399924ef2cf2dfd063eec106e2975bf07d6e4e53162dedd38cd405a78ed36a4b90320d9bdd25b651a035b88d3aa9d258072e6e29a51b0c57bbb06156dbbea44718ec7a3f2e53fed32c659a27b55d059d44f364c2c4175c2de47268f1062057cbe904c605807d273ffd5d8a136c5951d127335ad93b985a1b60eae646347e0dd3b7f76a01bf512f4a476a6d9ab1ac5b0515967066787a072d106851f42b4887e23faf572aae4242326e1f57fd7d4988eed7c0f75784775a0c11b1566459db8d8433ee6cab9df68d5166188161091d388b98f89ecef41a026501e6319c4be07d7ec2f27233aab9ba4839ea98be3d469dab16525de9b806f6b6e0fcd53893961119d1a03c6efb8e8195bb106889073ef4bcf237b7160ff6b9c249ea2bac87d24e5ea5c2e2779edad32be4c949697ae56c9388a881c37d0352f5e4c96e836909eb1d2136632b34b67f8874998970a981af376299ec38b29b4fa741d5c27117931d92292e11b9f554c5396d968fbbc763473ce720077bb1415973b2c0786904dd2da800880cd24df3cc01d98e5eb7123dac2c483e14fbca0f13567b8bc4c4b88c0177cd62859dda82169ed6e8ba68cdf3c4ae0c16d4ba979973131d0c671ac35d998bfd7e48f4a662286891932cd93ac1c285c1bd119df00bc0c730b53d2b5cf7374d9481012932515d5afb153ea3889a2563adf53e4ad5f8b998fafb10620f36264835a119800e6720155e3542fb1d0cbf0d6662317433f4e1e4c0d0348eb9269ed906b2a660fd393d87be48e219726f88c2f0aac7a58cdfcaa9bda7916e0b7206932fadefe0b8b08bfe0b07a359fed7c96db9bfe26ec1bd12a86d06fe680af7ed410047d98d6957661f2384e94c908ef79105834d7352ee2c9074cf57b8f385c33100cf0e172cc3bd857ed08ec571a4e902e69c0996a7348b5166c9ab13df9ff0f99471ad1ee18dc54ff777ab2e2805261501ae74e831cf7272659467ff4dc154279f47633b22f3f2ece713652fabce1d92884ef73cdd1198281dde65df49b1d44934fc9c1e55fd81741708fd916deb9b3e87dd10954e9c2ab99b86f1030c8fe9cf2b0b90129dfb66b641906b225ad9c3229f41d068867464d04e57705a0c0ee52b649661050bc7b39a47391fa7dca9371ba258d365fcc8e33b4cced8b6fbf2adcdaf3afa253e135ff5cb0820f6df2e4198941d7ad3e5efca34643ca3b600c7f9bd4512ff6e4a171e4b5b464110c41dddc034e8f5cb5c532d2788fe11269404856dd404c9958fdd268d9b48de41afe0e607c38eecf3bcec765bfba70a6dfdcba84303b78c5eb8811aed819dc392293816535b35fe25669a176da00a5d38a19deefd745b4a742abbbd38c6a7d3bbd70d92e9566b83d4f022a6e3eee4f25198b3b04ee2e36ad9c5de6c0c1b36a7d8472daaa0efc1c45ef08cf6decff09bfcf53cbee75dfb41dd2937edff6bcd00cfa3cbe4b5aa720b78293cc7552af61a14187271408ad0fddf72dd16eb884668acdfd0c80771918b1ce6f1959de715d19e2f9f9723f6eb640c397cf500dcd6bb56b5fa9d165e7ea81d66fc1202d57e5698105ae9a0a6e0988e710a8ee5d0a0c532c7115b99a6c47948074c274f0549a33b7e0456e735e92b209f9b1abd20d4b16327a18c514dfa1c94c497d3b4ef37ec95ed4394382ab094b8187638c6a5b3720764a4cf4c7910cfee08ea7d7af601eb47ae9a64a04637da86f49babdf57edc61d6fbd8e03de73e9026d3fa780a0b7496dfb638b94633bd8ab9bd8f3c3dce77e14a7b51e4d4f90d25478dda80b7bbf98987a4bfa97d2061355c857b73ed6250561b49116e8a79c9c316cd7c1acd9b0b91deb3da5c3a269d66577933b270f07eb641508bd005b6899c32ba4b004f02e9ff5284bba4d4235870f8b3253a4172ea1ce0541e012c80aedd1c94f87b33b1386037ba72dd030ac780224e01a6a5f739a42ae0663a365bcf7c4330cd90f736746ddb7b34f90361cfec266f16c977eb688da5d289568e28d2c8b58f0cefa1fb1ab40c6f243a45c6509c3a15720cbd3b1b1cd301fd721ca15241cbeb5c9af3ada2beda6847c856be1fad79b699483e67d2c2e42a01630abadbc3507f1846c7279af9a0b3fb411ab881221ad1a0353295eb3270bb9c3ff405721f2536fb6071efe3be3f0ba497f67ddaa58233c6400e69b59959f2081f853549479e15bcf1ee6a918f0aeeab933719a935446838239b98a0d4389b15dd93e3572e691a9325531d31d75defff4521f8e783eeb1b21651432f150f570827eb59c3b22bec384c0819d6790106fa0a25786beffb109832bec49651f992bba3896f6375421956230a927da68bdf0683b3bead75c1fbb0c61b043d4d2e73aa4209060aab1f84f6a143859924ca306985785b404b51425a771dd98fbccd8acef39af3ed326fbd6579c0be3605517f387654c9f84b3e2e78d1dcbbfe9fa02ab46fc005961e7dc6436a05f001334c0064dc5840bddc789247d80f1bdeec9fb95b482da8a84ae23d39e78bb84cb2a7cb2e1ef7d2994aa93941bb10046ff27e3a8b387f7c9f8ff5f5203b5393668fbd3784d8ea6ca50f2592be9540a314135a67e98d74c4bb48ff0ddbfb1dc6cc16577bc91b3fdd71ac6f9e76ffd35a2a686e358a705eb12c03d6c3e3476912499e3249780a5af7b4ed3b58fccb415bbb9ff41bfc58043ead3c7c3cbe4d4989a40d2351f12175ae09c6daa1336f27a25f1521c30af03d5166b7fd9d0ef4d03c5b35c84f134dabb863ccc6f39c3641a3a416e448200aba32de0678d534a822df0301af725475259bae1573cd51af591fb3f887e0c97304c25417e5960f2c55911f3d3b5ac6786f87749230a99a455f54b8e8e947f453e2fe6592f1a934efb2ade6399a675233d5b11e8f5616b6fa4e5ed5a1745c0cc66fa5f711a35ee3ff649ae2bfc61b3ab463acca64f2c4c05d3d0a9cdbc308ea6ef26abb8e63863bf855f79e2539b024a39aa90b571ad75fecda520a877cdf0615b43acd3fceafc35b3b8994006adf2c60856d352083ee008787877984e99c24b3c3ec31117bd6c07ca46af69e5f3720ba58b642f45a5ba272146279093c21dc284cb0dc81c729f3ecd46747c4ee9cd8bff61c96d9dc73215ad641458fc93ec2149dcf55e2562b19bb64411228a6b2447cf440206d13c641ca2e7c59ee8ce66ee1e22591726bc48832c4f910fc03ac061045ceeadca24d815778b59764cb4fe63b64a49a26a797ec8f70fd69c624c09f486d9574ad63ede543514a7b4916f4c76d334edd4dbcc2c229a7a7661f93ec8a448166e8681a44d582b603e388486dc775122efa8df0bcaf0338d561ac85e809439b44440b9b34d299d884ea6124fd3d32ba65a6d53ccdb535405203ab268a8a3e519a6ad24a3ff86c3dd5c49a6df988cd9cfa162cbc2fbfbb57b2764612de0329c25dbd1781dba64a28d7ea0f65bc8c6e593c964c1ae337023b8511e1dece5abd485cca232fc9e5a8ddfbe667c6253ac8b95f78a6e07ce662013679a78a235cd58643865abde7ac863eb1e2f9fc323bbb5c3befc81e76e3924a2a7ffa79200f55a54f08f3e23bef4c4273ef90e56b7d828c8c910edd18105a78bf14ed013b2c4bf4cf8c7285bf94f8ae75b4c2ad49512c9306beba14123ce02ad4d175baebb70c66a5c72253bdecffb3ed9f2b7fe5a934066c69cab7895d06402e39e6c32773273ba08f035a1f272e2f3d59e828a78d96d0403afa3b42118b8dab53176dc3d9d3d93c86b550683675b46fc3b6ef5bb80d54d0a38d235a540660b7cda86a6604d43bc4f9878eaadbc948d4f5072da62c7b116f2a643802df16480bdefd4559a7ef3e38cbe6706183db4a4e9972e16c4c02ca10d5698faa205833a3a61a5d430a3527b18c7e42beb837b7a27a6208b187b8a63d7a8bb49ceae090d4bce7ed7027cb81bc7b98c698ffc080ea2e2dab17ddbb057d1fcd87a578d8fe94098f25cba6e97007af0c88a05f11559a66765d898cca93f6787167795275c09319bd825922aa8d6b79098b6bb54981414ce82060108dbaa9d46fbbd40e9f1363c77ec36015c9c4c94270bc85af0aeca81dee306da79241bf23a18126c36d92b7f6a91d5bb963de473c52cefc9fc0631406b3958f459e22f737b279e6a418ad335eac1f32af74af05d58954d92177cfb67f23e8ea7b4a70215536f900d1c578a32837b989848be7ddbf6f178db37ea630e079a39941001d917ca9e46a5b56bed0a806830293c5cfc6681238550174342a0c883e75de088ef8fcf8188863fc357db33b56162a7e1fba9b8f5d3800e97df40133e124d6a1cb7863252949cc45fe3e17aaed9ce348d616ed829f9e61f4ac11137fdb0b1ff90f9f5fbb3b0ddb1c870c4f3483eaede13cf8f22c9ed2727fb98e63a89a0027324d95dfbbab395d090995344f71286686a3fff2c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
