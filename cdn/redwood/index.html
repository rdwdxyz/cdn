<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8bf9e0aa2eacfcffcbe4c33349336bf7f083f5674000b896a082c1072ff4a56ffac6a67e037ae041cc06ffaab5cde52e506c1a6159aa431cbb428b748468edbecb04941c5a588421e3c3f6bea1630b3c98273b7997b68d88ff6bf53bfd7e956a9c1e404ebfeea7a4db5c86fe920cf758006ef050fb323e86c973c9d70411c7608c213df032fa395883e1e8c86dae2ede0da0e3447d514a03901dc397826b0c53a19c07a0ed90ca8d77ff9306d6a3b353ae408c3cd86af0ec558320c454b91c0f7880a655885e83299e1a785deaefe944a5931bbd81f2c51814b23fbc8e900bc6929fb517ca15d117a8a2766fb609a35fc1d137827ae516f6b80efa6c114a2a17e44fcb1e51a2794d8d2aa94dbe36e678a4ba3cfe6b9b6a76ad5077affa95826eacc5784845674507a5ce16a454007a6a577f36bd9ce442e4bcc431dbfed44539af977a8a9bf8e615fc93a2df99fcee5b266f6e95f0af15c1e53c102bc0707c78c31d1f34ee2a569d1f1ef24739957da32fb159f4af802fe415c2f1875a97924c860cd8afab3df103dec0c3b31976652420d2673786ade63db8902684388967d01fa1ab742a80a2323c2ffd1664dee49fe9e8a2416d356b2c4f3a6ab585af97730a9770cfe305445b1c7691b44b839c5644ed704ed0a4ce9f7a55f2b8b3874c6fc37ab9b93c7ddc1395fb1f3646d93703ab4a19443a7c1c09219f217ef0abe7723e6a887a63383f09a581a87391dc07e79eabf4c8e7d4cfa0aa189acf368327bef375bf088ab87a8314d9c3a556663a49c61a2dc793d56de7d76693bba6a554a06dced2ac1b9cfa8164239411b2a711568618994438ccd0db541f5017aa0700398fcd72b866f04a8a873432e89101e3161d8cea90df966f5be8caa92c7e4723dd8b49aa83804ddfcd41d0de6c52fd4f0a8eb93212c9d55586f040f40502d3895d25189e06a904252cf4da804ae59aa77770e1f25dd1b94c80474cecf699186ebd36d56300b27d3569191a80ccd57e3073b62ab99b659af6277242bd2493495b10b4fef7bbbbc8c6ea85eb2e1609644088758568d8c1683aaaff64180a0cb8d2dfe71443464f0801694267d9668eb8dd293053272308dd5fb1dc7f7e51d39c420bbf2d0fd9cf6ae523c096c8c5d1c1e488182b84cfa06e40d044ce8b8249a0cec8cd9d94b8194b17fcf716f73ac0eb5ef48def97855e740b153c24775fe433a3bd435a55263837f99d22a9c756c4288d65af3512f38682a5d390589e14832f90263202df39eaab3deb45b8bee729ef13f96502c9be41076cc09bac039cce3eddcf49b62f26b4d04e039d282bab38719394b0036e0dbe5e14082655e7b78e85a79654e8eff2d673ac14d828b6b271d3e1a5f4f7a26666c97d6f5f13b2f89769d69be67146e3ae3802d6c33ba5b09c04b4a0c6433d1a50e05145f0b7c1535bcda617c1c594ed7b7d63767ebc02d191bb712af47c7ee0198b943333d9b41fd5280b6bf3d9c6216135b94bed3b634757bbb77a21a4926210e19ac45e3b2d4737164384cb2754f933b0292a8dc413020af9d7158a940bd32ce36e739c75693c029f8095989c91705d8f21146c345785c41746927342b5dd150112335f337d3024d89dfccd4374d93864b3f9fdc1c36c6205b4ed6817b49c5b9b84b4f978754cb0c2d33cc74157395debb247606128a8d665c068be9f0d0f2ed21a18ef2d5cb986b629723866839141267124a6df90cbe4733d0b1cff8eba62224bf66a7432ae08aa5bdbf4c8fbb530cbc7d009e450fea40e5f307362cf1397bf8ee7e8949b25c46ed2ef04d46244538a5456229a074843966d362ffac58e7cf22dbeb36b32b1c3eec6e152650aa26007824900b4dc219d594b4a84d2e1a07fe1348d6b9cf4d743fe4c522835dc4b7a5264614199fe9b43e925041f6d1404739775c4b273c1a9fc3c30eef046826bdba5d88cc51e0ee2e508177ffb8c78bc727fcbff10c639d84bce7c5f53fcb5698d7386b129895e47672533890a8ad2c88e02be6de8e0634d3172196991eb1b66959abce94354b724ce7f5738c289f7138bf76bc08d2361f4093cb2d306324f579abcf220240237e309fb9c399e7a00989c922a9d903d0fef6929eb41eb381f8b3c5a3d67dd6d2f4958e803bbe7236e31a33ae62785db04b2907a0add1965cb446404c7df85e8461a527a0893c4145a8833b68545dca658a8c5f278976e848c5e9dc8a213210446cf8f5fe5d3aba5260d02e70d76c4c54945c8ea2f5e9737e2e56b253e85b7a6d32e671ae759279a0d4852f2dbe76a5e502061a35cc1c4c310c6167b252b82dd9072c4c66c4b9d55abcae67e16d37dc387501441c6e19f4a6788bfdb6018ac8f82b2d6162085ac84589126aeb27f19dd002795ecbb8bef36dfc3a634614808d7c9f345efed7530831a96961bfb161d1f525c12dd62a421c6f092364c38c55d2fc6dfada3538ba64e9f9ab8947e6033877dea9ef1733dbb57814abee193c8fa79d0361c6095711399b6315d132c8e68c126e59f6b331faa26e767ae92374eb6f36c56ffa85a7170b08579f88033e03d1737bade298c0896324f597174dfa9d68ae592b8f37d3624561a837d5c64731bdb2a451fd5bcdd3967dd9228597a68bc8f453610056b55f46a8b223f24cde98f9b6b409b1e34e8502ba87a826331199ddfe91c453a806e5a7f5f89362dd4ee35a07b6c7bfc7b2a6b5abe83f14073a7ddf8c4df5c28bf5f99779cf1cb3d9ff74b677943b010a793cf69b2221d15677adf6b1646ed215b314b30d370daa70e2426bc30121336dac7fbf6a2e56c3e3822783f463adfea565112d1002414c92fbf154a28f978f3eade7d414dbab27d9a024c6ffe60f8f7538d24c0fd95a0e28987adaf28c1957f5726e77a06a4c2d34f52a9ef64fc03e564531fba7557e7ae336d6e751ff9d913bb2de7b1507653812f583baa5769c6bc74c686e34fbf40006d74cb9898f08ad3ee809a60b0ac541733743f9b8be1c54f69c5feffa7d935fcd69a404d2fb5f1fb1c80e4c99c5bd9fd18504f0f9fece002c66ce3e964882b15214c90d61255cba8c2ec990c713c1c1e2c4a5b25f74be4fc7b0d068ca6a8eb0132671c743413e3b0f458d673805875683ba39eba7c809554129269d5c0fead06281f75a45fd9aa9f2848a1b9355ecf6d8f0fb01e37552e1982e1fbfbcf311872c14144cf5a02ff7e3cdc739e2ff12da976796d83628b32da61014248290974481f13ad9313e29e589abe352d092a9c9c40a0d6bd61dbbf2e8ca688c1a9a5d0c9b7a80c180c2fe256d4450c620a12f0a55974d1abf0b5d756899f2b561d1463aa81fe3929b8b78c62c29ade577e6b97a833d667abdff5fe60122e485ee81d510fde46814e071095ce18a02ed0dc86d6ef38efc3aafbea1ecf567648b0d53a3370046423ff3b698e51dd85f8454d372be4aa528aad49dd2687e69dbec716b4c1abfb4a377c73119724602e9280317bbdf14bb1860bdd05befb78e80c6f6e7ad232b59a5d31fbac3fd00dbe3f2b9f455ea1d5258efe445f01baedb91c4625b5e4a57d6d4b04c4dcec69b6d6d0c9f9519bff015855e1a37cb416bc4fa48c0d9300495dce6a4e650e50690ca10f02550723999d063336030bc73027b014026d7698087dcda4b237af5aef8580b926a20782cd91f794120089a2576942b046d581bb6293461c9a76d1668eb8984bd829f43e66e84520f3fcc744e06378b8b0fdf39484ffcaa7ad4d489876f2291c7340aea54494d7219104852395a7ee1e27f0c525feb54e5e47a2380984da99d7485a8189a288456c92b64696dfb1265a3dbf325b687fd8db563c79e1c68de306aee19b090749bfc6b454d356e8e2b82e247030719791d577f1494a9ab174c0f5512953880986d71cd4a0ac54418b89fe3e8e0fe77206f591af573feea3b9fa4e6eb856152288c253dce9ef4be4cba82336b9b4df8b5f529e554a7512ea76665d30c400d871f2cdec4a28cb5fe2ca4ffaa53a9f92f1a1c4c617d8067e89d073b9599ffa52c1fd9ffee04f52030932f27cf8abf6af6d7eded04a194fb6b8a2f05ad21328a19b53aa476f127b23e4159de0379161d6d472e3b31c5a8a9e04c239a76292121eedd0f7d83b47abc98589d5fae92478eeb75827c084b0ff27c1d73f2069553856675a8a9bf72e98acc4ba90d3db19bd2a2360f4ac53552bd069538af002048a1c7729db1c19452b2ececf17c791d7832e0b709baa4417a7b529d5c16e4a264ad4922ad08cdf936ae86e14ba95bb4931d40566d7a68d6cc898193de73a838d7eddf5114db873d34baf5e303ce73b63d252e856fe59d0597ccff4dd74ce0afb49a60e3bcd30f5dc569f4f697baee29788fe917cbcecb395e90fd51a4eb81e662ade2c68cee9a748fe32391d6905be19f78e22d1a7ecd40c7f5e3ade6895b198a9180585cf824e97da5059f49c30b162dfc3fc772a389245f4704ed8d675e31f178e70b1f8424ef9cf9bd93bd47ef4c773a1dfab3b95c47539782c7b74dfbebec44b3095664c2b89ee203c131f7224bc01d538151551f5eab1ab266fb824bd8db9eff29f04c970e19907194b0d94ffda53daf232f49ac8cd4f8e1902d2e963706ef9a1d3b849e4281736122363035bdacb33b45f2736085a9486fb70b11ed81cd018f1f731aaddc3a792b9d9a595e6ae9b488912b130fa1594bada7602b24f77d665a6332dcadb02820aac2ad2c684c16a930ee32d3a5449e74d67bb982efb5fd8ff9b89fa318930f12a64dd5ae09f632de1f4ff932e51b16544ea44e74fc938130610e8a84010929b7af864eab113fe63f573444e3ce95ef49994e442656c38713b74c43c858b8a8d63db4ff5649bf66bbb8622404a55406bb316bc2136cc4904d7963bfbdf7a9f44ca7135d52bc1118b0d20c749b7adadff924dbf662a0b8ef678d4dfaf187ce436af0877eb4e833a39bda7360cd4f8dd15b4e2df4d6a5b6ab5767fd213d69a99b180fbe79a42a06e9c94846859798c0e565a1a9a276969cc2664fb73ac79ba482490c9a4f446554d0f1acced0c39e89d181b3f338a92769a97b8815ee1a7738c47784399f5d919c7d30eed95cc3ef880651f1976091bf8d039f7829d635ff0ef3897453b27eb22db5b74979b2d79e6f18198cd3e2397482d9ec0be56c6cfd88371ff4248a7d8ab17f362ce2b48f3b94db59498139c8064954fccc7af76b9b7b503f7bbbdc23ab6986f9f3e44a646522acd2b6a57cc588d90ac52d822ce2b4870e11db3da56fc21cec88816c894e49aa62dded2b91a328830cdb47d233da3644ab0b9eecb2e0febfb4b084dae179b768e23468947158365d3637eab44f46a0c4534063771e6489abfdd081f981f163097c95351dcb070787adf165cba1979116905f5fde6ad3e86e67892d9c4f7ae5f24ac5ae830549be39ab51c5490171d0bf6171f615b28397336d4ecde836d5937b1b2cce313f71fa7cac151429fd572bc84a724113262308dc4a7ebad77156e59140ea684de38f0b4c0f1a903b2da08b50dc7c7400e300828327e0f6fb8b7d6c23f6274dff825db9ec3a14c4d2c0f1d25c707818f6216ae55f09defd99bcf7d1b8e29eef5e4af8b3e9434508bc22075b907abb215d4bba23773abccbb26de196b1b7543a4547dd41779b77b8f763823a3c5f883c89a6c0e07ec7d72686727edc9e6aa149f43f14d19284c74b56da3393a4ce2c849c97a14edf90e033c18e5096822e97e27f491b6a332a8ba35f273d12be7db307082dcd44c17630956b5958cbfc2877c728416eaeb8cec68c2749882ddc6d30ca48a5655e2c0fe95dd36f38bec0b97c8f36e2441ad6a7fa5bfe4917747e559a64b8e3727b83484416aa059d9a3bc93c4b47db78c452bef82726fd4bd8e1f70f74aa1883299ff41aaf05bc9b93357379b43280a6d7890e75af8021b830d9bc7bf9d40cba5eecb3029495ef31bfce43dcc4f33dcb097a5258b89381e591249de01a9b8196f8e4026ca03ad0729ee35f46cf5672f61ff73736a2d28f8777fe6399856cadeed606038ec2a9bfd2d546d80797f05c32a292b69fa0271b63b9488ae91b80916b86ad69153a868882785886994ed35c288172518c0a4864243dddafe70514eed5ba410549e7276aaeaff78cb42149f5080e860dc8272f717fd3b0c7b5461ef89c2f8f95b44a8e2aecc7c015be5386e81eb9daffca887deebd4c28a1401f0fba28f2b4ee9880fb3f264c1d837b8592e2ef10338605442a669c720c24e28c6b7f90e47823d3f53bb5319ffab351c6eebe9b96f5a9ffcfadb1bf8814958200f3ac77e5e4226d00692f5f6497cc9a5aa6f3762aeb60555e419460af890ad794f8d7bc616636cb4cef90c4fa3758e2a7c2bc80a0cc0e814484d9c5025dbc9115cc480f3edaa25b9e6ac4ed4fe9a4733d838f289399a1ba27db768bc7c26d7f114d4e32eef26b62292b1d0751dd338735a072473f4c169985de49db410842cb8735832963bc6d8fc6a62d443b90c7be7813ae30841d9933f1a8f1908b496077adc353dfbe43b7e5de0bcbf09a0ffa0daaab76640838d98cafda3fa133ca6a8ce512839874a28d9bf0f9852c6472d79d4f084ef3afd95c8e5bda514ac705fbd91ab1b87a88841b2cb154e7cbb4cb0f529ba8b49a0db956af0e98f9b24e9325cc15c0fac60e4efa8aaaf49765b0429a2e30b2c9bcafa7f1e4b99340f319b0c07e42ee1e7d937339f37e0ae5872a21c0982a54566304e21cd84692a14250128c5937e9657a01d29c889eb1eb2de573e5589925351061614f37833b04eb6e3e742f992813480771c0191c68e62c32a90b11ab9cfafe3c0aae1929fe8ed4912be3810af32ae019fec15a08c3dab38dfd0218554d3d1a289042102e0ef166a6e15430c8813cccafac87782339a88c6214a03fbeae59eebb766e016959964e9454cd69c6c8bd1bf8f80ac8b4706a6a96a685438ad9deb4aabfc9dee5ba22ad86b3ef2a3f5d09c2947050121f724d31271a4908759ccc813013525997c82a9897214626931f698b502011827827b690af93169bf94d96f7a9aa791d6e1ce79d6c779f0e6f01eb24fc374a316dbd34a42e13c84fd1eb93b1eedb86b8881d490dde0f848be816e8c1a845ebf865e0856cea0f17ca1b18f74814fcd16e05e43435b1b35a2a61c47c89aba24eb40b1e39065b83b5f9a406ac956781f84522444149d483047d116f993fba82dfdd90444dbe3bcd6c4c6f405636723374d15e4aafa6a325bbea01a57ea31ff5f4a3b3b70f9cb5710e6587913b475d607146323d6f5b652b6d65d42adab8e2d02873b11ac7de903d9e5d02306f4b2a162facc4498defe922aba8d9ac88158db551f76d775ead8231780d8474543974cd751c10e28aad14e780a61f67c1e654238ab48eb0cba24e896f474fe9c2c56c7f758131b7b47a7e3e7a4534be26d1e18c13fab3373b946075200dd3480f51423680628252718d75532d55153164e21fb4b2f71d4c3e99dcd22361187689258483dfa9cc5faebfad6c56b20d7c618563f56f28a09ae2b4d3aa54a2de5a2146c5a2bbfc9dfe193b23ec3abe5d2a576b3e328d3aef7ea5440ff98024c5777e5d704b3dc7bc44df0616ce06ff36a5fe57c4b44c5ff2835bcf0f0233028e612a53b7bfdaee7384bc937c9f7fd28ed11b9c840fdd0ef09857a9c3f7ca0fc7fee42d28eaf495fe0f8727b579a6d267a15900c2d33bde844b99428331e4f1cd31688cd883f877123fa4643611a5c877304ec1f5a0e8cf3e6e7c7353af9c2890a9f52996704a860a6e9067396a21bf3f5ff41f11ff2bbd6b86d981cb4e90ab6e7f703416585c1d053988b0fd2a9718dce92bd524673ec7aacb680c176983330eed261518a03fde1330b2d4f0862018fb49bdaca26dc0008e7f91c5013a82f56b6bd8fa3df742de4e0f164fa73eeb70e147fe2a999955f6a38d76b303cb4efbc73eb2c724542cd7f3ddd2fa397cdca798c7123c4914cf4787ca8421e1a933a874d27aa7b595790b60011ba08db782053413e3476d05f7d6fea10be81245e6cf68e540b96d2535a4c35d6d107a0b394e66d2ced84349e8294251248ced6aab6e0a50a5232fc36de988e22360428a7bc644b7bf11654dd4a886977212e22124b9638cc142169dea83280fd56040bb55c135c8c94e8dfb2eee45704e6334bef31ed295f50ea7fe545ecc0da752ef704829c7f701629a943aff7c47b42048ffaf775c9852f29aea5a4fba4586f8cfa38de1ae6748ef7f1e8ce17189dd194e00e3317a82f57fcc5e0cb69e3a26296fd193bc43a1ada13088f468f3e1fe1938a3f11d20dcce7cb8967770a1713995e42e6967526b9ffebc5063f114ae2148c22eeafd62a880ce0d92f325ba75e41df34fe11f5d2d32465714026c895fb1237ecafd52f971e384bb5a760b2e18207fe910626f215296219e4d1b9c81974fa72bdc90527be23e55873767cccf354e5c9104e69b24e34220d2c11a11bd75f9b31a154c932bfc9fd1890060e5505c6a7e40a520a11051070d677212f7e2f85e5873738c9bc33abb2b66ea3f3b3e1a131bbcad88131a44d39cbd5f3b25b7ab34c5fdb90a69c480852d5c980684dd899f789562310641af827c506d7bf72bc06f9c4b6b343a7e84656c1be7ed3c849795760f3b0af27343297ac17cf2dc3c42c2afd28e79f10002572dc2342ad07226ec487c052dbc2eaabb1331f2901afb1ddc653d1a0edd577977e3c4222989cab712100aafb21fb294eb43f5e92ab21b7f1223e4aee33f3841418c4c18e165d586e9e4cff8071a294f0b5455d60d9b7ec4e7315abc7d7fd6677b06b18e305b7115fc4afcee3c4f47ba66a7f387b641eb86822daa319de28e1f14c04426e3efef45875f2740f07bf82b9bc0428c5487a89007337e4c1062a25f73194d9ae064f2099af7125061b470031ad202902a721327da0f899e3c4c0549d59c45f3971cb1c47e45d86612ee83a4dd518b22cb07dac04129b9c4a0def6bc7bb48cc2237f986ac14d5672f1ec9045aa4054c90973daae189be4b31d1cd1f05c5dfac26e4275887036af3f634b98acb258041010ba078240a4ccf451f504cb97f71923b2476a5b8c7d093f9d315bd9f01e05417133f34946c5f6105dad681fa32f8191bbf888661f11bb19b2c7435a2c215d5a665e6785f4b0cf8372b731040f1f36b81e8a78b6165d0d42da11fe508dd846e79315ad9d082ab194e30e79253f9775729e9185a97f8c08bd377b474c48892b52d716315ab553b3033b49dbcbaca470852ade9adf215359ff3b5da24f7a7ed80abd3262a8813e44526415d1eb26f3ebadcd89cdc797b7aa04bb88df0218712aa5c404355c8c35953c77db7932c3375d93e2808f5e5058f492e38f71152e131c985290bfaaf9d9108f186f68af6dce3c3b296b2ee908f0be9dd93792a8c217c10d5dd262f943e91490c53afb04d2d0be79c8395c9eb44ae86be5f7c56de30dd4d8734999554e0e5bfb0c9b00503c366de9acca4bf84382052d3dc4081f0a5a078dd0c248bd8a9c403d0533d7f8c4aae95afca14477b78a272a952b4a2a98c74d3a21ca32b8393f2418e92998b05fd3d8715e0d29ba3cd9f372ec1ef7b22fb6b17ef9373439962489f295705fcfad643e2db9a56b9ab1e6f59fbadc47480380a38e03fc1834ba369a63fb544e4f5e1a4133b6e3cf5e0e137fb7fe4d3304a24cfd319e7e45ec0d67a9bbb6ca94588e00b6a5503fa462475ff195493d6c5183bf8f80d442566f94f0688d974f48a80b939388a75238b85c473c9da46237e39ecc936ad2485bc0094d28b4db873b651bcf29785d268f3a03fd353cfade0fc59242da22347233864e6d8387303ba88856b7882653b14bc7d1ba43fc476ea87e73f400c11bd03cb29909bc88c0aca07cf3ee9dda308a94675e8b9504109db9372265c080e2230cc1e8a589a94057105f49847d14a68bab0ee05504523f32f945b6aa8fd15c70edb0ea650c20e88ac0015f265af9157e64fa004a6cefeb3d86209bf41e4b85dd96f38da1ed996d08c0a1874558fa8695f47bb7e32f446ac72323d88e3cc99dae0810348f823f28f346fdd6fd87120b4cb89e08fb38df0d7061d102022dddec5d59d8392ae02b64901f55f89d229f136d0a974c6b543be6d07a382c7fc0968fbb93d7b818d6cf866c1be4bf4dc43c02a965e652905acc082e102bb7982decb63f3c1dcb21f84793d5de3fa519bd2d3b6bc1a318f45a31aa269f926c8461d910f4f9c9fb85abbf49090011282f9a821a709ad9f732624255fcea7dd23751b1e205065e6c5526d15a29cd527bc762ca26e5dd93a02b227c375bcae8174e256a9af8de70f2e81ac221d6cc66a41b98995f82f4a85d301f057fff9dddb27b16e4b30db83c25b684ba27ce2ec55d0e69a68d3bb90c6af76c64d6faadf7f4340d168465108a8e66f9e97d4b2ee0bf2b88b781a0d72490103b01077a46a18b62f6406beb428bf5111c226c4146a02ffadcbffd6bd725218937c718c75d636c66fb2a365195429e4d3198600ee6fb970646fa6b58468186fff40215e05b56bcf698075c3810917ee692c042c7729e0c047e37caef8c5b25cd3da18ce510db7e3a5b3cdc9c61feb63ab4587503594f0d0d58a1f834828e4f84aa3edca429005b67e3d3c1c55191f4faccc98763606cdc954889b860805ad3811d50cc2b8b6b3293f6e899dee73eb7aecd3f59708f00931d2beb427f80b6985139fcb6dde59a517a8691b20a24a92dfd1a211a5f47a5d56d15b671b9ac208fe763a613e99cf8fc04d6c0314275be01a0aaa8e453f87c69daefe1f67c61d051e517de8ef42b2efd66a943d3918d13abcb1c6f398ef8ae68849a62402bf832dcfe50350443a06df7423f5e5f990c1f0c199ca8494c7997f9c19b4e9f4a71e63a15a1d40b8855e3a0dcc948a947b581573beb0af6b20d61f2d62250eeb81d34684ff41f9574af837bbfad7d17bd0949170fdf07937659283183273eada153025a86393a96d40fff7e87e8205f1fabff29e310c2de367d387a286855ffa23ce5d8dbf10aa7a84ceebbb59f2057be6f36dddf4c5b4b4c93aeb79670bff1d379c2cff84b584a4df68d73e186413cad578f14c9878dd106c59ffbdbae3ed8a1297b13536f6d56fbf86c8f2e3471fb7d2eb68185eb2728d4c62e3a8fc0098561caa274243e4d66f427c0785c0df2f509e5d2884b5a03b0ed3c06417ecdedff1af2ca50e09cc25384f412a5b13037e30cffd67714488c2603b5fb4b5c5cf32fe077129ebdfe4c45c0eda16e55273308001c27ebffb16cd17f5f5928345c3db61556b62d0b86e5bde0739c5ae41379c7348dafb248f1967ed17b42d7aa7d9300b10ba43b56603db3d3e6b4516e6f8e15b866aa27cf7c3a5f26ee2c3b98e7725f53d893cb303fc8fc356fa5585b84d865720b4df597a676c91df5747a8625ab7bc4510d4f97672d83d5580e24e72d3f6c5fb49c85d18fe1a98ee489619b89dc034945c4d3b062848eddf8e20bed6f85fd291200215f4afcbc36a6d880156e74c20f9a6e5a9d264bd4b931d5a93b58bddea1ddfa11a8129dc8b95714ac9998bf639a25254bacdc7dd8fb33ce86a658d1190524ae24cc0dba850ee6fe5b37eee9aec002e1ef30c163f71b37040faa218103a085a12c399cbbf478c3f701175ea2cc94786cf9099cfa0ebe29eecd7ca8c3d31635c90c89e8077d31356ad0d52fd09cd3156ab2043395c1eb61dd0802eb9d7dc8087cfca6879095bb9bf6b1d6f7d819b8a13c9f98757d2ea913843e433a8fb6497580a89c8cebc2e7db4476624ba20d7f14fbcacebbd9e0c41f72ede156a62c3365e53355f0060b5f969ca7f27f03d9146feaed2e7a4070a173e9949e0cdcf72dd754e31e44369c300fe008296c74ca076f53f4463d77bd48bfc74cf6f6d268b6c0b5e5856f1d11a4a130fd2359f09bdb9c58aeb76ccdaa663c2906be4f9e13dc14c82a78c2162cb9a4ec67e007541070acce2666aef28d8c4cb8ffba622ae56514a3bbdc721b38ef33fa659aa6df119e9930d4cff8834391f6a879454473fa9f8a34138ba931002a6969177f13a0ba11be40efb162231212223f360965cf1290ee111bb30782f462f1bbbaca4cf8f2e1c386f6eede43b38ccd542e46737c352d921e8285831e4a02631cd44bb983c2f06cd279c64a5988de0042fd321d9a053b78ac9e5e667aba36e47c28ef92627c98909996194bfd0d3b4c432b4764ad2754804981b7d655d3ee06bf55a36a29e6d72d6242ac6b8639b0a3f43eb7f0c08b3ba1702a3989d7f0d883117c1aa052d559da7a73d317767bae3b48450356ec3372a158a581367d2ef1a8e02369a7b837b77fb0fefb913e02eba75aa20e3cb37f1aacd40b73aecd8c11266302a0e1e77ea0985d363c425680042f763d9e913511c230401114f000b996d2baed9ba003121380056293b725b9c09bcd2e9b4cfe6213321417c452a89555c29ef1abc80e1aaaf4e5f4ba2c997d69693b8e5eed531f075c91b31b5583699ce4021316e85962f61b4ecc5354dc653b3784c29a8ac68dc229bc2123ae3c252af0f502d81c88143ee4080c9fbd0662ea94d199beef219ba2dbf59d97d12ae4dcc0aa307abb50622e2a374ff9aaeb9ce88b27659c0fcd84ff0298bc34d9cf9c37048e7b9f2275e8cbaaaf95266f01371232d2991f8c0efbdc27e9635b866ebb4243d5ff28dd1aa06ff0ba9dc2e4a5cb350f802633f676e599869cc414271c583b356ee8c6f2b19118695622442c675d353dc0ef76a1ed6be7673fbf25a113dc7f5791eb42e5f4e2398347fe1dc20bf9cc9320201643cd7a608c01ef5c299fdc2a568cbf4e2188c30b374a1c214d7d105e4185acd26c37640e926799227df59e86cc4c543a98250744840b4c08f841b0346d9814379536013cacdacdd9900d72700e6fc436a1527a4085381418ee219e96ed67b816283f5036d38c2ba8dc7173649b360da60e55765d7ac7918cda1003709911e534af9d4cc236f935e1fd54d4a120dabf5e8d8017e08333903fc372ae8da7e9c387f9659c341c317268e6ff09084230ee0fa7a497958bc03f7990bf0fcb25216b79f77a1924c991882996a7108152d56ad5b550ad3756cfc77a90c8bde43d2f0a7fd0b80c933b8d9e9a29a3d65a3922ae8923b603d67951a2296b17caf968cc9dbfc3d746adf783696585cec12a3d7699382245b10297f4a6040a6e40148fdb9466b93636f51dfd8586d2b49e4bc956898c3317ae13d53b699d0502ea1e724bf31c1b8cd6da06b0bf54797fd31e2d11825875129669b410170487521f9cf93d75d642240511d7e6124001ec191d403ebc05740ccaeb95046d777885b5f6bb460dd54227c827768cc3efd444f628b74f2fc437313d0b0b286bab6743632d96526d6fc418e7fa6d9a5e360f0b26198a7fbfc3ec27406ef97f9c10bd5365b17e54cb8e2d4cdb439cdb3a9fcba63b6b54a3982b9612f245e4077179638331d933c3ce82c044107bc1dbb75cc58dd7f180a9416480bf36d573259bda9714a86731c65a1cb1eda1c1cb917c62d1849169a28705b118c57cb18dce2ccb0794f00f6c693efe2d86dd29b40563090c11b28e3e53ed801e28235165edec096d6287ab63c04a2e2f3cc0a0952dcf9f0c40b2d4805a8b0bf25ef4b30eef213b0b9aae564ba32d367b9d1e9c766e79ec97305ed7b0803ab51d90e73578a1cff4065a3916682433765eb9f317e9b8cdd7771dd249d861edc8f9e100db51056ef07effe14f5d28b80fd68934206f36c913baa954e043eed7f9faef4cc4e09f527c4350c860b61614317883fbb156cc25623ac82068254177e03db9f5b9413c3997493f78561ba9d4e0dc7e85dd415e334e16cf9ac0b425388879bde715610a183bbff18889834de425b79311c76e724722e5504cae10bbe9f8ef2a26fe1eb83ca105555b2ada64b61d217a592af1a0cba365722f3ba722fa257ff7e642f56eb5ced0faf8519ebba1c29ac366be7013cc7d2ec71d69c3d0a5ff2ccc35ee028fcd49e6baaab7d405cd7aea34a4c54c119d46e92f9756a7f5735a7df0aa3c7253e74ebed0f5413818e51be73d0f2c52842add20dc3e92cfa3cbd419e5ca972da733c3284903ed610d0bf6789b090d5524a9164e0c00fcb2dbe47ce08a7bbe099384a31ebab7d868e79f2e31c24ea1b110d827b51a71a27ac8a767fe4f1f6abc7b1f18923ed409f767a5c85144825fdf882406e6bd459633ac6e9969528b7b47f5cf2f902f29d95afd375c5389df7a4c32f690af1e0af3a19dcdbcf9b44262cf7614e856d2223a823e1c49450e20241a809416fbd19fdbff77545098e2de7da1457b33afac4ec20b2690dd74f3abf698ac2b904bf4d8073cb76d54ab9552c65c7cc9d76188ab38d4de16a96434a02c92a63957b8e16bf381838a1ba419d628bfe85fb78e5e203427088b27800e76211566eadb41a1d23718b415c8fc187c77ab6f15ae57b5724a930fa32fd10a4a2ffc64652b0af153382be25e397b0ce1653fec24d4d893d95ad64d12b7b57af5fd515aada704dfe46646f6b6a5d64485c53aeaa18fe4bc4329b7232bfc14e31ab857fe2e42398f2e7bb782a9f952f363a1089633b79d32cf8e9d05b09751a1304846fcc1da28865b9c086ea74c3bc00753dcab85c070eed872780e9b165ccf0941e1575fe66504a64525e891c49ab19031bb8340179ecc2d4ace85c4ff2b59069883d0758ef12675b92202761dd0f73a6b5f66a7c6a23eab336db90468b88edd9d21c8156da3a7b83906efb8edba21a4e28a5dae2a618e8428c80f1cd53486268e152d43befe6a984c7418431a2dcd8a389f23582e7c531ffc2e25292a06d5f189903bd87904407229fc3180474cbfd23c666eb9b05e45b7d0d2e70fa4bf0880a01e52ec70fe9ad468718840b3a9ec0cc16addf06a8e85eb5afa6f8dc974f7b91499e1ce9c730fc1420738476697f9626f4bc1c3362dbe3708645705f909f7eaad5db5bc57ceea1a656235ac56dc666ff4bad8f520dcd7ce1f0c6586d40aaabb4e1b349ba86cfb902e5bfe6d7dd11233f197e8f08dc07ad11ae49ca09","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
