<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5fed21035682a1c3468e54c6ce3b95523e3a6befbdb732ac6f77b348df2e7c47f5181b769de40c5980e492e24dc3610c059a3c5b2912842e9e8459169fd1e41b66efd95a04ebc45d61ce43351825665859e00f19e3b58051a81490d6dacc475d09cc4286211fbdc93380cb4e0b9b9c6f9ec2ae7c64f92f5ab141e76f5c8b387a145600c9f881921717346d82b864d6b2144fe70e951047e8170f078ecf713eb1262cd983400a319ebb55b5bd35691aa918ea8ca1d036e07e736d148cc44ec096447c0efc63bf778979e43fe478f633377cde52bae9d16ee449b793783da659e241bd51bf426390336bc2a3206c60e1a9486ebe8278754d1930aed537b06dccd06f0359f87d2c0c17ebf86bf5f062a0021a46631ef38e0610f545b0649a44db4c9b78ec17aea2b1203ecf153806fe0ab6323fd442bf0c302b792367cab8c35aae83f1386944e8a5a7cf1348558a63666c57d3210fc353217e2089b1072e0cc9edaa8a86f7befcfd91fc5b8a21bcfa3f89e52fb094eacd6f6a1f0164e96fe8ed81bb00d522f24d056a49f24f41218d3b93e5751ef50af36a1cf66862f466a6fa8b8bee3de30d98128cd647dcfdb0437814d7976a056fdc7a499183f1feb4039ac2cae5b556ce68552fa32c0fe36d36ac908b684b62fa81fe43ecef51b20ac6cc3c2cc6ccfe282d6381badce38e7b60200f27a8cadd1835586d50af8155333f58d24c81b968d382b2604fa6fd9ee9a8d5198ec8bf65a650f7267a0707d848760ade2087ece4ebff7d94ddbe1aa94cecd18ddf0451469a6fe088fb42f5fd250a5a95ad956c27d9f371ab6280dbb91c7d148cfcf30df2f9088c990a87a95dfc2e3f2cad22cc2ce8368e5c889363b90821c9be23abb29d525f505b22143966bb35a2cfd3d484a4ffc9c6a261cd695c7809d2bd228de3947795ec676621a58fb0de5a9a1fde828ad8c40b5a366b1f327a0b6a4a1930b0fbf3fcd02dde7c0eb35bc6c07861147453673366c548e03e4c24e661f2bd0861a481f1929062ce29814e19d4759d48e3d1ac04d5d1fb5c15ed3c5176d74d34b533b64bd19dd6a91a8089a96aadf6c423da2f6b2998648280bb7aaefb3ea591f6084caee78ded676d2e8044a638fede4ec1d155ef49d2bb3cfb03ec8c0474e17439867a5fa6c0365897f06a863118362804c68b0c8a3ddcb69e3c61387ae7cb499091e6b4e41e958fb28daef3b5968c5a8d3a70d29d5f6671aa5cfc50781f45ca34e0e002b5fad2182a26118175a9f8ca50a5f8dc60ab252dfc332a8cbdbef59309933ceb6b6373e877bc796f2ae086df448c8a9d79f9e8cfe6661f63c81cc6b1972cad3f30d0d84b098934db34bceb577afedd7b1f000bf60e2073aba9da52e8b93575ec4c61dcf872d4cffbfbe7c9b805bfd3dd60f9dacb4dfcacaea75ba4ab30fa4b876f1755262f2d47a262043ac9ff3991a0b4a6415eda25976576ad98d1246f70ba34b4c4f3e47e86ffe579afd71d0d379f594812441f0c541b2494a42e50fa46470dd896f72853308cf902f04598dfc85e5bd1e4a69616bee8dd715a59fcb1be710a9c5f97fbfc1298b6621a4eb22a2e5acff576ad5da65d768fa32a1c77dd81220d8680e98da9724b4c3db97749a3aa96027c374d29f2acb77808f8ab405b03edaa14f1f389cc3a010864062b295ef56cad97b91ed1144615c5a08ca0e1215c2c7c6235358894398a00b0d62245728d73cdb9adde41a25562edd6c723a4e9d10077c72c9a389340eafdce34bcd61c8a9dcb4434c5d4e168ceb11aecd299acd71d12757cf319cc8f4db8fc2e1e79f3410c4d7f81d7944ae349352093efbf03687882798ab1567410a121e81a57516b47884ab20bbaf87a5a99ea333f67c7f0ec62f36b24b2a5df17d68576e635570c2eb0b02c86b59dc9d2de96489a3802d4ff079a7dcc833aaaa6098de0832f35958bd35e7c0a978e5ddb12e08b8d568903a45aa6ca1b16715373c50bbee74bd9a7afc03fc16a402508db4d975c498ad2e0194a2902f1ec50ef3973d05f33256a71ed786825b6a5ad1114cffce5259759d33c96755a7034a2c8c0aa28466aae0f2779c6e2444e17f30c572ab9824ace8f52f5bf6ee607f546da46002fb2bcc0d18b35a28f361181866cc3b5c18e3bd57bcab81cdd0d5328758fe5264462ee7e7aeed908b12e2403a51a37afa13eeb6f8c862d488e4b35a70a0f434822c712afb1bc64375c343f21b887c39b0896b742edc2f4f49eafb06c73742572fd58f0afe4a3d9cfa931bb4b0c2d5a5226c7b18d08db1fa41386e52e611f46eab620d75af486813544fb84214026a7ae5d892099bc81a2b3dcd4c1d292fc8e46d70769ef63aed7b6c13f7ce401e6406e1cd417b15b4b41ff6c5e4379341c9319e2428646a24ea9f5dcf11c429d514ca8ffd16e0ec38e2685db34ceecf5bbccc5f55fbb938e9a219160a61ca990dc6e09bf352e003c3c51cae880c8fcb2e153968f70a91ec955c39c41f6b0fa2c1e2a9f1b23c8e58ad61ecd836d6c1d12dadbb23802cf15727329513942eee783f6e03f9ad08e89180bc4f46f2dcbbc05e446ea8862d88df17fbf5f07ecb2f6c2a8c2b0f22818142b655cac6029af2bb51cb459c570928fecf60705df394a6e04177a79a7d7f5c41a536d593e891098334a34728e10e5cb4adce5c4eaa9f2b55e07950c6c402e5085b50b096f0640a0eaadadf4f29f70c48df46cbcc453f925443a98ef1aa860168ee4d772a1f1d2896c403ea494e7468c01de0548ee0ec114b0029d62b13c62f3e7d06e13e81ad14fc48751c72c84f3e1fd02904909b1dc387354620d440631c85d31dbe71ff5c174f560feb930b8bbe01a1d70176cff4a8ace8d77092fc640bd8685f60e81b41246a691ece7bf367888e9047185fad4eb64730daa4d78c086773e82f654d5a06221a1e01c50bd884aebe9427904fb2a521b58fe09054c10b3464e12bbcabfc25f81ceaa331712c609fe472357f56983f466eaddcdf5270c5a150e05a13c45549bc732c8932b30858d0a8e39049c9cd91456ed6e2d926e34bc8e5801d1a002a681bb3a8d1c490fd935f407fd90d0a3d9e045651a6dc074154c472fc3c4b31b41e419513fe5074561f74a204584d69de84aa7cdb71c69878cff704aaa61915c7698d1c26f2bc45ff82ff40f5b2fae6445e6051dcd7de656df3d0e7988dc61fdc4db7b42477f6db869619f861bf30a9655ed64de7e5f4bdb25bedbb2407f0e7b0eea24ec206c770a64263675d776babf969eb6e4107f9ea26e323ed67884b5e83ed9f789e1c0c6f0c53e540221e08ba94e83c93bf007817121bafb3c70990ffc610ac34d8e897e26f07abf2970decffd32ee045f2677a5941411b3a855647793df526591373a171ec845e6d807ffaeffbbb72e712b14a4b6802ea25baf96987f078850d6bf9728d43487611214845321c8d1c828fb195b807f44818799711d7a4ff6c2440446b01c93d413cb3a8ca5063b8b3f53de1653b6cd129f6c8d6486a41376e9be36c2127711a22a1309ed6e03ae65dde78e90fd3af03f60cefb760f4fc2ebf7641b53857b353caf99e20a3a1c159e6a834b111f69850fc65c6948149f0186b81d178ef0fce12f308b6b9581fcaf99e0d4d683ca83170a3c9983b374c3d160b268c24a66804d88478fe32a21f45a0ae3dc23c22c216f08010eca6a2de3669fac2476694b3346b0034a8ecf1c78c5f3e0696ed9aa58eb6f917bad8423758cc973117c6c873bd80fbeeff089d37cdd8df6e865d01ff25b1b5f7757a5257f4e066330367a6e0644f2d3f1b4faef33b0e8fd5daeee12afe511764f71c91ecb3e2d765acaa09db219319777de46505ca07de4ca73eec982a0bf9f3f27b1f1059ae65f674dd1836ecd07c3f1d18087e59027b3cf3af68da392e73ec75ede60c6c945a3a7949c6de948dc8f5e4dc6e69d9b824aa785f9c37ba69891a90cd26a848f21ef4e555b51aa6b3b042273417558e1c6da1b8458f8383fc9cbd2222cdee3616c9d96003183b9235316e657deccf1d55ef6d3a06d4d333283319b84c9c499e472458f486ecd3535d2da46b75c346b8ff1b385ff1839eb685f902d703e3ea5df3f6022aa37846bb53fc83162daf1a9bb57069bfa187c3f94c0ca6798b46d72cf68de51458a256b64698bbff983340de6937e39d0623aa6f960b1341a184367dae2572c80f0c813e060e1841e2b671a4ac352747eb251b7ef35e5081d07b53cfc592871f31cbee5d2783fdd85e5ca53fa22b152536d13b61fa1022183fd53c9e3d624ba660a110a648ce3c098e14bbb2e60375ad099a206a4fb590cac4b3c63c5b1aa85e992206ea38c6eedf155dd96dd0cfd53da9a0be986b0fc7250067ca008dd0991e5a32ba50c7e07c34aabe9188106cb669c164e763158318fdb79bbc42ddb86af38f22d5d0040236e8be61ab50d1fec5059da40e122051d7504a296e5f942a2b4b56876c27e9fc22370ed4b24102e7f239b32e8012b5e9670ad64ac3f8ed4f7cbbb31bf3cca33581305b6594fe910e67a468929154f7dde613c89cf1bad6695ca699eb25a69331e0958ab54892facc327a56903c926f2c66540a85f5130c5030df74544be7fde0945fbddd9aba29e258466bfc9775ceb4de3b48154b0995dd28398c9221ab8ccedcdf167f96d51ef340998cc80f328c7c2aad8fe4b2144dfd13bcab1296ec53dd011f39597e201082b08299eaba8c97ee8203991715f9c041ecf34ccf9af2419170f50f82a4a13132a68354b02e13caddcc7fc66486c493b7ef5c589cc90aff2ca8dd4321be96315dd8bb79522cfdd1a6ef4c7f737c6ac9e7c885211ee7056c4cde5d9b11d013f0e8d3903a7e9354530b68b5f65d33e1a90d58fc3f1ce21336aabd3f9ff83b3d7d5976a83556ef9d26009c55db2901708f3d9eb527d44ad91d865c746b527f521274e96075e5f554f323027e513055087bfc9ce9ac3a30e968ab0e550181d5594dfd631b8bc485bcf3dddc7a28b3b9949be021094628787d02d8e88874968395eba44c9ca3c2458f51b117c016b535180682e3ab08b5dc5c28635be9d578063596fb7e316fb29f23873e748c45f7d36e06b88f1b0abdb5b711ebbdbeae02cf8e771b4c4fdff9f75ddad1ca1e23b5456389e9a270a58d9695f09740e6c074c848e26c0745f842e62cf2536415689bd8ec713ca91de2da79fdb17465a372b8bb5e1f8ecd9463a8838c6046a9317e0914e38825a589911d26e80266d2e15cffbc89440f1b79342ddc45183cbd1db655268a827a5975b1e5175f99a5f9cb4276b88bc83c142da2ba7c65e1ba32172c8425a366f517aee703697146d975f2af7c43995715f55ffffd3f80502a6c8abe28ccfc2766783c5178baef955486e65824687740bb4169f5349dbaea25cfd2ac0da815a720b57035fb93e72b90bc459dd70a19695ded2391305917b30907b00525cea0c30b50e592c3435e325a273bdabf34df8df3f3ac2d843b0e4cdcbd666ef211370b154da4cfaccee28ee344a317fc6a162a668e75aeafb0e2e1298322eb4d379058599651c086ecf2d94c73e97885fb5e0b7af0076f50a3460e1fc788c637f9b9d767eb6251f2453dc2fc7196a6850207cec2d8cefdccc086f95d624b9f0e49c4f30b15591ffa7f87f1daf724b1f7f62dfffad56556ea9c4a92fe0b9f32e1d280400b30d12306120a2333df908327a6c4f2a6c397bef1f201a77420ff4fd368f27f32a0d4daffc34f346260d9a6ce6268250e10252ee67f1100f12c125a4d9624951a99ab74f77506a1f9fa66c9561f9d74dd47010d8dadbfea7850bdb926e6e5db89ea728d46ef0893542347230fbe9cc131bb2f18c8a17464d19c1d3a2d08ebfe2b9f27b18c0241a2fcc94ccf815499990b946f5c75bee4b72fc5473f1b05080ac16ade1a76e864a490cf6a64ac20b5fec8c7a7f0cfd941ea2e3ecd14e39177493ba8d8057c9a973e2898dc794687d6858629ca34186dc952861cac14abec13120c00edd4e7d1e70e5f8febb79b3047ee7511b5b52fc91a8cd2d971a37ed4145eb3258223d76fbed2726158268d8d66a4f47f947228feda984544a317c9bd1b7dc426fb06a850ff9884aeece8ddd1c2e9e365041137725770c0061385af64c3718c7b8ff16daf035ca11fc6382745f211241ac2c4cf6e14f866aba58ea7b3d61c5b66769930379c8ffbe797bce05267dbc8c8b4258a7980bd07099cadc1d59222c1ad9000ad7ad023fc4333c3772b112db2a8e6ee6a4a523f5ebab512a65987ba3c8072529b59eb0bbd1ddecbc2b2a6c3b3605ccc1379a15b19d09a5b08b5e3fed62176f6a3762d3bca1139c1e5b8d11a8134aefef8cc1a4b2a462738b768c7d494344967f577b23974c7df12c7f0dbe0f62fbe15a76ba8cafe36e236bc647334226147d20d672b49c1f75c7f58f3b713e5a88342a9beec4915cb27326a479d5a81c34875232d27a1deb2a23d81a25d5a2f9958a4fff6c569f24ca1da7b4ad8b36deacb5010f977bf0dd05e5f25763b85e849a37a5ce70b62460d257aa8b1d9c1aea3a934ca1cc5f92f5784ffc966ff661c7994b14c3a3b9c058b8ee921c52613b2f3c26362fe64c7f760e53aa2bdb6ecd2b3a7f5cf918666f1a48869d347b4d48334ee9c1989ab46e133e97ccfa90ef59a68bf2b25c3c547083c8ed8dc0c2560fce221ab42cbdbca2f132275428b459ffc88726611c978f072aa39d4f3583a6cfc2017d9e2e4c7ddc2f71043bd6f884f93776c5ea72ab3b778dd9aef369864ee331e2c089be8017de778f9386780b29fcd3480b65d9ec52e0039654055d6a607e6b44ff16afc8028d4cff1142e908c8d01caf7bc4e3a962630c04951378d0bedfd3b3731b78a1db1bf06f750c7f8079ddf5499a28b1f8c7a8683909e5239a7e438561e4d97e1f930345320aa9506a1d9c36885e81e20d6c10ef307f54848c3d7a8a001c215c3156d39afa9e5a7325d9ceec644a846400e4088b48958ef775bb6ad2e8c063de31ec4e954804e08f56387b6782561082245ff35084b1334926ab091dcd13ab4a6d23b601d0f4066158619fa2c3cd255b317fde9f54b65ce0035907c828067a62b9f23e49dfc2483141f553aeecc4622abefecfa81c4b30f3583fb73a7caf5dffb88ba9bdcb12badf92558b783f80c804c9095a7ca00e0f3a377cb5fb9a91e6c3aaee7eacd979746125a91fc7483f9f280db0e1f7afba7b60f7d05ef531c80c9d092124a58a7ed565e25a6bbeb8460677b6e5a158b09e6d10c2897b2ab11b0c7a798f0370bab7eb5bcb51d6f441eedd3a31498a6274b78842f15f42e9d199e5218e5948b8b230600ceb6280c97b38c8434696cbcc1b90eb825deb7f657f8c3ebd9d66598d15d4bab039bdefbefe612efcb3370e0869416f3d81ef999875abd6ab43a29c54261e3f998fb4ceed408178b1d65defad4c1b7089b2caa49f4695347db1c88bbc66462427c8daddc0762d1e8161a6ba8d5b0682e9ef2075d9de1d72ce18cbc6498d5548e8ddb782e2015dd93bc70d0cf93442cea20870d748c98e5d658842c9bd60cd9d29e4c8af9e520340d6491d65ab1f8e1cbca9790a67b77c6e9896267a4103dbf62def1ce971add042cb1112eb319a7735b7603c119524144f78fd0b82fc94c5371a356e0abcd4305440f2f01051ea3538eb0d69562fd5a937928c90bc364b75d196b5910bed7aceb1ae69db7a6c90537988298a9f62ae152f60e4c39f41001ca895cac876e2929d2c6e4824e2e8a7bcb8e408c483bcbfa64a038cff6117a15300628c8762f336bcbae8e012e4d54c884f0a9e3f84e9d84110792df6a5bec82bfa9bb2072881e208c5c0b60679ebd9ec247e56a01bdc756a4c9896cfce56493c943810f09017998fd04917d672d882bca4ccf592341fbb7580c444429a80c1f950ebc14ea35a62ecbc4ce6ac987f5b1ff1d402df0fc312b234a3359470a7c2fa37f404154d8d53308d5b74ad1d7e1839dcfc00664ed7a25693ade9c7c2b81af3372af6ec8f12361516b83df2d8ca47ecc384c179dd927cfc04e9730af529828d2d2074ac9eec0807e617d9d290f8ab01f6853054d6f6bb7f49c6e77ff8d1f619d934376af37270d0148109b19778e3ac121c02fa184c31935e11add3c2c5556cfe8184cbe965430fcb836d7498b1018fea97c4ae1841a9dc9059292510ebc0680f1e37cac0c37090683ebafca3281961ccef16559a6a2d5e79ba8287596e5ed123578e8322e3ca2cdf395695642d41e82899f44234b01e964931d25cd01263663ca3be5d899058ecc37cec13a5a570fd26178d005c1395bc6d0b7f60240ff9989522aabc2e05ed5c7a0869d4fb642a6693e185095a0252d630520de9b1515784378d12275eafbaa36d8840cfb6dedd27fa128b5e0dc4d8107939dcc4f6b95853f7d10bba6075ed4f5edbe8d6e017e76f8ca6966110349caf48fa602000ac7771f02eb650ed79be079ccee2aa881a0db9ee1b1869e4f63439e2fab92bfb8fa27c4cb6351ff2d1a9a0dec7be81af06342b8ad48ee9076fa24a8c4a4e1bf3fa5ae062fe90b2335f3f533a0d3a6a5da230d6bdccb6c71efb7b73134251de3e3119dcc972d582b59acc18871dbdb10addb17b165e96f8d76c8ee5cd96ce18b72e89b7c1db19ef5ccd31dbc2c8fb2c13124ceae3add3e0d0d584b072d01b6d3eaaf3df2d6bc5f0a3411033c921fcd062765c4e5a02bc51ae1f15c68f72df23f5479373a4e84a017d840362fbc6e1749460bfe20bad79534569ec47ce4f04ecb90d31feb7327f8315c2f33cba496a25adbe4980d3f46f588b2e15781ca2a053ac662f00d8380cb2b29ed945db49d7f68fb7dd5a0aba5e06a1354dff543016adb1702f4fbd8c650f66865ee9f3f09d71693aae3d49af2df137c5e42de14303ea5d3f54720a7dcc25e2eed5988923cb823ac9f59856c73703a0ba4fdca95d927071a543a3b0bc5c3a12fad46bed0f76b25765832d55bc64e34b8341b368089da9d0d6f325e0e28559ff91fe60399eb334228f015cdd974297aca95955b15b4569dc9f78bc4e09c514e3adf4e0fd54a9c7ffd3ee42b5e1faccdf0dbfd117fe33327ac79d753df1ca3249965c087edd644cc0af4f8941de9d4dcb0f2c50d24b3e7ae74fb5553fc113701e247db5773abf417068fb00649ee56aff137f455511de898e854415bbdfe730fd7eb133e211e404f1cde76b34179828d0574173011db26a5dba1f329b5fed4407b3ad12ec76d56434a91d3a6abda3d6aa7987acff7a062273cb37e95f48b50c1b32aaeb795e9730e680bd1a1ed3deb22d2256ad4a661385278edccc493eef4c0609e519e3126456c60f251662d68b591e217d5332eae2da526ceca3a2634bf98ede8428a2af60c2b6cbfe25de4663206c2a41660534e598488b01e18e66e5d011705726cc7cb1519c3db1d20b18f5df11de2c58b4dbd088578f70389827710d70f9bbf821a4d9536413203f68e4d2de5466e60efd4890e19848b776a1912db75e958cad9ca080c0bb477d1e68dc97807e58d6851d6837c2ecf30684bc36d25c331b957efaa509d2a16f864b83f634fcb333895af110d1f6833694b09b6bd8b573d94db43ac0451f615661d0f709c813ad2537cfc3bf2aba59766b49e5799a3f4bd5a451655f5360519e0464bb3ffaab05916983b1f129138e6a959a00f3c0cd0604828c151f48bf90e47bf8dd324c1cefbfce9392570abb18e777221c6b90fe456c3f1264faa47f103ee7827d96a159aeed88f055f5ee2b8ee41f7c8bee6b4013e02f10180b78c475a727cfaa84220034f78072fd216665af2a2ed156ee07d70485c01752eed6c09f38f59211b8675d3a1239bc5acb5edeca28cb75ccc8aec89971c5455f2fbb78eea7c8f57792ed0f78f5ae731d20a423bf017a22d8a7166f33dee84080fa621c86938a736f28cc1f3373bb93cb92c4d4c9f66e97aebc7decc32eab371a4ee09e9186513cae6236c9f35d0e2c1ec91d7e8f94e8e3496917de630312b2a2d5d10177e00c38610f7f61647e7f77c5dff3c2e4c2f07608ff67b0d963fea915dbf77722d4cb871bbc114232ba23547a3dae81fd0f4b9eaad8a2bd80e8697a24ed9f3158ea2388dedb59e2607801ec53f9f4dd596a0e1b7ff021d5aed88495af9a367d76c76e607e032b758b54e3153ff7085131082014283b43f3cf3c67adf7f8d5f6b62c1670d0ea1f901c5455a215f32e671f59f200fbf5445b0b34b48f53b203315b1d1f6b5f7637a8054e1b3d9c559b41de748fed07d9ffc0e4b7a557fc6250017a502e4ff7b7ff51b563230f783c86452becfcd2c1f238dc5d4b1be29e0ff265761783b790c7f4c82d9055d6b5a8c8a4ca1fa6daf0ba47e961e0a86e547714eeff27d270c7c3708f28dfcd3ab0814115593749376a7afcbae3c28089a70adbd716cd0ceaa8d1c2bb66d8a143a147b2d156253abce4f772e35e492e2a04133cb8102424c05ff8a37590e913eeb287102346ea12b73edcaf34609d899602710742c48119f81c3fc9c3b255fb4bc595131251664b3212a3c473c45293d0c55f4e88224de86396eda7e655eb06c6cfb14a73503f4eaced33365c8399b9e770d66a115cf254a87c6eb9df993ef33dac344562363da450dad3d24a198b90f8c19bafcd9ecf1dca2aa29d9c4295f6d7d9e6ac34c2a9cf8a7a845c21239356bc4ca662838d788b479bafdf592cd47e645ab4f4c54a8a6fb986d63a76c9805467f8deab0f3c39593bdd2249f591b9bd63346b8cd1dd9a24ecdd539f4723ce50a22da95abfc0b37ffcbf0678d073dda73f0121c20c64f7aa3f02b6c152eebc08106525723d9def809f06772c349ddfbcfaa1fff3d69af7f458fe6313219ea1c73f407da4526c961886ac26e7ffd0a5dab7ccaf5071d162ac55adcbd1e51422f25f6988e94c24d84a852fff3f8512732499e733cb3a6e3fce27c72a0c6e6d368767dc9f68d1cb4367cd8b185fad771d94d8447bbca492289fbf0f8f9056660b18129f95d06a4a81f3ff01f75f94766141d758ef5bbf375a609e83789d04891855e417ee1986988faa178b253bc5fd216982dee261c5735deee5a7e6e2cad11a75537b726ca78de7dc4b7b0d4ec36c192173819fbb49de8016e25fbab56eb976198f74c7eb22b5194df4248215f472a090b52dbcfe845fb317c697c6a60bc7d58af241e1e3982cb352b7f8837e9f9e6cf6caa444f59edb0b84ef33216c2a3fbd964ea2bbfbe0ce11d3a03f6d29406f77458735506c3858eb41859a4c03aec742a26b05c82b1e228f150cc0c1a1b2296fb37b5b33175e9af19a713a77bab87161aeb9cdd02ca0c57dd33ea6e7f6fc185ff37ecce82d52435fa4261c82b978c7692f35900295f0e250b2176afc79bfea0568aa2f4b42029ff9ca1a54eaa9eb63b76d17cdc17da75dca24fd03a50c87b90bd677e911fc74b8b6fcbecef2555338a4feacdffe407094f085fb7414e3a3e6c74b5732e92678555f2574d99928d567363ee308462239845caccf65a593ffb4d9ffc60505eea071630b326a963a0a09ab4d63f4f4d1accee680898e3c0ad887219b4c0e384d55b713173d7ca99be3d97398eae1420335eb34b15d935376bbc8e96a8c2a05d1c2ec20ded3f9c995a5c9f300443663883f8815f94ad08f80542cb784f6614a1a49df2e425fda6a6d19daaa5e27fbef86440646bdc5d53906669ae29af84ec3c3c3ef3077bba43edd9771d0d3e65a84b64c2a6d003b42ae0fd25703cfaf33e3a49b76a0472e810252a666c444cc878c50c7ea03234dc80a3261fbdad25ba4637f79cf2e6a7650f8bf50931dcea922f0624c9dda9a3d679e86842b1004f52550ed8349ad0c87cfa959e9efb994c528fd0fd0aab035c1aab6401722251b3341b7427a0a0743342a702672b1ddf57d681d745d894b626aedd6c19e008d8903b04b8754df8b7d855e87d1a9c88f2b57491a769b2c575fa9629c66834a60171b0c66c840908bf3a7cb50ab424f313bc364a3f7c623add1957a38131cd416b79fcd4b2f2285afed5595fd10ab7aca0b41e22bb65211c58e857298cfe003c36bea433ab35c53fc680749bce5f7d572c742eae7a8fe3eacf6083f868b705c3bdb5e862c6e9d9b0d01070a2bf270c8aad1eeaa45a7d4ed454a2c7030baa234c4a12bb8807cfc34bf2ca5ba815ce6607c7aae4b21c158f3c6402b48eab1a82edd520461cf34231fea3770ee7b8e380781e0f194b2da02fe6bc8be39366c236a45abf0fe5c9ddce31f714715fce5fd6b11af30792000f39da1656479ecbc817505800fa693e261b47c1e464d8d0ee853f1fd0e3585199618b3f289d8d4f622009030bf601ffbda3a40836e955c03fd513e8ba97b6b6782b4bda175b9c874e0b24172656d87b3bb0e70175a3c9a298ad90c7a7ad8db621da1e9db0ee65bda5167fa38d3df9f8f9219a23ea6eb708a447193d5cae5f91d98d7f7bc2d436d0dc796fd07486a7c57ae7abf271557e06cdd38f28523d072329b3e6ac16c3a77f17b6cfbc4db7e702c0844ba691d6539f41bb6e6113444428e06e3368df5cb0f82784fc0f966a3cca15b5bce3ef5643ac2f35ca664055d53e9a71924f51068d853ce038ee064e6d5ae8b8df127a6f539c104c496b47b2c8ac9546213b490ec6d61f23073c0e2fda262ff11ee40853753ead4d5d915155e25988797ccf78d0d05aad9ed25d72ed6802a5a8e8a9a9f911a3c9a6550bdc4886c1ac868327ca7274faf96bf045b833b804e117b807170599bbc4097d804586061b584dd02e540757a744bb916f83bba7380a00c776a4b5e1346bab5f54e8fe6400557a3e83e91100329fdce191947765e4da99e147af383f69330e5724e135b27f660244ff736af98f087282ab264e3e6f54ff1b08e589407c6d352cbdb2b6714c4a660a8fa2e7962026de43f7104c947cee54d33e6d595818c13a88bcd990444fe972564d6a547b6747fd3a0c589b5f786ca2af1238d3bfce6aaa4ae6e1929760765f1a1f82b4977f173cf0e61348048dfafaec4699f6d9fdf530e91b62f556f2d8145aa606d5e454126749df4c9795fd65b571ab31d5858002b0e4e194c45b513446df4163eef11c4091ba6c28511aeb43c561157335c838d20c978f526b8b458ec76b7db6d02baea9ef31ff6417e033f62437d6deda34b130c2300fdc1e6c98ad89902419ea8be9043c55afd98f30eb9ca6fb74cb48bc273bcf04d9c6d4699979b6b8861df5a065dd52305f1ca321f6d547d8583eaa11ff030eb930a60baa422c5825bf09ca39ec80dfa7a75cafac7ab46b46df7f7b1a668d7d116562b3466efaaca94a8049ae18054e1b811352c6288c4012cac56b28d5898770050707574dc63695de2e0e49f6cb9989980b2579aaf8016aa1c3ad6b0f5eefb67c69afc4a7e437187362df959408b47a1e06bbb8e0b71206e0726df429e55fcb883668fa3ce95d28aca3d12beca456291984ac05a2b6ed6ceb82fc272e6bf549d0d85802bcd43cd1c96a4061812b1595173a487796959918ed04680a7d39fda9cc0dab8bf06b45ebf2864b9212a8e90b8df2082cac623941a0b594b7ccb9ce044c51b6db05233b078e76ca80d92d141fb10d94bcf3707f2ee9534974bb92ba855d7af6d4963ebe219c8444b7b316691ceaaf52f210ca9a57a8d45d5f5939199c9065d3e63053a6cceff1c2241b97d9fca5a56fa5d832cfe6746a9f6e746d37bcd32448f2b2d1b743cbaf2dd7259f4f09f3c4cd5b38be254519189e6c03a66f02fe2c146c10fcd9d5a78f2ae8494694f2f992848ae4d07a4cb3c164bea2a313b1071da6939005173800ddcc78fdb233b7222bcafedf4c1f46d37bc65786eb9893e8a2ed6ab250e91f9fa935cea7fbf2aba5d80b558ef6ce4c4035e31c62fd686efd573273c8282b42c44e6279b7c3310e4ba31e3876e645b8a9d253e5faa93a2444cd413f6a5005a23dcc29857a4fad7af7f94db5775dff28cd582dd00152b61c5457ca991fdf2fc621f2190fe0654f120da4e107724a29c4a3419a350ceb0a812b2171864b653d31d5d682c1df82da5f083296824c439dd21417a28317bc30365d5582ae0ee4f7b760eceb774d9b0d3281701c479777f5c92f701002ec41777eb82bf4a63785b2c8e4d52318ea7fccf60f7b7da0115e8b5e1432fb7200eda35462f6ba898c0fc7bd7555e8ce2263e54ea7369a6f1efe49cfea09cc88c52464e230dd11830b90813979ace12d9f5c62a2c0c30a6fe1a2b86140aab0b813fabe98556629e4ac9722651f18b5f819e3fca0c5f43c7e410f574894787472e86450c6cc4f4218f23aac4f7a26f2f6709fda2f7dd3231e80e46a8d320b57c3b4b4542a320e033d9919594e2bbc9724acffb83da3b6542b362a9a82effd1a906284be0cc9cb24778d67315ffa363ab12b077023b31fcb3ce0b7e9c97d1fadecc183a066f6725c5e8ca02cecbbfe685cc7ca95ba96d333841228362dcfccf9cfae1f741d37f1ae8d2d9dd130ab291ad26d4628812722f2c253022df25cccdc668593fea1e89d8cd6b7fff0cb75dee89f45fcf819d731145beae737b409fe20ee3f6ec57bba49eb483e49ed8223fa9a06a5c701212c4a8e444d8089693f515e2ab33d7b5683d8ee08746ab3416aaa1c16126c1889a44ca9e2d32aed4d130c5c5b038562cc707c6ebec64c0ad90214a275bb08237397e56593fa701ed2fb4c817820ee0dc9d5253e654e21adaee9b5cfbe6cc8cb83cf22098832f932b3474b1b23842b783ad685e76dde34c3dd2afd21932cea378f9c798339103d394c58911dc6fd666eb39b538b29c09fa8033077725ecdc7013009e368920e1b0a189850e6db3a5bd407f4df51b0aaaf2d04f23406962d0e58e51d823699b2ffe4f25787963c89db1b6578286345c7957fbf9b568721958aae3da7af810a8bfe76129c2b165c068f07e33b7ae254f58771a38ded11ffac1d629781c847721d349c30f5a896eb4992df5af2e944ab8d6a1e313c1cc0cb370646e8a7ba88b7da141a7687537361a315866e4d68acd0928720d20f21ca0ffa9a10f5d46e5df5a093f4e0274bfb2da468a8152b8f3dd42bc8e38e8e0909c4202a845ff115b7bbcde65c894dfb07163b512f096057d46d6d8e89369f2e81242176463994e819908b6f9ed7e1669ef9367c73954e7a2f32533e2b4da4f5903b3e9f0510c1da04e77054e902ed42b60ef238f4ab842d92d52a0537b3b03da931443dafb8ee2c9ee1e1e3e53b3ce99f6a8fb538cb3dfbfa1d441214c3a161de8a163dc4ebf9e78b01752dee88405a74ea86ce58a2ebc31aff238708120ebbe1796f4f768e3031b1c43d5adeedef1734b12c553c6e5b2f6200fa94d055795b62492a9a5734e701a5a5654419ef967750ff900241adbc4535505f62aa71517acba34ad0beb7cc927d18b81788a57b20cd89a924e44c0cb6f1f8d783d5e8d7d4ff5d31c219e3466f11d887b454d6319c996d18460a4310ec733ceeabd12ea58640d1a6af7e27eceb982c1041a41660a0dd67d4aa01e52c69c88782fe7279b19df689e76b5d819fab4982f5f374a4fd012a7603bd32f325a996069f0c22aed427343cc81a575ce364ad36bc2b782eda7a04f06a48afe6c010e556f2ddcf9a28dc40f9305d7884fb3113e270eaaca363ae1f9a6e6ed493b411fabbfa17de2e318de70871b8aedbbce4aa638c1e767d29d2dcc2bebd182bceee05dde033ca748b5bc94ed806372733cf3fc294cc5ef350773151236617ae2164d2d439f270af7e9e47929faaeef786d5fd8dcc81afdba53a037fac8d711d372086ae1c76196ba2c4fa079a9f70ca94018463a40c3f7d3fc8da9eba4deb8295eef212dadb0dcb6b42a4526aa9be169f4814801d4ba72efb548fe6ab5efbbb8077c76d4db07c17c641e11b6aa154e7d3c8c59ea114e94dc84ca2cf0889e26721b67967c27f8fea1a19b83013fbd5c6cbbe0099dbe018391688da306efd2b8afbb31c01e48af6f613c3066de84c0e55662cfda072940e8b9508eb5f0395d385f888e28b5634ade31627d8b2b2c7e9d7b99b0a33ee966f806da5e120e276072fbbcdeaa9a0f212d41bcd88e069fcb7c449b925477f981a13d97a7738921a9adfb11aafe27321351301f5e5f76c4fdbfa5c60285568f065b9e96bfa26ab49dcaafb97c9d1bf916d424b5fc7fef07b5968f85d1b165b5a8f4131a8aa3cbf4fcd7bd518c52e9316db8004963990319e40501c44a1933493af912f229bf0f10374c6372ce4dec1886579643f056068a87685e1b83cc8d711bfac00cc88fcde743ff4a78fccd0dca827cedb034d10b21e4161160685c093141c0aad4150a71d5f615d8df7673d7226639ffcd27ad464b858c366a0d9517be31c3e9b37aa06f8708067827f80d8e803bdd1e6c8102a84b0f37778f2b444913cb45a8c8957d7f9049e8f571cc9ef987e55f0c72bcccc7075af18125e140c5c13675aedef50db69912cb4e6d45ec9c8354d53cf7dff90fd93a7ab8826507e1788d01d69ad13734bda6e33f9400e79f2f7d12833fe6e3588fb2ccbd14d1c6e3e9502c3093c35617829e4725ba66fd033142b5387dd289085327a125c67306c49de021969204148cfea7cd25a94f740a049c13182b3ba20f3698e3f251b42dd7eb9c2ea7fa644d6bf0ceb292d6731d7cf9d8425b8862a43b29fecec5c09b0b3d2d8560fdfe8780953eb0a0ccc9a4c68e38f47ebe941e4e82d2ac770106d8208b8febdd68452edf33b1456309f949a90a777c920b50396caca6fd4d617410dea0bb10a268a69903808ca09406413f77d49c75f5cf7ac2bacb35517eb626cba6f3469dce741b2238639acb9afbd4e025c86d1aef652ef4004504890cea96ff31bc1ae90355e6e57e0eb5de0a0017153b9df3b0a8266040243bbbad6fda85821b7881fb34cb4860a9d38a2b780b3d09dce0c05b5425292ce5634248966a7bd4912a5c07384dc2db762870c32bf229028a21120d52ac23b0f68971764f71da5470b176b0f169cdb36d42542be54761c20842eaa66bbe8480fd5ef41aaea162abf3d9909b3b3da17e9149cb2c4c591f175fb041a93efe7962cd072fc83b1fa23cd90fcb754b14795fe15a4d53ae57920e608aa409f66aa0d79871167f62223897154d427e1d8fdcd9f1feb19cd645b8d1d9dfb8e82aac183338c198c909cfdeb2bd6a7e68efc273fdcf5bd8649fbcfa22ee85f5484bfeb74ce60b639c1ae1b70827bd9d44c72969d695532eb2817894d9bc485eade64fb4b0848eed2ef95a2e9d23466a5cdf4356fab382395981d5824d934c4c8f1f30e0b3b63263267d051eec36a7b8e6543fd022ed8cd167c6687f94053b719dde7313e20818c26b282fbe73bb103d103c246b302a53df2204bd7ae441314cff220b824bfdad2ee39f588f2f1c95f5962d93d440def2f3bd2ca8065b2e30836a9ed7d9ac4741443af47f9879df5ab91ad0a611f153e9d745a672f52ce1210463da02467b5029c48120b2b333ac2d50395811c1afd50c0399d297848ccfdec1a7ec5e7225fdfa25d07fad7af120562a5ffee817de0522f4310b1c384cdd2b609ff53964b9bc536ee78ba8db6b239e099efc48cda4d81cf6cfe2ccb3de04f8f5cf17f27842d8854f443d8178f1b4da632c022109ded8412368d99e26992c6be1334294be02cc53aa79c68d598bec89f19c3cdc4b9cfffef66cdd5080315a9f6463dd1a3da5efec13b566a5e0bae2f066b17ca4454a765b359ddec8df3bc4a4a17f5c7eda763117299e8cff66d0e9e783ae3afef2f6596ac4ec4ca42ffda6abe508af6157d36dd86cfea9a78b58c7a559770bbeeb6909298fdb95597be2e4289244c40d4e73d19b2a0f7b194d1e063bdbb92c0d7524890866c16ebc33fa808397c0570aec844234c5748044d2f13c1f3a221c12985dbe2b8e56f0593e13467c7345046f4d7769fc5797546cde269de69aba72ac1cb02cd51839bf01df044ac106412a035c0bdd8d7abf7dc8c82690fca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
