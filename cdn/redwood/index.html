<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"547f5e0a7a8c34b73e31f74812554f0e2e6f6f2f8fcef455cc3ef65dcea5d33d86253dfde4c8acd72d46214db875a7403c114f74a8b41b5bb57bb6397ebe93885bd48ba1a7d4d34a787c50406d5a9b1b2be66ab7502f847d626637fec660d7c1de2879f6061e53738b222f335520df6a9f2f21addd3e92379d503da6db89b5ea867883f42101a36ca636544a3c5e4d9a6607133a62f305b57c1a7f06c9778bc993a2145e210a1ee942d0ede6adade3908e7dbc9a9b8ef3cffde035e6b070320c4e16caa2c4ef49982aa183b31f0bdee72d8f23ab88d38d1c59f926be3bb1a72a65988de527130c694ff52118b33aa706865d57fbc5577ae0970fdd81d90423fd6edb555dc5fb09c2696a46b63643500062cc70d753cb7099b3d62df9f6fedac0b6767f080a349247f428eb691c88d2ca18aa3f04b6dd4fdb1c5a00cdd596727bdfbb116d4cd4c35dd0e53edb3678761716df9905a31927777e7bb17a7022c3e9c44922ddf5bf68711439ea4f6c81c5a317aecca2a24a1863443ce513dd303680b6e2bdbe8b02351f9c0ac6612075a39677c071ba5725c43645d0532a14b205fc6a17b269807fb790ed087b9fd5ba0781d498ac7b30f8b616b0b12adce2b55c5e26e0c36b9d68e2ef55bf1a38ef912ef238382146f3e1cd4a830a344399b9c0bc0b9e657099cebb74fb73413ff54e11383bfdbb1a100266ba4aa156a942564db877e5580ce564dca8ce073071f2205019d74222ae099c9778b0b1f355cc86cc2a30ec01932e4c53ecedb9abef437344f118618dee4fa1d87f4dd71648e3b1468b906f533a5e0686205eb9622d6286a774c9b2ff4de3b0fafc60fa9c5c6513049cadc21cf8ed088ddee913abd79246974b71008abd302ac89eab2a98fff29fc0bacf49fd3e15e5bc5f457e263627e128a07430f6de1ab3a16f4dfa1d05397adedec4ce0cf4d991bd161fe61c95a5091310515b3571f91c6959a9c7533e984ce05d945aecb4c3af198fe79c4b6971989af8d770491005343001d3cffc9011b09c3f4462ed5d001647290e0d8ffd69f26f607a7be501b43679a267d7c3929bfef610f76a8e35808f642293dae28e31d1179731efb25c1a95e183d8475ff6f838988f78944bd4effeb9cbe078d0840ec5a915bb7b7c49074b26a64511d9cd40ff2e994fe3ef316ffe1e058658d44afea31270eae4ff2c10bea735bb50df0d976d936ce77c14eac6b1b07487fb6a5df21050caf9fb3067d77849fbeab0b10e45b27bf63a459178831137392815131b94ba1d97179ebec28fe28f7f6ab9d43972437511158006dd07f3b9c0ea12288b54ad2764855f622337ce27e0c4a7a4e5b29e38ffaf6a8268d277857cdb1d3c5c10117dbd79c686101197c923c3179e248c39684afa25f90116096a4623ea23ace919b34aa0749d329ee79dcc55bcc7e960900a91edca49e35cf45d566e8ace96487cf4d40361e14708afb8218df7c2017d5ecc3fd1753d0d8f2901f90bdfe196cd82fbe396e8ce58a21c23c44f5114edf1e185ff69b02254f57d113c82d8cfbb0c1dbb09414cfd12074ca73db95fbf2f9f8916e7620078e84e18514f51b3a864033adf40bac4756022ff85745bb2918865fbc82409393a4e9a122bf0ed4d616904d4f43d6d637331262b15033cd996dd9b096705d9455416f81e8418f3ac4b8d7a3b662b04437d3272dddcd2a494b4cca67248e83c294bd70407ee0f0fb7bf30b2d85985e13e80585f12294463e161dc93e2fcd17ee32f3ce44a950690e6afb13fa5d2f06bc16d19724152f69b3b48d9f0ab76e85cd301753690773abf8f1f1e31653d6721ca1528bd7bcb3a0d0419b1dd4b0d4d74e43a45c4c895da5b8412f117567c9fcbc2f66cb9037670121c59355f56f9e0899db3ee938cd9514dcf55ba9bbf754b810bf0b86702af4cf65ddb40636943f63b5da328d16b4d7cc2accf6c2f2f746cbefcd134036b00c18178db5737163b90ad2946abc3a886f7cfd9195469ce727a15da03d56610b288dc109d1949d2873edc2e9a29e126b00baaec9fca9a4c90ef2b6aa42639a7d3186a60e3d773bc56cf21f8df124fa6fdad05f11c4a9bc83a889aa6949263b3888f6de8245c4764af16545a511d3eebc77d61600755534d317d3e13528cd6398344e4fdfc209264b3b92b86aac0b30f5f72eb1cacdfc0aa18419d907497eb7a252115471263a8ce13c52fb4e877ebd26b7e42d55d76a2dff85961a4cdcb110d61231aba459976adc6726179cdef629d708092b03d119d82d46820feaf3f08cf46b533cb9674e33acaa70574e8790aa5da8c3b1a61c21fde57e441692c1f5871b54a3f65c09f7034924fce1f9820fca756436c21f8f96ebbbe42a8cc7c24b4f8af9b730f93d2fefb774513d22ff6ef5ff994e9dfd4787de6b1c555c30174a0ad45333580a7d0e582807c43b06acb503da53ea789f8a9e540736a6a4fca406676491941c35ef08e3a013619a36ac855732824043dac26a43437ea300b4ee7fadc8f433a49b4148f2bd0fd1bb70a6764cac33fff6ce747f2752c034c59114834cfa49c753cd8ba32c80d7e8267fef814ebff6ca0d6846bf4fae9a285c9dfdd610f7d84bae1eebb4b47bc0af94beb4882459ca872ea9f2938e2787ef7ffd8b2f83a7b7098d35b7aef18f297cfa5df9eade8a4c69b9bf25a1386470f322190694d2589582db40e2012bc7da2644c54a0bbed9f9eb6154bb9349a61d8bf7f6d494f32ba4118959bc84eac7013c62969030cf6831e88a402572573c691227b88c33aabdcff81c3cda3fa72a15b0f694dd890485406d103bda0e30cf7e656efdad492558cdebb8c9f4848cdec61a0069db6b41d04d951d302165c6e8bdfae0521f4f29ef37f1650bf3a50c5437a558562f836f550eccd47f37e2e78a0227ed0497f59dfc7b3d57b48fb694cd0cb71a4819554b27d2c4ab7bfb0092d0c1fd5c8adbc6139f1c0445779f4d1015bdc726a34ccc1f635052b2093625209db7d4e9a0a52f3ea2405e4fba67a5183ca82fc5545c5624def1966de5132e87d6c322209f460df75914d5cdf5b3aa6c77bb54249245db944164c892d3cb13c6715c25e12d328b62572aae44a2001412171e51f28cf07bc12f14c8bb1b1e54f016372630b733fdd7aa99c7240686534a05a281e9a0c369a81917c1c8f22854847664ba86358454840b45ccd603a3ef4f5ec1e19908cfd13b44a1eb543127ef86ecf8af03b502ea3dcdacd77653d7fc81641de676a0a2cc4d189e9fadc836059565880a9dbff8d539b098a946e25358508523842a3f6b96dd5fe2b278d0e6c21c3e14b520003c6b3575945040cb74ba49445a18d7c005aa0417cc078c77d3c11ee1ddcdf4adf40e9d311a1e0757d4be89b9bb119b8c2832dfbcf1e2cc43afee4389422d600c87ece3b10cebe777b55c5259d601e3423991aab39d6a90415a08e913910b08972bdafd510296a669b0a0b7484e08a80513626a5be8c71b0a139a879f754395712e4b5a91ec7aaf0f0eb38d2402c328ddb5dca566ecc774fa6e9cd66dd92dd71bea3b6010d40bfaf8186309c5d9afe94024d02ae6ca13670b53b39ca7afa0ce4c0d744ce07bfeddad25fe89228089088dea87c4d2ba2d664d35cacd9fe1f24af8e375f1aa66dfc3bd0363ae824368a1738a31fbac9930b8ccc04e814a4bd98f25db9b656531182e4dc93699e9f11a85124e15ef8868fba0a918454e7617b11d14a069bb35da89a3cd46f09176fb960be28db2f3befea0c76e8511192a4a9d5014ba2b01b0eb5fa82f65650516373bdcb1164d58061b23ce9c93c5edfa7a582d2014b4abbb7523461a96ac979b53b47d2538e03dcf015b67df330628777b6c508422f9d6a636da5f760e2c204960422d30a574ee963d8ef845ceca88bd4c5fc8dbe95645dc8ea1ae3b32b923be21d402825cca0598cc67c196a4ff0f3d67cd3a493c63e66f3bb14b57aeaeca74d04997cdaa68a511b17b9fcc4e882c920bb2aaf3998bfa39c8d128408fc70d89ccba38b27cdb0c15d9b7a50cd3ecdcb528b248c81d17adcee61a7e5d0b92461c87a9ba247db5147673f678644a1dd8553d6debc2a7f5d95fb1aeebc5af68c4ecf43c2d05899e83ea79c9b3f8244747215dc66075d5061658c1b83c1667edd633462a2c92b51f59f3cb733d86e4c2cda4b1d6f6f83e991554d5afc9261a41bacfb641cc35e13e1270fe32ccc98381f16b4e4109452b2f5bb326502087293b722d0ac56e6a4ef473e9adea012b4d0cd5331a597fd97d6908f8bba95fd59a15688cbae8203fd0bccb3832023d1f97409a323e933d0e8485ea7584493afeb78502cbdf5a2625239077557d25fdb09e54b28dcb9eda33c88c59f3da3f4e92f96ee84a048875fa002f3c8a7de58bd975d6ac37d9a2a18efc324e46af991964f8ad02f5da4d370fc0ce3bcc8fccb6c86fc5a2055dac95fd4b3d25ce12b7c84605c7c5dc2f43be870ddb211be492e8b863d1e84ae569e7a40d89fa64d6786d2046337ac8957953d1aa0d3c04db602b175f165a6b78e17c2adec76737c77bedf08c44200b5fa1360e84479dc4ba7e7e22016c7ce2a043246f996e0a8159329a544c1e117a3618167e381fbf4e65d86c8c246519139c26b3aae21263adf989a3ef7cc95f6a5bbe0c3d1fa4a756eb315bf62a4c0faf088cb79faf499bded0e32cb6fa6dfa34ffbaa80ae5e0a81c21c1c9c8920fa300762b0e94abb1ee64cc066e690a95b4b6b6eeacf4792738fc2facec0e82b16edfbb25e11a8e05c4b0eb280e54b032f00e4ccabe3954e19aa32c651369a47b9173159fb3f579169685d6dd58e062083a5ac2a331b0c9f465bfec2c44e3737f7e1ce082342c4ad8c340916ae669259031ceb8c3fe95aafbe0a5e43bd88e38407dad93f1afcc6cc251185c6d8ae92cc0dd5c1d306ce0cabefb945bd340024d534be1e0418a748ee928a48a87cb532648bfc448c265ebdc4fffc70f7a0ee56dd5aff7481345010baf688aa3ce0e60ed56b6f50d08c78c896ea14e150bc4ee4f866f743a304ef8e4b2c55d3ea7984a17b344a7003f11c8d660ce2da84b6a3874e86ea0f80fcc0aa23554185a9e3b07223938e81823a10ba49c2652d9b77f1d728b2ced00d06d788d8b729c24f2a8ea22fbbc0e41cb222d94bedb6afb819b8b96af1ae98a8835d1c60176414fd30da18ca0b5dd017230cfeb4877afd1a465571c28edaefa2a046feb6dc5edd5dfce26c4998b06795e8dbb54d7eee56159015c52a36fc10ac98d0c6b3722683e77b2bfbb1d59b5973e27e07a78697e0dee3fbefa09dc43fd45aafe7f683c71584b9890edbc3911edd2c849cc3ac9638238cab9d903d1695eaf1b9659753c56b5223c454a6b8fe6bbdb3d8bfab29315bac4c90d9d30add22b485c46e3b1fd27b5337621c847db222dda56f73a93ba5458bd709527185820ffb68357f7fc271c99c9e370e235ae4dd2d40dc9fa2cd85ddfa5b3904836eae1007fddb896dbad8603da7cd00e82b440afd577381752c498cb89e6c27a481ea54195c4f78ce309c52a8ea56fd3b109308f1a21167b2fd74ae78740fb47ae3a95d7c767e8a3a5f8f33447d4b104eecbf436cf1a22cb455b1d098316433eff42697b9cc79a06488b60e7173572872b4511bf4176b55495e3e39e8f16d57f81b562ffe0fecc2101fd8472f18d9f65fa2c53ef7c7d222ddc4d9c41897f8bcf70f860967668068e18bf6a8e1540985641fb514ed56f2c18a86945680c29cc452848a5166f401872e609f39a01b652aeb472bdf2387964e4795fc0dc0095f0bbfdd0d110764648c041f77d50b08d813348b3819fb69d36bf27232de5a860508a91ba94acd61472706fe90728176c963f56d4bd90dc04fc86a71aa800fc80eacd66a54502d7b123c6c828208cb7bfceb713fb920cff44bef4f8583e1e47bdf9b279e7646ae35d46e637e794519b549b67e1c5cb7bdc21be4235de9e5cdd91c2617a93c518caeca572a71c1f542db40b049515936e24b5505a17bc50348951441cf97ea70c474d7772ea1cfe4c6002c0a85218e0ab0a8ab3b5ce6d33b2f73a9c1e083d909fdd9741c1aef25de4c229f82246d1cb536d3528b5bd012bf6c6d930b5f9adc42c74e30da039895dcbf38caac7a12b1b9c0d661d510c3e7f91610c12709ec0ef6164d9f1e87272be373254057cbc020e2f4faa81d199eb6881b349b32c4f37641002f1d88f81c2fc2dd02824057fdd5c5921fa64f48e9a5ed2a245c0f02fd4c26bf170f5b9ac2af8e14eef287bf52222ab80b3fdeba4a7b04792f852eef731cbb7b564a402002673145772a9f7df1787c3431931789343d18133f23c55118cbbee250a512d3e07b34d238a0eeb793973532093a4cc8f45e8cee46b9a735f4766c0fd5b4748466c5dac601719b443d38068ab170ff6d02195880618fffd448388950ec17dded92fbcb2375b8c0c16311ba8b6e28c43bf81366eab70c12647361b713d772e0c16085b48dfb1145fed91f7c4e141c2e8a837a54a8076908a52c78239296a2bff8757970fe035f55c5359fb0fd4ff76489bb6bc5c83d26110fa2f16cb9433732ec11896129e3511e759c55cc150323818e99ac79caaaf33f17d7a2d5280f4021dab5a18eb4f3bda3721f92221981e3a67efd206af561f3a213dfe058829e7d3fe27d7da9f1b4349fa98644ed564988e79f099d76fc1d3dcbb10b0636c4a271b0ca4131e98fe64874854e3aa23fb3cb105dd7fd88a55034e75cd8ae5e9413127f13690c72d22aa1ca0732c34050c55823fefedfc47608aab98c39237557a983c818a922e5e6295c1e621d2a0eabe4186ea49d18ea46cfc1cc700f9fe72636c23dec07e054dee737ca98a56d58bb118c9531fb31a94bd68cb9d6ddf82ece7c8ddb4436e54fd1fe0590fd78f9857de8c6b90faaf7b8015ef531a5195f3e2b25d03b1aae42f14389a82aa771438e186d2395bcb32dd95b7841f0ad188a2ab8d1dd8ef2a0d9d1afe06f41cd10bef9d4aaf6b8b044eceb3dba294bfa91968533ae30a8c9089030887cb675c55dd05d71d0ccc3f9cd1f3109dbfe09c914499866c4757936505cdf36853f4145ac448276949e35387f54bb65587bc0be6559147ab2ac10a052cc3664ad856798ddb78cd0428e6abf9397312699e9c2c9298700f51119446b569d09148664f4f3924acc2fbd68256bd3766c3113b4fb9257849426b6df19cff4af716cee1f47d8978234113710b767e10ff8831a6727240ab43538bb42dfb10c5541d2417bbb466738185dd41ec753f99f55d6d67e5faa60f6cdacd846c8af34d884d13d2f99d2dca048ccf989486898d4cc3708935bc804474ddf333f0a6fccb95166d4ee0e75be0a8e25d0c78fe94bbc886011d1600453c8c752b5a4225d28a598d67fb7b1c0865336340e30d49a313170aeefa5d07d6f63cadcabe0f1faaaffd9dfd74665c7e90366fba16ee847e60adfa7e7b820c1c5be8049477e953ff3190f078529b71976166e236c30fcb8785050a764ad5f3793d8649bd98e47645bb52ec26c0e27b9bb11da27a3baa70cc7436e1efb4965181de241eb43cdfb903edee17279e180cc9c18230349543c3ae2c5470f97ce77fd4b4cd59a869114342b1a24a5defd5da5ef4bf8203f7699c9968d3894146f3db2b93fa7e7a1897b1c09ccf1fe3012ac7afb22d05b49913f9ec75727f6e59c2811aadfcc6b5f865b60ff9d740e7c6f83b01f016eb4d60f75478f4db7c95dd7e78e4272be5dcb1e9403f476afe98e5a12c91e6309bf5329f465fc5a4557afcf07e17e9930a7599572c7959b3fbd80b7f36e4884ece2447f5104c48487feccb6b3d4ff76fb1007fcda850da69154f94f8fb2a95b098060453ffaedcec630cb64dd11cbd8f38120c7f2477c93ef571c6ab5dcf18919b4cdf3cd009ff58f14b242685506fb428274162f25216f033aa5a487ac0f365aa7568baa20058341946dfb783c7730d04d65799b4d18d31e87781cf69e26d3d1c775d627f67651e9b430b150ccb4cca6754cfebf1b111bef605aad79a19b3dca02fa71749cc6b36c87673c353abe0c0cfa123bc769e89dcbedbb858f6e3a3af02b68276306df6e31932fb4b000cf12af445d419f11188ee1f9b3e69f5f519e3b4ab57e1947d329795b9e8bdcc56b2b8e32a256302bbd780b457d7fbfa490c4590e6759f3e1efe743f72847ba602beade0d9a68d035da2417b6eadce624c33f48eac8206adffb7b0b61fd12a674d84e944aac84173185c078011fc0569eb115ea82916a023d3c2d577d69da00e33d4e9157a65af0ecb3d2851617707d547c6aae083236c303244b04fe92c72f20628de6256851147d48eaf4064a0d06151b2935028072b8946bb5eb9029b853341ba642263ec1784fe02d73bf5ee22bfcd26eefded1af32d981794ddaec6bfe22eda732425ba489a43b7b62c292763ed503e0d129c56e15ccd452b90f06e8740baff76430ac48420b268acbd66e5b37e2776313703c9a19aa2a5b5240b0bdbed91447704e814e8659e1189d9d323db1700a20db548b36108c855faeae5b6ae4da8cb2980946ea63e81fa7920635bc8c026d7544633cbfaf925ada2f4f819d844c46cbb6cf966818def02e3cee317f26719f8e4c246d512d7c381877a14d7eaf7c51eed510a92207e0e82bc55152b4cad9ff34c8b2e2d051fc57d5d3602c0b6612043cb11ee736c6f2b240a225685d30f17754e139611e7502570536280083dc916227cca97b5a0f939b74dc4ba13897a38de64bea2e72bd457d3e60863048ce66d0addeccf1ac50536d2764548452e0ed2ec6061684f0bd2469193e7fbba3112164f008dffe93bfe65416a571dc655f4272f6d12334278b95344652169f23c897ec1edf9242b8d28fce18606dae6acf171dae1559b0fbbd255a4c2dc2151070c6bd8a9c85b6f473fc67711322b3ab464bfddee1ac832e80c6f0c020cb775831375c6d16dda54c8da8bcef99e491b257394b355ea864e947de9258193ef2cbe374e7ae0dd92ebfe3183a1821a6638d2eaec143b312d3916ce3d20dec07ff970e03e4cfaa7f9f9d13d097ab4bdfb48296c2029bf8a5225959c282b79832aded9bbbb66d7c268bed96d53546913265a6e9a0a1b47933bca6ee4968210b6bf3e0a7e45aaf11b6d28b6d4879fb6cc95bb76d184db1d3b7144db808a66b6ddc21aa71bb887d93f24c460c138c1b2f5c1c12ae2ab4df2b823005e8f817935e09f186a362d3f23bc80eeafb46c4cf23fa7b1af5c004cd5e173dcae826e5d54edf2b0321a6a05798f694795ed71712823572abd395b4a885b6d8f89eb6ce5301af5be0fe727466168408c4962e1253e987877f54a492386fbc4dc42adb12340ef4bd6ff5718ad64d6d5f7b94fc838148bed911a468c74c38808ed4122e018dae06ba5278c3e527c6e7a943ae0c291a6cb71b3299d1b58cdd7f0ef64493bf29c132e1c78917ca1e9ef42e0204858a606e8c0e67fdf12789da19570cc2bafc6046e799aa00fe23ee362c36072583fd79fbe3bc519cf6dfd3af8c83d1ecbc88dda463a310086eb1df1cbc1f19252e3f7136177688d0dc3f166f3388d41754357d5499969d52789d7def83ae861a7a5b83b4312db52e4947c6f946d9d915da4a3d772c579c294c5e1b1f14df4ea2c3b7d35faf9c490ea539d3f26ce7d80b89a442e0817e9f13bf120fe0c324bbf6377620ac510c87550263e5672bb6ecec9b727051bf66774b7dae05cc0b7e4a7c05d052b1a2adb9f52be021d4f6b7d82a801d0a8c1135b5d319fb1bdc10e03e5a26ad328359897f9b4b87028d8c8fb4206860fc0cf84388c2c94099a3b9aebb2c72a936d56762f76f5da7e37ee181f3a9d4786d5defc0241389388d47db0c110904c5e229de1074d1dc0dca32f25bd61f2fe62ffa5d3c9de1b1deac4b8c60fd5f837eef5de1b2e5ef74f459f389ae8b3c89f4bf6e80ff3a589cb8c1a35e1fd700920d50176e905226b41bbc61e2d19778b4ecf812d9f351784a3b80d097e1bfd19e45a8141728f41eb4371c4d4b7d016584c1ccc61d7f02823344bcf54b7a819d1dd23e949758d39a9198c48a96ff2bb7dee50fa0a5a07a610e944ad5fd3d829139b65d616e1a92e14dce76e48fd1eaa6b499ff40ba077bb2ec466c6fef10001292330f94dcc63dab101f4c53d8b4c8332b4317613ced0fa88d2ce2a1be220521ec7ffea8eae8881c9feb6f24a792c294393cdc48e6ec63bbe7e40c406e4b98f322d115a5a64d4f8903d362f5df067f00830ecf4fe0ace5e4682f442b19aa2c9bf4bd39d8468ceec8a857b9497cd6755403a4181477d9ab151d3158796d59b90cd3156ff9d49ac2588c030690b06421c605a0657bb2b8376d800f34c663290a9b095967b1552f48c21c4b1dddb6e3715b97754096ef63505a28c89c6f76081442975900135a538ccd74bbcce4ee29c58c4b721b296a41e53a5a66f5cba9d0c146816041607b50f3dfcee535e2475a64804253fb528e624b37ceb2e7a94327ed2b78b831271a96971f4e14924cca633a3a01ab1e78a47eb6f9e2bf997c68bb2aea75c3fc73ca2138233ea090c4af59f2d9929675b46e48ae9943ec4dca1898c159f76404ce5e0eb40898d9065a35146f62004313c126b07cf2ae12bbc263512525f7db8679c1876b8464eb7eb6dc6d2d389436d054855b1d0122d40de7aaaf939c14ced84939e50fac6c08ad87725373dc3f64f4a0fdd04d28472fb1d1848895f7ffd8908422aee7ee7cd3cf9236dfb66ac1a4ce6582484493175ce1f738743fcac0cea94a508dc9035bac970fcb84b72c6fd8a21838ac011a5f30bfaf89f0f6481a6d52aeefd0ae088ff979beafdb38b3be6b260dd32966784d0fee7667f91dc675eb9487de3f5955983f948dad4805c7ce3ef955981a6ac999e170ca62537e4b30f6e91cb03341e347c1c100b22664186839ec587264a554f40d32ab737b29e47de4b873b9fd53ed642077d4cc2eb6ac4d22f92c0cae2244710457d2fe42fa71216b7a491043b5535f36125f2f633c5e269585750c05e0197575e96f8f839b31885f2557aa89a0bb7288064b521b8ceea22ae837ee00f91d31a0511b59bafed839c666e0394eba6e64e9c85fdee33ed8b4a1e1b953d5358f98cb44c70a5de8f6128fd4a1777d6fe6b539364ce5b41f5ab90d182161a448274a7b695473a298e1f27e9c4f72956399b8acfd5d180ccdd1670f92b7bc34c44f395571e741879c4747d5e517d9ad37583e062baa8b11d313e759dca3968490239816653a8a4623e2a8a28c16c06c630a128b3f223f746eadc9ab7dd84572cd7262e9b61886da9decb1d52b8f25682994f2567c263a34df827dfe2c77e8c9871b29261eb9ed3d0bc526a3d58b4113071d3c5cb1fe9910ac5d57ea8d54a43a6040147d098be20b2dcb8ed8f6c3eda1a84187e9d9bf64f12893f826ac8378f28d91aa1942c280478c0ee688ef02fb80a34d67b166c9fd83d7d3e2aa764028a88f31d72c96958be721deeb6ffdcee58b5bb7d354f191e735d4017a2d659eb485e5a83d0b175024471afe1899a964f4bc51747f1129d68506cd3bba82ca5b2a5a1c7abe2e3451dce9d135149623f7b10cc0ab53e4601e3e2ca66f32cfa202639ec2947b059291739fbe51e2ecd478c74d141a6643b7358dfec8ae442061e64f6b51c92b0d42eb10e2bb2df4d53c76606810ce3ad3e62969e19f581aeafb11b2962c1d48831bed6fad93290ba756dcfcb03f8b8ee2ce592ad5cc637f89f6bb73bb78bc2456bd81c3a858093cdcc21f7e3cce21ed50c92a02ad89ea4e139b05a446085f2440e3cad29ea5d7f9797b0a265467c110f4d115dc81fbd5e12fa527f7d67a8196598783d372b55293f557542057a681706140b6c16d3a677997a2449172f2d4b9a023d6804a758cb8ea4775ff5f9e6a15c6e8d7ef17beaa19eb5494595bdeb6bfc35cf143320eefe3d0c9f1ef61f3e0b003c15c1ff68eca7c96b21f8575d9f02fd295879e6ac01ae3f7c6bb5de04dbc3f7ec47919368aebb62e5db85a227a56730a3c89cbd114e6395dcf2c3bf9831a41bc8df5d04056594cee9f98c2594b54d743f1384909853553bcb06e0f6026a3c85ac2839b4d21c75aa879eb6bf4183d6ed688dacbb04a9b8e603d06734a68db55689cd42e393e67f135cf7c41409cb13b8e972c01716eafc408f0e5311aa37cf4c762ed01ccfbf54c842d81f9eb4f0e1c93475eb15cca3faa02a98ca9b8c8e233c8f152f8b21abfb472424688ccbb3ce29d61aec4e3ae113c4e4659f6998f60b291ee68972ccb8ce28f0bb2faa49908f3f3c5c978e2327c3e25b5b675031c0e29b41b6e1b39f6b5b9e04cad8bfbcc0e5e34a06018eecf6b1015e0f8fb011c85bc53559ab9b5bada6c28d2356c12a616c06d08c1d896d55657eff0c0a07e79758b7aaa67fac66e2287c22fe113695fe74f8c9f3ab1712d70e37e50689bc106ba178df03842c370fb6272d3521907b18cc392dad55f512eb962cad2b555e7247dfce227b8411211f51a3c6e4edf7fcae9357f2707d1be713ed385afb3a21b8d497768938a7cac8dc07560153a43e63d0d0ead7c450fcde27d5d702cd6642aaa60e88e86ed2e3479379937d1ce3299383bdad2b2152744949605c6db2b2b0c7c83c194beba4aadd4302bbe7a5f5e13e50aa4b1f9a4bafe8896b957a8d74483aebbcb27aa81e58a6fe6791da6c86947f4683fde35e97ce60b5dd13251fa2a6345ed4411b23fff60a59b21a3c1103ea789285a71e97ec4b5b952e13c345f640be65c4dfc46033dfeffe23b8518d8ffc8ae494a5311ab2c5c41b846be60ffe69358e32acfc456f5643d41888e98674b64e54227739ff95a756acb18aa27148087f523d7ef48c53100a990127c7af0ebbd214a85a4036b6f188604d8887307a5d3a88303a67587308ddf4eb7bfca14c9dfe2942b72c1ab462a935faf0356876e6fc310dd840003bb788820f38dd449fb39fa11ccc521415af01d40b677a5f3c87242e2d79dbb516c79a20fb0af47a1e463d633b87e230d7636c7841aded051a8fd090f1bb2a31493e5e4bc29f9095964c506039e3aab43b775d16751a209e8e2ed7af8cdcceb7fc19602313dec7ae3630f1a23864bb9520dbaae5ffec594873b564c9d81f0ec5c59c9e0e1f28fb063288a3ab5242dfe064529d33362e7b3f9dd51b4223c79ca7b2087910b8dea3c5869fabc558433b55c946f256fc187fc5d1042708ec5069ddfb4a7f40e094e1ab7a4932fc5245d36726906ed8ff12b48ae2f78ff6a155bc9583ba289f21d6458445ce43930086369eadaf674d860e0805337d917638fbf89af41a407e9fc52721a9c2db6bfd4c48480142a16d11d6b63863a91352978217f489c98c7110909a1fae633f10546ea1b553f5531f96b12e1d42afe6a71478bc3b99a865fec10641ae0fae453701478bb29b8f4f55efa376af535dca55c082ec720baebf6aef42723ee0801f764dfbc60039908083058e3e7090bc47e88392a36d251fb1d0ae64a8f6776b61300e8e8c103d9ea296d92f0d0f2167344a46228f051235e66182808f7e6420a85b3d4fb7b2c2dfb4ae2f765a09c134650cd65bbf0175b5f934482eb01fdcc2d630ecb33049c195de7781c7d792c4b9a7c526c003819951d36ad84379b854dd8349546fdbe05b2b22e5fb7ae2137dc80bb78dde4cf1df3f2660cc3e26f2824ca9e5511ba99be437ba1b479b8fc4090c7a2cc21ea9a48bb06008af3e8bcdcef0793e6365c70091e6df1567e21e01380aac7bec623c01188b21acee1836ba64a194dd5cc8fa51e70aeb3450f7a7896c415bea0e6802d1e4bc6bedd305f663e65c1f30de91bd0bedb5d77398b9cea45efb3eaec11b6e362a17a90a18e6f9f1e359401c2dc7ab28c67a9f1970abbe0f43d40e8dae545faf24c29324fa84144c20a9d02cdbc3a82847168411442b8d60f101c0ff9de935246163a40a5cb74db2b9b7cd1f06e02dcb9c0a5ea4d3988ec60626824708932d3b7df8918adde4fe32264dd6ad3b7d710f2ccb957d9a07e64ce9ae0c0f868f9dcc07e4684fafa3f1ca7a771e7c59e433241a27292af90baaa95717b12b3368d9515cc0cb42ec652fc0b30b1cb2b13750ef48bf64e41996a7291dfd22c58035c47c5048b204d226b8352dfcd6588e69851663722df096bf2822cc297a42e08ee426ad4839d25cb34d56f7a33e5a613c2999207990e4ff3e2599b96cebf2b5206995e00e667a90ef4d54c84f8d63471b8db2930ad0c78fa5f09c3ec8aab593799653dd01e414328e50d1a386ed43dc9495aeb0e10df5914844dd03b60878cc6e2a51e60702a027dc30cec9dbebe1faf4a425b4324a927bde694836bd3b7ab0764f21b0a2bc64b50bb39b9c72105fd428ac35ac976bb995d97750e70823f85d055478d61f766053c823b3b81c6698c98944cfde5efef569544baf505a529ff99a58e3d5da72d411bafe03664552c7ce4a561a63ce4b85ce91a27244fa44bce39302e1408709336a17a4ee4f74dec2d21c64a86dee2da62f28e02fed30c3ac981e6968c2789f556b589c7f31c53c39e3d8891ecb4273977ee5570b369eb1275c4c3c54aa76c45b8e8b2b1b23f892268e609f3943a6fb5f2db14b41e4be483ea574972b19e1b2bf5998f47db94766b20e12b0c48ffe555600d7ea028ffea2825da644a495677a931eda30b1091777e40bdba4b704b3628e9b13885cb727895ba4a07bb959572a090f4783478bb17182e051bc0039ab6f7b71a2d8cd4e99296612503972ac43a317387075e70d8d6317fcc24e4bff23dbc80e6938a2121eec960019d4e656f7eee59dc27589c524f83b4bb469f5e7296cfac049c6ab5552f7859d6ec198429c86cf519150914063f44c1e1f806f80c6463596132b79d83b16ff296b171aaa17ba92ee01c2a799e6374a9e31e09cd249e7731b2bc5093be6b16ecd79e0765f8238161780b9be4f959080479ada7669a5f0cefef15d3575bb949bf49565b2618112feb7ea95b380ee136de780dce055ea2a1f46218b3c87d47a762e162581c322754c48275ae2f5df25dc7dcb0b61d046e4822c78db1b23da50b34f89504986ae3e4153f284dc9f18d5a1ebf1de48b59b5a53972a16df33d722d16478c4fa3c64df9662c287048431bade6fa346a99596ef8e7d79fa26144eae2c92f6ae4c0cf93ca2d64944d17663fd163d08e0e12e9817d7e37916a087e2988d91d85d3b0f0021b2c64c37e9d0067ba18d9ba4214cbce1bc4ec857e489c8220b2c9cba34c0778ebe5ceb45fa4096800b900eb68e34b1fbae1ca1979b23a78b42f3e2d879179ca181c645450465ed04b32b0d273cc372e2a538026b3dfaad0c9e965b055d2fcac9831071d00c96d1c4cbfb65417eb362d67263fc5d6c02ea5e70c7d1d34efd0df67b66e6329657cc3650b855d29224f7f93c341ffe9024d73cf30d3f0f8c77455f1422d4297fd8d90cfdd76d41687d6cc0acd96218eec05e62b82c8b0a9a68444299149d09a839781374e8e86c743959e1e3e79a76c9d81e8df1e2d1d5910589e9ba9184ddb5ce7bd4ca4d6a880cc7b3d4e72f62ff6dbbf04d54a42afb45772716f570bea617154150813c96d5a04c62c5068dbf603e19734dce12e67fb7a7d782b2ecc1ee2db129353bc88860a0d7d0bb54b76aa2de5398b1c98d4cec33ab4953b47a01756aa5f6e3f81b06878b2d2321d016481036d842aa024677621594631112f77df05a8d8cf81d2bc61a334e38f0b2c54b0ac14ade7d82b45850ba863067a2d1ae9cb5c5c77c992e9dba2e42c38e2079ce547958b8e5f0bab5805ba27a22c14525070f3374b553b8a8df63869ae94976db0a1b9e1566d7114017fbd68f08c2978a02b49e35fe6c7ce7412695fdb33b99094094b515820a2daca5d3692e37926e1c71d1c18285faa8b46a511ed001e0c35b2b259c46b7e0b62ebb6b0fa5a7773af0011c4dd230511a5189d504ce713d8720bd28f52d8f6931cfa9d86c9f49edb0adffb26d913ad7366cc2f809e6623538e6f607744672c18242437965cc8ac161212adfbb9e6a754b546765781ecab5aa76eb1c236a61421ee3faf8c3e33801a1b207e907ac7ae2f24da37e349d10d92ba4f0aeaace99847d79bdfbca3e24531354a03199846c207c8cff03865541029a287c2702e772629713669e0e3743fddd19ed5977874eddd73e2f96970a61538d0a2d7866594011dacad5ca3aaee7fd656e6ff55ee8d2c946726baba52f6fafb5844066b8ccc8ebc058b9112ef4465f6e01219a1222958850773df45adefc19d11b96ca7f5ae7881ef28159f0000ae524ba14168d633edb8cee3a82bfb78831290d146fcf92d8a108421dd56fa8bfa0922c207fd417f66de3048eb43afb52f051354adb384509839e4a5fdb4cd4ea19548fd7a6561cd2f2ec21dc0c3a2184cacb9deecbe8888eaf0060916bbae4501066e74f9a3978c825da640cc6e4539fc4dd6c15cc753ed89feede20206ac2bfb9efd162e3ee46da7e3b29ae6f32a5c532f8cfa94945a73f45787128e07c6f25a5ef215a87f1fca8b7182ce270fb5df7d0f3c98cb493a7167181b5baa6c701299a3ff2670108dff6e5a54c4c85581ca1ed32dc8341dbd9993ed1d4787fbd5035fd5f690915a8e78ae6c31ee9054a3fa29a04f7e58d763827c6cf67e49f58b7fee9089e0af0b16888ebeaf1bd22373f1cdb50eb9d450d651ab9f77f15d2c91b735627c6a9bfcfc3060d505f752001887ea20d1ce8960776bfc0054f096c0dcca0b9349e7f444a3ad9b8c3b63e3ed9b4a34801e40a7fcc4cd88f9cad9432142d1c269fea4a0957be80df0d6ef6c8aa83db9ef7f87022fe3b956a5de0d872194c86b123829398b32b48ba10ba1bd797621324e6240e70760f030d1123ad542c0e581103235d67b7aa7de593bef20c2999a9d03198687acfca1a8a20a1d200c6d29b011bc302c9edb62d1e86ca1e1158a77be138af484599d5a165c893b1c6e2aa11a45f982e2ef75f7ec61e1275f4b59c4479447c25982b883ccd896e87d3da004814be2d76381a0a62900da55f6b00948aa96d9a44ee012cb557da84f65727bf1934ab2d2182e7609578e4ee894a423c59fe2917b729e0d191eed8b3f1d75f1b1ca718c8b711c4fc02c1d99f4ad0dde02f9341c08b303d45bf34f0f062846edb6e6b64e989cfd8562e8f13080999318370529b6f458be32ce26282de964684278b7d64549fe6dd6489e65c5e2b4f619e6d8fbde842d8134007491e912f66dc5e28d724554ff3bdff96585d1ba157a6010ac9f41122b68da5ca7ff7d58cbd6a4c3e97b842d6bf7618f7a3b468dd317aa2065177ef795e92c7276e148c7562ed03ea1b87574a56a2c6106c263ba5caed8de28018b3e0103a6408f6bb9eeaec703f40b7891786a422183e8878628829213dd8ae798cd8dab4b6aaad84e84757bf4cd6230f0b520b4bcd26e16c51a4d33eab4020149eb44bf81b8ddb0db5c62a38639a0accba3fa290754be47dc974543ac20c260152a6581235e66817d9adc18233dd990e39238372729f3405b19d54fee6f627bb9146f9ffc16cd33f59a77d51ccff91cc813ab9c9b3aab0578ffced79e4c86b555b608677f4f2623d69ee15144675798ebaa8e081a7dca93de5f544abc018ae8b8db9a19c534a81c7d689ac1b1a60b3c4f24c2456855bf07e73f418ad1b44a3940482f4f536de220fe98629908169a65ebb9c1d82204f0f73a626b8016a319e5a1a2f2deaab00f42715741032ad2fa5883dd03968b7e13f0521fcdae1e969d93b5e4c728d6bf21292f3bd9e4e3fd0d609d599802e7499f37140f9464d5a7d136660650bdf6ee8fb2b0697b7340403d5ec726547cfc4f7970d57ddbf535cb20f0b9c279e4c5b957a744501609cbf32f681cea5125e2bc9be251188c698a689ea281860bf0f891b44fe582c7f9c4b909253e2cbb6639de3997d31605cedaf7a67d4d0d356ffd38a51c1436bdcb19","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
