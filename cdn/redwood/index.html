<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"505778ca91419c4630c291de0ca4acf0c080388acf859fa195a6fa6d64f1e48cc52fc8a1eeb54cbc8b5f77f111cb75601d08c05ddf967075f3f41a602014530fad9a1dd67d5abff439ecd62e5387adb438a79e47072103bfc2628423e8716a604b6123b669b94e0da1781a586bc05ae27179a536914d85fd17de1dcbe3466c1fc252dc723b1616d85269571c7dee247f32410bfc77711dc7cc55bad80f53336760ceceb6a7409cb71953f4610dfa057dfc9163419b98ff6bb56c462279521f422f91e9e54ff38b1d4f04a7d2380eb333d220bb9247ff9b65bae78f56e3f5ccf52fd1dad78c933f4b32b19e7c2f476f9f43c6a421ab2f7f0e3de8feca5fa185684a5b0736d9399489b11873a92c7b7b10226944ea8b5df5497ffa978c2d19240eb4eff7980ac78899e7431be8d64142f7c17b0bd9781e52657e9499053d12e344fbb265dbf712c021b0df72d209466871db73ef21c09fb319489bf10e7982b8a8c9ce35cb857427f751480674395f5e9bfd23bdb784f98e4c72d0bdc4c79e1976eab564abaab39bcae0634a3c55f7b76efcb5daa516548dc745633520fa271c2bc766973a82837728cf490b399e72401c18f7eb84b34755867bc87366a2a4603aab2612578a0c42d1ac4efc07722e75d0e4e1838c9e3981d002ac537e785f2b36e2db0c97b1def1c16efa4abe219c27e1551c0b86cdbf87b315d59a7c24c9f9c469f16a29951d2e1e08974d5c19c44f3a2f95fa2c0fea9ddfaad9da1dbb1d768e1272d32b576b3080235cc8613e15b5cac327047a5982a1d3b6b02e9bd5951cbc3647d90fe69876585e9633171850805350e84dd80b53bf7fc4743e42f04dc2cf707cd7a28ef750b18c191dcdb9025c801144a351370ec82cd234879e616b59cadd4d7ffd98ec12bda9520090a32f9f62aeacefb2d69f1c1d827564478bee8322fda4536eeca2f1080f9f9ec76eebe6c949e5c85c5368d46b16e7c0c85a3a034aaadf977643a9e93e09b4c5e3ccc4c0ae4c65fcb9ac76053a743d7b32b474d7c1d8e152e57dc0a2194c7f201e110c4c1c1f324b9a627210041f43d4230c1353c60681bdb1ea2991b0bf96fb5c5e1732e6629edd25f86f548ba69e8250b73e27f4e22fa3bdce9c1fcbfa1639d53fb9ea409334117ba00d4cda6e7728d69ba9d20c6782ec907e7d348c69c964686dfea52fe4199e799774afb9204d928b6343ac2f2a2c40431ebf2717bf4352bc19ab235aee05fd20f814210be48231251464b0b27ef93e9628d68bddacf0807c81c356a7fe932174f9caf75cea09b9695bdb26cab20410ea02812b773ab2ac8510bda5a98445a207934428ab508467c8b3c124c1d15cbc1bc4de2fed931321b28c4e06199a822718a401ecb8eefd6e791a428293a7ed59e0d8eeceeec0bcb4dfbb27b3eef6611965693d4ca67a212a196bb0e8369180c8377f5e24947e37a9ca99cb12ade6a7ba88ac07cbfb775c1acbf29be68e2c0c4db0a36bdc4b2037ea0350ed6e936e468d874f1072a5f2c9efb55883121399fdbbf2ddf315d70336f03386a8a66138040ab79b4d930a86cc7a4d061386d4a10c1a225a9b67f6a8f52143b7e3bad388db26eb85337284e46cd77bb8d2dab0be0743617043187156464a6619c444e90c6d1a6854a9d433785380bdf50f0001cb8a31a895d05c65ba6b4300fa3c0d7ac285f4707f7f577248bdd4c8863e65781614ce5f90e41aea55b9fca2494dbf1eaf95d32538fc1d6c15598c5c07f68e2b004f383bf62a65c30a0869070e283cdd874ee6afe095ee7d18e5d22bd814f163b8bd139ee8e7ffb1a01ebdd658f079c6fd690a38eb325243bcf1d21a60c05f724200e0b7bb6f6d3193107de836e9bf675eaf58c58770359c879c8faf2cf1dda6c7850c404f93e395122f03092fd6e58550597af4845d7818491f8462f22f31fb70b8e85a60c763e41d662e88635e17314479b02678602c67ffc1a60914971322ff1b20db4e982814d94779ffe2eb788e6fe2c1d95f15e45d864c992c06cafb0cb449a5bde9c36d116f39051215373775ebd6d3a5b20b5fafe2e0c88c80b5273e4dab25ac27da9999a4aa26f13131813a2bf065befcabefec67f54abcfd53a6c83974da42a06258f45fd5a4285dc84d2afa26468abc96d36c0466075be85b5ea3760c3c76be2602c32e5cd7ecf558cb1bc6966c7d15b967959c26703ee8c5acb987b6f46ce6d5fbf60dca361bff049f35b86e311284ae4114ecd04f3d9aab8251f1956963f2e59a66ecc433d34e056ad48117949b83e8cd08ca4ed5907374d570037754cf8c83cb1bbdc627c544a3077b1321c4411848fa29f27249b6e1f167a25463db86a3ab4d8e0718a738edd91435fd54722eb0df47643d2447c58280b694dcdc888e06dc3742991a115323fbd300c25d71ca1e4ff01eb993f92e950f36c786a5e149d8caf78772ba90f25c135c307e6a2dc68c992cf3b12d47e5deeadc802f63190b6c82f7ab1342f9c742a949b51754cf77dd0a4a492674c08be32e3904d75bbd51c1ca8498230acb31a1991c851474498941aa3389d432230ee16c2933ea399fb768ccac4d65df9be220e39481eda9272ec43a8ae14badf496f2a1edecd2c5ed120c0fb22767f59744b01407e61a72b5050ad9d08cf7dd9974c8ce8c3190fd592e3f2208135de519e3f0924cfa428e0a3031c2a3e27a90fa5727c28a4cd114855649c382b4751c7eb1d1599fe609bcdc0c05f8b8b81e5cc8a554a1918c438adf36149d890b7fc168170e50e97b875b2bb50a4005cf11712be6c346fff9dfcf337fb54c8922a5424fa39dbd3196c3d270146486ebc67f5454d726fb53fa4c56aef25f2246a1fd382af593fc2aed74ed2eaff7acf1d3227d139cc25b0fff2f258580639815f8a74520954747de5962dab2a8f7540ec26b2ccb40122ea1d04bde7df97ccdaf31b30d95d61cdedde0334d0e93dbf0d4917e9f3c7b9be264f1890420031300fde35ebda066e84ac9dfddc2bec8d943c682e53093afd73caaf7ddf49fe2a6ddba4c4fda306ef4963b6ed9c5894d3377189a32b67e051e2c5a6ca56ac1f7df438bde5c6277b8f644ef4082e1cca2a95c423fcc03565c7e1b589dd00e76699379b9f558373d5b84f3801edc8246abd95a022e801218f95adac868729f4b39b18faec953c814eab1f8768eb6e133702a6ae2675dd9db082334436115d179cfc978fdaedf906add44b84cfc6d87affb852ef3a283268796af60cae4cd20dfe15159974ec03cf21697a22e38368b3c123b80284fbf1d3ec5afa02682633dd7f090fe69b71d6310cd1c75a3accfe465613fb1db4c206113cce4bbfe6e818038fa2eec4ef428741491d7ee762e9a143921f1621b273da92ce98299aa0362d9bafbcc6daf744f38aa369443284d6104b8559e358edb2df5e83e39f341bd982059a1c0680481fafafc21db9b72d7eeaea554ffb098e7558b47b59754a6078c1534cc3a4170c4dd247a4c98d3d1b9592f499f313df05183f74f46891dc58b69cecf8c8744f5cc1920864b5b3b0a6370c23d3101d94d26ad76e599e13de2b9a37a657e189534bfb51a0b3c94cc0ba704448336e9fa9cfbc89e9707201753987d937aad2266da4435b530a4e05da39459f18dea7a487b656a02f212455aa3978fe12ac4277b62d1290c232fa809ea4e9ac1f6336280ae65f88e7ca5a2821950db06687af0e68dbe005cad18f4816c3201803db15f05ca010dde303aee6620fbe23c87e59b0d294236b685697fb3e15b831435e4f4a64cc48b4d5084241eec97cf1599568f5fb4268fda9c58dfd8b4a33112e2a55de6b1db9c41744d4a4e39dbd5db5a7b8289b34cc0a0840296bf94c3b270bf305114a8dd6326022e9fcd08c00f249826ef9025202810b2ca90d8f9dd98156f1470245f71e1792c61a646fcb60639318ecb7ba8bbb37a2bb11a31ea65840feac48e1535a7a210d54f0fe7fd365f49809036c53bc95a262b7ead73029891fb62f043d0500cc6e92f7300a84e495da8b643fefcf2217883b49d91d4cd9f3b1b6b605bf813ade1130503b70aeabb853e96fa3e905422e902ba5734cc1429123d8528a80aed3054cefec916efe081fe97ac6705952b37636d7ed318df6859ea445a0c204496756dee25afc3b19693afb69df87b233ba8d1f81fa149a7dd5fc61a3f36c124dd67698c988d2665e7fc58b0349a63c25ac74cda2b4e6e14b2f86175f419083f1ec7cd4028e85f1f0045257dee387393113a64879f9d8b580e3f68a95cdf5c21e12ca074a72294d0ada346d41179144acc299ab582e95b6ed5fca70df85c53e06ce1449516d8a2508aa516f9db771ba30f5ff12f9eb119fca7e0f8126ff8761189046bbfc27eb2678cc31ced5735e0c828bfeb840e111beea25c3337006bb37f9392c94aaa066dc068c578efd76f334e7fef24e131d8c17ce3108204f1b7f1c0d427770a971bd877bf3438e85cfbb71384f9a19e06415b068c33ea802d6b15bb0dbbaccd24fdaf93c99d76b5a8c0abb2ebb8d14212661b5e0c0e6dee8948e271028c9fbd7850abc57ffe867cce1735631688f90325eca70182beeb313ccf30a606643f249bde2d2f701e0e6ce80484ba5e6b2a51a68e1ed153f4dbb5de63e86949d2a0d3394b96d8d42c9a7a81913771359a47fc69b7bc4fd0ecf93314e34bc5181ea252ff43aeff22ab5722eea86de874d95596505acdff730c62f30e69e4db2da933f83089deb69aef7eeb81b84a9a1fbc5915a8f3a6d9b352d37fa6da7eea20c03bc22dd63ec8a2504acd9e59cfa94ba4100cf5b1aac88e60c807e0f0e4514adfc30927722314bab406ea813b24ca35c4dc4de5b9eab56d1d7fcf72aa9f6d7778f3fdf5f002eaf752d3e7b83e76ac9e29e3328cb62297f9c5dbd965f720375aeac624c98c45c48a944484192ae25a24a9c8cf3897ab646e56279e8a200e12a1f9191d124ec8ccc55580a8383b1e5e54964302ec63f6e198cb57176fa036ea9fec150459819007959d39f4e672a5f0434543aee589e4181dbd1200a5ea616266dd8b24131af1f9295f7ccba970056d0fcdb1ab1f86efce3992df73665422def7b35bea13222ec5c12e5aee41a750d2087398558cc3f9c9028839a045e3193120b14a195cc38248c772dc1c86d1f3fa8b834128060ac71ba44ebd6aaddaf3e0e49e58ebb46d40f44c9d3822d1871beee091b30ac871ce783b96352d99ba5996cab617acbe08b75630fd97f94f96f4600db0c43c921f4ea27af9d9ce8522cec56115b95e8eeddc4caabed3bb9097a27f2dab4edee2ec08d571ce29c25724b6e6ade078e3777b499d67e5b01e335b50765d11c296b2960467c9fe69dd89a64c52d0b94d9a474931f9daa2d5fc3c744e212a4fd84ec7d8e82b2277822e7da535797e34cfd62dba564702ad1d3e7e38b78355f1bb1f8108ad47821392b553896e2a5c7fc133818d2d4ebabfba7aa3dc2076664612be08e4ad32b9c28aeb38f6be85f79c20a9e406b62cf6fb0e2e9f618d018b645f32bbb70a47f0b249538d04375930d8e1aae21b3f42562dc9a5009a300f1438c1144912a6fe1113811247fe4c5551659980fec204551eb8189f396391b36ccc9e614d43156bbcb05899a5d8bcd4d4ac922896026a0c26af5a6f1910c32c91d639b640c2804019112d92c5eb64a99ff2e63c6a6dc97599c819f470a436b4fb5158548091708bb8de7d526de2a0eff760e1646266b2ad84b1da2a737f7978ff11626bf40b48e5d55d53a94bbde9de07f5464092bf5d3a3f60f3370116f150b10a62464af5edef4e1c5b5a513c0fe99090fc048ce6fc0111cb784457d32a17b31e17ba4282c799480f53c4d55f7f03ee6801b099250f18f191062cd43c5c41fb1727dc7090342272f2238c14c971a008680368d0a7d386eff12aa16c65f26b93a292536547a004597e7efbc67e49d4f21790be1f424b0fbef4af7a23276d009d35da905b70accc3e340803f6083052383ce0de9326a4a02536bd7fc2d0b1a9b8776c7d78002e2e065569cf65b274047ce071b0c3d1aabfab8805edf8d780563334ebab83ae05b12bbf4485130259dd83086a6d3b880fe88b575b3fbcf429b8660aaf1d3bb3030353877646806430f1b0a5a36cf7ac6e82a97f4dac16dd49d2654c93b1f2c7d4f3419006c6da5beeea86e1d5e17de5234b774b3827352b5d486a8e053ca7caa5aef53b51c6e860ed1fa838ace9ec43a8688d959b63d8e56d0db07a6e146193793a1ae889f95999addd23ed95c7305b4dc1eb6fa0f44ca5cb7b3997784eb33334b3c9fa2ea226686424d741ebcebc99713a09e5819489c4786193b8bf9ca12da1ed64d307984c52cac8a920e33d4896c7c562ec216f9664d94999ce8458cb7086e74abeb640344f2959c0ba5938cd19298539ff1b582dd35263ed6dc3273558918e5fc7dbf5bff72bb18470210c2a99d7c34786ef5e593a9b27208293c1e115ceffc3b343f039adb861fcaf721c59b3d0b142a7ae2004dbd1f35d1967cb64b4c1715d7276e47378e5b1873ae28558c4a3ccb7bd3cda41f09d03fbee9ab7e956af9772e9af47a6594765139d4fa00088f251ae26fa8541bf2b5dd336693262b803e8f8f9e8598d54b77ef345525b07d43590083d5467d2b0c542935e3237d10e5f6399607fd64c83fe24487d022334c1c78b42230d0839fd47a3665370daa2150c6d065fb83fd6103f970b9611aeaa44f6800c73ea4cccb567096b26898ecc5c9d051a31eb2958608937df35ceda89284299df41e657c074f41a722e55eca0945ca9ffe5343fa6dbad2d621715e354462884fd5b763d16f2b88f365391bc9fc249a19694eb62e08a6c7f6e0f9b6fdb19ee99f04ad9cd0001527e29b6db27838ab48731fb4834f25c74eeebec375f10fc7e2891872cc3c21180f58f08f8cf8eeca964789886028486974ec2560d0d02679e5e6fb119686c6895caf173737403a42f7fd1dd1bf45ee1ef09395d4a928378a60cbf30c16c3581b813a656d61c7a31c1989acb3127ef477552c7a800d1a912c9a17473ed4aad5195ff256d9d2b8d4c6c0aa275943724aaf93350dc2a6986b7806d6d1f728be813d268ace3bd3214d29eac6d31fc3a7ec48217b7fdcae74331bf45906313b916c7dd247fcbb7c1e5eaa142e08c3f932a6bf6adcb49d143b3ceaa94fc3f9024b0a71c950af9aaee61f656980328eb6446d9f65be911eb07061d372fa1e1a2762ca086e6bff38a41f530ddb785829d6821431e44ed8dd1da2a5113befd89cec08e4fa69e26d70e49514e3e74e5da2f6574f745255fadfd67d2d2f6e38ed05132aed80a849c49beea0534b118b6722b40fc9730318eb73eebc9c7eedb623b187194cd4695a790af3ab9a30703843982318a03f665a1a347bdd2064250816069152f610bc6d0806dd9cb3a18264a7397024b3964c20acf13d9951e2a3f6535f5daab481e476e8f13a6d041253000e15eaecdab0b694006fe0e621ea794e363b7e4d9fcae0199593bd17f76589e91a3201c5b902e773f022e0ddea50f2f97e97962b8fd05de4136bbd3398c540ee5802c1685988616140b45d2dbf10fb0cef93a4a2f7cf0dc5cf6c7da7ba3904b26aa76cd306a838fcac9b241bf85565686a10fc15cc24ed398c304ba6c36fe323ebbac1f87dda0b2746f967f332b79e969d8d76f48bbb580059ed40d9f2621a31909fb7c12ba289e5c37f9f4582adb8daed59057ff7cc557ed5af261a495ee197a31b984f90e6d3761bb647ae31f2ab4596a0287ccb9f21bcd1c60c4d53c0bb9e09309fc6f125bcc8341dc4c0323c23cfc4e1620f83658c180353a5d8b7e8be50468f040e4857eb78f56871bb36d5d5564eaf3394525dc3568dc6f8357bb586710f2080ebe7d388628c266eaa907b57e382e118358ab25e2f553c0a1b9216348d1ef9299f167c7ed98ec20af2c63344404dad1485bbea5553966e3cfbfd7913bf6d0e7facc2fb4a386b7d9abd6b648f55c7cecba2338811abe5bf68551f17f64edcc60b4b33d571ee5692845ffd94230e7c5850f005d7cc2b2e70983371467d662d3d8f506153ec2fbdbe83c1ceedf7b93c296122ef3391c20458e9efc92336b81ead53e54503446f72c122fe5b836eea516b53b7ccee7b3a1ff6f9846f17ee9da2aa8cb78832f74f4da89afb5e077fbf4d7ce49669d0868b253a38f710dd15d66ec584155741819fa3e2b7b7e482d9703eea1dfdb2d8820a19d0e65dad957b1120e4ea9ae0ec3ac9c5925624c0b86a388ce325fa9db4d914f4e9dab45e18bd1c83c70e1943a800b1b53fdfd3ebe43f4c0d25a1200dfe3020b66ef32944cf2c2afeac4b6d15e8ca4342a66d54a4fbf94c586d52284ea63c0c204a0f92a0ac228cdd2c45ff7eb71bd58de4cc2272b77d43f36540dbdf87b2c5b7a2a9ab648d693108cd5f4a72b49a3bb6648216884c87edfcc6fe61402d0d215b96248d6526fac3336060109e3ad73ee05725222c4b80fc5880e7b980d0f90f7e5c0678e19d367184d1bcf0da6dbd460108e8a429faa8fb695bcc5ed0072c604415538e807049f3a7292642b05d271340307c48aa096045d1df9554644630fe415be9083b43fe8b4a05621d491bd3452dfe51924ab68f3c887ba9c8e9dbf12040a32a085d4c80b2e9067c3d1eaa325772e108629d83ea1588091756dfa2bf990a11b590aadc8e740e66703dbef504b43b8b640253c1b8f5d2dd21810303aced8ecba4760ab6b5cbf2d6ab83196a9a20ebeca64c0bd705d886f5a71d3a65478ab1fe4268049e3acd60504b0d18a05e357a91d237fa15c4870011d5aaf307255b3e00e196ccf931f336b4a7856621c2829a3e1c5043d0c2511419c01f76e0b3723fc02dc91f8f815b199d042ee9ba2ab8bded8243201c47c3ea6fd4370509172234cd12a5324bc091d4b6231fc2fa5e0bb11cf47bf455fa47a5b45a153c2b9f0e7c17221d3b0de19fa51e2dfa2f2dd3a6225927ae77854199a120e1d4139ac607b4b3ad7860d354e381937342a5c6ee37c4f6b80c389292303b60c6cea4097e926bb97dc0fc393228873086cd5d88bb3d658e89e3de496175c2e91075606421e6741501c4f3fc98d62aad2acfaedf705a1980bdd63ee50ea86432f8299fee1e4370e06085ea87263c1174234b064cedcf8335fdd178434792a7cf77988645d3d8d9304d6965f6158ab0f54a6e87902fc1610bc6ea88d33d41c685f82efe29d50802e0b0dfcc795e6792bfd76f39cc5490f667bc8ae59692520b586410c25681bc79f4d1a3c65d13da43915cd5197631f1f1a69b174ed3dd1c1b0307d50394936dac62df4b000c2a278b367d18b87fcb172d1e7be36c4000f87bb504cdbd6e2b689cbf5a8c0e2652b030b8bf7ee5a48d3051f48402eb1ab51703fb895223df0fa118ade8e39b34dab37344d0044550026f833c3a80851aa591e9cbd6a3efc232c0c5db144adcb26145b9c18e568d453fa58e57aa6ff9c355ce0b102434f93b4ed86a55f6e8357e0e20c8093aed0ba71f2dd6961e597f0d1c59226e55ff4793d8b054578047643da6c1215bca96a701c660d459ee5fa7cef5b91872eb36dd058724cf5866cc25cfc9fae45b80773bca26316eac77e55782561d2844160d1b3db7c87acb3df86c9d147f4c43ac1baafa34a5e5642e5eef41417acbaefa972ebdf5b02478032e5951450bee839f97fe2a126c6abd73a05bf21b4d9ab5187022cfd2a7f761ea5a8c544b3bafb98e7d965bd3f710657be51bd0de2968d80f4cad54127eef1964bf70a9530d49425885b47afbced7133178e99cb7ae6e8f3c7351566e218d1ad635a8a7f0e9fe83fb5acd3eb8f74a377cf31f1ba638dca9ed63f9d6d219f7c376ce2fab24b58c3cec16fa542bf19483d2c4a9551a71a02a0c3f86a8ddbfbbec753648e4ab82347ccf23bf44a600e376f7e3d01274b7153c105837ff6ceff1ed06cb5e4346f1f80fa80c295cd8b87bde906c0a6af7f5df93fa9a313f28fd7d0357c94c183d48e471607990fe5666ad7af84bf64c1ed4a4636ca14baf274af07c13682e8ffa834e490804410fcc9521168dcb3a437ffa3a5762ca9d2f0be05700d167126d1f040862826a7a5a7501aca78da46c7ddbfb6c34dcb6540cc19fab7c88ed0f910ee673074628f0800f924d051c90a5f90f21d0ff91f273e0752f2018644cb689306f9974e81efb1491c9639f4c1bf8f4b35722e90d3fe469776a7822a51b02dc264df566ab96c2cb5705ed63ccdcdc8713786447812561573837bc5abdf5291970c84199f23940d9fdd4a16f8d661ff76b4129cb88fda34ed8395f7aed0d1fec46b9c262baffd35590a576d348051a5408121fda5d7924e19b3b0b160ac9dc21363243fa9be16ea7b58700acb7133a3d9627a848dc784ca3cc223c89fedd1ecef1282f73b4c7ae7b4fbd568ffd0412a990b0b2ea9c7bf7d0c10522a548a66aa7450e20eedeb0d8ff09181fd7e69a0a022d967ff0339ac3fbffdedb04f74798c852330e91ac6e646aec0892eb73d054f4698c49e24f0496d998f80fc6826e175cc18b2118515a88a3c6e92f21d07bf432873d5c7e4dfb9e872af3209b3763ae14b495b9018e34ee725fd46e151ad7e98fc313ec9778cbf438476bf36a75f59194a477dc3320ad515e631fdb29b4d2220ce3ea8b45df70800930131574f9be5b275f7c9de66008f1ac9357bcf16d81621ba0898845ab063ae7b868692b41df535f05bfc61e8b64ed01e172e8284cd84771c6b72456aa5b8fdac55bb9b273123584f2aafcaa1041d35b1d70e2ade05a3180240520fce176755439ca8402dc66747897f63ba6457b0f927f5ced9a5bd68eb02158b271ae330a4897d2f438d96ab400f32320aa03754d5c6866b4d1006780d79e46ab8441c868e90ffc7e218fd1b8e30aadbfe959ccf1675e01b15a05e31fb973c813490a3c3c23ec09e1687dfe2864cb436b5c0a5ba663f217482490f1e5d0b8d748d03f8c8f1c64383759137e806ee9d00a04fe67fb1b50af48673f14d0d94576eae889178bd7594adf3a0f66da1709c67824ddf1ef669a166a30eb8d0e7fff02e95b49be7ff12ede40a4e1b9d8d75a9488139e13cb58ffa0a395274a1650f8ed4847452c4485ce6e129a8cd6cf6a170fd0ae4ff1c91804feddd912568baef65613fb7d39abbe51c991a53d35b0d1c5b07a8a1739fb2e6282d6f9a87baa071df41ddd5ada5350d0845ff18fd51e4aa4b9527e54e7c4cd879b5f24676aeecbfab2f08a64f67df86ec2d1351fdf0dc1493001d7143f57b8d510a126ef61fc3d2012ed888f0c726f36e7d9482b2a958e70597e4fc6a063d687c22b96bcc50422479ed9f245a0fe04f035409bcae7a55299b66549be471e2e25b4354c0b867d775451179eed9bac76f907faa76d72fbfc9c324605462f90466118d6881345ae97afc2512476ba7ad41b04eb1b7cfada71768cdcab24ec82036e106ca23c5d78e561fa9053d33d12b81640083e9e7c020e2665df274b5a6acb2da01b8f3db57575b48b7a97c0a3b39012ca60044047b993bf4d229562c10324cc80db033aedbec6e003fa628a1c7a2b0bc48170345bf420f2f86ac6366b7495bcf98a36021e6ef2c7a952fe00a28e5d512084c77b2303775edd7c716f715658c36ef0b6c6c97d2b9ebdf265ec040289b8b89d9ff3f7d23f8123209f0be9023746f677390d495c4f5465cb76ee5c2e0458f1503029790f23d0a6cf9d64b5a4c5913a51d03cf01d6c6a37e3ddedd013ca29a81042262660e9327ec76683facbfe7087bcdd6e4eea96c9c6887a9b2d5d6a35cd4374e5da4790f986a87f5848439f6b481a7cccd2803c48110f06120d5d88ad5cf42242ac63f9a06f1a9f9891f4467ac9a55ffa3110b08f7c897edf50efbb4d8f76dd33cf6b571bd9126055531e3c0bfde85b8f64ba2fef85acff2e55387774db66c6a55080afe336dd44737e6677b3df862327006fe8f95fdd7bb6b28130f8e1b4607a18e7f058df390dbf12713989954f1332dd73aa2b812c0f389b74e30adf6e3d87c7b0069f31f79da1a696dbb8430e09e756308548807233a1d3e9e35433ba1c833390f1705d0a4f325008f428ccf5ad039ea34633e19b6fc1bd8db543dab0b405494b7b18d6179f6b25eec15c61c1af67321a563ed9d253a8b598ed87867d4d5a0bdea49a7bfa926a3c9ec949e35c7e11dbc12e2ef700af5a00e9bb25e6844c42e21f2b1da4a29b2c94f9e7d626d6701a64311a19aff55d522517a0443820edc945a231fcfa62bde11bdd546fcc9acf05d18725c3a405f1a99d4a5ebfed5b9124a6e39cc0b1cf4962f8f1a2828898bebe16042875ad1bba0ef6d4c487490eac242ac864ac61337ddb54be2049882ad28f69578451e2b4769945b95f7e1d8ca4bf592191c665c1cc26ce94c65129c8e8d83fd40d7e7481ebf138ca8c954f1ddac7fec92040c5aebec72ea238bd2a21d6d75f84ef4b5264f27c5f904dfda0f94cedd2f45732a530861137438f9a0ae085c997c550bae5e82e0343d60daa454132e9f8eb090429fb9e0371cd0ae9f1c9540cd6e5e78c9b8f19bfb51b8dc43b18d294d498fff78f46ed73c50235922cd5624724a83a7f0e06af0508d92516a071f3093e3161d83e661bfec6326ad7d3d3bdd6817a04a1df3445b15ae193adc9d076471b81323d27ef1547903364c11ef937137e4ac37a66438f5dab29a31c3f4169ef90d95860a617b08e31a89e4cf730c4ae88c8b1bee164f40f207a279d8426ce81980916a808f62b9d5aff970e74f207451be9f4a024f9b5b6a3ebf5280ccf5c3e0d35d97952929e2db5e72b8210441dafb9af814b2020b42452c42ef6f002c1820e861d333a0721420c6d55e9c686b34adb3d201c675d03fec6f34d745823d3d1756dcbf3971be4475a01dbbb2664045c35425b232736e25176014c335bd8baffe36371699444c5dd9ccf4b3f72d7df7d44617a93c975f34c97abb43122ec6a5511a2901daf80358c1ed5df4db2354476731f1265161c104aba10e968746d25f1258480a720ed22ac9b1f37dba53bc823434c0a91f7c9ad3ddfbe5d8c510fd773633a7720a2f8bd29992c005f6a649bc345ff00ceadbd7eeb033b596bb385d968bae2b06248a8179a412a920512dc51733a0ea818e7c80ee142380541506b9282c1300b73a474d1588d58d54aac2ac7652f042a8da58ed5138abf5e3bce819aba4a30e39ab73c840e17647a7394fb7bf7493a26f468c9dc6edbf5419e21df8a6dedbdca8e5ea46dac514c1f0452562f1684a73dc440aaa61a9028fec260e24c67808cd327dd1721df064b1f118a060e0236c22614196dcee4a8b9a91094d7ad57f46c8ff2c1201a8f341161fa2fcb9fae9c89b573cd27856352fab6f3a097f734546ed22d734f74fe6e7b1b1610a3670a0b6d942a93b7777cf1362c59472cf4b127779c991922703b7353ee7d619c17e5b34eae27484b0ea91a582212b79da22487e854fd9bc6a619285e70cab32e80cb1be33480dc63718bb278f0e622e3e3f93a451019f447c30236511fa5c6c12326d2de79faf852171f8882b99469d2123bc166a1c02800d3aa4391905e6fef44c5b25badb03de37e2c94bb1763fe5bccc533e246b42326d52cc23df4d62e8f94598119d97bb087851cb433ab53fc3c22a506cc61dba15cbeb03057a4ded15ee3bc7f69f2b2f24134590aaad38e3b87c7ffb0cf05a88d294980676e8f231e35df080a5dd697c50d166901b94a4244a8bd78a189a4d057e80bcdfc9126388ccc09aea2c127a4374c5c3110549a79fc3be9fe9a71534eb68eb7d738bdd8a834203f677023b75776d7c84da68f4c34bc55fce358d7977823ed745ff9fd5ea5c5cfdc1d989b69f5d837e18096409500e8c8a4a91e69240fcb7f80dbfa093fa9aada48f15c723cc74612eefef718ebb4d3764b2acf679559b54d6bcd12a13f696b6031b9c81bd40f1f286899e05a3c5ba49740e7ae012b40827cbb7f767bfb96b35cc7a3a69a126a18ce468f2379922b31db40662bf394c32810fa210249a45e864110d9e169b7e841bc16aab2500254c4344a63d35477e4274b7d5264c5a0bdfbb7341306c9119ef7ad78aecfa62b3890d30a21598517dc32ac9ca451fbbdea2bc28cf6a27797b5e00f308f3f815a94db9a2909e781b4e18b710359dc551f078d4924c1dd2e0c0691ce3e0d5f8a66474e2d3c35ec691b7613f4c66cf65fd08b00b3bad814096f60a94e32161335baa400abb1718029f82759de3202bda12d57a5a273adff22a1c40e5e537992e093121cbec53c85cc02109c5d812bace3fe854cab4cbf4928e5440b2b88e6b901c36cd63bb5519743c613d263d289672e60f3a5b35879ab15ace9585a775442945b68d6d16ffe00e4682aa69b2d198af5c448f938dd99e5811767818593b083de17c5372833a154fb961e6d5090c8e4cb6cbb3b828c5b4c6f31d1eea83441ed7626d43720de830efee41fb58057566e13069736df62eade696242681cca9ddcfc87840089754aae098e0d4f9e45566b5538a7da0c8e5f5fbe1aaba6606b3bff20b8f195e072bf5da1b956c73de6e4f14bdf05cfbe9ffe589d29d99303142752740c3195e1b76b14f6d5a2b8b6ab0f1ac35eb7f1132eca3e324db2984bb8556e02f6597dbf7d9065bd6bfdf9040181ee4584f4f477fa701358a965e31f65f78d8888689b02d388197ac937516f437308ac44fe10b7c7d31e71c18d5f2b13bd9762e63136515141ab0256577121c02fe531df3df23571af421cbdb858c9b7f8a4b4440514cf81773298de153e360cb45a9722ac8e940525c18cbcd14d5e0097220fc65fcf87bf09fa850f86da933106fd413c068c44d2e8a3e394f994990455a678538f2cf27a9ba22455023faad88ffd95be57060fc5ba61319bd4371c3966209725a2f31e47417820e98c5591be7936d011487f6124d0775a617ac7590669354c3641ecf6aa8e8d52d635a44f9064c8d030434ae9a332a20e00be106f32db1e4ab5f1263082bf6d1708c80cf3d98f03a5ce2c021a67e87a72ea4350189f87b2d97aa748df9b8a70804c6356065e40e41b757ab9208d05ddecd8f92027a74723f84e25766203ff61b2b30a3c5fb024a8566f57d1648d99a6af404db2b40a4a534395f6f0ddbc2ad6c359ed412dd71b47b9fdd31433bd66cb50e035a18197529bdc2ca3ac7b3560dc4a6897e76332283d30479ddf9ad557bc04b51857fb4fc373fa142e4418d562313b75bfb5a78bc5c3f1e09c72d98e7b575f0d4159efe9565bc945ad1a4fa0b33857cea176528f4f8cf0b74c8a6e1e448e86cc88c71739080c14a641ab48d5ca9dfd20b81f8469d41ae8583b177007fb8d9ebd467296932cd144a0b92eeefc3f45805c9df4e0e889defa9b3618214672b987a879423aec587e71f403962bf87325ba5b40945c9b9eb0afc8cab897cfcaabeea12a7cd5c96395605c58813c50efc882b2af2e4283598f27e84c1678460e2cd0feb4b2423c82fad142b5f0f551825c72ec5b0f49a5df70c6e1e8b983de5018ae4ca45bd337dcac47289dbec0fa7b5211a16b3270f9e4d1e9f9656efe1a0f2f79958331c35a2da989f7ba870477383da37a1467a63b871cd3a3be6884dde30c0c245dface93adee9bcc61f4f3237f84feadf4ef3e854e21f67b6c8cabef43bd212b2763834e0909884e6b7248e5d9161981806a0c31081f2de37fbe8240239d80238f87b9c0a3329f558d6e9a4b905c53ce664c237c22f615a3a0690a484fa492c9f42b101c4698e1ae08b484c0e3cf56282818a8dd883cdac020da705fe73d4c56ecae776504fb20feca67c911f737d0331d2e10d3fec77fe16b084e6092464a58b086e11727fa81b130329463ec220987b26eb425f30442c45986ae79145578f65c7fdc606cd12dbec2b264a05b3e4d94ff58d9474fd08e3fe04eb4cd1ea91ca935067aba8043837efd02d34b3d94f5de8fb8ae2ce1767702e2523472ec400aaf5a1a95651a12f1fba47e6f10dca6887f5c10774fb9ce75d1043e141ba13d51c22053ea868f0c75b485ca50ad99fb53afb8ce68fc8a3d440b10278b0fbbaf5af1ae5e6ac2a1a7fcffa340f67fb8e3e77970263dcb6f8f9b91863a9fae407fec82622b36ee2f86f3d6fd8d5ff20f5563c2bd15d514397e8dc1a32fa88138270e2707b6478e75afab0095038c62901c7da7b07b1bf483ff13f17d7e1ab56d306d0d430ec4899855151d34e499442a90c358880e111ea8db9128d07ceaf750eb41a455529d4b7f4d6749830dfad1c50bca9cfe324919207fe7992a0a164e8c169f8722b2ff1f1164b41dab9f554c1e6c5419ff2889efe6d518b1eeca13cc6a2a67aef0633f56b15f6e518cb063b580214f81c40e9e64174e880335717b9ce1dba7a079d307de51f631539487fc8b0a305adba90c59eb85503fd4f8be8d8d065686665cbd3a5dca64d210a2abfe69880869844dee2a6ba2fd6a858e6bc13c9292b923f1b719901fe5846ee2dba2d6a2c2045ede39893ab8069903f5a5a7b4f14c07a595fd02221b09bc3962267ec6ec165f699d574e676eb7a110dc05647eed7fc61b688d665d528613d068d147516f08d6a054b19291a580b0b73ada4ed91b1aa060dd1f5bb3ef196b1074fa4988558606fc1e8ee3d64cee1c841a2b4ac12bf94412f075b4c3ab81cef1f0bad6e94c50a2776cf09a51483c20e6f5b6ba752dcceb19372052fb81ea471db63bf411f9c45205d751d36e570cc9c633011bc3ba3fb8635ef8f483419e3f0be31168f8b396eb0baaee18f485926c2b61efec2eb7cc4c9aa07759278c7e5740804b5879014c3513f8f1838a70e768035e2c20837206c1894af71ac5ac88f9a82a3bac49d831d8b6440f892c68c2c2189b8c2c4568fe9c8d81866c664d1322acea6818bdc5b38c1b1f520bb18ca7f80cdd1bf134f12764e384434d81d54326214320602eddcc0c09e082b019cc29027acb45ce70adfc495d0fc9eba568d30876e932e6e278e7faf53b6adc5199464dc816a95575f8c3913ed57d846cca69b7d90953ddb21e7afc8531e62ae5837e0701b298a7e2e050d5fc8b736b382e7dc0becfdec7e377240262f2f13ccd75eab871c633e16438d2696156cb0f0b3962a393da240aa0f201720a9353f16ed1cc020039f9d5ebba66b1b9240446f12f20da9ef5006e1bc8ca54daa236763170470f84a2d12d497d14281963151ee2e6283ca888985aaf83718bc6c8063480703e55589ddb09384a01f2d12770950a328551b61d0811778110dc1da1305375838033340a6906b7c3182aca2270bbedf34df7796ae10f9cd6627fec7594e0bc1c13cc4c8f3b19c6479f28ac0a0990511ac5117c4e9ee74436ef53ba227a6d3d72c656870ac20432db92732cf6c46c8be660748ff45cd82a02a932583469a5368ad826127391a912c4ce6ef0113a39bc069975f4c3c26bcddb6e5dc843c4d44c607b05fd224827a70d7e526eeedc39cc459faddbd26346998348acd3127a2a1bb07607f675deff57f9b834a5c17e897e2a773aacc483458088c501ee9996b049a4e5a0f5c9549c64273301b4bc2f4045ce1ded4e4aaf557211dc5bacb1217402a668dff105988a8ac63962321e9acc3f2ae4cd8134a7ba06a83eae41c1ebbb5fc2bf7e1e7b0054a8455459c2663298c9d0548c544ac6aed1f6fa6090bf933fceb4f11a6388f72f25161908bc7b805b9e69522cac66cf60b1868fa16b82d90a94ca10720c1ebe492c06392d111fc615d9210fee237fdc7365a2294bcd781fc9a0dedfdc5a92d9a80949b913024ed65da5c89666b554fec111cceb0bf100169eaba82cd3ecb6422162b3bc06cb6c95a88a04cf42ed322e995ace64f98403ec4c8b5abf9696c86ce7b6f9a6f314c39a9c71bdb5a7e731d5a5d15bc9abaa0eb98ebedaab1034e516e7ba3b757acf6486f1de203003b34ef8bb0026ae00b25a96ec889984e62bb09aa194dd419d818f11e90","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
