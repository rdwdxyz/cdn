<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb5008f81273faf652a1f8ede9de156a6c5d24ad13d57ba613f19255f8356872eb04719b2381ce28d9709262427c0214c133adf8e71e1b42e816abe8973e2e84fb1b254f238f258b1dd1f2b81f0f95890be507100a59219177876d07be71673cd025cab56458a96b4a91f90f856443d979292e2a9531fb94b1cd4174a4440d692a3e207a7354394e7c5d52ed15b7096356f5adcaa1b98d4a73f3ad9030e0b6622f6b844770669d9571d0f1f3e86ad6f5df2c8129dcddcd17ecd43fd38cf88c5d06555dc40aa86a6823c2f765146206d3c5da6ce2a633094c80a20d01f567f802ae203fef305f1c7a15e294b50be6e7be2d9cdb9c8e74feb99fe44ca7bf4b526267b42fd4f7fb16211a94df9c949dccd10da749a1a1bb77fb286b930b1e8c4b06081e2df1b46fd79bedb458779c3483eff9534a1f5bf03d4d65010051074dd58cfe59fc52f41bb1ef15a21460131ace9e1d8a7de6edb2204c393b8cdb8e4ca36190baa44b7f0b53a5ba40840e07f74305d7e6b2398a9bb05c4b8c064aff7f3c2511e262064dd33de2b5d02ac6a0b0ad1fc714c545b44614a246f8886a773c0d6e438de33b0ecfe3937fb7f6584df2b2fb0253d0adb844ead7ccb448cd8910867ab4f36aa333cc9644e1987f1281691cb873251bafcc365b93347dc1a488694537838c49f1cde469e34548894d50425975d44e7b1e8edb2e7a02b03a632a3eb9db89456f06e6046e1770bcf5118f397646c22037b8d47efd0736f98b7d894ece2b6cc8b560579ca7e3a1a1a725b9352daccaae68238592a69e576511215d3b42b5a07de372d966c2aad3c235a8787c255b86430032d8f24790d8472d08ed84764a8be9cc9ce57065421edf99ea46ce96492d798ef40fa53fea824d8b5eec66cf84316672e515d4c244170c4f00a462368ad6edede487c25059a9acf533567e2c10fb9a8c5b7139caa598bcef720c3c8aea903052f17cac10e7c3bfae8ac1cff441fc81a979f84a4e013163a8a89768e956574601d04d3c499ee7447b4f4e95982705e98d03e64f518550d6cfc1f4679de814c88be1d64ea620280ceeec1146ca074166f4e6f9e22724e0b51c99d694a77c664585a930f19783b5c3cad30145d6fe6be815501e9dcc2b0b98eacaa3799adffc72259170f5b9bc1e999be10e98eb856f432b9f4f643dc66b8e451ea1bd835c2e6cb5f0b523c06af50853b351619fddf77b480e72c356bd34b331e2291cc56f215aa7cbe160cea21bf2b08263aec47d1a05c730eae558980cf7b46b058f36d657b0b394351311f1c37dbb18525540a7aa1b7f824f78df34d4b1504eda0080aea775f45e55e8d77aef599551248a7673c44fcdeedd98cfec0de8d2c862ad4bed04638ae539b721eb0762016d0b44b20ed61424df090a3cf868ce0adc72268c6c4dc1035a3b90afe65c6f75583febe51e9bf44a9be4b0e840dcd1e85dad50b480bb7706acbc4997f1b758ee22b0c4ea91ef5d869f285e8b79682de3686ec1a551f1b43b837efdd5664ffa07e32b8d28c9cc5298490fedbb053564cd11b83d320886775ac7a195353cf479657e64cdcedae386c32a5595081e096d88a7466edea8c4c2f1c4ff14dcb21adc573bd874ac8976d02ce7c71e50f9a2d5d69169fd61e7e4e5c20a7ef92502783253e004e72c5d89149ff2d6d156a32a9932cb528faa4095fa5ffeeb2ff00c561619cdb5f4fdb99ae19a41aaff19fb8e35872c0b0902969ca9708b2175ce9dcd0c6461f8eeeb1325fc5a17757dbf06939dca4bb90fc54d6c88f43b838f584d79ec558a7a989dfc20b520607ae0a383e86d358ed58e218fed5e8d7d9e72be99117d03d0f520bab24e7d6bd1cb386afc59a9598695053e429eca033cc2881ada539dfee90ff2f52e99c3af59e1525746b674a85637a70546347a773cc63f487f694f7944b198cfd686ae664e5515a60f29ed1c3bf44f2b17d894acfee640f2458127d2886af5c2dffc9dca0eaf716ce456138bf835eb33fba745d719b65bb9c8a22a1d160e661bd493e2d99bedc0a1c4d984a0f91eb1b74cd62c3510869a56ade9706593f12fe7ca70017180cda432bacd230a955a1ccf86ce98786293ea6b8e95840268b0a3f4e0179a4b6697e732e062aa9fe0bde6238b32921158e567f18b2f7e12e2323d4d36b788b06027fcbd0c67d405ac858aa0bb8854d9be991424f4ba79091e3a36a804d9b19f95e38c9a20f81d049c6455af37f9c47b11f71c5857bace92716019eef36ef12fa469939f072c2689309bf186619c76b78a4b57222dfa7503e80f0c7a3bb6f58be160abd2fdb7402650095966ddf30c58071dfd99441d6d7c52f3b121d05293611394293f69cf08afeecff38ef57f8d42c9db9a2227b8c3cd81d1dd20a4ebb727c174c419911cf74a66c482fa8a77424371a7aeedf7f1a4d844d130b4c4580742ab07dead13fe308d50f3e4b04676dbbd44feda7cc75bff8d4325fc8a8f86268ce8bf260a87460a10934341dde5eb795204434f398bbd8077c260c7d084071ba9ad537b75748fa93be97cb503b2c148a187d4050a33b0cab68ca39effe91fb94504c8a0f45143f3985834fad05b77d01b0ed881e8dfd9f941195d073c66d359d710be1e815356d2a5627c868ebbce5ad9f626f6e4f9bc2c8d7a2e72629560f26ef66f9bf9611fab6dc794c9e1bad86ae48c6615bbf2cbceefad80d6634b690f421533f932507c459257992d0288637b7a56e64ccaf40471e93c00eb8188d597fa4dd3d14e1f77c29c0c03652a00376eaede442077fcf4377a3a290190e98b872e7b285af712a8a4050eddd820fa29ed49c49173504d38cc3d4bf820944805dd5888edf2356724467533edc408043a7121471f00fbf3fc9ef9cf33e40e9ab2131b8172fab305de985b16b4cb1cc253f01a900aafca7a165640a3ddbc1506641840bb2cd7e487d59d4332457d88ae1fdb517bb4ce6991e7bc604e84aff711341f0f7fbc4b204f5c47212b58fc9f02cef0c172dac22145177fad9a71368978ca76149eb080e95d38b523cca2498c93822042066ae64ca3b4822d1db82983c536167f7f80b693d5d4d97e7f64eae746171593c8157ec0724a9d376cb0b6266c878a28a8ce4b194c57f06b146d4dfab0d7ffc1fa5ba3e5b600908e8f42fb792f30116ce8f51f0218dc4fafee4b67890d5daef38e7fe53224fbe23c9f903625a9e450bd6e6cd71d7509daa6a0cb1ba5762edbac1774e7533550dc05c9b0a8e24da9e908b8777e020388a93e24e4d35c5e761fb2bb37aee4561d8b27cd4dbc8cecc687610999248587ce4eef8ac818039014575fb8afd9b6f57c225af9b32fbd19863afb2c63dcbc29634580abb5955e8285ae490b8987e737fefa8fba4eb7cc9aac069a17275de10e0282560f1436e683504f54083184bcdf6feb3feb27996d498d5855bc2f05cad7fbc1139e0fa809c8578700faf8302b4fcd3f2cc7dde2923613c77693993d067271119596d8a8326b570e5099e1a0ab25ea8b3daee60534f02635292901ad527d6bd5976b4d194a8ce99d8b06fdfb7ee7f60299894aa7c1615b5492eed26e35164a2854e79ab93b0b7e9229a71ad3628f7d355982137895512068a82173cc844aac63bc1a2521c5b3a24b03418119ee72372b0530261744b36d6214097908e721b5b923194de33cfc465a88d2b46f1378ca95b1e3e307d715cfef85b002824fc313cb189ab05b56e1a4ebe1fcce283f0c22b8c2a3e8a26e82568618586b5ff6942c9dfe4faaa991fde2bde05ca744c84cef1b75885f8dca550e20d168a88949e44cdb590c49fb7eeea0323c764e923d2b69da750852cdfee619250b5347475e0a6cd87c2df8be91982e461c32899971d2dd89ecac901d08ba1e5916a49af1c471b27db56cf2af6fc9e43a773c105b71e2a7d67c081cca0ef5886ef85c2a7bb7f145319f473cefa9c058a1b4d190a070e5284c1493ba825784d7c1620bda00d258ac28bc58cd6d08bfadbee12644e76a415389628880acc537c84d0039054558cc3442142014f142471b24a2a8c41c7fa1627ffb3de4ebb8fb7104a3a9c0976291e13fce19a004b7784eb20af849a473b1d4ba066bceeb08370195c1cca70928969c087e8175070e8640e5665b36671d0d31dd1d654c8275150a583b595f119aafb6048520d7e05bab52b7cced30f24aacad74498eb3296246db864159882a12f756a33366bee9c991dd8ca9aa170b8301659a6acd221f0574d3bd059af2d3dd54cf223365eef5d58f6937f526a177cc10c9b5ad7ce37259393c319ad64cbc4fe6f29e75cf9d256b2bb505921b6e59ab7bf4c5fd451a302f34bd398b3fd450a482b4487f9191b005da9c17636c577753005e81e0db0bbb7648ba10079ff42611cb701355081fbcc8eca37b1105902fe5f53b2755c06457d00db3d63d04dc8ae761f0240befa232ed850290f1e98cc619422fd4c4204a0d42afc7acf0ceb23473b2264b8baa8f64c4b2e942775b709f33bc5642e7cbedabada16c474601a71f7283f2a625faaa8123a31babd1f6f080684120df7ce29ba10f5811b134771d0d8bcabf435da515b6910c0540d35846e9d9f78313cd08ba3a5da05f1680c874c10ec3091ed2da5e94fb0bb6c8459f509679dbbc8d63dd64cbe0f754d99b269dfd55c4b5bb876b05dbf319181671c45b10c41c6498871dc514a37c8fe59e8fdfe572801bdb94099265e2b0881d0144bb419631875a396aa4e1bcd0c07fc98e81f601eef4eee0d89e7c305f1ef75868718fda80c015d1d8bf632842ab11fe92e8698a9d2ac003de829c7ee578ef8eefc3aae7dff3add3958d77f5fbe18f6c760425a7a7721d1bdf822d7b60a673f7606c33f1b827d51c0151b5d8367b97e3c78e47100efbe0f5d5d8d71c830fcb9a0d35f904aecf49221a4b4e65ed625548cedb60e12726771e88ae84901c791149b66ff13f40c099c39853e0620cd24ee028c14febb852f0f252a03e538a99e83af6f314e2731f1f1d849120513dbfe6f97a7c08a43115752decfd197c2518df70cf88326537e5996089baddd02c41973451c90f5246e2c24744a2e662109d2cb038fbaaee903c67d332993666950e358f154746157a0ab60b2798af126fc3386336eadb393e6a1b369d7c7f088f3bc3b9c8571f3ec8c218c1c4d18e374b2775712ea2d2173aaafc475448459bb714d06cfccc42bb95f5be00b45bcc959a9fc5691310e251be54f3c670ade27faa6bccab97788fc5536dcd5d6c8280c5b0f5a1e6a97136b9ab3ff2dd5244522a6394aa0846d58e874c1b1e0f97e7c6f4513a852f79f8c96079203e183bbbae76ed1a69fa0a2904c360690ff492ef45ea9f592b4f32f7ad16fb832ce99300d1ce067c39460dca46e734ed4001f74b1b1ea77d416ca8f6d6f7d7714aea8507562565426578b96fc090115d594090a43073fc3e3ef0ea44fa20fc47eb16f17488486f17829cfa67d79068ce385a677a7c1046a4046c77b48341e0e99a450c4c34fe99a8230a2e68ef4ba3e7be5eb17bcda9fd9ce6ee3ac73419aa24532c912ddebcd621765696d80f083d17e78ae1a4b774d85c22242d98a18e0530f503bcfd3ca135f8b4d7bdcfff9740a3eab36e087266166ecb39effda0e546ea501f45d5e3a357d2ff76f72264fdbeb58a467cb4143ada23f9c9d09e2bb1c603504f75aff5edcee9f6b27e0f15ce9172750832c0708e7457e71b5b190732791e1653211e7c8bc598109b9b4fc1028cfd055a3b473b36f90e36fe5eccca6c974463582b19719fadb680f00c38c1d0265bcdee29a9d8fb382ccca3941abedf11b1c6273d31edca017a1b859a61347643c90fc6c99b6e33a69c5f28de1b49c9f4093ec976b20755df8644fa930651e22f7fa568ac4d2d4c9db4cfcaeaf354dd1c7b8fed84e666b3d9071390a3cdfbb58faa0282d88cf2bc703c12a301d4e707d5aa2dd58ce24415b082d4eecf5d897393c390eebce359ed7d778936c3d49d56e823f459e9da2bb5d5b05fcb413b77cd84f4608e9b87afe38f89b12ebb77ec17bc710e75db88edcab46153736244baea843c1d5d3168e0c1a2bfc52127f30073da7f1a0ce4cc4ea85a0e360a594cf8fe4a7a4407398a0558c5e78ee7dfb1855c8311a8093ca917ad9ee3fdfe466206ad169af154ad553b3ecc804f350bc5361ee6e8a299f589f3292453dd83c4a2da4306e86b36d2125d3955ae1e006c871573082edb3ddaee185c177db5f952c998531c7a601fcc396ffce2635142bfa79fb1973f00b3043d3c0cf657a10757a425a30a6a0dc912101dcf194cc51c82c60a31618ccb3d07332dc11febbb425b71a9e31e32afd8fc53d33dec2c8678f365b461797d54c08955b5c5ddc1c691788d56fa96d22edc3e6da515db97099ed9d1091577bc3020841cba5862e2d74fd1b31bb13024ca2f52eda0b1b3189d0c228a1667ed199489dce0b4c069adfe162bb4a13b472481ccf526aa549657e9cfa409751d8a3db982ae6114bc9819ba04178fb41187b567974051248038b3dced2a273b59c8fd4b3b22167d0c0dd5e5b46788e32077d3c9e6c34f30162be814f691758b17976e4f815e7247ed8df7e80054bd7693a684cea745e1977ab9cac70fa4189efb8935534d93d7e5bb40199300fac788f8500a6e62a2adb6b0fc09db0e985bde5b6521dbdc1c79241d547c060528a6f53d48dc6274bc8c3571f44322d30524a6184c76eb289269c969e3df1e12f53231887d0609262257dec1cf22203f5f796533b3b3305342752875d09ab97eb5f3a41d7038fe9a8631524db38fee5dd17da26863bc77fee549267ed0ae0257cfc550c0217fed2e37ad947e4cdbe408a1ed01ef85506dbd4d844881694c27ae0e7191a61a2cb529a937304383730733d8ae35511fb61fbb4cfe2435cf3199cc6c9176d86f0e0d9905bcf329f87affcaab299847d1593dbf376bad777160f6010d2e29b64e2e92707a80d648644069f09026033e125b74ab7a0c743b229fd47495e12a7baadac6b6a97113db5bfcae1a8db9f39450c873dffd7d221cdba2795c3f433f828698bd2c3b2823999357e3fe7329d10d6d0f8e099d6d0161c674e50af25bc70e8ec71b42f1453671040c076b1e7a50a56e82510fe62e134f51f1e123525d2c9b4927de93be3a47994db62d49f5b10119c20af2e0e72ef7952aa74cc73f4dfd4cc27681175fda3e559c42ab4a16d7cf37738e9059599adcd3b2eec78856a6d7948a9a2cf9bbceb0536edbfd0a49b25f088d4d5db62eced381ec7502feafe3f78a487d8c7878902d79a3642391dc128653340ccbea648db52b921cbdafd69dac0442ba6e364dc56c4a39e071466001eecf5db8a3e45d25c46348d064a7811acd993486628b30358e306f9f828499de852eb8e030f5b6b7ff3653fd4b9c075467411397241a5760cb06499583e1f5383ef2295086c8d692f1dc3f74b61a40bb30c03df5ec4fe7afacbfb50e538271e8cd3d73b85d86ff6c3d3bb8f84415735e7b5163a0e9f84ddc52a470bf7f1954c204c83cf96a6df47d45930549415b6d09b5e00eeab9b7f6bbeaf12985973d26ec5ed4b7fc0a118cfc6759f7f8121d20b0017c7bf81fd0f27103cb11a57f34b9dc5e6b4f57ad7973b82d6b29038fbafdb256f907672a82479243efa859b5f705226c43e05acf9ed2d0fbda175f47a7025b87543ffbad452a3670b32e9266424386e618a75f8c2a9f1b129b01c1ee327dc417761c4fc426156c9cdcb9590d1fe35bdd19fea11a67774a0ee40057c4b0ccc54f53459ee5ef9a9d6ae3e0058a1eb1cf568bde64ac664b7ecdcc08a44196d6ae7d04a821a82ee948a2369dddfa8bf910523518e72a0c6575a37a8fe73d3e21a3d33ba62ea81e87914d40d9687375e2457f336ef94a804141088307f0e5deed0c418bcb0913a9f678c41c3dd5e3ef950574d7c544e88d1ffe8db7131c20ba8095424e7fb0c8342f624146f33f7c3c8fb9b5341b7546d2719d3527ef8248d220cfd486dda1bb7167136a574c8b6369cd14f41c61c0b1842b420ebfe63ba6f6f65b3c7d907425680af7ac8a22c6e86162f63ba1ec9abe948135fd9ee64ca8e9cc2df54c1f82d01120f814004fd35c2eb7a757c491a7471beab519346cf39d0ed615986f110a8b3a1e49d3e54dc07f76048a7a151b2767374e7d2a08bfa63788973900dec68431a6a1f1df1db8adc45e2870c6df7f6d80577671c27153b32cce08f9e5e8c506f4a61e5bfdb39c21f12b0ebdb6330d3f7fb18c8f315dca0a53cec214a239dd8433c27cead9f13109b23f46a51f586f5a072dc0928067ca44e42b091065c785bd8954b0e0ea67a41bce2514d9fae9551ed075c3cef616ac364dad46f50bb3b2e77c26380514c1b62cd1a3467111cb8f0650cd836f2be2a10eebdb0aec6c3863762bf7334fd24c8ac04d62308023df072681d38b57978d0102f936b81a3dcdbecfcb611c9debb89c15946b39b6440126a044598d5f7a2d60964b1ff32cd1da63eb33e38aa430f7d948a1e949202103f6eac028b062703be05ee5e99f6e305de0aa8e2bd6153dcab7757eacc7a4a26e6ab5b24b342a1ae24b7ff5b32f2de354d1f2088b86082b9711844cdf307b581c01dbe874b40242c067b3d0cfe40ea983e1c658fa3b26e558df9229ff3e4d2ee6d86c677c9a82f785005577b247e0fad4fc1f317c107a260bc355f0f030f253a8eebc9e13a1792f1157014f7f4b49f761111328461fdcdcf51af414eab7ce55dcfc627a6c1e61b3344cc9eb4bfcf1387e22eedc315840dced20d7b12a6b77c65f4d401ac3cbf73b28d4975e66a20db8e6f62d24e0340d506eb877c2ade5f0dae28e43f8e2d40236a44a6315c077ff377bd4f96ad13c65066a47f1e8c05333ad9c7949b435491f1aaccd8b9e517d497a40a5f8db02937f86c39276fb01e0c1ad646d3b6b27dadad35fba990d60bb56c480a5bbf9e9db9184749fd5b2c4a9bd9ed7e04ec70c5442e4ba2310b91650a46fa3403d040f1e2fc324221c436518cfaf60d35605c5aa09ad3a150a346503e55f1a7544812ab3d091feef7f2e3da554b6871d8d9c497a76d4506da39f43bd4a7aea13767102efff54dbd0a94fb03e39831a9585a82005bec7d9e8370dcca444439d154ff278cf88656903175bd9fd40270febe20d7af483f8efd33c0873b24f5a98c4b13777c810a154ec8d7063e0d85ff5f509c31f7e7d1bda327fc0e87afa03ee39dbcde4ffb3c333e326c2744ee191b5607c58f54661cdac22504897f2cdf30332e1de32b022acc366919e13e8bff53f6c220072bfac292cbb2eb9ef877351dc92e61d78de27ea30e6e15d4e49921beea5215d98ca2d097a5cb8f908a6e5a96247f469ccf3779aed922a8b1c280039ad27eae60dca249e70dfe7560d052d05f0166d7c79d93826c2cd24aa4f3b55681ae030772d43524771ea6eefb7234f74f738adf0cd33c3c3fd9c4f73b8e3868a0860394383b2b9382ba679bcd17c3e6cf33bf3b7dddd283f5e99d01681f8e9149e250af403464f26332cde74fd63d023c9d216966f20f32177712ea67cae25d97d25e4d97198e565f6a2d418e38e1d41013db82a38ad2f64c3cf135d1c7bbcb3f09aaeac4141b654fb37ff41751c59c7c979615c7985cc1ecc8555141ed4afa6b2c238ba64632f387eb8b3bc133830955e97ed3cfcf5b55f2705fcf2d0ada45af393ece3536ef7e67131cfdd41ebd1fec9ff8f7d4c987317e490f44110ff53171cc8b7b4f696dbc0a2c328d6a691cb5b92ba8711880f80f9bd3299a4e97c0e5843e7d2d864af395da4c68d79b4f1b29b7811118d28f9ec9e6b6f4934cf69e0a6e81dbf394424bb0c8d357e6b6aa2f97f85e1b93197e6cc77c7cc49b540ecf3303dfd433869eef2cf039efa961dcb672240b578af66429d99a755cd7ba67975e4ea05e59602db3daf5ac67a8af763e6cfa66a2cebceb537b80fbcabae0f91a7623cc04b7833f3fad3f4abb80df5477691015efa9d1e7dc98421f00ebc4599b926f0584f857f38b24580cb0fbf6b100c4ad6efc15e65b0bc8c0f62379dbfcd161d8bed460e49e29ce9c4a7b771027d8163616fd4c368bb0d73d46944925e561c18c0cb7d31d95095f069a4c41308d61584c12f4a503736919f55de5134518eb37b7608e6f8bb0a769849a54f2d24d9fe190d2271af0d4f2faabd87f8031fc928796a02ec812cca317876730a2038058dfc0663d2d4a8635ad10825f135e1374d6baf84c521408ee781e0c5f947f8c15dd3fcc8edcac8372a4114df46bdbc5352169888743186afc2dedaa392f300a9e782d21d37b7db1f21b0b5e4413c4e30bcb5a30f5b4fda38d162e55ec65ecf32bb0841736edc3b06e64e70f898d30a36096761001baf8339e83f5307792a9f315d6c065a5260b2fddba6f675165adda5772bcaf7485aa2a5c5f486448051fb9ad3ea7137a63063e658a04a3dee31fbd3d186dc183b8291e9b5a5b4b8dc6ba2925c6bd8a664cf9bd31ae657c3082e5e65eb0d87590e33643563003fca3d835651b842ba539a9fb62016a5df5f19c6a7c1a7c11231a3fb4b39fb2ce9a229b8f128c3ea0b883563858b49bb4b0f0eed236cbcdc8a1c9380ef7130e2d1876e2afaa839147eed49474f8eaefe5da7a2a6c3161fe16d9d27cf1a2da0d887f45b94ce7577228729fc25b8070be4f6f0a41c346478a3f05a1281c182f382e62005062e2ad30dcb55aef25a35c2afe9b5630924848db6b79a804d18e2419a72b5f5f4265c3c21fa69fe72cb6d749912ea90d395a5cc878f6ec30ff89a72410858e68798fef3ee366b181792750f34bf7f3379f3e6a70b55d890d6bdd8074863f24c5930d7647d711a7c420ab3d1a3f66a32a2c413b542c20456c1b2d319d2272697fcf2ad6c9474de4d5084061646dd8131bfb0be6d3b999c60fd7db3b299c8de62df7fd92d167dbfdf3d61eafba26053b4d2b1ce04476af32c7af68424cd97a41611adac6e32cb80ca6b3787961e95ba6a0b56488b7d763e2e5f48fca7ab35067e3598aa7d960ff8b522dcdb9f3b72a195764a64468e855b8bccc758be7dc279199a9599a16607a973c4dc67e1415f2db04c415ae07d8eecb8ae0da9188d40913cb2ae55b8010efdcac1d4d9ab0585dc6a6fea3df1d2e41635c73563f09875d70dc3aee22129814860ef0b1e9ee34a0b409a7254a65fa9dd4ee47a6d1da82ae028f706b03e8a43d21048152e37e12308ab054e4b8e14c1f5477ea37de85c493037e48e353138c957e1575d6cb140cc1112e5802cebc4b16edcd41a72cfd017a72e0dd4fb0bec09e543f8fe034eeb42750c9858a056179fd34245821a7195f1564fb6c3107ad975ac851dd60cfbdd814421a6e2ba8b815388a013610e63bdb7f7f76789dcd2f0948a092772212a0aca5074252cef36f649a38a6e0b9613a509db23eb2274e5eeda6d94e0341a1e77c81e492979d1d670355b925e4f1602ec02b4ea69ad1bc71384675495188bc13db000c91f5af23d4699c20d72aa297e774bdb928d0f1edd13a0db70432571627e73acdffc1126e221789ff0790d81d41b7d7e9e0ac3541a8f1853f0b71059f2a8eb7811b031eb83d6bce4ebcd0a22d1f23d20f9ad57e5f63d1bc1f8c69869ab2c1b14157962da1451c431d1d80104f3657c68db608621e2f733c188a3719dda64e9436768d6eeeeaba34a291e66638351a0b3a15d6d2b0b8abfeccf6465de005480c255253d0aea0a638c94221a25c2dd02c828054f0dc0bcd513b6cbdb36dba978ef59e308059bcb58bf60001b6d6ec469c1f025dbae2ead38e733e5a476ad9ebec60eaf59271fe101fd18b4b8d2eeec074b8bbc686de498ba9421a2688d63153a924eb68a59fa97497f33d61fb3c1e3ff32a6c058fc28f1eb671edf2b97312b2805d7fcb04464801140ad9d35b494108f3a5fcf264f76d30c8a4c317bb8e366af60b8372a3d9c10d9da1ef50cc12cf1018741ad514f485726842c5e265c12079e199ab2f90d23372a6392333315350328635356f92ed5c7215b34d1e35798944610edfa8ca528115eb5b09403a4be2c20e8ccf9c7e99ef299de289595e1d832bfa7e0ad30dc5bbe871d5e637c829d40d582d391a18fbcbd7c3ad67282dcb63a2336d6506d07b4210c26bec67871be8fff415648b008ab9ff8c3586fe71279b04ea208b8acb1c1d1e824be609a0100a21ad8efb2294ccc4d34889e8d99d03f029161776b6cfd4f551bbb179ec61934a195cbdcdac24363bd94df59d0b5aefdaae45b3fe54f2bf371c6c50345788424a9a3f41fbdecf6be9ea1b307642d02557629a2419f17e8c692e245e39e8c2cec9a408b9c039094d822c4128c72d7aea52429de7aa5536a6786843115931a8ddcaf0b1bfad7653fc79775e1327a947fda57fa5a621ae5bc09a9e2824c9c37e25f772096891c4e31eb501158f2b5e6903c1a64bdc0069552cc3cedf3fd9542fa805182c1478862c373397c3fc2bc51b2ee2b7ce5d9262d378dd84f4add2006e73273b4ff3a205d3d1fa043d38c8bfcf3787762ef5ee8e694bad6c6caba58c53506916b3fe9189a58ee9e27c84cd28d69bac1858202e9c32ce5db8fc09894a6fb732d72736788ac916867f475eb69373e29ffde191372fa68bacf2732785262e079533a776834d741a8c43495e6c64134879d0fdac348e60e9150413a7a2f56b4749ea0c0e06fe60668b51ea199b30e899d41dbe4036e1337623f70cd69b73ac2e9334f3569e866a026408c2367a1a829442c32175ee4b18ebe9efe57c7faab5bcd60a9c7c4422beabda5f888284bd292540640ca4fcdf18bc45cd46d2aa99952739f31dd1f30bf9735df84709d123e616edb511410fc8201da10500eae8e492a5c5ea2deb85fea84296a53eed01ad1c809597bc3d3d7720f7eada1803c2445254ade9b43e37961e1753299b5cb2d038d6c88398e822ec0e2e395fc15b73cc4acfd63350718978b96aa55423610c4de7e4e98097cf92dfd9c7dcbf9bf6d59138f861c7e103830fc971c7c39bc017001458c0fd6375bfefbdafe66c42b9cc813ca5912c5d57f195a06102ed3bfb97d7ce47d44bcd321d9280a2c05c1b5486b554ff50714ac7333dc83c4b9da4a49213a8447a13c3b2ac25018cb1d1963d1b11ef112c27a1a329be0ee74a6425d19a08e2cff94054160b29104a89fe9ea53c870af501d7e696e4ad2e5c607b99f78fbe72904549e691e7268fd0c264452050c65b0f982ea3821e0888fb89fece227fc235c616f3b6b82d24737d9a00c03df295f9fb65a025d2eb8fd5e590ec7f92464fb8656440065025701f89ee1086231ba9eb5511cf4375817615b286333de40b12a963e97dee01fd39b40b9080d082e36cac436e8d5fad003845f218418d53043070451a033c7c2fea1d4ea0782b0d808bfbb154abae9ce6b94c1e0615d4a888d02635b54645a7a04095f599a16247d75b4f3662774b03025a7b454606fa4ba54cb64634fd14f0a968481894055bf01628ac451b12ba1aaa4ff21d5291f97fb77363a3fac3081df2878665da7f52babe6e452e646d2ff08fac99e2278d508ff4e09ae454f0103249a3f2d86bc0d0c43eeb53a318a763ac54d54367a6cd798c419cffcb4ab37817860da0f0dcda970fbaa3fdd42ee688ec056021421106c2913d1908703a9c7e8f0d0862c0c9c3f3a48f2abb5ece16b391f69bb3f260adbfe1a7b3097497a1ae526a4ab0510e7cdf3881a41572ba7af9edc611e85c461ab4df178b89d14f6f1ac2e2d76fab80fad75ea4dbc3cc15b41f1d46e6377d9de81453aa0ea802b3bcd39f3fda14143aa2dbcadd69fd918014a23606e5bed2c62254c20b77024d8131c19ae8b45035d58a1e68f14b1003acfc67e9d5e891f4407d12d0f57981597b8fbd342036431bcb7268bd006acf1fba8d8e5df9cdbc365ca7aff55236afb1c72bf74d30a3e04ac70ccb50ab1f5a17d9f85b41cb0974162c079e366734fdc62b1611e8194403bc570b77c879a574245912e58ef0935c996ab6d3f49b12edc8a0e94a3da19055ed981d798157b01f3077454551ab00c60e1e45fcd838f9600ca5d600789c2d66b36cd4b86b98a394469838c3b5fd0ea5ba6a0eae993ab4e1dea5173b1a2735c01ad48d49c63a6b5d5d9c2489d5c4e1fd25fbc6dd528b7d1091e83200e246e9f718ff3fe86b9be0ae74fc2bd880366db64d64430c5f0027253b49cf14fd90c185dac6de564e55e7567ef32347f48de6c32ae69270fa4382d0f7d2c109161ae37cb09baa8994eadf51a0f89b49a05a1a6076bddadcd0751c9d09d1c8203529e56189b3ef0fde441e51c4eea87dd41101fada9ba015faffe5eafb1daac9bd3a174421c8937d244448c605dc2c35c11a9a55ce94c6e5e7894334b254b412f480c7fc915c5623a37e90ca6292e992b3ade357e66275aa6a332fa16ed8129cd7bac2cf5059b8521dc63d205ebea0880ffde1586964f4bd0a0c8d68b3354d7edf87cdc4a98d504455fc0bdf0287583531aba9bcf55f68aa92bcfc9e98c136179b7b4ba5ace5abb0f9389340b2e595956ce03b259f898d2436d148117e6f63f90e2896d634d24bcd8e1f349859035111651ca804086919eff38cb0a7b1fc353b762a92a12310a8037e4b6851bde53f751a9cd721c82545fd2ac3ff319193b3a05399a935c01c6ab4a774a2ba1fe6acdcea96cd18bae29442cc30647f4ff30a874eb4b3b31e5d3b38e0d63b2d9df8bbf1bd7bd37b7ccdbf2a792a0dd94179a9676c7ee88a048fca0765b1601431787286ea272a49034ba29ee910fd91981516df918c268b40af9ed813f5fad1e4f1a90b00da9e0afdf90a25d009996749b5074876bb1fb2caf67a4d10785a1b3d8562a4127f3d29a46bd5e4e8d1c69305a71a155bfb7541e7ebcda6302ce75cd16b844d45f7ed560389368e3124881c5cd953f582161e107543895dcae3964b8559f8d85f1171f74bca9b6911624011849b36ff978810438960528ae98b9beb033faf53e89c118d28f5ce0713017ba96c6d8197d12d33357c6b8be43afeb01538f60d2b7b382341212e302424d2ce2765694eecbcd777200b2addd1702fac82a065a01b4847c424dde2f88aaf006fc275e511a34b35b0f14ea20cd5cb96d9e4d10470f975ab7150a8e54ee93746ad4d221997d55dccf21a09bfdf66295b429f57acc1233b86b22770425498139dec8ef941206d28c4ffd68f29f485c3f6470d8d901c362429ed049a081d4d1b0e6bc5006d9204e26e8f260dbf8b0d84c0657d1f595a23ef60b0048f52bfe6ae11da484c95e7a21abb7d45e7135db5c026558a659273157bd5dc62fef35469a2bc70fc184febcf283d0445652b626260890f082b0cc35bd1f412ecd4b5161892de55d2d0795fc7629994ecd976b848b90f3a233d62fbb403e30ab570d01a5de8226e06b70202704678d0a42a9f5500584c3fb142fb73e2c801110acb75f373acbabde0f13977937bba123d33b5d702384dc4acd1811a2d5dd51970f5ce7b5ef753d89318f1dee66b2aec3c7c09e2053e28390cd2826ae945d3d54069746dab7695e7b564f04620faeac6b733a1cf6238c8c8294dc2f093de3726740094ca8c3deea7283b8f6646d83f900ac36dd0e9d77fa3b559baba00f65181a2896417270f6fbf14e68ae4fc1918eb59e102bf93b0b960ae5571de4837696dc096918a551e5d39de7ba3a26083b96f67560e510713f41b29702c8506ae5b55bf2b39ea0c02f28c32cc5e6c8a3ba45bddbb121ac529959a5900e95e41384d0e513b7960f564bfa264114a0ea77372511b4040b3830270b4721e1448bbc22d96a6b96469c2a6fae3faf93d4f32faf74063014e84cc86c83f5dd47c73b0283238f717ed20db68b89c02c6c325f1d0b0c6a27fd2cb90a3605942d41d7557936bcdb0701c7b6402c4592072359345a837f884abe6c3a9aea17f5a20dc1dd945f4158dc640896ad4cd93e48dcafc1a50a4a884e6c5301e98fa051fd84039563b7017447242f2a4e9769ae4d43aa45ac04ace95d166fb2432ab5943f930169b7fd30baa7d76810a20565c00177f87d322eb5bff2de4bf997ed9497989a786a08585763f7c87302d2fde925686fcc564e49fc443851a6390dcf6b810d84ef5e9d7b5d67eacf2d288dc1f163453108fca7ba3f415d126c2fbde4ebdc7bd6b1490efff40a6a3e309e9881a26c1549c80835e7fb2c7c5fa26ad48cc8270cae98942fd404c54e211cb82c086cdf6473cf26bae5336b35363f14881e99818844ab6cb46a8b02debf80fbf8e9c38e0836ce38ca298f341f60b0b359b2724378195bd168383cde358f2c638397e96b29b19f4120f8081c5445fdbe7c91e35790c5ce7559deea30eaf77e3ad7d810727b82734e5b6b2998a4eff626d09d55a678b861687158c321acd1c6817e1da9511e0137aa763919acb8dab95425c610d7af317cbad6d82459f091ff9fd5386308f8dd59396f2e9b475ce0822260eccca872b85287875112af322253cb3c12b050ec4d1127b9f666d2704db2c70cb95137c6d97aa21e1809356d8ec794beec2707e410c41773ddf70c50009a5e409522f644359da918430a0f6a41625588a197fc79f58b79479142a1a4db373eeb2c5cca29d9955d0aeedcd7421245596b5803f723f7a946818166b53e7036aa1a407813e7056d99f15ea511a192acb188f1f73bc3d1cf5a701a5c9ffbf1f8459c014ff42ec5a5ff16fca223e6c61aeb68da0e96e7e4133ae0a2d341322271989dcd2c01648b9c7be1abb346b2ff4dbeeab3382159747ce21f55a0f8858f3055fb51b6fd8bcc69673c18d5d426f4ca2aac0ec21dce815e4f4a3dc2fbbdd400121c5b9933ebd1df9941228319d06033aa197438d86dca9abd9aac937a8caa62d3b92bea606d345456f17cd0e602215f2f9485b25bbfa32eab56a2c0693c2254d5c44bee327c70f187edff1c1b96a465480d4d79563b0faa64a9bc2cb09fda991aeaa52da3b169bc9e78a180976f3c9b25c895eb349e34f257d1345108b853227315d9c578e928059df16de9fdf4034be2ce433f23a49f7bd2d1195de1bfe826268fee5ee16d4aea5cb38726f0a573f5f65fb531071062d67e16448ba78b5e7b9480189eee84f6a82fd63ade0fd9af3c2a886f40f16470b0f4cfdd1a8d36483c6226555993c9b64e07da6f57565e90f55a80064256f862bc1f53fce6bf94c060a93baae32a1ff77c9e883ba398b95a3daec92ca44feb1c6b0152e9371bf9d977bdeff28947e748d4babf5e596ed875122ca0f88fd5bd12e24d8b9b7b32136edac5d6f3cd183a42bb5276d391458bd2ce7dd428b5eecb76e30939074ebff757f7e1fe78f51ef1927b3a2b949be864afe9413e5d0271e07e7d5e8d1334179859966a36bdf9ec480d200eda6ad6f44222a78f63b72360b147e22913d0f3c1b99c99183b0ad57f74be2f0781bcdd81e7be1fa7622deb55f7be9f495cb14cd5b252922bc50321f0db2d2807a2606d4c647898449b514399cf86c0bba3ee0ce764e6ceecc83e764a5b8dd428fddb9be8bb6eb8f6df86b46f23d091f91f67f8d1f74d89ecb03f7767b3ce8fa492318e16cc24be493370d3ca66d57b8394255559a90121a26681f62eb9e588153e791923c97980dfa6b6d792e92ac586fc1319c71434aaa233d0d73a13c943ff3a9d01981f378c7e02852f1cfda85bd0422558fb3f3ca395c5ae68f392c310bb119dde65a44db3c31a46095f4fc6e8dcfc58017b4905b47c16cfb0be243695dbbb1997a2044f4e627999f82834362fc3f055b790b58296efd9656a7b91bf3afb0bd5ca3e6d5b7c1347a746709ab66cfe41fa631d13681e54f22f8cd56590e49d6456764edbf8d6228f2069560cee7580f35f031ecf63da904d77a60d01728aa5ec543cfd469f04ab8c0ec6d4b16a7cb8a24d81461c18e6d4677ef1d12800dd7b81d62d08f17cb8fec4acc8e096d8755f9c30c14ced949693b31d0bdc30a1b32b46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
