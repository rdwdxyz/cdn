<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc58fab1bfcaa30e039ac7f11b659ca78ce2095ac12deea5b188bb8df303e535d639977e40a02826ed494e8da3b55468c3dca6a1d2fb783845c1cbf2a3fd3e2264cdd8bf5ad233d6d89eaeddd62c6cb0f183fe1522f746711d7001f97058925440ed5ccb7c507d58b6e65fcae2589bcdd81dccc47f0aedc034ef552b3c38b0409c3532505da79c2186783c9a79b28637124bd489332a90c6117957daef9f280a1eb0c162b0a1a12f1d2f34852149ca229a5330542fe9cb52c1a51246fb77003ef5ed6d5e21c9156c29d3a32132234246cdec38c344a76c2c299837361aaf28530417a45e7b59f3f1f8ebf9a72cd33c9b9cad12179f7b55c0056d144a322f053d913006ab18d5d7ab9dbe54197f0c29c8c6c06702266f1750244c4b1aa9cab9600bd0757e0355bece4e6779e0c330781f7ef68598b39daf0ff518111e76c3e19323ff0ab0b03d5e4da56ed507b6cbf2176e2d93dd1f8ad61927a579467c4356a3f1bab6e8b6d96e3117d6b19e94aa835a8dc271e69c36260c8302d37dade5063782efbb7e321ea432d4b6d46af026e1079fb5d0db29cf4adae2237a888707e289716448bad533198dd6b701b1ec8d5cc6a47d3c3152d9e2dc32317b07ce47f5a73039fa0f4f60d610f10e5759d859215f419c0aa1175517ac4386b5ef81e7bbea963e8184f10806735f0374bd09e9daefccbab64662c873f20de4c84da2af8a71edaf2d3eb14b93e03b60b0fdb6e9cc5a9df79c1f4f523e712957180d0a926e612319413673c1cc2e84973e913382c6ae59934da1a3bd99539b2f8464e878554f6d5090c7ab6f2442a03099a717fec0dc1bb33ac2ab9356a58f88f564f4f011cd7df836662c8550ad82430db911f0fc5cf075386eaa99c59874114d41225e21c176cd4210f2f29092c64f4ee3ec0d6e20a47da1d18e8d66972ae3520241220577ace86a1053800e248c616b10851e6ab17e06ae862f66bc25d78f7f6aa1712525e02c47bf08c4ba915b4f10a9ae610b9049c2cb9f3b689da76479e96d3a6851ec03347706d38f85a96a479f072131d8e9e472d32ecad995f9859e52c5979cebfd6b9b3f5a24e85c5680c318db0878e35156d4aad898bc93c91bb70325a362354ff6e3f7a64ea08fe50660f0e464b2444a3bf168b3f89d65f3547758a2720acf6488c4f3459188ac0375fa3b90873c2616789db533ae710483d941d9f2e55cb836c2728eb8c36764cf4ac6b7d55ccf42811c8f06e96d91e920b6939042d15c56162263c21a856fde96192a326f0fedaaca827c12a8977601def468419dd0f1b43f6c3405b45b055d2988cf2aa97cbc8bf3b6e48b87d29a99110ebb55b6ffcc7f594f9d8d42952437c6e586303df13e026aec864afcc93f6ca761715b1fed7e4777869752e65d8ebdd6ac4cbb0a1729b2246d45f9c4babc4e058db61081d497a4a0accd7656781d274ed534255e26b8b89ea2d62cf2c09ff41844243315e886d5ba7173216342d7f453a9e0b76f5782c70a780543ea1c23f58af01a7ed907d9a2fab9c31805d91e9cb0c0545d4efc2dea3ea810171450a4351bfa985034f5f401c7c9003e93797e6e09dbd2ed04975f2142fc3143b7c6038d387daf529f5dc62aac474f10bb4819acea2187eb7b90501a8c13b713c9fad5e86b3c1ca048dccb2ea0cc913d8216e89572bcfeff079696d674ca970da8637c80731a229ad052f3c54fd187a0872f933d17afff18019e2243dd6e3845ce601e9f48e58e27d4c1f2fb8934e8a6d4f950feee3ffb940179b1b00a4588a279c12605aeae8485a4a9dd3c0f434a837a749f35209da73c4e4b6b030d6017791f27e30d64046d9b1aa210f2f71e4d93e354303fe111999a1e7c64a67abba2691ba98927003164eecaf07716fffcf3841da9d4e7157aa3d5fdee158bc4ea1a41d0b66e4b411dc385a2247f44151d5c48a87422b18ecdb8ebe4596a9fbd410b88ef80bd77ad77090e89b8026d9fe8efc3676f73c2ff61cf7d607bca5b0aa4e48d885c59d2a1f087f1826768e4f57b7979c2d7a17cd835eef7707748128b56040b701eeea8af33cc57ee2252957ab0cc4c92036c577858c4f82ad11f9eac6cd99a33e52786d9efd69f58f320e613069529f39222f26356abf3cd20898cd17d28d38a789f2f6b2e7ccb943e69183bb8f8993696cca85894e3e578f83c19b406c353d02fca9214156f051e4777090716b7aaf4f86346ded5a4061211f15b2361aebf0f5c3facd7026441152ac69c2dcfdef1a91511584ea731fd24dca4bfa8d95d7130b096906ecee1fec6304c63a73adf74be9c93a65765935e5d90022ae1dceb85e75cf9e33f1ebc3237c5f0e567d1e3f590708b10fcd1a5b240d6e770963592d99b11c7661d41abed6de12a63690a211310a2c46d0f82bf0dd9381dc4aa0a570d87e992fe886f43603c2b0655385ab9da101e70399209aa6cb9e46195e3b88d815f1386cf87f6fa482e9f42f3026428ba61197936cb56add25733e591a2d88ac78b69a124df68f1c5c1704e3759542b27e6b175df2e085456d462c1f86934b05bb944faf50c9ffdff6d42d895c7b8c6772348e20a1e29ab52c867606cfabbfa22845362c82e9c8a3a9b1399531325565da02ac2ab2da53bc49c0cbfdf69687459aa00d82b5ce3cdc0e8b814c023370aa56ad83be9e181726945ac638609a31c7f7ec40e586e7e91a174dadbd70dde2b2b7a2e01c9e142558cccf47bfc9376d9d6e1faa53f09b69d2ce92b915341a187f61ec465276adfeb6b1335970eda95bbac7e5bd30c00b9cd2ba8d2dbe3e5577bd817c360bee72da73b356fc4726d8f4370450775fb8054b58b86faf059b30a747345b9b841ac7b056fab95ceac9aa05c0b23a044a7084917b68634bd90db8f150b9b6cb9a9920fb16a46a9551a6fba5bb977918daa7c48155239ec6de3bec31357c05f962861dcb828594cf8e2a2417d6269a397cad2a360f0146e550e17354e1f43a896a521cc14959d9dcee6019f6900b450cf68319c1b8904b74c67efee5a426ca3672c24f78a90f0576ee2930898458a64fc0a338d0652f6c79cdaf4c83e035bc317b1c8974c8f82e3fa2e0a9668796f72627ca5d209f928bdc582b40ca24443779480f8765820790b5a0092b3ec9b82a9c0fcefdff27df22ddcc0090676fed5f5ce8d867410c49b76dfe8ff7b8646f341fe35da1242aac53982c7aba15163734aeb475a3e6a1fd40e68041b7c0bd8498cd7cc98ecdb6e772dc8b226492c93c973f7c177b43d1fd2213bf63b57af02e96f207f71f5be36bef3390aab6e2a9b691eb06b4480ed136338d75a9943b7fb1336770caaf6168ff659d1b2066f7f98b767985c519cb1596dfb9df4c48d8a58ac3c434cc81e0f60a9cf976935962d530908727920c9a4a4c3352e76afa1b271e17e574b51202e00ba76b1a1f3484303f6ea1dc8797277b58143917b64e613ad220125420dfb6f3371881bfbee1ce9576d8a46bb97ad50e28984caf2ab8a8a8ca10da1b31fe4c6f3421caff8d92b1262da542c0e61920108a0a4ab511a7bf2d0a5f12593c445032c2b5ab2896d8b6f624cd7e64d25679a6d20b5fdbc6c4b25e7e17a3d7935d2a26d74c824632cfafd263919d2f6373c7d94f367103a22d15bd8c609cbd44bf7f59473f006793dff6e2670699b33f4105e671107376e8728e614e09171cc7111325ee699b4d38f523c2c94afa9ab686afb0aea01f9f51a88de8935b961c71db48d993a56171e8284bd14a3826c8e2261310b89f480d6b7bf1f9cd4cc150d75a1ec472312eea9c680b00ebc1651b7a38acef3b62c838ea0f5e51f9488b45e7a2e8100ddc628806653bad02f14bdc38e8ff52c22cbfb381f1581170ec6002176df1b9f0323619d3cad0ab757ca21b425010c5aa71952e737278f92317bea4f194a96ee56dd391d04981f625945b383e3cd30d69f4f932b5f95c8c488f2e0c5b81eeceed05dd89b5f83084e8ff21de37674f87994379ffffdb4895e91858d75c935981f7162fbde4c90ce4df645d53d47402e89f0a85e5f94efd7793a74f1cae3c8f0ebd6560a488bae405e85811813eb6422e3e9a063bd8cc2b1305e2d26dc3742bb599d4aa5c528e0fb775c1baf13d9168ad532fa5a200f52bf5a76945ba85a2a17128ecfaecfac30b47f2963cb6d803ea563c172d064ebfb994a356b7ee084d53136199d1c7e4bd0beb2d9b5ab19c3330647c0d0aab0f1639e975dd24bc06ee1e754272245d85c8a0a6c7903817a3abdc5aed855cca4e5e17332c9e680a6270b4136d933c51d31f89eb06681093639589e4fadf00b345d156f371c49d1b0fd37ec502fcbf030f18b9c1b399cdc23b6dd5d5539421a5efcbece95efe5a9264de5c28891da933f30da727c38704c9efea9b494291f83574a7291254f53e3287f1adb57315174d9df9cfe84405821cd740b709d2d7f365aa13c49ef795682859c649470f1ba1628e9ce3b8a32603faf7cdab4de03bcc8377952faf9a06c85f7e218c86e5b4a10065683d105513b0b6aea28d0b01995ae7e126f75623bf3149e196553b5ed4410f5d149035f207568f1042ea6d61bfb92bf49500faea3b814bde238096f4692648384126f0885a05513dc3f7b595605b3684b5a3b40703fb8ef6fb9ae50b50ac88834030b091c4a1f65dbc42e515d7dd40518d393b53796897838d5a1a25da76257234ef1ec05efcc6599b3f4bf6d0e4754bed8b40d5100aebdeef4c8303d70404b6b2968e5cb5b36e1be1cd9c569964f8c2a2d3c0071bf94e94313d7541577fed5f3c4d6f74550c901f49857b0669d0a3cd53cd839971ca4682890e7f4a9224d0951ef249c39480e86ad9f50d39fda3888c7795910ea8f1c9f770e6c12d258e781664f59a66dd8b7f15c70751e70c1f82099a85e03b0b6ac06f777e4a8c818261afcec1011cb45802516df5e534bea2ae66dd43ae19db35287490bc7cf887838c5a1cabf7e669727515e2f7aae860a27af5e7b845a9abf17c2488fddbce2777df11b186e381641f451bc17c836b0c5001442ec4e97288db75bba00cd1c4f3e01cf09a3e68dd518cb753c3f2dfab24e0ac281ebc5711149b4fd41ca546b0309275b49229493b0c6fc7fbccc2f64bf0b927b5a891244dab4975fb54a1259a04adb94e5d34e0110df9fb24c8136b5159a5c5ca5e7b0951cfcacff1cbe67ea8c6eed373ebae6ab639f7e025f9276e90e7c138dd3283a970aa2f3b14e6e8c193645be46885d061ffb07e7c4410f6536cf8aebcb56f60e8f9d7871e6c658aa08c0ec765fdd10a05775c07070099f6fd4c2051241124b4fc7f5724071c7d9b6147d91a8775df2d07ebfedb2d0eeb48ef6c3ca4d0b0d0e9674b86a6e3ec4f358f7e033a8db5197e1ee5e2a3c72c80b1eb30ae76c7bf10c5c3728f3176831ea4947cfa185fb9e6c878dd2e3884e66114d545cfd63471750bb3f02b0cb9029efd3f0ffe526fc7dc901a3451c5319fc954ee54fff1e943c8fc6130a84e223155771c9e5d7d7ff3bcd573fe720af78801dacb9be807250d8047bb35ea15085f12040151ea971fe5c55b20db44266b4b3ccbca19bdb5f488f18172b06c7cb82d666edf2b94c6b1338f74c31a10086bbf62b72ebfadf87c05be97eecf4666cb810ce263a13bf19fea423a212c7d9ee021b5bb66dff7f791cd2261d13fbe5369a598884535ba19e0abef5751ce1f6c120b96d9cd96c885e2d08afa3d39c9c75ae9883ee20d67487901bdc035e03b33a025837b618e61a3c85b09d850bfe09b7600246c5dcfb1bbacab7b133b68e64ce48714e757662da05cf1854a98523be55c4954e0ad02482e0a46bd6d19de59632683308b9461b08f71b7567b9a6b7454552ec8ed3e70d2d85e5f235d2ba0fb65be41dc284e1e28a05084330b6a7935959c14f2b7b8d50490f74d2934f26454c34f7c13ac86d5da284b0feab910a2d81b52df7dffe07a53878ac367b366a7122c0ce2061e2a485bdf7725db1044d59d0b5a602c24b0073ab6f67ecfd350e70f025888bb391e24f7dfad667e99e3fccfd5d1825177bc01b9e1fbad333c9841ced43587829a5723b803dd3c6c45e39f69d20ffd5c2034e9e9e6093dc46ed922750c9083fbeed67375750eb89e73b05460bc076638d127852fefe3eb351f4ce7aaf5d84fb8a284743b450f8b501f6a3d3b52c4e3618eb2792847b802620b107045e920194ab4f7669ed1f2de383b130a9615f9f66f9b26e8533949a2b22ee06a6cf09de98ef943b87673aab6491e857eeeadf78d7156f5a88c79a10d6dfdef9a914afb4ce6ca32b4c648e2d90308bfd90f21b43a7df1359373fb8623846fa008b555a1058b999779f0897db05fbba42968f19e4bb28a871d25e9fd7e1dfd90b7a8ab9af816ccfbbdbd12b16f1f7e8e73759ddb80d9ec19b9140561cca00967cc32944972bf6e5a001251c5e04a95535477a2f68888ebf1d072b995d6c7cd276b4ce1dfce45ef72f388f4237c0a70ca8e87d00afe25216ff0f07440ea7accee5a0c89b49ea5a879507c259b5962135f813b621bdc01de8d01a1c0e15e6c000a302405ef3a961b2076dd2f068ebdb5e3638844e5c54eab07cf60ab3c8ebb3a9ac1274f685b0ac3aec0a11e72d9c184661823f1e531be2b902164ff203857b68153182b7337a1a4120d21da4593d3ed0dfddfeee00a20edd17bce9485c0b5843d472dc18f0cadcbb050b0be7776081683b955b2a62bb720f1ea8c6e5b73cd8e826071e50d4aa5131cae2a878498753c1d8632ddf72a6eeb7222d05c1be4e357bd153c88cbe3f20d2dbe4a18942b80106cb5d996fac78df637e8f9653392c70373d53206aacb0bad1b61985b3c0083c5059cfa843224690b99b86baf1ee3544cb1de4a6cb06ed5a0e17b4761af101aafb32bb56f744f36598d40fe1ede2e611b987560697020871542d67fa8d4f075e508934c9b7eabd3cde4740851f1a1e11da35dfc14b4ad22e94621abd18eaec04441656983ca22ce08955d7290261e5fd4cd81f85b7ac9961eedf5573ccb44bcd4edf97e3e79027c184ddea3e24dba04298c99db7c5116d7988276ed29171f1bec8b67d25b37e3289930149f2736645f9d65fecba3fdf6cab0039f3f98d95030b2000e043f203af63a193ac96297c42e47459130d627f7acb3bb3f3d99261195fa05e8d74b61d8af20f0d92ab6865cbbf4011f75ce73b383fff1da46a9214071df93ad990fec228fad230ca9665cfcf5a8e7dce8c0d4ada8a1a5ede46067ff4f172a4990b9966e2ad8396b1c089279efdafb1cbbcf464e6131efcd69f6df6aeacb197b9ac23932d43963f16a662f05e8850ec5165e8a15a3504f4273ff3f06c07efb7504c4e9cfc6dc0dc22c55df49057e8ca7f948beffaf045d6475447a42b68194e8d1b1a74c18ef5df8e0559de253cb41bcce5e535e8559228d1a696acc390309d9ded89ca833c87767284a9c6e564c3343b5ed4700d5da349e5d65b271c2277e8ecd8d489baef162bfd7083e2c4f0ed5287b9e9b91cd8410ddf58d3bf2f266a57758cb69b09ef8e6f36648dd71b500f6dba060b2db9f1938c0be8be7b09395dd7e4dea7122589ed1b80612132cf733fbacc9b4d139c7c56d7120153da42fc22f191756b041d33cd6479d0d29c70ea5c9d07abd9a4df690282ebc3d0f575d2a64bf758772cff009102aa8ad2da0dcc62c6c9352fd475661a7238a17ffeac763710e0c339b9af3a896c45520abf86705611c2e7f0a641e97461fa6d476e906a36a262d92d733c229c68eb71bf18d009bd9b979b2faf4c72402017fa562b7db8cc7709a671385944cbdbf92298048b8ff227d085c05739d4dc2ec763933cc92905c00e9721156a0ff7cf8b04f61f3e23c40464c81418462eadce489450b63fa9e08e3f080b6d39085fcdaa3f762a6b4a0ab55ee9b05a3792fa0d3cab6af8d66c59eb34ab3f5654e7c207e23b6bd46dc845b7e5f57735180e01d04af974227f237fe5f70472b5cf46919d823c8bfb4d1f18d6c13711fc00383ec7b12b5757755114f0b819b3805544767b9e012409646ed44612e5d9a70e4919173c4f9a1a57dbda5889a2da2ce1ba144e498daf709400e930f72b89d62c6e17cae368642b7429edfb6344bd3a8281ac1789c5969a6202fe33502bbfa99e4551776d8a7691f89db1f211d9254fc645a96583e3738b35e38679295678459c2ce1f2d21f298d6de3356596718eee4a245c351ec29c0af6b1a10903b7068eed9d25bbb0fe31277a4b8e1bb210e59d919ef248c76fe929ef9b93acb2b84681767722e75865cab8b0ec410df0386cc88f394e7ee5ee57cdf5460c95a2abed2025aae9a3fe58cdd681bc6f7664da79ac89d313a04212d5d95d1de040b9901256d9286f83921a449b82da9145534700ef063ef5777ce5b56f7b46121aac31d9f3efe803c440932034de00604d98b0e18d6331cf895fbd96f97b41170c1743c79d185d1058dbcf41d037e005091b457bafe3db0dcbebd238518947c1168100fe98de0aa4523d9b30e1dc92f8224cd4c1250e94310211782308b7d7f283d1abf2c4a6abb3d7f592ed5f3421538c72a826849447d06589eb2a9f5b3f1869aa87b795b0082445b3ad49610c1d110ae43cd14cba9ad32d97203edd1903c7d5c2a05e0578a8cf0aa2a10660f0dd1cb3ee0d508188056089ac09c8a7b4e48b1de0f507309f6f36e9af88e292f93cf745ac17f143ad9cd3f7f169761325ae4924d1e3146ff9fe8d391035fcd53a593cff5634fb3996d1a764c9e069549aab341af9840830391095c58dc7f055e578d4e44799809e168fd01106627d822d6520856fe5edd006ea6311bdc9309f970b9175b07611dab3fd4a3ddb5b84d1c82d285cf3edcc72b101328cf2618e54a1c892dcce2ac86bf78fc8ae0edc1e605a294ee59f4ff9e7d10410d5139d36ba7c9b0248a4dc89bb9abf7e1ef5905d3bad97a88aa5c89b03e86ceb380f32df286bf4623a722b8d98a2297ccdcb6d1c7c73892196a6ee83a2ad172886196c6d1f64867c031f4ebbd2fe1b79a5f2045a9babbbb127ce6f4ac01873783fe5608c724dd86a98e1d6e917ef15dbd53bbad154499fbf2ac6a5938d503c23f5dab382ec6aee37ce1081b91fed12e8ce442fd646b28a91b86e0ca3882e5cc1ececb7da4900c637bbc33a2545a96164eea7a8f65931ab4bcba74f3551003af5563018542022d1d9bc3d7daaa38e5214387c56e40b8cdbc85c92d72ce5a7b08c5c0d23710fc15628a562ab6a9f17d45ccf10bb0d30cba31ea849becda66b6e636e48111bb1dda2c1bdef81cb33312c8101f66210c5abb1a701576f57f28b26da20dedeb4641589da606226466848e80c41b97236435201318e80b89e5af557a0d539a4cb3764e7e51108d1697e310876b90ee5ab51f2cd0157937cfe768f8db743ee9c83b5783bd85f0761726c2485290d124a9487e4fc4f79ee3c9c8d2ab0ed0e6fbba02aa6d9c82d05c037d52453d49aee163fbb416d77029df587ca0a407d17e46e19d09737156b3f4190e4edd2f67e6979dbc68114c604321b0a7d7b2ccedb73cc39743784f5e31c17a860d31bedaa3a04b85ab714abd70a56f9f3a4bdccf3c65b265feb8ea8b3e5121a99c0e25ec33a1da2fae15a788272a560eca170f03c6a9938e2068c236595c79a31891b8033d6ab0eb22684d83f9370e0041f7b4b04c02f8acaa46619599027372bbdbe4cd1fed786daa60b13871468b36a8f2bf39569c0863de9e3b843b21115566dc87d323a366f5d163ec252dd2b5faa83961daea0842ff82a3a06693cd456943b0250cee25a4d9cf61999e2333545fd0720ea6da5c7e263e8f777f3168892f5daa76242b2d5c6752056a3db77452cc81d947a71303b452485a8c7321882499e37f084a36ea82a2617094c43031efcf04b1be57251895f3c31a3b3aebd6bacf1a1fc8bccbf0f2a76b48fcb8bf103cbc9d154a0d96e06aaa8a99e792ead5644701dd77ec06b656c7c11a85e06778389c02badd39642b3822e5ca77c9df3e4cab36c06620adba719b03f40f0e941870800bb052fa21c740b5348bdf37eacea623a2a8853b77d4e621630a44d67484ea1faf3b586084b1df5c11c49428361d8674b534bd93dc7131a77d10aad0fbec0d02122ce1129c53c4b139b08115a116947681ef31c113704d8bd0f676944acd5c9621c6305f75b0dabb7198840a3f1f2b53259d32c26089233fad0ad77e94a87ee141568d9f80026784dd660279745223c0d4a8fc0d565c30760f7757394c5ce49b0d5ec77d30c7f353d9ff77289e7e82c074b10c54e90382e29e459b786e0ea76784f849acdc7ad4164d3a0d5fcd8f69f46f6cef771a8d7c4f155","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
