<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3aae2f45dc50bb7c17b3996f4bc2ee57157eb634c8c749a2b059da5acfe7ff88f367282def94cd2c58263bd74fadbb2401fde0c32af1fbc6498ffec4d857627cee868be0ed68546f0e3b053a31802b4b00ebff4728bbf2a94db0231742885dbb0ba952ee26512137f0fce47543d969d4aec767fc31cb1de14c2a1848901a91cc8a53207d77d183b232ae65c50dd27d23e7ef0014c581d24934af83fe353604f5fb726304eddac4d629e834e59fd60e15777e684d129a4c6ea840612c64619ffbfdb0e1adcc15adc7a789f909685fcbbd5695b195857f0eb2cd4d2edb159a017aeba0afb3a0775da6d5ff9cdd70dba4b14ecab6ab0458514d383711fb9ec28e5c21bb885eb53a57143cf2b1c3db791939c626d926a2c1e505e439dffd911cdbbffec4cf11f5ec0f0ca0153cfe6c899074c920db4bcf129e274a7389a921f9caa804c06d2a5d8befcca40dba044c3adeb15a985d46ef48e18da2dbf6020e0452721f2c0fc86b239f6cc695aeda8a603ffb0f6b9f9201c2d585b1192c94cc010ce6f1f620daa05d19322c1e4fafce3ebe375497338ceb062d86f70cf1c86118c798ed8e50f2df16a41adc092638231ff24ec8085b3f6c56d8d8cf651124f0e91a9b5c7ca04d2cc504a098c4df11add5bf4b6b821f8ba88cb5cf056d5a58991f3720f09ce4e9c1ce37263c7a787ea2cf2b40446d0f36e715e9756620760ecdc7a5cb6c7640672fbafd22bf32d3198058e290ae64ef5f27bdf644767a8a089452f22a30abd1576fa0bf11e5df83945b5e432ed06fb74fbb4d7d4b49a15a7513f951f6f1ad9d14d7dfd4228b7f4b5853c9f71eb6cf95d931486c63d340efc7bd905a4e1bb1ba2e7dcdf92a19cef7627f0d362a4458c87c0f6738030bc51aa82260526693d7f9d70182caaaadc767d391a466a045b36d7ae4b9d87090bdeb01c33440bc3f7c57b750969dc56d037bc1370f3c139850260c1e71fbe1139df22be5c5ce47c0f3e8be10ea8c46c1d7f1c11781025ec675d44411a2ac20383d10729654c7a76e12be9e0c1d831db04f0a5999cf7602bfa35e2493065b41509bca4050e280af6bac55a536ea6cee960af123fdcd6d03d5ffff6928da6c2f49c2decbf74802195346bb0bab6736d323b74c8e476b01eedba13a00908099ceb7bec8aa9273b1e3e5f4f71ee90ade4ca66937caf49234839454c938e9dda5d1c406d47a0b41071fcadda162b44f791ab8e6d67ef939a7015179ab761a76b42c668d210068481d56e772fd21b82738298f2505a19ca77299124b0391aadccdc824d7476c9e56a3c883709f499c7770ea03cd867e6f72eca033ee257b0d2e25f1cfe88f4bdfcd451a13aeeafbd75aef6c513179721e6f8b43a6c30b84780fbca820536499db8b6dc5c5e22281bce365d6dfa613b17ed59b368a01e25b347d7f14075d7dd7f0faa5f2f9ef2bf0d502d5b74c06c7b13e152b31900b12c76f3dcc126da16151cdb9493c4dc7b516cd6e8bc6befd60ba3fff379afc99fcab90411cb8a19474679bdc547b7d6f97254e7c4e8f2b3c45cef82b5d9a67b38f92fdf6f4e3f51dc078dd03644751d201dbdf9a05c6483a6feafcea8ff0bf544e03e40d3f4074bfa9e6e599d903655bb7feb5273652fb79bd9a1795b6cc1167aebd1fd376fe1b1ecfad9110ac91e13867e6cdbfc48e6d0ab89b2505db7aeafcf4fb1951e9be9b9fd399f937c16ba30358ab50d2660cd2d333e4cacd11ed38518d91cd8b667814d87c52a9d92190e3d3772fccf8c00ac55b2a4c4b0f0a0cb92379b9a4b6c19494ed0f299fc45606cf70a5882e87dc93a126d5f0c0fd7b49173d6479e864fc41876eeb2193b48ed5b7261508a83f4bee97c0eb9f36fc1cfc6d8cc8485d32233e16ec859fd2cd1004f6a37b1466d2d0a1ac4520282f034244f31c534130e38257f1432fbfd14fbd502a08b48569693bfd90d9cef82860975c40989b50e5219d72eccee0f1de657484fdb48316c92e933e180695de8c77f96567a80bc7b0815385397064d5247bf70b309241f8f1d907c633304b68f3df7991768523916840b5071c3eaaf3d31d37e9ce4e99cbdd4ccbe5243e1a50bff97eb347dfb2bcc2f6300b3eb4f8f28cb008a75ed9ba68b51290d862f51e097456ff01f9df9de83f313412dc2fa6cad73b63741f7247cd5ea11c1686b6cb23218d1314a6be6a5f4ce46377ca7737787c6efc2051d4b1bbbfb10bce7171e4261411ababce19555c2e09e4fc2e0b10a60c8015ae9d696dfd7ad3d24eee6702b1f9c25475075833558176d5a01ff9c8829a4f0c025aa7237d175959a30034fa93e49d926a98be2634c7ab68771b5c8fbc56557480fd8d6edfb4c31441c29052bfaaa980ab2a1d8cf2ddf590f9f477fd5310e74f0a63d9226752abed9f773a2bc837c7aa5ce31d2221a614de070986432223e87cc14426cf459e5e18565bf806074361806417ecd51c971a55f0928d55c29e487ef4ba7e9206bdf02704ee5ea3f09d3c9f996a7e5a086562d419b74ce3e6b6244b29e268d81c02b2a97ebbbd46676fcdc4ba84b1f80b2f59a20dbef0bc170beb67a40f42b9f66959d7556f275caa958e1be08dbccf0670278510f0d08b717b91adb93660decad5441275192610c5e6afec4cb01ce7108eddc9aaea31dfce88750ddab42f28861c7438837843574b500b391e14495e2936ab8d893482a009152a97fd044012a16c734bcd1f058a2df06bde148cebe973fb039ceef55b80573391b13091dfb08a24c78402f6bc44593a46c4f9fc8ff7e196402af2315b1765ccb239ed8755d3b25dc07ed95777603804efb15948732ed7e53c1776bc16714951227e8d320894e70b96dd0d8410738884782914e6ef3ff01241d7927126079d3eb8b92a0923786117dc74e7ee28a38e05aaa247a7ae87b625cae62f046666c1960a0ab4543d4f5621da75cb45c75e6ddfc1a0094287c10eda5e5c247f9a96766375936f089a128a0ab0a68aa61378d244a11b380b61804cee430d510a635edb9df4df77f985f4752322fd9f459af8e8e2290e5887c88155b7a2bc073582ec742e0b4b9c7648c188077019f3592640580debf545bc03183c194d96b382784cbbafd34f1deb1d0e8cee9cc6235a3f455c6d74a37b3f1788f16aa52d15f5e4c168513e7e8c3d2187ec4f3ca5ed06a485728cae97cc0674fc24f3c2926249ba40f32a10a587f596149cf1f07188590ebfa57992833005952735462d292e8fb15198af60b02221c1912165826be577baa3e894e5970cfbd8546758052b5917f91726872ee455509695fc022d344ec05cb9b6206b6fc2a11d3cde46e06869ded51323429a06c8afeeb6ac76aef488d322e0195f32d748fa3960c19834515c8abbd574c398e15de740da7924a15c7a6fed2f3ceccbeffe3ba37ef80457555b1cdaa15e65106d6a8c4bdc3a76f24821caff7af680fde965c3e541552cb4f5dccaacf0a5583bb8f684440589abbbb969917eb1818634620b254f12c976fbf5a3e28dd42743bd5fc07bb127c22c368557f6b228f7ca9b960afe8f3913536e716c4207f6ef1910f8b646cc1aa0baf7df370d5afbf4396932703c1a5016252cb2e9cf4773a6effa2b64fecb88a166fffe684910d1a61901af68bcb54487f0869f1be09f61b043431d73695554c3bcd47c18049ee3cb39304e90939d0f521b4d7a35e3c01da20637c4edcec600fc23192ff4d51df1ab1cb6e417e0f9db63185eb440e0152ce9a4a53afbd9befb8bc1472596e0b12a13643da611490cda7b658ef7eff12dd352fb8223d88abd502dce38ff913e10384fd78dde3f5b0d640dd90ca8867d8de88ba4a9e12a27a9536fa203df8e0e1799ab2581cdea01cc75142122a15eadbb28a898b0cc4bc49a3d7a0975fa004b705e6e54b4fe2e6490ca37fbfff9fbb217eede508e1380ddcb1588720de5a081de772e3ab40ae4f202439468826ab51b1a77ded29a70c62799addfbf770e74d42e30269de50f68bdddd4acb2ec9e43be7cfe407e09d085935d77ed2afd9e3d692ffde76daed1fc3bf63905b85bc2e448d5800931849753747cbd3c08d2c969f62d2091eda576adc8aaa3b985c2199adc0ed89f3b06003c7fde398aee939d2c07b936b0c04e627c029634872024f851f5c01f1121b1e47cfff7ef9063b0b269577cb0b3ee110577360f97d7d91542f53458a4439b3b45f94cb180113e00cf3ca2b395a64f87c898f2cfe729f1959ef29bad82b15a2f81d8186c32f5d579e364c00d13bafba75f59f4e4c521175ad66b18ca8e778213a52b6c12338c1c47243da489f7c0d756da0ca9a70007169d7791005948e97ac0a551238250bf9a033fee65101b1db45f6bb9d379bcbaeb69e962937ffb3ada058dac6478c8be028f43e90199a0ce1c245af447ef23015d02218d8a0834dc8ad764558e539b31a8e97bf2969badfc144c85171f0147b8cb2a1802cbf181f6cb19d80ec10cc8fd60dedfae3405c2f8045e8882f88d095a3ba5f08f921b28fe4909877e2dde4452a76e6e67642efb8c636328d88aedd3c72f73befcb5646a7191c78c1e399d515025f44f6a95d754541753edf1b444eb8bf0f4391eca0a5a14d503cce9a80be4c2b8f799e210d355e14f4ca621fe4e8ca37bf2d19f830b1796c33a92e1fc01d0df5891ef3d13bd743f3e42a61d753411364eccbc720240262a9f4ee6852e1b68274d173a3a1b8b35930b7d20174dc0d0b3adc05232f03ec51eb9a7ed138d596034ef409bc553b047669791408c75da0847245870a58a471a506fc4610bf50a0a4b9072c96c244235cd72cf39be43a2bd4677bc292ea5f2e6d6a04f545ec8b1214965928d5004fac7e233c3550f1fcaa064f841937cf0df6a5a19e8b7fd14b03be146944cd3a8fdc8ba1f201f7e4aaad12aa7b7b337b4ded8dc32a3cb30261c4ea87a5bb3f342a414ef7eae4675b1284754c9a0acd05069654d4c6fdaaeb3dc1d2fc094c7f38cf54870ae0ee29f10e583f6e4a8f5be4ee1069e73763d479787132f7eedcfd1c33f8357fb1d13b37abe8fd013334ae02f2d43c48113f42c73e9b5a5675ed64d60b08e71b922213eb6cf15e14f69796002e637877e34f3c46b50c7326af1844a5aac43ef68d3e90ff0377b98c808033fb9aa2952c9644461b91054a29672fbfff557ac61c16fbd3a71247997746998ad38f1f2d1384b24d4b5e4cff871509a7cde28a7dcf1a0d363d7c69aab2d7133c6bbec5e350e45d8db18b9756f88a0cc6339b135fffb449c2bd8051d92fcab9ffc1195c996f7191335437fbfa4e824fdb30f261ce1dd4d31d5b91e8eb07e37766395194201470b5679379c3383b227eae8aa209332f0d555fbe96a9b5fe78d44c696a2400acadba4b11e953a808a416b4e362d549810d49db02f135c2a6bec9581be2e08af9baf28aa009ff539630f75f41b945b3c8488610c67051d1dec522eb5f67c09397a8012a9e0a4e105a9e8c18e85b93acd9f03d49a6b8d42208880ba446c3b935f72366b84e1c70c4447f7da89a7ac9c16e899d9ab0262bc844af108d0a7f9d3502608c100b64f51945a65536f32fb6c556246ecf286179d2f03bdacb9c94a8f70eea27ced8f46a57cf199ea141299801665d1b4d0fd798d10532a00b8bcae852e6422628fbf64a5bcd57c80d4a7237e6f602bb632c057fefca5d4e8f68bf8c3ae42045e159aa570a4f8139c12d6273ca264d6a56f437e7df592c8eee7ab15e9ada7a6ff8c2f0c1a7ea589cf2b787ba30c68234e2a39aba1f7d0cbc99709a33a89ad8c9f73df5a4c4601747fbc9b7ee3acf7b1c4a04550122c8e93b0ce848886db4d849a29b542cb5c299a83ecfb3bf6321154c158a89a39b2a2c063c59eaa13bf596742cfd35496c6546575280432844fe435305f101e62a0d87986b2d146d3fc69e638a7903a408d2cc9ea7e0ba0943b700a4383306dd2e70ae5a67cd64266cfdeb2a92c1a175aa1e20dda417a3010fd4897641e1b34ffb33761366ab04722c9180d9b77e0e4cd6cffa56a3642294a35eed20dc4c73d43ddb0b0c4ce230eff17acb53a296fcc82059faf2264209c444acb3e85f033fcbc5b7877283c91b9d80e7d52e7e67d22f09bf5e0cb048f9cd7e280b535256d39d0b221507650ef3f9cc485d64b5e8f8d00c8c3e2af57f5ef8532f37e54193246316fbce091cad4c781e8baf9741431a9064b591a0007e02e7ca8dbd84b91f5a477c9d8d49edeba1def6b16fa3732e1f2c69e1dc33f3071410958389bd4d885b4f82b3d580e835c6d9c62d8bb139a25b4970acefac89b3285b9c7b8959a65c87c3768ba7ed7d58086d089868d6777c9d28c9e08d8de88aedd9636df3dab41d4756b7b97c2b44801436721988dd012f7689df3fa6a8fa590b6e7672fcf9d7ae43b7d58a1e8948d2319a1d42a20f3ff357aaf91a317b050de15e28cc2790d54ca604c31d6edea4fc7dd72de1f3a3cb972972aa87c2479598fc0910d80cc402650d9032a1db5feb3934832d7ac381ab4acc4843883623d5c7f4852a4e89e0be1da0fef286215f8c7453aa4b846b999c3bd4449c6b6c37ba3c1bbf3693c21df017d735ccb89f693a82987931ea908c9e9beb45d3a0f4988e4fbeee2f8e2020e714652ef492324b6fcf5b5ccd960ed9239486d30013cee20781e61276028670c15445a07228846a1bdaa739282b3985489e4fc68264ead0e529701c04a070dd901a8fc97e37f404c44240773d7463ec73b1b6dd60bea473eb4571cc2cf6acc53cb72b570e94c68c69c9af2fb14358017fe290c9fe16d9e0ffadccfef6e3bbdac904fd83bdec4e5b46a3ac8f96c5b9ca943c3b8c00b13f0fc4510724f48ae2ac3424cc4a31a9afe93acb6eefa37482a918c93fbea4722e25fc7ff707084af33aac82070742c19442c0fbfd59c90dd25791daba71de898cc20f7b7bad25256800b6bc914234f3c982f5ba0ea0dd414288e8c7e67c971cb9f6f1a622bb0c72ef1134af354787e08fbf864a96f9df537a3c394e96c323d2878aebf280781d9407bb195ff4949cfa2de91ac480cd4375a3690eafe2ed63236597c129c74ed72ea8401fa76dd3c48ce8bb0aa480aad40924fe1c44c76cb264b7290f4afb86d6fa24e519aefd67e67f086f2a3c6b16eb5105b4d481951bfdc0d07b05339a4ec78c62e955fdf05e38b2f310d79f7058074a924254d6df18fb35be6d4f3a9494344ad3ee52f2089b3cce23cc165c61d196b921d4aa53f5e6e61c180473e9bd32b5ca3d2f975dd9e8163104cdbabd952d778764071667dad7a50406ba8d138de21ae3781756a0a6244c038fd858cde24807f66437bb010212aa4bccd3747b28fcfdfd41a7b289c416fddb4f5259bc103e89d87f7ad4d6fd4ed52eb2524afd7ff6fde651b1411588d062ee7ee596734dba02c4bd869b302fca53df9bb49fd3de11906f569b25ad94b0ab2538cc6d0aad1ac5a0413a1a2758d693505cf58e07515bea8a32bdbbaf7a6f806225b47e5db4bc45303abb8819f7237549e536b7b0f6dc76048ebd2c8b3cc45ecef7c3ee63405a43e2daf28b94819a6fb21a9b2efbb95d59362171813ba1f5e91829073b31c329ec4d6fe68cfeb6d783a0598916a616e8e97f469e6601928d48322c4fd92c8497bc54c46ba530f982e615dbf1410d43cab7d1c3513fdca48762e7e455ddc4dab8c227098b193115d0742ea9564f4f55024bce62e38fe9248c2df68db5283e1692112500edb4222dbde582293f2f703fccdd004fd1b0517099a8e309bf5dbeb638a1cb0c5d84d9bc3931a1bd5035d024ddbaa53cddeccac58df202944d1a7e4a5777a3514d72452f8eb9c010bc3d91437318c8fef8c3915581c330729b640ca658c3bd399852687418e3fc7fb0df50a90cc4bbb1f48d6f788b6d5a9a893ec3515c95df85fcad814578a9c487592026c83284af37eb2b5d8a4280ce6e7e97a68516dfdc97014d72dc78e66687c0296f4a12378bebddf4bbc90f55ef5ed7d035599b07c41206cf83a361b0992b6dd21ec298480129a4aea745ddc98ee31812f115b70a5cf75cc46e5d1cf0ba7e1303f7940230c2b2a03a3b44320b861dc9f3edc11343e77066e349a0a924afac8982ddad5a9c10c6dae743b5a75ac32843f38ea8b89e06526599fc5bbc8dd5a2851f5b8d2b480734d7d5dd82428cfa69789c415b3b6a16f8dcb6f18e1e9c644a1a419041be2c95d463d3d6b88becbbbb888948c40165d66ebfebce9d6543ea9db9486b00c5143c3c8bfdf97c750ba309eba5214866f67a0d6cf35e3afe91252298e0d45d39cf1945a1bd987bf10f2ff4c3fb789935197c3b6753cc3f8dbf526675f3c4171f8b673a40e8c6d063532d74a44e207db8114c4e7040e2e15bd0c8f5603c8358146026b01e2406853c5d3af8fa76b714852cccb16321b66597863875804dd0faa763b8159805a16de92ab7d68a12d43a04f0eef9b8970e112fa8538de852feb2decc08b8a64dbb192bba5a56779b92df514f78b9fb38fa2fe1d7329af48725e168fb6e1d42d06808571eff742013ef3ceed8f2befd8f75f913183787e6ef3680f17df3be09ce555862a3701034e946160037597ae8b5a0a816bae9a8b7d1efc9302cbfd9f0b73f551424a08c5b6174924a3a851a535cd7f43891c91461f619ca954a62da8392737ebfbc66cc69e110621f22b73342d55da5348dede955cfdad3e63bcbbdc359335dab6ae54b1de2baf57daf172db5d276debe303b5573377899d80f3aec53736e0a14f352a6ae6f233addb260659e84be031b8a21b152b60a27bb3020ab1614f9510847ef03b52c8084ed630a33d63c39cd1d0a95e22ab62528cd0ee34897e94ab141b9052f3b31f2e7e41fb405ebab9c878ee906d0077b7f1a2232d309b54482ce0b727a3d76ffb5c70e4e97cf4eb39d075d24b74e26d96f46eb03ce2fc2d1ee991faf4df486e8dc64878b1bd118fa0a76d412200ca1376ba888c2f2be77eac325f25d9f0488fb6861fd78d9ae114487465573dedfbd576ba7a137bb7b5aec4d40902617006ff609dad2d26d4ec6e4d9ebc6b92627965c157b344e0cbdb42cefc9a5103a343b6b1a898f4f8f5663b6f297ed8172d43e741912de3137a7f8da6aabc30014f11c76e540706468118b80abcee3fdcaa7b37421f02fade57c8e9c683200d531132a7dea65dd32b52d3dd5b5c3ee4a5000470d8e5bd4b160aeebae404c1eac6af8bdfe3a7e548ec42c160a3090448bbe8a53c7ac497d9216df6215560f2df4955ff712251ff3fb632abc362dfee0c06a798f09281e61b303600a2bfe687935f5c1e7dcf21e06a0e00d661c1ad09ac499d727b9c9314f2bc51e6515042b7ac4dc75fa39b660ee1de1d7de5bcad37b958ffb79c52f5e4e48389f22985bccbf1b9c310fc283e6e90824c632633302ba35ff25a8e0c05cb938a32ab66cc9535e0d446a1aab072009cc567c62debbfcf0c65b6695167ad5685bfcc2e405a008ae155934b0a09fe4430bbff50425faaf99dec02a646ecc952ecdcfe72d9f2f809ebec24fb24e2eaf79b882aef77c456071819ec75084168082e9116b2e2184c81bb1fab7ee7c605bf06ccbaf6ddf83da154da7c99334ea65af8a02705726ff0dd4fca302e517d8ef892df0b0309879a309fbef9790f564896ac6ad87087aa9866af65c01da239c598b271b4d9da8dd1648712d10da1490d5e12268aa1e38d5b26e1f627007f567907c17e8810eea3429900c600569cb3417b68e7626d557f4d82181eebbbae61741d3f37c0f0ca93efb58633c466a900155e94bd740265ac283ae4f6f9f94e23d2e20016d74edfc3e0e2173193378157ad3ef9e8832ac08dd0b5e9fcea3cb430333c98eb1d7771b03d98b28d7d71fdf73cb8849bf5f32f5897fbeef489ff2ec6509b838263c13cf28d1ce2958cf813aed1e8a27a912d79cbb8c71349ab8ad48a790760cd90784bd6d937725e31c02eebaa59bf8c199e190afb846463f59c611850544f506370fc6586e2d42f0890145a67e2451da5c4632dc92699b48cb3dec6de6e032f3720a5620fccd99392773aaa473f2478bbdea13f623321510cfab49b10c15930015e72edeaa2b552c8fe3fb1a374b897e04956d4fb2c6a0fc91e27ae692bd2b87f253ce1db9942d4a31297dfc66d4ba1c517e1842e1bb17302fbd609915b034b6eb34fa12fd5799d2ae8a36fac445c010cf0d9edfeafccaeaf706fe66cb2c2ec126e3a82a2cf66b8c53b2edba9ef7b13b596a399110c9538a5434411037273894ea87be60808d600fc18d8b785c798d4e462e85a86760d70c322f6776ea844a61fc302e9f117177decd2d167bbc708ba87feb9063f02c7d2511159893abacca903ce6d5e0daddd8b40f19007e25afc4c258be5964cbe5c6f5f7da13bd33931dc6f85dc4765eca0006fb8943d843638e6bebc4b6c4fd912bfaf4921b638dc5bd341010eaf69e567133fccefddbfb8f34e1ebfa43ef2a537fc54520717545117a07d5699cb4b71a9305ad08e9dde938a21c6e336073795e16dfa0e90dbe35e5106eccc291989404a2b428b934e651a61505891e52b18b2c2b46bb9a0e8a555c7d4e29297666dd98970c4c208ef0492fa3f9d952a18767a7279b758d380da7836f5a665e126142e5ce503370b6e13058e2e566df1b7898ae78de5ea89bc776c4887cc82703b84d5e5e08334f6de822a050a9e8d858ae994f54b8c6455dac127424bae0a89e3c8aec746c5f844d35b77c77df0721eb027d9552ace3539c0e228d4a85624d1b683b0b4fbab85ef4d80b7c6ba8500af9d8ffdb0e9bf62138dea4f9a51500a0bdd0fe13fa1aacb4f54e5f23a49992d45f2faf4e1f8b5e6a0a39fe7d8e343c443106774372a7f2da38b12f0883b03e71cf2c048636df8369f193865dacfac23b626cf39d3c798ed6c18bf870b671223193ec93babfae233c8e967a32338e66e5627ac00ae280076ae06dcba31c96ff7917f82d1f9f88f7c14b09f702104206a3922d6f08b3a4357dd820826f036bd3e4f59190f498e4945619ce301f229006f5c4fabfa30f06a01fe15a1cd8a619fdcd104eca630e4a5fa692217953837d3706aab56ddab1253b38180d8205af43cbc7102fce6cda551a86f8ed53361d09af917c8461cd747dd8b2d9138ea997aafbc1bc910aba549314e2b1d23be04d884feac5d5c5a9b3150fa8ce00b11b157a683917cb029e348adbcde372c369ad1cb21757c9754185bfa0719a0fabff2e379b250c3315543e3e2e39550211e5cb8cb468834c9af96f9e84d186a90471f07857f39ce1ee1d037f95be226e766b519d3eeb95248c89cbdfe36cbd7cbb0e43e1914be899e5b2f38836ee040b16c26b757a75ac5c25b456f6b92661cedb1fb5140dfbe887d3f0ac62ca2bdb57cb46114a3340e15feb080139f3f2d5bcaf64870298a8eae39445f2002d2ff0a28f101e4b69f21f8d01ceddf095bd3a634b1d8b3f78feda16d56c83306a86e751cf3781fe8e92481dfd1e14f108557d2bdaa92d14c6125da773ec8b8a0424d4b49d41ae4d09dda7c3a85c937551320d3b522db7672e3bfdc0ca6d3a0a8667feb8d267d658c44ae696d5e238faec8b45d38e2d1c68fc61869d15ce88372cbbb583cb96a3f13e9a5c8dbd111daab2a41427652953f22d26678d5b6a8e5ec788ea8de9c23193c64daa446bb01791875f8401df04373ef3eddb0dfcb72863d9462a876e039ce68e4be4c4dde96b20c52de97bc612bd91356f8ab318cfe27edb4c8952deade3db9ba996338e10bafa3b6d34a96470ab4aba71ad61062396f21c13658c5fbce6abd2dd3c3d201361171c965a1fe75e3e3339d2c17b09b2c52157c76ae18543925269451af0ab18cb480d8e415b919642be2bd18b97f8168a8a7a41cbf96e467c51b62e777d6b82bb34fc957c742d42f77b02dc155276e320ea8fa4b6eed326859694ee78374bd2fc1a11617187980e6ae69f5c933d416c90e360ade711b0d2949acddc555ddcc30dd0415cc5b8c97270f4880b6b250e8af69c9f051f0e45be1b151882fcfcd15fcbd5e440d7e54315a2b2d707b8d7d535321543086dca98d634778290294fde6981c718b570417e3a4c337442e0c0c201b75914492c01f2681ed480e0f40dfe543648f74e4396b3d14199ad0072e2e5f3980236dca6195516a4f4cfe9f9d5820bcf52e5b70a8249f903f2cfdc40c77a694bab749bf805dcf2793932173c9c856d07d980f16e459497f3fa2e6a76d8dbbe78058544c4e28e53c064f4d7de24cb2c44a2d7de9a35b35c2e02fbe9f4048f8daca5b75230e67665cb0bc746c88ca97f718eb6ae63cb60b043fd0e0307ec495d9bddce7950d304dcf617867edd841f3531ff99f7f42f88ce3fc92cf7c1ed4b78ddad28e0cc529d7754e5fcb4526772b6b2a861be4d2fc87bfaab0ff51c2e5870ff6d7f11cb51dbeb39a92fe2760490a03cedffa209e061ab3a1e4cfdd22444a393f6c8276fe4576b15214e1d558486fab7475b784a0af15b13fa1c8fe1abbf7d57d37c0258fde7db1f64db7c005dff962820e1bac0522f71c5719d61ab96579aa85bfcf4611ddc4c7caa3ebe63e10c60c04e6466c8af0e54429fc7aa9bb393242f8ebdbb34f59e66249a91bc8c8cccccc8592a2343c92f70905d01115b3018723b488d43c399f642f11856db55faa1abaf6b8f9aed6322fda1d93f2049f21b35e269f198a13c13c7eb20443a090d6765313134d8001cc9ca994a65d3e79b8548ad8c765b6fc04b854f27523a370f1c77c3506e213f286837e62939b69e74955f37b5b4c4d11f25b28cd849a4e18208cdc8fc75fb360b72b20ab36612913ee9e3d6d8559d72156ef112e0cb34caae52f4ab6941ace2e83d579a215b5485a36754d8ff42dcc2152750f32ac218421260f7f1543954923ed4ff71c477fbe48bd0bebe8f66fafb559a5191cffbaba3be8fc962558f1b9352fceba5da663834385ad3e47c68a4cf583d8cd51cad7e3362b1d21a0e4648f3d559b649723be16aced8d3c903f1a90d7d8c447ec2417f41283eca48cac01c8037f1d215cf6fcaf26ac4c5b1d26b3da91b6e1029873fb46add29e9c52870c64ed06584f79c4a9216ea6e534f978407c2905cc483c7adac6f41dc4e291b28a48e65e5c3005e0e9f8ef64026043594d8e48f9d3c72d96732feca949b826ff58728413187d524e7b8e5b4dfc2ea26d92a6d0a75b2dd9b13c750e972bfbaa3fc4ac3ab926a4e38f377200888365e458cb78f14be96366a46ae4a4df91098b059f357a1a869d8df13d77620ea590a84de44afc99c1012f075029a6c22896e2774858c2b5ef82ffb205db2270f1f9372b3105dec74f387deb181cc16d4c22500f6ca3003c67d1824e3f2f2b1a445a9ca653290bf7daffaf2cb0b6a5e14fe0bbefcf0292f9784617a145520550622a270a7444ad718674834f4b66b726f6671fa9e6fb90428063be253eea7cd0070a04db4cc3a586265da1151dfa2f6dcb0fb6d083f1fa748817f8bf07593b64796ac2d546432caf4b1e84009e4844bc019d7c48dcaeb5c32b45b268598144c696ca8ed88f27683ed5b4780110294641b21eb3261cc1985d326c34396fe77c86eac78836c31ad6d2d90d6e30629354e921d36b08ee2268e1618f1e448a9f969e1af74d1841d8c18fb8cb9522a9a8f1fb1790b2b780e8d9f692dbe87ea4eed08818bb5cee57fa62daef5edad218ac4ef9179dd57bca7589202fd23bedf64f395d8883e8532d6ddbe976fbdc83a6aa72f78ee229780f81b80243b9c0268a6932831d929a6effed6cf233d2f43b3c133d98442288b4aad718bacfaa8c20537580d2aefd709f95f12b696506e66df43184295d22c10918f6db2b23570dd92e85dbccd1fc69d63af21ecae4d4967a68ad5bdc8e6798d5a636d85f799ee54739c82687e0ed75b25c2e130143444d9a4c6051647bbca768d9294f4b6b4b15bb7a6347749b67d417024a7fd5e44633169b38320cd54ede1a86eb1d29d341a28b7c47f07ae8e7c67f682b3bcedaef39968038a2ec41bb561660a05280432136f9343ae2610732c2849363a1f09cdba143509ecdf7bb4ede244a987fcf787bb84128236adfe0aab022fc84361f4c64fe33a79c76fae7b5d52f1da946ca64ca78e55a52a10c4f60fe18f679232aa331bc5d01a6bbe274797d9aac5705cdd82e5f6cffd2e73b045e33fe79092f907e04b3fda50db308365284db2dee7585ac7552ec520373593c995693be9b0e04029301bcef1aa8e2b46c02237a8618d801f43922a2b736870ce3a025d19f6ba4950c6bea3e5cb0c183750abe203de04e48d309daf891e6b29108dce52cbacf99e3d78bd56da8b31d48b8e94518b90fded2b5d4e2065fcbb554148ffbb624bad0469888ec72a05d191d0fcb58a19cc4e2ca31e81febec7d706c2f7c9e3985eeae05d81130e69d8148591fd217e67e9f629c4511cde8fe1de27a5d8bc0bb7b26bb9d140d4b151b09a6fb658e452098f8782455fbefaaa65643dcb0f6ea2cba3346ee4fa6bf1ae5853b4ccb6d40d343870108864f0ee9f0d6b934f1eba1a46bcebf6641bce36558ab91b669f00027f7e28f30253c79dc9469a96ac60f477f6503db3b46d16431e63d8557583a950d436310f25fd32d69b9a71b4c303130a6d38eefc6c813fcabac54218c6f1242d69f65b4130eccd8cf3f34054a24ac88c36e0158207dd0fd00b605c50fd2f3ab45195b29a16047dab5bf9c43815f42c0374df38a4195f506c89bc2063f3a3def1900a0079c75e783dd0ccd0e214e2643239f36453ba3e13976e5400be638991ec97dbd148aa6631b78ad23c2f6dbd4571283e3a184231c70f527713cff04393e3aa7c3537959aa8df392ea72fcd4abb9f146752c3215dfcfbe4e43ebd65ee996f8f5dd59ff8ea2b5a6a57f3edb085b46473fcdae4d4f13d48cd6938e3e8e9def7aae0a7977ac812638c884d79c8812d42960514e7d1eb9304f893c1948b761a77828144e002cf245e1c75183da7e3fc0b19ebb0b2342f75986e396d104f87327936d31941395cb2f02d0ed01db34ee0c55953cafdbcedf82c921361e4967dc63f665d9d5b68d2a7c8b33f6d7d7439e9cd551de68ea5e0c22ce5fe76032bff8f87e58029ca69d4c88b17d4a4b21ae5db2297e095999de7afd9f95349b037926a3ac0cbf033e72bfd9d4119476ed1a558ccce341c097a5576fd7c1426127d2da887dd4c00f67662873cb25e40eced79f55115d9a7761008c4ab25bb61e701a4ecb3f0927c046455f4911e757590fd22d3c25c952a5d3930e27fcd14b306228dd1933ce217d9dd39ea0d592bd19255928f701d57672c560bbe8e775351b56e8252e2ff1e8145f7361cd2a54605a1dc8a2e32c5828f40284c679c7cbfde50b6b4d203067bd231d09f7e02130226117c9f16de7446bf13e1ba55e6f806854fc9290abc2c89927468f719f0f532d04473c37c299657cb69a1de4dc3ed12ccfcea6aa068bb09b9ee85634ce02944f34a33bbacb0f55aaaf4259071ab8de12c5d76edf577d1bec6a14486eb399d03308978541b4942694b19152ea2f65214a9f9b928fa09d2c9e3b744c0e42c257d0490ace14b2b5667d13d84d7184777f05359fc522a7a962d7b3214ae777a5dbd0cb3c40c8e95e25172a77f5ac051aa3beca65b9bb0b5adc74b5d27b260105ef3ffd50574a99805a3b03ee2f8db585324f27b137c803fb3c81bb31702d3b1cbf7a2dbfbd10509be0dbc0738bc80070c018c9c83e8d17036ee8a92939c1f80ea70deeead30ca907227b38e457e9d5ac471943c163072d349e5f75e6ff6ada02a147640e8934818b0739c277e53dfd8f76727110d9a567dba8aaf4f9668070b38d3adbde93c601d2cf0968a578c1a83dbecd56c7ea21ade29da9db4bdedd39c3fb698e86510ee5ebf84b58960a4ac44306a38fee1dddc7ae18a3dd364a5c9068eef3384644fd112b3fbb81b0f0c9cc6a01901c74bc3a9fd78a13d010d7a4f07bab79f5ed940ea4e2421bef06788bb60408be6763c6d67cf6e9c220944028c9ca1c5f1470d71ce8c26c5eb973ce6efa24a92221124b87db575ec953889a3f7513ea96f01067131754e3586dfd8b47aea7d3b61c5d2d034ce2da8b6b31da212f6b561b5251af9acda651cb2384268bac13483135e98ff996314020aedbc0dbf35c819a08c85d9c10602717cdb2236db808c677747e04644b9078164c4926ca3f347e68c8a96617c95a07a2c572b28be58ab3d42c2ec9b5ed8e72d2e46d6934a582db8ae7d8250794da007e5affdf2b8547f884442e3e47857491c720d7f92bf0aa0878fc1c84916a8eaa637347663f24d05bace171fc7035517248b313fb44ad4fb73c5dadd9566a7483f71dc3507259f0e0cbe2ebb9f268be57d4960532972283b2f9398f434faceeaf3ae1c3fb5356f763bbb323d09221b35f5e408a0bd3655958d2915104fff49b28adb5a137d3855d004be74c6822afab6b18e7350cb0d3f189ed3dc3528adb5ef4d8a2fb0fb297d4b6c467bf0bfe55496dc4f67695ef85f8f55b1c9f8b77956e6654f55f72307614e1928592556ce27b7c6611b538c6ab6c4005b10bfb3a404f32e23bf8c98b5690d1e2a40874f2d629b0a23a4e6781b260540b5cbd16521be33c4786cb9728ed7ff86e11d7538da30768293c0d6eb2588f8d98ef422170b14529295e8276a77808220826c128e13f0fdce0f246c6d23dddb69aeab46a53815011ba1bfe2c7b8ef97530f22ba322007fb2242c5451f333103ec6ce642fb9a9843154434daf701bac5c3b175baf903fa100aab2217dba52f1044ee8c7f432e566ca8380424d335be190e4e0e34654f8885ba05ffbc92dea86b5eac6ed08d38192c06c80623cd07f32a8920a12e4b67d34bcafb83fe1fafd7098a0cd9ee064fab9068ba70eff2b92446c22da4e0f48e1ce462c27aa79e85aba160f69de32f233547bcda3c67f9f6e4b619a24844544bcdf00ebc1a98f03ce296c09252e0522db27e326e2a78ef19790578b2c9634140f7ea21bd16bcaf6681c9b4adbb2e459fa725b0aaf74f6e9504dd0b699fa48672e0131b24fe25986df92de5669ce11d5624f72e8035e00ea4f9e3b5977f51e5a6fe0db814264d60a3e7327320d275bfa73006c6d3d02b0cf4e519e73931eba3d6c00799a50c33821943c1fb12ac4bda27ca3ffe9fbcce0ea74e55cffdbbfdbf96b23affbb812966a5e3093fe22e1d3942012c751c22873aca0644530fd583b80f9f4c24844285eeee1be7e1b9c85f3e1e7129f064fdc14f11891b8d688553b1a84d1d27518ab5f0faaa79667d901b6953309f8d32094f1229f7f175ee6c4cca41771c70630d257265b6e012f9becee55ed69f426c61b83c9496d5bc345a37be03966beb530b988980aa86f4276d3cf59f8b23cddd79c3c9edc2b05f3853b7401e2f2165e44acb5561649eb9b9813263a793b8f88ebcd1ecd5dbc2450787cc8c597abaeb281c42ce7526774834c5e30f31e3130ee3defc3bc99203f019e0250f8689d626a9c8fa091e43c0a789c30d3a81df0f6d52a9b6c8ac9d83c2812a96290cb59cb067e3c279bfd33d72bd6a488adec9347614c5d6be68bcf90e139697f1d2f833af4da5ba75d165dbdf1efb97628e0da14c33416d70e5fd30b94ef0d82cc374c6f0c616f6cef2fad3216bd61fbe4cb1b89243cf09946503a09203f0fc9a7e54584829e4ab3b79429c778e40d9533fe17b4c08787fb3903855f04c0dd30e6c3bd0ec9f83340426b0f5dedfee381435d9428d9455a4e8ffe402838d7ce3f4fdab187c1ccf9de8ffcf865fe5cd72e7c17d373638319d71a6f89e48a053b3c275317d10829077ce1d3e7d9d325264b34c49b02568afcd5c1845190caf4dbd7b8c76bbb68ea4460082b9671f901383352aed420514becf25eadcad9510cdba00572c10884ce89510d7066f68f4440eee8292f5d6eb08356b399b1bb9966cae38f120b5ef038ad62dece987c264fb8eb10f1e27b8df05aeae36797fbed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
