<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2044e6b637d2814dcd2dc92cce44349cb59f5a37bb99183fa8a2e9d11d627f79a6a52a2780686570b4429aacca8f3e92fea6d8edb2dfe5507d340833be0ad7fd193a13d370fc0442106027411453a1f57e3cf5e198c6c9bf813a94c0f29f70d7c33b4767223cf70509dc3bc899bc2accfc635a7105e0834ee420cb7494cadb2077fa859ee69f636f3fc457c2b9ea46988229d693faa62d3c58fa0eaa4339fd85d5badc742911e60aac2f828e98b6992a629e0f2c3d3ebc8f1bb1c094faa0dfca7b4d555e69bffdd865522494cd5e2ac45e073d57f3df7ff059cd8d3398890795a70084d3eb42968a73333bdeaf19c7aedc97cedc31a0304ec7a72c9e05a33e7ca57889aa66a38b8cc65cd0c3f3978a58d151fe7b6b099274f798ccaf7f1dd43ffd383475d062922f91d07abe0b782fa086af82d4ed41f0268d5b07a16fbcfb7b6b7ab52a2a140aa56713f197336744b2ab8f0cc9fece586151041edc4191ca9caa868ad478f8eec6aa70b0c99aced597e87bb6acd6523cf7618068dc919b86edd3629898240d10fc51d0aed83d3a388e4757176419ebd296187b61355bcdb0b568c56157bfb242e0d8e3578a84d494191e220e6da07924c693aa0bd53dc9e2f85539ea4536648ab3b118ef39b1a873468f8f24cf267e64a9fcfdc2d0e412ac8dc7b92a0a505ebc5bfd1a8eaf032c99f9dcda7114a4b112c239372873a3689ae079faffb9be78d99345277426da21a09fbc6775e2e3354507224fbee5de302fd2aba7b039339fb5ebecb1c6a5ae0572d91a5320d60028030885b705c137c7ac45b762e22870e9f3d17504b98aafdb7e53ad19e6a9bda427eb079692ec7082f20948b2ee2b574f75cd8385997d9b12f546963acb52893f80393fcd0cedc1ef6480abcb0dbb1abb12ba9ae5f9e60d7a042ab85962e583d0042f80d6c153d1b35da54a4445bd0639a373cac6d2b02f731ba0447d76a9984c114218f9d4b56bd8decdfb670ae2f16a3058cc1ad9ecf855fe493bb56e898c105339e98a493539dad5bc0ccca6622da333f01f9399788d5f567303e7a93b872141b1986999bdfe35814ce8523f85e833d850818fb1762ed9d18d0f6a4a2ea933f9596cab470b0cc826560aaa2d8949e52c24fcbf22b65b6eb5fbae6926f8ad4b72024df892f1c472e2ce84df44c30c71d37fba27c257510c06b1e4dbe4a4b50eb79facdeaa37d72eec91cb18ecffc424ad240692309202baf75bcef7a16db62c99bd566f3b9129fa38cb579a2d7d69810563d519567259817ac1af85f4f81a6506c435c1c84abdf781b906d1e13e00b3fc03548a5eea45f7a70a597a4165a1a5fc6d0179e3239ab289ad7df8b0c06f0d67e051715fa6a5b9ec77e5736ab071a185e09cac5322d9493696aa5a9435fc80e619c7206cb08115883fa3bdd5bc7eac4fb12fa0c09ff7fe717232f203045221e13bcbf836aa8a459f314d520e8714568829eda3235afbe78a9ad119c04621c776a214d0e898a16b58cfb6628d2999225cef86b85c456ee89c4c0305346713e9a7d8be7a9debba5de609d9fd139c454dbf9a7536856d13eece7c672c9e7c72c4cad08685d025d2f610cf2b6ac3e3d607fd3b85eba0e3293277a2b4093cc70a4a9a9a98bed6be3f96d1f07c4ef0445eaa175b8aa32172cf3a90b81261c662c7e31c0ad743cd36ba4d0e648977409e39fccd85a08003e510133d5aac144da8561bd98e05335a3f0c3322883946dff92face9932dcaed1a6f03fad1e11b235a2af03bdbb6d6d1bac31a59c3147f193265a06228066430b4873c8ecb235b12d648aec46117795f32fda9c78129d4238cb9408202b3163e854dea0a0c865af9926abe8cbe0b057e3662309bcca7eb344afbb3a17551335f175b372d1de2b38e6528c4d4a4f8fa6562d2976dbf1868648d21c9b1dd3f4ab4edd2c5bb3f3eac84d4f2564a34509bfea6d2ff1006251ef08e7237f57521285253baf56c3215bcd9a50bb27315616d6fd638d1c33eb17237f00df2b4bbe0493e0d5051ec350e5670dc1080ebbca421ca5e4bf02c4b0f07280b91283b911819f6b5cedbae380723d4159118b99c7e3215807d1caab910d943ff633f6d1d1db01d4fee8ab11561a5cda4894716d40c107b42d78be9de1b66cde20529112e6a668dfeea98095fd861805e2b334b19a5e14ce6bb4025cc6acbecf53fcc4c63b1ff265273fb9b038864b96afacc1dac952dccdd81ba0f272a5258125d6be9a092bd26cca96363d95b82f26cfb38774b0fa6fd9d4419592e38307c70b07765284d16154df1c07b1374a0a1f55f81dada00ec926d756d7073eeab13a0f0dfa870c2b82656c006f6c61fb038779f5a72e67014179360df7c331c8227495d160e4acae7fd19b15db9b9e83918ed2aca170caf0bf7227da79f7226314559318dae91f8f8c3873d14dab2bed120fec4e1f0b4f8ea8c5ad80e1eadf8cdbd10e597abc5b197c3e9d9c7d36d4368c46e41cb87c68ba4bf32d55033471c8c0cbd55212a9c35bde63cb85d3ad950e74aab97fa613d5a075969a16c44a458738957942e9d1dab7b0aa36a3754c3a0c2a3539644e526549a608d32199218a227fead7123b5a352aa45004b3abfab24be4bb30d5b341d6e249e5353b5e73d9406c60088aad811b8f4095ab385e890c2e17a102409e73703b2c9a2cfceca052b42e45226d76a5c2a3a00bf28602a8c4cd7003d658c29ecad15dd80f4b4c661530452ac0a73b28b530d38046efca32802b4e133c22b27fa50b790c286863b796c349a2b78cccafca226735ac7c70f418a594232589f909d5048718584893c5a23a4f1611d5b1eeeef28632cdb692b998754d991e9a5a615dbc49cdbb56d4a417fbc6ba46864375523303245f77d0683cf6b54b1a1154a3b53f51e2ad5ac0f6f3a545f0ed9a8631ea800d6425674cc1d81bd1423573e2ec2456a518ee412a1b9ca1c76269aaa612219a5e49fefe7108681b0cd3a147ccc20c3296aecee17c69f97fb0f32fae775ee27e39612f190ffcc1586fe64be6a669733ec733af8aa430202614f50b0f27482e86ee6ca1411ac65f9b6111c035339e40272ab0a4621bfacb51e9bd786c1ae0310147e7114280e141a401cd4ed2f96c6a0ded35ffc0dd8a7aea4ef51134eebcbe71aa3b84f4a5823c937580c418fd7471d2ed10ae9b8281b147cc4ef092b23244ae26aea75ea3bff34147d26ae9a4bff598e4a61ee0089fdba70a5f76f0ded4254d60320edeff5756791b8b62d9476d05fe594fbd399977cd579edb2f6a5dc422a15cec640c735d764f306f7c81bf6e97f5db502d8a11baf0afd663605acf6ec9094901e3815c0768230adc787449230dab1cbef4138886af24b9dc5c095c93e51c40f9db23428e373834e70079f3d024a48d4fd60184b8df015193a764beaafc37b43cc35bd0a73ac26a35259daf4a239b72aec141d10801fb926656d886e7937db5efe79e62e8dbcc3416693978b8ce6796a4bcfe6d6d0e7d320826bee8a76fdead696abd835b34ec4435795ab5e573ffd4ca1c4dc410c696d9e96a1d5a8f04c9ea04f9838363994fff9f427d21239e056781afa7e35a8e28e414902065030b437f305dc4548ed4177ce9be05889ecb8b4055ef9e8dbaec302a5d175d0c5cd02cf5409bc8dceec7f3b6cbd471f372620374b45bf777ee5f6651dd77712cf3e10f2541c2587e1c3ebd9ba22a8ef0bdd112af07e842d755f9e4abbb3b5f85d7620bec26718fa3e86301c6c40251318da093971951a7490588418a6e53c94142350990f0a93d50b3c76e9924b7b31be038ba912562b25c5087efd1f3c223d75d1af2d18f4d92a6627bf73c6a3fdc2425473ba211c0006f6638b4a5bcc22c39914f06faa18b8206a1e1cd68d1f989fbfc690d54f4187332ba33c275366915c6241ad4861859bf0550e39ea49f0f2db2c71b45b40491ba948b06dcbcd726e006c7367aa1d84df22fc8a5887d7eadf0fa6d8176570cba3de679f78fb866513d3a24dd11de5382be860482f9448e4546bd205a9f42880d281830953fe77164bb02d8330d91afa98d6eed37f1ea6a6198b9e097d7f5f03f717008a82da8f62fda88ad7640b211ba270c2343541bc34ee5f54920d927873f4fd3ddeb46681f3801c5a883f68cb03fd8e60b8bb56335bc50653d5aa5d8d353b0bc65bccd496cd10dd5648da6df7f01fb6c6fbfbb40a39914d3b57f32a99f5201f2a23819f63af44d0d22a457032a849009d3bc9e188e8fb09919aae96d82fea0d9faed8b5fd13bc48f513b552a2dc2a7cec334a4f23fb5b98cf32c00be471969fb9b11d00cb27c7988f3517671904a83f21c77c05490ee246111b3e314c00238d207d412e132a253f167150432b60643e14e26f6919e778be2fe8890b72b0d420c94a493986a612904d9321441904dcdb9370af66f67a5974f1c902712e3bceffae50a03dec86f7bcae3b5b76115bd7240114d94d246d459d65edbb432e4c409b707aeaa7e52f694c1c5adc3bf0d4bf4c2d850f56e5707f06ff00275b1993ea2d15a872ec193d5a81a07d3a8f19e2e30b84f1b34694f3075554b9166e76d2071dc86febda8f199e2bfdb915fb9104c564444023403f0ae2a46526527b336f3b47115ab5e3d0fbf0d36e9fc64a11857ed458121bec72d47ed1ccc54830834f50354e8fa75d35820cf2254a57b75cd06c14a1f603acaade0c33ab9d38ad8a4e94bea72ec13bea793aeccf1cf486cdb43bbd69c2673c43eff58886ea856335faaab506dda070e73dcec031155e58df7e637fe3427494eb66b4ffc9aa623e8e526eb77fe4ce6f7dee026eddec1238b57c1994f2a3de5c221d1f600cc11efa4f4e3c39b91a8c48a2453ccda34eda855a5b70821ea03e4db69aac085e6e353bf5c73754ebed274858f3a3c59a776f396b678cfa5028c9a39e6dfabc9e73b5fbd920ad645bcbefa89ae13078b8260cd7fb9fa22f89a1a1b406b80a0cb2863443f609123848c056e5e2c5298a59741eec1009e74b3d8baac3b5cfbcbfbc7b0291897047f04f6fdc550cbe7e829776d85b51315d97f36efd637bc26a3f140eb689575727466b4b8449f41da23e4051fbe766edc22ae7fd432a86b978fb5ca49d2cbd78fbb14bf223d3660635997596aaeefc4aae0c009624057d860b97aa0fcc3651939cae6cac0e4b4317f736b7684f234e82c40860a988aa7f4cb659d874fe7592306b4338231e0409c7f03cbcb49ae2c801047d9e9dcc12c1168c6dc5b3e655145a3684ff6aa2b1f3043492adffe49723fb1b4b51d35d929d1f316222f61007027432fc0fd0fee97fa66009caa0e170a541579866598f49deda5a25e7550139b065ad44a70790db23fc2b7c061b4f9f5d6b049c9ff729de27d6e80e8b565d518a790739f3c7f8335bbf073972910eed1237022135ce5803dce544034cb7eb2907d665174a5967e89c5318e0639ce60aa203a7617c61c2bf0d9e42ae4671ca565bb5a144ead2f452981bb991f379fd27ffc4575f7576da7247014cd18b2b553b78b9b4c2c1a6b6b10928ea3d175c550ad3ed7694291dacb3d64393b499075c0eba62e97bf8cb952a77f92ca0fe23b41bed241b16c7630de90d4079186dd179b413ec37188a384ab4316812e9c07e44758bc221afa22ea4a3c144d78f3fb55e3bf87be998a7af418a932631771d7dddc80350dd4a9cd48a20820c07923b24dda920b4cad2813a52c103c6d588aa9b353303dab51caa9277c6c8008691f5d3761192e5003103520cedc3933a6e42b1e7a8234da262fde570c6d068f75203a1511d7220caef0ba539ae38bf892df66a3c305b73cebb82243c032c03f8fe75e6852e562594e615771538d84066ff884de6e8c6233cfcdf8554d0dfe248ef0dc26625211293eb4a31e48e3a09b5cea78f9df95436334d8b41067c922c127456a78190a10e17c4213b24b2f32770ce2c39a486954afdc9ed0916919f9a6c83107362c8c3820f7c0099e27d7e76c76c3a7a1ce8e70b065eb4368569b21d541cd104aca393371a176ccbc328b35dfa33a95a29e9ee5a9924d21e66e1eac77fdf27849fd1dfbb0004bd129962c40329914618eceadb6a9f8ca4b4ca7a49a20569cb498066e44707d90915fc08e33230c0fe151c92fcf0b15aeef3028f4344fc93239d7b387008c6444c46d62c2201d9d6b3cbf8990d91bac03752f84d90b27605ea0cf297bde426068b843cddd150dd87f39783716df2c7c5e04fdc75627d5654993da727e8e8e394c3f1cb90e872ce40fed9ca3afba9aed9229a2002cef4c3be64071b300fe4e580b9ae194026ad42060ca98c98c2fb92cfa066ea7ee5d690b30c076d6357b3633e6d688ae1eba5e086ae6736db208ccec885f2236fbcb00015d86ef484bf523dfc50da2139e826de702f2c090d2f1b85d482995d52ff0dda6a46875efcd0a97284fabb8ca818b0ffbba50fd11c5a21e34ef50fe3f80abe3f64e9f6ac90df6d92f39344da1187fad52c7d2461c1ac073fe75d1ffc9d80224d05b572c6b4a398ab07ef7533033e1169b2fbe0977dffbf815ed4bde63f020304497255343308c82f59efbac298b5f86349d3eee752823b1621ecb555151f436213f7aaa9c478310799c85a845c28f81c6061c18053e58e4337695e91241d927723fd45d476830a267896f1f2bc7424c0ccbba548b88afbd0a1ba5da2407c97e266a7f84dc2e71245d90215113cfe9102f27d346ab962e3cc3ec3ebae67514c6be62d228d286f043d061985c9cdbb79dc443eca3cc0e9ba262bb98ffbc00a272652f59a00949cb5f1dea961dfbd334ee04e145ebcb674f971c2e6fc1e0247748994e8b3be67b2e896a0c5ee70f0bf54869abe49be245825769a7aca234393a6e105420e68af88d29467f7db34db703896350388927dd1e47383ba0043c88ab4ba2a0e30594b201d6813cefce50ed2bf1b44f1527062a62774e29714dc238f067d92dbf48da279f26cfa22d671a5a7d839647c584f579a6d80be56313478c3246471f48f3bd5b163c7d7f6b7f2b3f074072fd54a5f6e406efccf6d371bfaae8f0de9ad542834017f28492175a16e59a6ed2b0000eb66a9cfc94865121667c832512a53efaa6575b5b6a6223c9d83107500bdd5721ee3d6f948f0747ec91a7832904c579b56b67eae0a3f1910d99f7b32f43a62f3f015282c74cd30fde1a87f7694e6d7073ee38d243803b895d91def4b35c64263dc1395a11def684a952a54bc0d77c7a75a2a8da9acc21179fb782b779c6f19165fa945191640f0f55bada822da23e5871340f08d90fcdeae516f723ad6ae85cbd27a2a5b49bc3ca7357b3ca74cbb3301238c941f38c6a68722113d686fa4a55a2af4ba95646cf15f1b64089228d64dd2c878054d84eeab084c61096c20316bc3fe9411874c894f05540f37fdf0e4cdb80c74cf20ded6fe0564933ed3ef2843b5774f982f5bbe8a244acd2cc4f6e19ddd364d618a4e35fd4a6907710ff3d636ca5af5c627c5e7f5b1a3738037219d9b4a6b28c0c380da77654f5a20023ae58ae34687ac899d1e6dd7e8e28cd788750a0c56c0797c6afd04f693befe29d9cc10104e35e38e26a44998584066528b2aaef4179042a686f7a1ca5494bf8865e16107c74be8ae14c096c2a0b975f3760c3d4f4736264c8c3ef9e90f366a1b735d85d0d7285dd1d0ce109bfa283d19156a9d8566a3bca6c00d7625520425d3140457a321574e69d184161e3b169c44afc59d678fafa2ba2dc34eca6e3244874a33fd1b5693579229a4515139fd40356f9842e5e6beb97168d37d29b0018b38429f4468ecf6d312de9fa538cd70cbe4a6604f68d32f444a7a967e6d7f31869b15d12fe41cb0f29ecb960c7f35028b8e6d13a18b49f5cf7140be9d9c4fd79e59d2580388609268efc0a8a4b6a94445d4bff156a22c871b69be0a81fcffc7311910138d89d55576255650f922d0661914b378dd76a5ef654a4b611d6ea6c458d31ce3b45355cdf992f5d90d7124338c33a7d49362137ddbdc3fef87d30e497e6e0e1728d9e82dff1e701273402e9ce2f22825282fe78ad5c7e941256351d95d360d83149faa6e25de1121ad57cccf399fc434c1b74b15d3f726cd44ba08ed79657340a5105244c33c55c2883ad7c35366ca1258a0e0e40e4cd47066d7cf8971344b61b4ba0f70f1e7c8be78a362b3e301368e1b0fd24ae3ab175312e7c20704fb347ee4d6d77feb56eca0a72a8de11a9fd3798823e74eb7447762079ed43cf9d969ba8573ecccc045c590933f22d547281fb7053a131a892516538889f5c0c2997111dd178d3b322f140c1e3489a27070b121ab1eb90259658cd822ac858fb61debdf561b2def0c46037335b1fe70e0fdfd0b023b498cc3862c40adbfa309b5581c19de2923f7e8a0ae06b8e2806463e3e11676e6c3eb4a54ea55e53dba9071ccfbee821c1c31979e068bca3b7b5b39a756f71f2d6615af6dad49daa5095784f9abf759d48c35972f88bf0725e880d857ad4a14130201cfe88f3936ae4d0adcefd4628c77061fd7aec696dd1aced1a56b8b1735d7cc638047b5f1c4b2c82c4c0c45677aeeb2b351ac9ac7bb4517d590c80ea47997790aa6c38be836983dfafe377191b1c9f27d19425cccf2c44c835457cada9fa470d09b9079cfde55747b764075cdcbda8b2c3424753fd3924d69d5b29bfc84b93a1ae06b019fd986ed13b86f706c130c74439c2de2d3d7e9b48a05062a13601dfa4c18a6be0c3e283087540b4ee478551aa6177da49466a12fa6c7e0b53cb39f52f95f9e7010707fea1bcc11c7cfcb160e957261254d88de7811f1d2a3c0a8dfae04afcefce89544c053718f54b5bb27ce79ca7f0854d59fb7406650e2a5be2287cad3458a9f1a12c4c64b6d41b8b84c49091521c3e219e80b245092fdfcccdc599d9ee1acb79b23a76234ad5eec807a39c1a234fc33dae854a41a8e51a218d0250a0b94b3031a143c2c7dac8ec5c053d52c3ac4e0685419d13189c677b8b5ddad16984688b961f08ea9a88d53e530f33107ddf4bcb0dd2f21bcb874caacfba3680f36c33abc98050a6fcf6edc7fbab6d97003ca676bae66553fd6112a5c7478f7806e367ae2a3220f2cb11e5794622ab04663ce8e59eb1db15544d0fb5da1ffd8e31b250e499f482c294316f5cdd6c947e521e7a56fc081149e8b65aff1a71d5b17ffade7dfbcb8ba4f9735eac6a4c1a770c5f055a1d9fd40156c7a8e19e74d2bbffb2644ecf664bc82cb690693de8c8a40427d36dc6994386992b4a07eb1bedefb5e4e91df33da96837f8f1a682900562c5ad93b354efe90f16d2d8eac700d44d533b1553f26ef5e2875952687966c2b1a2746af2ffe95eafe4c88a84013d1e9864cf5e0b4bd10a6911e5a4fe9bc43594ad2a8e799cdfd09d77728717e38f5cb17eec0a07797054a893d676ed19f7b2ddca7b22347bb3091ab299120578dc6ae967104827ba97a900727c5fca902b2510fb69185b28337ee7a957c6c5bab5c4fde6fa6ede4db50c294b2e3070df4ecfb07e906a2418753d6df54df0002cc432da1043d371b895fed476bf7bfe5b1f8c0bf9775a5d3eb3fe93974ec09f30b9383b2b5b27485cb38ec1f61d75ac665df2a804b5fae163186273273791c0efda30d37aad3f92072c29711c1f1b52c2ea5041733179c433052db2e8ff834ee774636b948ce6688033464a48c39554f0e4650e4cebd49295750a10f3c9f28a0b889d12a508a65513b3e3a1f483c2aa77692e8fb41399184c80497518f748cbbfdfd43c255903be8fda7cf8a816e95b1782eebeb687e97cab9479e169adde987aef485847d7e230a71d6e5ce1b4ed88e3a145c52095afc190220cfd685c18bbed428e3754c7b513b3a084ce668877539013d02c200888d219361e7a115664ba4b7d6923e43a4ee8e655f3edd42784cdaae0b736bc286015ac332fdd1186e9bf5efd21dc1942ae52f65cf40f25284edd2551e705ca0ce885818131f6c231f71887119e8eb3b77cb2659360934f3ab9e9e0a248661fbc41723fe9606947a8a649707a9f9cffdc939b1cce882840be38d44f842813272973295676605e542afce5c71f844bae1d3f4634c3ee7b82fb167bd6cb37fb1869abae09917ccbf1b8a8968edc761e34c3e4ae89a45152a3940ee7bbb99ad5ff983a6a2b415501c8e23abefb1757b1ea34e4bcc35ffec5a3ebfda72c3b16b1e59e4c05ac3605ce880bd6f32182976af08cca94f6b74a5901ac311112d847b04a27947ff0b6908baf64486b0acdf6446bcf5e6741326e2e1803b303ee2890c246528eb20284bbd0fb4f17b332537d2cf2c27da1bdfa39cb0f6c983f96f14ef0d958d92735051d217e45dbd0d708953fd3212a352dd525cf79a24a979702ae3bb55f250a23c217db4ef52f965e2f2f39bf1e81e700935e1d1477225593ef319d5af7933dac47c9bbab5b9ea435b31ead6b37cf988e818a8c8c2353d0f2611b3f2a17a7c40e1a6a077655fd505ca8154e3b23010fc48064ae40e4dbeea7d2a4ae1209e2aff96787fa5332255af8b31f88b4b86370ac4ac1afc880f25299751bc1cd4b7210af6ac71ac86efdcf73928dd06744fe9d59d102120ad187908f56f40e6bdcc38abb87d96488f11aa7097321889049169de235a7f26d0d48fddc5c6a4c7b0abfc19e57c3e3bdfa4868f0b4ca21345a16d3e0042fd2051d8ea553926de6639e64454cf8d2cc0ccf4f8a9a366e6c77d5c7fb2e2f1810a99cf97ef3612a41d1d65037ffb7790039a6df0dc6b9213d19761aa3a5a15097ce9a0d3fa6f2f6c7d4e539fcfeaf7b695798c2da73b7bf0d0cd2c58d30a537ccca89f1201c6381261b95e90f9de9c868180d3dc031221817c48b2ab7dd4880e4d5dcdc53b4b6484e7b69f0a37f41ede3b7e1f3ebcb18dc1378e6edf854567e50a5375358b85f4b29a1f0baa87d56898cb6af2c033f6bcdb3adc6f4b0fd7186458c29efdab3e60cc792a1da3d1ab6b829103c8053327e3216471a9420909b8f1f70d9b6c760d1c837715f43378a93ecb9bca3b1c2fdb147fe5a5fc3b213506246524b0b951e47b440ca9444a08f104a3bf6a9c939f334f8405f1a8d16809cbad707e6994c8724228bdb44f3b14f8a2a6c32b453b5a701007ab270a59ee535aa11aaa2e38916f9c96057bca7c223e3d8c8cb6777c0ecc59c8b5a42bf7bebe683f2422a668b3f62b10d4c2cadbff7714d633dfca28d5ddbd17c3de64ddbe4f830ec675082b31464f7559ea3f55e251ca9844cfcec2ff7dbf83a5d760cbf78427e71b55bff20d88fcbc02cdf41b01912a4599ab1d3c31b1feacd2cafca8467ff89344c96e6c8b683ca3a64fbbb725e45dd97aef2efdcfc4654249dc0a8783a4a76a767a9edb2609ac2e29f166da8528d747638060bd7362f48018f46b329bea3b14f8c7488d70556833c0e2250afff98535ccf0ee9bb17d5e3f5226dff2a258941d06b5ab3087cfa48d1a85d73294f79e8ee5f84af33df28ec2179f1f75179cfdc0192e9d31c4e5d3b11b5155df6b456d74b00f987009b8cc586418f7b83e72524e668cc9d2d878f41b72cc47c148cf367fd20a6d7d7bf04cf4360b4036935783a99cc06248b579f4cc5bbd342baede2dc23eb9f1859b3922f74ffe9cd6207365d0dad231e3447b4373a0a313ba503b72e007b406f29e2f9a0f50504e00c5c71f246a00b534d0501d962cfab87d5093262b277209ac06d71ba4896225f73108ca8234e3d0d57dec7db0f4581fe9516f3b2e54c8bf7fef3d2df34f4a55b98f43288cf87b6c9155c2974411a8a2569afacf4d2e35fcc87e9142a44c1454639110b7c1093c4885c5c3be56220133d884837a112cdf943f493033e57abe69cfff4a8108242be7058194b95327bdf8fa88f07a1acbcac27cfac580f8d0522c5338c86d2b32f3c499c2032fcae7cb240e0868e70425ab2a65e8172a0a37eee2db99923035a23dc2f590eb001d2935f925c337d4decb8b0920db55249710f5b84ce546e5f3aacb46872bf251f44b753008bf2696c558156a91efa34173780c598fa345d5794f7ee95db94ce608d4e3488602a7706b9da38d3deb845eb8989d26e0a727c131c603143606b0530c3c93399f1c794fd29153a866f3af3c08298c95a6bf6da3a70d61388e906eeeb097bf70ea14b6c1d6fc71cada4bfb31b517e23eb29d54a387799b2dcfe5a69e57cd7e5ebb1cb4982d68e3989dde4deaf31f92546c8701d3c4d1d6d932ef16090e07cb5cbf9648622f4df49dcbce7e06823d3d4accbd9f097e2aad136c1ef2cc26206f980fbda18e78b2fef2dab9936bb9400aa7cacfb2fbddd566668f1b634b47353dc0cdde72e2953eee73fc19c0bfee5dc303cc2e82c3a193653145cd7c967d19312a330c87a997d7f3784b0bd67d52299a8cd4f2cacfb084c0183a0d0cda8884bea5016fab1a69ad61abab50b8865871bda4af7a89fad901435aef8e04b519e98abb413fcbd1d12a0a652dfd606a35abb0f96dabfcc9d028877e1c8d40ffdd6d2c921b431b77a1ce33809895c474a1e15a3a71984295171795611b956da104dd7b6a3fa4510865eb7f326ecbd3f407bff580ce2dcf0e84d90caa703fe8141f0dcccfef6d5e66f5f0db4fdc4c8fac38998ced3d5c7f8840b37b8883f10f5e75c295929ea9e8110a25d2d799f8d19b4ba2a6b33b9c19ee970f61427cc7629225b61c28854d02bdc2bddb52cc27b2bf68f5af20f7266ec7b0ec1929ad0e9abaf284615ae60c48b63f42ab6152697153530abf99e8d4e140b0520782c7116498f2706c9e5881b427073cab2389d54177228a156f15a43bd2b5eb23d85cc393cae0c61d32a44aadddf88fd0f2263767e5cb407b225de58ac22a37c1311c0007a2b200f6c967b1c9fa504fd6d7c5e1079e2cf5620006b71189c9556ac4012b0611995444cf028b649ba6f07bb313b5736195550ea6624d5a30fa72390399284676ddac9124b7beec011d838594e238b00008ed21a1f975b90342a2e65099975d1376426b609344f1551e97683bb15359f9d0fcf9fa1fb3791a0357f63d4a97c69abf23f5117475f5cc0a2ec5d11f6495d997df9dc5c2a73fd0d603794570fdbea4c972e816a093e8eeb97c345d2c07b29f6864f91f66536b2ba5c4ddf1f1c317992c646c275c3985697e945a8f9c795a0420da8b683e455609e1e6adf8c73eec083fc01914d8b89a1d4da0abb18f39ecfe36eaeb678add01ca15e2afcee075d4eac95a2f63003997eda6940ff732927b6467f286a49010a963e440095b8db226770d9e3f145ea2991cc6f0aa8f6bdac363ec56a74a4eb9044e9d1beb38985cfd0c542dfa7d8aa09ed3cce3a13eacb01b44940614be489e48385717e698bae8bc061b243cd56f9d51e2d17ae5254511ec70a714a0865d170cf299915204d9d4990819ec35563b438a7ee78b9821ad9108c13420da1d77679938fd209b6a8d9e323d83107c6c7ac080823a84c2297612e77a48a66d1e65086ce15a9323257ecdce44b4ad259bd8acb5d31ddba18493c4ac5ca213daafb2025ebd77f776718b52910b2d075a95ac42148bfc3284ece146d4efa1ce40d0cd927b59ee77b7bfa681f93d33531dbcf80520e67841d39f34fa2daa7e36b8aa249d5c3b430c3ae9e442072cd558a1b8b48b707d073cae862ed08360a2c38e52777f9cebb7db59cd1aa803809b2874cf96b3d8944b8083949b8c19f6cd58ddba1e707d18ec53ebd456f3132fe65aaf5508c2ad948a3fe95c481490f22d36905013f510fe2bdbc6b2b215e303a5ca6a23b30085f8f93fd46e91309fa47ef7279c365a8af8bac75ffb54a0eafc6fff5c185a158dce858734a4328371b5600dd235993d6667928c17774d8876babaa6d79c544fc55897fbadbedfc9086f5a00b2a8422cea168ab2a7ef6c55bb86e218b11bec5c1e6d769057621ba787b562f2b9a5214178c6439ed21fe1e2fe0e82178788e6379e20f6a382e827ce66a4c1b80469db281fdf1962898484e94623e540dc8c9c9fc37689be97c174b82b04f0aaab7bdc17b31f340c181646361166e2b7baaf2c539e8ff7823e3c8b70ce58e22a7f7c9a32959fbc454f2168d2b7280e0d8aebfabf55eb09083063a425a65f4a6adda1cf374d52b7c8307b0334b637bb1bfda8192db36db8617a0f0107dd4c330df38a2c6cee57283e5b192088abe788e15c78818224b15c0bfd4e3c65eb7086587fee5470537437d4607c2deac1842e6c72fc349a35645122586a2dd22fe88ec2287987398ed46edfcca296c0c63195c4e6157be53605859233858e60c59e84ce152fa96915845bf5035b2b1325957ef9259cf0e8c87ec61bdf914d8fc094965fb2cdc3d0ea26e1e3fefa95aed15db600a06b600ebf964d181b3018e652774cef1cf4aa102b01f10b0cb7ae6527864c4bbabeaf1a7e14fdf879a6b16d21cc88331823c30f77feded0437cfb87b7da32cac2c5846e9a653120fbaacb4cc59a774eed25e90b54d44a9616b7683c0d0f6208cf5ee3e3e6e53da6a657ea4cf9db101094371864a9f4893ddd904b19b4bce22b52507269a440240f3649cb79a319581d555a186015701ceafb342caea36d7cff860a00a91dfbecdf45b681acd8b7ab474710a5b704a6783bab8a359ac9dd3512633557756f67767627c0c2aa0c3ddbe30df084a7407447764ea26e4c94203dce11969908debe2f31cae0bf1848d24a52dc04f4f9dc2dfbcff570712a53861044bbdf4bcc0cff9b618ab90e432d98374af530973eeffdcd6191bd5f4705ec33f6588c77a47d413195208830074e2e83bd7233f888912fc5b261518ac69a0bf1b0fac4688d435250beafb9ba7a4e15f590c847dc6e5bc68e0ed1d1d1c5ee203f18fa5ecee6093b30c0df3dd11323263fc9fcbb137c9ad8a4460afe75ec5ddf5fded530d71ed972029b56b5a53f4d8ee1782779a344a792cc93aa06b9bf9257331f397f2116a71e2fd18f4c7c5adb84697bae513f7cd9a2815665be4186c319515560520f8c3530078392dea41f0018dfad745765db8caaddfff7b1764334451b2e8c26fd37adfc4048f9f891cacecf45748192e83a8b9dae250996dd090e17c087beac5a277efc8c080470e83825d90d8302ea8521405829e6a0808c5b885c2f773996d73b9e60b4f6b7092c0565263d96c8ecda83f0fdb31fa25f22c5880665ca8ad1b4d17aa894a32e164198d4d975ea169262048f901af11cf00fdb5402bd2d77db2ca90a588e1821351794300ab5f51646ee108fb0f84ab5a86ce11613f402cf7bae4ceda148c15ec20fc82c0f7aace779c874f86005170e8b26d47ececeb1f32ccc229c80623f65c12cd52433590b40a772f7825a4424cff1c4c2a9ad4162a24a68189efbf3928aaf31cabf2009a90794a734ae31d5160c838581520137090b37476060fbd05116a80ea78e04f64776db183b147b6f18c9a2466f2d67129221a05eff23bf85dd0c72da781d2483e9fc971f93540de1c5b868c9750e064770d9ebfe938a05fcb619661e3edb6601b9f1037aabd75cf2607f51ebdb6ccc1fa66b4821c7f62a4caf41e3ae10142b4cf6c8181a21644b0875481262f2f2c3f522a778896eac6f666d8d6a73d48bc15c46ba535e7baad063bcb9f5c41a42bcf85113cf30ca8ef441a3d3cf773a7dcceb7a977d34138c189d67591ed6889cb2d1f227e063963bac6a0b7ffdb30cb653fa6cb65b2f970849fd65598e270232fca6fe0dbf60e02b542a0fcc0cb9ded1c48f9a853d9c02c88900fda8fb9527abbaf613f4916424a8d9ca6c38c9bb5c60d7b1617e078f8842bf8b45dce08b89a84cd31353d5aa5f91425b9284cb6d1bfd758901a0b8cc403b93971a59fe37c4bfd8e074bc757dc0fd411fe1ecd1b729bed35f8daecdf7f2569dea00437083fde0ff40d2ae75dfd730f20306e50dd0ffb813b44b9dd2a26355ccc307b990b0bb392790c64d925fac1572c5f168b3635b63f5cc9687f71474eda269c1b26d3637d2d80f774dc93a45e7ec92377baa9dd0cbd0779bade5e903e59b8560fe9c0068e6d3f7647ee666f452dfbc79c783535c8fa597363c1c4ade2ed1792e59727a3a9ee5e3ea65496ffc25a785b9774da41c982d58ecce7e0783b0e2b0a36b79aa57928e614b3a1f1b986b59b68ae34187c6e5748b41f1407e4ad8908270fff8286e1ae88ddc2fd902b2d9b1c7ec24a7db8b9fff8eb17f22081a26da4647b277123a5765336663d122da9718d05815f28c9eda29812a846d13bb8b99c0549df737264d76b79995913926b2f30e67c0d3b79e72fb8549c727493ebe03cac4d1152c450316ce63c1ba905bcd5cd4ddc0db80bdfd9c94763c881509c86259281c4a73d58b0261f6d257f5386f4675a30312efef8ea16522e7ab19e0c79349837482f27fdaab1ae0b5b95a85dd399b7dbfb98fb3af6fbded29080e1cfa083af84ad1f4c6b46066bd2da4ca1d43d6cceba3a1024ef3afb4fbb508207c9f3da02336ac235bf22ef5239ffb230fdbbf2f784865949ec6c951017f2cab525bf267e480d67be6a687ed91f32b93a4ff76f9e98d419e19a488aaad4f22b1424f20fb6dad59942a89b50a012cd201b0eeb93fcad2cbf2d44783fb6cfd05f368b18425dc7b0a41e162ece664a1dede07c843ee9c76dab3834f9471c0ce429cdc793bb75502a1c3b2e0c907b5dcee436a5fad11fdcdd8b39947572c902d0ee5a02a4e87a9ea6939f9157ca108ca3e074c4fd3a4faa090cfd3978a2783ed5acb367b902b422e399b17f9a79dcbbfbdbf3f986f1845f09133df50ba42d9150d4590feadfacdf1775b7e83007d4a85ec9bf713fb9224bbb951394d4d58446c09941680074ce7ace85e9c3a4d16863f0089b2dff7984215baadaef5687ac04628aaa87ea7860431af302fe89549e5999e1a2cf42ed4c72d4a09033b13e40f593f372de91e180bf28028cb13f99c118b4e8242cb20e977f8f805d33829c2b1161105c9905df39a5b8466f1a9ad80014d69d62ab40a4c9eb9424a2f8b471d94171419ec85b33309defc8884afd9441389ee295d368802e193ef14c21f8b3fdb3a95f3794716eedf41103e759fa512163f3e1217c1f7dcdb885953a31ce6b792744ddca3cb27cba218d2630a94742888a4e4516c7233f2e3bf4193bd9a372e21b4956b18ad92ca78390b05d24ae5043bb92091b4951d00df33a40c3181106f3a8f2dfad953a3eacf26edf569751c6a0b877b4596d665dc60fba4c5952731cd2d6b6b5d293d13d120cc4414e43089a1144043f4c17508610b2d2abeb380dabb9646b32ce42ca019e6963efbc9be65bcc3efe45faf93d194a4723adf0408555d8db00935fcba2cda818a0cb4bc374745fd655f2ee3f29adbb28bf34b194f912e7b8e468a4feff8619ae8d956db76dca8374b2dab607ac17ffddacebeb40e39d6128b8a40c6876d02188cd2f6e2110e9cbee1a95bfaa4caa67913edd3a621c9e7499ff439367d08bbd6996d20d4d8d161afca336058d3096dede2d2fdc46968ad0caa2c4dd1b1860419f4fab0a3cf8ff20873f8912dd9892fd0eb60f7b8db99724ee01a55f71d25f43610cdbd273e8d17388b44fa03ff94875296dfd74addee849a215484288c76f69d509c4561d2d5e560878ad68345f3b527870f48030f88a57599e54c62396ea490cda97fc71c5d1142e7a715269fa006f69e3c08e7d32df0f4ab281e4ca8fe839ca61e453acdd95bef119e1a00ad88677b176e9851c46e2c849b19cb4a81d862480b842e2da7a538c2a491652b66df15e56e992d40cf7aa659e64ee8d402834784a65e57d99a39f6557c521030a6db19fc6d60c25c500bd859e21f7e3eb02800b8ea158dc8100d9055c15bebaad9cbc74d419bace93c3e4510ea7bb5bd10811d3da90c607a6b9a992bf883f034ac96dbc78086f79e7a09b2f17d012b844ab97cc9206213b2a419d32d31176d7de0b0755d79da4a0eb7653b963deb6e9a86f2b7244c3bd0b673ee9d9eeaa89dee2eed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
