<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff48429e69f3e946f268d87cd6e1621a91dfacfaf82a3fa9d7e164a5938a704b3456a8eb68740dccaba79014424b981577950b3fa0645bd026d5481f4c32e16b27912cf92b4796f669602f5a7f970de11d30966e03ce062dc01a7d539c96b0bc088cebdfaeb9384bcf90564260834a31e14435baaeb6bf8238601d3d3c8d2b9927fac60140011fd0fdc9b0f4184eebd5f0ac9fbe1c3ed6438c989e4720312a9656c747839b0333ff58b63d9d703b23dafc374c037c54b000e297ae3e866ff3d3cec50b83e897f8bd7b6e31116880a5ea117cfc3ebf7d702ba1883046d1ae35019b60364ae9ac1233620bdbe8f2324e8c445d9adf336e95124b10c5a4a85b432bb5124aceb7c088246b25bcb7aed8ec0a9927ad98b0727ebf9e3ebf6f79173dd91e8ab0ebae7320f1287b14e127f09f5e19cad19e2b29a79e6d94eb027094c167076137da2880782991beb05b5c31b1934fc7abd1799009a0d2fe2cb148e56264a8aaa2e70cd8de72272de99f67bd7cf49c317d21a22469b1d8b277f3d8c162321ff302639133ed5fba344792deccdc2274bbae9b529f8beef121883384d205be41bb38de509494de7500e8d9a2ce5e263d6584e10e42a8fad82adee8231f2e5f75836cfbc1f05ed3fe07cd90b26f58e4d40e74d3178f297bd9c29f5dcd01ac90ac4fa8602bc42e4bc8ed75a5e524964a8726131a33b5122d830b95169ac0a183cf6fc6d95ebe97b7daa0135564d6bb550c768570806330ecf6a6be53b7e2cc02d260350fbee9576c913e2f0ed649f2e89ca0b5f9c369e177c0a4aae4f19b058ca3ecd2928edf96d5493fd2f10777e2b0e5b504c626658cd30e918db5f6d1d7885ddab557222da183ee2fa5ff625c662df3cdd77d2f8bab820160c0eada9333395e26f9d218bcb6a31a427872e6302b61173e28153a33034c7f889998a5bfc0a8afc981cd42fca6f547e2e4a2d9718241800cb390ecde45890c2f03995ae44abe5371d7d71a830c55b585ba47eb61f62f8ff6404c44c468287fb193788361bd41e498e32124025c76948b2c01840d22ecf5ff9d5cd9acac55495beb17e9af50aea940efff03e28fc5f712b2f5fe20684a8293888eb6215be71f0f4a7af5a6eeaaf17e26d3885e79aeacb8fae36c29ae3b9f6acaec62fa8e4fc48f732fb3f683067ba2915ab55d8bced27c7ba694ce4c1397aa2eeddae76680fa844443c6ea6d0101b0fe61a159a7d9ba6ac8cb4b75f1146195d28f65ccc550e529fbfd54de6d040ac4628b3bc4f239641aca2bee6b91b86579ea343af3b6aeff9057a76c2049d61ab995de9d85998fe2202502d9773a5d11cd67c73ef9ecf5d575bd9c515cf8e41b14e59e8b5709b2a37d93708261a039551426245c706b3425204ddb973476f34743ebbbb9519817d6b201cf6424a83001ecac2d496d4a61715ded506d8e17cb30be2e9c50312ea69f0435e87348336b55d9677e617f200e5d0de8c869136e52cdc185e790124bc060f34892cd29b59e897cef0ada6540ac4e1209905ec546934e48cb17e12621c78a08303b9b53e6c8f034639789f42de9a8203edd1d6c42d8e995dc8369c3c1585d383c0494406fe16658d26d2630ae0f7480d6160fab4e3aee6fc11c2488fc0cbf25f11564654ac031c44cdfd2646893ee9b1fe9a2ee768002474af5dd180cf58df436a74889e7f7d2247775e2feceae26ac7e38e1f8ca1cdf5dfb15711e3715263284e942eb2ac569d83f9b8cc4dc650efa08cc1cff60fa344826cbe25a38bea18d9c22e09c6916340294f62a32a9a030c05d4dc6cbfd267406e04146bbdb6d8544bfded297de0e503a42a9567b484636bb98b9f14904479e848d333ed60e6a4ece76179d46fefee65e5ffd7d6b0d5b1018956fb6bb3527109c9f4a5f6704598206658a3d9c1c0aa11c0cfde4d83e965e7efba7c42b250ad02c95101d09c2397936d847a364a77e62dc9ad8c55115b9b13bee303e7428d145371836f22f010155ef4e1557ee95d26ed40859942013471899bb965975242802823d6956940b0b61ab4f5708a06a78f1c938456b71ef47f34d4e6b991286ca973d8a846c628cc2f2f60ecdedfd3f2ac9f5a290aceff5f1c629f4ae3363a16c7cc194b5a2d5c9067478b503c4a4aaf06c9d27c86d6aa392af1c6eddba17e2e36dce4489d5fad8613953084e1261b802ffb157aa26f6133c302fd3c502080ba2a677d0848f238239f9aa35c92dff10a1daf5e03a788b7fe15856874ada8b7de4f72ab2d4018ee162e407692efab162e2490df76eb449bcbfeb8540fd70ac0a54a0fc4016c313d9b44d8f5332ecb3344638a27bd11db9403243e4740df7c098b56a3858b24ecda4746e918a210bad76933df3e980df7cdd76450a52d3ca6405674229787955e185d00e3d725e3df12b33612b3e31f7e7f681f1ff29a8d6c8bc30d7f4aa42d342bfbe71ceaa759308e57d3a6b15dd91ff276a9295fb69435125ea2ca145518f9d7efd8fc77e56130a25bb2bac190612c221bf421f9b4eb4dec66971883abccd8bd9cf353299cd897b7fd0f3742ac5db8436e16ec26d6dcb37df72188aa452a967937d509e821420e3a88357b6b9a1035f133e290564dfae688fb1e03791439edc300bc240563bce6edf3a4e21da84963c7cb4813d7619df614c705b87ce5e641f19ebaea8d894dd89dbd51e0800f3df7354e43bd9d8021dc0d1494dc2a25f0d35768e67cfc2e31dbed107a86befc5dcdd93567a08311157ef7554fc6768d8d7bda25cfecac58f6bc73c42f8b9a0794b7bb20672c9e8719aef15e788c79c2a45c7c03c49697c31e3b5f7dd7c0d40065e78ae4f86783d54959ca6c90f8579f9728cd116df7898f741398f7dd933bdb6f8ddc80dd02d6423dba487bf7cd9f11387d3c61f3143fb96a7587d76e28c38bd4e00a8db5adc44fe72c9e7dddb6460b47af7428416079a7b4cb54cd2c843b3f938508a2ff34e971323067a8862a21f791388c20d282d85ec35fb98af9dd8aa80178ae73ed99134a4e550516ad48793183293df5cb9845edb88b2fd0d1fc3fb1c441782d4d441a308a33f24c38bc56b96223a0e60ceef5cd3dccc194f7e846354410a25a1ef44b7ad4d6a20d32f54329dc69baafd811191fce8d1c46dfc798b94d88a40001e11641c9a1598ad5ca164a1faf85090a049c3ef33a6e76b8c1b026a3a63041b14ac3f048a5a879a46c7905812f78d3deb36ad497bddc7079d7129044387f583eb3c79f2fe70b642c035c68b1d9bbc95d6a27cb3cded84120054e8cb49973fed7a9ad01432e869ed9638454c9a2be88a29f160c6cb641d0d66b9a9aa9b986f63b1fda62d70074078ebe8d14dced000a9f0718d2ba8a8e67af4cce51addf6f4ec1cf80f4d6b0b05e88cad9d6c5e91b0272fa36bcbcfba36660deb60ae9c1b55e1f4cc8ca748309cd957180f7fc1c3ba7adca6ee8e1aac1191baa405db8d84aed778db004a9d70c50eb945c5ca25ca7951916fcbf91c55e281aee474fbaf64275b6fc806e50defb0f9c63309b54ff29e3e36271cea5657a39c2d924fc970359515d240815bbe474c4f4621151c5f80173eeb6f380cebbf05874f7e1e9d58826600b9dcbb8183886b87ab8e55b28d5d5bca4b6ed8296373b8f251d40b56569872710d60a4bf17c735f41ddd13eacc22a1de75c9ea6818173f49b40f8d4f7504750731fba31b75fa642f54151d040f7588d1917aa898749aad8766d0063228eca0c81332db2137feff980b66ebf53e55558f3c8edea3f7490af867cc4168a84a3e62a4b8130462c7b890e1477e2a482e7215652710fe7a23d0bed086ee5e56560f506d63c1ca4c1570a7acd3acafb123d5302c0a9de28c7a514c0f803fd5ffc3a83fe950e07f3f22622a03c19a31fe8b0a47ccc658baf8cf375f6f031ac603961059b71f0a6c11fd7896fe75428a1b578b186e2ec6146fb93b83ed6fa6fe6b106868f31988792e0f0893149f73b617f9821a1577271544e40d7d1947bc68af9ad03c55a983ce33bea3d17001beb4ef4cb9e6d2848db129cbec989218797a46e3463ba0d1402b7709d150e0775cb95aef5f84a6ce5b0d239613f72c6ff56c82e893a22688e3327beaed7d835be9cc0a5e386c3a85cc2824fc52ec50d1617dcb942f4fd7ffe0ca0feb9c78d9deffa1fb770beed44a07a3f2a2834ff95bea8d4bef378c448453a14527b0d09b542632befd15e3ec885abb61afb84c90c47c4510d719469d7401d62a7d1bbb273b1bef5b0dc40471710516b9467992dbc622c31fc1511630430d9c40670e580c8a10519823a0dc83eee175fa47d4acad364b336f4f1714f4df063fb467aabbd593f7c892d9ebca251a75b24060131ab2a2ab040679aa90c78c08f55b1b437fc98d4b34bb9d5af8b62c6e9246f4b97142b72b511a4334c453c510672aeac3c4a46c5df578164cad1d75f9a8def9ea2894dab73033e06430bdcf6870573cc49a727c1453e893c6c1118de2c7562fc170f8743172f07ee57a6a88ae9efbc9b75ea71fb95aa25bfeb9a5972d04d15caf71cfa8ee78651625f6bf578819b69f0dcd9691b2b6f7c5815a7577c016dc7e6cf5b37ee468ddde4b2ce91d388b92e91a4760032fa51378eeb8f5d112d08fa8be078e3f0c7a72991b34d63f4cec255ea717ddb244975a946a15b182cd0ba779b6c02ef3b766352854eaae9e1b6a8d83d191de15e4bb1bb533f710678df7cc30eeea70d5da01fa314bc6435c37f79f631514ce887f4c6c79188c4055032b08b2520585abc334d264a08f44298def67f2509ef4d4d39f6dd8310280b09c2f54c904cd01820d1c21ba009dd1db99fb57282d41798b270f8f19fba9633cc293fb3e2b22475bcc709c08501bbe922a49e419f1df69e786b0a59cd97ea1275eae8d04269841bcce1cb60cb97f8240dd9d0bfa8769b111d1d675924056a3478c6426df091ef1af6457b57ca2159c9d17729be48399aba066a61861504e484cdb62936ea6250ed6d709281590db8ed8b44d7d5c7edb85bd2d021e516d9d11dd4a319b2529b7f11518e9bdb619ab8cf765a2f3a57f9e5d680acedbca341146ceac4fdbd5e90f24ed3054e50cebe7f862ac7e0a3345ea59bbd1963e075ed5d2308e79e4512b34d6070ccc438186fd3c00e5e7661742fc0b8b54a82e532e5a2b6c6dc574f2bccd021d6259d47e3aa8c2ed37dbe0d5f3b3193d791fd4969d0c7885bf7a2a60cbd7b183a6383e8541aee2740035c916f15b57be5945bf51e6ec79ed22c9ffa8559debf736d613978514aa5120710f4ff34117f0e2f4315acdf20d31be35b86291f22a4d82c233207d585220204e8106e9cf1b87237611c343d71bdc678e3337b7f533085611198ca18d9ed8a51552a225bf55a44c2a4e3e4daebf1bf0b69b06fa80ffd977d9c90b7632887447ab2c9156e09f2734532c3026ae665a25f33b2ed77f5173c9d5fe0f3b5ce0378fa03fd22abdbd9739c3d4e8224f2b7d5a9dfde69e567603fa64198f244a94fae93cc7c951e962200c347ce95590f223e34aaa35926a30309e0cea27e11214aa06640b487ccd54228f95c88113bac5cb30c50534d531dbd1b04cd8a565fd4f36ac1018f6e30cb0ad557f0a5a661460428e90acf2c15c0ee9a9534273bac84f6335820df22aece666141d8ee801df218d5e5915b2a4b391e944ac7607369566144f3bdfc26944f91e78d479d54e3320f291f2341f8c70fc462079fd0722d93d48fdd5afd90ace03430b2ebde0b1b08a05ac7cc9c1dc18613d3a1ee2a1b89b0df87921d59305db21fd33ee3d7ea318ba60ac1b7793a4ebd6a5f3228ec5011834cd135985b0d7f3cf4882e95e2e1776f235bb885558650343c428e4152fd3175263e8e324644d950b017bab39b70f2aacf7f42c634fe9a16f060833c3099e9019cce9fef2dd1c7bf42299a8cc49ad140469584083a03ca0d16fdc16f457964d72c8a0ddd46a769346848b823addb06cee88fec7807777cde6041fcf88402cc852ba71c166b1d4bdc9e17add874035d438969165917de9b65d400fe254d846622163448d8cc09260c7519fd4fd2e5a3a2bcafb5632043925c93abc914cd2fb68d0736fa008735596288f9deb4e5553462e7a6a8eff0c83c721d642076290827e7958316cbc97b252b011985e38a5c6d6bf7e31b5a95a34f51b3476aab93734de57808ff4942ede84ea7ae8f8c32d65ce0f4e7db7d24453d18c82622fb22b65a8b1a0e6614ba27e6629eb80c12e521ea69fe3a19260d3acc6c792203969ec046b9ab4b5106693d99b92361f3897808b8118bc47a88eb3d66d0142afbb120b7abfc229a00b88e6e526a0778468edd558560b22ac686c34b17275836d4518c0d9d0afea0db4ea9d14698cdfeffe9d772bba9f1e618ce0afbc96d631da05590cd9ba8064e55c33e89fd95b29f4a65782fa041f0293b68f78733343be11ed9dc82bc31db87ee3d238e03b1f6b8d47552d856e4bfec23735faed0606224a6fc8a9b2d14ca13f76b80d2ee085d8220a2f20fdd8f45a867144ec8e01a3a79557ef309dc9f0cb7f8ef8f66dd6eb654439e0edcf301732d07fde0e81410ad0d23dbda217009bc7dc9a1ccbbffeabd7854b20950737e94a28c9e0515fbe2678711fc0e1c8e2eb22b9daba5033e628b2164e2e4253470464955412b2d1b6d454b02fe7f27321222f4ad895c39bd7db3fd20b26ee527b97b6b95459b5c7121f93b845e337db90e907d9f819f2e0008358126d64298e81699aa680f909b9d78338c99fc2b574bcf9b5c76e84b8f7f4bf957181aded5e355e505b3d9c2ed908449bd55b201ad6f0b8d4fcf819619707b376ad4ba1af3b380c6a51a8ca6e2d1f0530d583310bd7c26551f530ba4a3e2ad92f5c05cd78d6f70fb548d9b98036b75463f0eb63511631e43b5868979978615bfed552909327f165db88cb55e76ee09b03da5acaa7c18f81d78fe58d8f1f2645664cf77694dfdf597092bfe429553c8d940c96de95bb38a6ff23a6dc821f88cec84572e6fc13ff9a5ee578a2a75471a6dee4460193760508bde448304e5e75b8c060ce12f4d0e846f436cbf1f42a70fd9cfe39feb748802f8176f402d2c912c655640657c353d8118b5ef2a83da86092e814a2a33b300cb962f078e11c681e5ede6f96bbddbc1c5707cca82533519b3b8e39485985b750ad9170dca94470f307db2c56984e5b61086e1d9e397efca45c5392c2030e0209e9983edea0b4340c9e2cad41b7112c4d0304ea3294025ba6b2590fd279f783f092ce3e2fab9ad1664320f29d97e01582a6c20b2bc860e55d1ce81104328a060bc37c029b2d94c1c4d214f48965ff788016e37508de0fabf0df43cf3cd0dcfbc3722532e5bd04c50bfa698dba87cf9917a8c0094c08c5e3d6a0cd5fa63fc2ed293a6da9a60d825c3625e91a7efef63bde9973c27f583e0e24c063cfbceda31ae4334905e0bc6941a1a8c570dda272c0e19fa77d3315a8a900dc16ec6193d74a20e756c42e63563e7ed5373f1254d307590f1e85c57c05c085202ec0b0d3513b4b3a7664c4c440625f52b1198216fc7dff9e23ad9f95c7b755295e4c0eb85ed061e21a181c6870f36ed415e367404f8fc095bd71e5821a5ad4907892a819335566c6e17438470d400a35a9602345c9d73ff0cfd764e03ac75d855616e1a6775f2347ffc1f0c2e4baa95a6209a39da26077cf9593d0ca21eea1c82ed2dc39326abd87793b710cc8881687ea823982540129bdcc6b4704157c87773f619d93dc18cf0aca75f89c68b98e708901f0dfe0dfa370a957db74718496b9bb23d3bd4601df60b0dc90def53df41742617572e46d74fc3de149f76db79644367378c29fa3623b50d7309a927649567d441876eda39b3766187f0356ad3da24e298c9293c576f19608b1a3768a5d3995ff750cd6f7a1a08b716cfadd335d839bf0bd839aa79449a76ffa817c027f6cab8b9ff33cec6e35898f94db55e2ad15f261b8060d1475263c54c8c77bbc5bd416e54564340c9f4c50eb63e676e1dc021d02ce93a70024ba4f9789bd59f3eec8105f24d730c436e4bbf5921e65d9f0cc7537920976c474d73f8020fa0163bc575feb47687250fd4b5425c669a6720497726fc43b5fc6eae63193f41f13bcc52a759d1a899022b1dfbe58796bf0e6379896cfe883d25486b42c827d1660b918ecb974e06bb59d7fc7727c88126f465bf690d5d8b6f97ef9a5970a2dc3e6b28057b6d42c494a1cad76a5f017a427b246812c2a5c1f05ee0e011bc5a5baa30cce1b689dd1f39b4269c55b30eb79bbff098610b922166e39cd993e3373f271ea9f8382dacaaf78074f0c19bd916e86e5b98138eb43bb5ce14ffd39a1f149d333e2e1b1c56b80753cb6e61dc74a9ede996b1bdb0742fcc1bb94654a12c17232856a9756805784109e1e38385162c793a6f6b4c80282972c0fd02817774fa701e53dc536306ecca28a2e22d6f83fc261044674cb6d7791c56b89d75896e1068b98b0700af7a46d5bd5ba46365f63eac6d71d2dd1001ef0b8e56b55cb1d1b77bdb0c4ffbfbefc235511793910e88d931565e7b2cebfaf7243da1ee44712072a40f569020a54e3dc864d42b6cb683481220c07be309d75b2514adeea3b6b8702d026f4cc00982b3c8a47908edfaa0aa2460676d894e0431f86fa0bdbdf487aaad7a2e9a2a9b28c8a6680798f8ada8e7f973d80ce71bd3cf73f73ef8cc05bc2eb7ee4761e38c235e482465e57ac0eb15a9802c40aed5a36cac5b48df876cf18c428446ba7db06f8f00f390864859ec9e3573a2709055fa160051947e6ce2b843904f424aaea4e43c43e05850157cfa2596649fec606cdc5d7ae960b9c4b3f4fd2df3250e8470ca0865c81e73b29feb983f7d82923deed2407264db0ea20ed8aca9aff06092388e2f5d831703f5cd245c68d1eecacc1c831e4f00eb1a3a689627ea6f10c9305ae1ae859214c2e0e3efae8cc190180f45b60a3bc1ebb958f16ea101cdb168fac92d100d63015046d1a0a24232e3da507f498c8568ff6507e288bac2e8822d77b8b8103462c9776db1bda5ee0188b9a41250da7daf925ed97c7a1a962370a71ef99149058e109e7e610ffb50142af8947e40ba5f57b770bc8dcbbd1d6ed40c250e2d662410e4be47819eb1b34b12bfb351ba64e74c46556f1f664f555171bafd27d9a8bda6a053593d28a03c551a286f56cd0401fa8805834ae24a1d6270e9c378d471e1223e51032f8a53d1f42b1ff5b7cfa5591f2d011b807455e9e91867974c8190e57b2d283639c3e0f2c4e6e3cb73231e97ed7ff1a1fe07f9632f9df10917270e9a4628f2a7a697e16ef85b413a5ab3d71951ae507ba8077ddb6cca30d7b29dec61bcae6442ab819417725d7998250b1df24c23837db5384505c6f775673ec4bc4d2c0ea74032637d7afcd8bb7bf7acfac2c656b900d6b25cf78772ddd60b90b5d4f6f569db2900b58610a0eee2ce9b7b1fcabe4c029daa6ca4664cf74f75010acd625fb135903ee85117162e21e77e9421724a5d3e14eaf6fd24567426ac2a62c6d26170fd06d7b942349144a27c25a2521d7c0bfda9127449e15b4ef108f29b4f2820bf87a9ac460daaaaeb78c60b7a2285a5fa75c2537d6ffa54ab90c9bcd30af5be3baca91f93633147cbbe965bda06dbefef56810a0d0a3ac5bba7c6c0c267613b3110e74da6f33258bda8a286cabbeaf79b29c0398c4481d1021bf4864f1be9078abece6359c0e50d0d42826e30bd5cfa7c941d0526409be741e13f18b971fe6bd59bf94779bd1c14b0b26fa896c906e009152c518defb56f6d88d0a05f2eb637c74f464d94fa13007f21d69d1292068723e1a7f54f08e7825caca13bb6a311acb3a9db830a825a089321d53074d4a9d9cb7cbf6c553bdf231ed958fba0bf8bb0d75a5ef7be06f274fe5a5f0e51049ef9dbe9c8f52857dbccb76202a258a032da3eff5d4b2ec44f0e2d879ea475e847d690b5a8c758a5bc90a6aa9269de733e492fbef126b3978bf510ec7efb030e55b4bfaf0658edcd85eb6e42a77eb47cf5b78b4e9fab2b54ad5379e8a78b91345d05c9b371f355ef6f00658639d53d098632dd2b0fbed70e99fb8ac88e8d22d4f92b54b4a9bb4eabf32bec107b8c729239b5a00fb351c0db6d3eb097eb847ef1ccdb575c89bdac66711ec5be337bd6350d1cfde88217e07e764b6c5a672741358677f15830390c3d502592ae8858a0aca4f5ba945a73dc0958aeedbbdde930a27dee0fa21e5a621520ef8d9779882bf3505410aba49f5d2f326c7197ccb05ca82bab5f98aab0e51e59264c305bd19a1c570b078631eaa8caa572fdd916af91376c5b775ce322809155766486cd5882c2c24067ee96317108d6c91fcd9ab72b62126ff2505a47dca0991f7b9c71e420bba9ee906d845ca5c5ea602a6beb4ce8632d8dfc5dcb8be195f00b4cb5bfe84630630304d061fc5d142066cd13dec767e3af65cb179feffbce52af40398b4e4d7058ad9f0ed192d87358c3d5ea5d999722f893561503e6531a4af67fff27083bd7c82bff25748bbdeb2021d5c35c84acf62ef5278065f53d7011231178b77fb989967da8db8f33f8593b33f9d97fbb1fe2d001e91be9a8b695d2d03bd3b913a22c0fa20ae2d789041f36b263b23189476f067d14de5ac975f218d7f0bef7fea28fcf084174318a3e0af36b286b0f12f7f800f04bdaf330ab4cf238a4919ffe4e600b52fd8a23453bb3d267981332af506f7765e390f6a22ed670f0bcc3eb71b5a7dda78c332fb9f6dbfaccfcb68a6153485859fe96a5cfe5f0d7edf7bd853a4fdd40261b0928d20b1972b6cc5874dadac30e28ee4dce5d04f9d4c0b7596bfa1a17d456912521ddc274963409f37f5771457959f713dfbf9226df009f9b5c6f8f5755897590b2154ff9c29551b8d0e7d523f672e3f80bdc94490b925004efefb2dae1d9c6222986a965ca8f9991d480ed2fce03f690a0a718b3883b0654aa2288fe3d4e89b05fd0661c0e7b6e6eec920dd397b975e0263a2bebb50293d15e945df4f84d2a04582712af9a4f5fb2a6e1611ff85d8514a77139ef1580b23b508c30e39107241844a0fdb783172c818eaf8ba783df4ee6ad3315c58d04da9a6ab647378ea54e3ef268e3f4ebb62a8b8a22e153b723c379c54b1d71c7182d5516a86e97532b81e86234a5d9a69663773c3ae8007b6826070f9d9043662606870494e640b19b1db6ac84fe043a450eb262c7803fd7cd708a76a0ec0144dd848d8833c66bebf90c65766b8c82c3d3ff0fbad7278f42d3f9d77246c6bcff8d01e16172cd9fe11b2dc0b23dac1e67b0a47d9ff067872b681be547ecdd4287b0dd1b176e5d2ba0bd84516aea9a60725b195654364c3daf32e04a2821c5d28d6d9246e19834fd374aae5f9d18e17955034b6e0b3e44f6e685fccfadf81932240a5d2bd721f897b65127fead372c0462a452b2a8f748edbe10f18735ccb190f5f55578cd6ef3b2a2ffb37b272442f4dbb018fa2b0931af4a99d7e3d6489d6094820f1516e97110929f127b8eb92dce86ede65031345eafd51f288a08e4f5b739ceb6c357db137a67cf58fd0de3bbe6e1c063bd0e450f753eac122f6e23a3d64334e3bbeecfdc424ef03afb7cd65a077b86f9954f3a10e085eaf47f0cee64d5ab0ed08857d99af92a1d78a101483b79917c42bd99a6727bddb4f55266a436af369ebacd1728b2b7155334daab3d0f1784c8e49fbe15034d73eaac6f4662f74c516fb22d7a09e46fbc89cd1c080277cbf5368e42ce0ff12501f8087f7cdc1dcec5b8c11d9962a9beeec60f2db4b935decd42377240c9aaa660796c195ff8079d318a4100ff59d6f765a1409c1551ed2350cee3ca78ece432be169edc7baccc1a0b7057c4a2cf9ae0e70d17dd9b8077664eceaabea45ee57f230ba2c86073903407ef162c9920ff0c07287adc3c035fe51f137eb97b61a07d3c9df26196d3c2684665b3f0da377bd682bb7c5bae910ff10af7192dff8213ed73a32b014f5ddbab07c7ef4840b1cd48d9952bd563d4f32dfd5872a369f37d8ac42beeee3b3ea05bf00c1d95aa1f00121a1404f8166fdbacac2148ed42d71e714b884cc24e7dc4042fb34709f501de54a4b2c14c683b3341adb8f9ec7c5c02d93d679bbe25f1c267cb78b0ba402a40a20d06679bb6ef9716a3ab21ae93804e951aaf4fc2969969ecd16a6076b030076d57564270d2069adbb03d1a5227c4650317ad24c36df5b47e4cee6d70bd0eb69a8d3ad4ed4a1cc97a7844a2848b467f70f16bab1b89be2e3b305dd4be9eb4e5fd8f4395c5e5830fc220bd271475d5d6d254b29802ec5e2a9002dc6bbd74b50c7bb2c5606868ab3ab1cc1214bff24b06ef9dbc9d766cc1b7dad219f975268fa38852e3fff4cc79d21569bf904d5a22b710d6c75782c0553c47ea308ee21b322321577429bc466f2976b45ddfa3cd81879f4d4698b0053f3abf326ad1be1b9467e41e5ee23974350063d2452deaab2251af7f02cbaba19c149f91f34bbf616503bb270f158f3d0d6e2d64d4f9065035e92df8142124305092be02404d8c8601b96e3031e8b02725216e54869129418fa0f8a37c019122645a1a0fe72de47d118e9295e3d8d803829fff12fa0c708c1b90e0a9abef2085778673128a7dccb346a396a2fae584b113b144a87af955da122482a7993d39568026492bd1cec0d167887b09f28c81c6c46630a6e62452d65602bfe6ca076b7a5539d164af1fceca672375aad4a77bca038e1eef2d0f9006653e34cc9229534daac63c1d9678f643d3e9006cfa3dece9c2075b20c25a2fb52f4e5f408fec9ec6779698ca171d6306f0e3625fbc425cf4a3899752f5748220e6572f7602968f27e9d31fe74ba3c74969ac319fa40acb331baf8ebb240349d325fe289ba524845e25ae41ab352f7966d5230a7e262c329ff883d24d91982b74c8e5ed4096287cba69406954132ea3f7930bc9662976f8f5baf0f09d8c108ce6fa5a5e9fbd99c6b86e152bb0784e461b166a968389a96918c0d6cd1154d5a95d1a90087ae459b4c0d0fc858292f49cad3835132eca6e0cca3dbcb00f3b69d3dfadc5c4fd9cea97cf2238342f4caeaef7dfccaf92bad60381ae10110d8d5fe4e4f6dbc896539900b74d083183b92795e9be9f505fe196d636a29079ab003e52b39c29d50bbd6c580226805eede867edf7479f1d01c1bb7089218c6343fe5306468fefc235b358e8cfa2664775f3f9aef2f89b97d181e13f6687b702a06123d216f897464d27ee7427778f464fbd1430ec71be9f893b8c449efa8572faa54a865af140fb154eff75d6e487541b573f689e40c45b4082ef363cdffd6fcc270d5e6e94f20e87ebebc9599c9dded1e4c35466b8c1a8ecfb5b90da3144b5db161972dfaadc64eb1742acadecd9fb2529f296b6c550c0256b90e4b72d5f58b5a2dc83e33b0171cb5fe4948d8de71a2d99b603504e7b08be7e6249519cfe189ebd643971889b9455afd7bef1ceeeab374d913bb170e6d99146618cb7076fac6a976e2f1f7305b449c9ec9c923f539b70c7b6bafc3f7785f35674d5941176944452fbfc2b0b998dc33748ee084b38d03bdd6771105d34dd2e9f81dee2a3e86f146feb82164a1994f4a5f611b67ceccd5c9f63e290057472411e7db20bda990ecf8497b7957f8d384b93adf23c3b097abb914a643c1e90abeacda4e759da623820ce3e72a973d138b3a6dc5a80b5465b4d36def9ab8c53af85662fd44750c91fe1371647437dabbf36cf222405b96c32ec2aff670a5cab3e9be83a791185fcfc8e3525aff81b32f7facb3158548129ebeb0917980e2f1e769efb797c73fdf5f509bbddde351d9ba5bfd5eb41f78d724eeda1e0432c61051e99fece2a1d3c213f3f1f4263c8e20398ebea1e951017fe9943d015ea320315c99d6d0d1c59d618181aea39072831b36807813446e2ced5bba2175aa551a0b80c0a8065ec551afb5f109ebea3ac685470d9dac33bee8c263fdd17c36b98bbdd1a62c565d94f85c475611ca0d561229272ba162449382c99412eb5ea7fdafaecd2c27dab98f516f22523868615a8065b210ea0b40911844051c0d6547979a371ede2994ef49427c9194915db26354b7290362043b87efeeec9b0b70bb361c45937b64320bf482dcbbe8b930b574efd7f8a8cbd5f5466de2bfc3794dcbae46ee907e65ac27709da858aded4acd362e2c8e5b8ae92dcb20b6c0a0a46669710fd805206938c696b449c74f520bccaaf9990f1f5133030259ac8d093088c4bbe6d5fb3dabffbc4048fda9463ba410c0415b1c9b1b83f94379ee4c31ed07943a9c3ce4f1ce836eab5e206bc5689188a9d909f1fc0b356cd2a801c4d7b46fe1e8e1c4a6b79f77fb00d7b3e0fa22656f895109ed78f80b24e3f4825b791d34422b7e705806140ce12aa80a1662547b916f9a88fb6d72ba7a4dcc7ac9af2045b078d45c3e9bd1b630faadd0424668190427f856d78a7adf96474463065c561b23222c6dbdd67ffcceb6b594952b8f73b33287a9910fee6d5f04ebb91a95a6d886e9d9a675c767adc95b02dd65a2c2bba1e0dd74b316768c4df6d280272373b61096b8812eab71d9550bab1e9658570e869b06aed3e24bcabd1297e615e92e9a67413708c206a38b31534ffd2ceb7754412500a6782a4ff24d2508346d60c2e464b40366e8bc771ca31b5d47839bad734266e1902f01d65d02d88bc4f6bc76dce88aded0d0c0f6e022219cfad49e155cca4b9db11e68f1fbfa14e1cd9e45791c4d0cd4849c2a287e8f623c412f5dbf803291b20a970bf6f1918b2d220bbc6e998ac2eeb501bf8226780b05abd8279efa00fd8fe95a049ca6e13ffd77b155389a2ea296264536f52ec485511581f94df62e15ed58bca6944c90cd8dd067e3298f2826dfb3e5d33cc79dba2b80d87f414b43cead3bb55b672c2adf9964e6d226f21662b97faf44f84b32ca4513fa1732bcd6beaa3306c4cd148b4e36131d12da4be5c7ffecb729e0303b4767d7a9b88c45dbba3ec3a0c08f078b6a3aec3f399fd217e294199d6e9626c18306cb41750d93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
