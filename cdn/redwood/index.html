<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ebb648b3214e522148abf9f1ccedc38429fc49682fc5821365e370d6e2780ecccd62799a317397cfbd53712ffe15e3b578a945cd84c96aeb9cd17a15e64e98eaa878a619506ba3d6deb6f0cf59b4431990303c9885f926fb9f596f5fcb72f53dcc44fd699a537e7fe887075594cf79273399104c0928099024b9cd50c02df4569737ee567024463016468f5cb149aa5aa5b0ff71627745e344ec2dffb62e7e4dc8a437e1857db82037ab4330c658a5354838411095c4fbb3adcdc28a894bb34b38b89d9410a7a59b7bcdfd8e98baf79d3104715497ce4649c40ef28ea3e4ebdafd1a1e1fa552cf083b2697939e5dc933b9639aa0c7da78d1babb9ab4805c1bcc93594dd91d2d143294c62c4c3f0e35a9a28018947d0bce26d3fd7b6fdb923ebed6b04ad686f2a27b8afde0e58d0a1ad023535257d5c295d6fa23a6414dcf1bb68665ef2640283581d67005f2c2477092466e0d5393c0c8c04c1dae23944b39c12273496261fa691e7ea39e20011c8ae48b7f7e3c61573b078c75390002eefb6355854514ab5fe0b31a0ac7ff550074950a704e52c8e129b2ba306d4581322318d420b5fac60092c86b6e0b33e38c2f44f5004d590ece37bb64ba54dd599f24b5467d047753babe1a555c282c507d8af22ddb267538fb8662f3d2708aea790f6e740b160e6476ca1b5f521e2104d5ad10f456832f4a13cb5e90f72637c083e0ffde8d6e7746b55689271f0ce8d5028751e545e3574cc4e2f101326bf0ed22cca6d550e61efacdb2b6a189d0e950c305fa44ce64d1d49ddee67b289809b993dc2dc2b9149345d37555050ba561658780954cea297477f1e08c3b0e612bb38cc7bf74fb0f61944759e7d7a9fc21f4303a68abba5a5104855058140c2f5b979153004cc3988c3a8411a4fd4dd4f7319d53269be603fd231f231a36c4d44fa750b6c810ce676bfb55bb9f09a270d5fcbf9d08cf816afa01aa1a4e4e0503b1afda527cdea0ae0bb78f22663a4876476c6f64bd7454efb976439da9ad995d9e7b559eefaf46bdb757751a6c4edbcba4aa47f7225e51f8e9c27ba8d574fc30e5ecaeb541d647e756a94ce2cc229f230efa64282f3f52341bded41d1c623fb366532ef33af7de390ca2521a63c6722d47b3a1cd28bfeb4efcce1faa73bc030337e0f5eab29ec074c71ce621bfc33e1892ee0d82b2b591b5473df72e3b370eb6c4059411d99a0c3e8b9ebce9a41c00d062f179923a0b2bb9d20f48b4af06e6842c59301747d1bb780982ed56015f8c42d22c7042b2dc6de0e297e6b2e797a1f59321acc10439e97784d846c31ab35450da313de279956f74070dc9d07bed32299cba711e521b3d049abe2dc7a4b9a49b7018a9b4528458e4c7e2e5b1f442d02f022545177ed5a34aad8dfee2057ea3ddf1c4a2b4e11ef62d975912d168f1b125e060c7ba6ec3ae38373bd342ad06d6b8d64c9c4adf063649f01b6b7b5236d4d538d2be48acd743619241e87b33523381679a7956b8043a759d4c9a6577c947c70dea3555851340e9a712bb59197a6aa35597cd8353d3164af7ab18d53a64fa78813990e6b26e9a8e745f4c42e61097649ea15c3c42af8765f71a89ed6f8f5cd15bf6e8f0b2bf780af410505ad8837b4774df0ccd3d55b17592bd0a0d4c1444695e74f223b4338c9886026817042434f42f0f923c3c80ffe5e1ddd31702ffa882b923fbbc69082709e2e21bbd27b11b117ff08bfc26c9ce6c0296c4a55a455b482140e0cac9669590f05d1703d55b9cf58095818b4977bf5a8e915999193ff59cf1819971e4bb0eed38f6608e10a530d83ba7cbc2c170a5e37e3438d51df9457f9b9762341b4cc28ea0dc062e4b3346e08bd8a7b01dc967c74ef7c231dc59b1203232af01de9487009f6e208b324c177ace0047bb1b06c9e92c3bcec25154d8976d0a04ee0a58ca7e46577ae09a5face76a983abffe5fd2815c030b8a43688277d953f8ddd67d758a443e78a756f54032d9ffbe861fa2166bd7cd25736b6ebe21b798474fbbc777bf643a78ba152e62bb5c7e2a5dd8e6be88b27b8429b6815cfd872ba8a4809e2c36730989a907c9d9f3e83f60aeba63e9c2ee8b1aafa23a39880d54443af2c10158c8e876bb9918a3ebc73c1657e817eb64f4a6b4b0def8cb471c7f4bd8907fd6cabef197df1a2a5d1ad43a4605f9046d79a07b67a0d6ea0604d8b42fbee30246342234d8bf5e3c87803be91f2da4a05b4348358971cff944d68ee8f1a7054669757433a783ec139b94f06a25d69f6ad30c9cc036f5ad974eb00e29087e0067426233a40a853e1cc0e00a3f0e3fd764160c3db8c44330e1bf5b01c810264d0218283d3eafd1f8bb267642e9c6f337c57e9ff7dceb11387b83aaaa5817abb0a2ba9646314a8c87f54f02acb6385f239b0cd63bade86d0bcd86e97221891af9e31ed3e78b0cee96cb6b3f795f705b4299de52ca4c4e57b175a4616d59fad70a5aa5d143ba83c6d93871f2e6b75c49fd6dc3b46af12a763eb391d26431172062d2a5fc8932a6537624db293907f7425ddab3618a775c67b5e18819dbb494ba7855e3e6d6d089cec0dedee18205214eec50c279eff350ca57c848477fb5e947b5c37190ef0f1853d4793244e5bc3f50c9f0ad841e75b2a943cf171a97551297dc1b4173f5712563a360d379f733c04183ccd33b50615b1214ce90845df3c1b2fe413dffa73bce1ca1b4186e9fd399961a8902d90553bd0b7fe1a0706eb0ddece5d1185f5ccf9f2dbcf6613e4f0dcd49ce23bee971ce7053e82644280ff3e2290bdc24aa8ea40472fdb2d08d205abe3b5823093ab074e238655b05002da57fe5f62ed937c66fe47f5a00ac21a30ddd38a09d64ff52271c304759111a88cc726e841ec9c325c619e0ed625b5ef5a3cf54bdd2334c942ce63f1e5a736fda60446647c908f003b8b4b05123e6725fa425d4ec3911e6cda3a9f2f22b19d453d74bd6bb58bf00ee47867ff717b5f7a9e731d9947e23c2fe78081d16c96f50fae401a2ba2cd610fcf993ed3c43137a2862d3f4d6063d5988785946b839a0d3f3fea0567f260d754d4be84b63eb266d46a01213db5f42138b2c3ab4462f4185d22f5c28a0d5e7e86874ae4ae7720d6de592dd7e597a646960a9b93693115c22cbf16a2ccbe75d938c1c2dc73dc3d58511d92f5a6d1f7e6887e3d6e917faa4a4bf89754a93979e409a76f2e93c3044eb6d032c12cdefcdc58b3657fccf0669eca1f0a71c6dfc290c2936dea2fb47cdd90c4969dba57f05adc4b49e0bd9617cfa1c19df977d323df2bb8dc8ac72ef30f75252047aca89482813d3b94eee8e56055ffabe71fa0d57cd3c3008d92b8a9fd62d9a139687c217817ca1b5dbebc791c4a37499bc7196ee84ff276a1052edbcf4bc1a56557639dbc6ed5138f6006fc6d6e9a03928b88ba5600b186291cbcb7aecfe8669e73f66556b6f3cc1131b6d5d540c9f88aa74d4bd94d4007717986cf7bf08d06c2a0596e3b47c1e10c39383b0ea20840026060f2dc469554e930c8af35e197bbb9e2525011e18cdf7992f4948195e1d4978c941debb6069889d01ee4ea87343fbe10a3ad7212c59093895a775f04c17c9d27e92dd6bdaf7ee80851b232a37dde375dd7ce03a21bff8f86893a14b0d3b84fd1ff7f3ea79e91b1fdc1d2504fea62985d25e9562b28db7c0b4825951f689b8b9fc20f95a07493195378bd90a4348c24c5a6e269261cbb4bf864657e0c25417dc22b9a59e95750b5950d045bf57d6dd3bf088d4fcd67d8b16f165daac30b763313dffbf507552e186c99890ca10c7201d6eff196958a98853bc5a406e774e383cdd9ae53192bf265cb51259bae71cf158c09355ec0125dfdb3b14f085a4f41cbc4d5e29978f4b3ba4d824aa9c56dc7a9dd9175678325b57c27dd4acc151e11b1ec91f38b223dc7b5b3b18ec59936b95bff7e7fd2a6fdb6c79e0a0df7dc8592ea13871c1f8eda2212f172224086450afebc2c2706945c9b292fb03b43801e20272fd40e7d99e680e74bc8734291c517ab92e60cf6ff4a9e123611adb29adc9ec2a622402d0fafb8d9c434ac6d9d4d42df756beb3b48eabb465c24c9f27e73913bb9c9bf12380b110445b8234a6ed941a09a5e41ed2852ac2e13f9b32217cf049a9fff6442ae8f0a274be78ab60abd8820cbfc3f77c6d827bdd7fd1b54507e85adb5ec53f3f43ed63d1fc2e0b9af5b1442c1340366832adf16ab4623bea0ffd0582ba3b94f65fd89af7233e628e1937e2954a77a90a4f30888d0b7e3e67e0b8645e81069d25db867cfc3b2c34adfe497e526844ad2ece7075f1af1f5f9d4ff2b8629796b3139d4fa346d4a58fe62cc0df7cf2c1fdca751ee343c39407ae6ac8058483fbed06364ac0d383b7b9e8ef10db913b00f97dec2353517d165906f8d9c46df60d3edfbdc4cbf4daa01934f142cffbcf88c287de8c878eb995e563d80d38196548cfa5d4f79654ab3558e6c5537bbc1607b229fd4fd05ab80aeb9a2d07489908f9a2065980632b14266bf5f70fb560fdfd5a94d20e50acd46d66f631c52bb3ac954b7aff56c5bf4394cc12eedb1301b60763897c1ad7a2b9a270f7f3545b1da642e20623311477703b9f04bb47d52755ca26e6c3a69e4c8613b12279c084de6c41e28539210d66428b86fc621aa1b79a3b8d9bd5219f114a5e050ccef4c85e2f419ccbe8b5e69714ba720cb647a4a5b1ae54bcc787d032238647cdecf46d9113d615d600be23e6a74344d04f5bd58a5ed5af5b1a624f49fc307b91cd227deaa4a88e116669b1821174b564ecd40e92ecc17fb8b43f2741ca89a0cabe5ac3dd34a960a211b3567d8fd26fd6af9d99293661ca12466c1a2bcc92db074f11048132353b869978999a5cb2e03a4e1e94717a64195c5e0a7bce8a59c25c21468c0b275b736268d45ee4380e3ef002c0d82a11c061fb578eca3595a2cbba109e3a8cfc18d12016371aac9f83f36053a9e79fe9f6c07ddfeee59e5a227ea8986f461dbfc3cd7e31be8ac2416c9cb5034c5cbcb1d8ca596cd55b87e2c9cee27e8ebde7fa452f2024a3bd76f3232808c37b169b71317d12ec3185fe71359fb0f971bb9917683761f6816e275957bfa5c0ae3144e938f1e734dc2c31a9192039e19d37d21a4fd874341f29e0bdef3a6d92f7e8fe79bd03fca818d29f94a344f28c37b49aa7aa8319aa70632816dfed2a28a25e490800cb080fab488f96a2e571c2225e9b6847351717def84f678212808a375fbef8f8204aae56f5a9b01ada44fd1f5a918259e1e7b1ee3a04ef1e9c55509f1130a118f0a37117529f4ef7d1c44708b3aac8b2f2d7adc1b91a6c436d72cc397dc04a941d9a599a19d68656fed528bf1c61c9cefe9f5be708cc3f1783f9d19a46a155f7acbfa125e651f8df215ff081e74a6115a044811f8bbabf61dc7d14c27eeaa06ac800601fc509f2720968cf86634d16fc2d0318c59b173f4b5c827f888e0ffefdc6809f8440cd83d1a4f3503f61eccfb0f2b3f9ea274aa2d404176e2fa805450e708f64feed51a03b110bbcc6e6c2c0f45d3d80ab2ef190b33bfc9c467a923cf14db3adc04f194f6ae19a5ba09abfc24961350c400e75daa827c2d5ca5ecf8927c9093ac3d818c8309ac4598e8d37763a8affc89f6434c5cccee3b669e2be7348ef2f0478020fa10fbca200eaa203b67bc3a6ea02ba04bd8faf7ecf8313724a839d49f48f33dd5dddcef4db03cc361b8f1ac9392f97e8ffdde90b40e8ed12774b1d21019cfe3e9d7ea1e9e9efc530fee593971f19a67726fadd3379c7f01f7494ed69042dd7d28d70ddf6db24290a1196ce7de1829f5526d7a7664fab003af7ad11fd045e47272900bc4313dbd44261d9b31d99255dda7faaaee6fdd25c1b38f8c41c8a1b1d2fb92f576654a98a398e9178b874fc3318b7a873647b6b14304062b5014d60b9a91cdcd2176747d23b63b91dbf4dea28efd1a4d777baf99e771ae16befe3f97f7074566810c410997b640a768bc302455051612cb6e579943c1c52ac6a0a9bd294a115415a42a20248d7dbc5939ae7582df6110380be5949112cb9c09764dd8742ff216f7d8f8d8964576e6c6d219abdc7ac2b68c4a08dd40d518d4c121a339b040b539eaa7fff8154ed3d54922f92219fc81932da3298f3996f43f80a06d4fdf285d976dd5a324700bb54d995e505d00373a3069b489f44023f9932b2c2d3194b7589dbc875be106ddb567e29ac7b4e1d5dfebb8b42e2c24355bacac28c064c2fbede3fc80edbaf4deff91d3a0693365edfdaf230dcebc42cf616851a290cf44344ef398606809860b3cbc793eb1e66980bd9b11a711174fccca25e73ec27528dbcf94ee74526c19d26a26b61a15fd6db7486064898ef2e0f4ae6b896511061695eb7606b5e7e669903b198881eec1033e7731b468b2bbf8aea6868d9ead5ceb6e2c6a4de3bdc6ed2b6e72074a33f6c11d2e7b77a10493815d745e00101cfcb08a03ecc4a045f4c754a0a785807b8d4c1b8332f58f5eb55f19cf15837922e72d7bc44374b1ed87e8d4b87a1aa932ccf132c52336577543127d5686ddb8de77dd3c7120466576c1433674901ed5a45a738c9776357a1f13514e173fe71452cec710ecb6a98f86091fbb49f991227301220c8ecad96d10db62d3446a4b09c541c71d4191310b8356f75c5ba3e2947477c52f44bad3e11fca9d7096def7dd251d5cd1940efac7bde567e1970bdffad8a98252a412f7dc3b149f9aa7188436868bf198248094c76b4f6536ca1398963249e471b64157037b72f5ec09febf949461ac4b7a70ed173ff8eb75ec20e36553ca595a2a491bd1ed10ac7f2adb5d4e0bb67bc4232c3756639bbabb1295bbd427da9e0c5b698773a30a28acc75bd1b0ecf5b5cad34a3c5ba7e7480f215049878e436f7b52dca64f6c0e99933d2d8d3b6f23dd71a9f550b405baa487ded07e9df559ac8c2bc7a304d7e1591c17d8124f510190602e5e0c273a9b06253f2a5babccce24850ae05ab266293083f07525db078dc5aa315b05d19429167fca19e6b9ec407eadea5295176bce795d6e077c67a04a09e66aab86dba9b78c93c6ed628b146e627865328d58a9b7950d1451fffcb069acbe2c710aaab20558ca978760151a1ae0f1b0578c0a8dd398fe5b8433d474aa32dd0a951e087e79e8a770ec5737998a614d74ebb8a77fc7c31802e6ec7f0d32d65481546f1db0f93579073cc5b6c6191b6002335392409a75892eb13fd0f2c03b912866412320e69b6b32019060bc78b954983052594eb4c4bb61f7aea0428d3690a180c9d2fbd4896cca1844b890897bc184fcfc9f71133804e708aeacf74ac7be91e286df65388f361e6608a1e9100984636b25bac36325d79d5253a82ebecb30be676ce095cd99be36a76cd15c9308ecc0ffcd4177fb35c8d6aa3b90b47d325cdecc0151b33b5e50d007c17c7b3348b7e282363b980a1830ce97d0d8be7cb942c403676fe0d15766dc5916bef65a4617cf2fa3a578ac044a50acd54c0c5ce9e310653712a5aa68bbece72b5081cde8ebe3fe543e60d901688275c6622abd1f6b703999ff687dcb0d0facce42303613b968c4cb2ee55edf986911742064ea7b45c4fdc952d1e82f5a7f56bffe833b6946186a16c8c165386403a6789df77c7535812aec9e68fc8957b3a49c9953c25513640c12e29ad878b0cb7418feab62607769b0aab7b71a88a033f919a237685d79103d7eea5bcf250fa8fa96ba653d692879933a00285a49f2fc009353a279ad826a0d9605a6182b07a0d10f52fd85fbd935d80509927f99b8b6753344a14947a30297e7fe5c2dcf8f39827ffe30a5f9a3447d8dfe83ea61a217900db8e025798147ce0ba3668b4b2658c3401bda443994a2a62d3f3800ba87d2a7a4ac84d1fcffc0631aa46ace3a3c1e38fdc99625eb2341014a62e3d63d78efeaabab927a4dbafb9e102a3dd249ccecfcc00b2682dc76e741fb2a6f6a0ce2a0a979f833886f15e4fc37badd429076ced1fde1709c4269af18043bba5d9b3bc7bfb09b4b0e34f135856a73cd878e01d249dde9863b5d02f247a2f091b7d5ab84609794ec49ea2f0020a792bfa83a12ffb1cd3ac14adb35e1a0c701a2ff118d905f6e103244abf60c601880a985468e0cb02f65b4c347f13244d08d8436958ba6985923261a20d0a47f4e8214a9ba2241ff804723ced038ecdd16a2e4fff033ae47a2b7c1dfb398d793fe7664326e2f9d03d08f4a381ba0ead7f09d811d453fffef9f522029a39c29a3eae91f71173ce542135e48fe570c7d93e6ebed22625bfb20988ac6f98984823814f50f71fc29cf642cba2433f3a622b6e6195bbb54ade0cd381b120a00c9364672e56da763263c05a9b97e2c0c2d33f13e74aad2d1851c34a3e5e15131f6a06b8ffc3f2b46fd91194e2e5f3ff852abbebf902a440a65ddbd5800c8a07359ba4735d0e451163e1c3a18f63717aa8c9db6d40e666083c82a5dc70b0636e24d4f709d0e3d04d9c6b96b6a46c9ad6f54146ce652e83e42bf6e9002354764d74ca88a38975dc88062555ace73af55dd671aac26d4b93b79645f2ef1f683c8b0cbc6e8030617d8884cdf0461414428956c9d73ef802491ac0542887e2b8ed6938f2efdd89b7eeeb21c16b425ca15dea31d17e1c25530bec810fcc6735a1ea1ae042500a540f9a321e42d187522621c96e25f379739a3e69fff5e94ba7379f1fc70e1246d8fcffc5ab200b496faee5eaad74d229e0621e970bdde96140bcb78c87c74777ad697eb9daade631bf3b56edaaeef4bb0c205e003e24d5f19cdec5bde3d0eabb1ad1380a80544043771b04ca4125f38b8c1920f30b1272cfb8fd9f755cd71dd5c30b744c267434f36b1205502fad8ddb808acd0d8eac5d8910003df34ceb0aebbeb021f6da0f8168185775b7cffa73be102ac38f4d4b96817825816019ce9166064e25e3b632ac531795590bcb400c2da7a6453ece4f0b4b379782f3b8f4b3e52d59cacb3cc711cc4fadae111d727081f8b6c6bfc3ba2df3ac7566dd2761c974afcc6012fa05bc5067a9c1564dc388362fbc96851b3f418ba94ca35b6c1422be91e2052c0893038488c773057c02940e35d8c9383eb4e1ab32b55c5d49b60339fb980e9424f8db0a4866aac46b951cb43d89b3abf1e7d6e4ced2119464a065fb60a650786ee9924bf89e7985f4ef1c89ef8b6e2df57134793319cbdcd3ef65febd7be1bb37ac78d08b7fbaea53c7d9f19e009f68155c6b76b9878804759db8a4e14fb3573338ddbdacc4dfcab46788d3239d017afc3b8ff4ea67485256953884be4517a553866d48fd4c9a4ed07d7adf6dca48b9f8acee56fa3ddd012d06b4dff348b35cace7581428cb5f499ebfa231f22e607f31d57d72153f36e3dd1331ae0dc92bfcf963ed05f8f28e6ced5d4895e89e0b68e53be4985a68b1941213c9c7401412a4cfa437c2f1fef2bd814e1bed5601a4a3689ceb819a71c992d98056c390726e7ade420b53b54c334eea3cabf16e506b80d087ffea0322cf24bc7109ad348b90fdfbd69cbd625edcd222e519098666130fb0cf77c3a90dd853ff69a7d1153394196f7933d881553d2b28ef01f1871694c1b905825cf747bfe2dafc34492a1e7c4506383bcb3c9a756d29fefc79b428248a11849d93bb586a9a49f1a8e3c1ec8049ef563e19fdba6e931781ce379b817c65e0b5ef59936af98429dad5c618667604f32aeade9d1a269b49d90ea08406e81ccd97883524a31c9d8f3835c7c87202d9ede6816c943f190596c698861d68d6bf65bd6c44e0f8f95e4ed9481ea27cde986a87e6766f3e8944da7d1dd11cd3c2d93eb05d7677dfaa34f0228541dda603b33b264e05973d18061a83e133f303a5b5ef75e2c4733e819178c2a31483f035690a6515bc7c6c0111b983fffe553f82f9e6f224ea8575ae7a4754ce607b2a6ef4493c496148c37515cf7db9e3349427a2f5d1bfeb69da56aaf35c54c10187dd8b72988bf96169d27d886f98d9addd18c54e6e74506f92a1acf265e278d08f79520bd81678d3a01dba20054b3187595a646663d0acf3b7c9fc0dad7da52e10c2ea8c47f833977a9456f1c90103ffca11fe720ef1dc61056df237275d0f349deb79ef26164d476316e541a9173d1e4d87ecfeb28718e6527ccf304fbfc39080629c37149b53eddf4585213f3326086e7effa2a78848ee9bad9812a675c365508b61a738781ee6161c794e38a71911df6254043d082d3a1f1b4cd9c1c7a81af3419122af785f722770ccf32b3dfb8b8a49d8238dadad1a1876fbb542df98fb1b34efba6d516777840ce1438ff7ab7e4b067af9d4f3dbd311d8ebbbf996ab904ee9d75822080a4a722dbbb395755cb321d1aa59795eb3d9831a7b7b1dcc2c14dc82feb12969e4b0c267357b850b36fca9a32a5facc5a7d2b9bf1167aff673447c1e3d30ca80312c820ce04284476e9f9731d67363ef6a6e4c29c12569297f4a84bd958745634553faa849f013eec796d7a22b7ebbb3171652731c6b638a3c1ae76f41868e524de67513abf5cad547eafc5e38a9c21154de880d2360ba254e8bab9fa4303c53afd372a96901b80471e02d21e302dd60672dd9301653271b39f64984e8f4d56843cd572790fe44b4d977f22c685be967bccac0b99afcb9409ca5d12f03cd1514c33b5e44168e7abfb5ec922918f407b666c3e31eef8b339562aa40f5831948154b52ba19603e2b1f5f26b82d3f4eb543e408ca78f85c3c5666bef818aa4171366889ca34f31c7c5460f8d8df53419fb9bb57381ccc7042cd97138856b3b8c2f15369fb30677cebd9c843b200d3e77e84a92a477b6e9bb450ed8dcc3bbed4a629681f5af77cdb11a49a309b1feceb8d1d07f2ddc816411812417a0382373b85ea3094be11aa490ae9557a7d6afdbc744be410103012cad1b8126c326647387660ff831c6889c7a9d1599d4817d23638bded804372d30248b40c84e5163e7db1cf4fb8e56b042cfedc990c7e0f4dd33db8db1560012e610d11acdb905bcb9094f25788833a27857d72e873abf781c2d26734e2eb235272561dee61fe3c2f793878409bbd8792a3dfb6873e1bc5d02d51cddf681372a5c93e9ea88dfb9f042c83c656424f9e3f80035b8be40ea19af3d07ed4e7b99a4243c576184651134832fb2980ffd3ce6196402475336d8c0c4641d127b3bb9c08d151f8e6dc2b2ac039ff37c9e685010cd5e901f1f64673e612d810b7922ca1b3f4af08dbd294f82373d1bacc2f85236bccf65bd615640cf27a04d8a494918e2f80fff431369ca78ff29cac7f9838fc8e3c68703f7c6f7af4a84e7a94702b70539193185f0d0594cc968adffc8e9084a273d5511dd1458a12aac5cfd8f230fa70559a2f7020fd34ff213eec6b9fad0de355ab9a58afcb4cc5a677e6558f6f5fcb2bd1e05f6fa380dc8c911d4dccd9ff0935c1a770db2bcfe59510ac629697acd939a930da311bd5ecec7572fcd8b8041d0aaf4fcf70863ff4244c2f536d8ca58b09373e538349b9950a109b968e83fe0688116f1acb47dcfeca41171423c8a8e6ff4de7b32a1c9dbe36ec94c835819e844e4f5234a1e0915899597a714ccc78d70cf6f3ef471cdd83ebae96942042e7bc8995a6af4720feb262f4c45b2f6076ac7f75b3167900f1c1c3b32d2546036be8c0133bc74c6227686199388c72f0fc2dc037d70d5058784f1c2b30649eef24d2229b57bff01a3529b87ac47e735c9b89b1d8c19015bc928bb42bac515f4c1e086089d2160bd29c813d644286090ebe4122629e7c8bfc1161d1de7b48df27c344e451b93a8c5c10b50266c64f5f6a501aa923f738ebf35a2fc0fa2d1c95c078795cad0ba39b16925899c3c4f07b28148697d3432341156e2a55538048fd0a7d5aafcb15141a8bb1ec2069f901d0a469ff82bb7ad32474fd922983e0b40590b24a9d472b5999ee974dce1721d3dea01d3217667a111b326e3cee03798cfabe45f1fcfd1314b310c030f6167890df3a100d7c2bf05269745596c42148c870167cea83f90715537997ed7994512018a4eec493300fe523e29c35792d5ebe4a88f5fec165bf4dd686f0177703436a32cb7b7b01cc89c5a8756b40bd0ebd4d8dc4b64e18b6101b38a488640dfa08ec2b8d868d95b5388ce5ac730eae470de47cbbdedbb4bc68c71cac457865c95e873fd0dcb9d11663117744b50b94eb67d04b895de880c4d15269533e626f1e2e573786d567b1b03e904f9fca30d413ad6fc0f4a24e6c6db2eeca8e490c9b9baba5a0b6c77bd8401788478c840845176567b7220a0e6f10e3c7747452a58caf2284a589cea9d32cf03fee1b56be0188a116b513f336c402df058938e5eb83d22ae45f7ea0bb270ebc7211a0947b8bafc6e04f0b1541638f1572090b9ef7341f0ebff1bb92a906fc469cbf7937c0a67bf5d0d2ba71e6a8434c124f402f90d95b86f2cb8e697686101ff461cd74abc6312d0ac131c8e708a89db0530b3491c298de0dd9860ada4eccf5d6fac39053e04fff870a3c710a3bb677182dc0d030cd96fee9797665b37e115960d29332ae97f53e00390299d7257684dfc368b86dd8a0c29a5ed90663343ba8ed1ffee0257f9c43c0c657c38b839df526a742007c3d25cf5c17f155ed5c09aaa75223c1783c56034b55a09346ef88bd9199b9e7db02b77fce326c05dc5abe07301ba45706b2ed4feec02e31a5b992696ad43abafc11d95c7722559bf9545533fbf1e3c81384e6d97d1f2fb21bb08787668fea95c9298017114c482c67a1bb05df95e2b20120e349c5dc52e1758c4dae0613994a632442a0bdcc6e59eed2366f66f7ca2702c0124a8ae5fb4f89709ffc7490953c619259070f06bd1e2a025d6b3ba98a9b58fcc99474fc67d5d19e6397e770cf62a4c2dc8b8b0c29b25fe1a68c6a7dc2512142aea9f872eed850f5900e3075f7a221ff58f446d39744c030d03c2b904ee3f5ce87c4afb3bc5b2549f14cfb4b008f59fc5bc3a8a375ad938df508378bc87922a0b82259ea43c0a31ffb13fffc013db81252da4f05b6555b684d1425a8b0e83fdec79b878e26dd5427f9796c92dcc4504686c7a79ca915f56e9e723e2cd3183486b414c7b728d726a5c7117075792041453412bd4b40d2f18b9ada7a0a7fd14f6e98265f85a622acdbec3ef76bba658ecf0f7ad86365a2cca31d0b8dab555372c2215981e7379185fd856ed4be7fa7292e6716f2f1c53cc3f1566bc2247af70a59ce5854332adb6ea16750ab07fe16f90b0a20850baaab382bc1b153c1c6ab1f045e3d086960b08431bab85536a6b743e568671e018fe9d8a9f76a6679dec23f9c2228c0b43e796dc9967c5c3141bdf37084e0d7d9571f813cebcb5ced880ca43e4a1fa053426645208c129ab2de77073641c4862d80ad6741e5f00f04ae69531c0c75495e8cdac789ed7e057e50309cca448eb57c2992a0e85a9c31d1882a783f938cbb5ed09fba37b124ad7be9c16eb42764f0b8e5bd60f581f2abe41a17f0fb196c42daccf2b01bb5184db9fc545256f04c61a816a7ba287f6f65e4e814368d94bd1c67576bb4f8ee5057e06f147ebf45536aae96d01aa61d6383801273469c4f06545e5102283826d078c417281adab98f8486215ec9f5524ae50303a8529047a43f4db0eef5bebb7c10c99e0c96df81f8a2189fac43880806770dd9369cc1d79e48297bba4bd3f2c914bd8fe97e059adf0b6f647082079ff4593087404ca724f1ab757f3f68a87b07cbd99d49b45f26deb212ca21b2d313dd94d77a290c40454cadfc691c4651812f63deb46c4274d2117f426a06f7a72eed1e6d315ad65ce2b59fffea7c22401d0e1bb83e67454cf3e83ad06d03f4df805cb128ee3a0291e186e7dba76dbeaab2df2f078ad0a11d55f5fa0af3ccbdf7874af0a05e45cb47e29a4230699d71f7bf0b7741035f98866f29db1287b14089fca41a4a1a9e0cbfb3b13d413c3d25171dfc462655eaa15c13650c8542b2d2d86106f80e614cd235dc2036e26d826572c79ebf1e0c7236963b654484aeeb756d12363615f682c83b043d5e7eb459339683090191faa5f035177d6e01bbe2e1eb6df780f8d4e981bd69b3641e82801482c32323720d29b09d228d6d490814de18bb204461615f2c94954986ef9e87725bde2aee2aa8ee6f24c88d9d6aae5311c592d165c725c48b3d2ab2a09b861ffa532e35f6bccf49a7485cbc66391e666594e09af9d6dd00c866ac661ac2a0919eff6f13a1ab56b94c8755c4b5e75c5abd23ee78c8070db61b957ce617b4c86f591646caf3418c84d054be9946213748034e98d55bcea9f75b57882c386dd005a2dfb77498c675d296eec4ce5022b89c41bf4cbf77029c04e673e57c445b540f6443347fec0aa7dcd4763a40017e4ffc4942857ae0932af910aac9313ce0e27ed84575be24d0562b947150581be2be922936c0c450436b8218345aaf3557b96ef7f7c5a9d47b0f3ad019085859af0033f9bb04c5b960a6331f8d93a26b7cb33e3812889ca1f4b0b5e5504841677d44f6832f892658488c9455bf7d5060d2e5a595148c3f29c17ca86e79f84dcac6a45826b637d44028f7fb741dacad40df130ddeec57b6187bba9e63ab16539e071e5e9cc698661b98ee86c40a3c58c4f6828f097f1a798e43535898f3842032bd115cf8645971563d327563401c9f55d1e41bb14e4cffb851752b633e9570b80c16e0c92b2d210c5707cff4c1148869e027b273cfc45d0a2ad4e0ed563d27d6ee42847ae50e832bfe105aeacc0779468fcaf6afc325a5f07f01b3877bb33afe2ed7447cccf67121330f45a1762b5d4b053fc6efb1beec3af0c8506accdb59b7170275db963d284f287de16f55865ea307b527ea9d403d949e9e60b193db973620aaeba091a46de6ea0eda5c86fa05253ee3618f979fdda90c50c96aa5a550f5deb163e72abb516a11b547541b3d21adcc489ba9d798fecfc7386eae3f96024a29b8a70e6200e9b9a83719f4cc1f0eaf480d67828c031af608daaf246e628e8fe803bbeafea07e0b5669b83c623b2413a4b8a0607d5f7b208cc764bf5d3de5ec15ab74b6f186bf0bc203332a4330a16dc624694db9b85222b43deb4bb9ed8e8aa04921c2fec2bb126716753798195b0791b0c2d16cf2f23d51db828de1f4fd0088f1e7224810e2b0cdb3f85ee3cdaf8597b963c2c70c7c75432a8ea729f7f9d38a1a9464bf40f2a47c8d68c9af48afb2fb6195a751c9957910a0c94b552c5f58af91028a51140829d87aae7e4f58dfea6f018cdb953236f2529ea31d7d70f4c5929e639ca0421134a95a8a5169397721929c38d54d09fe56b9910303aa25c59a65a90143f74781c035443ca181c93791eb7c023c8602dbca83cc4c37efdc2397839b0c3d296567bc6bcb33e111180845bce95c03b6896b8cd640778a2fc2d03dcea17cf99fd562c44bc04612388df858bda0451fd91c5429d8bc99de0b6cba020e05f571db3e7be184cac34eacc2f86c9351e274bf09ea055746c0204be7c397f91e396b18d60471f29f43a41adcf7f6215293396f6b9cf4b8d2e8b69519dda31afea7e8213103b4f9eb91b3affcf0db61ec6fe1455de1449aa62fac161813048cd812f0f97570021c783cda309efd887c739386ecc8950ec0bf3ab226acb0231c35fe9a924674feba3c70cbfa0062b9fda8da8f4d93566126b4341cdbd4946e1aedc97bb0a9dcfa415bef374c65649f479b187662e752fc2406f3dbfa0b9499382b9657c022eafd64bb400bb16cce04cfa18449880dd6368a8b9923f82e79d90d019c93f77f30a78fdd07f2940d408ff97a378ef519cc7d5af1a8cc07d0235c62b760a444ec12412e1405ebb562f870d3e55b39c1c28bce9233fe4ebed0cc81b90fab5b215b5353aede7427254058548f6b61ae2bab5af7ddad079d67c5a2a6c38e3ad2c85ad8a7891dc45c90b262d29872ae9612a22080b87bcc5921b9b82aa547833cc2ab86a71f052fcbdd8354ad5e93e77f65b22c50034d68f8fec581e8d25a8eeff25eaa7c873638eaf1e539087db2860937c39c2164a2b7a3d481c10c9ecb2312926595582889ee14315ac15c1a6b0fc718ee609a5f178c5db4d20c3f64b0181cf704cba3e90836a6810ca985238f67f21a722b9166f54f24eb71d1ac4d7c7930a0aea8d7e91294b6cf0ad8c7412d9d1d3344c242838594174b2f1c8fb066e1085922d7fa4c5427fe4c1ffbec10ceb83c8a14ca7d46ff3bd56820fe20ade1a4867f4fe35c4fecfd33515ad9a474f04ddab45cc4a2e89ac0a067261dcad0e2ece12cf0ef9e01a9fe622276bc623f8256345c1828fd59fae6a4198c209064a46ee6bc763773eeef3175096fa863e571aa424f4e6ff37b7177a84a257e25bbd9b4d00b403b1aa41b0e83bf819e0e8637be1c865972732def2013094c1a3e5343e12249792f4d93e27580418eb49181a4430182d3af194aa9bc4ea0498e81f9377cdc28d42b343e49c8bb58ba017e6c6231ac397ea2460d39c3d38c74583da37abf55608b661962913bcda1bfac19786623e1c041e341a67fdbfc73492e07865d352242b0856f66533344e02859658780cc9d216cf000ec36fdd1267dbce951c009cc9e0d64c999f7568e54c4ca36d0d7d624c5a3667f9c7199e1cf7fbdc9459208ed6e1672963f3b70e89a19b279b92a2bfb0fbe68531d0f8f58645d7a39703577ba11f0cd530fcecac4fcaf432c7f6029c884db56d0cf51bc8ba53e2cbc0578a97eab815d8c171a1fef4d7359f7ba3b4270381a591d843cf527bf8347a2b72468620e32c2b80b206edd0c7cff04ba628ae35ef1965a1a8c695f58881616c8624c0d732c83d526c9a70e340ad29c416119de7d22623714bf1e8843c3d65af883460eed1d3c2a09df333605cd377f76698e1a5f588338159acac19a520e97a08f755e61477c947c933fb1c00a2c71c0f6682725cd9e8351b02214efa7cc648d932433a98ef114788135b2bb32fbb78c383f3879a4e5b629134d4b36b300db53dc6b32ae9c6db0ea7fecb6f22e80b4b62aa8116252dfe30b21effd803cd9ffefbc4951f2b5026d1faa475a76eacf82944c39dd6d541739ac5bc2038f75532501367e33ad28df428172f02e5dbe4d16866c7d6629e3eb6c7ce63ca4ff61b8ba9caaa1a5b823b5e993f494b249a42884bc623483313c8281986924cf3c56a86fb381ddeab41103aeb682c9ca6650b566990376a5f6b10499354f2897a5c577cb20e46cb994d6291a63447d023c9069d1abe54f891c38d86c8933b8a650252cb8c6c2eef0533f78d317d9be33118acc83edba2b2be8b8ebcfbf1261ea2035ac0e12ae685a3b20f6634090f7f962dd4a615f1e136dfbf6ca7915c5d401b6450ff58113efff073784f0ecfb99cd8d587f39268c5c360732bae2a1ae4497c8b6f1293a7ffe4411100fe4e8dfb731adee2fcc6ae1b7c0e71ce453338d018dd40ed734ab2fcec1cfc455ce87dea53a7f4ee36b0cd4da712b30a8f3418eca2057421819a0b1a39474ea3c65c3d4d058c9b40c995c1ebc6a0f21c75e9e51c2003ce62abde6ea4c6a76cccacb1d32e270c5a522f714c34114c8c4ea60bbd721e6fca40fa179e77b172d737285d54e8d4782f0114e8de476545ab77789e4ac910350cae549d9c3d298f3418484fa4e0f362e97f1845e1c2840941f2b2ab1ca6972c0500b19c7bad7b022dd8b83d88f5f92cd645a8f49e498322f4dc438c06da92b1e70fccf35c773532ca369909c8db6f44475433d161dc8f16f581bde09a09b8ecaec28fd27bd68987cdcb16def31847aca47548c7f5a287a16b82a7e89a7442d039eb298bc46a06a453657b960870011225020144157955be92c32fdba22cf7d7b8ad4563d804a2f8919aa05a4c3340c5e202108ba740c03c2db266395c720f5e188dc00236bacb61c68a7640776da52464e752b17ccdc6a84b3cdfc266255ad0f95","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
