<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15a50116fc818fb86c6376997bca94bd38594f3817201fd8ff6eb41c5e30265134ad99b360e7868ce3c96bad22ae51d4b0211cac9c9abf7ff05b2039b10268e0a6a029a905a023b5c708c00570b513251f53b5eeb164cc54487cf6ef0af87fb8ac44269c10f0fd61836fb68d65c7cabc469fd3ef143e73013e37e60607f3ce4f88b6bca9dff313c3e3ef56595c2fc7d1c34a668dccd038b056899f9e73544b776c7c72f2f3cb455d087b044fa31984d5f0a2c3cb2038b82cbbbafdf3745145619d7fe92d151a36eb64c70ddbb882dfcb8d2b9aba4c2e4d2b92cd9e8ce294053c30eb121a4135f7cde8cbdb7d1316a8ad51ac08d7f8428d3e849b0b956ef182e5d33e140632da9884f027e8b8659a27def19bc17e5f3ed359efec64bd9493c8273a546501e561f02ef8306e25867b234ad7da1985b560501061ca17fbd6fcb231228da8605d31be2b098d259e50698ba4e315ac34ac3c59a7866b4a4fff9bcbd3cb9d46093e66c6b7b7fc3edbfbec7f5d6ec20823d571821d81c89dface9ad6039b4d5ef0de332585293c91dfdd0eda90aedac324b9db1f2fb9d81461ffdaabacaca61a5b2969e178459ca2b628b01f5893171bfb18bbe21fd1ee7245063d98ab97d6329f232ba7ae979c98c6ad6fcee15af33595745550f08ba709af431f7fbc33a64ab0e1ea3f9c8b66ce8445ecef9db00e8f8c4b9851bb02ce07b9cf133c7f7b0c007593b18d077855300304c0841dbdb6fd844c083231fe4b5620d987477a3a7836ad7d88ffbac833b88b146e70ccb832e6fcc86830fd450d4f38c30079df078887af130a86992e6304fae9ef08344d5335cec1d09e503745f67f7179aba43a1222f0b9b1f01637b69c8d0ad8548c279d50768e96c007a5cea9a4974206815393e66b77c102b85f9b84b451653e839a7ea76e7bb54d62dd49d474f616d5708678b01cefc88be498a5c212f0429b3cb483e550b0a41d38e92b3967d7b539734eed36d6d9f2ce9528d727ab0bea35bb8e3dd54b573f12ea80640237a497036ef5be6c22710aed49ddfe5bfc69a9dafb6d57523aed6c1735e15eddb0107799fb350c6c564414bbc2e66c65e7d7cd5aac0adf4db00c340bedde89d74376cb33fed05aacf5d91f1939dc18c1d4eaaaf08b2243191e65aa1794aefc49be60d4cc24dc427309ec029dbe26a8b73e3328c07045f83ec68dd8c3e7b8cdbfc09c2080e5706613cf63c52ac4f82e34a0d9db457ce5b61e2fd31d36581668068dd22585d911d05e02d6fe0bc506c7da2bf36c19a10f97fd592d642bcbf5117600dc316b2f7eccf0d9f908fb1bc275b2357f5e0cb42aa32b6109acc1d78bd4853f1f3c37a886a8cdb6865b1e223c8cd20c4217f5492c86d650bd7902cbe219f7e477cf8ce01f843e420545440bd68b11d285ca9457cfde9212f52f9316e5509256035555d2ba57d91b4e18ac1d2491f9f6229894d08997395de3cf39e7a7cec1002277d59a24ce8bb37e8bf5d294e3763a1c48b359114d651fd6eb8f518678502a9fb981c8a2ae04b3bd8ac17c5971a4f86ce35c6ae02cf4f4f23b4ea6999120a02d2ec1dc347d8a158c39e802b10dbc18c018c68311d36e221639dc994028d49678949b9f2804edffccaddb043b12566f256462d614d7997197835f0f1ecdb5892e013f82e63c68bf8b3b3ab5a525d79d3571da9a1836721b428bf8fb3db43c6065b12b28e6f53d6dcf4f621790797354cf5c71074ab8c6bd578efff3515d8576208f6c5bde215c0909f36325259354924161bff887c61332244183a2ab8ac3b5010ccb8840c7e782fcd0381068eb59b31345ca05c714857d09d7304f7435fb9fb67940c171cacf36df37d314154bf7b1b8b3168a8c69bab3bd928adeb20c4b907d78bdc9658a7765ca16bcfb24a3abaf2068fcf007de3a7d03a07dbd1a6f65d56e62e9c9483fdd9dccd913c8a4c49ce5ef6ad82ba5f6b0d8f9573302f3e20857c85a40e25b48b616a16ce195e8c0e23770b644091a6cc39cffc6cd26b47aaf0cde135ded5a2a99d10b3a455cdfaf8a71d1f2fd3df2a5aaad18b9255c219fcf9794c8214dc00acbf49edefcd72a968e2f11c908448a969d7d60903d34e5c87251d88e168e719ee79da10829dfc5dd3fd5e6d288bceae38fe5ecf78052a680c39dcdd50b964f7b8f40793d6257c2ce245b7af27f3d9aed6cf8121c7bd8840f41ec2603c9e90a450c113087056b7505e87f4705be5c906b7ebea1f87497cd0b4a9a319d2026130e0a3ed533210f4fe766d0484800b25655df6abdb455f66f24bb795714e416b0305f3a208131d8b20152f846de1d5b13b90afe497d11f10aced0de5ab1c650b9ed9a74c9216fd23ebf8faac5376bd16100651307b6550dedde83b80c64b347cc7ba2848c850121fae632fe86d6cc9450daf3421919ab7bd5757e052c0383838b608993571ffe93093fb1f83091cb4f618673485734627c71e9859b119dc4e77f06bb434bb888ce4a63a585319b24a6691f3f4514f5030f986a5268e707e9b7e465bb8bec729bf6732300a413f4862f945c3e2cd6315c0d96ac965d1a7f3b4e0184103f922fec183c983a3e81813f721d29ff37ac6148b52a27531acd17b3d0b942d57a31db086107614923a25f400a2a38c77d32234cdd0de7261e0b1b8eacf904397b6bc76f694f6795825d5437425dc5237a9978f829b131005b9a4296df8587ad7bdee8a0ea91d3dba9acd2e24015c04f72e0a00142ba8c6e073072883bcf1bf04e4ff417a716b2c753307bbd869a7b137a1ead9ae514f28f05c678fb34b34a8a1691c7d3c2ac0a3c06408a19aa9d25b35eb3b1224769ad2ef1e7ddeef160eb0db9c14d5d1722b7105918ed8e3100b8dbe1ca2ebef45972e3cdcf67892728030d16dfe89dbc7f78154bf07fd41d9b65bd4442ad08c0d833a37b383074f531a8aae55acca4f629ea4fdc62aed96779ce479600b8b03c4e416731b18b4b0068910d119c4af34e496ae83d80e9ea604f003d2d28eecc5a781901e93b5709cb85fce3115f058f0810d1a15d838f2b8dbb739089c37a61d3962790b82b4869e37a8101ce18e333a517386e6775c39de76565a64d55dd1c0e7b931dd65fa49ef01a97061a27ad7f885e306354168a4282b91422c42766cd63be955a5b0bac3f5f3d28ac56ebb5893abd697d3003c48f906803283ba277aa70042e48568d4be7e34673e95f53c8db1f3c4486733bebd4d01a4812e12059bce3d19c6737df40fd44e035d45c033d498af4c4af722d960e59f37166b72a4c5538b780790f3120e23ccc56e58690e2cd4233f9da427087febb161c9151d81bfa2cbef85d2337bca2f18c7c70fb2b27e2c54f6d2101348081fcb6350449a4c6306fd2cbdaceb041917829b9b6792f93b8f2f29a2fb49fb36f5c8da75fd15c5e44a13398aeb107fcc6404cfd61b9fecbc51eb5e7325c533619e795b3e695cbcb261c2e23a348d1f071fac6fdc54156ef84ee81c170ca8697a20fd81ac57c21f3c40cb59e0a8198ca3b33e90d128756a1bfbaa0e43f5091e1a16627a354a5c9b2e7975d94915ce9996ebb2cd93d4a0315a0af067fd27d8c80dd9319c7705feaacbde1137d0a08625e1a244e0cd1e75f93deee905164362c2d4f89cab48dbbc628a6e0510a9999ff65bbe18d0e4441b9449d88ea053eadf6dd2cd3358dfb5263964e411453181681af8a00fb1eeecf8b5fa4dc9c1d7fe44de564bc54316354fbacc790c764eafa26c5c81a3cef02aff4fc47613332cf91a3a687ed42efa39712c85d61a4e44a0ed727b87ac030b0713a2858a770bd41169097b7770722da0c8135f09d4f1b5d0739c06754e841ebe587dc1579d23efd65aa11ba5151ff1c1e1500aa4a6d526ad684dfbb8d634b6e810c95857708f9de4adcfd19b85f3b631b1b152edca5bbf8aaadfdad29f57d827396c232c84691502aff8b7a51b5f9a1e9d86b6c54512a34bf6ed334f6e0265700034cd5074502b6e0ba839a83d86d4076cb66665ba18684001a99b3c2cc9b10d4c76c8220598ec19784a9a24caab44b1dadcd743ceaa288bf22079eff78063ffbf42d6aade3255ebadf7911fbd2bdc19abdbac36366ed567e0a58b346b983d9a535acb8e6ed83a01026baa5f1f467835af7492869825ded961d06c0608f7ac9633fca112977ef707a7fb617e03155b9ea0b11d2c58ad55b0f11a6e239117d740f907887c49b6142051ab0c92153621c3007fde73feb500f36469345927a2218f28d69527ba3b1f7f7bf0064df1363bee7fc3534f9d0824068e6531444b640a92870d8210ca1de9039f6946c49aa374702e199b1fb9b128325e07341840cdc9ae752b90e54634decead42e4f46855bf9851bc67fe8050354efc18e07ed7f6db46cf2304ef5f2f2f64aee1d7c2370115f963e041da889bf3f5307f0fa87efac4f6aff8d8523af0b9b7f1ad9850b34a495feee5a5f057ad961cbc17f79bc53f8e2fc7ad4a6150e84cfb01fb9e44aef0a22733cc7a976a246e0d3567b1119fe5d63ef24267f0af20566f3d74ac11daa2d9361d3c114fd8c6b1e9892a12b2da4977fc9a2b3b5e3ee84e82047d5e5a7884ae0d319a0620ddb52c5633e9849debb8a94ce1c712646d0e355523f4af5ff0b048a3ad2538dc751749917c16683bfa3e4158fadda0adbc66a9cf059c572a4faa8d3d4ed5cb71888352a665ab1cc6847eeb70eddd3ea9f98e90c8c8ce2fe2a4dcf8d23b854eff90ba1dc84e92d07cb77c68783845af2c41cfabe879bfcb917d4e93f6b5174660185b6c9edce365fa2603f91155347272a7f58883f9b4fc1e964e2aa1a51e7fce97d50ec159bbee036cf5df78012b9558e5eb4f2e7ec7205be4ae2af8a791af5cc8e4959c976dec7eb836d2f137541ff801fc170b78e5cffdbda4f3e5bb528e8a21e326ee2406c4c8f9e6b0b233e4802ac472a21a6b68a57acd5b70b1a94f9e76e98ddac6d2080a8796e59392d4fc687f89f6001d72de584e2697afeb368820d38a728b85bf0d44f7515e5275a9248c3364f668c08f0f17fb49dba7fc57094494cbf764a5ccf1c79ec07650d4ae1178f0d243e0468363b201b8f48d32348603c27c852e19ae3f5492104d617d2cf53371e8abb123036cf127a357bc56176e653ef2910be649c74830833c7d945097c1d95cd38725591ff482017db082aa84d33b95c3fec3fce00f7cd130155671a136ffcdf32480526e2b40f6bc920c2544aa7e51311b363b6b7a89c7dd6d82dcf70fe8d215ce241b4d0b021de66c1e0fc0e929d2febae4c0e68270e7a7397678e0ed67fb2f6ef8b92a713a738c34b8b481a1bb7eed4badc0589ecb132cd64f7653cdc88a5baa19c4d519f9f173e5bea32842b506724557edd8828a8274bf1da5f26ee1e2e3fb425d36fb58d3cee7ac0a5476469afca21faf457fff6524d3f4fbb5a0d64a401262ec6b04ea603aa87d7afc23dae739e4f7bed6e385b934a3d73e6d5085e9203779eeb63924db2bc987dc5ef323405d97d4fd0c4fdc9f6124cd427ef18f8995d58c3f33ef45a79c6c537eefcea51e0ff4e7298b0ef74ce70b8b7b366700e1d5c1274131f51f7862efc1df8163fab260310ce5cc25054f21a14b4e375c0470fd718ee5c1718d20bec36ee38d93f850fe2ad2e0616c4bbbcc41a920b82b4ae9e908375833d1fb9e6dae823ee8530e11f2e111c38e02f43c919f5b05e599a0cbea5b396990d5fa84401751bc774ff7cdc93ea92c48bfed7ec85298f9256549f2e99ee28718e57b449f5317af342a3669dc87807f5a348912b6bb0ebad3525c45a02bc3b7b195a2c42f50cdd8c151c43cc866b382f817a04ba421b215b70726e94c16ccc67fee58320a646ff5dac91d336e3f01f835c7a92254d06740ab801bde82155c9aa60e74d06b3545d233a43315e36c08500165cae3577fdb01896b1b05d6c7b74c2263e6aec0ee939642ff05e3ce3ae5a1c935fb77b253be22ecbd05d974a269080a6bdde1ef1bae3fc6816e57e8c775b193c014a69eba1fd1ec20665daa7b55b2391f00a99b759c9a73c0259cbe30cb65b12d5dc1457a1f77fca95fbd7775789480dafe71a9ad4486b875da0fa09eedaa576128a095e18d9a0110d66ea0f7d82e0e46b84701b51e105cd45f0a935b77da3fc72a88d8860c9f764071e8a075c780ba34b8d9e0202b8cec4ef63690f3d4895c6e07aaf88029eeff159b3ee7408efaccfbe243ed02316811e000fbc110eb203225cde96ab0a299f2e4eb1db01bd57291ae90237aa00c7661b6b6c3bc121d52d3a7abeaae275d294315fb1ac5105d0ce928155d014139d75183b71d24c0371a03edc9c33989bc53ededa4be17b8a713a63334f2b9406b10816a4ce64dbada01acfa598ee3e7d3d2c1bdc32071cb3c3d94de64556342f31052c91190b4c974db18bcb87b2e4dd7c1b3532232a720d739cc060df656e350d31279e9ff674e861fb37a2d92e180ee38d3e5cdf590d640eaf2176be2767db3e2042dd4aa13d2b00a2473517501f901d3702592f291a71e2982dc17f8dac86f6b624663c096e9a2e72988a528c111888d046655ab1fb1e7b2bfb28266bcf735698c34e6bf6470043b16b3af51da0c1c81784ff1dffc15f916babf08ffd659d4ff52c850ac0af2a5177792d95aa3f864664950d5fecef5807f49d80cae045f5d8be0574b4557135df0ddfa8d8c870d81994b443ceffed157dd219ac851ac6c8261cdfe0495d7a660564b94a2cad78c3f0001ffee7952dff1834e96699c0f2233053164d31340d2b37cd378ce3c21e66854465fadf106c71b4390e4519cc4e16c61d5fae4f0c157ed52732c515035ee58ec1ad1140c9ebf41361b2924d8b0591656a9d4e9f298cf449cee1b9b91f8afab5e1e3ccf7eb04eb14dfbb3d9452919e88b4d283bbb329a38cc1cd5a5e4523cff106489bbb3d9229b641a4224c89b9f7221497110c807f5d05a0e94f1068cc00905bf41a11d463d3de392c9db96bd24ac3be89b50e2866665acc731a9fb33e8002e65f0a39d8e19a64eb413a5fe63dcc57ba43335d4faf5883aa066b36f735fefc89c8933c4a696997df5bba8ba1e14beb782d193e88604474502d2cdba9a6537ec7a7e7ea2faef862acbb65ed40a7cbd581bdf80d176fa1b62183abb85a5b562716ee818c6baae36b458143580b09a1027e17dc0a5fe87b0f5feeb5ba6c740ed1e1148514c70e25909d024f48d0c07f0cd71d197d5a763bd2eda9734e1d39f0adfe4405a99feb7776f835f729a90b97e9c00f4160b688d82183923b294a78be42e111c174889f23f67fef525bad418b1d8de37453e2b3227f5ed01c8a80e7d3626448c3b2aee80019e215c4b4c64a49bd3596caa72d814af0c10481b2e9e3e7b988be438a5c63eadb9d28d9aee35b36d94d67b3fa29d1f7c49963442d975140a46f40eca75e7828e2f142d664c3483f4799c2d2e17357d964a183211f8b2fc741e5110f088384c40a31405f8ccc4e3fa7f9e10b75226665ecedbeab8e8a422d27e7bc4f182875ebf9824199e765b31c44866f035d26b2718ec21e0c7ffcb1320f814d27e02ce759a21c4c354821cd9938ae316e978fd05b43219f99955651ee195fe3b5ce66740fa050834112ef69c3c2b2d7923bc7d121f43847ad81e5d5fb9cdd2685a4c1b3db365b3b7283735927b70ec2fb29c20cca651fd04e04666b784494004b4c60371614b0c3cdf527190db6459ee41fc92094222c2f5a3bb9f06db7a40fc20bff1946613e92c9f8ee2c8e6536028d735d9627c0bccbdce4bbcd57a5b13ce659383bfe6fd66b4a3a0b7442962a0e0cba0610e36e721892f4bc2af970e72e69adfa29a20e319c10da35ffea622c2b70dbca14583f3728d24f7697b7f88d4491cf5d33277c75ce8af53d2655f5eb0dec667acc62de4b86ef542f5b1dd7aa68b3a4dd68e928123afa1f5ed30c1ffd9b8355c1a39a23367b0d4d6fa27db88af0bb25bd4406fbb3791eeff7a9b1cea07767c9760f9a60ffb2d582c27981b2ac69f23bb0daede9d257db25a2b6e0434f4535a9c1e72778825231292c1075c2f5a5329f91b960c6ce3c26db4b59134b7a476cc0419393864713cfe870dd78f66fe18fe7dc371297618b492b66dd8d3d32e06ee5963cd5a3f5913c388778a89a8c1fda9fd42c83c8640c90c6d484e9f0146ff1e27d158d42cfbe7daa5bdd309843dc51fb899d75ae25c6df9179d1c83851ddb8e28f96197295a2fc9d995834936aa07b30e71c6a9696027bd359f596caf9d64d394c0414e63abb2a8e78cbe38bf7ab2700910246243f4a9d71fefe75e860dd9d1cf0b6e637e40791d6144a7124ce98ef44e2878e3ba4ddf74011d770f7937a9d44ecf15cb81d9b06a72d67474dfbcf8b1436251a2a9af95ff1a1bb3b1937151d4a7830dfbe1df7f25de3ed9be331f7e319fcf971ff24d273433fe5f3d0b71b0c5f84ec501565f30e1294d9100e1453af1616836dd07cc5fa48c3cdc0f496144275f9f301519845b3131cbb6bcfe2d522903c9cff8269c3d251d238c04858ca25c7f214f1364d0247c3d5def7cdb7b6f735cfbc89f24b9055de3b34193b4e2624726fe5264d59642ee03edc4ee8bbc6f5cc6cd3bd1fcb95efe6ca51d575465399bb68ebe343cc95a52c2bc3285dd313b8428465760c26fccb8782bb3d06d35da03da18cc9c1bb2f131dfa8fb5101ab47f66a6e0b294282f71bea56408d1154eef60441092e0d0de98d5354181230e5d2fc1a8cadf89811b3284b2d1aeebf58afda78a12f9844daae5c091fd04d8b24618d084f04ff0c17da9d16c0872ece28b2c86114e71bfaf27a30abaadcc6573e7bcc5b8c4110d3609b5e2e822a3bd549482aa8bf377f5f694adee28669650fa1699d5919b4f1f11d3b2aad6e960d3c9e2082b5003a4f76c228b70e95334b27c9ec88c56a2e103c11d47dc62a0339f1684f66024b958108d369ee554700317ef2f9a9ce10edc36eb0298ef562f4062eb4895d2038f96b0002cd82e927d063a076bf79cf3cbf4090aa4d1fe811c1ada21d29f54b611974010c7dc2d0a6c7e3d4bc4ccd8755b010eb383a39898b730a177b58b963a53b89b0e8de16bae8d872c3c81ec309cd8cdd64979f9ccf51f6dd5f1cdabef249b0c2541240a968df64a7d0b7ff1b467b5efbffdd6a214704d0a7a888855aece6491c6aabf2ebcb8a868f74220076e5ec4b39df6f6a7bac203603e8278390fe9c3e085d05f8cfac822f0b77cfcc47b449c4abd0101e26b9f556ac0d37e3f37b8b8b70b46411458c20d2545c42df2560f71af13b7bad8a88cf2200235e7fddc5b34474f0b525d2ccd74d2731181645f4da11b1f6b915e91313d39cc86647c303dd42ea0efbf6b8d720ef0e60e2c58ad482db6712e8556f57ba91e8defaea63524b75b79673f40e43f9e2b43786eda51d202be3a5382851e9e2bd29d6d22b557936a212c6bb09dc2c84cb6842b063e7d447cf211556634bb14bc7545a800537238ffd6cdd23748bfb7d44ec2641db3cbe77789a180457e80427b180030a99ce3289424f589995129763dbcdd4ff70c266c2a92e093a0792a4ff6e86b227af61cce79e96aa0c292ce86aad2cc49817e8126bff9b6701564c35f7dbfe7f13ed6f7b8e2ec65ac4fd169dc37ff7aaef3c4191be89e30cbdf0e5cf3c203417451439f62e46c791f767c12d484140270b982dfae727af33e25f571d86a580fb5d285a4b58a1256d9b5f30cafe990900335b6d5974ed52b57a8a81e689799c57ae5af26a1761bc8488a08429443c1b8840aa16aa1f8df5ddd1047943953ea75a7b195168c785eab370dc1182c3db5f520e0454ec79c137fd2014f016c647940691514f9d6a5cae273e807e46027df5c3cc13dee39d276ac402d1807d33373be6cf9a5f7069de223f26818cb3d37cbd654b962e7a4ce97deaae4381024a242ead1312c7a9494ba4dc9647a5741a1a12b6e751142b8001c9815f6f9015ae28556e84a608115be2a9e4bacf6089c4d9fd481be91d86d0f6d4477b4a00f4d52f1c28a3c6a0f3b68a60d3abebdf464912939a493597bc44022f8eaa7f6f2bccfa47c010412bb1ad4b90cd7404e52445d520fcec435d0abf55ec832eec8c4a447ad4cf82de90b2f426fecb99b2e9fea76bc8fd1d7f1dabc51f5aee648af9f5183bb14ad1e8845794b8ff58c1cc254ef01f6b6ff8060661285251f54bc462ce2d63af631f39ceffb423bb1a5dd04d8c7a2a48e6c5b7e7f67d9e1b07ba0416e51c34080fe69cde081f56c2655dc3ee5dfbf9c2c3ddc85c735ab2f62c2e7c8b5bc5ed2e02504bf5551ceff185699b6d52177542e85d2986375097e790070202cf8193d4f93411ef6ade4579cc065b16fd9c7454d7f70eeaa9c15594e79b42610834aa7374e5d658aeed21f08f27d4d6dfda31f9ce99a90b25a2f1a62449476c4949d3173cf3bdb5323ca53a1e2f09444d229979318b33e55ddc5fd285767f0422368f2849d88c7ffce392e749f56f9ef7f0866806a273e07a2c16142043634b5c05324a4a3cbed2b8e5a94a099336a19ebc2e418d7a9243e52c3f8f944202b8254b59688be23bc90dbe281fe9189f195f7a0bdeb84c6748aa10607b80acc70f11b90adca5c08bc6e72c2cbf672d1e31f5faf7bfdc4b4790e28652ea13f090417147c3b2176d659c46663d89cc273d0d3661d7ba71926e2f23380334b3bf6f9c772a7bd25704022b1982079aacfbc81910fe42732ed89df8aae191f0842f9c10ca41101caec6f959eff1e073faa708e93bec1bad9c2f4f89fcaacd474af7356ac91b201073860206e519ad256fad9841da09d0f395ae5950102e9ca93be5643d71da9f980e49c738ad0da9d86c7e9bf86e1b27972e436ad6b4b4862e135e07e610e16e86e7226ad93d4fcd9c722115a841856bc8b2f7bb8b4fa0bdda0656e0603c58b071ac9dec6231fbb93eeac7b226e3fbce1893f3fdd578c8209d241d5df381fbfe6d7d09f1ff04452eceffdbe89c821251933f39ebd857dda83aac35b5a0f8edd4541ebb52b09e0248a65e5fa3df9a1fba17ab8cfbe5d2ee51f1f14db94ec918247fc863776b605070804a61a128b8591e040d336ab7677513cc3cb4a28beaf85bc4a4e2d18da066309c1a90229d37657a378b7933d19ce2f2fd05aed557abc110ae199b03ee8cd548b07f376d8ff00142d9725c640565a08517b72aa4a4b85736f4955fe5efd5c247ccd34d685511d91cf6f3b526a4edb5fc92d29220510a1817a7a64232f843493166fa20220c632fe7ebc45ae08042a0d24db209c201c813a5325c798a8dcd9b55bb1d3f3c3090d0781c3276b14dc5eb8c9202388b6d1d818cb5781e11f3631aeee6f6cadafc8f14d659c2e061c6b329c5bf7005f866aa876833461367a4302caaa677f2d88366232e6e24af821713f2910e7078ecead3cd18df490a5132b80f2e8e6d53892cd37992ef686fa5de142980812e0c4f2fefe599ecdc39c4fcba65ba6ef6ee7d50126ef950781ce79302b9895aec1a33efab9eff1413113caff820bf53126ee798a35e7dc2d386e67a35ea6d82e2bb01831cef929860b18908120ef48e2df27ca8963b926fda4afe2291e5da10b2f830f5d35adce74798f76aacbef9b2f3f792240527920ca3c151ad032fa650b0bac768bb36b982d39d4dde8804a256414b17fc1d6b835c5a9df2560499c1cdd1b6daf3bbce1f284ecdad965338dd1abd393f2659a721422316392ff11344eaa6d77bfad5b53863ea558b6166db6e07e3d6bceaa3331843e540fe444906cfbc56d6a2ac480ce1c3d0fba41e041ce4c49d7fe42677f47072fe805e9599fe4d087fd7d53262cbfc7b6c29a1ecb4f0b32f21b13fb798192f43ef1312a80c8d1b1279e92c1c83379930efecfc482e76cf64fd8c469d4591f60a621f6e26e22d3826d958f7afc824912f1c04297ff531055bd468fc877592784199b21807c4fc0931cd02769c8adb96b3a69dd504605f74f7a477294caea0d31cd46f4f4d47099dcafbfa2f70e55fb21bae59dfd5169adb45d72d824912fcc5f5d04adf1b22cd79dd8d6664f3a7fe1d4f8cc883069b30c2bfb4aa30a4be68cc4c289c0acc0d669ab3e4e8c1bc4f0d0a74004d561ad1268dff8762a7f0e325524933b5f9e904cb46afb4da3759f9186545f2f0d3960bfa1d7e219bdb681ca5875e8f74ac5a5c2da8c798cd9e407b16eadeb9b1d44ac03ca7537429c5ed8762cb62f8923b7924e91c2c20896421a34809e5c41b19dcf63c22019b2844c7bfb6166f39d4022884a8c010545a6664bc7581f66f223d51b5347ea3f4aed27a8c17bc07c39f75c7658360f5fbafabfb3921e941fe71b15f76b6c06e96a60ade5a82f9d0ea396b944c1d537df7a66908c7323116a5269d475dca78097ed2042c2b7649482787e0084f4a2827427b1ad5c6290105ec61105d422f66788e099221bba806b95cd3f4517b7040ee6f222efbd7f6bdc246e9ee10f9feabe1c478c77077277b44986fb806a75bd42251aa2bad542cff604b5ff3b16d29a346507a81be0fd8240270722975a5dfc59c0be30af35b9b19d8342a7c82d4289e792653bf9852b3e0b4c0b2c32359b1cd907829e3367240c649181856ebe59f831cf3943b6a464cadf5a3a03a08ebf1ae6382eded85b19a99b6a8fff5b143b695dea6676a04b6bd07febe960c10e9d255292ca5edfc4ee38a98b7aed0bd52e59409b523d20522e815a7107e80faac16d7bc0bb735afb31dd2625c1bd7321e73ad33e5039e93de11038b48242076bf2e682ffd3fe9eb09421d8334702e1ade96cf1a659e1f9d89bbac72cbcd45c60b8d8984fd17c23f39632519447f22cf86f55d0cf502cba835b7e078513ed232bbe811a9276d4a967399f15b394f88bd0f894f883bcbf0ddf57f981c5f5e84f379990443ac5aa9d7b51fee8dfe8eda40c385960996073fb64c5af28d677078d77ef526c4c9e51dab6340851ea730e2349099854124188f0814da3cd91a1d20ff1da305c557727b83ae808e2109864340aa3132aa898bfcc8462811f21e152d32bf5d55207a5dad235ca2409f1dfc52696f3a0f541f8304f7d96a0ea907804b6acce1da3fe2a0b63d562391b97fc22784d9f36c81a791d9c96819d8683c8aae2b30ad44cb3da60a298d0338ed0653a7ef9b76408f58996053d2fd564fbc26eedb3253be57635cd3b7c5d3202a5ef4b9b852077a13c364aa41b532535244849d75e92be068a97785fa9d157b19f20a2e2f8b0fbc7ad24bec2e7eb30fb975401de07d2e9c3b6740ac9298a6620eee4f1f9ba9f676438577d1eb27ce8bb8b5ca8e0d3cb675ead822b1074762d659b3625fb705b50aafbb52217a212bf27d79658dbadc3e06bb058d2924de421a5496658ac6551b828b18879a1aeec04ae2c4d7b8609d3a4089784092528ae571cfc4a9b953d6b77b956d0e42ee66597fdcb4372bfa0751ef8331e5b6cb10585bce5d4c5289c3853992007dce9ca215816c3ed71db592d2a1eb56b81972becd23cb38c36e41173551c5e41f42d0e11ab1d1d6901c7f364020d0c93f64395836c89f97cd0e911c89f0f376bc9679603d891314d3aed8cca320806e130c3ffce0789b8453c7e50eaa2ab797a56861839df0f1402fae1183ada4e6ab053655cfbed321634943d2ae10262fa63644ecf2dd6d8d523045c1e2096efd554b29177f95d6d22cc7a18c5fae640098691e201330ecc7d3e308753f12a6db37adf3d75913230055d85302b6f437a704797848437914d6ed218b7d6e2cfe029f60474332a666703eac46a26a76713fe46f995d89268ac076f0420176b5bfdf609f0c0795ef2672d93b88bf8670a3677eb870523a25f78f6498a34801d1f7d9d703f361e4b07d0b31c2f6e76ba0e9526462cd708a85c7b71dc2abd5b32b96e337a1ba8ab529020da8c3efb9641dee52671de752fccbd1f1682c9fd5e13bf431e824ea3031986e603125605a294d1e1e863c7d89287043e4d4c38d76ec4d67f7eddc7eb5880847b4e2eb03ed767dd8a578465e8ea3b3dd50f1feee3dedee33556cdb66735acb8a3204d819467b6867a91e51953a6d1acea89c04221f1685fb203d353b523629c98d77548a4d31f035648beeeca1ba6572fc8f9ffdf7e09e2843346a64f5317c9edd1b7d79db8701138fe7796f6a6845f2cbc5bb4ee9a6d10ed73c10086006d172c5653eee693659e7ab701c23a52d3f7c6358cccb6b322cec99d0ecdd5537d3e9325a05f11adf6ef78b67bb0304c3ab63edb5d3ef8a6615bc52689905e055c19134dde38da2ee5cf6ad5012c2268b4ad0ae2ab4164b26c9bbf205ffdb12c8c84f61673ca0e7d244bb840d2cff26051936c9e81332e24a1bcbd406566dd67eb68cc07be9401bfe935e6a83eae6a19c435ea60567d313822f7a92b13eaa6fc1627b030de99fdd41057dd6f203a8ca03f96fea142705badf5ede2d94bbe0e8ae74791a35d3d48babbe82ced7e68d7237be3722969a16905ea8aa0b56b924939098c29dd4bdb4616e7e32201c58c8e8607d278e24133ba25da9d60031333a0e569ca3d785d9ce303710a784e0d85b3f4bfdb17de48153298cddf2d1edd5e72dc9b9468b8a9e5e6f5babb8127e21086e8540bfb5c0670442090ac12d53776945b78d564946a228cba21a26381fcf2b5689741185038a1d65d01afe355b29d5c5aedf5954998769343be19961c74e3417babb82c8e938fe6284443d3d9cdef40916f892fa167a84dced915dd01be57a032743ac918d00086df57d4b3c9c35c517331318a1227decf4e45839502edc7fd0bb3f41aa703bf07e91c70adb95a4c1e288c697e049d6587526062a15a544fb6584ac390c579678f99eb270cabb6b6cfc31f1829629880e14e2a04ccabc5a1785dc2e29ba0e89e88b376116151132f5b7d95fcb7d8e7d2539a8d496e9d393cecffb09231d6862d3b41ad358868134435161596ced3700fa345155117ae51746e6ed9a4a66d8f5afd1b163d16b6d10d39bc34814a1ac584d331d9f5f41d91c43ded4c7a0aa31116c1bc26d286017a86d48ab13142209aef24a160ebc1293f78a4e72581d2e0638a23cd5582cdf3c14c1b107db3f8d80c11532aad679c50c3ae9e901931d8e78e994ed423a99344d4d87655540b6b2a2ba3403a83ccd43b6e84fc7f850d758913fef817c7d71e06fe5b7caad990e4bfbadd5875c9aa78f4f758e3da81cea77dfc9db2e8dbba660ca6602af9cfe4e39435a65a23595d6b952aeb29d67c7e9f137ae0b8d3b8719528d2fa5b3f9948158dca81e776ef7d0abed892b92fae364bdaea33a501fc808b2babd53ddffc3e2918eaf00d31ab469a97b68c0f58758cf74da0e9307efeaf4e4390d1f30594dd41ecff56bfa033080f09f25a87c3c73e3090657d208578d4a68945ef2f3350a00252c628930286e5d78dd1b7f62e61db24e21f3763ad11920f113291415863f01562f3e48438db282b72d01651ba4513a47399920a99e5e1fb539fa78c1ca35b0788bef960a9d9067773f84d7f9aeb7b4e06f7d775fad50ed1caeb0612e1e883f348b7c393ce2e0ed4b9f496f948f7c2ebfe0fd888d1c03ba01743da99d4b503ebcbb93c0f5024d04a2f8c520c1fbaa751902aadcbd6f9b0f4e10cabccc9a94465e695fbd97e7f051e70fdfbe519507331ed4d7c0aff75adfd6c1d83ed8ac4ff76a114f62f4120c22bc831b572aab4f9098de1b44587dfc51ead785c074eb249f4b0baf68683bf971a53ac9e25371bc7640a709454a92b86f4d0053ce9e9bbbfd56f3b6c30a3bebebbc1c2dacfbfe379d790d75889ee40db084ca21424f6b762bd5e7523a26b2645d6f0359486ec6d5fbf1ac657934fe847b6da683230a1b65bdeaa6ad8e418bc8c37b9a2ff6fd269148ef1f3711af37e4fcbda604dec68be30a12dd51b3d9aceeca7687cd3b7352b3328b550964b909124ce5453dcf19f98a4d8e79e93d10da86dafaa30f03753686d5e4bf12f117abdf425e39138115495ad524dc0f1d32f7ddf40b5c62f3eb14f3980dbf0d0d8e16a89a0cc6019916004d268d8fa9502121e835dc2c8a304aeae8161b31e8321a9032c4365a33323a017fb0f070d0da8f56a1386eb89866474235034a4d677c2df39b9fe9272f2a05d0fe67dbdce8946fefa89c2b95e7eb1e1da33b6f844f7a4534c2079f8c626ab305209acb348e28c30fa522cdcd243460143dc12eb1b11a930e1014361df3fb81461215314727ff5c9d9008a528399bef66a6f1505c6e17572a9d18e302bda32019f567dc3b3dc7d88f962b2e698da067e2d8c8d7bb1e853bfa84930a93f66064581c3d87060013c52a2b55171d76f3acc38bd3aefae88f8b3c839cc18cfe4dee25443ea9926585d430769506fd125738c850e8b5c77d836a1c7ecc57a4f1a2f36f3e19f9fca0e583fcbd84473d933b3542019d47e5b90d6ce993dff4f8ef1360faa587cd5a319fa2c15369cef7f94ab73d8f05f79994e0c9a5bff18d9224f03acda926d8c23fd015d24da65ce33e5ba4eb34fdb045de74ecc7ab67e395e4aaeea02ed74e963987a34bf59a72f2eac7576f6a68fbfe6817fcf99d918b7f926c0270836cba181a352993cef907a54a242b549e5f764c41378a89f8a90d94b39ac43402837477fe9b986adf227db7b5ea717541578095c516db63261699e27307befd3f651776ec196f70f746599200f7d300ae1bc9006ebfb4add6a6362b6026a17a0007e4ea706f6dd27bb44abfbf0d83f27bac05658ca7fbe8c4c00f84583da2c0fdbb5ea1ec1f5df4dcffefe1177cb161fbc49be8b01d0574eacb7620cb92421706e634fb2933cb144902b8085d0cad3902b2cc243b894a7714059faf23cf1441193a4bcf599eb7e455a1a92a897c42d825619c0768be415a5583dda16b2c5d120e4ff76ef5fe1b9bc202454f04a63e3860844928f2abc4a8563bf6c3a2bd2824cf83c3a6ce1809b484d332ab05334018b2c90caed881868c640234d0a245cf8f44847299e7a46bd4c988b55204f6360afd89ec4163e5c107aa5edd22dcefe6093a40aa5f6073f2b5b2b3ac6993e7bbde3bf88aba8f0a86ef102241ec8763201e42af4f9c0ab6d31bb0b0562b5e08912e86e9bcb72a84eddfb47ba694109f470731ca1c0f5245f061bf9687d6c7f246e39a04ae3c1256227fd682164c16b00d2126d8146f8623f1bb93cd9a6884ddf9aaf695d8fec28b28e254de82b918ce518b41d5fb8d6d7f719f4eab080c0ef946a5bd18086f6d3d41e43fc99a4b10239ab0207e7cdcadd0fb29790a3cdad0eafa06a3c2e61976b562e4e6569d8b5c37235a109b31bc08f911ef6b139bef1702ef3b236d28facbb5a9aac90f28a23df2d78f7b9d394a6f155bb4f0d466f8f4966f8d33b146f8af80426ac975f89515439ad3c0682ea9003ac59db6f20be8c1f5434b99d630349c64983a8ec1a00a4b9638aa5923bceb257a5d225ce9567a53304308e14769face3b887152119bb5d9d55e61674a4d05fadb808e53468852ae2ba6391ffff377cb8422016196b9262f0850edbcf02a7a3b726b5d093caba23a565569ca9ae21404c9a61de64106b93d19a436160bde2054783b6eb40ffb87a4292d4716bbd61ee0c092af2c3d20168bee9fb3abc0e1245ca0bb5a5ef37e7d00cc6c65bbabb0b787b657ce90ccb183686eb34ff31fad136dc88fccecf1932c1d30156b0596423038ba7e09b004de238a4e946c9931fef462590b57d6b8b6bfa52ab9ce3b8f96fabc1fd7cc1e2909fe4cf902ee9c9b3683bb2505bad61dc50c41b76d4ea9025aaf29c411ce69896232a02b722f85a85b2ae0f219b9f5430a213635a8167f1d3d45c45e84224044a502b91db3e099c41871bf11c859b55400f397fd0c9b2e6ae7156dd012ec13ad3d6b81e8ca9678fb3142d856ecc041c888f1a656c7ac8a2ff251b6506e5da6f6ed8b0eccab29c5e303620ab01bf4642f58e96d98bc7c72db5fb108ba4fe40cedf5c91dc88c450db7b62af3d2113fb11442dd72073e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
