<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e3b5d7524126b68dae2a8fcc4017848335785ee58228aacc114c1af64e78d8253968f775e9a3a1c259225302a83989c688af45b5bc76dfc8e95d45988bfe59b65f292852f32d4640e01a69aa43c4edf647c50e3504d21bdbb644156c60d58a063971c8515689181a5322198f8cb07f69e9112b68a45419a71014f9f12783d01683ad15146f530b5d93c29e729dcc79708506db13e31ed81bbde9653f86bf7dad4d9cc1770a55fc0fc8838ffd4ac0fc83279ed16c79e0a533cc052817bdb0186f6d1590c20f7f7e75849ec5659e19989dfb718369a534d242c2056fff3e438a49b0b0cc4f0bc09d770db8cb8acf89122d047756cfcf3871e25df738b72ed6e736889b83e8f2b54c704be4724b066ff0a37d249c0db17df78b8d0a636f32ba49739d711fbfdf623d8781bec8e3278a6159f83c5e33859eabf4d3c4535476b93c42db29b2c5b2ccac3298b2d3d1a18ca8fe54804b0379aaeb5a9916446984db11edba38beea0ac855b2493fd73808e31f7382d2f29d7952eb404d448fd895a55db417c193b760c0ba87424285075a042e42d74cfae5dac243456e9724fd1351b192893c864cfe27e24e66913d0b65f60922c1fd4e43e867a7259e7bedeb486359ff6e9a7d3a7275ad6999d38ca58d6a4f3f0bcf2a1ccaf065f74cc566ede417a57197714c856a39545d51952b7533eb18683eff01fbb5086ca178f900019b0987c4a1e792697586ec39c4d0c45d9a0fba8e4cf6516dc2c384ab19bdf4f6a19ce60d966a663882b0cee460ffb6ff080918a3503439c3e330d8b83e315d279a08f3a3bd6af2bfb8f95119bbb1f2af5a0a839ea33d0dd109f7f727c5e0e02cd8f13e2bffccd1fc2fd5dfcc1ceccb84734f060ac44b673d1df882ebb7c7625df2ed3cf99ab84eb6bf1a20647706dcdbf4fc1e3541ec064cd02062ecef8fcecf60a4d6ba06e9f9050d3991e8f26191afed94fe801ed2267a3353196cc61e9e6940583e0ca77a3819c1b6dd44e52f5a0ed07c71b706678769daed14b9f126efd610597a4f235e6eac86a024c5bc69ebf83bd76d6adb3cd62d8660c2c339e0378a595c623ae20cb8233d7d2eafbeea0760249b2dcfccac759e36c6314fea6af7fb73cfafdcd86eeffa938d506d15e06f49ba1b082c103304911a487b6e6424ab55746b827eb695d3660d60699da76b72fa1054b35c5f9bcf944e6a2098e744da423b1161424a44d5e24bc02e6cd03ce4c9935dcadb8f66be7ba28467081cec376b518f77d53a7aca18c8842ad6bb81d0a21aec7affd37aad3ad0cf3071766f364e0b424df77bcdea1d42d2006ce0f8346a15b56f1538f77defdaa2d161d659c341b87414b2dbef6f90fb4afae62457310e181e4192ba9ca23c824b5ced2cd3ea2a2c7fc22d70c643d3a1579341f881d47768f40ab91f9d871442119059205a82812c629538760a5fd5a23c7d3487c359744c99af6f258d4c2a2e0d03bae4e558e30d7f50792a47c990c77c03880fdb6a9b3430c3b8f204b8f9a1aa10853938c36146bb6c54a66812d788548d7778c3104fa0ca0e5282fbf9e8e8dee094966986e3c08dfd54189156614ea73927b2d0d23acbeae1a73ea5cf3cdb85956892267351867eb849de7527c0abb3e0ef3c106bdb955041d05d89a4d5552d18abc178a04f931cce482128adb7524d1182f312f778e974edc092a0ebf063776130ec88b06c9606e3537c378890c2724d9255ce730b0067b27a9732c60d6c864f33fb9647e3ab2a20a43501970faa458d5c8e73bbc56d8e6bb6f121632af87996d3e9ad802cad9e49fcec67231720e71d15f2950f2f9664f5dc0fb4bd6110abca055ad4a1ca49f9c90de69f5d9d8faf9814ddc4b14f34280d035fd895ae232b9214d2f9a9a8eb7dc637dbe8a44f092156cc2e05428e5c9be34ee2d43d17b81fdc0996abfb907ab0d4d125c1fe1dbfec05b9b6c211f1c022e41f7d6889dbb243e0c3b02b975d374a68904fe47f3e13adb5331c453b4bfde4204961b27a6345ed5faaf8ab1af03bd31e3154531782d217b14874957532061bdd938267914fa7a4602b27f8f7e2461289a9745b1ecc0e56501eba535d5792d0477d73bda58b409a08de0d6c63456e8fe7f9510596a6a9dfef21ca015fe46e67de4450b7040716d7c23fb0f3fea1307d25b7bde310aab4eeda886404d7f8ff5e405379c08bc4743fc3a8f4b71851abbfbc97923a47ef4742494f30131a9d17cd361e1d7ca5f8662bceb80aaee8875daeda5fd6ebfaefbd8fd7b2866206651abb346864673ced9bbee540a61d08fe67493308292eef6fe1d283c8a1c5ad82d327006a706d1b6efd812232050ded2e5931ca372f5558fabf0e23c113adcaa84bcb90ecd48be8093c9dcc45e13310fd65e76bd6a77de98cb9428c1cc449f78466687c9a8abd860dcc229d0ee37f2ce29915bc6ccacf17f6f794b9ddf3d93e0f1fb8aec137557511e0ce2e9b9342e7910cb318ac103e22505efcf48f46d999fba065ee12db7325553fa5cebd1311d12e1bd76aa4b1b7937b7f38d2f1a1ce5bbe8acd2a7a73fbcc36658fb54e19ef2c8626e7c05f7881d1f017b5313c81d39aa6171aeada544fa1ef83b83bd32f125f08c20c70c71eb0eb5cc85b43b1767954f5971250a538f2600327393f86c9ad83ee990b3fc9c3219c94247464f2d98b9709b5c420af1155404f4bbcd974a33480f404ab9993f2768ecade002322bcd7bd2731c280c5c8c6e5cf0dfdac0da4c3e195c2f97a6c8ce5319e1eab51db58d28fcaa6b2be7258fcd355e8f26086a1910695d2c61b2206937c55c9b6a81df0eb7c655f7355d7b336d4b46e3c7f297b08502d9a5f600da556c02c9f758b2707d6281d2d21c7f4c764d92090cddcfbf9749a1a0ebebd1f5a49ec01fcda04f1f498fb76cbbb73591d3b51c8e6eee63ec4884cd631fc46a9887cbacc10c7814e5392a2777a8fca7028a3c22da3b4ab7b41645a87401e65dec0550f3ffe8c09a0236fb22b3c79cacb98aea3addca7f62bd8b971b59cfa49729492f46eb00a464d99ef9a5f119d20d49f723234a9c5de85e6bf3b208284bddad6fe947022b122f9fb29c55fedde1abb6783bc42284408185e3b938f03bc150a6e753ca32f010bc82f18dbf069887897ac0b7d101603fa91827c019492a0fb43e2d988ddbde82b5eb1b6fd1f79a656dcf99532bfd5fb5b52288f1c90d24d048ec3de4c2b38d4ec5e304b41d76aeec15220da51ae673e06827021c98189a33d2fdb146d9a7948239279972956553f43a7913d509797da0300a6411ea24a14f70b08db652d4b443f9c6688092d2e54867f33a297cbd8fb27d71531650840de3b81a66aa589657d8939c8b410f6424aa5893b7d9ddc222a68be6ddbefaaa45682c0e39cdc5550e29c57004ba2b4c8f71f26ebe08b115bffbac9fd5942cdc9e96e7a56ba26f048c1f783118ea6f4a3a408314594c5fabc3153dea63f6615062a5c88dcfe64f43dacc37822337d6fb7a79373f1e22f0ceca3a58934ab82689c5c604b21af2eba01ab3fed7f97963057ecbc837bf5fbf292164c1a37e16b9f8585c09f39720d9165dcee61336590234dfe0d5add795cf14de8f689f8d183cd7a64529b9f388f5b6ff571f553b04891834a864e13c6a0bedb96250758765e3ba49877646a92cf67caf2904236caa67f375b8d6443fd90da5f791ef1197e5b3adfd958e9a6d6d436fd55d2257defd4c82a353318925214753e73b91e131aa95111b1cfec7fea85a954f4c1739fd4471a34848d973ce14855a11263f089808ea9214bf356ef299bcf6b983db2b0f30288014667054a72dc5daac8b522bbfc9aa9e22848db765e39b503dfe0a6baa430b43f290327d8aa09704f9196e0c3f6e3edd2994f66711b035d2411047998647f6caa47e4825579474b794112d0a2b53ea638b6220379d318d299d3bc1a366f27d075b217b6f7e9a344cd4dabf8befde5ac40075fb1d5634f6c4395739e938c321360b410dba3b5bc6e7a9daeb6e9095e6eba4a1a4e76e3f3ab205a6d412318d95bd905b7ed7d22e0a5e9a63d9aa4655d19a140a1841f8eca4aaa9406ad0b4cadb461e9b51422fb3f6421d38b98c634e71aabeb86886f70a5d825355c5497129ba251911653ef401d6954e6ee46c789b738614dc0a6e8c672ae041c3952309c80f5291a4a1a3acd1202eb5db13b17ba80f2a50eada64750b192ff9e041d463c84606f5b1c111dcf788ffb3df7ae61a2722c1582ec8273b336295dbe49e58266c52cbd4a3675022daef68f3a6eb269abe6bc6638c519d7a2006df0767ac1e97465f5567b197d5b20a5a9c930de34f94f79cd5ce9e6fc080773409f8008dd7dd7bb4e75c7d17b892a3971d5410adcdc96b4f62a319de5e119a1d64a8b8bb8c6c8b92a84e86a81dbd716e0b95fe4799efdd2c64396dfab331545699c08192cb4ce427750d4351d31b2f75162cdf66a6d91ce8119a75cc88fdd45899f171b7b4c8fc78d7d0d20e822373e43e4d8dcb223daa361f19d3ae24c39b9b83ca730d32e37005cab82b9ce6cdee9d736cd291cf83fb5c96fc81b72145fe1fbf235850d0614743bdbde8f519577aa381be85eafe9ed6ffa291f00227e9da8d4bb0db337a3e80e8519381eecf21c1ea84bfff8197426530936cd2b03fec8f7c24f7ee9710f066086f8240937f2aaaa2ef70fe9e3704dbb73929cda556c1eb5170fe39c2430d6203c5a0c44c6faad806b7a01be1df4bb5663f97f32e4825cacdb9a191ee0452fc70c6b0fe8b3305ee454ce3c04017b6cee04fc8502ec882143068b10aaf6707792ad97728c59abc9e53a0245f27ce95d4ad82f2f279ba3bea9aeb388d2535507c41f5c525f5845d853fb67a660a620f108cfe86229710b0644726dece9e681539b2600140e7505db4a68404aca088a51897fe1af3cdf5ac697ee486832a7df5aad42a66d8bb384b7446681bb3aa1a1d545f4de5786335151a46dd3a694f59dee9e0cc36ad22440e71208deaabf8730f77be3bdc9994630208d33e2ace01e1c720af9e49c1ae788b355e5c4d2dfb692ca220fe2e6fb3fd76bacc4b7338db55a48fd20000e04515170eb69e5860ad3c4b8e3fc2f71a20b6aacf2ac0b1c297c3a346deebdc0fbe2c33b150908e2a188f2b0caaf12d5c29bd21485857eaf5ee14bcf246f5d2da1af70bd71b591357b435aafe7f8449d57dfae03ebbd5264d342b5ca7ed0c0bc0f9a3b4d76fa4f6bb36ba99db3fe8427bb2852bc54af99c6c75660fe14cbd1eca96abd640cbbc627832458d6fdbf3c85290f9c3a2fad4cc4823a7f1efb1af50898172b983f92f2f95344f6bf17884e4f313c353711be2faf511801a90c648b7df531aed6f0127682fe08e3e7cb298416b0a47b7fbdda5d15db7036dc4ac10b67b75ca63189849b0b684ab7f897557f9ad4ee00015ed18575f6d7c4fb88cb7db4c5f49f12941f2e47ede544dc4dd5473d1123c134db31b928cfbd819ef65b5b1ff9e7270b5922bebfb1cbcee8112376de9885d58617e0f7c3d6718bcdc984e59e1e532c7ffd713293926e5bedc33753d09a46c22810f54e7dfc6fc6402bdab76261d7a511e67daeb185490d077f33332176f693c9473b9e8965fe15a0b40ec20151d0d58ac4ae82ce9382e0a103b5c9290421c86ed1d724018acae3afd899e0b90d71269f35cc568c85a9f084fdd1f03fdb375f073b8da140596d68cdd9adcf7a00746982e1a9cbd72d7e33d34b165fd936b167d84302142b04e1c211e4ed95192728687272fc57a5363cde03dc501dec28f307cd6e44acec8e5d81732241bd913d383ac26faa6d025e90dde5a23d04a6ba13d07c3cc6af64d6f0c300cdd960caec3e81c9bb3f552c1c36dbd536ebf5980654d754a7de4820ad3fd88f57ac5bac86ae71c488f5e3294514de0fb93d4dfc5417a68b6f299009d4612f677522dd8dfbacde89f5e0800d8220f5fe0a12ab02e354d4a1c7f41b9df4ec0e201a91c6b74dfbda779fc130c216d3bee1270e705856929d94ac73a777adb1d53b92449024b84cc774f7ccfb4e466b74ef7d4e5512985de020ceddf77b4f9a7430379d80a2b3f04ad0e457c9fbffe086f68220e00ebb449f229aa73268e6f7b2b960e876251fded2de595374a72db3f5e7b895ba25ebb1e7a4e33e61a7464ec9eba0e9df44725c074371f558aedc558c1e13cd9a5bcc44781895d213d2c8a3580e80df0292b259484c72385781c6da4eab1a70f5d500c4a94d6fc7c35c2763c3cccbbada7eea93eadc79eeadaeb5f977106024839b0f7d767048cd4e89bbac12ea6e3227a7ed58f6106d8e00a3e6db5eac10ce06d1d07e104d2b06345b2a9e75d2d3261c5d6ffec689a08ccc2b85f5a54b489f164629f451113f93a2a8bc75a3c03f21c082ce6e80ddb2cf907c5fdcd95e2ffc6927c8d5c053150b1797235fd7fd1065da3bb48d7946b495ac801048b2a526d53d84fb0b4505d5dda414cf0d1af74550b76126a175829dc96e760544be31145161164e58809835e5496bce30ef41ada641cb367958fd87e8106e7103fe8cf81e3e58e9dbc2701846a1b0d05e14afb958630dacca34bc4c56149e723a8e898af1ccc15225af5d8679ca508105e1aeb249aa4076313b577818d3bc4a18c06e25599829cfa441806244e744b1fea669df36ff80b436da6f968455531aa032d4ba67f71234612a96470d1eec3dc9a586351c7af3be8197dc97fdb14aa6d062f5e0c77859b236d0785a1dbd47f2df7c6bec1ef17e7f3e35947142bfa429abe5440abc2847c44e49e2bfc0e2f6652d18a04bdd6dd22b6b4ce4e12647efbfa96f149f34c94a41abecdc65f1e427aee13bbfc5b6e118c095db36e54b3f406edf963d5a29164503fb7524f698f4abf7bb00841ef07eac2ad5a6f8756469045d203aeae0bbf50c683cc83b3c7fbcdfeec5a493387513f23f685735fdc2be2d7d5d5d420787c9a6c8cc99c9227250e146c20e77efe6e748d2c718d41456d798cf8993a1010c84ea849b872d7823cd8b2eadc6c5341f0497c70a771a703b66750bc6a8d6ee46778d8509f0e934b6fcd1da84c597458076e68b94ad6dd53a7322a297a337168d25db5b4ae4fd6f7245fbf28bfb3e8c0f8158619c2094aeab13567271543c09e4347f772fbe197c08f5835dad5b2aad1311e2f548f6f8e53051a7a17e7c646d06f8509c19e86ecf850c03005dd74ac62cbafc7ed5f10a6f4ddfd9f6f991bb154c6e9bf2945699c0a4b941b6926cf3a04a3775d699cdd77fed8ee332c1cbbc2fffd4582b04853f30002b7a6e82dcb5ba9afd40bbfccbb4e73675f79e1953b74930eb4042b8837c60c93ea9d429fee7762824cdf559b6008be8b684a3d0480ef7afd701a34205820e7e866814047b650c1d692b201bf0db4dfe04edc55364311bd97ad1c2ca830ad2aa86ae6b7503c1d88a58ed7b059a61c11a46d89c98ed729947545ab412db320d1a00a41e62b5f3a90e208a2da0a985d7dd9f744aaa71a35a1cb7664e06054aa842dff988d0a269727771c917b0245b89f25b96bfa48210fcf46b35b3471624e33ebe1a942adff88e5d3d38d95c35053adcdf256878dd3218ceed5c3936b02bff127acb31997e4657afd89f0c8b94067ff70a92d8484138a642db0551e6a45d871325673887e13f5bdc1f7149ce3b865fee9bcb4ef37b4c290abb7daa1ef31667456dad0b2548b54a8b02f1befb93dccf5fda55e5c4e527cccd3b548bf6ab222b5ee100aab83cf41f770c2f18657ce78dc8bf485706f9e498f66bdf737482a110366a3462d9cc1172b33a8b7833ce272ff3f1f09b4a115e8dc2fe5151f73ccb82dbfe9b6128b8cb81f0bf106006ba17aca790ec86f5e640494a02e5e75ea77405b8d080fc685ecbf433fe8ae08cb27797ad630f244ccabb690e183495ee2c2c178e3996fc6dabdb9d4cd9c2b13633e6da1ec83b3732e60d0883951828d37b1038b514a377a9e29fb0fe630cafe7848b8b7ee0ac7edd40a9d34410351f74e6989b6736f5278b3eba728ff0a1b8d0be4467fb6de9496d9d5390fad049dfb08b45a37bfe97e2e415fcf187554d49c2d8c559375435ff1d3475b7a20f75667bc954b944abfc26db5a271a2940191f6870b50045cc748892be72e064994fb12fdcdb3e12f43345cbed346904c4eacdf1e443090ce9eaaa50d2e5b4abc8f1ae357a62610f960b30cac78228a30ada2a8d38cd65898b83dd4389514675360a1956d77fe2ca7e0555421bf8906c5a458861e3629468acec37451a5c6271e558108e477cd0d439bd9e152bee31a1edd107687917342d39a25e558bccec6cba790447b3374ffd3469f1ecd634feba4d88ed3bfcf96a391026668bc0361f5d44d119204eee00c646754906a212a1f4e5642e7705297ef7f8e7dc3d3a953fdfedcd677f05c95a6b51f8a30a17c5fe47d7dcc365f9c96b0e12b43f760e8e146a4853edaf673689fa399671ac80c44e2738c166a717298eeeecd70c99d69f3e15f1ca12cbd338bf2fa5befd935cabfc2f71f06d9d5c33fc02be4f033a6ea565ce363ccc1f856cba0c035ffa93f4120f4b52119f10227796aca46a93d8ca9e2084e92fd4d1da31ba2fadd6dae4bafc2fef96b6d03bdb8bf1030ebb13732fcad043a2510cc05d9557bcb32083535ac31c8230778b4b95cc443652296cf8f7a9549282f08f122bd164fb03f9af8ecec36b9df0b6fb05287463482e4f0de88aac044f53e477e7a9c2120fc3ba04d5d1f50c075dae2c4f18962883d9a2aa155c43f0e3f00e235722b93cadb14a1d0badc4064b5e8f4fd93def372c825e848afb8bdd8832b82c66732804881716c3809e8342ca12fde1924d3791e9eff2ba9c05517d399eedb4e679bc0a45223069483b32cb2a6b5a87c99d7f3d29dea9f171600f94db74860926e3dae904cce231578ec3bb5dc118de795d104477a4c887a06bc2bc242b53d2bf457af679bd8afa60cbf86d254ea515b25accf5c3fe7491d133d520bc08eceb5e89dffb6493c38bccd57a158de49dfb5b4ba70b989f0832315b6e6dcb09765895fb855587fa98ecfd487668f4a5dccbce4788643185c0929d08de08c692b3c115c42f1e1461c77d427e093dcf939c39215687bbbc073588eeb7e811df59d060e33a176293f8ac256e12fdf6b46064603afb9f7513ab4a0d46eebd63271914c3aae153ff05d6c2720964a6dd5218c43926a37e56aa53d06020828bb0b3084f23ab69f7c997b23396376d5d02e3bcf8b6b277cffe6f627511e7b885fc51eba028938077974afd8328478012a6da11d411ed161fceeb01256fe38acab5f6879fe2bfee34bf54e871ed3f2a7552e01b536cd6defbb9682e8cb29d0ac95ea13976e6f47146da6e550358eb2dc93c31c020fa45da74775a212f74166b62a978e119286441d3cfd5c2689cfd8332cee499628a58e614629bbf2565a4b49ba878ab4c0930343a71f9edcbf60ced8b45b16854b52fcf3e459c1ce9bc3aebd714c7524f12019545692dea767970bf464177f75b959c691237c249cfea7c7843a2f3f676b27ec20efcf0322272800ecf02a1671565dd5fb372f103b29f77e74b9061b45790f26e4edd2a548d271f9cfd67d2e1ebf4df9d507c9c73bce1f6db08daa3914b96b13218ee93d8b3627dfe850715feb396c2de47aa6b174e65a38fa329d3e6558da710ea18b8841f2309306df11c4754f5e804d0c534b24a0a563e385c0eecab3f73041874feceafcc11f2a12101c2cefa46c2d7498077b8c4e6dbed18d1d7d7799e71f78357c7bc06cc83ba60b128e78608e9948076808d66d9a6927a07bfe87e5583c5f2e8d59f76d039ca128882c31a66542b01851bd33a2f93caf006fceab77297482ba07f2fb7a5b13b115b3720d44554547f7fc4d04055c217714b21963f6121bcc49e44e2183d320891c49308280612e5d0ccf63e613e7146808982eeb4ce224fb4445176ea09110c4d7f01613d6fde25ee139b44dcdebf52d286f5166a2bfbf1a8f77115d017bbb2fa0b8ca47ff92b6316774466c487efb211017cd74085c583bf392961bac4b0f5e9864d54f4bb0ee2e6bac21798832fc3c8a0ee6181f73af6b66698311ef1bfa0d0bfcc3bf26e8674017713b2c06b0d3127e6d91116f649d9f97ad706ea5096a798e874cf544256fb3651fc0e79ce5d07dd15408201f4535fa66d5a339fe234d12cddf7f436f3fa7c91b959dd4601821bcbe7eb8a7d387b45594a5c14068e944d795887c7f6cd49c753f20d14899adc2b9f97408850bd30458e2c172f35f5a5ffc378403997e9983604e640d2ea10ab02df470eac267193142fa4025f82a2cb9e65ff79b8fdc2907b47d4d28f1a26596521524657c2051d42ee90e0c3a66dc8d69014bbfaa7497fe33e35350651d675de8be6ec988c38b792285e416bef6dafd55f314f1a4121cf6296255445e34e9f65446a4514b4fcfb25f2213abef6b5fde35a4599b65241601d21fd844daaab12e51391bd0063526328279b92923df495d601d458b7fc1b5cc9ce19c4b9933d36cfa89437659bb79d91a1f6caca7ba52446f704886ec897ff34c89328fd49859a90dee40359373b287c9ffb89fa1df5ee0ced494796bfb7e0521eac897462068268e0540ad3d7f68a4f0b907ea2ea1953c48bd3b9c85935e34eacc4fe587c88883e9f34e5b59009b7bc349e1775c426a597a7af88c3e3f378948073d8b02a3e437476ca9c0b9e0c03de20281fe5720588467a93493ece99eb0f4d494e9f1ae61fe9a31de26106649a7813c926b9cc42a8697b496f6974371658bfe2f7022e88aa960eb8d3116a1f97eb206ef6f153fea2c5e42d269e2130ff78bc0733a64ac37023f89a2befe0341dfa14e3c0ea9f0c79eb8280746a4ea99438eb481d5b581a76a81d6e9017fe0db85477805920fed1fba53dfcd6043a29972e9f580849574a44ac35987823e4b8967f9525a759de74a197bd333248df0858872e70d8b4ba5e2c0c6098bd50d735259d18b32eca574ac14ebb2ee17abd04bf21565d22f66d567855aa33ed869ed8f54a4d210aec5dfd7a420a5d431731c582938408724a4536050fed79851cdde684eee6cdaba35bdfc38e62787ecc21841206fa24303f7e5dec096cae259b30e879dbb9bbae1befdc0345767def8b58a7c846a236fb16a0f23ea820e2abc48ab5703f979d4f658f45a08fdbc131ab5f684f4605cb784b72202ee8bb45c6cea589c1ac2ac93cd34bf3480c2d37ebab2a20d5b3ac119c58549bcd6c689522df2b745193e1cba4213e04df593ae8da5960e33b664d02b0080dcf88a70c8115a1598f7273b32d66461067841989e221071239642970f261365bad4e163f3ab10b08bbc719c6c346340a022b5cdde8fa63b79a849409bb8136dd4bcf42c9264e85b404ac916e3e638bd269f4726e63e11d2e53f42eb714d45f06f5a6bd3c624dbae860f2b27cedcd4a7d1c267be599b9620c35a7087acdbc29967e3c0b4115f3cd1cc20c0f3d150c5a5c62272c61792b527dbc91c2ec96b13437f63b8a9c26eedbacb6516b428ec9308121892c0a56a329db6c2267b27a1d1369e53b7fa13b45e528c0327d970f5177f9032dc2b3d510c97c459c5cf158be573803f94c431ceb11ccd6d2178eda6652d834b0d36795ef6cef532df1ee63f470409df3043cb3bb7c301ca7c6d08e74925790d7ddad4eccd7c60b8acb411aa2a654e4fa90728d77436f92915c6b25698a2f706173430ddc8a53670d6d49f9f04773b81141d941c4e214c3fa4432d1ad31db7728a73fb858c4fbd29cfa11d0295c454b71da07196195d90429a15091a1e5ce27c0376d0abbb68bf9503c43e95ee9a973aabdca4d7d0f62772bf6d74038414778c6c5c6a55273c4509f5085194a17d71bbd5c60c7b92c9e1a87034a9ff4493160719aee64f7ceef25ded8d83b1c003c94246e1b0e30325fa9b3ced06e176c8cbe164dd9a65bf947ec84612dc5842f5cd7d418b3ce277e1dba2d2de5ad7b0c4fb7f0c6a76a6c066da41b78aabae0a5325060dd3ce53e32e9af5011514e06bd9c1e48d283717bd36391d7184456ede8eccd2ec2ac584f69e6c5f0047c97cf7c7c01a73f72c5594c1c77b30c9c8d039d0f0ba5998fccd73a6b48f9a7fe07e135403e88e8d26adfd8b06ccfc9700b1b7e851343c5f8c6247d1d9b92fc90abe11e514f56e22f2c2677427f5d26218cfb12863a788b4baed74f08c8f3bcdb07b92730b44301522aa4aa1ba1b50faf597e14c97baca11d3dcbe8b5fa61e7d2971c1326a4f33443a90fd954c4860c4ecaf1611e7c50c5c0ca9ecf9cb4b1e14f3d8564b77291d43f84cd8b0b84e46f9d97f7539422790aee4ac9101472b3219f6a1b1e5cf5a8d96a4879f81b9b93c2457671059f072b5ab05e8b3bec795deb0f9cf99e028079ae0eaed0c479edea84ed3ec22e4e0a912e60645ee639d568f982b0d1a8e95dbbb21572fba17dfd7be3795a4714ad9ee54cf482efbdfdb3581c00147b149a4b919bf953c179af42accdb8f6c29cf57dedea68c91f2a3ab599fc20977b0f01740424e3229bbde2ccdc4094b9929987c83c47b300d70d96517ce56f7dd10bffd335b3f99ef166b67db7c49c7c7afc90018e589c35ac2e43cdc8d7275234d6f170ec2984b1ef08de8aa24a7a96ea7b5b199c6e89929c35ecfede87251b77c86686f0965f0a518ad05545aca4f0fdf72af6d548fa78e484aef1e01fe8fd15303f83997f1339b7ccdd478d81c6bb4b3ed020f096b46650c8af3c3e81ce91c9b1011f8b66f9942d46dd7316411b8dcef0d849c062a98907b674441ceb3c47ccd74ac363354659f6f3d1fbe4f55df3f95752fc73836fad5dde83b529e73aee00b8ae46da1a708c988ce8e682ab6a714c34b785354597612d8ac6c4e8c564aaab0f568ddd6cffbb251b20c79fbd0e2767940ca720e577d72f3b7b497f838e8f3e745259713a12c6255ad101d52e7a3f478d9ad754bd91835fa253026882e6968fbefe96b47f8447fe20ce54b6b79abe6953eddf4bdf17d050fa7a65cf511ba682f9f5749bb06907b88ecffd82613c9b64811c6fb5f2c84d0a53d2a9e00de24eeb55d3b24fa98d84ee5f078e1f32b768f574624e57f80e92372b1bac9ee442d1515c099be6028f39a5bc6d7a6d1484b67badbf3ed63b885f1a03fd3566e1dbd4b77d72b793245311048acb09bb1caa35dc0dfac46b4d638846d66274337f26ef8aae3480d3f7e7f1242321408ec629045ce381fbadc7fc189861edaef789523885766eccec83cf86ed1cf7f21030ca5c2246e3f050e9ba1986743e199897f86af5696d1db53f504d11dd0fbd4dd1b3b96e3b34982d73d59028063812718d3350385b1c7a4490473fd43aab2a07d61bf811473d8e61668a8935a6cd80cd0afbc39710ea4bd24d117cb2e25354f4b5b3b25fab3a1b4f695e2b03cd4f8889b514729231628f6624b6f0493b042540347fd025e641ae434a11ecb3cdc3790ea39a913ba5f84521f5ba0a56028dda94b1ca7e23c7378cd68ad5aaa9abf4ba9ef16fbf10800d6f501218e21c6921d588ca2bb76c507a3cbbcb4752b144488fa98abc7ec24f96935726486251b34942131763fa5fe13106cd12e8b5977eb14e6439bcfb1a26a4a2814c6951704f5051067afb93da630f1651ebcc7eab3952b0c8c6af44d4d8f833b96ddce381d9ceafffe6e4bbbd671a5c0aa6ffdbb85d616b7e846791ab64c2be3cb1e3e3637b254763208ea58a45fc7a43c0503f4821b8636202957a558f6331c117930c0cf2b9b1fd8db1b4e2f9f640d1d5d3db72c08190b46263c8cad25f6ecd08060da60d6628bc4d3dc228f035184a322777b0045f99de4f79478beddf43dce95d672f9467712680482a13d985f1a2c3dd490c2ff5b58d4e50155e890818b4f36a1356b4b3371e9dbb6cd221c375e522be0bebf3eed82cb19356e077ab50191b7162b0a023b602b3faa6e2b64247277d2a06409dcfa850d1b53ca90b7c4d7d1e69e34c5d2b0fa5b0c200c71310bd8d59d3533b5d9fb0635035d0e79d84e16ab0532dc69bd82de8b550eac2d846aa7c5da83de512ec8b4cbd2d358b29255c7d043fdcc6ad9b028a9962be5e52bc593fae60bf49a342d49af3d560ace0279cc1a9717cd6caeb5e747cc97be6578d165730b88da26455c6654e96136f56ec983f6ea22b9335e28aad4ec1a3bb76670c25ca43c83f0edcb76f21ab417aefe84136a77ffaf22be1b9c5100a0d3238c308709f79eb9b91b37b5423869833fcc212cd268712c1230dfa5d14c1eb846f025d82d5c4d56e3660a97dda71d850155e157aba0f000bdb1340ba0b8753fcbd360f53383138ca4fa9be9127db90c4d6a998767ae4cb7b3539a7ea78576824a6b772d0c67d0da2064a99a25afe4fa212e194f10c98c1071bd1bda88f331e7d07f2858b7076368b3d5037a18c3443e7b02544b211f3976531e81ffcfac0bed7f09719c6779c4dbb0cbfcf0e6a054040d412420da5e8e42c5ae18f9d283510ee198142261226fb02647eb37560dba93f83ae615afd9b494427205dabb35ef04755c47a7981e762f1272ca67633d79338a263e6ec6788aa01d05e8b7b14e1c00adfc67d6693b99c7fb150053bbdb34cac069a43225b2999b17dffcef94e55893fb43cede21bea82166f486def58bc610c3adecab893683533e3d7024e2517ba69d859c6bce33ccbb6f71246d91bccbd266fed28048697403b1d739522d80686f7ccc30d22ec078c5801fcdff0b5238aacec1c411140f0a41e8536c3cae33e7416b92b12873d87c60a7f9f2828b685b3acdeea0818eaed914235f4f7fa63acfbd91304780dd2a6939ed07b1bdfb62e11401a78d86249915793e50d79a1bf67cec6a5fb31f5147f2324832df11f9afab4baac9abcbed976eef4839c57fbdf1285b73733d4df7e7fb088c75eb8f21af122424ba78911445166e5aaa642a0b5e9d42ab6a006f7abea7a1f1555988784811c7f8f554c1f0a01587cf70f377fad6c8ce5f22ad0406577378e8a9aa570263adfc03317362f086376d4cbedef545540f360553ea97e2fc7290e5d7707a3b6af98c886b4fe5e4dbf2500b6ce96beb0cb4b5f6e06fded4fdcdd1e02326","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
