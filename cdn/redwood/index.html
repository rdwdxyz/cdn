<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"abf315c85cff83e0a9c8bbb42344195c691bd9e785a1e8373b0c85b8f4c32db4a0650b8922de9519608f07c89f4f427dc80f8b3d2acd264b27c9835a87d3129e027578c9b6cd790f901fedfac37d46ae332dd715365d7d5f14b232ac98e8ae90c458ab070d97d93360b2ad9cb90f0fbeff06f25a88cbf6448fabfd686f7bf65117279141c208df2f984815cd4a0cf98730272739d41ba4a171577fa7d1ea7fed5ba180632c4b91c22d453ddedd583f8f5a62c4796e1f0e406f628e8e97af91b9cca770419e6f689becea843854ec262fcebf42fe901281ec27feb0daddf7fabcfe4a1de249592a8218d5d0e949475f6363a891ddc4f9dcd3c11e4debe5217956ff896b668706340f9faefa6726ec1dc38261024a9e8be6f044879cf41383a8309e53c1589ada098b473673874330109a4d59d68cd6992074ce309d6607665a034c0d0cd74f514572e2d970d47101b41ebc97bbaa1e4a3c580597e7959a1aa252f353cbcfe8a849645e193a898c3d1e2a6c1e97da915525e731e0059776423e11991871a3150774cb7b1c72664445441ed853ef07903d876aa9867cbc7b4d489ed2f9bbc02628266a25ccfee62122c7d0dfc00830922af148ddca1da33a535795a542ae50078c36b95c74c5b04c76e0c1305c5a018ca4663ca2a94d1690c25cc40dd6b4fa01675edae147bdf5bec32c3564a4ac88686bea72b37813b4bb06aadb2c8cee59b36cfcdea669bf52e31ceb83fdbfca93b9593020e3bc23125c9be782eb2da45616ab29f64809113d8b2764db6e9ec38f1388a5debae1cd7e1c3238ba84db74a775ead506b1b6f3bbe4ae4df9d7eba0aa00e8909d76d7352192138560eec7c518d366473aa3a59d0c56cbc13b46a9c9d3327dd9b20c1d223a7f27488f0205b822f54e42462b35e804393644a07dcf6916537be75c15d2d5b0fdf029f8a5ab0e2f70d7a19fd0a810cba61517b4de6844b84448b99a82da1d6baa0bccab41e2467ac69e8cff4e2137632c96d8a8b95b7fd9c113c003967517347be48b4e96a23314ac757683e5eb4ef1de7aee6977841a6b5316cfd6a8842a351b3ae072c16412c30fed2138a9410502c8fdd47cec72b1371b238a51df19e2913fd9e1afbb7bedbc9a926d5c86cd5c9031d351a994b9c861dfb0306fc6640751f1f15c704a60ebbd9cc32c86f944086fb87b607e310316b30a9c5135aa8295174f798768a0e350c813d80e2279712525f19a79d45ab44f615f2d6fad1836e0bc56259f627cbe4cad4bad7b6a4a901aa3c379c06819385ee65b3b86a15158537fb77a97e520073b9066fd0586cb5a8fbc64c0922983083eb5d0cf7481242fe516374ecdb09c5ce2ee95dc128fdd6b5b247b5d7bf9eea2e0fa39a19b6be2e9bb8098beed064d3fe72cc2fd79943bc51ff7cfd1e00e8c1c69d6856a3c105e296471cb346356c44e3b5da20b273151b8ba14f5257da7cdb51078c754d48dd6b395b115b39a0ef683c71f2203259e0b19f775aa9f3db6df197627b9cc1e08967acad29e0e6c9f053a565f9515b9f85e918a07ae5861887e016417355b30f42eb752608690d92dc7dcbc3101b71148f49a6f430ea1b7695e2d100a1f6fbabdd26dd3bc990ee308bb8dd7cd3fd4f9b044a88b682ccd59e217e9607d7483b1f6a588816977e8ac045debcc6eb93ed4cf00e46e449785c13fd713e34b985c6b30ad195aef104200e85a91415ec21ee12896d25a96e466a998b19d7d0184d6db947d5b040aa317a35eb0b507be332f4e408f58abd902424fb53881fd5b87da1353910b700a4384aee80f8ceba95ab87adae515762caf8acbc61c954858e3f34450046f46f27cae68f717e3d9aaf9b44e913eeb9ab39a1658626312bf4ed5ee32d852bf539a0a90076bb4ff5bbed3398885d8c94bbd9d4c824b940c33c8cf2b386869d0a5d26de0b29e17529d5acb2f162d22f40a257ba8af18ac6ef3b3223cfdc69073e82b03c41331fdcc77ed3290b88dd53ac14e3f9b051845ef64c64f7d471656f1cb27cc9fb3db7087d1ce8e6657aad3fd1bb8ec1ebf03fdd0a5233e8631ae7660c098be98cdd7d838ee5e1edfcc7a3f1ff77b93e57f3d40f297653f128f422b9391e059617a5e16b1549fef963be13389c5dfb437550abcd8609ff085907925a9bf415d5aa913cd42c4b5377bdba8b2377f97e8336b5bf2a91cdd992e71f940efcd22ca09dc472d30f6f1865b98112ae9ab215b198d47b5d0abd7f4d0651e44df35ffbc218da114a3c9357b00147284606359c5e7d4b26b093c51a94cc614391fb69d69572cd3e2da42318852eaa0bd67c1651087b45985f522a1d889b1d933a5090faab92d92dcd5d82ebe3971a6f4c84e1669c03c98f947ef8919fc2fe118f0ef85f7b9c242d6099a62618fe57009fc3420b31703f66b3b4bb61b93a0ebfe5cbbfa590ee55c5119eae1ad675553aacecf342d2a08ebc54e323bc60d3ee5b518bdc14731fbc4c1aa6e026efda23af3b2eada88b162802d791401d4d2d1f7f76b00ec7153caf83197a22378f3f99f37a8f96d36b751a8d2655fba0e507205f2807dd1843dc68b8172e9e66b848d1e35dce5df4ac56cadcd74bce5b74ff737ce86f033b08610c66a1d52c8ddb998396db3b09c0476ba5eba390ee607a4eff04d04856e214c9aa9d6fb1f2a67fcd102e62ddb92bf645bdf63b86ceb1d7185d0114eb084c2321668e29fbb723c0194fdedb84ea0e6b7c64149038005e44ddb6fd8743f202621731482e1bc7846662e4f93cadeebd5a02bb43b49016f66a0fe9238aadb1d258ad0a346904c4d9fccd537dc9c0d3a6b203afae74178d5e44d848d9483b3ccf8c0250d10bbd1eb1232ab924a7e9607d74d00396d0481ec33ba7d41d2de395cf7a346752a47a95e39e03e3094541e8a8c802d2ffc3a8939ddc0e3ec9df054236b1ed4e6e18f5e19181fb61efb0634ddc50206e2fceaa656ec3b8017c4b213377b90d0d2a81e36971349422741db5ab281074065f49a9bfb9fe36ca2a57d1c3ec1c1b15f3b8d9da9bd002be6aae32290ba633b720dc726a2b25d1b12fed017fcf2ac339197d1e858094dff28d0a27e1fdc822e6e48d8da98f00bf803df52df7f645518a22084854537226ed42d9d1bce18cd99bd3054e10bea12a4dd4fdcc4dd687f553c9989b2e1fd1a85443724ecdf263126f4223ffcf34a291821312e9b609ed869fefd72cabd4498a92cd484f02339c4b38b4d0d700f4c98fd0cfe1baac4d4ad5c6fd4dd7710d2f97685c5cb74e4b7a4d3af2906e91b538df6472a8d29b95dff7a3949a64b3d80a3b4b35d7378f785b176455076eb82acd7dee3be0918ce7cf09ee6f1ee8112c1bcbb1e63af14f9fcf3629080345a04e928da6901a804d9bb9ce2837b71b3980ec35a5a9f614f93b2d6244ea20cefec19d91ff923cf077bae505a73f172b1e5f3edd8a00068365b16a6a9a71031a085a653d1b32afbc1134b1f9a699366e1ed8fe59ebf4eafefc29307569314a13bd3b783481b1368ccdead3dead023f71c775d68a10ab4883170a66d27b56d2be88639ce498fc804e65e5a91550c914e00a2695176bfa0f2d8cee2944c3abfc03e975a63897dec2c22cd092c1a3f588b1517665dad6044fae0105e486001be7ed10faa88fe18453451b2b053f16870de5d1bb50c511c63e1952e9dbab955de3f3784c143a43fb0c06586e6615030228f38b71ff6961fb9c5b9f4cbdad874c400a3d97c0dd618d3d825bac7b24f8a9de8d3a1fed83dda5394e20e90c3d5a91fa050996ce32c9903470f57fbee2523ae8174c87ffc5a6302405e8ccbcd51e94fbe066ba93e099242047d29386020bde77d117b56e4e57490389bf2ede3f1486f38fb873fa56e9b87b8172fa492cf8ae3daf1f03cb143e976ef055ded2348d8fd82adf48eeec5f1d1f1dc7134f2887f7623b659f7c482d0f39638d5406986792aab4bcc95644520e2b71a89ec020f850fb0245ab6035f51ff5dd7ddbce8957ce971c2db57bdc2fb0f4a7b2bafebe21403855b2089f441bcb891d7b905b1c93afa4b746bd01ceec5f72f50c232f281ad44bda0c65ffba867dc49f48b128669ad6dda56ed97c21e13b887f13bdcfd22b8f4818c638e98cfa2475b39d19275870f36ae37e73bc2bf6f5fea57f47f9a6a9b58c5cb012fc3209c6b248c11f104167e2ce825bb6e438d13ce2108e33a6caab6991e1c844a04cd108502f08b85c41ed12865acb4b5be8545be8136f364fe60f00850eb9d92b2f79a943926a2bcad712236448b6a0e4dc2e6edd5cfbd0beaae9df93c0d533d6acfd33f38a9a683cd287bced9f8ac59e72cd0ce4df3816096f02475acbf0cc5b053ecbfa0db3544401478c1d6a4babedef168d0b0cdfabb70f920a80129ea46b7d0c26f6f3226ceae81f69814082d2f43e2868c5aa98bfbe6a7c4cd64856195e1296e9a2d8fe39a33e4cafab8e6a50d252a66c3f15ae7446d1c90f1862be0c58a27a208c59945f608d2cfa55dd4d627727710bb3baef00aa024c2ae1a897d0e8b86a13a85bdb6dc9b89d4855a6e7c7c0b4a522367e0984ed00c3f607f7f83ae2811faa81737f1ee63c9f2a8bccf7f91d653eb94dcf727d6a1f773876b56b01f3c5028cb254de46dec832c6218af007babf27fc1c9ed46be081087c12c8d193bdfd388b27bd0a61fdccb4fe874a0a86d0a1249a3ddf1df340e5565bb1822cdd4708f6b50b575a19b58444618109459f4684905d2854afeaa7826319daab3b1186076aada510e8e84d72d845332c3493c8ba5c6d655a5015db1d3d3f17ec605690f28d212bce979f4112de3c188dd88acf195942faee9fcf87efa2f6d358bdb1915b4a95f2de0778df31f80541f5678f2d7a7f1b04551f6c96bc733ca8e800723d9712ee105e0806a41f48ab1c68a3213e0b87691e911123eb8b1c53338e73e447978da4866eae319abc89331fd42dec4057b40c7fee9c790a872e076cac447fc94b2f02e5abbef26bef232f0d25fecf1dc76530c11a42e872c71efd64ca0cac5b598a4466a19695db44756cd603fc115b79fb06c369d59ff93ba52a87d4e3495aa2ea7d9c7ea5f76dcfb9a32d29846db7504ec38254ee1d201fc0c30f2230a5d894f9bb095396199cace7069667f3670307498e6bdcf6dfa8cac1d485691329e27368935fbd0c77af2696f59a319d385200d05940c36d03f337bdd1fafcae458eefd0eca329494dc95db2653d0e089cc5b2ba6bf6be912273f5fc0d355e5894dcce8faca7d1ef7b96546d8ee79154e83b374a8329860ad46e81879314ce925648f16928b2fe44a88c451dbd11c688921e4b76f1991a70c7ec05b5f0c7c6d7a6d30c3953cf5415db44deb1cb45ffe86a98100c8c2df133fa8bb33db73fad312dcf6bad4a085bc8f85a392fe920599aae2444dff31c4d9c94ce9a36a410af57f6c9246aeef699a6f9fcee81e77c07c86afe8d9333bdac5eb75b044a7f64a774145e684ec09554eb3ddc33f3de5e2ba6259a0a9f63ae6da458e774cdcf25ef8c7d0131db1a84b69f103231549690ead27a8a6f863f92d04c3fb47ecbd1eb42f9ed75f947f1858341c4b8ee9f354e4b8ce5da1e72242eed6f3278eec7f9e54a30e151c91abfa6e8426192a3d45857ed3727e7a8c6b252f6c55e2425b47ba6a550d60bdcf105d5b60f3b01775b69a4b7d987bbacb0bbda8ae4a25221bcabec6a56e5639ee417e9740a3345c499d63fae1c138ecd7446490012012e988affd0029f67f45598a46483d9e3d7f47c1073981f7031a5f99ba2d5e6e6270f7661829bcb544759dffe456bc7acb862dea1ed433082f27fe42598dbf2d2982e1633b665d4441c57350d047cc88a1e795894dc136c408bcac1878dcb093c59ad520dfd0086297a272ee7a74d8e9527337a35082925319527954fba6ff496ee204a1b26d8a4f0bd1e8842f27c34582547fa81a93946347771e81a2cb2bd6e4f7d30d5e0eb07721e7b36e87172c961804ab7c0f6f7f1fa20eaeffa7c09f17cf2c84e0c672fa414124562855e9e7f90d494732b229c4a16186cd191dba01f64ff47f7294dca77a6b30f1173b6e6d6ca4dceb66de65864d8879b5abb3c060805105882a2d317e887a0c45d9840b8dd0d94e88867864bc172076e6a2817c8db0af16b0f53feaa9cea1cda30b75a4a5949912ec553c16e2820ad06c6bdd109cb8ebe20127623dd44e64eced5199dd226489e8eb674150875f3de3619ad88f976925474bbbc9e3d809a432fac59294eeec7c80db7c9bf1349d03a987ea0fcf1af178b89d3d30e5728cce46d295177f4895e401437dc6c7b040e073587e5892edd8c7113bda402aba93ea83b1d0b51a5fcc1bcf3726745076f180a469192eca19e344f53712169726ec975bdadc20d44eea2aba4feb578e7393b3e785dacb2458a31758d163cbc67190c1645d11a8379f15128bb91e2890f5a55318f0772244a7c096bf6306749815ac80e97d5e26ed7319f5cd98d9c50e49f8986ed0e67fdb17a6067f780b779723f8dfef8041d5fbe27f0069f0fd8132b4c9e37e7ec8c314a8e8768750c750dd3dd7cba8ff7eba3d0b4a5ca6ab898cb23be593087a2fc9d84976c31b91ea78c3a986475503cdd10161d501d816561109f5f6cee06223bc3b5d28b17c40250db316da253d31da3316487ea43c1cda28d77169425669149ea5882a26998b567910578166f1d0607e4dbb5e37ebe59ecf1fe0a80f7233a1d0b23c68e3477b1b6aec64f17d6f1ea55e516af99ace18fe8a16b2d72d6e0222c4b91483950a371fd92e3a2becdd22f9a11e89f7cd37ec6591d327fc99af72968a952f3a54e7deb5b3999d8ad456cc41c1f30ce0444184b3a52891eabcabf743fcdb43e3e02a8753ee001492da1b6cab95c6da2574342f199c8bcd39dda2af95bf33146f9ef14528af93430a21db6ca1330b6a436f667e9eeb270a480d54c4fd3e22c039c5e682e2eb728473102710baf482b543dada719e3f861e87bf46f25a1b6eb047345ec73e0796658d1d320a356f54935ecf988b4656b50e0f9f594d443db2fe02125214431508aa2f7fbe21fc5cf0c39ad91c61a2cc5926345b59bd65c0341c9cd702abae70c821b94eb760d943cc2ed4f5c9f7d052f1857fbb1b4f44a079ac2d0a944bf788e1a30c079d2c112c7003b6085d03c9ca42d9746f0009b8596502773fae820f7e1a9f4641d77491c992c7ecb4bb8aa9f20968585d22028d7c06e3294b2938bb6a7d644b7b77c41a2c8c41beb137188005b76016507631b91bf672c747c95f34a25549d7db3df7850db9d6d391c57b2d2577d8f810821aaf15dcbb9ed4aa90d210308c83691486e47e978c2a67c72d6d65aece2a864936d0686acf60cbbaa352d4a4cb9700341be9e13f5444f49ece6e8871b37a2017dc86d6c420fc39e67fadc718cc8ef8e476759507dc158c64129c31626af5fb0b7d642c8c854cf33ea69118ace2a403347ee31d3e469b0532407a2b212dc29dc9c2fbf5f3b62ff1131cb449db7f0853d8e8f985a4db9617e0f85ce1612cc5e4b1b90c7d721e4ed6132fd23c494bbc2950c7f9fbfb8a132e607244210ba154137ebc86b118ebf45a7a1801a18ee138b4c4343d1e9292ad8e868d2197a185aa8e14461b206238426b746b78549cb86ac5becba6fdc4ea228f692070914f01c86a1fa433d6ec15c6b2e1a500efc34dd207a8871e14b31b7072749409694e8cc0e1121b4d2e51b493299b4105d3a93b9f8a819c2734a74b843e18e4a4b77934ed5da6e8dfc19e5c68d320d88379f1bec8bb30cb36ac8f70f0f6983389f01435f90daeff29a18d6bcbcaebedf3ec449c85738c4a9b14b3a41a5fd778f5ae226a7e45fb990d76c07362246a11b24264a9052db711795d345c73e450da87fb0b4b3c8c12ec9671af4a3d66f95c8502ce6c8dc8d88d35ab86c2f8c7fe4c7294580b219db6658fb21ff9bec6fd86dfc6798658c54b5db80f0a31363450024cd607203349160fda387e9890ab6959696486f108136752259ff4df64b5c3ee36f349201c1db053a0cf6bc845be26b3833ab06231fbac827e7bf3701d7f94b67ed38d1121e68cd14424bb01e4373cfa1d59ed2f2fe44380b1980076ad42395200716e0c487bb7a1925831e87676df817b188b7072405c6a3420ceb65f2a7b06e39f34f206eedc2b3b05d4512dd0e80f67778283333482aa72f6bd9f8e210f5834bab494591dd7d56a1d7ab1bcb78093c46f784c4805855db10f5ee3193aaa030bab98e817a9b007b2f081e7459da25a85c427eae52f8f5c937ab79391134abaf548bf42617afeda4bd99ee3851ab8819369caa9e33c6d8334c54a5543788c0d05b90fbeaa8d1b60acf246738f35964bc25bd9cec1df947e9aa76ef77f33286ab33fe7da528e02dfbc20d06f565ebfddf22b9b64a5edbe14fd4b96fb0f752468a97516184f2dfeb26d096c586038323f98d02c15ac7b2bd8b70bc6235811b2385909f1ad90c4e7698c6d704cd0bfbbe4dc00932bf64a8255ccef1e66bbdd5463e5eb0cf7b407244da2570d5d9f1f5495667d23927112c5f5db16034a67ee2663d69cf19fb8f92066a2338a7ad6732abb0a76e0d8156d9545e3956e025c84cb62eb910828397c3d3cfb37412fee244abe9096174b32462b43fbd659cc6d0e8d7b1978a2fb65783517560aec77d91c7eef188b8f30a986aae9f97aa74d5acbaf1c7349ff5459d3906e8b378fec36d0df897c9bf86fb1dbdb435c967d7948ce2c51005480c8f2b29e7cd600bc1c237bf3aca6f37814e4d3c08c55a06015f7c6442634cb8f163b198a26442e1798e6f61010c6ffb88cf5887b07500cbe2cc9ed1d061926de2e1c1614d72bb107816c18bc92fa1068c82f8bd7164d694b26f05f4a71137899a7a1627557927de9c044f2d970b746ada3e2c15c764b5a7d23d568cc7e51f8c6b6acdcf03bd1aaa530c2fea66409c450ae7a68bf794d6ff6ae8818da5b570f5b86af2b0a1a4e7848c19c95b26bb76bf381e9399ee47c11bf600d204efe152f22dc1a6ade517ef8aef4e4a66f8ce0654043611b5d80d9c0bc0742f62763d978b90d99b4ad3ac52ffd9f59a60c7b842e9d0f4f910dd60b5f71c1b3456c1a10bf6c5c177d58d2c2b024e0d99f02334db042dc151cdc34173f2457791a04146eace158053f6b3dd38e7a89cdecdd05dca33446f4a8ba45414f763642828bc6dd7843f38d4380cace5fecacd7624a841d3643989772558217ca8f689f3f70ed09645b1f96f3adcd26ae313b1bf530d799216e9e208f100ca77a6b3692b326880745cb4f19adb9a0d985241aafdd4490a2adeedec5be2d9a8eb8e643e38652e875d02c3afb25c60caad8adc42b18c35656be2a279b9e2a0568f9d306db539334018d69a7303c7e154eab8443dbe6ccb5cbde2431c2feddcc04902095d54fe229e53d47cd5e61f4d0dd2d549d348cca6d5332c8cada4bce1aa8f834d89232b929569e3bf47d22293cc265f3f12b485be53e6aa34aef7bb38edbf724cd18e0789e7f2edec01b2210d76a6a5ff4e10e4bbdfe7cecde40c3874b2360fac953d8f4638f44dcf46c30a66e3dd978179dae0e222edb4fd79b7fd35bcffc594aa82825c8a00d14213dcabdc8c7af394c67fb80de7e90ebe6c9e05dbe67b0e74d88f106e9919c71fa064aeb9e4138dbabe4ae431f9a133c7c19baf9349dc583764e2d99aef742f3ea83e64f2013e59640a95074f0dfe3fbcb37471e15cc3b17787002ea1e00d61e91b289314db8f6b537040721fa989b265aa4e8e72683fc62bd4d908c56f905d984956dcf9024178fe36fbe3df52752280669b7342a5775f7e2c4f15ad920d597d43bf1bfe7f4906e6206c3cfa78c7f54188aa217678dce6f063cd2b0143d38abfe5a46d4e9b7964200a5c0a8a5e8c58887970ff03cfcc07632fc6488f0efbdb89f4c39186f72e0a78e5ba0b06e0102c8299e2dc1853f2ab1ec23cebbf56ebe9fad55699e21e7c71656932341c4d45c2b613a8b66d9d91f5bafdb31edbf70368b2d531386630dfe4acc95d2b1ef3d2558987c0771c1ab8a821504ed1a38e2a82361d9fbf4b7b4d77902d38dc14618859cc3e6052fb5800fe8dbad99f17aeb9605caa62d0208ee0f181e4aefeac2cc2948e548c663ac36a873adf70cbd7c97534a3e10ea1c8ab8b632f6ee8effc13470b051bf4b23d0a4b12f207c48f9a970d2a4232f4fb8b26e3dcca4dbc53e827e9851003fa603b0fcf4da8f352424792f420212514c7c8f353f310a01a2607d16358843281706268416b1e756c69c9c31d4a9861108845088ead48552d4f9c550d6fa05b74d457b8d206dd01faa36491a1d6cebf7d7f81f33c0ae5625b13f6e2ea20efe1d7b0c3e11d73e2661368d4bf7ac53df1bbf74eeb537f1f3419f5227e248375af15c5cde2db259f15b214b1fa60c304c3e4d37307c5d80c88ff089f7f5591938b913e9b2ec6456da7b9c7cef42eb393ad352f13ce8045b82700414402adeb04bdaaf98a401529ce37474810717d7ad47fa31a4f33766390844ab04fe9e210b632860839957a68b5ad27adc619a30dea62b1cb6e3b7aed6d9034ae6c925158ff9d5678bfdd23414b4a741b8961b064997964f01433e15987d33a05b56c6dc234d2dee3f357362b68b8c67cb9b835c9c604ac670f51b2716030558c1e831e5bda2dd0d04b542435f6700cfa87320f9209e5b53c213205a6b1ff1383e4daf579004f8844c6287c597b3bdd36d8197e2e8d2a52e139df035a033436ea1df8a6fc7c7bf70d3f009e3c38a27d088e89a92a948ac4bb3fd9efebb94d3d0b059a0ec89dd73c1c8bd337568f2ca0e47787d535d1ffdb437cb4de5609f12717fb2281fac5895bbea230d95b30923820134ec8607cd7212b5a3f0aa22da47e8b27b672d8082ed477413c3fca83d85949c8d8fc0526448502a58a10224832d9913f02c53659eeaaf0c9989851dc2ef8da70bfdd4a403208579a78a2288ad0c58e252c8897d624eb41bcfcc1253a5ad9adf818c826e60149dc61198070ca785f0eb6d2ec2bb3c58e10564b5560bd9221f82359717ccfa042ed01043921b3d399009e77aa164f8bdb0924d8035629e8bfda4641e9ecaf3373d133780adba58f43802ec8e06e0b26998beaaad5e579c760233fed0abdf06949d7f068ca251bc569029a9c42c22745609e698aded284307dc8de78fbf35a52f1280aa1c0c6ea9872b1d58ab9b9e04a5ad4f4d6afa9ad177a0cef196ccefcaf38553cd8049f5c226b47b56ce92dc8b12246dd4a9687fdb6024b89bfafd72f76dcc426f132b6afd9c0dabdba3a736114784e0b04076439ef41bf0920a0c780dcc0565baa5b6d8b9b2e27d8af3b4c3aa693d5ae54901142d22dc69ceafa580db844054330a2a06a9d57e8100038e99a3f98a19342eb81a9d09754cfb7b94d2158b6abf9d37537880e44fe60d7c65f17b46959219a86ceefecab08acffb6dca7bb84092c97ce0018b5b88fbe28db189cbe81ed2dcf3bbd4a264b1b52df79149e6c8a3ecb02f5a2d3fcf29b8a56874290d15dc1408d89bfd54377be218e31338c316e50390a3d9bf01d82a61757656f566a853bc66bbc995d1aa4f6347455ceef0a0ed1970973d87e517338f38c7e83ab0b327dbdd89ec956ef54a59932e7e00c2b7586d5bedc7ed7ab939965dad5c869b5d55fb9b572f10dffeab5dee651d4ec52fcacecb968ae02f217f9143124d82d6d7de1bf6bc55411f906e16fe64b073c22b1bb106d177923ac74abbbacf16f01a08ab5c0fd11352921ba786d7b3a114cc7b12773c595d8b3ddc679762a3beb5e3331d606bc8100a34557765e9d740db650419c03fd33868391f448b39e8757abf9c011941b4761a9f19c8c19457007e46077b318e1cadefdae472edb2e9a24e7420ddfa2b56bb3ed6cdf2ad1ae71cc9475924594a1a72028f493fa0b7949d2b7a1d68f96bb81775a349b8fcb96946a25b353971cc29257eef84f2fefdd1bb6a5bbd8c09367a7e2139dbeccef42f9fee0db7aafe2a5b789576b43ba9ce1d4f436f28d626f2301434dba9422b6f7ab595948c41ff16c5d1020684f6f3755709ff8f40ea17c2abcc33d6324b100c43f5ae3aba68bc926cc3c7e221201d9d1a789e75d6432ad37b479cb372d6db7ddf8d0f3832848183971767a3290e8697bc420f525e6d9fb08ea3d0dd0b1ca9180801d6d26f6e2257cf30e497d5f042e169a823ab05b84c3f236c5743dba24b7628554a695d6ff2b7fc01fd066f826ccdbc90f59fb7fed704a56037671865ea41a2f266bb56f93b6a359b744ada2cb684a8b20e30a62b209a22eb70b31812f99cd76539f773cf15ed833b79ebd2868dfc2b5c799115f3c0c8113ae02a8763b9793a11a0628ffbc44976eea19f60251f3c963186311b319c5a62664f64d2640fac3a336987115d7725250a36916620a12f05f9a66ef6d6bbe93e7155ef5e2efad486694e45187297d06d35da0f8ee7b08ade15bb2d4dc05672b4663c09fb3d0eb01ad8922419fec35c8b2885212d51a23c7bc29792315e7dc3e6cd63d76efa17fd36d280398955eea0302935aa32a834c193fc1ec3d956427a9d19b149523b1abe9a8f618c3b7c0f0adcce89ba68737cd5411b0b19ae217eeea9c0f02407fa23139a4b49c3cddfc89d48ed79f5717d95ccf54b38af48d7f75b348c66579fde5b692adcdcb4a2851872c6501c01340cf94214b3ac43590118ff24a9325c1b34ff200615321d211147baddda4615f292a73b895c17aa41925966cf7187cb81babe9f4c5a11ad5e14c8795d808baa50e1057d59209d781276e577662182eed0ff0ac19ac3a4a51333bdd782f6985950b38cc1c57825bb90809e42d817272f7e41eab9755077c1688e14d6b11dc8380b4ab2384032a20199dcb4d7d7cb7cf957de2da59b05653212d33467547e574f50a3c6c9c4148cab5ff37accda4c8fe807fb63e929145775a58b614e94fb4f1ee4ed8caa5f55f8b65ec342bc2b153c7c13631706b749d78c8d64fd75ba3dedecb3692ab70baef8b0c7f1082c2f086a9a0ee28553c96e6b2d21e418a08c68df6fd6d8b6ada307ec342058d73fdc582bed112fdcdcb141ff20ec301ccef7952e246b80baf502379e8fd26fab8fe20896fcbb79a9ac1e95e454221cd7992abba33cacf5c315d175779e1cf68de9bb478531d5a29c4f7569dba32d4d0f67f859e03895e6df9d603f82db2ec40123aa334b01f35dfd8e5e0a09112cd2fed430848dfbfb6fbd36430c9f3546b5b1a8c9a47d2a95be2826fbe75b2bfa75d7091dacbed74d026e5736efc7792e370c326661c59398e71ec40e8a4c100038ae27d8901dc0f5ecc845004d61c314578af83780f93b1bc8f6eea2fc4f4f66486c3b8cec4fa641a325b248315d568a28fd16d513465c3d8e8f5003d58601fbc7409e9392b304ce1c9be3d3c6cd1f41527ee748266f070ba21c543a45d25dae41f94c06b8e6ab787ee09dd376fc2db660ca65977cc29d1c072f8255e36fb5beffd7c93f3b16eecf7a0a2c50ac69d49c95c2cb839e6d9676cc77f5003b686461191d18e1bee67bda52440ed747412fb18b700dabf53a9736cf79f2294cb50cfbead928e69a73d08f6c1fbbad559b76646604bc87e81c7f43ed751038872bc2917b5fd44fde508a8aa5271deea821633bedae7fadc301aacaf82d1142b3aa7c6a39890270e4e4a2fc0b3469dc56be8c953faebf3d8beaa39e881e920fd4f98380f776b48f87bb220416d50b727e0b95e80aa93cebfb493c7ac3b5401d26838769981f439d988a05d2d75c808f77fff43731ed0cd93659a0859818af3aa1697d09a283c6dd9463f2f78075f11c55877c18473a95b9597e71cb2e9206b5a557c3197e3862cde7d467f964337de20dd21dc8bf5337ce8788bf6e5524258417c9408d93c124149e1482f94619e241b896927d702ff44b63b20f66fa4d712101c27dd18e2edd504a84210eb7a060587cd4c7bfe0d8d43816d8391e774f6a6fc66b1a2bf693611c64427e6e4210afedbc9c932772ff91bd049063c5da93ac08a6d97431cf26a733fc674fffdaf69a4c0b88efc498aa8146a6d373cd5705764bab3614e8afd7fd909e5935fb828c851bac17cdb45f6b7ac1b7cf0e7bc9f9d469331175a6e1af0a0d64b59202826ec09a4443b22adc8054ec620414190f6462e5bf3e328908c5517505f3b660e01b01e5f13969c33ac375a16e70b915143886f44569d4faba9485ba499ef4d4264b96ab610bdf0c5d08ecc15fcc159b39117d656da40477449bc10ecd49ad50a25bf07fe9ce629f9a9d89562702956a006900e1b86a4bade637c39de655febf4233e5d2c160d3397cf128cb561c2002f6bfa997987bfb739857ec82dd14cd35105cb03883220a83c00caedaf28fcace53a292935744e12d6603ec6b8b301fd195107e4c4f9ac3a55fb995a7a1a612d28713f23a3758332fd3ef224a849a49ada5b1141bf21e8ddd8a5338dd680e2f1c483c17a9aa82f450b6ae02e12eaeeec4e1fabfa5c45394d48185532720c4756855c496ef5841b8cd0d501c05f00884a5d4a74ce2bce8ed82ea3c8cf460be726ee95b0aee7674e8fae411691cee67e17092b40876219f909d69b5672ed98d534f5a1329282308c5203cbd482f5a8986ccd385659c22cf9ee2ab9eb85b8b58734a583a7bbf66283e790c4618a2e3bcfec49d4a84c63d6b6e2a1ce9135cbd42830275beea1b6cb78c1310e69baa002aee4ddd5cd4fbb6d340b0ea63971e88cf9d12a44445f915e29b2877d997dc7cb25ccbb744e320529bc0c60a219985ad675e576014b64e482447612eef46cbf013c357cabd6a4078812bbc21771893ecd6174ad82c2fb9d9ba1c7f106e7dd073760e96c94ed76eb47946d2de81078365f23810722ad1645881adfb87506d5c69a9178e53881754f82253d69a1a49a72b07f30af5717bc0b841bed8889fa8990747a94a91cfb3f0eaa3aec9f3ed45e6f2a010659e26af295ae0001718b7f8d9d9af1e9778e4240505856f2483d4bd73c87464e54d6f4c9f846e14c5bf9947de990a88c7c2cf0ba0e2eac15316a9d61036a826e84c3383d3f1a853f80dcf668463742cbae328ef2ed11c476176ec98b83a4af83f2650f54e862d53658be26c235d1212b5aedaf9ba172bcf2772d0415ed24522c674c2aa66ba5e270044e44d492f224efdf521766328af9446430df1bf454c8e25ba272bdb908996c383bcb6723fe96a9b7d94bae32bc7e42ccb88fb6b90c4c5a96fb870f5a97ea55387b37f6eb1d3079513308e147dde43b7970e83d7e4d53930c7a61133bad9157afc6a0180ffc79d9b59d88ccccacc2daefe0522f8722b10a7d79f8cf6cd04527b7e0d85fe1b1464293f90d7bb426710621f3b144bafe085d56d70ec48f666c0ad60976a9e65bb38c9d015d97059b2618f830cee543b109b00f9ed1655e203007906c6287c5a965282248f97f6fc5ae805f478a794c37b57af5dfc334da295e040454160fb27466f1c1d8165666b164782cbd147b6902c952a40a7046d26d8520acfe050cfa3799ecd00a85717ead6002ba5b2e05f52e9a6f0f447ff40a1d1b97fb426a8a3aa3e39761ecb4b453f430c21cde6c5edb3cf2d9d29f38e1b78a141e56e6ccc49da8dc5b39008557018f7d704900ef14770e1946107cbfb360ae042d7d5b98f22a5e601a93defb2121f327b0e07e84bd6c081200aaeecbbdfc658cdb17cb62540e44be2d56f5b0ff7cc835104db47e4e747a03b9160c00ca38e87d2b10275c61aded7347d82b5fc2576f55208adbc2fa4bae5a32aef51e7e4bfb530eb311349e7c24f10719e2d1737e5cb54650e2320929ca8d870cee9e506524a877bba2cb86550b7f9164f837dd432eaa978a044baac779cb7d33211392b71a3220f0219f75726a585b280fd48a7cc39d40c3776b77bfcba74e2a1c6bc9c2e8e650f8ba06cbfb888672c0e6417e4b169b9cae87da76881ce6fe5e926a3888157fc17a0ce5f7e2e28d2317879bf643afa41ad3572346945e584b5738fb4a150761c136ae9db0927d6e21daeb83d16db1ab3c6580676f6a83845eb824166c58c2d1bc2430b6831305b22ded5728b81a7624950d4cdc571abf2ab1dbd6427b4060f43f388232978941e5be3b44a6c0d8cdbcec130b03315a3c3205891c37e743c6dfbb8a135a477e41e0b133995b28e23c9500d12b09580ca2c0c0146e7f73a6e13416b4f537742bdad91b180d2bd12943768bea43fbf152d6c80da7f0dc47fc9234a7ae564ae8c5d4369ba1b0d11662e67a72db74382c53ddb8a1671a5e1ba7b54a1aac1ca2e82f84b00f005fa1cbe242c1fe7d804959b8df5a717fba771a97357a8964ee20068fa36aa7192ee563d855bab2ee3ef06d67309608eb8971bce6a255ffda019a8161cc60f1195a91b85271f64d3c51003c5f0bdb0a10e1f008c9399f85ffd4edaf7165c2a9134f39c132d02ddff2acf8e16451eaf7f15049898c7a4b5ea085c45223505805f2ba2637b244b394d593a8793e773368f3fb08a717de5b8ca8d8fe056726e9e4ccc5796691afc71ca95c931bdc795bb22af10c9cdbfe40f8cb46cd88be88614cc540df9cba677a152fc1eae799ddbaeb71e997faad6b7d3235826f13bcea4a9ea5b28159c351b2e3659f562c804a0d123bfa3f8f65273e01054ec54c4a1e6afec7159dd18b9099c6a6f8c42dd63750e23c3997b28a910c9fa4810364b0e2496d515c20a08d1abf8e9c9981c7bd7671f41502cf68a00713b324b119447c295a3a76db595223423412c2648b8b80d76f4a82b3e827f239f5cf47f0e9686edc0d8df94b147cc3a69cc8f31203eef4717f1fd6dcafb5cf0ae2d8c03d4fd39a2824ba6ee8de242073cf755eae4820dd594cd924283f1afeaa85da12f52652b4fc8ae03c74db2d69e01a3e976331652d052baf747195c72f501518528e68bb09ad43e3a63d6d14bfb6e8b76f1e38bd7d2a8811f4ddb545fbb1feee5e949024d2a2364399d957c44dfd65d6adb1e6aa9a7611f189e4a3a3d997938eb60a3acb8fd46bc7dd4d967bad7ea5339b8cff58a1d894982522fe50272d170612894db735e317d3f313a59203dbfb7ff383ccc1bb520897593de502deec4acb8195e52ebeb023156a04d5c50354006d11d87014fe2350f112ad8e65e5d6d61eeaebdd449187a7813822c96b85b868459c6a1d3f9799dea9cf43b319cba0aea7ef217dcae364c20b0cbc73dd4aaef5e446e5c3a4573477902d78ccc95d1d22326b97b91372941164881e4ccefcf79f98ece73936f494a6aabda6e146a7e37a43833ac3a30f5ef52aeac8a98c45c3472586b6fb6d2b70e3ec5ba0ca6bc30ed39b7de354cb5fc53a63294bb47881e3ea289d136bb11bd05d0796bab4522fede75d11eb88a86e21c8c87226ca033ff263b5e512fae1e98abd51da05f3cc5cfd0cb4d88307605a26f255b2e0b4bf6f2944c439ea309a1623f2f1cd194e8be1ccaca003c1da240a8bf7bde67a5a92a04b83a9483b771abc36f1dd72317ba8180555b0533b3507d34e07cf14956838be5545e5dfb28d1db2ffb43dea4935595686aabc9b77b21a61039271e890bfd5f2a733ca2c659452fd05302446c7f60cde52eb3ca888743b89aefc66b2990ee89ddb20e4c13dc6ad85f456abff4584e3631a221b93f5f8f94d296f8eb6a170398a21c259e2213543c7408c75c053b7f56df8213b79e44323fd5f9b1e5134683ccff5d55d313b553460e874ee57c47dcdeb79c93bd00a5345e4751297eb6972a6ee9accb5de528399f52aea6040f16b2b04bfda1cb7137eb41c659b93fd76801efc32e0427b8665dae7e9f6e755a89020bd90f4233c67a1cfb141219abbb3e2fe024daeac0a0c3463104fda47eaed78900743c017689789f2f654ca7eea546fa1108d4bb902043b71972ec6183afb64f05c6c3499d89104de651c383c394088b9f93b15deffdf52ab1f25bfdb70ade365b85888fe47136808953d92f49fe8ec2ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
