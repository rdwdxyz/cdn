<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6ea62ed99af98ed4fa83a74743d2f1214f94d6e3e0756fcc609162903d4f565fa4d5598c4dfb4041d341a493be83320dfe96b997e3289636e37f099b5b46608952c2f822ccb562c2e6825b198dc3e07c53c965e6fe64d698e01eeff41c82c9236bc1f49129b97bf739e1f5b4b08c5767728c381908ff760c8b28f3ce97bfa7747f64c5c83ea788cb4a10a33ed200e49786ca048b0586bf19d033748d1deedd484b663797542b61a023edd98f0aa5b46c941396eb5a76167f41e954817237c2245a8e7ebcf28782bb3d811db0e4fe3cbfbefd78c6a06021eca1b3800141674d886b233d0f8da9731b9104064dac9311dab2693b1853db189ec93faf4bff5c380569f7347afe4791b07bb02d2179ef87cce00c018bfbe5f23f7856f0af3148a8208193a0d1b8edabc1fc69424c64e63f10ed85ed2e4709d5408fd251147a4d0cea3e988b73257756e5b2373bc10c44e42eb25ac4ba4161a347da70e712d37ada759aa3b9b34a9ee46b546e07e668161d6f7c5bb8d011f744fc8ead406f319ad96374d4786e3b5434e0d6febee624b590bb68956563227a906160fdb182adffc337cfd1fd4c360aa37ab144b7b8af3c924b9a5fb4b01bb5724faf6718ef02b7f021c8d769cdaed27a5afe59a396e788b13610b5d95f4377c0f7c6b4f86dddcad0f85946dba1103e3f00ee3df50eda9636abf33d468d4ff7ae634fd7652212e6eefec4667979adbdcfe4652cafd37d548d5a1cb3562cf6369154b940bcddb3eee589fe7902bea5fa0fb74c1c12b3f831c761bb7c959f547aa1a9845ec870f28e13336f7b07bf5ac7fde384e358213f16168fcf5e1b0d8e322272abf6ff92fc74432fd3ccc4b267979257ee8cdbf6b2f79f703cf89c34a418e8223734ce6f719cf7448c33defe1fc41d01ac37ae998a512d1cab15cbeda8c0645fe038f104cb1f21c00920d44d71438eb2492daf094c89a74479d9309ac8ad0231c1ba009a5ad0c910c211ab68fde74d01eba3416efd4ee859002eb82095f05eaf199ed4696245ab782dc2473edeaa35aab7d91b4b2e9e5a4e324dc8777966b84ac29ef70a5ce9b9b5018a15db30ade944387b018c45a23af4b5e696527a813ffeaee0495fc4b278f2845861a2fae02fd7ba94145040bef7c5fdbf6c3722e9ce248de1a38f1d0971ce231c9d30ffb31aa01e74fb1028327172232f5725eb040ef98a72c289f5acbe9c72019eb0e69c809623ed14dd8bda5dfd3ddd6989b7166e22630769d7b7eab9a9cce2c6e090ffde3f353069675635bc8e628842f8a82defd1ba8f23fb1e9b02134f487f816dd02611353c24fd9b158c984f4d0448cb9a6bd214c66543193b8975d651abea5ca0f1b026f6dc8b5907ee1383ac7cefdff4eb992db5542a249536a3bd6565e25c5ac3eaeed3a85a84eddf4459a7b775df6b8f0542c710e695e66b5a26e95538643df9acba2a182d1990ab36c36d3423a05fa280c8469b027022bf15ebde798d8c35c3562770ef8522d347010facc8fa27a9d4fd847b12f3a939c8d1fe22f6829c45c2ff1a05bd651b55147cfd0549d100f27d7e3af6e1fb5fc1434e9b341a48a6767f56932ec4f48472c7e6eb6a851a8afe205a87ff0ac45c77b6a0850987beee1d4e994b845ab2c98fdd7712f76deacabb0dc6c0f462e2901ecd004e3ac24d63f96b1741a4906c6ab1b9222e18e8089d2eb96a4284cfc4671f4ee9ad2b5fcad22b057bb9bd545ead2f54a96f07077920113e37a3f24de636f1cae71b382a38604b42788c2638607987616f97d04ae484324deaa36d70f6f90ea067cfaa1f0a16e0ec211d3e8f1a389359b74115d84d05e401bb202f7c20c94fe1a56a4c81258d1b61fe02437f75c7b92c634f2eb13819e64d5cfe725fd5a6dbadf3183ad2561e986e73463db0ee63cb58dae178179b432e2dbc490ca125d02f098281636fa1ae518b1e83bbf634382cf96f7e7b8e6fdcf15567447ce83b10b95c98b34b0e48bfc6c6c82df07a039f92cb43097016b3bbb4b2d7470e87b1df60ded85530584e9eb2fa3a82642794ed8b5e0c15d1cdc2f89aa7fee7ad1f49f21af65331bcf4c0772c0b352860975cf303a5c26440e92db75cba59d7d2b68088bbf682d767765146c3443d9bc1179b2f4a7e3187487b97b5a9a1dbe9d3f821cd1d13999e61eefea381bed0b3f55e54184187c88c643a543166da4732f14c2f63973176352884d1b481da9a6beb41573120b7bbcfb1b0a4ad211ce4c9f9ce9bfa2ac2554c36d58a5ea9f953118b20cc14ef893be7cfe4856b6198802b8fdfac81003ba66fa6828984a6b0c6a0c0127fdc99a61149dca29fc2636204350fe4cf9af2bc1929eedc9259fe5047ec0f6106cd4fe147693efbdd2b208e5b525752b4d43cde440430ca00e59f1b4a622cba2ee89adcc0fd55b7d7e92170af3c16f751d7e908e6f083753255ec0db1e2279abedbc3aee218229408e2e0e960532dfc02d72333aa18a56ef81f15f0ecb340c99260783dba57187154cc5cde6f7fed12ea8cfb790d56dee950266081ccb03515b06a5a346df4e52f4279e413045abc18eacae3bc8215598c62838c13939fb9538f9bfcafe7b67c8fe4c5f3b839688166a966c31af7b7e56be045b9c1ff65057346a05c553a543417553bb75a6d3d007cfe6acd2e8caf379385c90ce88825461b31ef94a5513329bc3561e58287165466ec216191d4de5598af2572585f19d094eb0e08395dda361eba4877921f655531ad8c01fa9541e616ff4292321336dc4a4fadfc2ac1eaeb15f938f844c35e4dab3a91622dd5d6327d9eec1e8d81abf99a26ef29f1d7df3a603dd981f865b4bb4e0b05197a5c4e9d2186077b2fc7d19dc242f6fddfa4964e37aeb5157d38b799d71438ee4a83ac35f0eee76326e67b6c6774cdaa23a0c5c8b645b2121798ebdf26fafac5aaace34e4ba14c3a332352dd6ec5be53c8d0429f191c3859e5825e522f86307ac27b541d253667caa15b235673aa71d1294a65c76465f5828fcfd81417d570f33da3ec95c29077b98cf0d15213bb0d1cb08681f74af5766898cd3fe1dced5afee5adf8e2fa45aa220b95e8ee6f517b29e14cd44fb031a0fbd44d79100d681ea04875221a498c299e49367c1acd5da81f3ea191073d5f239e756eb120c45911e051796f12f5af451b09d9379ff1ccafcbf0a27642530d49ebcd54d2cb1156c5cb17403255ca36d69aab1cd58a0337f252f5c0ce876d864226235897fef7d60d695efcbb1a71fe9fa986857d956da9f26b4c5ad82ed563676d326560e75a32a2f4009b17dbf15551b50e31802ea1709042d92b2b387f65a2c039e25befb27964a414d8c6fbdc25ac5f6ff7bcab0e3b5ba630e4c487b9536d59a604a832d9b44b3a219b14a7888fafcbc90210b69292ce9d2f61ad507e8360eef1b67f44fe630c247961562fe416d7a7f805f26d52cfd3c40ff1aeec3e945e63cf87ebb9b8c15d18c25160e051ec6a2a3daad4afb9e44a0197f8654d21d040a9f51decd8b380595d44be79e6ca7b69e5a247d5925d6982bc3a3965c208c3fec2b7dcf78952009a89c49dce9ebb0885ead9887a93dfd0366fc659c9fbc58637257e9209aa66b5605b6b1445bce6659c7b29a4763a25b46d84bbb9cf9bb317b7235bcf8c4bc3501ab2151008ceb3e56c484482fafaf30b74db9349d4d17f79e389fea84a3db261dfeb4d500e57a07db04b7c78b0e2aba13f0efc5def8b1c4902dcb78cf5b858a5b3d7c92fcea946112afb20050980f5f6caea045d5613b1c7fc455e0bb1a708da2dea3b83ba523fc95328d3b4915a79b3713d2447c70bb8369318264cab4535249632bf7c147bff51d244b23dad1458fa09f7ad55c3d8ddac36ded1c0ff0ac2017c75ab6fee3098afc66bd9c5efb8bc18bc58d34a52970c35a9c9dec3d2357bd8e16248e0033d8e2e7ad863f202fdb6cd016e979b619ba091f487bae5af92a91e48c7908794c09ae63569ff45a303859ecbeb5dfec0afd17e631de3b50be49cc927b2eb35d925d3adc05f24dc4c5c3e1993dc792d25cf824a93c514c23c97d5a5e579f270e34fccce3c2de6322aad9a770c8132b0a9fd589a785585446d7cd2b7387d630b89a120fe79bd856c831b7b8e39e24529ff53d89f1c0094bbb6e7c687e0a364d112938e71a3140c6492c273fb5004d27ca91bd1ac390927bdf5dc7d6ed1d8545996dd11a1355b77d85ef8038913b26039317d56d2123606f437be8e94b34542f36f702bbdafb92368fb08c80875139459b587599a1a6fa5077c6ab61a9abd5d3c584c0d1e184f0a2045ba5301a5fe2653fddb5c3c07fe9550a5d0f691ba9679b1ffb62f5977881434254ed241ab0ba326ced5c6663080c5d0e2286f92898d69e5fcfca4d952daacace0d72980320cdb8b28e65c85bcfe22adc0927b0c7a282b5ab12c089d6dcd72d9150a34859a010c108aaf377e075aef07fba37c44c81bef839d1009c9ee338f59af4ae6623b65ac7786180358951a0bda07e7c8e05f8f25051ae7ad0ccc896574340a1e0521346a3e426839051465330a88e386db3b1ef42784c5127926afb673fd82359a00e7a3645fb6e153e49c5c2f534d0fed89623ec2985db99dd03047a3a9778a8b3d351f9081ae1a9a1a70ae4e6a0b1ec4856b624939fb6903b510bcfb1f7c02a998e75ec0befe1f95add6cc88e4cbacef7c1e12da89e1803a4b4c3eb2a6125a88ea847b5c7fb87c1bd3791d61d7e09cb1652c814050bc2a0b5c7737b702d5fabe38fa49815bcab48bbc7dbe973dde4b896c0c583849d504811e8f65b02282b4ee65d4471e5e208402cefc521f254a09c91e444a6b29e0c28af9cef4aa1b770113cba86479596717bfdfcb253394789da2b15dde64b44d65eb19174364e014e9ccee1f79b77e072929971be84c5f72f21294d5e5032377a3c03c5867f80981af8ca072a47373217dbdfc07c6f2efa76db4b7358fecdfe5b365e2e88072a38c2a536633355aedc002d9c33af626837ea72869504e2b94e237dced9b3a3b09ad5e24c0f1e3b736375ca2f438441e6da3f37d55bcae26c4ea224cdc288411c75691d579c8841d0f9cce4c1d43121e08124824caddf443f28b740a86eea0ce28026c6abeba0d6de7ba4fe38106e8daa90d8d0e77a461a5067277ab466a4fb97f2f034ecf38dc979bedb306f69f54d4cfc1eaf3738418a1184b8e52ae7cd8786cae66a9a1edd3e3983993d6e46f23213065293f4dfc32cd0109620bd20226bf86b33ed1678f3aed4dbde5451464f6192fd4de80ad1f490a4ceba847ce698597ff0369f6b0d0000c359a11c4bf2a192a78a4bf1aa325cf1ed3cd85809567bd54d39a2e52b895fd9df49ea220616c6bec90a001a65a81cda72094b33f3e1c2c380e59d09402a069f483c9627aa9f72f8ef2c1a000177f42329ea8b171018eea61cd887ee55eb6c614c3be754d94c1a538c7038afb3939a153d1d349522fb679ff36902c263ba0b5e74d686fcc0579f0d1609a581838a30b050b3c99b90c42168017416648d3b6a73ad3f063fc9920af8389d90aa87ede984c3daff47384a4437c36e3c4bc9554c611d094a01151de784a72f6eac617c8f7e15219f2104872c7f0019db6f0598f2b28d2ff49dd8a708f2e143bcaec58a0619b03d6222e72af8d76203ad97c26fe2487d5f78ec43eecfc2661762373424c9b0cd0be2c49601c42f4ac39cacf983024e56a3cbf2537f5d6186e7713236b18b52945053f8b3c19c5af84aaef3510880d80f8c92ddd3371a16e2de0eb7d7b4aad5e12cd4e3da613fc8222133c7817012564162061dc06c421abc7c1c88b2430d7dea775801552ba5eb7c32ce61b48fda63fa9d1cac93907a72b53f0c8ae981ce32128a725f313762f32d17cfcf8ee714822b7dc8b488d38f8112a73e3381687c2ad7a687fc768c5f15ceed253906c663276ba2ffa2dcd669db8bebf656d4504703a5005540f4a3bb7d4c5732e041a83aaad97c39b3002ab3b21e2f1545963233d369f0d9ea82bda7bda11d839522fb6b97d2d89c0bdc5e9967421366de5ff17b4bef4816cab45b957290e744e5029fcbb8bec6cec84fd1e6ed61d8b20e6df027dbd89a0d3a7c587ca5b91599a024f316ff719a1476ede4cdf39c76efa8575cfbe1d4e60e211586891e24d9c36fcbb912e3ac11e382175fdfa389d93cbfc56de75c5e11e33f327255c63001faaeb96e642ddf0fc8ecf154cbc92dfbf550a4b899301c974b3d549a827139cdfe631b6fae54760823d873ee8362fdc8c91e951b07a4660a5709f40ecc832f177e1c543961fcea542b3484130e4bfa3e74debae4218489a53631de48f6bc1d20c856c9d7525a261f4f200c22b1f4808cdfdae90c53830e2490313b52742a96705d7a0603b5a051ecf697b63702a0b50478e222e27252de76ca291c0f531fc0e10d2646a20b9d01384c4e16523b92590e5ad1002a1cb90c837a30d52b7df5014028cdcef129a615eeb7589771714123999c0b52b6131c5a84a6d1a66bd45363cba27c5d03cc920f908297641aa99d70680e452e39cb4871ffa9a9de783efb2fc3b2a878359d60980b31f61664ddc4ecdba09f1f81f023210c83b86da75611c62d845036d5a89e274f1d52887ab7d60c0d4a8986da21c81306c306e26758b7e38b991808c060650e8ca3650f120e7f8a92c5a3bdb79756cee0f6961dd704ea5eef54192f684eff703d68b22b599284e227daee2a39ab456eea2be4c46fd3726440b3b4160ed6be23c5de38fecd004b6a85fd0ca28542b722a609a6b8f5679df29d7b84b71bf4b2ddd53468704e24fe43e347ae0f4847a25465ca781b98321d56ce4b3d171ebbdf770b4993d6db1fe543d2648829670976cfbfdba6f0e916f9210edce27fac71cedbb5f5d416127c02e3f1097f66a25c99cf2115faea7ad355daf8e22a16353f61ffbe908c0d60273561e1f2976f84e3f9d526e2256b8a869d0f77f174f6d3e0fca4bccd8c9ceb2920a9413e47e6055286468a08808bcc8e31003fa38bfcf89890b0e43e48da36e1bc64fe073716a4bdaf05bb629350f3838a77665cfec987870df8f2a0cdc1c98415b096f5146ea7c52f920cfab53928c6011d7c94ba2b452278b7538a3568780b262168ad42146875d5ef61570dbe59d878c74943f1c10402e774d413681ac6fc18ec2fd61503f7fc5cb820233021f2ee4ab3652c08540769e7ecbcbdcd17a87668a38bc08b64ce45d7c7670181c6dcd27b0714325323373905f5bea48468d13bac07e337995fac7ff2f8bd1defab50c2b9f13ff4857ebfe7c925ce007cec554989d4e2a280f9762db67495448bc761b54e953cb74d8b8c1a5fa08983f746988bc811da161185cb8036d191b6abc643d887a2dca07784607acdee81e750e2410acd1fa038a79ef527b19ec9a8cbd6388e7f9aef02eb195b223bdd3b3b8aea50647f718838ea61cc03c106fde42a5269e685e7921d6a6c34fc8c4c703a41837af4de5032674104d0afe647dbc0463407a0d17e3d090b7fca4b84ae36b0659bbbe8609876616b4d55537a2041a66f134c3f73dc782dd974a0dd3f11dafa94708543b067435872acb0d1cf4f30b71beef0bb05ef998fee3928abe916ed51cbc071bc9abfd6d929f10171e16477a443a5b3da27e09d770df0fed5d2726994ae9075f97c017a4998bad0425f91ff29392dfa919eb1c3db183a623f488694fdcd413b31668ddbca9a3711a2347f22f42666d74710d9cce3628120f3b28ad1b6801ee4a24c29d3fbb05429158bbc74ebd2cc2cf9f682d8bbfba9fb12e6a1a344391f70eb782a75256776b146479d60077ab944ce150035bd74785e11149bb7c340028e924fff9fb3f392938207f288201927ca45e849a4cbbdcf2b811bd325cf94f665e3d9dd3e4006044d4d3384d3ac6635a50d30c81364ae75b3ba85c35acb4e99354214b723f35dd46cdecd4be0e19b0a9d7b1f01a5165674580cc17aebcb0bcaaa3cf7e10b71e3893fe42f21ae45d7cfee73bc5f82b6e45e86325bab11136e036d21ece3b6b632d4de2dfcc5a768ceecb05252f93a54c20698f29eeb3cd94603f076028e8c1180d0bbba6e80705641e291f73c7f9487aa42db8cb87f0fb6167b16ba390955564f9d6728de3ce3832db4b1dfd0083e8d76dba5e6fc7d3507479373fee517280c1bff0ae34e236de393f6d947451b58f1aaa20f699e735458c7cb18a40aed6dcc6c51b4616d182ed91360394be8935bc157b490ff1920ef2e98c73c2641f8b2eff36dbc38f1930fbdecd558b8fb9eb27ef91d28293687865c5cb14f0974a979db06bb06d9378c972b9fd4264bfaa815723472107dd8514ad7cb6ee434925df400f3ec61fe6cb0743480a2de906be83294769d64367663d2d3f220a39199f228d61ededbc681a13ca6d6bd878540aa349eb20e25192e1749038023e264d8b8f5a7ea834ba173a8ebf8c58814cc842ce0eafe8016e63540d56edfe182581600974259f74a8266cd44510a84c6062223549b48b6f657ab778c58f3e9cde443157f481d973d54a723132cca1fd25895052f63f9301d4706c3e205dcf5aaf00f23acbe1fc6eda83ebd28f3ac444befb812d3454c9899dcd066c87dc119cac200c9c18e6548f29372805687d6486903f4fc0b19df922ed55e63d824eeff51e331cbed3231a77051fff3d3e3714c6a42d9551c03f5ca476008b6fce28d83b271c81888849f57364fb77101184e02a63fdb86e5e77e8c3c45598473a78ce478b169973ff436f90ad1316f853be71ef3fb12e82ae8a3618d2fdc32a2b8d1a88a8069252ca4805ec2f22374461901639c6ab4680a759839050d16b3ab520925e83103340dc3a3e2d92e56bc468d094441256bd16e6642a7ffc7812f2f20e5bc4961c17e68efe679312b0568ffe8283c26b5a41b286a0cbe490197ed39fc4e9bde46d6347e2d60f2dba84e40920a874a3df1904e8361428086e8b84dcf4ea5ab7be9dea7ca62060f8a8e677c8be665d6e871e103dd93d0f912c39e94e0669d5284f1909a4ef9ba53fc70b1d307517d23741cfb1c3d0286397f18cdc42858c684ae7c94454eadf9ddc163ed4c84416f224fb7bac03193fecaf799f9575a949c3c1bc414c06aa19aef2bdfe2f32c1f725b814e48f796bea7f756342ca961561b2bbb1748a1a798e7e6555a9f360cdf240fef77926f4152cf80bb1520051ebd0908cb11a5d4f9b55bc638a00e84faeed6dafe1c126c9fc4a154ef4a94fd5d54313d2b50fa652dc9a60b3216ba08ad365ecb7b3b54b2f61fc3f004ceaa43f6124575ff897f91ed140da91fbf61d310e737976c8746baacb71a0c658d76ff8536abef724b116a8aef7c570e1501738811d5c5ab6dd6ab7307293dce65b3b372b855ee62e1c79fc6cc4a762b0fe59ba502dc59edeaeadda888de5397b394ee5d0d9dfce9a81d7b804aaf36417f3d22d688351dce27770791f5acf51fe68f1a77132f85b5c7ca15d8feb225e307cac4d2196899aeac1cf7ae376b521923a3238244479a2e3fe0d0f6e2217c517f262a5daa153182ca7c0fac55c493d0aba730d2cbc341e4bbffcd8451dba0f119995a536f985f99a8909924cf1730a6604fb0cf91bb3935ec6927ae6631f45b4c47d7195abee867aac1a73cf8b9037ed9ced713ce54fc92becdf028a2e1e23e23cb0b5d5f84c92f526db45a17d375b51ce8130db35f9d7c4398abafda3e4d97a5e888c9ca02098c59808ce601837a54169fbf012b2e255bb15810a990aad05d26d19d664e1a6a94bff9555e4818de8215a5c3ec8c4c576c668d38138e72cd2d85fcb828d3916dc14af531f4d7087fbc466da23e603d6d48556a7ec4bb3dcf55e8dfc8e86554e24b0d11a9999d191f7ea4af1062a66eab44954bfbd3b5cc27e6784058b44a2db9d2f86f33f7c285a5ed85f2fb4dcbc068c708f51fa8e4c2a000fa6c1cd66584bd243f4b1ec87a49e77b4e84e7e8b181598eb321d0a53a860a823196f89be94db01768571e067c98778ca5b2ac27569faedf90ef0370db4792bacc87d246da012eaacc1e7301f9837159ef338e6f5d4bd0ea832bb2bef4eaf581671a55abddf5d1013023bf97d382516dfddc7a3df5ba4edb5ebd43e3173cbc5725d79ae995389de96ee52162fe6e768c0bc13b75672aa9d9862c861e119fa25191d820fd07e6708b19b0ca60f8629461dde5e788af53df596ab2c7c216d10f726cb494a84ffc2fa29f35b28ef3679982cd2c4041829ed660dab5a996884bd3af1c74d87ee8fbea8f99c71329a310563fb2f333b2ab8a07c97050534871e9a46a783c9fcacf517c1d754f1e9ceac0f5f66d68e8dc7ce0b93b01c1d9f2d6829deb0b0ea52672016b2b88307a5d05b2d36bca8351db39c3f72efcb27d2c78886fa6eae9f8f02dce42c599e0c84fe7cd82cfdccf2300edde903defdcf07d890d0c15b317bb79a69a8cad35ee0ee2d825ca221db5efa374eba124abcd3716d42b963c4e62a0f91e9817ee9b649a2d2e6216518aac9056ecf1da90b46c891f9e889f8b52f647bafc6b9a3cd8bfa98c28c309edc1fe924cdd2cf6901422755cef3a8dd1856cbdade92a40d0c6b6426c850ef0c901715e062619b226c0d10f9f4f690e2e43b9bb0927c157329ff1fbbbd59c1f63d41f056b61f45227bf0727b3e6601f53d4071aef607ce60b5b1f81f85767c4c0f8d1f3ed826c518839e601fb47fcad95083c22004a77459f9a20557722b1fb6f524b63d53560ddd0dda209150f79b053b6740f7d25a703871ef12a6de9abc91973e90678b347b3e10e521b50720dcea9646e7eaad68e575fe356580dea821192265771703ae0ca3fdc9ce85cdd362aee0e665d61dfed4714cb00d17c7eac61c77b843a6d1bbf8be346f92ea2498063ef7d941d0820e684a5eab46f27385b1ce81d82135195403d80bf37d4be3068edd11e7cd080d2318308be7e34ace58c460f4c01da516dd4c87074aeda5e5d1f7b130b52eccdf0c1f44b3afedb2f73ac4571fbe716eecb9fddf343498289c5cc3b6456d5439aa5db20c80ab24f6157a8328ceffd888a569ee7e7d0e3434a68c46d7d8c97115ccfe489e7c21e499b6627f1a961ff4282a6288faa9fb2ccf3c70d2ca036a549b54c32d0c951e03c7f44f9ece285c28132feb8a7a18ed750777d1e509c6fbdf226270c033f6fe04a1dca184c6bfcb003a8559986067fd62a7143c094fbaa4f8651882079542c59e801c93cb44c6e5a6006d48f663d33d06f68f62bdf9dda21fd9111d27e507a061e783602d57efac97940d245f27f3fd60f1fe29529ba00a9b52d3c306ccea7e195b34161177ef4f8ade15188516faf26e3e0cd930add9618cf09f2fca3362337067c63d306c2fb7d0f355e6abb7bcc61f4cf004b2976a35b76ff77f1493fb26261fef1e91ae6e4b4383bbfe19fdaca63fbdce995376f6b32b415db4e6c53b7b61f6a00aee5ea9946c94540cc4a8bd3fa4b203ab3d525acc6a2aea4e80b7618ec2fc1cf3496323d751e6c52ad0abe75a7fa6ea872f30e74baa2e7fa315bd0df6d46a536e36bf1d7011f2f570fd4398542eb13cae262394306f25360b169c80cd1ae323064ad9aad07a582ec4822effc9a3fcd21c259150c6b153581bdd9ef25693dfe9e47972adcafdf4a4e2f524f06af1dc40bfb8b1e36fe56f8c4320c43440da1f51381801497777b9bd0a51dcf806eb029ac1ed328635563e821923b504332e93438a0f9da96e5872e678f0248b16a31a305b732b757b2eabed23ea357062361e8694db428aab73eaad40a3c38fe40479fc78e9539fa5db26faa9d0eb5cfa30fca0f967cf13c21fe1f79d234b663f7e920444423de6a1a160e4c1e527336fadea964f2b93fb6ca194848a7684240e2ba289de1c79e63f386ffbf2a3f801358235ba509f5bba5b4c6a404a56c5fb155f3ac4748b22dd8e93b80f1d2d5fb481311093f1d2562dfda30d755a33d0b3d1c5b888ccb0fec5609c678a618e5cfdef419a259f1878a0a586254a85fd2f5ca42068d42122695c074f0da544bf8f186eff86fafce67feaa116becf4fa5481cfab9f8d80df347f059d89bf38ccd27d2ba4bc424a12632c127f250e681f3554323f0fbc586ce20e4e624111d7fa026a652bd005fd827b920925da4e4ad440b5cafcf8fd81e47173af891c8af544a87ee473b00010e70c10234d018405bba840344a483acdd47ba79d1082c078919fd4ca5e3002e1f40ef1a0301edba3a12022d385520b5debcfe8e2a35006c85d8e4f3bf19715930cfff5987296829c6146ce0ea3e8aaebffc2125076cb3c10890e88d86de7a051af14261ba096db1cbc1308a85f7b34868362a50e13752ed582724b64f550ceebad5e68d13203efae79b9d91e5b7c7983db5b4f2b7c72b23a7ab609fa0e0492a3f06ba93e9866e51ade080e128a2656c6be76c865d1ce0c3c1ddb5dd11a51fa33aef5deaa08092ffeb5dece0bbc7e4018b877c8309147a7c718c5f40a31454fd0000659050de29a5f6a5a95e0c025f768a74b5c231d99e822f0767456bbf2c3c2d64500511fcdf5788bfa99bfc853086317456f3721d52697c3f0e777468cdff632fd7a1895af5bd36e1d5044c828dce23d38de99e1146f4ff63f6007cfbd1401257d651389160456ed2bef66fd9cc7900ad92b64524d6e775527f8c5333551df903cc128791c1ff5033fd8f7afc256bae4db4a472ce6ddecd116fdb62640895adeae49f06b14ed6d60a412b03bf08be8f29fd259bc0be55b809ce38cbd13864b927a7663a72480e10e42484d0e6fcbdde2928af143ffa16fe60e61b818046c7a540aaf63795989a0fb69b61903f364abcc63253ceaf7e7c343005ec2e0a119af79c351d4523dd3bd550863f2aa2ed7378700c064908202018d7c1c65dd5d329d17353480a053c186a38108724b4dd3a1c50b23e55e6b76362e468d51f9a4e92a5a2c4a3a65ec566977c18f37f24467a26c326004c5abc0c22e25a6f882d1c54cf95ff3080deb4ca8081d22d06222712ae2c36b52a63c484268a888e76a64c00518c2c3bc3ab9ce1e525fb2b114941f9936d867c0ebdfe8827612f61d5d78263f234b031896636b83ec82d239234338edd71dfd65bca348b87e4eaee7458ce1c36001be943f2c5bdc0a4153e16c88fdab07f7c63c64ca75ea0cb6665c82912ffbdb2170345163b2c781c5372986610c261d126db64c9d53a76c44fcd1e7b9462e045d67fcce7e6fb9b693cd74d1f3e8ea91870c7c4a81eebbfa25aa4c41fab4babe3067ccfda6c990bf27b330d6cd738f179469e0ea2f43882b840e45fcb2ed10baf4daf216913386588cf6f050ede62df6c943fbee7e409ea758f275ec065736749961d33ef2ebb560f14857db47c4c766945da2efeabe039c2130e08c5cde05e754035224b8c12cde4d317b336b748a8268ec8903f9885d90b3333d3ee7495e0edb8b3171c7ff3cfcd21fd9853c21ef3ba4e7e82b51f0b6d7b95b5f89ceec4aec722b08adedb6d23bd5c47cf3b51ffb67ee12f43e48570705524006b753620a813e4b885588f5dfe2e8ab853e5d88e84f4279d802e15552f897447bb27ffc7d5882ad28c79705a800abb57be3464facae9a2ec8fb8202b28fbf264a390fefc1f6bdb2305491b26da338327e5e7fc6a902d6023911034182b3aee9a7cb85fc543a78da177bc9c2510a3211437f6a3105f445c7d77edeb927285f896dcd6492fa5d835efee43695b2774db6104cd720d008b8d10601ef2c278c4b806f693f319b40095ba505f0cf889e041c2c03b8a67668f934c4c4f8452f9d2b590cc6ca9982ba9de03529f1a9d9a950889b1ce2276a7e05f5f953fca70c70a79767677a69d9e0b058dd636e3d36fa1dd61e9452394314e9469930432646ce587f14ffe70d3afcabb26284772ed92097315f92be343e54bc884a9afba1f78651855d45713d97f6e3529ad1de400fdce9c048299417261e3edc4590860cedb56e4530d8df7b1146052ccecb7decf8da2471d0d3dcbfe77171222ecbf4b08105d0560e5d6a498ad5e2cd22bebba62a6f9eccb4177c42e7a2c96ade9676cf067b5ead9aacebe0007b2f5cc37ae54dcd06115f4b176f0bce50ba90f248491feb6e79c01d8f842675a693e453040549216b8233540af3454ee24f77a8ed66863096806c9e006bb477408fcc48e5e49740029a1d433b0d29b4b63784eaa7cb1d9f8c577b87e03e4b944d68ab1ae35d1cc53d4b4c985bb6ea5f8a2252af14d90e4faadc325aba186a896d50882f2f75c8f6a226559c8fc9171a309be77aed654c14b2afaaf396e7a2486c98b420ff9c5527c1e09c16016dfaedb87efdef02c8dfde284eca4a6fecd97a62c915f77cfcd5ae2e5af2062e0dfb67ca5134b9a390dd74c4bd3fc55560e792aa13d0db48702d370890cd921b920857c90fa1b782f90f6e38aa4f461333e02eecf82d6de5b67f94437486d7752b3ab8f74a542c2d9872273e510ea15c747d5d7085d6f9f1959130205dd5cbd81e303fc47f021cc2df127ca677d1873b9101190c87eaa9a743d1241b63b890ae42a4a1263479fd4fef915a1acc9e6bff0ae756dd83ff6563fbde519c4ddb76d7bb60eedf530f154972335b00491dc0ba86dd1aee7192eef9bd819a721acb49e1467b8dad13504bf12148af8cf402bfffd1fc5f709fb55d9a79ba38c45dbfa51cd71bf29819bcb128c1f20ab42054bf74a1b44ca147178fd631cff5f7200a7552af81efa6c8b94b156264a89130d569421b8b78a3421abb42e81c209656e958e634947e73fb7d6cdfd78e72bfeefdd616981af0f0777f22b5c65ecf3d4c6a1a9d902e00e6119d55a25ddcbaa67392c7c64804a265b217c18056ebe879a0af7e3377a5255c72151c568214203d4e2d9f755dc9d029186344c70e053204fc8582af0e7cb8de5633a6ad11c9138d40952dddb53d734af698e80446238b8076c47fe7c0c094e8ba2b231511b775b1841e50b5a28e53351080cbc159d2a21c49c89fea65856db0fdbf5126b392172852cf116b43574c1aa5d1ff2696c62c9046f94d901ccac8daf1f2b440c6dcc896b31ef57c88a4cfe8be0d9153891cdb72243dfdf10dad2776db0c3afa2aad5493fbef7c606c39e0167178bf08a1410ef0c6b08646acc440cff83adf7510cd4814a3d7f01e7ffa951ff2cf4fb1ba86a15dbeedac0e9c89d0e0e82490d47ad940b3ef236b813b4eda21247d980568ef332b4a5c3b6693d902b8347ec685faec9144cc99837e4801c975b220f01e45812766e6d46f1d7df040e1df6d2e02f276cce1c40e487c015557b1d268ffcdd7b0be80a25b1c21f7b7c2613728747289cf83f4aad554d9f7e194b99c01251eadfe1e849b13a4fb53136da26fd94efbc781f8d2ce56ba4c7fd6f6c4d4ab13a842f37f52be4b611ca51557f0ae9ddcde91aabbcf3e74e0c2bee8c766aa6eec9f155b380616762c974edc48a57d2b5c124fb84dec9ecd1a7a40e197af86d0502b40650c5675cd6163185f080595a477bdadf9ac35c5dfb1d4e8f03c735f2e7dfb4d167b50056b51cbc89105546b66a1ecfd422858424e9ec615d72b68a334c9464bcc173e43c37597eee9491ca2510b29e5dc4c2f6f4d1cab5a51364b8184f8151cac3ddeb3c3a363dec8f56a0caf6e1ed2951bfd410f736fca73cd2ba0ea236fad4198b9055d1d1fcbb267a0b4d41ca56608120fb78a18be24e68dde7c6869a8e840bc2dd5ea04f5dd035cbb2d721bbfdb1e8f7970854878d8ba9a99af2f458981e6417bb25c3b0366d9becbe40b2116ac4c8c3d61ebcad27f730bd60f23f458393cb675e4b2fd53523a82ab51dd43a935b6e0d1720961b3aa42a3ac2be5f0acc746d5497d195af6a8f20555b3afdbe440810bbab1b5315896c23568b37a53e2f2701749c7d001ec210e56c02d9003c917a21810ba6fd6d7559af3194d5cbc72498de354bb91a3c5e9e8362177c8015405c836884a181c2e42e6e5b11ef62f2ff779de4cb8ee58086b3445e018a921feaf1136d9ab2c9f1a8162c065d3a19c6cebc448470a8b987fd7d583c14caaf97c64658ae7913dac91c67d68ebb31b0bd5847f8010014afa67fb57281052352db5c3a88238e10454a963df92293106e4614e5264b6e60f8d16cc2cb0eab49c6efeb6b66b9e43bf608918e1e6258ab2237afa478e556de625dd3d3253b4ebfe91430d2dc3ad9c1b50997d8814a404ee2c2eff03b8a646faa9411d2e602a005a82d8ab77c9a1ceafc879ddf1ca5f99ad78ed9befd2cfbf77030d583b4ea07135e3acb531b40fabb5708e0c9cb84c1f11c39ff227d0ab9f3dd037104fd6f28a276f5830997850c72301ec499eb8c3e1b421926fa2a7bb603d64d970c5c76cd1f01953d00067e52b5b5c996634a24ce51ac81aeca9025579b15b7aa792fc648281ee7f1d9bb25168f3d065e7ef76ecd2e5b3954ec6ab4cf5e3dc7e279385bad5ba0f733dff89d41b4a1a88c41ceda76797ddf7e8fc0634acea1d38ef8b376347200b3dd1992a1f4aae9536ceb1e1db04d51a342f07da5e25b518bdb1ad97d961fea51501ce12def4cafa4713212fdc9b9430fce2eaec380cd04ce85b4a971c90d7d5279157431879324181d7df7aefde7a170d8b70f1382348ab8a5139769cb994e80c606c6a624913fd720016ef208b7188aa96dcd71192ab38ca25372979c32daafa4cc7e7865b9d5031098436931fafdfee99d43f28bb148befdf4a6736e99e269c1f101e4647e486cb52ed2b13a0b153d4915eb5e3a320274d2616250cff61779f823a5c656a86395acee6a49d275b6e6d861f7d4ed1331eb142ec542121014f8bf409dcd351863cc2eefe9d6ed99f2773d88e752f52ed8da53bf996a0294f98b8fe4dd732d61a076786a3af97a813c689b0325908ba6fda8d522e28f062e9e9de952eb7e2805ca9ca1b5d850b2078b3dfe0dd0a4fe9dd7b46f9c74927990b4f66987d42c681070740253f2d18ec7811e22fedea4b648a4b2aa94653c97db5a10e9994e5a641b7fcc31be3ac1c6caf104ca7e3ac68b0f6156da26d62bf9e0bde8d49cc73c80f01063aa55ef255185966e11bba601c6a919521232af59aac0f86b69c8a8e5cc54567287e6965cf481c07db8bd96b36d29fc7027840b1ab5b9ab3e44217b9bb58b3d3259a6d22f7d757ffa520e1def3a9aa25fe71a75ca7150d2991b06a648e76efb33172bb2ef8f58af7def10c5024a01d4566b1302f879ac88c8f9325cb0543c79a275931b6cb18458c586ab084ff87fd52d63d92c13684db1548e4b776711ca51eeb761640adf3d8fa272bc5b29b68a7e083c02df01f2090cc3b341d236864b35f866680eb61cb8c96b52d0ccd5d51acd8cd82f8e9145b87f82b03a12914681bb9e70073db0059515c387507583defe1e44548a27b3e18877f32b5a49a6d88afd27b09a24413ca1a2e0889f46e2f9335e939bf66abfb45f60eaf1f3396d24ced906ef9863aa5005563edf6d28a4fc6b9b8ea00d57bf24a1f2dbfbae3cfd6340d20bf3c16787aa27042dcfca2c6706723b7397c614ec21fdbbc8e5616831725809616fe3a72977259786146cca4c4592818fb494134cfe595b215abc6b3ac0a6445b09f5fd12d992d39eb5c54524ee59f69068188dbee8ccd6f69f26562c5b4131f806b4a7cd3e1edcfdf1ae2a8d86dc46a536e438cee8ba225013dbd7b3a64b2457dcb66b1dbb47844f89ab841747651e6c6e84273330d1c84b972e8838f174b9f0a445597a79e5908706d96438e50f8e798543b3ef68e10c55f735a40e56dff3e41fc9d15effb62ccadf4d3155e2f84ab25069631a252ad3a567797b58d899e0a7a2dcbc3fb893c7e150256208fcbd43e7919464ccadc5fd7558c7be079b9743a23bd3cff7a48b155145cc862d5975b3bd9cf43366fbfc44cbaace2c95188ebacfbeaa42d58fe1ae0ef3d5b52bb9d43457397bde5936ff39d2c789163d3a592f1e8dbf024af0ed080b1109808cd4c28085c8e6e489ae124e955","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
