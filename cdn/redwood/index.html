<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9bdca282e7321f4fe0a6536b48f781fa89bc645547f32b1834e41d335e0725d8c41b3952f93c9e165c3a7cd10409ddbd8e7bf107f6e6c01a5d16d9a658c714fa2a53bc732d4e72932cc54da6bf473855cdfa1e76a78f41a74bdf3ddd17a4032ca9c79a62cc4f6f19a5b17996b1d4513c096d558cc918f762614ae0f2a88cd57e7bbb37ff9ebfe4ce96846155d3da111cc6a4c3999eeac7f3a8279a631f735bc6e6e56dcadacd49a4f49833be8502adb81ecb9cf5e3e5537ccbf6a4d85ddc677c7c76211782e0cc54b04752d3976460d2f1a3b6bcfc99497806961b08fa29e71d3db08335ffec28d017988db26885a646943941810da32d075008f19a221f5a1b3d78d78a0cd9c0f7324d2531e82820b948c9ce4a9ade3533a8d85badb00097eafef56c0460fb13fe5ee0eb93310ccfba0ffe5adb856f7245bf9855054e7e694055a61e45868b0a3f492f6c67c66e459dbb5bf681f00c482e2d6eb525da1444ae3c3229c3c4dae32437a7d2d86946e32f54c52496f24230929e7c7a68e5dc825e4ca59225c98af90d1f32e441dcaabed80e9925545922e4a78969c13562f4e29eb6d09ae1ce7bbf1ed629a4417068f41d2b27d94aaeb361b2503f5d98b3124ad186fca1a8dbcde7cea7837d7450b0ffcf25242527f19b303a198149fd3f6a4bdee2ab7a31eeca3b124b26340446c1789fdb63a0006f53db0d50f4f6f98cbb9fc8e546c7de6419002b485ec929112fd697a06e2cee34d1e3e0e0823bfe22abc12b17641d5cf2e5640cfd77dbfdd94c1fbbe308bc5ef8fb99f4cd9cb697819fe534e115485b38dbb4ec092a00bec2603749e5f92aeed0bb45add8b37b346aa9bc453122586442db882f3b31541a246819c71f655c6ef3ecb9b0d5f9d40af1146f4da4f5e18c151c16f0f484093e2f2a365424cb00b911a314395100e411be59afc93440b80cfd6d7f916fb7f8a2a8ce9ca03a14e4949911f3a0127b7a04430545b7bf3fb1dbc333cc6f5f5cccb89c1f38d5c4dae67bb7e32e0a93cd0c1d351f8f7ff69c3e528870e61fdd845a142129407604a456592412facaa1897440443ed677586380a6809d2cdf72256e0f3dee6dc2bf7cf8323aa21469c50ecf52e6d2698c3d796b8cefaf5d5ec93593f2275f706150517e0befda2e3661ac4d1694163d5d9e1545ab00425b97ffcfc22facc8e0fe13f407496b1847462ff8ef44fafb6aeb54f416ec0ead645dfc16f1e955de612406368aada05c41e459aeb27f103185d4dd2095a2431f0ce3020f0c2785b19505a8ef941ddce98734d92c3819d3cb4fe095d7a4f1aebf99019c2bfc2d0542dd348f13fb34d4cb26df0a81a2067cd07bef54f9f3bbcff67ea3e59c9b7d788abdce72d2cd0b8da10722da835b47697c44cefb379ea53970394d121e7c17bb336b27db8deafbaf07988873ca5bb23145ad20655534aadd6b9de4770bd5427f0f5b8d08a5256b0a31f64bc4e56cca7f4213baccd993a14d8083ffcf5a4c48fb668d32c573751df60ce397a3aeb91660ac308736745846dedb7ea8cb6ace2ca77490918c89a699c5929c720fec72f258fc0cd4f953883677c4a9af30cfd921e5905a69d6cc58b003add83e9065b1370225fd23c49e0ffafc551366ec42783949454558180cca0b5b64a228a6d1ee6176dbe36acde480108833e3a5ee900e4ea2e133f4cdf7c8d569ea6723bf34e5edf8dad24a3c904bef3eacc94c06ac18840b9f6c609337a21b64ed38d41eef3f929ac001215b3a4b0588cbf15237b9e3757783efb035bec19149e309fa45b31399cd6d77aa5cd3e9ff901b0a70129f73e6f841d749645c7980b6fae7af86f4c8fd25170f01abffdf08faded684cbc0234bef82d3c2af578919f8c02617edeb81ec1b55b9ef55c4e95bc05eb1d5fda7f9acfe4918d28fcd7efdb1d58ecffbc26842e45b90a80ce201a987c9a6bb6f84c7dd01a0589b0fd86cd6ba63a814b9af6eb31e9252f095d59b39c093f07f0dcb276ea8b8c1c19f98181aef322030ea669d854698aabe1ae8b05bbbb2685d66325b724d6f0a329df96336ed5b0eb680dcbf69e775e32c00f54ece6cdac09a5db1ba9e249fd35ede520f494835413e4441124334814bf591476fa2f5be99d22784c183b7edb1d539182b3899889af3b26074b64fcdb8760bbeb5039174dc2eb049975391c68e1a2122fc55db68ef3fd7398e16bae8790e0533b4646438aaf9d2cf40fd2aeadb782bd8e5d3d8ec909be3d56c67819082bf93c3f58c2162d7549908182490dcfb971df417400fa858aa0a0c9740dc492980b05232e284a7dfc235b4063850fb2855d17616842ea5732c86018fefcc1c7e3e65a140fcf96992fab9dce104ac124f886e28f7171b9392f30fc6cac605578186c6da6cb9785e73a78d10247d2b74b007c21ae97fbd80a2e15dceccd3f00b295b6206216f0c7d86230fa9f7790bf3a7825889b5afe8b896a97e007fe7f23cd5fbe3b16c9000d5becd4aecd2dbc356226865a22e8aef0555f9ce5c07c9a83bb6adba624eec0f43c7405c8e064c9b210a53adacab92c42477e7dfc8f2bce51fb3174c1d04c00590cfa3493acd4c77be2ac105a8c35e4ddd07f84de5c1a827341126acf4731ac1f095648126b03948aa91f0b071effedf48e358c953b4b8bfe4eadf386924b110fde8178311f83bb9c9bf7b672b1d651bbcaebee1c94a1f1760ec562d463b560f6365c20339a5a3465a845bd94e5c6518987f85a5ab03d5522c549f593fe515ee516203cc33b98a4598d399cdb8669b590aedbf5e9be8e5b32676635ae0f988de311ec59b163ee532dff6d80782895a13b036839e4e9d63ace0d2ef332876ea740af558082c89bface999823c0f7f6962d896cb8d23d706e54835f9239efdcb87666ffd8dea2c4fbfb243abe134547f11f38669eb0f195961de103fc7ca9521f1c27290f73609c8936cbeff00413f2df1277c2d4b47fb527e9769783d1c6888e674adfbd776a20e0b3d69f29693566c93b3c6dbe9e53af6fb802a61fdbd924fb4019167f1c7aff77604fb74b499d6c13127c2238a8521088b7dad07a12757d993c5732a16016cbd2d24d4b3fd91c71a1b0b4aad9f3b82f6bf36539137c9f9e54a31c16c99e492efa1308164f9a5a62906efd65b6d045c130ab8ddddeea7435811ab78feeb757b00e009b79478c64322774b6b5144c8cfa25847dabf0d88ba5ad5d397b6c0748b06511beed7660ed9e036224f16de5f68ba6b71a1d0b2f21d4ba7b24a2791d25a68ce2b724bd2bd1effc45c244f02ca142b7c8c1a37faa6a43639b70e6422822bfe85f04fa8f61ca6ad43210beba3c85370a5e99d5862d2846cd5dc7d6dfd3e5e89d0046a49d44d1d3eb044ec799a947122b3687a270bbeace4c20d8191d3754bb2aae2e29519b6b9b24141828982e995ad53ec7dae90c10e00ecf99b6cd39fda115093caef62ea66945125ff6ef0c6a31808af05ed288e0c00cc5ce12fbc90c16e616a9d9d4d1259e36dff3670b3df4122c12c7642321c3cf56c1e363fec0d1eb08552f83f10dd3eb890015ab980790dcc87393e2619e8ce6668ef9c2d11593d0bdd0c9c6d7c84381a8123b22bc0cc7e1294797753e227aacc90be41ef77a59ad5de8d2ed24b5d92e8a2d1d8fd779d33a5903948614147b1e9f48858b19bc188e76ab140c15ab6da7397092cb9ef905197e0183e3263126e3d0dc3f594098066e3c3b57e885162d82cad55e31e89f85149df3d74a2ca9b646aa5fd6cba0b553160e542004dd472df94a2d9b44bb577d21ff2b5abe7bed1e31daf1d4b8be9959618bf628b16d1df9f516eb3900e861a6531cb0df991e94ac0b74670f2adc2e3d20e527c68464288028fe4ac4eee695b95aac6ddb6e70bdab494212b1fa06b919ada926f23315e934cf9b4a7a68286184df18a4df775cd2abc8140355ab7674b7979f762d6e33fe60e46c5f722cbdab5f1177c2478f99aeade5daf1c81321ca73b44718a6236859b55f231b490c439be88f9b5b96361827cc1f515ca58365f24f3f214643805088ac17fda7a0c71790c4361d682e58f452ca2d3d3102cdf3e09dda267e62da1c810977995c346a9bd2b73fc664601b32d8c9d3c9a91c9221166e4db603f9f5d2233c82376db6c48ee9c2100dafc8874e6a026b41dc91fac64aefd649b96da39fc84cb7b4e8405d79f73cb26eaa206c93dbadff7fc964f41012dd93ea4e216270996d772d374fcc7af2b986fa41327d620f708b43fc91ec67dde2a67f698604430dc55bae625557a5ac68e537baf0aef2abf1e2a6cb087a2ea4186917f4c2c6baf266a9bdb0f6dcf583386ff91559e12f0523617ad4dc78449fdbe708bf5198fc8fbf6d6a6ecc7cdaf7075aca3e212d5ad81f5e8a1233c18890258c619273f274332242eb671aa119ebeba68010a8b345b3575e71481d3a67abc4f7ba854d23b3862feecf1b14072e024316db8c8202b8bc9c70b10f2e4c60970a15476847d11a470e2e6b342b2151a7cfb42e5c3727218eac5ca7021f4b6cd5c085759a9416bfed30b91f1c5b612809f0e0a534a217f901e2632103cc1c395d56119353e8b1011987084b6c00762244a7307265ae0cd148c1c54f7d522f2e49ca2b41856a00a6dd4d6702c72da093aebf3b9d505c3a85aae2ce58cd4cc888465bf79cab5c2c7dd37417f5e2125900e70d11b5d615d05f83b59280b81f46bb220859a9731139c38948c5c84d49404cd9c67480c493ebd96120457c6717eaa2b5b8611c3aa63ea230f8e9c71922667c4c3aca974f45a365ae95a09f700a387475e3a1504ca90dbfb44648aad72a5a7b7ba1a6941b9ab3a997b9d09418904030ba9e78d13e975a8c44674782013c00a501ac7d9be1b66fc208efdbe8f4fb9bd5e0c24bd3f2d42cd9dc3d0bb2a74a9ac8c53d7408a1ab5faa963edf1290ffb86c834b3c4d598cb74e4b8cbba4f1a17e55cb0a00c323d9f0ceb2ffdb2a4c2c987e28c4081803c68005c723a97be60dd063e1cc3c5afbe232cc8cc03f3cb85a1cb6c746911a82bcdfbf854984f3a0a6b10e0e873b41ed9c8b1b9e1145d7984de80fa658e2159c03224940fa51d0532fa912235fc34436c3d35fb56c9f26d626b5143011d40899f6cc13075cf8487204bad49a2b7df67dc101f66a040085200d6a2ac85a87ce32e43e4c8815b410d30ba4d86c4d2e565de16646e8d1b4fe2c2526c7dda7694b72c4ccc26d1553e9ed48eb7d2a9a8afcc93ece0edd75434d392a0441012f080b9ea7600f211f87b6f26ffed52bf2cc6a91a946a0f977d53ed034facf6eb0ff9657b2685a41e6a538bbf599269ca27fd8bdc9b4a35a8824eec9a61a64f9908c0d4b981540e7a4496a0e08f216f8515f25943d02261e4c06de4aaa7c61c1f488868ba515e24152864cdaeccb4ab42fb42de9e77690822d02c2c18f81aadff4d2596cddec98dadb0b6bf94da5c974f23c992579608c2970512a946e162dec10f90279cc982700b95e0ce6416d6c4b7fe457ad81a20cd093ca5b626ef5ed9735c2dddcf17bc5395eb02eea394ecbb72a3aee6188ff54004cf93bde62ca86fcddbd4efe82f031608881313b21ff48fb95a486ab8931efe7c97e4315b7d778349ed7956f1cf555f6b609660a91714e5ee72846b375acbc62fdf0c6e35a8205766cf17cb7ae48eef1dfc36108333555ca37ba8d9066deaf2acc709edc985ac3a8601a5e47d77a8ab206d21b2c145348d0aaee3142f6c565d51f3d6a8de70ee935889fc512a27ba54fbe372398e910e03daceb7b69c5f92f7dc6ad348ec8acc1b54c621d8f7a6a7e1234c07f332e3609d0fec22446cdf6b24e6aaa136bad1ad3018b1a87a1a0bfb6d53482d84f169cc24107cd86d80a93646b6e241290239de1c7df9f532799ba2643d596d75dcaa78781eeca0e8a35df6600b1f7349637fc9e6f2e225a7e5dc76d2a0790692adb78d530cfdde70e090236ebe3d5208e8fb2359fdf240f074bb28abecd084ee8b5cd586df7684a86193452f0abb9fdbf5ce467690e307feaf2d87d6fa1ad87c86329d889be2387eea0cbfe8cb47ca1c0ea71249b968310c6490a0ad62ec2e2d50fd96b6559d5448ef2516b5ed2454ba0ec14d81a392c582f897b66c39d27b74a2d280065ae5b19932794146eb326d7002d26bcf8a49104662e08ba1c7ad54d60a33237bcfb22af88ef86f3fec605927fd84b9d28246bf362b71b1a35a40b3e0329aa98f4dd048d6e6bc9e33129b3e3d833e52b25e82b0b0f5f5fa0ed5a8c8cce62fb0a4bb5d9623d79a44ac6819cbd1905dfc08250c35b6cbb143c42622a54b265477c8dbad3ad6b0b15649f8bc207fb975946ba8726c0fd01508d985c89a3196e1efbe820b086debc5bd4ba00a9ac64952999158b95afc94d47d3cbdb98adff0ac1b97d6fa8da6a45d1c5b2320950a9e8225362dae442f5498568087b0d147d1db398c4afab809496831ddabea1ab9005a0142a2e249220fe556bedfe23f720093bbf79eb1c2f66157a35e513e4db181a592d0388b15f9f36f9c30fc204695ea8e3489dc78e87ccab0717267232f1cf3511c0fec9830cfc2ad8017ca7d08ded9da421650926c2d2914c387706964562a56fcd64f72130fa5a5658fce1ebf121cb2baa439c2bdffa3a65ec04d6d309324c100a11d1a0b582063c4829580920b810ed27273c16f429769a18876a01d317e4306e43eabed9f91b43aa8f0e5c1ea14130dcbfc1a4727fd489bf52a15851098f4e70838099c778fa2feeb30772a0586d66eab00a2097dbfc3fc4e56a76b885cfaead8796d4b2f5ee4af6067fa8867a929f82030bf200af1067d11ee3b7e2ea5a03255ddc96d7f5d0f86de9ed46153f9f1204dfb167226a970709bf3f5cdbf0740bf60911cc6bc318c2c2c18a909872f44b4d9182f1eeae611f6fb3a8c86065473196cf92fdbcd6eaff270620a031ca76c940c1a414e807d1e3b95faf4333eeaee65d5418bc02541291f52d8a3c87853f5101150ddd3a4a9cff3c5c626343f4409e6a72afc2be6561af8f078ee717d191d758f4db1a9dc0e37fefb9f8f40fa41c99a567cbbac43b9fa58ae2237da470874a0e9d4ce6c4f119bb7bf7ee1f2eb609d4b62d07d2bfb40a854b6ca967216bc5825a5dbf69ebe02873fe6523b7e694c13095a90d90ee9a168786ea75c49f6cf679b985fe3d083d7803e65e4f500b858660f33def656f5342e1ec5ad43c5bf1836054791fe85515abe8242c69c0ab79336c697be6ce0795f15be221f3997170c8be09cd80833595a8986270b0a11f505b8470acc14befbb5290a44e0df46cbb07e766da34c77db41cfd398df045feec2dfd67210e5d533df65f7be5f27a0177731e123a1f8427bb7a3051a9778e866a32403fd6dfeffce814e2690bb788eecefde4e717ec468351eaacfce7ee221a61e2f5943d0377c40fb75ce083c389103dd22c288c12e44ba2eff7ec2d70a0d25fd28186a6e2c62cd9a1f8d7765ea49dd4c7a71aa95bfcdf455b0f7310342436ad89909a73471319374b1a31731e982206c2e59933cc52d42753da9d7d5c4d82c10dd2fd70784181e8742937d937c39631f35b4990d5e7cbfe517df37f8c6506198c112f5b2edc6f5ddc34a56a233fdb315e52e0873f6a45b93c3fb6e53532b0c47f1a0217c5e537fc92b49ce569b9eb94f37669d4a52d2ca65dcf3ff8074621816f136736091c0999ca8df7604a4cde1b1c049e3b58fc6600f8f0ddbe168d725c1c369657ac9a8d73ecfba89d7d17ad9761943110009f234bd37f81ea68c45cd985938134194adb61febb2045385603a2cac260ac117a716d210a4f3cc797c01c05a2ce97446e486f13669298b9840d2f16b9afbbea9601012252ff04d0a7864ea54da18ca26242f79253548c1945e6307d7936f74cc5db27888d9772dd7c8282474228db36d5d1066e6de2aec04ae47adbfa9d211a37691e26c6bdeadacd4ffeb90e2cbf6beef05ce33684cdbb9912b846eaea1bd64fdfb547e57fb03d18cf2a949b84c907a94bbe58f4e02d2f4552fd0cbefb4aa729ead0e5e3213a12d82a3aaa014832fd907fc21ac9601322dd3b74c322fa75fa1e3bf8b6cf0d72c95097aac61f0078b1168b7291f03c5ec46b6ec37fabf583f6fff944ae33ffc138f9563e14fcac5d73c238d29f36a7fb65d6fd67e103bbac466f4b38b12f789678029fa18ef698c2f3461131c4582b60434d1ae9b3552f2699e7d106522805ae0acbdf92aa09add438abeb8fcccf77807d46057d09c3608932120389b77672e35b1cb67107f9d89be86765294fad38c81d1a3223b058fcfa66176394ee88e153380bf172d2f15af7826e0a8b171043d20e851ec877bc6b06a38c3b228608d7a3035997cca6e6defff3f251de0c0742db9e0b327057cfa6873e8f65a99dea9727e884fbc2b6e43deeba0947a6b6aac3117710be7347d2e875c6cdcdf2efbd248b5aa337b3129a887239cbfaaaa21b16b089633537a916721b2f8a05cdefc0103343723710742761d013594b201e18483b93f8e22515c053373a45d8a524678539a57596f58823e72aa1ddaf04077f79fa9a61503dfd476c825f7217c7794b533bc8a28e2a68c79ed1485d838168f0bc6aa6694607b47cb3f53f8a419cb6cdcc4e32ac35364398b5f9f2a35c86fb617c78535f5e6ed0a31c6adbdce15ffc8db4d4b40780488453c081077a21bd1b934e298e6171ea67d96390127ddb14b8220a7cf931d9a0bc04bb65723405a749f61a99a98ed76a79d6706b05a816387b35740990bb5176ec6cc832ba3a738aee8ffa33c375041a9907ec72ff6f1e3854dd6bac78ca806df4c194e9bec645f33c16206eb190902cdd8f92f0d853beff6d07bae7ede04009fb4c5199777792757337820827717378d1a0e58f3c5f6a79f7ef8ace795f603d60a247d97c1c6491830acff705cf219f4dfd8d858d636240f47c5abb226ebc5d21f718e2562a5cd54f011452f95561eb91c23bcf39332d9b4cad9e57379f9788966876d95c56d9f73e4f31875d46b9c48240f92c0e44668fec5d0259e305048d21bba5483064162be4598758263e26c34e81c8de8076f91f1acb2d0ab2b9194097e51360e57e96d69d838d18c5e712575899e634893c7698106a8cc8b8cdb05cfc170704d138084cfb62eed61df951bc29b6c9b1b122e20418ca6959d76dc1beffa5c7f87c147385bd68cecd2a0ac76bb3877dd73462215bc33ef63a498defa36e3b248f011987b5c21ca80a077cffa8eb0cd7410d5518711adcf1402c0694f4e429d87477effe8cb6f58cdce6c81525bef9818a9fe4fd86e55a8952c92b669138d377657016adb56c2df22c72a80f2046311c44ccf7de061c6ca7cb14c5385a8bc861fc0511a1b7aa13b12ae490aeacecdddd2a08460342e49f3930605e7abe09ce41ba628bde29d8bc7b97e460781a8d0c5b1b0229bd5b1955efcbaec7f8fbc3276bdc8c24a78fea0fc0398a3db2428ffbe6f171c6a23166e4b2d09687224239db009b4b6f90e1d2c5c02270a93d6854386e9eaaf06fd184ca3161f9a5b878bc0cbd01bcc6c897d648c94df98c885885bf3358b7c2b7f66f314c3c069a63e63757d4279c0f306cdc741df34a5c8bb0d379b6638e921b3ac507fdf2fde960dfc678fd8aedc12e8ac3992f8a004c1a53f4c1c7539034c51bab5707112d25d604fb28e3a542bb747be50bb7f0af49cce3d4b1689ab34796f1c6a5902fb2f0d5b3012f4cb88bf3c69752e7906008c266049b199d7e6ecf15d842ef8199bfac101c3d4c7751595bd8be1bdb0131ead6a437532751cbc990dc9af4396a4a3ff440941bcbdcef695160a80a25f976a8e31f00003bf288cbf7d74f778fbceeacfe3fdd65a1a7111ff40fadf99fd471e8bc3c02f2519581f83601725dd84b85dc1d202deb65dd2c62472629ccc5a2aba8466d0ed2f6053c442363f41645da02106ea9594b9745ecad4296bb2b8cf39e1cef971994f1d047a0ce5aaf191bfda39a3c6496752037b32b359c41be2cdf5d2490e050514b1d8cc1ca480015aabbf7cc9867c1bf0671f5b644f9ec2dad0afbc3321765c782a560053ee150a1c43c33c5392235d8a3b022961c8e9bba4413c2d072d36076f56daf12fd25129652f8c19746c72da9a2a7d648178156659925caf1bb76c11ad6c3884098869aa6e16c000c5aaceba370f2d1bfa871096eef7625f76557956ddf0337c6586c9e9eff6790b8f38dcb7af98cfb9cfa717893ddc00266de86fe5fd3815a2a1b289f5060d2905388f5a17562fc9bd89565e867f23d16c28ed93d01a3ecf6ea4ecd0ad6a8a17992eee0657df0d827339f962f550a164563a2b7a95bc7f491044cd5038ee6fa201a3c3276932d7672dc2a31ea90169ff7abe831f278f39a66bef0f3f950e416abc39c002bb8d46c298e4412e51227eab3ef3351895f58797923d084d18de1b8c169e710874d5ae8c5b1dd569064cd0b22ba301f9350636de3cc5ab7ca16a39501e41a27ee647f8012a8459f1f2d451c39dff5d7b8211dd83063e05149be26d6b964e782f6429d81f3c7fda1eb636837d6d00239286adc9922e1e9bcc4fa146cf31517254777155c66585a248aaceacff16fdae145b2bef29eb36eb7a2548295092baa823346e27f6161931833c63dc2ca90675d2c18c46bac1209b1b6673609a4283adf93fea009f45bdd0f0ba109002cc28d459dd39531a2d02365fe3475ef9ef0c563d9d7359b164e97a976a18ac1542c47a1683ec6f37b42a827107f8f23a2da18cfa99957f5414e2ec9659bc277ffe9b5f7cf98ebd83de05f3ddc7ee9e7bb3312d024ca747293c87fbe69c350e4638c2eb12d1b4fdb7aa341aed64b9796350ed52915950d3da8988f772de98143c28274287053287a756ca177f0bbfee0c6a228a3746c86b01b8ecb1d47e0212c4f9176c4e4d57894896878764847a02ad4ed0fd23fe09ba674505970c3eb9e14ef46bb7c20f51d66ce07b4cd6b9a49bcc124278e5b25348ba638cc8d27865f45aba1f0f647fb2e092759872b4d219324b58433d1032f28387fcd5564489f90fb26e6b89b8e8b3c49e4794ffb5d3bf88840e10732e39d41b87bb5a5a095bf4e49145dc7154b56f6fc059f2ac3173a16a4a6df6ed9be2b4af0250b7dd075c5945f3fdf16b00afe459c46b1758376d175ea91ae5c831c728c6736ac2e28b3a1676f90dbfe3e43b55b0b2f49fb973e34bcfa462aabc3b0ed1de5aa7bf489e941a72af02c1c834758136c9449967f7d884de562d3aab50b135760b28909e831730ea3b953c7b780b7dfba8fb091bc9de6d2790643a25d1e6b615de0e768a916be24aa8f543eb8e40cd17879fc960e47e3726e6ec3830480f0a89391e4a98dfe7d5595cbeef30e3503d0a1e3f26e823173269c1376decd25d0e33a36f01e991235f2d9d12982045324fea5d389cea7aeef7f0ce0625aafcc94a0b845cfecc413fb995d6f354ac0d3428d84e3b6fa98c102f0b3d57054c4a7d166abce401a8700fb5723515eb00391264e6d5e2249ed060fbcadca1bdb2a9f0974ecede31e92f5a337bfa10d717e08c459877761246cdb75ece11e1d86e9bb03fba436c1e721609a66499985b62e79c8dde06d9ddbf829c4a6f7667d9f0701470cd46f24222779ac7e79c8d397fa57ab4b1fdb2da98f2c708b8447f819443b4ca2554e6e71bdadc94a65e217fb47c3366b04486e60e76721585b54eda01ed6b44aa32291fd4f89e353a8c835b566a137058dda60d829916cc2a1e317ecbb6f3b90dce61cec4e3145dfe23e503706126e168ca6bebf2cefb376886600fd33a1abb9e7ce083a0828c70503e1a43c9cbd3d37d184ac3ef81650f3f7f115bd6444bdaa817b23e7c55eb62af44604eb2bc6be0eeadaa29f6f8c54153d97e9f808502603f48f7d4887dac1b3fa435634c9cde2f706809554d9f8ca8bdd01e970b4665a7b7be797931868fb777145f3b10cc22a3c46d2d1f297356b1cfdedaf1ec2699e19a3deb15864dd8b5a9ff0e061a76c495fa486fa1bf55c8f9d1450996072a1b9622b9caa26a836272459027f08758fb74c784c1a9af0bab39be40cbe2fe766db7f0308507a1f1662f18ea6bd8334da7e3a985ccaf4c166585a9b1662d13ac408dc9fdfba9c5a4da1e75ed30cab2fccb41f47cf9660cd50ac9a4dbdaf4a95c242d9854962de8088fbe78ff9aa8e1455e606b43daf64e0d8106b86afeb86834373accee2593d697d386429c3c4f2a29485ee8200a9bf09c81bc7a029d8c2246cfa82c412f5524b897f2a2a24a236f6596b753d778d71d03e40877360633caacadc3511624e91970e887b9de70bf71e20f8f39cacaa4c06be3ea02f126bd12e064fb18dde610180ecd14cbabbebc7c7b0562dad72004eaac465b7ec24663d4388c608ebdb5d86305e3318be57cc669c2309cb90aa12c922090adabd776f62119c95bd5bf4e6ffa4bd6b6980b3de0ca4416a7d21ac19f90361543baf87668cf89f61aedb4c2dfa183f931e68b5f77e4fd257c882526524be0020e4db44a0539a3c54357eb4255bfaabe266e68fee59e67e380a5a07a4b93f34dccf2e634a78171008ebc408d50322c98199b95fb1c4175e2139d91ece2b832fe3735886959020b7d843ad0323366e0b38065251b633a051427786fc92a78372c2a2c17c9ca7f378c7f82f10928d6975e6acfc753fbab574e3914dcc88d2a6a9e997d6c0cf14771874e986677882591547b219505a3d9b48f54af9303cf9a8f04e8f94bf50dae6fcad13758f41722f0940d79ce95723d26e895ba070eb7f1a225eb11eeb8a0724f275bab9188fd4fc54e5b20488ec5b126e8b8da5d429ef1fee38c12c676debb014107f4a6f4e984b7fd0c31fe80318874121e817e0fd0704b95816c56050ef39c33034b7f31196220c61bbec3aab0af9c06ef5705fd7fbeb90f37aeb0bc240c3027a771eefefafb379d77302624d921618ac08aa6786e41123a1665847eb0398a2afb415518870cc232cd2efd43da0968980c78f5566426a0a753f210688ed823954e12faa4f10146762dceab2112782bdaff66e6557fe83ff15841006be4abb8c75bf8a1d8a684491632832321bb06e92c00212b66a544016b916027ec0f4a03d86e10799e6732640b3cefae79bc2a275114a41f158b29c5f0bd2b71d106e38b8f091858834451a7c96e98f4b676ad3826e4ecf3ff3ce4ee1b06ec1f51ae94320692cb45abd8722fc2f1fdf035e3b30f5f5c79b9b34968224c3dcc743917b92bb05e2975ab06ec934a9480931d7dd2ef1aa335285719be197d6ea08f912f21d940f8e021041d63fd26a90c83e8f39ce01faaa86ac5db03eb064e16d5d27fcf2b123094e14c002121424d0f66168e7de4df09050c90d3070bd89bd2763b3869cc405b63b9ae31fe927d2cd7956220eb87c8b05fce44f19a7181e9adfaf8266e7cf056608ccc1e3accea43fa2e2e4195e49dcc00021fa410de59fbf47d230defab8463efb39a0e5a3c632c2e2d38ffc86f7f56cc8f9dfe48d259350c1f0913e7d1edaf89330830aac5d3c0db51c5ad4c8df0549ccf9eb7b7d74a16c4634df59124e3786deb28b0a476e4d5462c8f8c9b07bdf5251de830026f9d2f454ae704b3d2363245ad380e34485ccc85a6148ff6b7813ac28925cb129ef448f69b46ad544de44da3b4d7083997094d613de7a1f65c8b161cd8f1489c785b9a7e20717dcc69fc3f11d305767386bc39207c9eb044672f6cf8e29a35219b798873eafcf75ded2f38fe90098122923c67e17bc491e6003f91ff4464b932f8d1069d95c87f62b7784fdc55939c6c825e3b45c96c95078c91d009623e0a031fe44a5d3f08190e3716abe7840970e692305922487acee3d1c42a6fd56b69231e0f49385cbbba6da333ec39d6931cc32fbe32c4047253ba372375c98eade73e3f8096c9f0f8ac979bb213762ceb6e29a04510594f4d23be9721cbe8e48ee333ae6424999d046c3d59d7e46ad3ebae9e1c02dcc74f28dfcb9bef65dac3a5c69a643326cc1bf587d6d78882af461f994ef0f0d655645150f02bee73bdfd36ad11704646941f9d24854ab546d7ae93705e26041d9ea18aaf272c5920772f2967d55293bfce1e355d89c6f260018e6f294b5bca6430e3334c375dd9eacbcf504e07c661858d1cd94efd375c32537a2ec5c3d899f2690c62c5728201f8197601282a6e3bae61235b163196780efee424be9ce1bbf0af4b77b4632eb2212c9701aadac4358ea65ab9959a33852d3170100715a15a98eee54bc53505bf60449325cde33e3f25d90900b4f5314cc40c2e976735c76985cd9bdf5ab112b3ef4bbd15a52761d99a2e8e302a987328cad576835e06ea4d845c7653e9d4c9cb9885cdb7c4e6e978cb1bdd86db7439292936866ac7e8bd5064782f81a3953dd02661a723b809968e749fc3a5d96e8fb5c1545b6150e3028e6282a78905a89160451152650efb49d1e2f97bf18d33cfa336b7f0cb43b03e6da0f51781b130ffba4c51130613ae99b526f67ea548514ebfc86f2a6d7865b0eff4d03fa0ae203807a28dd6ab3fb8a977ba52ef325f139b543164b9286ce8d5301892488857a58fa34217f8bcea01f2a422c77c916c2b2218ae76308557fcc392dbb42044ce318549ee0c33605c92c40a448e7bc6967dae79c1ee51f9d5a91cfdafb076103882f45674cf853734b758a1fa65bd6dace4f56de0a6353ba2ee228a99672ea2c96b72736abe619f564ee9db99fdd700cf147fdffb96f59c3f02e34c1f6c15330f4852730589350d9cee77987a0d91ab43bad964cecd9d3c8de169aca469e843edeef58a9facdee9fe5ff4fdc946dd143d18fd230960ea627e7b09ab2db6837a79f958b4591cc0cea7ebd97b7bb80523e059ff023d25d9717a2143409a45502167c65b39982ec6b441773ee56e70fd1fe1ec4db001ccc9566a84f49783c651b82ec0df7be387bdee0502d914d4884ae71143e1c9617cd4dd38d106e46e4eb3695afcda07e76311f745ca3e931d2d8326b30fe00fcdd3ac056539803c93c92f39e9d973440bc8f48eaeb916f57769d8c2079f07a4c3b047d653e45ab7c805a7135619aeddc4756bc8aec6e1264fd23c4a980bcb36bcc4b458d1b7ea79c2b77ed1c8ff77f8d93f523ac93247ce850c8e5e14e1efcf0d31b8d4c1c8294f7879e9fe073f1ce5715fa6c44cfb3e5dde439677be6f30037f1622b75b40cbb9d27c5c1f0f965d7178154af3ec1c693c0242d5a07409f6ce263c8f6802718ce12fc72af24c8922e39dee45e467f5f5e04cdb9103645d60e39c2457c540f59835d861730c815fc0ce5482cea151f52fc3d521d19c5f744a32c5b948d766c41185738ed7eacb52f926e559aa06e4fdfb5f9fe911c92bd5d295a0e2df97702b2dd2cd3d71a4bf3a4ad2a9462eb35423443012bfc8e497fdede0e70e49bf996e3bd468951bc389d61eded86d3fa943d5c4db7c01c4e706f2156ee8ddd567d924060184db629aaae01bc7ed2c8420e87e0a09949f49a489ae934103cbdf97f293a601e3ab96757dc4e0f53e3f6ee17e2187c77389531ac25337ac9d13e7eac94280819515af10c0cda2de8c12e6b30a25c942655337a1c8829738a55ef4cbccd21c1165629f7a0073ffd5b7ca7a3433ad129beb1f6d07ad8922a355d48f33be32be127753b718e4c38c171b05075ec7ab0a60dd08ff32bb3cd5215db0c21b7705bb7480491ea0d6a7c8da3f98d8e21c7b2500a26c3076ba31495d1e39f3416d34d4af6ba2e8bc7d2b0a5124d159d64eb8365189a77bcdc176614e504f76893d5ca1a622a38fa56985512544f66e840b0129eb485ed1b70e6a464565eddf2dd601330aa8f1fb5fd6fef4961ec0217c2985f9ad6c20a6f021a9f1682b117930ea6cd458f7ae36c95cb15853800fbd1f5ce21a35d39ba2974abeb78fa7bf1561d38b0b2e784e20cbd6566fb7795ad7ad1305ec824e5e87e311503307eb624df536ec2fc46f5e2f7cfe537dd39c67686cef56b3531b6bd48594377944f4f3da73f9f040a7b71cf47894b33630941128ed5a028aaa441e5caa3f818a6562e520c4d7c1812c5a7bfe8dc869d362fcbda48bb39382cd48e3a766e12ff2dbb91edf0721e1f1aeaf2939cac7ea875e17c4d14735e2eb929498383107315cbfea54e8cbf1b4ce2bf8dd0772817d1fd55af89daefc79a8bc0a182b690f75ea309e28e68294d7ea773b3c9f0273a333b2bae1642fc51032d19468d1c3c9d9056ec8036c5c5bdd0b06d05f8549fa2ed7e0cb70eb4b27573d61b6982b08a31b0987457d5a62ab57b9e78518a0a81c74538b846595707936a8fbb6258220a5d2bce9e3d51d548a9fccab17db2156e0b1862108139f4ca8709bd50bf11070c47c0ccb67dc2ea4485f229c280cefaacf82ccb291c793306d066d1aa896665a91a31824e5df73d9d0ced15f4297d0741e8114faf438aae3491c6263e4e7e2f7f96ac2e1e6c6b7e2ea875672e9cd122bda43e06af8d384d94d6af11888b4a0f367d83b422cd2e0c5e47abb6d72c946d97ae0d8de583bb969603e045fdef6a22ff2d9f3333ae5c6d1775fbdefec00f48c7b5b55e20a21d03ad7e7707719af12a2c151cd5db7d5083b4ab3a1808a683acdb4c620093a8d9098a3feccca8ca37738e6625400023482ee5e91043875323d6e9750a9b9ddcfcd4810f913e7f5f58a40060196b13cb7e3c9009db3a10642e0b758856e858ef15bb49d15a2dca0dbcfaeccfab3beaca2ac009777e1ee4759a5aea84cea95f85ce5296c07999b568f8500281c25f52c6ade01efd3093435bd08d47ba601fd2a821bbddddb6265696043c6f62f724f62db8df201c27da002ce71d36d564092458dd43cd98e57a177fbb7951e2a819f47324e6f674fb688635ff33f9f351f82edd8b2847fb1df62d5f3020c7c90dcdd6464a012e299e0d4ea21a348d75d1fffa100a5f3457faa9cdbe6bfd02fb972b20dd3b7cb5cdadad6ffe74af0361847a04f14cce2128fa5f45c30c668809f5ee47c0f128b9c8aa7737a0a274c133be187be65fef407fba7547dd6aaf2b61addb9c872c2df7f8e48922690c5b7fa3e967cdd7fd2037fd7a8e235bc5aeb7cd58a3ce0b53713ecc9a725798f0d542ae835f04fd2decd0ad3dcad57924953bf9829633bea32943e4e5a36abc24ebd1482799cd3e450c71199d263f3afecd9b00acf524c8ae3e4e6eb3255fc84da780dd223072d9f0fe49068c51e1d90a543497095e0448c630b2b92e619d01f95650717b9f7937b8861a8eb08ce6e9d2345d2fec1d5636731ae0016ce8ac5bdc1ee7f3b4b8ac9e4733bf43ab0f851efa2eba2adae673b137457d80b2b976e56154ce34ef70d0588485606bf881bc709256391873f2713794daf9d2498ea4444f82b55ced84ba7fa57091f85babb648f03ddfcec56aaf77db5cc0ac10c00592302b6f89dcf23dadc5db9dd8721a141111d1982132974e853f092039c43c5cda3c569745de97a093fd1d51fd72d24b8b843c56d1a04b46046ada05608e348f4a5d7b6ac6393fb70900efec04aadb168dfcac3deda36fcab6fb1090e39ebb50c1d476254eda513f83c44cd82ff9667db18cb74baf5d24bf8d7c51c432fd238e4cf8d46f1a0febea92ca8e773014cf5d6507e6ae7f952b1f81bc6a95355ea8769a556d72ef64fae41b2da1752e020678bc6604d0a83801bda2e1d4b02c73da9942b64514f82c6085f129f4696f80e1c05ac0d7ce4a9b676aba45200e859b7ce2982879b40307d0e1a757a609170d47cf29b13c9503e2dba0455d45747ddc05a2326faf0371ed807311b18f21eb81f498c49e7cc22cc6aae1d933f87de8c01f57c1947b87c0b85cc662c4e989601d60a72fb9206c576723c9746db22f20a5a19471aa2022663d1d1a97e63ab10a02abba516e460f7656c6564292649426c415b5171b0e97b68c4908a67d8f8f1ccec2972e2827bd9c29b27bf14861052a6b90e7a9b992f9f6b623d6d527dda7f3a5d53df8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
