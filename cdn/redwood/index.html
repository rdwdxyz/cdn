<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd4f304d0419c6599a14a37266de35f61596b88b4dcd9a5d91ecdc4090b627239fbe526d9621600d47283b0f8ab417c6a3d9faf4eb3c139f56ec3c9701d0e6c17f933ed88c84b111f53cb556349481c7df575efd4ffa55169b4de5fed57486afcafcb24527e8c2b03875feb90213627554d39f620761a61f139fb7005d0610729f3aea491ce5358320a295734a6f7ce6b81444de4dcd0d46d8449091e2a607734b64a93a28a379e1e25c48e2a1d0ba81e0780c495cee51098ea5ef71e58762a8a57cfc9f6a89a99b49fab34e190bfe3ab32427eb9620672f0f7ae58b59978e76c8e4b76e3b21ed82f1dbf4d619e7bb5d726701d1cce5129f6e1da58420f031b6c045556809cf683076a900789cd7ccff136ca8bc65a29a97d4602a0ad0aacc73e3d7d91a97bb7a4bed82574a8eaf3ae57bcf757941d34c2a01c617c29671f7a74adc58ae4eaf320ae73707942cc51875d5e09d92a0d362c021f1758409c57c2ba37ba4c75b62a0aa4fbf1eb48c3b28eba391a1fede54405afd1e566bed9a870ee57a3d7d7bab0257f3c48dc90297efcce26df18d01e3c46347af1acd53fad38e4d216bda6725f931fd87fa903162d6c92056da667a5906de3f5eb6d05c5042cf2fda99cec2621fe2c6c8e3dbac740a0187a18af1b39aa103485117b850ddc26c8392acd7e02d1e1379824f5414cc58d828f5415b09d5cf15f69b6d381878bc8a30866839fc7d020ce7c99f86e0f00ba06b05d55ea0541d96f7fb7d9e8033a6df7192a2e92370d0fdbdd4fda98414d371105edf2ae9d6e31e967031c29bc66d1542fa4ba2dd29786c51ddecf5d73d5571b7f4c90747c642091cbaa5e2bdf55cc54fae2372e473a62b2a3abd0bace2cd6a9b856164f1bd881675640d48debbdb31f333b17c1cecc53ff866c45ebf0de2482be157d18ed34ad9f2c250fc415a4e06b7d83d850ff968ba00a31f77f53e4c85a3f5698b946285a7e04821e1a109bc43180f85aec750738f0c06f979860a07d6a9a6a798f81b8ca557859da04793b516d4bbfb6351f87d70acd405b111305454048eb08a16e5e1b638edce16d1a04c192f1041812d1c4143ce81e96e06c03b9c9074754f4bfb8811a69f4aca4fc4b2111d7102c965295f35fd436fc5d0b1e36cb1ca485ae547c457e380c78a9b72c88f7b4cc040080386ac2cf8b4e9aa9696be32ffb1b95b4026a16ad158d0848d90d7d52fca3be512214def388e298311fc2c502e14f9abef7be87ec0ae6a845d40e3fe480de0dd85fb0c35aab37ee71d8425e3494c09ffa98c4c9349643056d4aa9497c324adc506b0d6e31baaeb994233c240c102af584aec40c28c76f295e567e74e45866e5d28486691daa7fa87bc1e2718b626782c787cbe24e230e1f4db46ab5db6366a43f2b165f8a9f7882a4125fd99e71a6345e0bfda9c729ad3fe3b1d4db0ba681206055edcdb316de2a7bffb74677308dd1c991f649c86232931f8b5b9df6fba7ce92cc7546fe67798876f22f5d5986b48f3b3340cc66f733c1962f5d037a0e86784034bf828f36e8bfd6f28e760ac8ff2f4b76129bdc7cc753573f3569cf3bc557261de0d46481138d0d36f9743b0095448b484da6209d5c1dad77e128560099b2af4d85e9df5d3ccbc03bff0750039897f7fa4c65d24083e98183945f01db34fac69b1fcd1a0c7a9009e95b7b4374a14589cc3f1f439b7f547ba23a1313b6abe1952372f3e0771a45df8c0c83e819c4d5dcf69fdfde5d2e71107c0438f0a7df730965f7167d9b64e4ea01d4be693d7b18bf2de98d368d6e358e328821d38b266fd4b5d81f642aa5eec4645cf7555ed5c29f3d20fc814b1e45edbd64d37933b96fbd97a753013d418f415bbe7a4a9fc8985089105101def74df51287c988c2aa2746c16552b9bc2f4e0a4e1272a6a2d200bb9e0f9ce2aee8bb6d5696dff38ae051760a170049931c4035c368dc20e27e9dd85f253f15d541c60c7fc21e361cf96875a2b8a3f776182118bd4d1f252c0513036de77522ef3d5102cf5e687221ca6c522ca565dba935ecb60da4fbc974d6cdd8eccd9b4eb490b7eebe1d7af287ff4a44e5040747e1eb2d4ef736a68c89c7dd4a0938ace797137500e9a771db74fef20b1f1b359bcf656f9f6aa0dceedf1ff789e3ee638aa81a2e2055177a1db67d18d5379097cb1225dac26fedbf8f9330e6aeea604c8f9a62e7a491d6477af6d9ed3d0c647e9dfc3de4e0f9973487be282505524b5352368baefecb7a46fb90a18b3ebc10536e5741c7ec376d172d7a5484b177e5a07e94beb82cda28bb9a04e666fdbd875151a54303d0569c9275d790a0ff5a07d881a794bf8334e747f65e73161bc47f7c46e35d83b11d59baa79ab69d9b87e5f5478817bfdca7db9d11c99e461d3f9377d7d420a300b553660390dca2073d4500b090ef65664b268d768fdd58ff87141cfa89b90992cabbc5b97d906abfed2228c18de9f528538793a4fd86fab80b11fd272e17c7808f6cfb4611e421c008fe4e5748c1098ae91440ae18e7bd0f77c6facaadc839a31d698201dfe3a93a1730cdfd693e0dea954e9c84694dfb5dd9414b0db61916e56f95dee176cc02a812be6bb2dfcc0248a0d600c6c0b2ba7c0ec64269355f4e71193919ccff31d78e75bca849ca7a3bc87008ecc2e0806d2bbbd13309f8c91ea40d11ae16e67f50ec0d8f89e9403ee3272c74c209045231d7eb9d6e6178849df0a74d79d5ad6065300d9db81bfe3bd65db42c5f443a7004a3541c9dfe402bfd9cb997f92d498f9c7e92607288719430eb342fe513187b087e7f4310a6446877d8e84a8f904b38409cec5dd7374b204162faee16e7e44c622ea6cd59c13fc87dff24ba18a38edc14b2a2da19058b301fc9cf50a4ae7c1d0efbe44d0fd282cefce1ddfbf2c8db8377083f56a46d75cd6e243175de6eaa46de75486c70940103bb8157036711a1b5375b820d6011cbcc900c3b3e353789c833e3bfbf0a63e7ea79fb8a8c6f999652ce192e4304a87df1433308d2de4106f11e1c8280b5671a9e8bff27b882c092b13ca0ebb7891361f864f774134397ff41e4beb48194304e9f77c1f1369dbc011796962904f89e232d7ec4c6c4f1ee745c395ce889bf40ab86170e82472f05079c72970de00483b5dd3eb2e047336d45268c335284e96f80455be95ab32528cbff12770354deadf6b0f2cd5ca45a3e7f851665bf8ff17fea49ceee9069cf26c1b0750e75a677075d388f8aba0e692d20e3785d630e2758269b202e34ca686eb03f48e7f9469b4699dcc20c0091235127161f4c34ab7c6203f528cf4c40ef7df5f7854260fd7a36ff4ef66cf8a315ceb142557d6f7a54aa39a641d6fd5e6bee74efe128f7d294f026a1adfeac25ab55d422a4c8f172050c3838b2c693134e4bf1d6a4cd0ddf28fcf2eccc026e6b1241e87fc1c23383bbc5bbc098462a5809872d186978549715e36a8c33627419c58459f02084ded5ad0ba9c810e60ec579aa26e4e6694be1112ed8b327c9aeddcf974bb45cc899489900288f145dfefdd4573d92320dc4869f2f21b6e46a9d2f2a8d6c237642d8ab9cf427adf7040cbf5390c82bfa1ed04b931ac317f537512300b6f4210ac61725e655f2667039311530b130e2edeb09ea7de3a8512bec894b4de4d38ccfdd2f574d85e675d71be7596ad043500d62dbcb7edfa6dac5d9fa8a29ae4eb577174ca856caf7e7c033a1fcbd063291d9b4ab64a82c21bffaa70bd9e8ffbae0786e4d8a5143d7102bbd0efe6dba3bdbc54db952a5ea708247055403d153d3c5dc38cd849543b647d065d5be5cdf68f534dc66d385dcefd8e5c020b44d681c400c3d4d79305ccc211ddba60d9068f27e32e5b640a5c55b0bfee6b5bd207259c0b2f4253b137ea434f58ebe1aee2d52e668c864baa67a0ee9cd1528511001a2b773a7af92db57ef89108dd045de806fd612709c81fe911b04121d5922ce68886995afba5bad15e7aaac548100b6a3b6a14e9511dc4f8760bd76791465ac28412004a8aecc38eeeb7fae10880ab1f09c3a3c4cb4489124e17242c0be36daf7157523a057b31ed3b77dd1f13ad7454f8a098a911fb5adcd75d112bda669c0acfbf9537e2742922e8801463bcf51945121d211d19fa8ff7f8bf41bd1742f3c6d11fbc619537451c2ba4e822820d71a8634cdea3e57356a15bf27b6fe9749e15911c4e69fc07e73804a6bf2163165dbcd08baccf24b337c1605ab06b8d07373f083c2495f4a39fb868d1f58701f05f729ff8e60d10907062f8093b7971da3bcc277bf4e62e6b418d6512e9e8513a7dd7817f5aef94cce205ac85bf76ff50eaae89488ad2412d8fc6fb9c7f8a251434f1168ed75adbd58734c1e89775a94e264f92c7fe06d049b5657587884b393904da850816bafe427770cb334f60c9714bf3ec62677f9f7697c9a564b229b5d2b8939bf73a3e728f3b6879f1375f21cacc8d6933d192c2bb2e615c8e13fd4ff989c11a2f7f18d701075fbb7d971000e47abb5822e9418edb58818f6e3ce382d0601b483e8cb7a89085311f7a860db63350bc5fc78285c77a79a4ffc079e9fa42dc8fdc2e53663a2fa420d09a7c1e785ee47f1cf65caef296a6812b01c71a631cf08f2119de4d8b405934e14c7fe51e8f81befec48c594a1ff9192bcc18b2dd04d3ff13db91fe54e36e687f49030c22e6181ebf4e055fd5449cb2cbe776f40fe4c24bff158db5aeeb7174fabcd5d311db0302cbe2ff597fe1216a4d6d3b6165ea402120e7bc5051dbf83ba7d6b34c60cf5b312cae749dc9603226797653fe4fb921b13010e9ee635d640d94ef54fe58864ae7f1d2c9151dd78278d09e432db520f3f12c6c881021a2083e3e370dd50bf9c463654aadd1954be31b0ee638df7f24b31d3afcd098636558c60fb5df6034851cce39f9c113e6dcf11bf2aaa317579cafdf5f56bf31ec8671bffdc345ba77c848daf910d7f8694f0b51cd0c43389c0dae88a470081277dde877ebe69946d90dfef813711bfdf0efdb45baba7a0269e1ea5a9fb6cd9da7db51b75054a04d277e6f22c30408fb7027072ccc71121d03c59827872784d5562fbf39c387c04183874d980d56e93002af9b1db863ac1b7bad3ba91b44c950427921a3a4b1bdb6f806a563a137742c46040465966c867b5a237afd2380465b5e1bc1d869f691b56e07599fd01a8edd249ea9532ba77d6284f8bb61b8a2de04a073df35e7411e1d5f00976ca1e1cd57cb6ba610be8b5bfdc7b38838e5f282631c3bcc415639a5ac509b5704c3b88bf5c646889c46e2ce2f9075f1e05497965da7b09212fa7ec0c1a629cadc5957cbf07535daedfe314f341c5cf49782ccf7a8f45cea8f81ec15627db85bdd0c68ce7614c1d5cee973f82de011e40e5ad54e103add360981381ba7f19494a44023be218f6481229c5b8cd27967ec9f6ef094eb80df443123c9260d7821a015fc4a6de0b1aec8d94df2af748ea6456b16b66a6256cc6459c0cee970192f8189ed66c31bf2b5df68ba7d9bd0438fdbee592c49952a84987634078e0cb951327c959b643fd7dd7cc5128e1427d87e639115732ef6420dded193bf1d13460e21da5b7193327bff3ff7337c7707a8ea43c29cc6397bcbe8b510b54a2430dabb9366493c2fdf879b6d728dffc8ade9303bb014f105cb1268298904a905362831957d2bf8fe36f5a6e38cdcb25d1d43571a1984b8acfa5c4c32a61007be97c066612d3ee41d71156cc6b5c9a74bdc7b4b070e6cd0b372a41d8e3580a6e8bb6b17cb84e67f32a0b46779dcb2700775e324beab5e30a87584d5ceadd0910cd3eac6652b2009497dd9936743f1688d7fc3ce1e3ca52db19cccab479b781a82cc958fde990e3bb42fbfe475609237414047ad50d93bdb50d60bb6662d94d9eb72b72e7091f6b81878a9395d5c8127a657f5490dbd398010e5ffdca4baff8ec0cdd46e3daf81539dee2d7be0d30bc07f46cd31b4006dec32f9a5e80c8ca4f2d121ce599dc61073d3feed8f502c9c5e77ee6679d53738aeddf5390037ebcfdb8f2f70d7d88ef4f27e4f8a3eb92a309a03ee7b2a9cfa60d4cc5249f4935b73d6dd4b686e2c8f5c848a27761ce154ab5f53fb450ec42184b32415f47a0063910bd7fe17eaf7e1faa0a1bfb62f46fe925cd02270540208369818ea1c8e8e3dea856721ca24f3fa4750034f072e729a18e881758a209e9106af118f5dccb13e172be0a5062c69d72a1044b4a8b8aa446a2fd79c4608d37f4c4b810cbb8e7f90d700f22b7680dd3c814433e1f89139d87d675611db9d95d37ddef55bf4e8957bfe6991c9f583ed449d59a0fd47a97c9abf0d1c06d5e13a090beca76cb11fb45f0515bb506e604947590290c43aad4bc6c99003b1030d0585e3c5d3dee55cc44f7a2f6fb835bc97b5522e51f7670a3406fe0ceca3083aa66e7964256441100b68505453b75f1bc6f7d90650a37bed0cdfacea4ca0da279ffa4d507b0602a82e6668fa329b0ed6067a7448e536671a4518fa509328a72ab5aee80452c770770a1b91784c08a4bb9c9eb99bfdb64e5e7475eb720923911bd6abf732ad2abbb5022a3ab907b2d66a94bf8d8c59445ca90cd6b4415abe2af8062598947059b4796112173b7fd8da8eff3ca010b5a5a45cd77d1791519c3de8d91b392ca7aac4c320edbda625b906a5311c35b0b51a55c39fba177da77ca7e5dfd12b041486c3ce6e7fcf76019d9cd849069191a99477b363d34a0c70ae402ff926eab5f8041a10211b03c61a4933332bb6357a6a1a040b38a67f0b52058acd69733f6945b6eb8807712a67c3c802f01ce4cb80193228701336564efcddb6c404514ef4e68d5600b9a9aa35a9e976519eae4a26ba317a952f1e0fb9fd5fb86ca9634f5a736a41b3fc9ff02f2b2f4b4b815287dea03a280580933d247c3529cf7999a54623e06932818ab906b6ad231737c57cbf850fa183b764f33b751147949f8ae14f7a01cd0442586bc1a5991f2068bfc95cfae81d62bdf3f75014026d5465cd7342ab6df8d82061d732d9e51b2a81a588668623df5beffd472f919a7a5974755a4bfc31a07b7049b98119e4ac7c8e91e2ead6f773c5ccfd59f3f7b615abb22b89a84645afd582dffa5527610c578e62256f72e6f4628429d31e020bc8de2f5f0daf2deb94c58e3838766fc93a8b8988dcc6eb2d716fff78cd3730449224dfc5ac98a369c2529a05123cd0951bf1ea16d083e6d08bf3418a573ae23864b10d3632ff2c11b447826a1fe22677850e142efc5562c43e417f436aa9c984d4a624b3023f09b29dfd608266e8b1e9872a887263b11c124e6ebc24f9c15483e2df6c2337cb6e6b6c890dfc1f94dbc5a587ab2bfc88efeb576491569d02bbf48539b3b64a3f3173409eb2d60d07de9a110495a3a97be72d0f041f982dc98d296f0b53676961adcc10518e496300f65179f9b1b4ce5ffa6c95bb58b56e48c2011d111871741170dfdb95646bfd51079387f9926bfda17caff74a763c806933dbac4d3332b4cd2e1e4973e6b932ec47532eb266e267c3ba577e9dc389c6da2ae064bf05dd46d012f6e5142323637998bda0ddfa9e1469a7d8f65f8cfc2292d81a8b912fed43c468dfe3d7a109c168c4a69f4ed72c25cd844589782272ce57264314f3b85100cdf7e65db17de08acfce848cc1b15e11612437fe103f1582998772081fbb7dd6d9f396ce298a60418796de7e252ba182ab3a378a74d6091cae8e2d7f57368ecd48540902d99719e50839679fce2a7a0fbcd5fdda4ee3e07b426d68132e8fb35024bbe6cf040515194e1fe7bfd581f175751a34132c8f23f26c657ab239a58c8a24d25aee49bb24dbda4d458156351fec3892d16a94e391335476ea22ab56da201beb225ed88c6d8ad4d8bc90b32cdd1eb38eed13b224ad047aad459f76b280349259265cd3f053df76be791a2e2f260bfbae09f0ffeb1bd0cd28ddf056a8569f5a7791d7a8028049f0aebf5a1bd38a579d87a19f76512f332eb97efde3371b28049f2c7de333bc9da29cd7972d50e826d891d417ddd9219acb5e3adecbf85e3959cfbc864545fe38b4a3abacfb3188d9d1fdff25fb2a38036bbabe3dd0fb1e5226260313398e9b49edadfa7ec7adf1bddf715ccd5a74b9b95dc83aae53b9123619f843fc0c7ace6e35ca17fee187d5c1541d88e39479a8528f8cbd4a851aacd199eb8d0cc42881d408af33463745e635cb7d5f48b30e56833054f8ac9ddd2f2b178c3b9ccb358d5a4d388b41e2874f1ea244ae90d3bb446e85ca57ff045b6b4acc63b1b5520260005a27eca9cb9fd33c9eeff0ee5f0beaeae5d9403e00697725a85edb09a14cab4101c35d5294e6ac612703457e4297193fea9bc3ceb86b5d81c7d14a7e785c76b600b1e9d6c6bb14a3d169344755c3cf263b751083a28ead98af760f9791a733b265af4534ec41edc1d6e10b696cd86839299dd06aa421b996fcf696d652add4d32ca7b0197feb2c60302e67809c3b5591f1a13a43cc677a21a90fccedf2e8c6478b2b8a57dc7eac67a0842767a84eecac780145b7dea989efff252a8d4763debad3a481b633957c2071b4ed8987ab9b1cc68805cf6d9b6d3e658bfe0e2eb666fc4cd4f90c5b7a8f71ed52ce3fb7bee54e6776d7087204d9548556b0fc94caad4c23040c5ac3c262e8eaaa757cb9cc41161071d0d279f132fd6bb0f0767720cbb4c1cd8f3b8d7c02fdd35b923415aba08a7051a3dbf5c6ac4e7bbe45b8fc06906ed2e47ed58b754fe48763397decdd75f39fabafab1c0ffa4fed68a21720ff1d1520af20190d2b03b00ffc39106f242b13e5ae741faf8edecd0ec05998b38750c7a098845a15c1a8f070ddacd4f8ba10d3549333f7814e95d506b9ff8ce786c6a2ea0699b9f5572ff907f093f72d9d3d094ae287a5ca2bec155e963d6dae4e88cc7e5408d5bcf14b028bac2cf20e14cd4a0db2f519bbdf430f4e7334e5b35009258967c4e9005c5e842c776d0158a8f1e79d12a2ed026aba91457e19a53de6a20c27109cba31cfd8b24ddcda48a8c2048d13de39dd9ff3d869b60e39159a204365d5cf4411c727a80196143d27b711ada5afe45c259233f58f3b5b31448520dd75bfbd946df61e681e15306d9b32a013594a84dac88b0ddeb96cb266a7467cce6451f462bc9401f799d6bb81024f9310b932b11add4cdb84e6240bb605e303eba9eaaef14497b443ada4264c21c40063ddd75d12b1001d86746c03115b559f9c88d64b0c2065f74808bb862093c864e33288d66b8d92e1e9b430a4919e851c4fca95095b38c90097c82b832c3fc15eba4ed415aea1d0fe8f128eee5b6c48ecf06a6c1418ac80d08253e0cb39e0f10f15fb3b3aeea6f992797d7cd695d13cde8abb2d9940393814940228c5a6b969724fcda2cec7fed698f58339f84496c20c4801953e6ee0321e41d497b0e18d8139314e104356b2b01002d4acec7d7c02820302bc3c2476f564b70a8cfed869ef72f34238b5ede8df36b14970ae3034b7bde5e2ef977c7f8459dcd7a6c273cdc80d28f1eeeecd277b1450912e9c25f4cc0171bb8e15211fce1d057595bbb73b41abad847da14db92c1a6e57c02fbad5e3e2cf7144f4f549f1e815c1eec8c8daf37e4d723af363158aedf511c446297db18854e66194e10cbfc10843445768c09b58b19b8021bb9980bad5f1eff7858719a66590b24fc15e2f978ee60570e714f61b91b2fbf4c527c9e671d9b8196e1b01be60d1ad6935c99a1aca154fdd71bf141ba098a1d360dfe9286649de24641d27417966a6866f3221ea166b69a9d0381d12bcdd8bda95bdc44fd1a0fbf4262e04b308f5d5d5f397487dc087d988eed2894d7e1f659970bc19686804d70240947e765d01cc45ca1d81ab1d6692cd30a9a60dd3f259116e703f54f7cfd68b4415804d17ad4243e007b04a97bdb98e2f5b03b122a4368ae00acc9913d9effb6c9c0c84b453a3b2407a5d8397649da9bfaf767ebd330dbf8a7214c947423f558ed62c3606e477d5c8011c8103a4afca35e6b3d3aaf32f0e0cc12d73cbc01090a5e2efd1f04ef2a03c98efe9f085d0c06f34e5090cee39aa2cbca03e09596986ffbcda60d85d1eb37b7652aa479e3a347cf1b7f638568a6aad11be7f0fe599d78aea50dd48fe2a5e4cf8b37a11874691980ce1628662efbcb2b3de6850596203a246f5333a430c0a72f4ed18f986f3fbefdb2db63dd6e979571dbfba3d9119fe017c5a9b2859c09b0568ada40243054d7b27e92cc4ccb521083a0aeede467e057764e5afae7031a4ae6d39fab725e62e05e34e3fb94ab2962ba88af00aad492536170bf03677d8039c13e1a19ed545f3a87dbb8d1d87576b1a47aa80aba1c5b27850eedbf645c9e5cfa5be0eac0d163305625f3713547d33472cb63d55d4c71de17ad2dc94ee65f5ad6fb4737522fd84fa3fc1ac87f53b7f601797827e18b1922968bc2bd4a0a42852c583e8524d388b27360544568b0539a1b6df18dd3ae9bc415d73a067db4a67e7248d2236582f17f80873d8770c35cd7c776c8266636a503641f42fcb63c43e3d52f8b90a0773989f678e54994a8d9b906bb381fccc3ecc39d419757cd31798c77311004e291b8229ac58f0a7dd77a76a1cc327635df21e5df765bcc6d02b58adc6a6d2ede553ca638f61815e6c3d5d0fac54652bc0d0c5666b4ddf3acb846c61f8af1c6b94d28555d973c69787f6f8dec3865482bb7e21fa1ed83dee165e7a1a7110b0e48a65d17789a66b2cb3d4769b354221d1ecf260ac868c466a25693fb0a6c8af1c3a6774b7cf07d996d4557b9493c874b9431dd7a8f11cb6fcc4d6dd4be0d8e8d8f0f1bd78ae075bdc80b1a2c33cd0f30a56314fc61408886098998813f273c1d9d92c8508a41caf1c3f982c4f5881be66435b710269484530efc93f6053aa351d9b335557bb5f8fe169038105bb54aafe9a9efe189f32be664eebca442397903643e4706c75dee1a5e681cd37153587caa541c530d570cf0ad4bc9a729e4b2655d8c4fcba4c834a4a4b883da60258a0d1a21e67b6caca3f4aa63acfb41ae08be29a7b61a05a64d37bfa09d35def4720d4650ab13aa907661b6faa431aa1782027e3c244da410a285c45a2f1e45e80870a554c0da2b587a6af7732e8443dfb71d13853c50d4d8c2af693a94291a04e5b5b668beeb0dc414782a6a9d428e630a5c211883e803b88963b121fd020584cd6ff1bbdd94a563060aa2ad1ce7fbe95cead1d28d83d254e10ce978c4ed12d8bec83fc4604e76cf31e9e7383d86ae646934b6e56d8b3081eefda2f67ff50cef7c64add5238223b7b149224e4ac1dc7931206e8587824f53776a3923f11d9de8411208698a2d571a17348b5a047e4c71ee2fb36d5595ecabd07a273e921095f764e80c30d6ddc91fc96e418fa43589960044e923fbd2b18f61339f7e91a4e8553dcd4669d83550769eaf088c8f46eedc8d4b00f005ddae4a57a63827fed8948b9713ff3532eebe782ee2c216354fa739c24f575fa3e6bfae00b08c3b3b8beafb78e5d3017d82fa4daec53b5dcc3db5bc7428e598f06c5e4b997a46c7d310bdc4de48cfb4876f449e8cedf8e943d844c8e4a0e278ef92e6bb1783fa5c7b4d972ab79b5a436b2a81a6995ca67250f8a0254359825eafeddab3efe2674e3dc7e9a6f2635f9f6447f2938c58254fc875c5840ed8012e5e02678991627ace38116e252e6b64a15ac1b4a80a0cefdb5d287d846344d7b8271950241f18b7b92c2a0f1803d61fd666a52265cd80f765d0a37f7201c87a05783457ecc7c4b10f683a1090e5e35b1fe19485646547b6754964ac2cee4ee0c36ca7fa5e154541742eb1e5f25c437d87604c7932a6a07cacef13d865eb369abd929a3ae1cf43a962126baad2b054786df98529b74c32215150d628f1156d181937bf2e5ace4e3fd115475c5de2601ae8c7a1e2998d7957c342ffaa7d16fac8d260b0f436611012ef403a839a3714dad1666a6f8f119371dd622e067d4fb4aa938a38008e96b7d36f6ba5c3d9ec89813c09c4286c757050285ac59a0538ed568e94bdb2746a83f939da97718fd105ad297da80685a84e4706250f240eaef0e2705b5598476c7b053375e9f75843a79f9d61d2076c894fd9cae6a488cd2340fe6dcdd7199156cccac7c0cb73314d7c337b380a109e05fdcaddd812ccdbe1d3dc28ff29e1a0c952a270b0cb7c6b10a53f74eb83123d9a292d48bd55b5389f3f9d8c6fcd2005c4ed9f24878a4686d40283bd9d1040fd6bab6a4864a1e237409903bcfe4b81deda6803b1094d22633ed2cf2ffe1b5b0b566a7e3b49eb59866853ab038958701e17b689ccf734559c60290a624f25fa4731dc707497dac81e6a4a7535237ff1346a41448bf38bfced853ee40097db3862e3741ff63a0b8f7cfdc1b6eeb3608f7ef1dc575c50417a96b42693c302673f0418d3fc4b6af20d3cecedeb1750c17957c89c47bffdb743c7346bd4cb37d68135b3c7c4cf9463f984c578f9e2cf87063f6d3883d68ce3378e1fc6967c26d95f5056e42ca0455e7edc6330cb207f39e8ddeafeac3b478f4f3a28234de808c69383118b177f6abad639ebb32a22cc4b7c6bd3c4c882218010cd041991bd314b5d8130d61bf6232b52e3381b9d6907e503278e1270479425493ff706803d6a42486660c400cc468cb718b28a77f33f95d20b84d3ac689e200260ac8c07bee0b908e0362dfc603de2d7e24c1e21e5bf46e65f64c8f21d5a0ea3905eb2a88d885bbb178fa6caaf78c541d1fab44cb8b73cc9ccb49a35e705ea7567277585f0d02f922e44af5c0fa57ff1aa710c55e4fb3437accd5afcff60d3840479c8b2575a2958df23bf3f11b3288717354fbadc86a0861c4d3fb5dede3842fc11525d156f1f4f44148f07e1d1f32478d742765c1275f1586c0fc9acb21182bc49d49200020d5bbca980678eede62a9a437f942b5f5376052374ec4bbe80403b4fe20a067394acda5ceb4c74f161d0dbd19ebe31bba0b8b701432c868e2e6b7e3559d5c036034477a90e6c4221d8e25f1eaec41d9024bc284eb8d3632c5b663ad976f4726c81258bf097ef9fb9ac2742d71ffe76c34e150a80ec2c54dc691ba7947a898fd16e34b12ca151ea66ba8b039fc0380dd7ce609ab27c0e4b18cd23653a80cc0b294d64b525f4620d8e088492d891dfbb15f85a6d64736ec2e3c0e4453d698b957134c596f700e647e826445d52d42fd24d04d4a44c6a26f4d0e3b78da72ac2112cf0a5f83b721387a9f9f64e8a25a59f73ec61ed3b644959efa973c701232947116c7628071402711a713213462dc8ae2841c6e14d798b60ef5b3f1939c4999b3ecab829035e6caade344d4c86994f01db87c620ce8a0e8057bbd2b92621afdb9ca1ad86977fe3da983c2ed58bae04afb0cb022b19fbf9082e3a6482263e3d4a43e6bbd67067dd47d585acf807494e25c04c316b41481f47f473b45b273b43e70aba0a00dacb6b717d3ab58fbd123751be70859bd8dfd1ae16faf7bc71ef27f069f45759e6c23cc682cbc4b835a39644981235fa371dd445d23cd35a493e16e8c78d391a1c2813ebf007cab569e30d35aa86571fcba2f29f05f9675e8c240bdc4d0a3313388456b695d72603533e6222fba1905e1f1564c7e76f6dc88cb07d66354b5009e706c3071d7903aad42a5de965b4fe76138fcce4e91a5c400065af9f99388487dabf919c4d05975ec42932ae6563957947b7b76ab40624d8a239bbb9205d5e0321867ee44b866f6f2658003e1f663b2f23ed296cf9ab5d62b42272fa5fe6e036be429dd85a010ca1cbdb0db76094ead7ea75d3e18ae02e7d1991ad90970af73edba73858280df5672978ef34d5f8389e5f2e13174d42d3829cfa9f25f1cbfea1bb139604f2cc052e485ffba314a49e6a5cf953862d4c9556fb9dfe09631381c9951db730120cea69bde90e419b5cd9e3b54a5ce8927293ac4f95b18a17105b2c764195e23dbbee5c68be2cc056d1c5477d8b24eb212e48723625fdd10dc39b5852ec5bebd208b38e42332f9b1cc258558f4c1435afd725c7ae2d040f048fe1824ec798cfe7c9da58cafd7f611fb607c70343f1e936dc759f534fbcf734cc512b8605267dbfda8e9ee455c14eba9c60713e9fab42942dc8a60056abb0b64511fd1cc7351815cfb283e593c2e36d07a06ef1171eb5a015037d76d704ae74483810cee6de06d1814c87582883df14d044616d01541ef60a4aa25c0267719afc19a8f3064908b9f7be2f9e5093819867ee781879d05a9efc0e02b8e79e63e590b6cf6dd97366a1e44fecc9b5243a6734f8be1e89d441035b6fa03f5675f8ac2e39e64f14ed2de6c39cca936eba98544a747e7da73036b2f9bf1e0331b4425337b8586d91d28c29faf29bc3875c934da23a4e168a150133210ccded7424a3ff78515fef8a544aa95e2222a19346d0f8369f7b3c7b7c84f3333cdce032008c0c06a9cb621df3a18f4d8f467104075cee8535c262dead9bedcfb9edbcccd79a9a36f3973bcff8238595296ab020e1d36f67fb837d48324d5eb7b9088c299c468112b70242d28ee407c6229cca63f3e5c77c6bf450c32f39e70b234fa9543ccde49b82103986bcc9370182f2927c7d07cd82b2fd8925a00c4cfe3ba83e3a86c2e4e1a725fe20b929fcbca5cc248847d7959158fb065126aad34f23d9cac67ba13a3b4763a269e7e9281a103930f60bb12caeef3d3e1a50a89dca75378d9d2a87559daeecef6ece44b769c60b67746b6014071b07750090181e88a50c300147535c0b802d8dca4508dd9a559611cc66ac769d028e592e08cf227dbe5590edcf56c5d42912df956b8770f848f555dccb202a5183b2155c2d131deff1fcadb87bad59fd4878f38d8bc90d409cdc891dd1f6ff5363c2b6ba12739e993e3a2c12309ad0530b40d3c97e51c20284784c79c933623a812698e2886f02bad97d8e4458fd4ec8a3352b242f52bb3e8d429c26d11e50e50eb275cffba8419b5bd0ed50a628df7aca90777e3ed3b56ece822fa74ea8a300e5b28a4efbb98eb31b773d8c4136b8575ad8165f1af23339c16ec164084ac24296c93ba9662d2619c663251cf3c4f023acfd943f2aabc871969356bdf32b66afd96553405a006e97f8b8fbf8555a17da6de30342033d4fe2ee6a7eea04138c109892bbfab83f1b6e47d9603be8bd50f51fb1ef5f48fb475ad3c7a5316e10b4d4eeb45dd309cde168930f6cdbabe2111ecd01d1f99f212aa68d0ef02db3c1124fd00847447c8079edb364622ca8f4cd2381201902cb411b9f64d1563e5ae2cfab8a6b14cc8447688ada42b3b952e0b5f4e608b5b47189d40df48716dcc22c30c745502b54f08c6775ffbd2c8098a9729ca48c1203c096982ad4bd07188aa5e0cb8b5b14d049b9c7e50d59da775ac481554ee24e5294c08504d3a9e08b9e623042638f3b20830550f0262fb81fa640c53070b89f1947af391fdc271a02e15bd090e768a4e40dce2e04698951bcee8821a77590d8c064b4a2c9bdadf635ac91bd1a588324ca0cb4aca0873321ffdfbfcfe7516c65f3a2add7ffd5c59db99223dc2bf6b1d73bdf0464477c2d4028deb13df3ae757c136899ab10d72b34080588564cdc86a4a8c29f14a94a7472d77013fe1a98529165ac4856b56e84db5955cef1ef1b11d5bede220e4b21191c88e69ff04269b4bd0b636f0514f882245c22fc2fab5144f17807a392ab1d16e3c562b7627ecd0fca3c138b025653ca12db9aa6f37df6f44d5824796fbbe14377127ca8666caaf616e0fd16820d2aa1f81d4df59a048d2f4c6c6bfed27e9f410ea3d97d602515a3a83d58ab4131591e2c0bee905c9afc9162911d5d0d15050c3fc1f5186e79a7047270f30832ecf27b8ad106afec82920a163b4a370bef81f682f949390901defd021b6c166d4c5dbb47e8f97cd9c333e9ce176911fb280b0da66444e93e5b4f19fe0c5e721d15c3fcdd04c03af4b57dae869578de74fa29d1961cd685c185a3f0d45ff80baf7d6c7615855542be27c78988dd1e8a233e9a4a2de040c6046dfea2c9513fa21320a03be774fbef688519ec68044ce11cdde0080106302b7684da91f5cadcfc29dd72856991b6543983d1d0a7e710d3f46de57df6fca24b99379bf29e15f870b998d975f03a70f3d114cbabb910d335a361b2ab8af9e8942a8527a16df98be9bc0f5dde5a36dfcf9d272f1f6cc9af148522d7a7d2ea950b465a2740c0b18056b3c50f11370a8df6639fc86411ee136abb810314f099f5fe9383785b9e713c3989317953548acd2554722f809ea00cf447f386ffc81075b35453ed2ca57bf04b507f0c13568e801ee98343260e5e181d328c34a497815f895770a7bcce581bc8413aa486cfb9585b27f0e5841577da1630ac4733cd8a30f6f661e95389174e82a220618a58d737523fab4727b2e63f0a499b94a3d08cc663be08871e70b2bd3d2f55b159a670e485c8f124e9e5a8f98a4a2b58f033eb55b3d917af8d6e2713dc29db38dc06e09131156ac869141d08d768458e9be6426c013da8a0ea665588f3cd6fb3fc0161a47f7286b367627f29427c5d848f4123446424a88630cf06272bfbc18885cd6a361d5fb68e25d23a6068a779077dcd1a484e9c104a9fb4fea6f390d832fa6dbb23bdefe0f23ef0ae49b78aee93fc787f2179a7ed1df3828c2faaff1eaf66539530f4dd009e4991be096afce938f6a1eb1f91f12f58d2457ad35e6430066c2a4b4476ba22118b373b3c68a0a64e5c5cc302f27f6e92b89b63710a2743a8e9544caf3f8de32b5726ac9d109a19b3e0358cbdd687e1c38013ebf4bc5bfae3f13dc33fe62f007db26c6b06146a1379c0fade89b52f9864aadb63b3d19d8badfb2214f6bab75285c67269ef8095b84dc231ce685cb15fad8e82ef82eef2bba409ec6ea7a9c74bd4043ce61418a5ad11f67715e3e99b1412580756c8bb8edb68c60aaa42090bc028d2882381a0a9df2c75e4ace7c1e1b50b4ffe7b614e95427e290a0e18315d03bdbe1673dedb2871b983416944a69dd641d65172b9c8aed30edc2977888c54fe909841f826cbeba784e6c8134d7513c126e5117da166e17e50982cd9841719d08da112d370a5d9959879196b6ba5d25d905cdab4e8d1a45af2e7c25f4ac3da7bafcb451a9194225e3c2acf55d7150c24c05a6b6f9ed4a77c29781670beadb3ec3ea632f63db94a8cefa2f28341624f75ce77cd9d0de649bb8ffef7858bdf3dd62f0e3741a81dcb16a97a3fb4b597c1d349d4affd78e3083c37ec8abcbd87f8a2a1d235d94d8ef09c2ddb60d913c2a769e1ef571db03d466e366698434de76f2e775d4d7f218cdc089e4be3828b9e752977d7c3ba6e9f91d8251ceeca95b52d2a799fad3d6b6ce07d0c924d564992636454a70d45589a33de2aa4de1702ec634b5e20c3b93f717de4fd91794b9d155bf368ddb5ecfda95de629ed6c23247c1b1c67d763ae54e760a3983677b06f6dc17f8f191d3c2e6519a32fbf27d8ae2eabe16af752d08084022454908a29ad90dc47ce93d89d19ee8c9251d1b49b54cfc3333646bce989327d5519f18bf7889e8a2f7d70d3989517a2264c1e4f014164a92569ff33337f14afeb5102591ac5af4f9ba3631bb474778a0a313893822cc4d2f77afed73ef77c5dcb643c3e7fb50090ddc4cd0d37e68076c0201ab1cc62f80a4dbb13875d7c6d04dca43aa1ea36df548445242a93c7af13e247e255e74b55504f1f7e3a962300f4a8389de386b4719004704bd8c2e34fc527f917b368dbd9b1faa17b0d854a9ca8b5eec25a42103dab06e3424a4ec4bd53159f59efe5613c4be0e11cf15261b5698d0877b099e4dd943689a42b71c7d78fa65a75e0aa26950a3f5da822ee1c4dc2357cb43eca77cc1e2957afcc7965c5c6704a09e1492696a728fd9161f81875a1a3f4f66951e944f03e8e7b0974e05a424e7d2547f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
