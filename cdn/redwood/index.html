<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a867876ec88c6d0efb3dcde524f9a4289c30b08410b885560d70e7932fcb5d661bb7ba770d50c99a38aa6b0aa0cc8f7d7f62ae1fc279d5f98c6658b285394768a32b2d5b62e761624ba71a33a27456fb94f45da2692fd91df104c54d6d693b66df509673f824428c57ba5f223a1e1d7656787becde7802fcdf85d4c376b2d14564ae423bfabf49e9d7bcc245a90dbe13bf7f374e3a5f36afa355bd21f5f5b136bae69bb9c67717a58d0679f2ceedced547373191815b745a85be5d779fdb490e04f5aba71e600aa763596127bfd59a80ba2b460794597719ef842b79e0907570c26cefe24e8d9b9dbb362545126fc2a600fb06fbd909fda7f4834dece991b51542b2114a48efa353788a014627136242c7540982d4461a11fd05cda7cd4f8173635f6426d149aa96f10de4526549bf4b13af26f4687bac16e7f80e8c2e6d4459d8133c6e04ce37207b4f1927700738fd367f958c88334173c40ca7411521db67cd318526b0796a53ab3cec2bca3bb96e1e552b82cfc65d4023ac49a23911b03fbdf6a4ebd8acdecd05f5d0cbdec2b6ffd83e2413a3cd586cf35b7a15c566e0d3bce5992842f8cf2a0577fe464b02b5d0eeca7c75bf3a8d0002af366d7a1aa340c9f583d2016bfb6ad6f0f3a4b7ba0253ed35c40551364ed3f263014d46cead047e04b37cd2acb94d3b8791f80485611f8d8775c00f00ecd9da5cee7b7c581448371651949d59f14f45324da026a757eac667f3de1d45a5e09c2308588b9a867282393e88b2fac8b4cce23c28f91d0783342fc36d90822f31e22f5705e8cef855f657948983708cb04e1ef9c5dc718552358ca0602176bc1faebbfe378c17c707dd78e1c7d1eb06bd45bbc18edebed2a8e111956c9f059a78c3be4068e82985d79dca1699e8ac916feb55b0cfb9f422a71c1bd74a389a633d51ce2764bd18060f2e11846960f2977d474cdaa0ec58823e17cf1e033b83a722492a6a5f2a5a4c46e05c10494399d57f5353cbddfbd4a7090043e925e1d115492c6ee251baca93326daf29b9d4e3d0ed1399f41597f931935faaf98afc7bf59f615f1152cff78461361b839cb730f4b3a3ee3673cdcf0f013c9e8f45a456954f5fde770da1026c7c37085df90c833c6c38a2db66fc618ba609625156eac7133abaf1ce7fcb51b1953f139418c7869b65fd74c6f8d888efc34a401384f3d0bd7baf002b11b2978ce75a427321641354e13728f3f4248f1934574052644fc38b1bec183b764ab6f4fdb5fccad31ef4ce37d982e375c845e2bb48084f2d89c7438f83b2fb328cf63d618b911e11060e58bc4c63988034f7f77b26883f06b7fed8b49c99fd754d57fb079b9e9cdf86f7b0d32454782a148c21e2fdecebec1b98fdc5deaddb70a298ad44d385491f17df4b5439bd6f6c144bf3ad211aae61696cc37b45ae981478f072d5e2f5fc197eabb35b997711be3e7b639f3ad03b7ec20d7fa47f231f2b127e3599a3abf306cbe3f7b8ce53eac5bf05e01f0aba7c94f8b25fedc0fdc047611ecf8fb6e136786f4b5579859bd9562eee63f15337d33f9db78df6a372356745214debebf09f656c1e8bd89c03d181f12aa2c84ca1e092ce4639f31b01032e33d526d9c66dc640fab69aa0f73def26f0d403fbd8ed448433b1349d04c82dc7754e5ae6a12c2d038c74978c84004db927949d94a7cd75093f1c6f71496434294bc2fdef38bf001ad79fe33d37fb51afa6d0da27c5d5c93fd8aeb1b5ab3435d960f6479807781cefe1530845fbc5b20e01eac79b060e81a0887bd0cee47ba3a7c96e42fd89d32299293fa5f4e84d4feaa959ddcd86e7059fbda159c15d8704bf43fc9bc0faffe9bbb00a62f7d0b19efc72e8092ca93cc064cf91d96ebb9728c7f8a98ad427ec4097d04886351b9238bac6e77abd06057c63422925738332ac8e1839d2db0edf1d96e198ae946007d30264c97206af72dbc3595773e4b59aaa606e05abdc41f16e97d2588a818f47a1ad8c4951e6cafcf245e43a89a376afc5604a5234b542acc89b34e2d56a7b102341392efe9961b7c8b66e01819879f21e3399b69076f7803316f373e0566dcb9a9bcb239afeb70f541bcc4642ba890918380364710e6df602228efb61646d1a0578ceca29551562e8023013753d0ef10bf3fb505dda6314ee28c37155ce14713e964250f5759b2704cb56f552d5e6201e55d3b0320f1fcebed04617bc88c6f0812577441185bafbea70e5c67e441755904166d86f99cdf84db3e8169032546266036461488cf19b9d5d25023fee6818e47524abcd3079768df6de7e33ce78a1aa98bb445a565806a8c2a61c271daebc2a7e5aee20a49d3a5602fb623b00b724508f8c1974e6d1c29888a838d267848df8164265c50b65c1ba88fa1700e1a54336fe4a367f4052d74cc8e7c82aeb9f2ac272c4690d1e772fe64a6c4fda4eaecc7a4975b0bc4d2c9ad01e9a532dcb02d1cf49741a5de9a340077f7cd1c0ed642effc3a61b9489144dacd04a79c451bd99ae1afb877bb6b4608ccfb07fc195654bd5712668c6eafeb3ae5e10b7b47ff23f15c9f2a97dcaa757dc201ce1d2ec946b167c326b8590a7da58d4f5aff9d4885b02e451715dc15b4843e87254ce794b62926d1aa81200c86106b24fbdd37bde41f14177b20c0e62cc7b88d712f2e117cff64b9f33471c9e84d5200e6e3726a7666275c533c2d41d5c139e441253fff40b42d1d80da98a8040190ea611634402bad4dcfe7a7ecdc8f68bc62e81bd3c687ee9dfd8e27786ab64f940fba3fae199735b391574a12a1a9623112367950063a3ae5ccc0bf6f67304fbdc98f16e7332ed18c1ba32c8b2613ef7cb11732fb786d4240e534f02d8c30f01960b46cc23d436b1ef89a104c34d3b5b56532f2dd410d244028d162d16be3b5e0a6bb0aace40b3e2e7c0d46cde0fd8b8c6ea561161361b3e9e8e7a6ce14006f175690772c3ee55f1cc37130ee1ead7b8e08c00a7531eedd2a5991c01e2c0521e012b3c5cf597e580b8335c56f451f12ec6197d91690a2cdd0b4f6a79f4e84de8e49bbe8bbe871237b95d720e659cddaabe85f8eb9b9b8992d3c9b4c189114e708f78b6ebfd2c7e191b48b65bf19971469a05b24440774cc5848ab99aee57cf6cdb294bb1c6e2b2201737472e4bf4a58f0df465f6e0f70bf49ef101923ec29c763487d77bd898ab9699a29c2d7029120a395da6a28aa955c8b0be71d6e83a34dc549c75dc83bbd5c7f92ac5a2c4f5164559b7b999b2a6a6cfb794187cd7304d6cac97651e43de166055aa57a1a4e5a45f91900fdd2d7edd6c3e26604160dcde7e600a899ea3c87e760a2a083212ece88bfc4ee25ee3227f858ac618a075e305131abffb3ce2348ddcded8b6649395bdab4c0746627373f33014921249b2162cf8f57614410e13c532c61ad1b64b57d5e91305009e5084456dd02e9db482a302d99ec3c2f429f8f19880a6069bd536896b30df979c635e55924cb721576dc8e9bcaf58f81ca74a32449869675ab2e7b2f0a82ed9356dfdd7e8ea67c1c2f7ce08031d52e90ef3aceaa0b494fbc9aa676ddc3482051049f5999c7f5d2883c7aa44da0d2e3df797bfe7f0096ffed5872b18dcf2d3cc3d6dff1ddf9c60acee30aadfcfbf372ef8f0de0854084403e306d957239cf8ead36b51c96c87bad21e35863c9e65454f6ccfebc4c7832afe09e4678923462143ee9b9db3d99fb42d6fc9a1b2e899e209cf6243b2d825bda4cb076abc1bba5a64f1b9c5d490361114b6a0c3b310d220aeb71cc756b0489bd2135862e0ab5168eb1e61da04b9d88b1757fe5563f3433e55640ad690ab1fcf378810e0599772683bab17bc8997b7bd2038f85c41332d9b391925029d1ffa3fa5cf4cc81eb8e74c4688874c1f8d6bcff76a9b9f6de6da7691923176e27884bbb6c3bb45fccf33d2cdcd59ef7ad521b01a7a1059f62c78c1001f82d0e6371da90d894602c787dc74cc393ecf00ebb02a60058682d28becaff31926e14bdfa1250fbc20ccbcce323f5006b971368d31038d82a29cb387048b1ad4d868385801932f0019cad80dd7dbb89c12f49b22543b48a1add6ff1d5b150c05f7ba0824c3a50b30ae1345b3a0c240d90b80090aa8f415fcc46c93d9a8de8337e37106d86831550706cdda2991a56f2c4c2e687598005f3b65dbb8a480d7aef9510100a868365e31f353f950f28d4da22e19cc70804363a48f535485359f4c2b2a4a00ccd8d34bf82b2ffb6a05cceb6fb6cd86106058c2c4ed791e534df372ec0a04e3f9696cd2042b2ed432104b318d0424515555b601e500fc92aea8c7af9961291a3bfa9a6510d3b6c51288df16bda4d9b5aedbf0bdaa0210ef2004a89f2568779ad8521040ffa907e82ee5d1722daa2218c4ea05d4363ab6d6cef4459b29fd7a750d11319abf46362f5796861df6cbf60e4412e83a8155b8736b0ed1e25bd9307d1439e00460fca156c17c81685246fa66be8248e94a0ab14c5f1672c7debdb806bd03085ca090af98cf4c6a27115932beb0453ea7ba5c3af57dd5786662b8bb94dcacda13eafba0ecdb2520ed65b39ebfc31157328f833af67fe393cf837f587dad2232a8d2096db76a40a58181459189fc4a2476c7fd6a1e36634665308bdf14164d88ac7737ad221fe4e89f656f04b47fe1237d76a0784800324cbea4b73f7a9a691993795823ce48df3471f588d667db2c36041a40b703249338c6294cb45d65d47a25ad1678159b762ad997b9a8136e00dd673fa293c53b835b7253e49e2a96ebd815ccdbe1fb6692957d1a081abe2d7517bc0d03803f1dbe3f62b4e70c92aa9dd4df2456ca3cfc1991aaa49a00a48c2aaa0d9096a20c9c929a7b4521ebe55fb58817291de796cbcea8515f835ce90fc32f8039e766c39258d5ee8c3a5c5cb35199ba65f0c0560bfb794fe6c6c30404c3bc3688061dccbe6aee1b15022ce7f5b09a8873c8bf09b87c85ae4ad4d6b77c055fa84b744a9ea40712c2ca743964741b569ca5d41546af83a007fc5e73fb7450dc7aad5b64148933e60efafd329b37e79fcd77a74189163b24e297a7ad6e6fb063b07aa5661d0b343b0accd66e2e53b459fd3bcad2762e7003da18096b1fc1cef91733e258b4f349045df529c3c371e47b8dd8fba15de876d296b590b0656e77551eccde6a370f4d43fd35c6081b4a3cec5f255189de64e91f0ba3521064329ad16e3f351972065f34a730207b4038b57ab0d22c9d37a45d3a7938af8b5ca02650278a23ae78170004d51d22f5242438edc8f382e5ff3659f02707bac6ecfcaefbbe35a94ccdc46bbd879006bd465f03e8883193da7f6e985ba6b234947334f8d9fe2b4d50f16c856a1fe27868f2192dcd9cf78b4ad3fe2afd2bae48362a31921aa181738267d66e1f0e35c5cdda2e5c1f920e39655a93e3fdcd0e04079745b24cff3f3d7b461fe3d9584e5c73ff8b8b165cafd0776680ddffbd4a1f7f363c8380601faf324187cdeb2166a591b57580c80d9c49d13aa05b239fb21ddcbf7a10916d0ea6ab98ad2b7bb68bb5300a6c6774eece5220653bfacd8f821bbf826c3924d6b3cf6c890799e933fd728f169e49522fe075ef71f12dfa6e13ccb140116ea4dcf7499de59d34b3f05df1c97b6341bc633f0d1b96f6a2909afc51adac512b5d7c6d75a3ecff19bd99f2898ba352d46d0f3b070099217188e6430d7b017bfbe8ade05b7913fd6b60445e2aaf3770a0422a0731a98b243935f7ce0a754ec168e9d8ed68ac1467089d6d04545ca27d93e081c90d74b2e54861edd5459cf61641b89372c2346f0e6a4b6a3edc7465ebf9c3ed6cf4f0fb06e37fbed2c05294fffebf6cb80bd74ca7ca454d3f0228b50ec63e6695ca686b74b9f826a8ebdd270acd89ad3155c3539fe400b2ccb9d0a18b962b9f0e2f487ccda51b078cdd1e8c93b7d91f5fc378a09095b9eee236fb70517c80823412cc204b57afa57732121bfd3063f891cb3974ec579a0e72c70184352de5a640d4b0a5524668971d480bcb62e930d408ea61d152be41cd8919ae857e71274aa5d59339ccd538129855c5defb91cae24afe18f601b2720c81a51b4e588165c487d6d13b46824326a0cc8b08c57390b4c078fcf3082f1fc3e851a38750bc728db9a946595e1ea06657c34f1c344bb7ac95d69f3363daa2983380e8d570d5831c203239bccac431346019aa77e9d3e9a9b9451bb563c148ae9697d8c527c0652347eb80dff7f31d99b38613d49c3efcaec5e032afbfb0df9132035863bd15cc1f8405eb9311f93e808b2972e5ee034ae63d197c0ae97b15e083439790f54907b35f0c8ad7ff3d4d58ad129a6f725c502506a48fe449845ca8754a0e22ca3dbeed67328282f89e4f00cbef3a93ee7dbebeccaf217158494af5902803cc718b4893af6bc4806de1f50ae4a03b1274b7e4c4fe38b26abe4491d84f4bfabeda194612ef1f479c11546fe1cd5b50522d3c6d301ef1914d69ad0708ed00ce604f772f6d7dcb36381c58e858ec765cba06f5f539bd02c1e2f6c9d59441b5ec0a08bef8105103139336ce4bbec919e4594cb22f319c91d9630cf811623341586f0c35c985a8cfae547f8f3679da218fe4ab743ed97d53ca2a79dedf758b7fd53532686418f7a3f0ea205909a59eca6137233be37c9fceea07ac9aa3f23a3901eaede0290ce307fdeb78691fb64b9e38b983c279680e08c1a9f78c521f3a85ed6ad4e18dd97491adb1cdfed796572fc60ebaf1efc621a897838d36f13b6fe13725b2a30f91d877454922d32fca572807bc3020b06a72a5c0bdd1dc1d53dbbe4b75dd85f2b3210f740be6f7aada7ada01c5fe04abe64ad818d6b59d3d7c4257558570e9dda53e9803ed28892c1515e49bb87631e46f94e4d7a5eedc2ee1e4f22d60304ad882e6addc5f12a885e3c2a5fbdbf6a4d367405a0b91c0524506c8e30365a83d1ce85697d0224e3ce8a2267f484105e1ed123915d3d8e4ce0a5c6a132a3d0d405a256368dac573f2a475a09d4b6d8beae49a468f72111e75586fd51a986d3e166c1f19cb4311ead23b834695e9dea3d0e4066a8eaf7fba893fa9470dd9d553ad605026f877c188c5a828f4dcce5ab0634158fba3b044c131db5a79412ff13c998a19c24251bdc7d8455f191e12904ec11b9d41fad81b26ccb627edfb07ad69120c4526fe9c3c3680344336b41bfc7c60cc1c5a37de4dc6d04688b5087a974883b4b19e825179ba6635e4bf6ac8c74c94933fe34cfbb198ad9de7aa075e5114292ad08c11e8c6d1ad7556c2529d5509a1b67af2ce10e14f89f1a8c1db5d2f5e5dde86e59ce6db7435ca41c04eee33d16c5eff7326ed4adbb2dd0ff9c4f751bebda7c22d2bc42b91b23936bb0564ba745056897e2d293ae7e9d1575089761c60565867eada1951ced1129d641c809df5b83b5a85df311a3ea53f175312fb6b554528faad69194f1b424b2cc9e27ba28c99d22e90b2f1ef7de668a84b119f7a70e296361a08ff18a39c9ae3b0a98c144a4f8fb21904d762593b9797a11a0e840b02541691b0b15195ef519e1f285bce093907d38238240627d064b835ac05d45f6f1b413dca2c767a4e580217a4df97cb68bcdaf8288676ed774e25820231b51216a074e7e22f772bdbb003cf9229e5ddb4d6d0e2582097105b5ee890a1efbfb264d2bb2644ef1bd87b323f9bb4b14ed0a3e715d017f24129ea0406b96c8a48a1b7c50f533c3a3005a8d9792c0c01af19ef158aa03adf809a56417c15afeb44cda9a4c109d23f80af3c54d4ec8206cbbadd8854de143db26679b463e72b0f52354e1d7d7e376c64bffa0b42ac3eb7ec8509a7ce5eb7b67d1a224ecd89d851e5ed48d5035cb43a55e9f1700f0b7686b7604990c538a646166e306a672a9a37c481a1d829f87833eff71888581f77889ff6c9e00790105d8975315ea0c4283bb4a6d8135c87b249ebf06b6b37e2392525ed9a11fea822371ede7fc46eea39098b6bc9dfa929a5fb7acec8165eba77bb917ab9bbb79b121917ac11d996b9fc4e384d3889445c2202fa5f002c6db7851aabce0f7b0b375fee6fadc37a311295fa895ff159cedab78ad98615f49c15b492a71738b67914b813a0420920bea5217fb8bab64a5de343e4c2914e8a8967cbafd8fada4dfa4c826adc0bcf3fd1b9e63754c3a851bbe200c2fd96a8f1b33aa38a4bab1a360bfa76aa9700b178e940adca0b457f3ee74d939ab2bacb1360f527e3405a74c93ab57743c5707f99c6c346c755b90dbac6f905355381320950e851f2fa76f3676f73b8d07c906461d9cd5d0fdd31e6521b6ec2e833330b9a03339ef2f43a7eb777f8f7fb61d13db989bb2936c354364dc01639f4a7f28fb1c7f6e5874d892aaf71499a7c30618c511c87233f69e943d02072fdfb531f8a7898dedc9f6ea4fade5ea6729ef14111ccf66240b933984c2172d7d6d86793e980c0cc9cbb67e18870d08dfaa47a1e73b866766f59a89fc699492a4f3d2ead91246491cd54497152b1627b1e39f480c733890d969832fdc89b6260e19bfd28f4502787d7bb249e3dc951474f5f9e9cd09e25efeb5ae26e245ec2136d0d75df381e3f064cc8b08262985ee67a341f06980bf7bf3ee8b80ef89b6cebd61d63ccb9d1b6372adca836811425815ef4daf14a1523b48ece663050ab0bb152fe9ce623ee0c98c76183b7b6d7ac7c5608825d72721d8af431f534643f7a3dcea4e815409748a26abd03f546a61163128bb7b2c18734d1125a1cf1c5072865378b29214ae994664911e9cb0d4bf6f623d0abfa171783dd7575538780c86fb7ca3cd12dd75820d6ab5af72d3393ff8cc1d6498906fbe67bead98c91ebbdc42dcd8a744a07052295cbd0e4d3bef5749c7c4add01f8fa891d42009a0d408c3f1b77946908bcd8824a31d395c88c038fb6a1a3003678acc9e492d9e680d65862dd82b06a84c1edb6d215d34773c182790dac0cbf0b94a2084b5cc1fda7027f3304c547b2988b9584e46612746f5a4813f4e05e0cc9423018016a5913c10bfa21287ec2373490150b25ae241cce507077340b576663a68d12e850624af6cedee8a1b2452012a32e1e635e31684371217a3a2c776dccd5737004e12550efeeefa8c97281acb89e3b0bf0e975eb514cecbca851b5f9465ccb5746d9aaa5522aa92e5cc727ece3c8918dde1c3c8d4b4a55535a0acb448917fd9fc30985e09c163c8f4ed957d9a038698939f534f823d84f0e00ca2c6d84aad89047bc62410d0373603b4dbb09920eeb8cdc0f06bf6a85e5e2682f1fffe4276ee02b8fe07cae0411571fa47c49359954ef0a6dfcb80c179eb6836ff8b3838be0e6d31a744d7a18922fc52a264d249324f24b9a55684e5c0520c45e92bd0887867cf6cc3a3528c6b1d9b1529ff169da2d2b5b4227cf787313d298c3de1ea83dcc891363b2cce84131223cc5873c4c77150aed25f63759d50839ac2cb49c3a75ad46dd010c1ceb300bb2bc33eb1e7563d380da5f6d2adbfd87d0be0d19e6dd75e4777aaebab673b11b693084f02800bf4fb81cdf95d2ef53a0006768a4a828add1891533e3a572151dd48a472e7d8d7a6da00162cd4334928ee6316cc487440551027feaad0efac03e826ef583721835e50c5f5b7c442baa7369a9019de7999260adbe8a2e6702ecdc12c580c3702cbd8bcd2ff0020e451865f612dd60ec1b502a4bfd3d754be0ed6274df93dc5de2096831bb9b1bd905ee5d23dee67889cac5d7a38b2f3164c9240939e7b2fcd50b1d5070c6d7565a907d7319263840f957981ac424619b98d7d0f0066f29d8c4e2029af9242f47a217183709c859221f8e18b5c50ef217d6e8beace017d3e805a70cbaafafab18c8ed2af0148d62ee3d34bc70238c35a8d94b68da0b053be439657486c3de1e9d2764e045a58ed93ecdc577dfd65c168558fc0b4bb893729bedf242d7fe3b78fc408d64de75fbd88ae799edf5f3d8b7e27ca651d4b48936177a5bb78b8eaa7b9dc7f8e4768e0b4a5855aaa8930a50c45d88f6982775d3d522e8b8ed1f89e5218ebb9e93aac2505e7afeae2d8a70d2b7713148c19784cb8e4593ef8608cb634ea7f282531e9a1f5158db1c7854cbadeba8086f1512170746de612cf83237ac11882d3840fe547e74e1ad3c6233ed1f121d7356cd1de3a6767c9a6698ed127a919810bd42a6c89569a57ffa9a6ec7a4456841e6f24c78fab5ac4f0bba1fafeb3f153435840f71330582004d99a16545e28b312fdfb26cf6b2000612eb754e18f3bcf5761b14a667eec49d4e36c4a82b6ac728aadec4b1252b94551f02a3e03411c09c1c7ecf1d34a4f936b26b708f5004279af21ee80ced6c110241ba39808a3aa584a11d913fd62aaacc4f81739a43caecb3b75ddee0ba234d18c852aa948cb682ca680d67df56dc25f11e514c814b6002d1a2101db50a4cfaf5475f0dd244c741973b7edee8a955d4c4bb6fe7b0e1573e9ff6ca517d9da1d229ec01be332d40035d0c3370232670dfcececb7f3f0bff70c3e48ea0c9b3ad8fd7fc3bfb7f88b2742b2ff6bca0d898c1d7ae29157a696debff618c9bf63ffea4bdfb9ee6df313c23677f2c86df7f4cd8efa93a4d60f36b3da4a6361b88ba28a57fb31a169c86ef593478c2eb7773189b07e732114ec43e9a36fb408cf585626e7fbb7984f52a1a38d9b51fabd7e4906cda2f6196b76e3c0fb8fcf2c20178640a85bf493f2fd814691369161a9b67f247f8ed3a65a76dbdec9862a8d299714bc83d3892f766786838909500c596fec0119cf68a17958c69864366de94c020d4008ccbb2e1f2bf699b8f0aece9a92e3e01a6fba5511c9009d62a2ca207525402f09b68dfa4175621b926b33f2efe28f27dd53d51092d039f01855f62c62c520dbc921131ec6d4e4e85d81007884896dae2211b998b86dafd083a553c36c3d699bd4c618d370763d3d66bc4c9c85d39f8c9691bd1c30c76b7ecc70b43d93e8e09a4ffaca33850a7de8d3934f021de7dd2224005cfff40505cac2332961f1b58dacedd851591c9d7d6efeb65e2cdba249780e092778c4acb77b30837bdb79d3a2b4505a0f3c45b46ede7feed2a70f32c3bac973075bbc25bbb69a4b27e7decea825a14f35b8d0632d34a2557d94dd27293da6e823df12f7102125b3607b1ec3a315274d7abdcded78b16fc4d6e5cd1cfff2ef898648715d9a123ae99a20911a858f6252c8dd8b2d2eee7617351c9601606ce28706dc673b1f013acaecc73793baa8ba3ca173778c3476e3670fdceede8bf95741a9f1de76c76e65114804d1f9b09a2875c5546c99423c8c18d7fcd3879367350096d218d1290efbeae969f5ed1e2077934bebd2fee45fab5907fd43a5a7b8a9eead6af1aec46414809e01a2bc1000036996a8a2562b2f3f4412a94d0a5a9bc8e0b5de8d158b6c7316572439d4171844302f2d8b4848ba2fd898fcd0a68045ce94747b360939fbdfdc79a182a16e5c3164043acb72fe0aba8210461ad16b2f0a09735e8a6e2fb36c662e3215e20213d0e86115f3cb86c59d222205929f4786df2463b336028e5188670b0ced5990b7a1811b362aaff848eef61ff33afd5118bf5ed82f77974039019697ed859415ee43eb2b14144f5813c62a8570da9d6c6787deb64a7be6cb297bf72383be75e7224d9dcc9bec79eed87b97e9693ddc95bff49b0f9751328c0a1f9d89b143217e9e6b365419c5b2f246e8a4428d8fb6a6b9b11a783bfe8ebeaa909d22cbdfc6ae3fd8ff794f1a3728acd206c74bc0e02b23d66008d04535cb445a3bbd558815c3841d373da800b3620ffc5fc54cf47cf8263f231a623dc90cc123f05c461e7e7b7b6b81b8a69a42e7b5a96c3baa84e75af0b52b99d3fb360b20cc07bbbaaecbd6583d13c5f518311ba555fcb24ebde7b71888e643f3bc656ed2910d965d560507e3a891717d1036f25b3df3ff327c35a514d01ed16abab0f49a667bc3025d00a88738427ebd7bfc9936836915989760b6b842d40f4e75977ffe922916efcdfbd8da35a84fa080fb55bc5a941d9719680dfdc1a23f98b287ebdf4f88e8ac5bc7ed33d230543b4d6e597313b1d8b2001e45abca5c80bd0c7cd27e399f57cfeb5678d7e57fee55d6b818390eb08d7993e72b4b40ce2657ac93fcf8963253c3db7c78d3e65e0507540c822ac16a36870d24a4295e6f5c0d61b3deed43e09045b89bb847ef6e98c478ec2d0174525401553daa1620d56f7b58667a671dd534a2e654038c3f652e14b907e5ae5f7de51aa539c397677b790d4fe055fbc829f8f8d1165c5628eceb224076afdfbd3be9a2da75b0fdde9be2c74a51ea91c08dc88cba05dfe6b10d6e2ba1b5df9559436e96ee8fa07604c8464300ceac50e1ed825a5649a4ab4df6d611ea2cb629b7677e8377867a91c0498ab9b8bc23f1eebe4f5d14a9f1c6e870cc2f4409d8149fd49502a4dc9550f31e41e4f5d500e8adaf336a818428c1f91d23fc3a5080b5feff0269859f31152791e7ec98bf44a388ae825525abda35b48558e27e4900053a6c2e4432d32dea26c6ea41894898d75ae43c8ffecce464f19c9e861d52d77c5e88fbf1cbbc66219bf4af49e9330c32ca35445d1daba24a4758b60730fc1f52efa4e5498bd281d509becd3937612485cc10d09ca6ff863aed807998fa43dfd99eefbdd6507b2834cb61536ca97c59b26ac21170554fb74d5bd4b9a2513bf4de1e4ebac93d9312608bb9b50a35df742e60c177d8b2f3af54b2a826a9b608227a55d770758791030cd75f8360cf57f0ca9910faee81fa096d9175e5a8eb0ea6cee6038cf908d7687a1ad1c1c2a7fdb5194fe8b1f43184cdff9573d87a49a18654f56975bc063f0d5962e3b6fbe2fdbe9bf72d00cc8802296228b3420c7ee150cd5cdb0d40b101b1e61a8367e47bcb1a91a71c06e35f4b8d1a7264e6b0e0c56506059363c3203d89b8d1a3a52ac1e4211da365ccac63bef00766b788c098128f4be4b47abe5fef46a729ff1d8410e4798ef1c07d534fa3ee904eceb8b5f536010ba534b246bcd20df8b16b38317ab16568e1d4e768f174e4d6e59652c6c303db117ebc5e8114bf9c410b70463445b4f77bbe195c902cee5633b6421136c31a2d0d04a03936b28df3f6ae6b70c92d37c4e7fe479242f3ecfb2de10889b5acd3ce88f8ba4cea0a68b217e48654ee95af1f5cf58b5269796c88309cf5bd42453d3d36b283cb8c44a4cb02e4cb9b09e4fdd2c49695a063e49f0ae716f4e80c9f1d864c654fc9c49edf6b368915affa49922e9a649432ecb3c2de07a1b8368ba972bd5c1d20cc8867c3ba5c5d7bd8e692a8fdaf900f412ca3987469ae589314198fccf96a2f154d1b9f5ca052605ccc1b650c38ea1364de12923081e8416be857506331688009cb86bda0f383362c1677bdf01cfa73714f3c203f7e20c32bbc88b0bcd50438e65a7a085db04279a0506ea948f7b363b3a6e1b96aecad87d8f800b000089592981f9ab0569bfb767d948af6bc22158b4323dedba53074c7d5f367ab06af80727c4d72a151ca0583e05d05e30b2e3c217b07c39c8dc8a210c5aec479a4676564d489ff297e108e398825fbfb44cddae8c6cc2a03276f084008349500d10116dbc9e372dcb8f0fcd6e57408697104d4da5fdedf0b16eedce6917670b051087cee3f06126bfcc1e4a3325deca84c51fb702acd8f29c04a0114897b06c119c2e40dcaca8a5c10fdb162a990a058cc5df8d1a0ac045d9792bb8e5cc28dde6199d9a2da01c85f0a4892ba79974233d08c33d73f528ac29f2e9e717af3d1d3ddae9a20de6be0b15b8079ed9cbdd5fe0875555154d1f9598beed7b37dea1e3953e80258ada50fa70c8ed18dc4fb852c8e898924219472d5f2b5f3b1aa737fefde2d3141055ee2ca28b06f3b0dab077f987dc133ba19f553862a315710e9377d207d7d668994bc2cc9e6d0b830cc8a9755bfd5da166cb219c53f6fe4851080307f69dbcacd2708622cc6e1e498aab03854426c079b967a27242c21b1cd5980fee6d7248ac563ef88ca34323e6e089f059bb48fe5bbfa14fa1cbf60da08b3e15d15f81c660cf4c4e5d30091f1710a37945916f54104b52e16eaa9ca1902d4b8a67da3547a474234a3981c2008684b0cf538b79e8b3a224349ba8c0c78e9447b76093c5b0f72f0fc174aff97c7813231676d73b856b9e075da735414ba887a2033ace0cbdecdb486e1823acb4cc0f799b28b50b490801bd8b67cb7495e20e626b3aaeef673ce270caf6f24ccb5bf0de5cec14beef9ffd681f756ed1b326e5a1ec11b521133a3809e2ecea55dd75e4f66a0b427dbfe80fb061d174e2b1cfa8a7a52cc0d6a3679a05dfa9c929db7c71e4b5bedac11beec9a8479f297c1768f8d9ab9597c8991fbf39b77e415324738b4313f9d3f79d3f2a8e7e36f3951512f7a3e08e6846567b1d724b10f9bf10f5fb5113af52c2562dd56fd4b0746b0b94239bd310d538555d1323d3f70f3d80a6468272e135bd994e860b8e1faa8af2c282d75a1126bead4451bc038fbe372b6bf118cfe27bc918dbdf1313a156b00ed308d3f76ce1670150ee745eb4edc66aeace87cbcde79d228206ef6407419b5f4e2e565995f3ed6f6c7965cd6070d1b5ad8781e7685b5840157e0853a0b4c2fddbf5de9769684114e9c0c281b0b1638dc52349d004b946a354e8d02b909d3a3031eba067c7c7fd825bbfb56dee720a9f352861d5b9b447ef0b5b7e7b036050436bf3d9e6a59319d12891224d855391f55b68f35223459035ab2c7020a8acfd76c81ef8d6afe13a59ca7bc8748a6a1e3dea70b95a6d04a4b4d8e2a053ad335286ee6a75da924b303259153749cbf579a805b9efa05143995bede4f97d2da74b886445a1015e1a8b1ddca2078d3aa12e56a6b3649b8f22265dc89250158d27d3638f785b966aa3df796a620d1b556b0f52b393d72076facf1903687938bb79f6da7f711b0fe8debb6d43bb558cf92ce029704e181de1ee9fceb2949b99604e48666c59acfa13baa198a735b542f53d589d292eb0162f3f8b1fb23f1b09ccd44064ffb292d02f48fccbd3dee293cc60b5425f69fbb82c36f1bbc463800a224f7ffe66b7d1bd4a192d9d4334fd1e7efcdbc54dac11d18d38e7ef9ec4bf3fb102a6680c8b49224ef607c469d605f9e5e010b3792b6cd67ce0a40c468272ee25ab5171119cf22191bce66761bb1bb77429c6a39fb9b26ce746fd19891edc05c673e0f7a92f51aacfde1ae3af1dbb94688b1f7a958ff08389b3e99d5e09001e149ede07943cc7850c10d7abb70b69afa15a017a6f4b7f87653b4f319b5e0a2624079c1e9683f038b44f70fa5df1add9677cd8f7a9adb9d21ebf61ee29e25a155ba1893e1e1d7a018c8be3ce5063899e0db8ee5d396a0ac1a2ba7715aa342034a7384ae95df259942112e53c7ce2f7d6b3631ff88d17a673d5157e56930385c3c70c56b2aedb7f4ff29c01d6d0895132295f821981bc26991fed3f934e246e6adbb115f7ea2d9418d9f5d6b71d78bf5f2cdeda3a5ac8bd8fb0e1f114dec63571612452997ffae81fa202cb0b5f0b9aba0c3a09764128fed9c9801c062b363c186801995785096c45f2066db469b3475eadb8a926d973c299a726b256da09ac4ff604295265e2457ffe20bd7c203b6786c042c06a955cf989495a1be4269265f9aceb05c73eb4f871197e7510cd83ee4dad1e9a9b90cf6c5f7c512eb45386ad1142968d7b5d794311a45bcd07c85c554404c1cae5870b014742a61175d8499f809a973687370944cdb5299c840b10cba9e1da369cd26fc18578ff0a49e3fdaaa5880513711b4716f6960c0c8eaac4ab8ed4880bdc2ca8921a870e0fa8201849e0abea57f9816daca62313a326eccd8369f913ce73ba2955c748ddd8ea5f71b9315a80d6a2d518c01092aa45dd693f9c9a66d5671e60f5a8f29ed9d1cddad750b155823119fff8857184f9f98d4cfdfd6e355079afedfcbbda886705eb35eebf75b7ecdccce01213f80d451465fe71232925e1272d6f0b8b1a56b0b222f4e1c61c9fca2e14ad3a3f9158325739d7bd4761c1e698cce39dd4bd9fcf820f5df7236a4056c71eabf66cff70c25115bc33ba5af14ac5dba14dbd38e0989906962e534acdf44e24b15906f76cc67790ca6b5b23d1da16c3eb285a9d51767220e20a53831febc6102baa7f69cabc0d5d0f2b08f139e5199a098e19ea0cfb564ab5bc9c51492a3914d31ed9fefa1d3053bdabcad168a6f35bf5044825335efd557070c20f72dd6c59b82db67816de9d7347893663498511a3e723f8f2782717b87fe98cb8120deeb7ab398e3ad6fdc42d55be641144aab49a8c14774c738454ba30692d9d6d65f7f76162a74b050aaec253ee3c80efb64fb6e9f373d6a550c19b90e49e7db58612a5c823ac5fedbbdab17df6fcc15802d606835d207a67419e3eb148e7d637a8e074081c178c41b3ef362eb58bd2aaf0b3637e50e6415de3d835c1462f22c5bc0161f508201e3b995004210de63d4706fc95cd0d6806be5c2d6bc09e86cea1c2071148e8d92d4a7cfa59368a0af7e420d8edb7cb2d378077080aa63088644c21408edfa5d6fe523e177cec8d558b990ed6ebb5ec03f9a7cf24dabfd88bf95c8e8bbf3d10ec86d5ddaddef11b9bd6fcabcd041a5e624dc07c546245261c77578fd69183e34ace01c3b5d7e318eefa0c248b619e902ee3426f34e3c61b644b6b77d2ff7a8512d43daf6580408159b4611ade3accff270d52df7f7076f65386c96ab7c8858ffbcc751c0bef355e571656a1b1fdc6bdc95a897ff8c27db1af24d86357a81c11311944c838f1f78747291f1fc1e80f80cf1667e2338f6d638f3bc132e9cdb3d500481c3d9e0c96455da3c64bb698b614afd461b233f678dbcbe6432cff198471f48734ddc2580340d9204248f978228d5497d3895b862bdfdb2b172bd0c627e36b752f78cff66e0099d2f272d8dcba9986c09eee3780f854e607c5000874afea8e8ce538b1f0c5673863eb38eea2c752a479d82326bbaefa5d967683c84560f6a2d9768c62b90e6bc3d0e79730375f5f0bd22c6af7c60da0725e5aec61e905425032912b557c2649d7ad2840bec3c6834ffa0ba5d9cfb9dd4bbbe3cd67df1706c0b8bf74c9a1af1e6101c2a997a2e5f944098c6186ee0bf286654ec8ab7482e79c41695001de59da47c27a8c6e583f0d5666842797a39d18c1c26fbfe43149c0bd3f224422d988c779d4b1c7fde938b7b50d75bc2fc469cf03c4348f19dbe13677618c58e38ba3c091f4f2c1b7d37d64abe8a01ddeef52b8808a23fc9274c1c557b53935b87619c648b18e6f430ee80edbff7dd33bf8d5925505a1ff282baf4e266a2f1c8d6bdb277f64bb6ff11285ea3b352037117d6e2eff51fddf0990e19959d235a64f2da99e6039567db57e49514f6915fd7690986440e7d6d7cc101b9ad965cd4c5c5afa39c3bca954a463787f2e3c45e5ba6aa99fb450228babfbdc7b2bf0c00a5ead5ea371540f06b27c9c0e305708dad016988d4313f890c8b3d13382e895983aaa9d3706add1bfcfd1f0799df03ad71a213fc62e8bbb60de3a34d395adcda4b80ffd87782ff3e315455f8056286114bb9a6b2876e886d555f2120fbfd3283f7cde1e52064b0bf5513907111722edeec4d8b84f94a4e984ecdaf37ff9bd7ad7be5df627ab92b16a6c3f7a60a2c98926d4531f512f5c8227ca9ba12c411d746c6b25cf9356a29957516ffe1266520d97b145ff03b4dc7da5cb4819154348b9f2632852a568f5d816a7e2b6c6fdeb15dcd4f3998359e676eba32bfea1fb74ce197c801b1732e726aeb3708ba6278ca5c91036e88247e2eb4dce263a0ef6166ab3ebe51a9fb19e2895ec446ff51ac32737f8d9788ee4aa25cb38351fd0d9e99af909035ebb05af74f341e1a2496e7ff515e180f09b30eaacb4bf00cb0df841decc227000aea736829af847b3a75fac9da775a40437854ce4c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
