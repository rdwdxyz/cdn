<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"231e32abca4d4b246d682845561af9a352d9697274d5787701f7d35f9cd89f131ef9df3f89cd6ac5ea6f26d1345d59541a6ab3e2bd24cb9cb5fa1d6153d3ecfa67887ca81d8cc2925e682a0bcaf96e2d0622e0ea723e11e0bdb5f45bb4a27ee8ee49d78a8f2ea3e8f8e546ae2a97c3195297c823b29b1f4500e5d1cece0895d36a87570b0a6c751b11e81386f62bfa1751bb48f9d9ea9672f7f3a6ee36330461ed8e00154d025ccd5910d251363e7d6e0dbe9f2c97cdd2885c8949e53c912902d9e4c2c411cc2d8b0d642b403c5b47b7e6d4d3098a46243ce548e330389ae21e9e6d6e028bc6097611f916ebe1be3f1c96a532f56f15850de4c89cd5199f75931383a578a96d082b2be80574189b21512dfe257a2dc7b7458af27862cf9ef065c5bbbb4113bfd9beee1cd71f804a04244b0cfb45d4680863d7f2de8ab51f7401112ff7b1b44a6faab9ba19b555ba956d9a83c50910f62c1ae999dc541ae643fe1dd35642bb973d2bf4a494a524bd8048b70e42b9a40599533113894560fd43c9e4757ae11bb9e2573d655681b7ab7af1a2bc5e4a57265a3d38e1cc02bacd1918337c0a1ec8d5a9fbc37336ac15c23c7ae42133172cff74316a791d9dd26c20a76192854a1521138bb9c5f6dd6f31679b5e280edf3bf636d22315b0d203e72e962d7f36d1ef2e27f1461e593bae064bc3d55e3b2d0b5ad57a21af24c0eaa21430853e1e8ba11c395069e6487b7eaadf36aa96209e539ab5ffa198092fb6bbeb03568ef4dc0bb4f0150da6affabe32fa9371b069305245c832404db72ca2406dfa218eefa1398e3159b73ba6d998bcb761bdb7aa3a0c91ee4f077722f4cd5fc4dc8b3f63dccd55bf03cda398cee559b5ad28458635d79798364b204d0fdcdeb048c24a7fddd40e739b8639e404fc24d40c87f5711bd5d8f3c8513f2d7be36eb0a2376c9605cfd23fc75d9307c97a0938d00b2ec728dc6a8272e6755f1efffc1d7e2b1733b6bb079ca410fbdcfaf02913cf838ca472f633340d971ade7f2c9845f7b9ba8e7d67b24c6286254e505256b5099ac786c94bd5ddc0b7447bc6b4c91e8930fb80db00688151c15f7385ec2d070a309a09dffe25b873ac531796b5a1893fabdec4f29ae8659b662d4f787ba0d5df232b6696f971743beb628ef5036b8843d7061d6c1651a40cd34aab55a51644a202c1af51b573d38402762664a9400767e2982f9fb881362f1dd3a52855e522de59facc0b08ed8415296b03cf0adfb38ce62cbfbb3a4461224b937470eaa88e85992df1dfccb12f951060592f95dcc06890d0532540b03a66ab5c153c5effe6a555a36a447bde3ea8ffb097296812ac3add5d9946336c472de2803b3b636f74401e5ea2c7556c735327e53935b63ea3b20914f13e6d1f4278746f8c405dc6ba09ad0534981ffb54d013b6509ddccf91914d18b7227550cd66dace51dd8821464613616d8e29d01a21784e6a6845e0beaefda9e040a0ce6a86ac5ea22bec11b400d347b3fa924d01b3b894d484611dda3adfe4ca1a6bdbf40c1ab7d9fca6aea43e524302b7e6fa2f1aa5db676cf8cf7fad042889f279a3e4bcd9594d256615a086eed7ebb075e2a775c063304e4f0904a13d4a0be25a07caceab3c41aa024e36ff2c851246c49950181282a74329b1b37fb3a799f980d993328499455697434d2deb6fa59fdf7b377ccb3535894d7db14103344438f108d003e332e6872a92674816401166975dd97b766461d001627a668665eddab94cac3434fd63b4bb7e5fcf7e76a68055a4cc9e1a1842f6e40bf9a3c5dd2e6a49ecffd2ecae3caa1cb4574224400d17a3fb72b48acd682597bf29a7af633a41f24d60d92857af1dd64d2c0c1463845c2c88f17deb513fb0b882d5068c2d719b1220aa1dd76f523148847a6de3388150a8cc8c19f9c2b3c9daa296db7ddb0819b342d4f0559417aa112dd3e9e6035faa09eb8ffc4fde30a7eff1ab3e063c7ee399416cbb3b7d83dc7d6f72478393912506cb3918da88ccff5aebb719a226a6556eae509edffa1b7c26c7c177444b8ea281d85dc3d4ed6a1c8136f395d0c95c9108f3af55def964ae76c04e0a1d07dfa261eb20dbfb6c2cd13e01bd57af78298d8207183803ab0057b96433251486c43c27ea60556a7fe18f5c9e48a46bcac2625f94f50135e76db616140e6711b16ca52361e4e88dfb32602f21fd4ca8afd7152af8b30d4e3fc6ded92c3fc5eb4a3c308a3139fac5a5050cac7bce2e4211e3f8eff0039d9158de54b0c93d6e3fb9539de73916e3018b3f86fa76f128fce523f1d0b848462ed787523c4bbe411a42d03223582b7d1c6faeb6d85505e31eb528696a4841ea82ab1d7c6c44ff397347abd062a5e834791933c86e8d2531a96d11c217d84458059b1dbeb0bfa8351caaaad500996e2f0803b901a8774c1e086517eaea29b8f087f9bc6f26b2eb36dc10dc53633ab7d61f53bf9a2a1ec0568ce26f3ab132255c2222cdc1d4a7296d9464e825362ab2996fdeab447ae34c151b5319d8bfe73f1649de0b0da20845f58b45e41df439b50b3a536491438c49adf68db714611b2277723814ca6f504a1820a04b3fa77669f70e0ec84d4dfb68ac034e231b0f646ffd5172dc694861712b9258b12fdc865b7901a4d41027e3356e09b9caf0bfd49ac14f45e8122b5452f7cfc5069b293d17b36c2c943b3abd182befdb790c204506bef798b83a65d928a9702c28173193db175b990b5d78656cebe2d0f407cea7f8dcd5dc7d9538ba182c213f3d185fd2b430e0ca2832e4bcddd700da700914597d021af41c7ae9eb40511a0f6f59b3d0f98861f2c59e723780a251070c38861bbe841b1876822b9f8c1417e80600aebf258c2c3eefef41e7c608b5b675a06e89dfc48299bcbd26646bae311dfc4d53d401bb8ddb8155754e05e926f96e561a05b7c45bcbeea5cbe335ce767e8ed9d8f7c332000e6229f2ddcf24bcd79061f72c486c2d1e43c7870fe22badb5f4ee401e7e985ffbdf6a7c0826e669e94a3ce6dd73bab90cd297f84b92439604192692a90a3dcc6bf05fb47c2e5a62d607b4f6a26c7a232280d9ca04b1155ee841d3ebf6d25c57baf7ccf792a045fe61309c363f9cf79fb11a82d4345e84ef1e1501e74f16a2d0e77abd3800dfcaa2835a96cefda5ae503a5e9c76b6d4e09bd9b2e7e12b5c211d87c24e65709e84fe9ac00be1584a5acd412bffc9ed5289da050f3e65128ce61c75444eaf85efc2b7bd36e9efdcda62a630bf92fd574ea35ae79bdcbeb26117d0e724e2c34fa796abba85dd583fa8ab867d544639497d51d11d679583859c30c0d0acde06918ed9271eee171b1a802f85d07074ceec6382d757127132a10772c1ce66caa673ba460c87a9c020de406d3896e700b996b148f5d3355c4c3bb529144a9cfbbb03e9f676ee9ec4a5972d52c445843debc90500c21436f08ad50f6b8e2ce370309e3a55cae47a51906309131cbb436d6c683bb4b9c777de3d5f5b9b01c74c9a3a8583615423a02d0d9dee39965b0d854536bdcd5efe170aa988924e19fb80dc45040d1e333760270f5fb38207093db5ad5d77100a230b5e1f2bbd70f61ea41e4cfcb7544dd05a92c27c4c2c4b0810ddf4525ef6c284e0d01b92c369e61127fec9f00f98cf5a132599a31708336423c8fe6b6d69dee41545d11281de1299b95f19848473792caf63817712452fc9a38e999ec957be711f83aa510d7745eb50d46db9a1b8cf1cf795bb9707c5d5f1b155ea949d7b9a0f592b0529ce68be10088ea5442e6c2b97ee22c32de0d81a5a1a3136d1424d9d1025de15119af765e75ab05f233290519514e0c27e5baf419eae1c235d97d7d891f0af85dc038d97e8d1231413fcdc9c83df847fb66c3220fc2fd41c7d70ac97e563b3878ef2972c0d1d08a31fa8aca2dcd07a50b58df385d6ebbcddb70331e3b38a10c984b7309058cbdfe05fa3c3592373eb8b1520657f68febd9ffbd3f111624f33c585247a28a08264b7d63f648cf42c27bdc282d414c4836627c2689113fd52b5c4ce80b7a7f01ac418b91b6227cc051a602956a8040694147acee229dce80e423658aeef9ca4fa70ac78c902d23b0ee7f6ff3aec6df1d964805ad4ac6ca61c1f15392c653a725e0038af384004627eba11fc8cf55541678ee45cd1c9ce8173e6722c1cc925f9a04778f429caece82c6f313de30ef061b666585c859cfc0039e06f0525fbcc1ef4d7b10f1d0265b1bb87724f524e001f1f08ed776eb78ad1f094aedf7d607bd02305e5f0eda7d418b52f74939cb05398eb766c7286644d4bb026eea55ac78610a29916df9d5d56fbbcefa84ed7c827704daf1e8f561e6e34b0c0c8a53cdeebee46acfe06a111c014905853ce64d779624bce3ee591a7dfa2c29f6e23ef6700d8821a3b075bd962c53417c298245c08877b8b30ef8fab733ace63c78d4d50ae96f436c3f7ff1679871be6b47c4f54f7b03edeeacb6a4d2041c09338b65084159c628c6a915226154537d343c6f337449a2c2c0ab772819c2a17933d3d060d4f47501b4b44edeb550f0d8f2009c9d7aa092277325a81e4bedcff57a7df27915776aeb3cd17a71dafabfbeeea8d9f94437f7d89dd2d3588e2de5dfc273711f5c712c30514cd3d3c38d6a8ca27fa8b18900957ff00e1a5380d86805d0f760de7a729c6ff73d5eccaeb8d3f35596ddeed976c08e5c6abfca83ff2aeb6122af85a4286e2fc8335cf7be6735d9b3fc01b78498d01cdba116c2a9e86f975d8c2705861798c4462ef86d07d2bc6a959e9976675e901be0a6e11fc6f1fe4a19af8a2647b14418811153ed8ab7c9d6d180cb8df143dfefe102e48e655a1d8cab0fba5eb640d2e6660ab6a8cbe909d5400780af1098d7dca350259d996185fea50ff5a1d783f32683327daa2bf77715164e06dbf415201fd622410946beef6e09e0693bb649cd1b068289da0d3c436753f6cd8706f2aec869afb0242740586af626d8d3e66c81454bec27a4b85021bfec8c6a9110b541070becd43eb7d52063f7dc26257cc45da1ca19c416ac928ec39e2706cf08bcd3c6b0cfd2329eb74128934e388e634b2acdeaaa4e806542525e967e94c98dc7a4427f4eb3d6f3240da94a6d09735f0fb8aac7c0a0065701781be23c83cfa3d7bc51fa457f629351a35d8d68031313b20ec1a4d6839f8c83f13badca2584196a7b0634dbaafe5ef16df069646ce502568efda323f433e46997f1803bd3b76fa002217fc022e7e48397f4d802dc14e539eff67248cd1246e5a6a8376f61bba15b11d1e2be1e7f19ba7bd7a9dfc74bdc151278fae40364078ff1821f439bd17e66dadb33fe5bd6e79659a6711fc1697359b0dbec312ddbe68daf75e414e2dacf6cbd0a3fb8f7275a0e0b55480eea810e2b6e55cded4d042378d6d0f05d99079cd2a3b788f836d0cf47a31bad6a2d328a388181c36fe3f2775bdd02c61eb6992143f2727e397dc11506f79045e7f58f56bb7c687fd353d0a0efc9488d188106a2a87eb9068b48ba552329d56dd512c0a6df2676847d0f9a5fc9862d2ed663fd18a6b072951e38f2c7efdc7f3e0d5068920e9c4595f058efd87b33ca27d06bccbcdbbdd9ebb21b45bb2c8bf40ffae3113c5234c219229f60d9a46e23a18a4b45cdefb7de6a87f35eac32217b1877be6a7992dce08807ea904c10e1e0fb337f6b8b5c840d6ed0fdcc3791e01d99295261a380c0115d00d768a22d20de2a3a39f9023e367fed292c51dfb92dc1acf12628c2276c5949dbdd23e3f5e68425b6941570f2d15e22f0c7e1f365acf86208c57a3ac9f17809b4b1d0115ca7c76413b0d6d6589bbe05e2b8abc9aebba8f3b8dca72d2a87469831144346be5701c12a94b1b593069614df836ed8fea5d7db875d82d8b852b392b53becdf0313799894ef344476b5786f1ae713df3ac2948319b1a49384a3ab9a9bceeef6c7d1a12e9c2da819de1ef764ee1cbc3651816fd975cacddcd62ac9c8b1690c6ab7423bc3dd2f9c2982d3b26e0f5733da29365b08467e5032b44c6de94e320f232cead72d9cf904ff60709581ee16324de95eb1aaa76161763b09795a8c09f4afe6b1d0d20b228df82a1fbbe4fc1d7f0ef6fcc3119daebe588c8a1a95a249efbef9c9bbdeb68bad5bb09df4f1f88794b88ded29febdd3cfe96d9afca84e95c4a4c6148bada7dc7aeed3621c0ca375ad4791c05690819aca7978e7ce32811cce254e305239a636b7f760d5aad1a29de950b2adf23857d57dd951a2b41845a1dda9050986d92352ec89cf9afa116f63b7b1f25e6fccd2d57595e89d9b61bbc95704b2b1569be52fdc3569854e727931871074d8f3b765fb02e5761e5d6955273c8f7fc2cb4381ba03936a5a51b9f4a0b521e4c653062e77ea0f1f3cccbec898fddfffc74af854c3fa6bd179fe6e671487e21c8025bce3134753c30a3acf8f5ad8a53ef6bd6772fa29535290909a72b79b36111fc616aa94c87770dacc1027d2452b19c763883a1e7d222b05e0039851e1e1597b4d3e91498a971ec7dc28134def2ba1729d3d464ab02ddbd1652965f0e2087391483fc65a221a48eb0540125a324c2cdde3d86e02e3db85b6ca0cdf8394044320c3c536865003db8ce0b4a10672d3b74ba9ddf3718cfd500fa24a97b5bc5953a2f3dee579614f4c8974714512af5f5cb9195db0c542ec17b0bc0b8eec8c20ed5d99ed81a4345bd1667f72381c6505cf3b3e28fabb299152405e1af255279d9b534017a1a7c526ff3dc3e35ce71d6caccc4359f93c8f46927fc6b4c1796b790d5ec7bb297c73e2c63e8779b1cb0f3318419a43119c48f50ca42aca4b63076a0824ccafa365cb1f6e5551368819b40e80c11706cbff7e9f2ca5b7213cb78f0a0fadebb304452d6911377ecd9b7a16779f9cea7f3bfe61bf9b08a801771c9d5f56332bfc74e151df6332bef426f3ddbb1fd006a5c56338ab4727a166addd741c3da282ff002b105514941e99e1eb47acf6cb1e39e99cee7ec2743142c6ec10e094b8bb99f394429c6f2bb6baa2b01a856dc7965c30a8172f620c4d9c40bf18cd8c9f053f0695ac924c2d738b565b96563f1fe9550ef83a06ec267a4da2e4f0fd679fedc569bbab3f52022ed7c59b57e3b69e38bf0eb6801975dbfbb912549036c19050efa565303da587b072f50bdc78b433adbcbf92e87950689fbc6f012381bca4b7bbea76e1c11001dbd017345f79552dfd985dfb7070e9546b94d6edc335fb084504db87c96eaf533019244c93ea70f5555ff1bb5f3b97cf8ae1f0fe60940faacaa545976a9ef62fae9969dfb626873e2ef1a6b7ea2e968728f0701a25892d80dd3de7b6b21d596b2ee383a460b94567d01cdd3a4f63349734e2100f538699fd3e433132561312cceb70f7a3831ed714ad011356f6d137e270f1ff14d0a56a9c5b1bfacbf020f14249b67b73c2b69e0aa95383a28703e1b26c8811cf9e80a7c71b37460259962ca2f2fd60a1e5d2bd2c82158961cbe28d59d6243df0a9850b30a6233de7501fe3f7677f3d93f9f9fe072f53c91d9a8c07b1637ecb0fdd88512230d063c444de99612b558bf97835ee4c92d83b806eb66671a87f8f1a9ffc1829f4fe74c379e77954f22dfbb4304840ad048c3a2811f1ef400324174b0c19fc47406267cd738cb3809c3ccdf5858d54e4a4ad8a7f022bd1ac592a43384102a079514c04dc8b0ebf4c531c5f9b08e992de22046bc106d0ac2136e287077d6841faa4c094177c3a2bba647bccfa9cd51115f78fb2fabc1c43f7b9d627d3d8113465fe147e612ecceba5b90ba75f2e4701e6d0d619d6df6da7888d6bfb0a2813d0c0daf984431e2b9fc7602611b9344fa131c4c4f21309d4385695e1e0ab1b74b5cac683228953e81e6fe762ad741f6eec62a31a5665afd860f89ec93eb052b329b5f6c0a885d4cb2c6264c9cd73f81de0ced5c9519b4c832d0b86b3e292ddcbc6781445820c1eba6193ac273d2702ea93cb7093857f961b3a38e610c52875ce6630379df4683b3b1dd6d73cab45c54b884e266c703657555948a311708303414aca97d70b0392c70140a69d064876b1e98dfb5378047efdf18da0e84b4e1dcaf92023793e6b1fdbf9492e74c7ab2fa3475a62c25bfaade5bc04c80a523aa93d0d5ebf98dba58a125305186bc44157c3e79c0c72b4a3d6e7c2a5b1e94ac84bcf3bdcfa7fe5b557ec00e14995b406f8a2de3822849cdcf9814e6f9a5ea0f1edda0b5b46a11e28edde088bb4a75186a1b6dd9fa72a3076e21895a3e6db0bfc0296e351903a603d7615b33a9cfada5bef48c8c4acad569f6408722d51e23f4544c2d3cc5dfa8c12ee7c371a6804ca92d0ff402fab2303b523c1a4b86742bc7d20ebe96833f9cd05a12c7ceec74fb86adcfb4da522174e89ccdded335fa77ed6e909d8371cffb3f6a2a5a9d15694e0dcaf237b4fad9334e4c9ce2962561d497869a07b4f71398b55cb68f4b8d0b53cb60992fbde30c56f6cf2162a1427ecb97e3d07b4119801180dda30c4a4e047293f809dfceccde02331d969da24cdd547ad5e15ac96fc12a467118be4b9aab5765545e37fffd16a9bdbe0bad459e4188f093a6671a02f10a29dfd87ec7b9c5096965c908be03d77feeefe69fbd096e0f4cb3cf230411ccff9e3f253d3a09d3d5ab98fe894e83b25ad0838c772d5ef966015782f7dbc053eb20ad4c4399519a32ad42fbda9a77c7376278a38ec7889351e299fba6f5b70701ce7518786494f5742b3d9a895aff26801ae5f36113c5446d35976f198a6cd86bbbd4c12d988233173a436849908f090ba8825b241dc7190c84addcd1a1799dc1bab1ff116a34f07f0e813263566d8a269473ff927a3a9b88730ab73998c9c9efaea26cb1d3ee01c5fffab5729ef554908e8a950493fe4145bb197adfd100d277716c07f5ef642681781ed9c09f4cd716c1365d027bef312a9d5d16324d02bbe5d9da3dcf628285761a72e3bb0e9d2e073fa2fdafbebdb519e5d076eef09bb348de29cc74c8c1a9b7a7b019d903c71b5dff26c90ad17bebf4d2fb3175947eb352bf7ad463160fe9524f5f533edb8efde1d1f493eed3746548dd655993e7a6fbc1dfb781ab13087b679f448ba5a65eeb98fbe05adbbdb01dd738e08862bf17a3cc619846d8ea27dc09d373dd34aa6d82c718e11daa8455d153d1e6adbf7d031ae7392b8a659534ee0770b6ad510d7ab2591548865e96740f00fa8d288362f5098af3c8df604b0448e062a558a3c23b8659bb093b1073cb0acf150fa1957ff24abde28d4e6808b1875c9f559a8a0f7b778edd2b3ece0b49e171f11faa33a0062eb2fe9b5901f8bf6e375acaa465a0a85be9de1534b5f511ef183972d9b6f1f4f0956e5d144893e4cdd17b3045094d537d28c6450f6813078acce202e380bbd264440c8696e0baad7d6b7c86ad407773c49954707f9a426f724e2ee18e9429949d4379a30a220b7011f4bede37350f9477a185ecbe496864195ea8327f2d3f79cb6a6208250c6f3f595df8864b25494f62e2ad8b87a25fe062fa0fe840109fb20832e15d5c6d3373060344b5808cc179ab9c1f25e0e74be3e438d25c76478b9c12bc9a97c0b93286c6ef5f0bb68b6903eacfc8073fef23631fde909ba41eaa5accbb9c3871c094c9049362bc7165a10c3dbf6b0161832dcc4e07c0293c02c08d7ced4970afbb613ea00866757def374ad5b261db981e393584e9d261b956647a06cba3b848bd5745558183867c127bb45547379261756f84af7c1c6f32e15bb8f13558b316b3dcd5d34c92546dc67e96055dcb9f84e220422cc6d59e17fce7d2daf742b4ba400c5da0ce6b1521ea9a2a5dce3b7ac76f5d6aee4b16ec9d0ef9f2b04974560e859ac30a8d1f962b3a753f1ccf7b9b6ebd20c93c107ddc3d89b970c0c5c098064a8a97e22b961c2a22bff4c379574585c92014485e5eb801db343d1d6ef663ca38c6d60d5951a1ed458bc326c00097861f1e49e79465621309a813828ad07eba4f069cd97854864e5245eeecf1c804e6a5aa315c37e5a448f6d44982da9533ea0a1a581bae0338659bd1a76ac39b97582e6f006e701a47346aba2af4b2e49fa46c7465877018edec1372ab36b5566c42df7b72b1e6930aee90fcadf181a7931504a86b24ebcdc0b92ed3aace3afb98fe99d3e4f6ef3975bcf1e9be811344b4bd226a35c62471610f0a1f37ab5487058a7ef15ce0b358a55e31f9cfdc442df322d29de9f1febfbf8daa06b8651f8be4cb541d9ce869f244bd220bc1a031b56efec60dfcb29800c9fd0ee9546a3614e02c0f9dfe4b482563131919bf18bdd7e908e6ae8c0f8090ebbf1d6fe92d612b07ccbdadc1a997e6303ebcf43b5495ab13bcf1fe86ebd7e11ec0d45a3c8f446a82b3eff6ff186dffb5f8bfc9089a8823dd7066be65d0234505f622ce05a160813b4222c71089599219d42365e5dc4e5cd35e728caac74152adf5d309fb4f40efd6a9526ec39187bf35c91d901f3a77ca98a5980cbba490b00a6fb4b8371163191ce25158ba0e3794c1159e1e0bc9356317196eea151ba9a96f066db402e61ffcfe00c72137a733b0b8251959a563c36228f9860fd1dab5a69120cb2f37068078440d3fa4c0b2871e733637f71bac0b7e542131334589816c9cfde5bbff78f5358d5501b0bc7a95138d65f9a938bbecb6f32ee018a2fef0fac608b99e392f0ba8c754d34a7020a6ceb7dd85e81c8b97238db539013c39ea3235be075bd5587fb062a7e1d2425dfdfa4a99c31003a4772e2a11802df3458e1e48d7837dbc31c8eb39f33dc51d94c25c3f7e5b1a6d3f35df2d3aab78d5c0d5f3b62e5471047c6af42c89940c2a6cce5dce6f13b08da06e5d7ebeda7ac5ef2d52cb4411e48f60f1113f6f18b5119bdaa333cb42a440668d2495810b109176926f08100825ea8cd20c777cf462ed4247cea40b9deb38f928edc6a2bb7340bee569cc672953e9778e2f9eee76350b6d3aa07e5802d83547f2eaa5114279240dec390287e04806aae05811448b8f7b4fbd62d5500a9a3ed40c596935fccd3dd0b6f5c13ebebab6db45913be3f6cdca9d554bfbcea8a63f236692bb301b43a52d046d2e09492ec71bc455719041a850049b69986cb9f89eedaeeb5e8da6ea4b082b4b1c57a5c07235f9879c9863c47eacc73c7c2b941eea4ea92461e559bd8dc4f7f04802d4687053486e9c3d7d2f780e43860cb16d549c903c543d42bdd5e27e9bb330365c08dacd44d50527b4754fce28dd442bb38ac254d53a6f4206cfdb51df57b2478da6632c5c11b96b335ba58f13c165276ac98b6cc2a3706480a143de9df1a8d92e3947c1b414772b1a09ecc58976d66f36ad4ee0e411e036ac106802f023e1f6ada82af10780aaee31f1d8c98123f903d8f06d62b8f62d39c77332b4c839f49b65547aff6d1165336d85e666d3ca328398c8b7b6994e9686593a7dc5c4435e18e2a50749458a14e0542ecb5640b298ca9bb28940c6f7681533e31635c3c84ee7bb7db85ef70fcd8a176075a2ce8325ba0288a2a466db29a9ec9e1c0d1f36d73a5443d5fdcd1456597bdd6da10649f628e1861f2668465c3591aacf6293d92eb47613d2a43419f0d4c8dbe5df03dcd41f1bcd8ac2262d25c7fcfd404e5a7eb9d491d1de1d5fac9282562acc7d8a895464028b79938b40d63f86688f8df4b7239a1db8bb59302df353dad177340d4077c9d67045b3eb9f1e5706646fd329cd272c550fb541f5e81df5dcdb9a4847b8a4c43e5b1caa7caa54568ebccf5319fe17ff7a6cbfc4fad65a126d070926fdaec1890d7568e85441bdc7be454840bfa92e5c13d0e8532e046e5ba88b616cbb4c675dce7e1060b96524ec6021500f4a7adacf09980536927f2cd91565dc49abb3a7ba5d887dd3fa23c7c76fbb661da4472614076a1a15d511df7627ba2abd90b39d5e689c82ffe4f2e2b2dcff8ff4aa5b8e50eff2ff7ae4880e266abdea2f456a1752962359f752d5fcb1d9e5b7e7868395874137da48a96a667c8c7951d7583ea93459429ceff23fdd3dcb57defad6093d1fc4ad67cf377921cfb1fcbe52eac06bc942cb168696fc4777772b1ce37efed25b36cb4183d4304e4872c3a89135a9ff17e1a6d5744b2e16db122792317b28ecd0f03ce6ea5f8c47a376ca09de95a8cb7e021429ff7eee0350ed11b3909aa101719d2a2abcde86582dd7cbb8c747dfba726c027677e247eb138a8ec1718385606b1013bc3b85c7fca205fdec1c76ce22cdaf9848b2b3b253e5ad6ce5a4be2de39d68fc1c84bff8b9dd2a27a50e5ccd55cb63d5e730df9fccf9b5edbc1ea67f7b3981b403d33c09e3378be26a77c03176d8a9cf168b32ce34d1815e2b5317ce5f42e2cf1e8726aa239b6f00c2d81853fcf90503dce10b539d7c77604c3ba5f364d0bb3c39e36eef79953b139ebb00ee9b41c87f3be71dca50bc73bb92203706813a06f718bc48b695014bb423faa04191225c7aec02e9584219424d6fc1d7759f4800793ad6aacdde0727d8adf0cd7a922fbf37e277fa0a4b295d1eb747854a6f9415161b2a3d488af452799cd6e9ab142a637a4e29c0f86eb2712d3c0839568bb7f01c0917d65ff535154dc13af0d0ccf1091f97d22dad998ba75adf4031d7faa39075eb7af1b231f73ce4b303665bf060c2c6c5a67c29698360c2a4a6cad9a1f6fc05e6bd9f96a6213afb269cbbed8fb51ca28238864435ce9f445eb2227b41cd9489768ed93deda0e1e30838ae521695bf9a2f5c385c0d32faa24effea50b3cfb032d46fd342e2d61dd8fa78cafdd6ed131591a8fcb36a2afa78e65c68f62c893dbeab13b33fe71d8d5f1171ba1deef2053a81b8bc3f0444edf929433ebd8bc943cc1ee8e79df5b65079812c08d7cb44e594a9128dc673f5cb572646662bc3f8ca512672f2d25370e64c83866480f622437f147b7a45b32c2e8806dadad13d929edbe1c60391a7ba74cca09d9a2b64c6565377e6c89bbdab6cc8ab78f428aed88d20a26cd0b8a7c2b8744c0997d6fb5786642bab1e354bdb614409aa6b60044c12a1f922dd522d55544f3a7b426f84897741226944f9fc5a1a2455e0dc389f8348b6db5c26577c2de1de78eefd814881ceeb3ee3f0302ed9fb5fe70d5019a4fb3c50f04220f016a5216ad29ec31f297aa9155d125cc84dd53eea319e43d3853cbad41e622b0e89833c226f36400ff228b5fa6a0186b5a1de2b660edaa5832c0542ea018f67fa82242b657e990d2c735b8630ae44ac05fb96c5ee0ae9ae18c4099990e2c0dc0b0f50d1d255689f9b7418255cbfdc4327fdcbc665025a7755f494841917b0e409f8c5cb8e6dc455a57b7813d963b0fa12b3fbe51e9819266c5d2d0f7b214cc7c58d1554ad3dc5e533fb4efe58c759ad4c024650d0833654ccb85e6624f50ef01810133fbb81f6b9fb57eb50029efe0f8520f92bca30251bc3e5c590320e87e3dc8e7df9c21d54d316b1934e31673001c3b1fe38b67e0ce8d554231bdff2717637f1dc6d2aa0037626188b7642d6aac4d425e033dfde33dffd10e1fa2d9535390f930cabb34ae8a4cc1b9e3259bd259476f437d3a2889856036320e625bc4a78a3db6d06e68563560430b6015d50a690b0be9d9181bfbec1a2d1e3acd2e66813032909e34cb86f4f27893d8267e6f344275118161e78d6fbef2d4ba4ab259db1328401339964b73055dc239d6eea5c19636d886638533c0e08ff8a7d1bacdfa95865a6af43efd9eb9608b12fad6074783c5edac5277b4817c54b6fb77ce007b38da9f98b131d738375644b5c92b3ef5840e7dbfb0b8f8ded06274a55faf09fb5358a14df0083e8c91b507d7e314445531001ac90e9f12b9f5924c21939d69f93c636341ed3ba411bf3690004b082a380fa2d4b728006cbdb545aa8737eee51fd23f4635475d4ea7215969bd7a2fed5db5135af6d85be9f8b20bef9680f961b78264a86a2871c2b35055526a3a0014b4362ee0bf4519ef5856c39a485adceb8d870ca0396663121e4b94d0925ada653b9a5fa8f435b30a67302ce38841959e33e590fb7cf44458c26b27259e9f6804a65ba5a80c06f20ffa72ebc8c30c6269923bd19f7405c00a57400273f2504468a5f94f79829c4fed90fc670a457792c7ae86c77cca52a332bdaea78d0e208561a22d090c780203c57fb78ddf98a45e9a754d6c11872caea5b52bfb5d58b39162692041aa523297ef4dbae8af5b2e309ddc4da6de2249ff7e7d6859b1bdd535dce3a96e7462d7f92308d5783d0d2601e51afa94a48789fb53784669335c1c3cf65181c416a45b82f6aba3c04afac103474adddcf3eb630ddfa5c9f39b427a6744cba02ddb0a3f93d2d6b418e1ecd95005e855e126e2ab731f5f1b2831296a16039f53d93a1a3130bf7f578899c90f414181206c5320922a9d66f217e5e5bee9de79289aa42f44de5c11f2f146d198ec6b5aa9b4fc2cb6b8f5c8e131f8e7e26b257ad9eaaec350b30b78e25a0538a072caa766919e8936a65c51f3584851efe5b1dddce2bb366af9a5ceee44950bb8c1f1f77bbcf52e2cf1ce00c7dd17eb725e4bcc03ed24e9c822d1be0eddaec5723941705286f962757233aab9a27030565e06c60f6768fc703e9ebd7d9d00db833ee6d9b2c859c9474a0ea1337a35d9c5ce602af4d857d2dda24ea3d2ef501d8e19144707c6dda5bd1761241665789ad522268b0f0a18c10ef7d51edb90860874b992810a9d2ef8e1f192d0567bdd68b7f0309653f7da9eff7cd9181f292d97a9b2ed997498a0ce506be066146d14a30397d4245c87a27a90c328efe7f5d071a10ec07b4240309222b930ce3c78c2c3c9452e782a5e018c131f820d87ea6decb8adfbb234af90eefa597c3b434bfab012d7a0dac9194b242f99f1f4868856373f43296e2c73815f912c60d6e849db1676cf11d7f89750432162be8c7d3afb3feef2e688fecdab19d97fe0c0b7d68b37dbcb60a9766edeeedb992a68085ab1d46c41ada2a8be97d9b27e6d6a60a1762cc8fb23d7c731f5d21d33e7e27d77f0f2b41113b7f6d6b8f8c68f5658adafac1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
