<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d6f8fd2d4fd315892201cb47bbf844a659d3e085098ba7bab669b57fbd812be85a40a0bdadbaf9e8764ab08acbaddec4d8e3a186fd7c40dfb2fb74fbe253e210c9517cf0749a150b4925c93260c88a2bcb2bd3de2e9c231fc288f55412c4881b99b838a79535405ff4731ff48c19f9ed931982fc58f570edf7d5df15a994747cb6df16ce09626d7b8df69ff2b8692cc4a8a3743dacb5aea591a18c56589b4bbc77394053562704efcaf824f4e9ebdaee7a02184154f5198bf0c835850b5ea2c22d47ac6126d2a8162d8dfc61b7d88643df0879b08a63537b56611102aa180a87482f8bc6b6eea8f27ae3627adbba80b53fe719134c74ce7852ccb4e0555aa21899955c01831cc1be349756d18fb7fe8d9aa3366253d6da78a3bd7b83b11600344862a2aa6740cc8d14e1ad7ec46f2fdc8ef62c5e3c7fadaa331a64b25866f8a83061312f5caa93dc2066af6eaf7295251b629070162284152333b7ad3a9a082ccfe637a49fe400e9b8a58d1dc024a540a34f5014f235cfd79a0f154fef63babcd43eb551444fcba6ef1e9c200a54386b0e50273f53730079b5bf01ca9c46ce12f4f0fff4ceed466d1ef99107eda2c7196300db5b5398ff20da8204fbaf7cde83b46e496c295d500b7306ff18fc202102f3753dbc8cbf98defc1ae21520999f7a9788a6b945d1479cb369d73e9b6e68f6c91d4c5cd5421354b658ff98592cde19003a994cece07ff38ecb2f274914bd2c8496c94e0f23241f8cabb6f36553deb79234ca899dcd4dcc2c1bc16e249e36812b463d7214de13e7abefb8694423e69e2fab3853a97758f1df6903e87d999be8a89febad05192949177470331909ff7171f34e7ce54d48e40f4c1890bbd135b651abdb361d589a605c6f70d9b67ec6eacd3eb4e36cd709840e6126e4733a935fdf1310031772ac3f37ea964d840decf0d544ad71e0e780374152ad90a8be86b1f4ce8e9eab84422c652200eb375a9fcd60b83758df4203e2bbed804a4a4953103635f78b1848ac666375a080a03ef9dbb3926046cb9caaf4dbf15dff5a55c54143b2050c633bbb4a0992070eac330d4af6cecc25fafb1b16eadb7553f04d26c5c44b178fddc6d76e19feb022f77d5fe51417bf2f221944fa77bfaf06b4e491ad328151d562db84fd462d882cd9382978f477e053dfb10aeea1b2e3e941ad61222f9437de3a2c6b03f39116a7a8892d5dfbfcc4eb8da2ded10c2460bfe0465b8a9f8f8c77f779979140e186e9f2a5cd1db4bfb8b262322ee3dbf437142637a1d5011e0da3181b5012533bbe9755ec32b8f6ce608e41e87b10cd8e66eb65a132a1deca72ba104cc8e9401da7640773a71abf6d1d2ce20b9d599cf932f539701266039831df93fb64ac20259ecab516ec6f96ca3a9b993786102b0ebfedd6d576f00d769e8cdfd1d09010c614f90f79acc1c287e87c1d58a85edc5781ad917b2849efca50c38f69c6d09e2004efc53f0ff02528b7b46f5721ccc4a02342c6851a863ade4bf82b0e6d44442ddca69e3169c65abab63988dff30510da4f837c71536e45f44f6ea58abdbeba825da23ae2509c05b37e8cdceb1f249bae79647bd93b6c84347cc050f801a96d144afbdd732adede77d6af3e0abf058ec4be475d00c89cec9386a56295177107b028f81e3425f7ca7b2b171cd76f4cf4cbfb0d402445ea7ba793f43135ca151548c4d8825e1cf35d8c5d96ac7e19bbf3dd56a9e335f5bff0f11b290bf0f66542016bdcabeb9f36637ecd935e89b8bff9b00811bff50fd79f209d104c7120125059388e98f4436870ff37c188d4cbdd9dd37e96b379fd4ff72865834fa72b28838f6016c042607e942fb5f876d3756ab0d21739ee1a8a270a8bdfed7d0482e5bf21d12945a58633e8599c0f42affe5e9b7152d2563b799c360167edde68803734f472bc267a1cb3fd2dae32421850701a25fca23899ed17c865c7f62d9a3060b42588ef9f9529b78912fd7f4aa973ff4d31cc046bd62fd20e58cccc5e9653efc654e177ad80a8c875ac50590061740ac346a3125ef03152e2fd3d1e3c5351bb260736f683868637d7e358d3fa8e05e6dbba9bf9fdf377efca1eaa1872628f06e3666da7034f68d5d17a69c627e75b740104fb01244aa7fe5ec4dabf2bccc01c1fe5bd581d92228f2af447d849e25eb59267f586c6eab44eef549b4ef915fe81569aae602276c91c6bfe81e3cf2368a26a6f996f0bc072a7f7bc980e975effdef45f083511ce3eb7cace789eb3e295ce010e1525d749c8b12103846df1ab0f3171394e930818c04588169d263add29a0a139037df15b2ca861e393e324e7aed0c83eef22d14ff7a33a700d1c03bc7ec08089e59026f0886ed96610db892b50a444996fe3a25d9a8087a4068f43bb6e38e962e985c02ce2a094bcd6cfed840f5204a3914520b122c32cc66ab16080eb37bfbbce0e447e91821f349ef395a77cb8dc58826ca877525c1bf46770e33cdfc868aafaf1adaa0bac88e4d75375a1901346296c649f43b8d47be01c9ad8db9c480ff8e52965c5554674047a5bf403f3532d14da9ffb106a5ef75b6bb0609b75b4f978cab4d33ffb72a1b3d76aa0e5fa9c63d37f09a4cd3fcd5f8b7be115b6c868f67041dfc00b25a4935fd9ef0be31542763a19f5a651dbc1eeaf1bb8638bbf2d4b16ef4e3b83b04d7f44e90eaed7a4dd1a400a72ebc66281c2e3e8a99651bc05a6677608300c952021b0fe73dd547075c835a76292d3916d244621926f47439ddff32609767367ac078df3f190c2a6e069fb6c5b488dbcc59cbcf0a20d0986cfca4897331e5aaba75b451f8e6d0bed5fe30d0d63385c8c14a8951701080f97bd92cb7c1f243f3d438e8dd68dcb64977c161e38585c9bc2fedfd73c56ebf079160a91cae016bfa74bc4592922e55d2096a643ad211d5a143f68fb3c7f4eb8a5316fc9d7152de9cdc04c37f21f1da2297b63fd3d068b8061dd768a5b6e638576ffd2947a4e2b822b4d98d7b4184bf1b065bfc4daadd798360d5e9c4cb084bcc2f248a699fc49c62a42485d466fa33a52a4cfc01fd72c0f684813b1d34bd5b3206ad666caf6afa1ec82f74bf2e1dbb0b5233a78f5a70f1161a573277913bb09f05e6c199f581564d2291367c97175d62eb4e83e3c1975af0de44c5f6f98f36a0f09f98b46b14d9b447bd73aee7a4f3f147225275fb403f5380d952161462f5548fe87b9530e4f0513d2512d6eff4726c98cd098fd99b034e34171cad44b945c6082c76fbde8d27cd302cfb481f377dbb470ef77764f718630140ef9b4c8e76a4916dd226721d2f449ce380129b7f4c542d5bb2c3e79c2a46912884b0eefe5436ae3962be66ed233c2ebe9c2d6a115eb5c7771d63e3be91650c8d682c9d4830c14b7d494c654a9d8b87e2d2e1cfa830e7186bb543aee09618de8c2d5e12672ffecb2ef6c9d5d7740ab0bb8ee44619fba82387ce3c7cd9ae0728c7a958bc3761a0f64d0b51873e46a65a44fe4929cf666e2be2b880b4db52780dde5e6485c0a5a74dd48c234fa886aa6a62609426e2c6f0e732247c8a9d9c10f5d7dc2354c6e274487cf9535d99622ef037f834fd0333f6087dc511ca0b437bd5c49bc3442ecc552fab58dea24b3aa0e4130c39d09cb7535c2d58c923746b58c8ae7d57bf19b1baf8b903a394d41db4f41e2b4cfde49954cd5a50d5aceb20cd393076165dffd987da60570de7a7fec33f5a8cf0595171a49929f74dc3c781880a279e141e618d02717af5b66bc62e6c546a2f80fd5dc5b332f13c0bf93a1fc240607df7e07c7fc335ed5b78af9fde6203640b2124db24fda2d53b82ab834392ac8a2e53e8ca318f7dfe8de1fcceebebba5d6df960abdaf54fe8fc4e53fd40adb14486f904b5e08a36fe3680bfc651c871a45f741bebaf0fb251343479011f8bee714774a794e6a9bf0cf1cf3acd9a24c14509d25554d2c4d21d6ccb8f61f4ad3a26577f243ed6944c2c66579eef5874b9583dc599253e25bc00c16e646a738b23c1db4380d7d23b70d4987b47e39fcabec131d557fe22068162069a0facb9788dfda5e259995b2797f4a03d6970e183d1ab130155cda4064936987b564a23329c788fd809e71951260b96bf6cffed3d51040179bde33595a3497dfe84181dfc22422c6aac84a1e43c819ba16db8b54d7089053ac56e70ad121ec2a74bb574b754de731aee2aa65504ed80f90530e099c759fe101a30eabfbdcdadb2f34c1d8f346f6aa2e31d546132aceb702dd73ffe4a5dd1e150c1f878bf331d97cf7da79ff52e2f2348bef67a57fe9a10098df11b390cd382b04af9baeaad9f15ceca4a63187c30dc9342b6b2e3ac4025dbf41f4ade7bf8ca022f5f1eb605fb32a327594f5e7428881ab5dfadf60a3b3e60a37a1e3aaea62c7ba207493d50b9cc93fadeebc46e8d736c215f7ed6d6dbc9dd36b2613115258ad851bb72025ff980a3292fcdf769412c77441a0ed68503685c4558b4ef3a3b585b4f9485ed3808f2c880d74bd5b01927124a4475ece08eeda01a82fc9d0c2e91c4f185ec6e069d61c7c0bfd1adb6e16045c4490721f3ad57b37acc58972be75bb7fea05e9e3daa2a42d2f655a873e91f8511a540413b10e9636c11625ee00d24f96775bcec1a75a6da2812e2b147aebee2ef66dd760b0afb12755778a03ee3564ecc7a1c91636f87e693f89239dada4bddb09d35a792ee969ef31941dcfc40bc5becbb636312573d20e3604bb1d0880aeed5d270d0639533fe728bd669351365dc29462115fdef20c201de042a5ad5570cd1a491026f1661b02327f01c93cfbf3861f2a14f41dfa2e4b42f9d5c972b551df1066f30b909cbc3f958a9e6cd9af46c69c66bfc2dff669caccf2f3f502e998cae31aca145fd2804a2979f5e409838e81b6b8c0f43cbbe6ce49e406f394fae2be2cb92d1db4253c50640852ab09cb58a2d7b4a6da6a4c2c89090a47c9ad0553cb5733adba54744f6ca73b79a1ff1587c2c27981235278ce13fad957c5a094130b7f298e2285d203d0530e37e1d96ead72f39eb91805c3edca44d60646613bb008abfd62c1a88895e5d64c9645cc9baf0731c0b63d46fcda8cafff4566d2a1896b761054e9687364b5cdddc0cab2b31ea3b7bdd6fea9c6a1fd26892a728b6f296d44e228b8b05891aa6b8d362be7d839aa568f60201e4a9213acf505af6b9ffbad238154a74df6f36b2755d68c9622735577ff9537cdbe5c50bc0836cb82863a9d38db8c9d7c599494e95fdba006a05e702689e21668a4c05bc353f4b0f0ed43de49435895b1f9dc7ddc507e15819ed358a883e8a2c168e65f2f2a219ccd0f5bd3140df89d7dd46f70b379e477d962fd80299fcaef3c47a4c35a4227390ce90ed90233a7e637c0b2e8666d1a27218f4d112d9c0e5a7f1c5ebd92813691016c1879ac53d012468ff7aa305568c68734ee23fdb61755b9fc67988060426e4777ebaa499d447dcefebf62a898dbcdb6a22f7cab408eedbcd5ddb98763c0eb937e07f514611d7f4db5df37e65ab56db6d5e76624f5afa2b2795854903ad78703b9ba50c601bc2653fc9882cf7757d407a3bd31817f07ee81685c7d0f252d7bf8b9160df87c1c4587828d727e1a3f89dd1e103518ea0d19b885c9b70c0c752f07d6373a51c3bd711b5bb2efc6071122a64aaeeebb5c13685a08c8fad97f6286afea25a3c7587b253a556186f429fa1325da63c076e0315f2ee34dce054cbaae2423af6d57e5c7f9f33d1545d49b4906f5760b664f4a7a4e144d2e99457f16dab1a319cce586c2c84850e9cbe97914ea4c4f9d2c6e0afd68d04783929b8f365c22789daec198a1b599ee904452719ea81941187876f590adef05b8fd0bd3f10d2969cd6bddd7e13ed08e7e42830aef0b7d2e96668188616f9546fabf2c1b658c3d15b167548e0dfbf9edce6047aecf1dbcaeff5b1dd1172e2b7189881e6aa342f7bf58f4032f0cf45983f669cbf3d27a738b5c7607ebeadbe7b968f87764f2c71be484b7a0be9d5fb02183f90e536fcb6d98d3a5d70919f693200b1103972b7b3d1cc20d54a4fad6ed4e5a7589dfcc12bd6d0bc9514c9393457d242395e8a225d4d1492f96e30a959a5256faec86d7acd1e63456d2352e1aa6d049306e701817497ef2cf2dd68a507dd228a232077bb040358e705829336421295b820dd39dcf8d1b600696f2717997132546453c81a5303f174371c1a91b44d58f91dc49d01da8520184f38d4600ecfb93e904381f52a465b1ba3a472cfd4613c7d32fed7907f372d9b4d922a0e7eb8c36a7d4d4528694073fab28e6c808c0a22fefed51ef5f3004b63957ddafd97a79c2fe5c1e7e1db5d62d3f64328ea82abe7882eeaff39e9f53a3d465ddc4aa12b9b40dc701709283ccd02190fb7406625b385cd7e56422b9011a2228328181c807db5680ff4c742ac1e4dae66d30d5e20b4d06e5ef3d95226baedaa014763fa967ca26c6dfd1d340fbcd146908e4926a9d4acc41422f3d172ee300a1fe91c198357ed646433647a55179f082fe6421f9ae6e274699d28e14ce35124499fabc3f459178a5373553d1b5521bee6f844f899d9927fda39cb82acb5423068c733790ff4e781c88216885db85a5b4ab8b762c55c64dc79833fc1442b090ce1276286d042d1d8824688fab5d8f89d42bd1c6a4be02145152b0e72199b657f974032ea09dac4135434332ec794d014a9180f14154ce510019bbe45e95b21b886afe023c7736430e5fbdcf2b497cdcfa0211312c9f1d7d2f4e8e22a98fdabba6a41800314da3c8c945ddfe9b773a7888ae9e24989dc659d2dd2b14c7d948abc59ef105d31e5340c5005ff6119840777362f708ead95ecb09bcec58694973b71c0520a3d6fcacba89e12c5863915aa2f6fc63f9a35c681e68bfc0d9c2e88cb0ec3bd5cbdc78cffbda32a44379e68ed109b4dbd9d318bdc60f15b8d292d8fbdc04861031b1c42c4eb682a47dab94a157250a4274275755cb9df9814db950d746751c2b76a07c754d5b30108426c9e3fbbdcdeea78504e106f1db7e1b4eed50fe3889ca187754b7374bc4e1c4b7c3774b1ed4f1062c6a7df711d0e859c2638e00863398dae78ea49eaef766ea064118e300e46aaa77b49221dfe54b2529f5443db7394ca76a67a591dd6d70db8b9b5196cc8f4e1c71ca2aabfe6757129e00132e0144cf75764000b35003b9bc75456b2a249101235f5f7cd8a0b7a05d5c2b3d79c6322b679a069894bb43573d51f227e26998b642b5b9e6ea5e5f1456d2a6347cd63c90db596fd9941b21d53c906157e2c9e7bd7fd4029e49975daa86359658b6db07ea9d72c53695770c89cbb7d75a1a4ff5fa20f4f35807c8ccdc02ad1bad051a9a17a875ad2b0bef713a49077a2a5c8bedc0b34dec4f25d5394989a53365ef787e5d30c7174cbae16e72d29cff3add99e8fc0570f663b6e6d51789773f0d5f9ab3a102c23878dbbf63e353a1f198d70c15a542fce4ba7a07645f9ad6e0efa22158caee41c805464fc663e12d28d5eb643074ed967792aecf76493cc497836441109dc352c84a0798adcf7a090dd1622320dd5847eb47ef0942cd62475d103045bd31735664f1ba33c03716e0b033092bccfc5155ad69db3e9f419a2ab7398bc7cf264ea864f054292ac53e7bee9d27f3892c9b7e13ca8b2dbc7f6bd28a85ae86dff1a9a5f3d89a54e4fdeaa306b6277d755f443bbf4bcd6f47e9b11994636dc2a667f4758aca8e9cfb5bdd57816b7676cfa4458aa593109600c282c50e996c1ab7959b839a304de85ae729809a5a724baa90d2e86e6ffd94c54daff0dd13ef8f3303e542d7e307ef9e7d53832fcc87ac69115c8b5a579fdc2c066b38baa55181b3cfb2fa89c92fe6b5ffa914f86d48affd9f06bc828f42d6a625919ab6d1b8b37cfa225f83a026198b0b28b59026a87c57985c6663f3fee927ea832345f5b748d0f15734a60a894e1ed273e23ac67cfb33101d499ba10cd6532a91f1128a8cdf99acebe6bd05f01b1735dd1b0b51ecbf1536f84a250883122b2fa1e6a5224cf68a489c507c9c62d6fba35aca921007af71d699a1cb0c829f498bd023b625fa97881b144dea416844f8c85ed7972b4d4bc875f9a5433ef8a7fcac74768b9a0863e67512db242e9b524e37dab260749d7009cd7637a3dbc5e6edc5b16db3bfaa2215740f4b548f89248ac18f641b65d30e8f97a93ec4703674cd89e13eda56f619b656983a48e231eeb8cb9f0247a69d7ece0145798820b6212bc5191254664a3eabe0632c87af04d0517c57cb3dcba8d19f0f70d6c60e4c0fca2952ee26d6d7f5341d3d04853d559dec8fde548573b57af2122d00a62cc84ace6e9bfbfcd98a50b3957b9223545bb34e6a7c8683674bdfbef13b16785d76115512c68412087c95d29e4eb51e59eade491bf212266aa57eaf59247db36e34d9b770f710874fb033f302a9bc6f2e23a6e9083181734f6711fa0f9ae94c8e31c9d8ce48a76cfc5ef33c5c74c8cad3d16a904280f4299388d3162c69bdbf4c5b9c99ccea5aaeb7c52ae8bdfbd6fe94d7b71c6bd09153d0171132c1b42be33a539050f87b45bcf2503a2d2327ea2ed623d6666c6a25e0b43beaa2aae7d5a2547f4519a086cbb6fc6deb83692f9507d04cda3c59516505cf4bb5a4862a617e337d4bd1288e9dd5483191ae0e511d7f11779dfcc9a6186f7c50e890cba58935ef8ea3c03287738fc58e852d6b48a14f9f76a98298016759475d427372a5393872aa951c186a08b76f9edfdbfe84f5bcd079e8983c6115ad91855b61b5d802755dff18c8878d08838842a478cfe1949c18668335c6e5c5a10a543d25b65aa56bc6cf321d76ceac28156db0cbb0d2eae5893659df28f53e76880977e6e706da5a58cc1bb4bc65d4e62bf61e79c61bb4d2bbcf7f90eb7e734c015076997b37b571937ee61b06ab2565d4536e405edc3cbd24dd88a6f398d537640a114d9e6f76b04aaecb4befc83f9978f9dc5503a0cf9bbca26ba33e4aa8579824e38e628a53829296356fa03d7c1b6ec06bc8d1b20b4cfc991495e3f1c601e4fdea5ff44aedc976e4cda0f664b196e518a8231980b630b6b4fde9039360b34e01569bfd2959c6f213112d66333ff0cb58bc04c28a5753c060eefc0d30a966446071fd8e260a981f29e9b5b833a8d953d94152323e0558620535b22c4387b02aeeb9b9c4d134a778dc78e3a4cb1b7b00ae20024b6cb07bc9aab96c940ac89cb0c514b2856711092e7d8362da88b6d9c5ddbf71c72467890fa76779baef33036a09ad700677bc64dbcf22fd05b6315ff5fa0320a9fff466f656cf10adde4a42550bca5064582e10ba3afdd0d29971e44051bab1266267dce617f5a6412f4be3f8961653895ef5c83346c3462ed50393d7e4008d8b650b59f99e0b1b8edf5d8d7d8bfd7e9ad593a5f640e333329db7a45eaaebe49055fc7b2721902d0796b2cd5494b81d8cb24e3b588882d13ab5d48f0e39d9b5acb3f850482ab135ef51dac16cd11a0566c02e0d2324f6e62e3077b8ca89992d8d593b19eee08b48723533f1685c6e04f5d1d2a08917612b5435fd7c2226515482e9f7ad6e8e4e67ec36cd5ba24d5add98e81a2d0313e8e77bb2ed6aab358161fabe5a0f97e9f9a3f8653a7b87d90e49b73e1abe144c570e706d3ba0208b85994e68660220975e80302cb93279a34a6c9addbea8f596ee9b46e4dbd4eba052489927bc87ea32ae0ea71adc115c6abf6671bf96f77e4915534ee2f131c3e559bda912b2daf0f42b3692ac9e73f677784aa63dab0cc6a2e59a12232bdbd1a9264b7ad788928e7c9351544b80807f5b5f774db57dcfcd8e04af15e7c58c117dddb690a9a16936b2addf6c6d86ae1d8121e1152c7e123d5a32d3b54b21151fed2e4b635d01b2ae2d8e573de33eeba513901a086febf82b6706e85d0f3d9f1624a0acb5d85df87966a28b3068bd6732d7c211c2c59499a79d20c93aee18956b3e93466716f1c090ba9c952705eeb1fe8c420a6bd80678c27b39a37dec7e2de186cc7096f77e84ba3b0f78346688e9e8d4a74ca16cfd67a7933fff0db894ce8840ae8f1642eaa09a2236487bb287e9158967f60db2df37af950eb560a7afcb4b32ac1fcdd4a3dd61d3adfacef0b38f7f15442d79c7536017ff5c623080f81bcb4c5a88f1b17a0cb27869dd146b2f8941c9b0c31a79deee29b8797cd35fc706f5bd592e6f6d8c4ae7c7453f0693961704bbce7b641c3bd47336c8a6cea66913bf3ea6e131303d6164edd07ec3072991a6af2292ec594cbf507e927de1a4abd9352854374da213d3dd9b7d4608865697ba19c104830b1c0a35878a4f2b3d84cae6c3c104d441942b080ef22cf9c093768c07c5b7176fe7a7270b6e295dd257efa7db9a1dc7586cd1ce55f6700803b908c40b7e1623213113b1d8af4a8a834a0fe38f6f1e46d437ba195fa69755cbfa4ccb1c915c49b137b86a6b0608811158dbd0cb5d8ef94271d3693e008e276bf49f0038b7bbfe4bda7d59083f8814feaf0649c5c2834d5df8a8c3041b044f380f1ce6e422b7f6a452ead8fad8f18fa96ee51c123f06de0c2cd4c2f62e418b5c818620c1b0b2d13b4166401530368d4b0be9f6f4d2f987d32c02dadad43e969171cef4153b094f74bdc3912d089feed8720d158da4f5b14576eeb6bf25981d483e0087a76d6bb2f8d7b7fca341344f20f7ef4176524ed25f1c3ea1dbd26b8c61dc8a69fa8d1d8184672a5f94cf0c1a963ab1a86965d380a55748d787605b10ad707b6711918466671e6aaa413ec08247e2a4d7b617101b3f900facb32c307b30801c60096ab476d192aa5a4708042a823a43761fd30598fc5254c8665d520a7af319c51398d060b12a6d16877c7853937766ea3760d11302323bd282e2594a8491d5c36f702a09099e9607f29b1ba6c1c44748656af9ef460ed94b16429c8e2a0f4c16c789510abf18fcb7471e63c7286405376c52e60f033d57a0360b6bbe4796528961f3d72f2099d329c0a878066d050e2fd791ec23baca5e95677d50ffc2361186b642e254c426ea5fe63ca2620519b16ec0657ea486c1364b0857df008b1429634e206736a917f326fa7eddbbe35bf9ee9ca1d5dcc067733659bc79083c2861631c16bf27daf7d34ceb08a2c76c0a730ace65b3509f79124af69457486941a642eb3411192cb3a6b74a1177d3c26694a4928f9994215c3ed7d5c5ff0e396fbb45bfc7fb0db16faa36613659ec24466fe6fe1f685b6172c8f7ca7deda331da573ac1393f95e070770084d829408ba231f9f7a39438f286977042e17967db66d5e8c1e1f5863a8da7dee5514b32c9c78e3b2b3f24a9ee28871d786f0faba22a54cccce505eb68d7d175102639003576224e5df8a9dc9d831b439bcd71d476f38068132a8f13da623d0d93be9954afba26706969988ffcde066e29bd01431f644d8e9be2af7b4d9dfd41b2ed002c568028623db91a8a0e74765795c91f7e7a6f7ca0cff8ad6101ab792dd271e6dcef9fdac15b3411e13c7c30545f8a02b33c7e479dbcc96e0340bc368d3aa7e336cdd40dceca29acc79a452298efa89bfab50a870aeb42edd32f9a4debd638e92ff1c614455aadaf2664412a1fa2cc0c2c977d1d8a3343194bf7ef7b4f7776cd5bc4b096f35efc45dddbe1b15c9016458c406ba3044ecd9ff861f8d6fb1c474457290d5e00bce09d08d513a72b39e16a99ae7afe48bec6fdc9e79e7bb3fa06fc017647c2bb285245f9e0e83c51fa4a757655b443b4e2e109bdf0b54a1f211b7919f6723f93ee0908a2e29fe137db38b5f81618f6d1feea7205be66d08a9d3d9481dfa36b2d5d7cfef2478b73ca6af411e4ae29882d4f63089df59f23388462cb7bbe75228d50880925576fc40a5632ada7e0721593d9ec3b6407eac502712ff8d2374895d4b3c1e503ccbe937e63be7080d7983e826527227d33a970e8aa4b81fd875d03f193cd79f7909e609db0c57c24443491cafc0bd652f1ed17c110e85f5be3cfa1a6a16e9f8132da15d04c67fa159e2a82d0946e90f89287cf139d900dd13384a09814ca2b5e11d1714c3d62525b1a399699582c22637943e0ac4dc582c78c0d43933b779e7d343a46869932edd13b96ce1d3500b1399e9b4c427dd4fa7d94be62c93210baf267808236370eb2a99cf02be2bda7175b2223b5b025b5b53b22b5519c9a4e1cfbf25a5f9ab861fd20a96952d73cc767c3913a1dce80c5c01abadd340e3f74789d0883e9d4fce791b6acf4ad7a93efcfd445c2ead13e5615bc28bacdb91613ce4341010e9fc57a38b62b1bfef2b25a58efa9159c934345448c9ede9129eb6fc389e52891b5ab464dade6ee3cb1384bbd7fd5dc28ccf570e91e4fe7a69ed88cf7eae9170055a8928d18c50133b886766211d171a61091e1580d99b9855384f6382687250e7e44bd18872ec68a68a7ab58228539546af5a3af8dc33edda5822557e1f6afd4c5cc6e389efe2eda18a27335d17f1bc0161f946f5387976bbcf0b375490507c59a419bf56b36e1532968eea08f23033575a64e3c90e11db81b21af9a863248788ff06aaaff7e9531f172a609b7adcf6baa02bc817979a9d29cf02a44088d960c564587cb1b3d091aa0d66bd1c6ffbfd4d71c5ccde2fdee3bb922b163f041d0cf5ae486b2f481434b8b9d426588e512acccced038b27517a76e79ceab27d8cacde4643d61b245e913a460c9cb2d64a423101012bb5ef21779307727afac4cb95fa20788ea7e064235aeca56b3c1d37d2543d7dcd318e6d58a88d11aef3975942151acd7b268fef97b17d0355b61777cbc1bfb8b26b73860d035817a9ad49e07c37fb24ce39d12a20994bcea419947019058dffca7cdad2a7ca88072678080ff73cf1bd209e6010631f66672e33b59eb02acaa3c31e84f1db13bc930c0e5f0178ccfd490b379b35706c0396d4abe45c789f971aab8e6b2ef7d02b098f0105d666cfb4b7f3cb0d7b6f4b1e5bea60ea92e7f45c8862f84402613122c63a3b07286110199789abdf59a85aa6cfa36899934e7d807772a66da9c94a3d59ed5478e5078ed9abbd9984dbc90151a67a5f2d2601e3323a5e96524218368db5ac4fb221a7b14bb73f261b520e209913e46c1dd82c9c0629df6838a8b11df18549199b7b5ecec1516bf9ce6a9754f549421e1b925be75d38c3d84acf4060686d4fbedf78cf25e7541beca5aba89af478fde9b59a0575ccca07cb744f67df98af1821faeb8e82972938bbcbe04a7a14b7d1e3a558b761d00f8545c1e6d7effcc755ab9590325d4a72bbb437b171c0f77b389b76309602c2afead677aaa3e3a5c6155ed454f15d588767848a54b72d8e0bc256524879324014a32c49f881bd1f1b058ffae4109c49e4298b24b82dede96b7d6604b3ad12d7d7a0c38311afa0ef620f0b2a2a9dd4d70fd80da0d791ddf21d23d6beee2a39d0903a1039a5fccf55c28a78070b5470cd04853b4d03e88c957416422de8ab31ff347f2b67134956f0060527d43cf6c62692e7a1d9d4f027581b93ffce0a8e13f56b94988fe6a0e05891ecee143fbcdce883e0841d15743a96258ba67b5f17997f402a9cce6f3ef0294f2f6d226e0e290d532cc87b430dcf46b5b6623dce0a31b41d8cc59afad034aba639c78e9bd7ff11eac444a093479919872f1ecae60d8bcf9398ccb2f156b3bd57117767f7da7a2a3e02ba9d2bc494c510ff7258791fde64270bfe0f4adf787a3aa15119e6ffbf6bc2d04f694df8a27f67fffec36d737510acf92fb59253843c0709ac29c2be28caf37d0b4ee07cd12aa8d8833d29966925409fd2a044da6bd8a810e22c0733404a51df48ab9cc714ef16ec5e2a0330a8f60a944b900853792d654a468b0ec17afb792a64fd3943d20b5150c7d2240fbc1f2791b4cdf08a4817a6263e18f3b1addbc5a5fab12a4f2c1617ddef78dbb6a1bef976f210ac8c26f0e5dd1d37f92b01ca88ce5e38206a31f53c5acbedf77fddee7d34eff1567540d6366b85ff05ef9611d153749846090e896cd5919dceb0afc791f312403d7e56720bb6071addf1bec5d235355877100e1322d113eb1a649d591f032215868b739526825340b43149e0271c81151f19b22cff8768f61955d6d5e6a82942d675d6e4970b4353215d63d93b5e77470d89286b47ef0764b560ced2437e857752c1c30d4f2e8ca7f63e1a6d9b29e5c4d861e328ae87761e9f2884a6460a63d2509a6b766cef578ca8ed41d9bbca8d5999812392305c3e804f2708ff7cf09abc6929b0ed5c9724c17d7ab8212429bd3ade8f498db4c15d30b23a00dcaffd8a0f707c5bf29bc1f639efca51b8b8dd4818baf71e581bb484c13c33f96c58c5027befe2212a18740a80e50cc8b19d2021c68f0d549df2e0049470b37a49510e6dc6b4bce3166c63d919b977c1104e143de13c95f1408bc35e4ebb055d251598f200a94c91f87bff4a14c3a35a06e71fdfaf049993c22c066243bb72b57cebb9f7d804219812f362f545922701a602771d4d36437cadac7766eb4d376dcf417ade161a09528dc3180748a4d0eebc1fabcc5958edc7556d8df053061515a5ac5db2c8662faae132d30c897a9505fd690281bae528177b6470d8130af5e21137bc309cabdacf62cb1b268821a5e80374d5bb06fc5a8267a20ce9d42147736050979c8e4c27e19c34a2969d199bc79aba87df2ee482762d3fb35240c88675ada3c16334aecaf40de68e8b39b5a5259c5974b91f1d20d93ca16d3c2d54d7119e51bfb6df799f6e012a2f0761aa1b5ddfddf5be1c15a78198a5e40e3a5867c55c4cb2fd395cb74a7c9ad83e0ce6be62bec7d56c2266e327082f1c5646ca3b6f22cf753f1f8c652efa6384297e7357ffc9de24379bf1ae7a488b8e751cfb1a4bc7a832d2f83be375a0bfbf7de8fb63265817d9fb6c76c88af0234b52328e8a3523df021250c66cc841a4b3a6cd3ef4786ecf23360b27ae3e3a7a32df8a22e0aa35089496b71d9d16a711d6a041acfe5b4176ed447b8f77e1d7cef5b554ed5ad15461794ba6a35539698840d034bb2d32957094fe03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
