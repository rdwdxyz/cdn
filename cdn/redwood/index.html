<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b22581c2970c039d2393f8d9a2fc8c7e0ace40bc58fa9edbf3cb54e993cc9496b07aa106e7bbd87461f2deeec5150f7544e2300a5f8b7628889fe47c2d162d76c468037fa9d6b51af3e91dabf75511a9959c0ef2bc44afe81974895544db1a40c682389051c2faebc40371e4bfc9b2d8387975dd00f603a0851fbc78df157cbc615fe407058b5a642a169d202aa40d21df6e027e2e14053b4b44c1ea08e15370ab023ed47bc28c17c60dd43e41a87ac5d22d596f3f83ad0326ed2684150caf73cad782a251e494b4f4f90765aa89777396e4f183ea215e9fca376e2c0137ccaeb35a2a82f664cb73afb39df77c74d5f80755bb373202259aa9508be805782558a515110ad79088ec88740bfca6c6106ed825b74a59bd34012c41a4d604750b66c7718de9ddd7889420d08d5b3a247a1736b00309b95643eb1cd545a059d4174d63897c4e21a60d309994f97c3b626cbf759ec031f703d7e92098771ea788f9ae42ccf0e2e9e5f7cd3123d5173249de40230114da5dfac0f9a06a08cbd0aa9db6dd6bdf383ccf54b9b610c4f3b861170e52a971f4769661a15e6796f8f777c3d8fe3410d576f59bf843691179d2241ed23e6e5e1ea94c9db501e0797ad0f9b209501b5c90ab89b3ab300abec90d50dd9fad000f2c34b0ff7b1780902219c71e457d0f76a1aeefab748ca42f89f4d380817c7ecc32a6c90100ebb1de51f54952b39b820fd44c9f410edfd06888979df0a3c9d96be4b7d751e932739337d452d8e7c4f4aedc299752d9a867550272a7803d3affd1652497f2566e32c047395672405a21af49d5b4d4cde0dd6ac2055d5c53e203245a9de5f17924fd8b6d16681f26e0e63c0b761fecc4e425e05f00dd813b6c3f1178252fd673a54e5a04b77f6d0a2cfea24cce8ce2d31c22c61a1247580a09010dafc89f8729df46fc51bb430065a6e795cabc60a2d4d10829cf821ab13e8a625c401e3f75c763b6c70e8d63da072b49e3446a661e1fc1450e91ec796748c1f3fac839f5a9602e0f3bee453cf4b81658844843f02b3d3955b6c92063bfd8b1070dceb48db213a2d212511feb2324c9c286abf8b7f3e406dc2d3fa1184a18762df9e575aaf9a22d8a3a5a48272cc007398dc415ea559a2f51a541b7e5a4985ebc3af5ab288c64c3c632ffe5995115216b7d3902cbfe0b41a8fe2f2f53408f2893bff1012b373d66e04d1a3876d00f4a313c103fd8d8a1714f8d7bb173bb4a4847a0236bf84fd5a0b21347affd275957ab0998e31b2b59378a11660bb68439418b47004042cd3b1cb510ac65b6ba2438e208b08256332f9faf959ac05ff39c0de55a422182ac92c3dcd0ea5251720502ff84530ee1616a044d3216a13b0ba4f121453fa0734eed3fb6ea22f0173afe58a2d57107ae182c85a80c48863d5e777f27474cacb723f79f9f2d6632c0772df10d5e3b2ebe626ef124c3694c7d6869ad51c9844ef411011a5b9d2ff869255856d05537bf45d0544963344af9c349ee18bd9513daa13fe9030601e3ff80cefd183a004ebe5fa80292ff16cf8f57d381f7f95d91ec3f2c93ce136a9a4af2d1baf79a4b024a3fd3f86c37d82d8293b7605c96f53934841c30370672f5307ccf58c0b86dfad81ddfee7c2ea446d4ac2219a2630d77b6dc9c95c1393c3ea1caef0b412774287e9c1c77e10c995110a08f88183d8d99fbd5dfa860a78540bf3b58f4c98f75be4d3e4a7e52cf0f4167fbd8ade8445f5d30e2daa983e9eff325845c36aae783974033ac3ce2f2d439b61a7c5871119e09646692b4afbb9532322566d8e8b22aea8924ffe58eb439d4ba7d4de53fe7d55bbb1ea306d9b73ae2f023fa45f3d472c4b684e26158e15bb2488a3949e276b64b9576a55bf63088f2715235c387d3ef6ec1202b3e73635cb58e7495f720fa05d2ec31f20e4bd3d2b4f3077600d0c6d0dbc32f0f3479105e3001d2059f9fef3347c602de466c9940a68459ec58dd62526912c2717f6b457cf3a78910cc96f52332ff64f1eaedb696efad7b72b3d13fc33a161081b310f0c05c6d8eb8b673643723cc7d674264fca2cd48c10f4d9ff8c87b913170a9725cbb6f8802df1dfe5decf1fa70c9a8ad5afa85375c7c844f4bdb1fec7a2e2e7a25ffd48550556c0fbfb19c3292cedcdbe1fac7c5b2181f1e2a29971d0e917b7475bcfb60a9521251f75c6e6dc5fb124d77867f6df16980cacfcc7b300f04a07237c815ef7cf8d898e62e34995f162cee2ee81db2a8a1ead1799ed68062f788a1708dc1d11d733c0f91259e59058842a3fe87769cdddc5809bff81e6e125e0dc0431fcf6f46d4b98a7d8d4fe637ae1e7713885735286732c896de8d9af3691f306da563e719ac790baf70f73257d2f53ded283189feb50156475d2c9e3ed017f991a4a53d3f8966e47d9eab6836fba20201cd70baab70d06994f61d6dc6c2ecdd4f51cccdeb3fd46f7f7f30bd9ab6d76e05c8836f47ddd23aee575cca9a3f7452a596f821d95eeabc25831603be7eeec4e106f5ed00568b9b86620f11386176e1fc7ac7d2665c43a63668866af7fe26e84161f1933c1f0e39d348ffe737cccfe938997b8408b8844beded3ed47eaf9f93aed901f75d116b511d35bbdeed7e31d5fa6c75133495bb34a9261cbb09ec43bbc6e1bf0bb570f91e0a8ed025569c1483f2f7a975b10c7bec276ecf912841c2b2b4999159b7f4a09c3cf615e481945fc0548c7dce10c04b416aee7154cec8f34eee2b86139c9d3c0afe27ebd6de5412d36791a691ca357b209d1b211606977fe3c36bc627a5481bac98f60d9d8a088a46846ebf9067538631b5d128ecd23d597c26f027ec9321ec7952639d6d4776331ddb2e251a8d9e72f66fcf93f46b881c40680394680e1c1cf56038e103e89333dd50955213d8c20785767566d58c49970063c0d5d70427cc70c238d32fe885cfabf9b696c273bfdf09d58a2b804881a9fa1146e973f0573bbc308295c3dd5d6a9142ea8165e9b2435c0bf6641840170e5e56d0e1de5ce9a06e44483d32c3043e48cd84896cd0ea5fc8bb390b3d1ab7313b74a1d145c1a60ad1dca959ffb908c63074620031fefeb1b048ab28bbd528c9e6dfe9fbcd8ce8157c8dcea1bda788ebaebd6cd5abe48f4bec6bfa835b89f49e1d248d6faa153116d73586ea44fe40753219b770d25821cf3e8ac5f97c9516dd56cc58ef60183161f0a629d6eedeedda92436ab5c3f397978b3ebbb5c622cbcb91a04a2dabcde597f459fbfc7b89e642c1dd471334c2d132bce0f991f14632f85d87095cc36fa3ae466b2f79be04b8aa29fbc2d0413aab9f72dedde0f82c657a513d247ffb27cd0bbd4a42dcb8010ac95f3846519682881462daf725fb6b8950a30001acbb70c4b755fd5a2542036850e92a248141f8157cac841d3136faec89b6c960291b39b623ac61569293935cae2206420de5ebe9e9785920565c7e7cc7670c1336d2863bf9d4bdcd23940f7c15d56d535305093bc7c2f1b2b28e410e0eed18ef001016cfaa0bfb7a393b8360445d21dadcfb984e511da2ed0168651ed2031288c6948be0269e58dc137cc197da181d51c99dde097519a8f7c418354e6de7c8a2c73e366fb200ad1f9c1a5efe3c679a4cf48c399a9235ef493b31b813e01b6bf2326e8685a3f6c6ed55127fbed28d34759af335e41b4305eef4adefe4666402966e523d2dc334f39c8890476ae86a25ea892e65308a5ce04abf4b4a4b7163e693b6239008ecb6a9350eebd32c146df8aaefb1dfe77d680f1cd0dca332e27f52344796a44f0efe15ed75b8547501ef7a933ccd41629231ebb96eeb596f602fd0f2821dacc3d8458e38078403f50426b0433d3fcb3ecfc629824aa70b8c772e65d12c0e43525376a1956b1ba44855fa49f176b42df8e29606566feecaf2d49d5363dc8857cb2917fecdbb8a5ef00f97e9e12fe60b4fc5fcaa2a91de1b1e750251f193844f1d905de0b93a4f9eac8f138aa23baef9d13713fd1dbebb9f3d6e4bbabffcbe80c4185dee23b695baca154673b64e7102ac9e8edabd9687632cafd776687d0600e2d86a045140ee4a54751f495b349babf351679197cae65681bbb86df0a44d28acdb99d3b82b5eeeb0a35f67b5bb8636d1ca4c37c7f6f3693642dd51e7bea926f79d2b5cc816185cc197faab6a50b3d221f8d30c315f53936eee1fafe6cf07541e5ca5ba04ab0a0eff134386c4f4a6e5545e21f75359ca3d4dbd446f0d542b91ca39c24ba7def45a07d824d47760a1c8ffe54a5f459b61a5c5c8dd304f2c8ce081f4f2d4cd0f48d12d65d38207cc17b71a73ccc1a62b41739c6e6e6475ec688343b6c2ced567a066372c3857a414365e49dadebc6d2a49f16389e0ecd1313d9012e7d3b4409cdd95beeeb2676467fbb7fe8b4b8a394a098ba2e928f5cf05e03fae912ab0e8799f48053b68c0d04fb4e5c4bce7a03d53b8b4654e63f3465c12b8b356a20000d9cdbe2f0a3706af1cd14ca3e0020b0b851d342e9a8064ff685d7dc14312df64c916e9165a5394cac459657c950db932d869fb53819ed0537e794dd7213f250139c68d6538c0df32a7fb0756c252912d2854571a619ab85eca1f1e81837cde8e8aa9e10016695b3598296982ec7438b463d40e78ef113ea9173bb6d1fcbe785df1ea3c140e4397f1e53f97549e619ca0660c75ce961468e6d8fff70b46d2df895abacf8d1a39d8ca518cdeac3eed63600fccfbaee0d7afbb6b1de667dd1a14464369c5793b4e49365545500645cf1b93b119aef8d5fdeedde41dc31f73be40fcfc7ce6012565a21b063e6a948149b06b4fe6db57f8ac22c3a8cfb2534217edf8ee210a29c4af418fec1d0a2c3493601540b0b386c188d08f90826e27a1c67b56e27b78616f5c3982e88dbce13882dcbdb20414ad3dd35e6d64ffdecbf0d49b5a731ea07426a77ddacb7e346e4b4e6028d391269d05b3c9f8feb88ad5b0c460bb8c5916ce5f670adecc97dff22bdfbdc652ec42780206ac575354e99b5ac410c3e8ff4414745aef9cf4180fe1e4d92daa35f68fee8478ab4d69507be9de2eb07bd11eb9b5f83fb069f391f1f2279940cb3ac6f5088a5a3cd7b6508833a900532c42fd7d967baf6e5ee49d96f9ade0edbe12960eb6dd46e9a8119532edcbf3674edab6a2c203e121ba81c23845e1b4d1abebc29e2aab39edf39ba4616ff0c42b99d843d1afa868fbd95f2a6c657ced11cec8658019c988eb672c8bacd6d26f2812985070cac97781a641b7e29504a627e12d2bb799827eb20e2db03bc0bf3a330c7db954b95311f0509bb6a4e72eacb3c1fc0698a3dfce1321861cf57678980a448d9f797be2aae06b053dc1acb3187f3abc02bc22c28dc15685306bb4c8d3a0550fa096efb0e7810251d3cd35d87a44778db05db25f0c4fd70fd076e76190fd4dd309a578c71d7cade3948dc1e1de256965197bf6d6ff102a80d0bfcefa4559c653b322bdd81069a4b91a5e58c19e135c3264fdc8b9c8aa41a0f05bac6b1eb871004a4ed59747d95165f71c8988e0c7207a17bdd1931a9a888ce4e33d4b9d8334057aa75cd49dc061a35b150e7e08755aa494c5d481b4cabfdc5cafa1d0f6975c01a2010b744a3b391e66540e6d6c52bcef1d13abdaba7e31b1af21451ff1f2d2ecb9d177a66b4ef30a3fbbe997909f13dc1f7e9fd8b654691c11eaa7f59e4cefeb615753eaff55cefbbd8a6058e16f9f23ec0db00c6e03698274856f8b42dbe6511b46f4f3056b50b8ad228dfce4b72e2b4f3cdb8d68f38abf2664a74206e7867678e8db0414a97147316f8bb3344aba235c5cb73ca06febe86e390d78e8ae20912958da5d379505e003458f2875673b6dcf6053ecf991f92332c2cb3cbc19be07ad4a506eb637270970468d8085aedef8584cd535418d40545a0c17181420d3e5eac3e62bce4dc5b43cca278ea4355245b269ecb5f9522eb3f74c0fcd6ee248881a3d2ccec24ad6c1610b78718ea58f5defb7b19eed0a22651de36c37ddd5782bb8171137a69fe79c5d5169c632f5c9028ac5510a536e947d2f8215fac680ce8ffc090cb9f3d933f58c80c69a81f8817a3fb1f9abacbc0f2287f5d1a0698f7a7bce9b1af1531300822a85552cdfdfd9cf190717408cff72ebc8fcb1aa3f55d04fd13ff701fd631c11227a6de32d5004f4f48f8f55efad98ec2a8a62628bfb47b3ffee3719d12c916d6eb10027afb5ee2a8cce79a3262a6e7def054ba5c47493fbd59d6241c1fb8ca19b906b799113f5c838b4eac9769ade436338e3c093b4b014577b02822ca8ca05fcb8e737e87ed601e28d81a9009bb7ccdfb3f64076e531b0b3aa1093eb4a67ac1a356a0a06fb40e01d40683b456f39403abc070a17e84b639e4eb2da9df00a13cd208d5124d52affc2601e09e0f871adeca8403e240f090150722732affd4e20a2f270bc832878845c466f04cebe70f637e17c3ffd11ee73ead0bd0b222912b83d7e6964e04871e1824edc354317eec3c8d2c5c0dcb25591e5202236f9a8e728dbe6d17d8d03cef470f6130a83851e9e8dbdce7aa9211725dd69a856455d369dde8c3baf466d50f72ade8631e974668dbd0e317558c9cfff3b896ba414d6d7f627c041105f900dc8190b75d7f9819d564ffb4e50bbc9c70269ac8eefca43526220ab3c19580f3e1ad8f6131b9c40419bbae9341ce00e0e2716915c6ae34f9a7fcebfa2d12638409732722a469f1800a0509d1db995e5a96ca258411bce482df4d0213a0fe480743740d3c394800152eeff4bd76ad21f863feb5268b9d953faa1027e64040af67ade9d40036da547989aab026d0e2a773a2f84d9c51a9854a6fde803fd9e7a0251a1d5ad4f23a2c754fe3e80cd472686992aa98d4a92df7cee7ef4cfdd1e344ca3ffc2fadab05116c9c24178957ac0fafe9093a24d86398f014d815e5bc69e4dd6189539428e5c9ac309f086b1ea5d6daf216731b42e8a759d6823c067da53c867014a750162c96900a28ec80c106407340c8eba55f868da67921161392289a1a4037838c643b4929c70383c08a482b0da516b5b972a4ab5d6468958a1846f7031e76713b168557c697e37e6b315ba07dc7ce47d4c2bf08fec239d64ae714adca87f1f641f5de4185c8f6a6a5e03ef43e198c2cc67809cd215c1e0b3a54315c90df58aea679e1a193e0cd68c5371e7e4e5297c804cd088cb4e9c9ebafda0f4fb19af8b1151c3150b6a395e7be71381b532487ad35f037b64ccd8c33e57b52c76b6a70f8f7f4413eb3884786bb29dfba11966ddfb876af493840a075c5324dd1afcdbd7b7311cb309ad598ffff4367e54537c885de160cba538bc5b9afd050e343604b660a4fb22a6ff58f13b6f23bb46280ef7273ca8a99265128717e9b1bd098ea1902d11c1e3171e60af8ab4ce82631a679b5c6a2c3702afc746a2f2de698fabb90aa01f0a101db06d7778af755e9a9fe646c3a208b414f369598bdd1f6695c609466befae068f6d524077789ae5f771f747a8ff0188ac296a885bda35ad49d64cf5034ffed0e31696e6feebdffb7b3fe4d56cf21b416289f2f9bc0a5463a94e69561a999b53ccf9f630926f3f682299ae3a3a19b27348177952785b40b2cadb5663809d22eff7ceee66963a5f0a4520cf59af077ffa058f8c38436b9b6a4498f84907e1589f6dbce40ecc43c5c684ec5d391d6ba7eeee4682851360c38b04c8b7ea1d51ef70bd5e8eae9803563996b134a0c596bc655f3206b989eb9c29c6f62a4a01ba6bf23fb96a4828a8a4bb88ccf071a60df99a862cc10f0de2e2303fd26f787772a7227c0df7d2a96f372c2530c9648d03347f7a3d42c8e28587f92bca656183e65c0ad5574e37564ef3bbbe0ad83943bf979fd096eb95c174e4e57adf7798d30033cb8d561f16a6a46b8904d3fc7a4242075f7d5a186ed01a5e1cc5e0ea7190c1d2fd50b866db54ff7ff6f2198b4783d8715be9146f663d80d4fe9272c974a7383c7f057fe3fc46a3c52cfb67f2ac85923736e66fb98fd108363a5baccdbd61d8405b1a0084acb5b7a29ee5e6085b3fff6fb66e677ffdfd4581953bb63af977c13a4e500b458e1f1dc520a584ac41350de7888c9a368d3d107265413542d1e3c429bd9494ce85de2805f922f28e0c1dec333e6428fdf499bed65360837f7f20a0082a8a14c659f9a4f25d9ae7a7a48aaed14d482f143b11dfddb2046f72346658403712b2f4a0f4c3eaafd207635eff67cd40a9c6071287f5ef803f6e8212c8e40fb166bff1ca23fd8f516f59a72e2f7151a8b3bf98d4f937563ed1fabe6c36a9ff022f803529b43a244eeda576af8a30d9566e5412593cc38a8cb0574d2e0fcf2e64fee17d0e9b05fd32f84d8b093771289216dc1ecaf98d1d0891ff0d7d8941a3f305a0b52d91620a2cd9d38498d0249e3d233dfd485c8c37746f4792f8b4468c5b8fe9cb8862658b9e1ed3756e55085aec6b3831eb604852fefebdc268f18d39973a0efd6e9b0e613d48b0d9029dc933556a603aafe6d03c78570d78769ff5fcf81b8509c94cebb0e85b73121a729cd01be4713c0d84c87ded92031a3865ffacac5f8fe69657df8ad49deb22dd720b3985d63158ca5c1bddc27367241e4e836d6ae7ed8a2831759e86a7eccfe70fe4867b88288685e35a32954666ed576769a1e89a893788faf3b171b0c5e3cdd4fab50ef2400674222d99e8de3e165d5ad91c4137116d07a130c1e328bd08d42ec69b5c7595814187dd01f2169c98fd7607526d99bd868ac591a1c732d5ae45658842ce4ab2b426788903bf5228e565c5ace4cf505466ef72fec68c7e117062fbede88a945f5cff0e5d3e6dea04b1b418b7645db3a1ee8522f07c45f2f0a626f75cd7beb51c6a214a27f67730d7da1904f630f1635e3d55490042c324c02f924955dc88248d126a39ca4177ce86a5533f088361990c234b62a9cfdc159b115b7487240f1d25fce0574abd606d92176e578ff5a6f276ebb828c6f454d19fb2db2446a787913dea6fd786b593e769c685a695722497543a1559caa2505758da79563af6884f2ea882bf5bcf9a58b879f0785efd5545f9214846ff88048c422b271774b1939b4301a7e6b4348e76691188602d6684f15f78e4b4bc786621c3ad4f90b105eac10afe87f0160644c5b92eec901127978405efb642497ee335e396716c148b2ea471fdcde81396db38129469fa7fc8e5722416314c965ae5021c7022b2bf3c864274c32a012cdd170bc1a5f1bcd04eff688beffb1372a7fd1ece3068bec89ad21718f10cdb82f2556fe00cac49871cdb0454c8cfdbb2eb81782bd917a795390c6090aa130a8222d7596e7dca4d5c9d3594b8e6671b39e3fff2ab2d5a0b0a249f978f5756db24db8b826c1df93615a26ee8cd919ac7ff491e436667faad66a6a4bf8e3dcf354095d47108b0b84c1a16e8f6655cf449320ce2fd318f9f5f99967f2f4081df4246f9680ab39987ed20a1f4adf3415103057418c0e1cf7cc094fce4b50ba0f5974b83e2c5d5d088f7aa237a99b07f935d148a7870551cdfcd658caac769ab608cbe960dd22605d3f546c61ea69483ac964f8a8700f60b4f0c4eace41aa4aa15fe2e0183338e784d3d80f0fadc2e9e2fb5914c92aa4a2cff15d958af1f18bd6dee56089625662473d9644d6a32527a0454d4fb61f586e2af0e3d3ec0ab5efd61604cb05862bd5bfeb2147e1d6d4136e3cb187f0575a4950ac44d0c7f5bacd1dc768b9d672b734184ed7575aefb2b26d76ed11483d42ef0fe6d272249a73b537c366d20fc2fa306aa5f7cf970cd657ffea6721fb063c091268e0cb10fe0e936abbec415ffaf2d35def2d72ab47c93255a426c97b9ffbb4dfc92fba308914fdba1c2bf5f12eaf41dadccf57638215233822d34e9e8d06fa98f92fab260ee8cba7161a2cffc22a2ff4744cd788d35f4fbb24e17110c2ef8f39f97ebc8478005f28454b82b2d7bd56582b2d84840cd62fea54238d102bfd524b1f0dd77efaa59ed0a2a0ab6e9a1ace9359700f13eae25782064a5f09f6d882239a175db4c5b8a11fc914a8ecb809862999bbce4801e0199e1ccdb1c9d00ba78f643d24e22fe19fbaf71b032f7fa815b3d49ca1e94802a30721a7c239bea7f9871b35c08fbcedb93c8a890bc2e722b08d0b047b6d426f03d97f77c1d4b323b997f947cd02f1181ed7cef5b7b9e6a07d240d0001f6581b4b5a5e2b441095f936a8abc07c594143c52098e10fadadb1ab1ad6ce5cc205361f9868a5448046f9d9572236504add0b7e943c929970263e040331589b948ad2c049990e2d9d9c3db09b4f366036d3a2fb11a573617f4305f1fbbb2693a221bc8215ddba7659e402262fb3504edb1aa872ddcc7328e65f3504d010cd9699441ad99dbf71cf7cea7e9c148e3540ae3f9ff0761976e1dcb5c989b17ac91b9b1f4d80c02899f62752a9327504e68d645518018dd5550edc0ca0a4670870b1da0f6d43ab3f966e17e537e521b62d8b5a88966c5a7562d2626a8e4ba20a914ce8620a2fc8fae82a44a4bc60d9fa0c508269118ffa148c4e8b466e28f69f8ac9fab04fceaaa556ff806505d9385aeb569a725457c101f0a76c55692188b02e8493479c6ac7e278e56918a5d8f34081e5b233ac33bc2d4d3769d1227d2f152d83830d803101bce90e1a72eee21e359cc9bbcf5c2662904a6be122d41b56fd5909447ff48e18480776bafa55f6e4519a4235a9b31f1cf8bda1c7f500b046caf804ed0ba60905e7a6df229779cc15aa6cb5b3cd48a325710f00198464fb62c73d9b2ba90e65a3d4e282ae3c5d734ab0063026a2d699b8e6073a33a01d94e400a25d7dd1784c8aef5ee5655f781359138d7b8142559918f6f1652129eb19a39a8e5febc9eac79e164346f50f6712ad3c8deb053f8e4a3e91918121391c6ab3dd8b3340a550e6177c085c910eb55ea0380a7a02872a608f25db27bb61c079d26938644c0766b6fe1cdd8749ff7101a8bc88a01d5ea4e59a088c42cbed18a17540981b81e6324994aea0a420a950203660a01d7d64fd9a5473252a32be1e9aa231096ea9caa613b83cd9360acfee6f5e481ddd63b89be2641765f56ddc51044c92c488141bdfccd50396af6b2ed999dd28f5f9abb63d33da29e967bb852b6f7cde16ededdefd6808d6e6a075c9603e0cd7644ae7b9defd08dd49637d9b9f9e7087d5cc44a5fe875ec7f3477dea516cdbdc0c0a63919652670ad8da337aec11a690af1dd9b58f7aacd89f285507cac215a3b35f167790a32c72f7d89575ca486ebdc5b838d9fa51e90248ad535b1464fac9bd2b29c9e5b1d406e0afdb2b348eb3025f743a0de9387d9c8806325502ad317295650c34b7b0966258538fc86a51b57663131f695551709db22bf5315f04acdf3caca2c15b54b02d5f8625aed52d27bb0ed5412fdea2c0e8c1d50e7a1c775cfa1082976d7603a1ec26ef6a9ca30441a7cccf91d68284622f5d85ed903f1c1c2f7e0e9bffecad901ea55035cadc894f9c1763475ca78ad1cbb2847c2d8b6dfef1177e795e84dbeaf748333df49c0095eb719577226a19d3994e3b27ce761e74613d1c0d283d1287ff419d3018b2f925c9c42f33c381bd2b7b3f4b712f58d0c9bed4f062755bbf983229c8f4fcb6740a9c8a8a4e65cc005f42315715325b902c76cd77a2f09c5f55d64f9c7d5a26f5e2530ed0b7912e1dbba5e43d1b2100686e23389102f90c33547d1700384a375d74b806005c86cb87ef0c5c8945b63d8378930df66a5217c5f64349198d9cb42693361dc8030e16104c678bd875b8ee7c6ba19f71f6b84b95e25e00363af33491ed1bb346ee80c35ec15bef676a00438df3b3ade8eace7052fc128c9f3ae303d9dcc9f3f1c22bce887514c48e9e6a71edaca441506ad232c5fbaa784c0be68dfc6c75261849b31a9c6e9159dc837496265f2d58575cacdee6fd44a437d105386de2283ea5199fde103a8bf4ad5dcc3cc953a0ba2c4ad713214c8c05848d9ab2d62535fdc06e1996c2e8ac9ea8c452828573b66dab9e9a341ffa24edf648db9cb70baaccf437684acdf00d4a6a4dc94af2dd4c260075a81e5b001e63e55fd6250f39a99bffd71cc5346c12ef56d99f97c065bcaf0a6e3e0a522510f04e400608d2418017103d0c2d3a8334d1d57ae4eb9e557d5cd9f7cfb3f306a15e2df436b153654f9dd10ab74be133c90ec8e3edb6e3547e4649acfce1531e540068d51d7f1468b55c978e2ff2569df23007a7de058e03e283ee060300122fcf429957e491099e6857d6a6dbfcfddcc49346c4857b96279702ee29fac5d243f0a0b6397b35d85639d47f9e1476980a8c5455d06b23a833ff10239981acc980b21a4e9050660a28c3bd2939a634257a2501056fd5c179071687d33301c2d302d5ce898b846b3a7242ef1951aca8fa5040b8dc9908a45b41ea8f27a5371fd5579c50f1c2a5ebb5e43079f18e5c866ca155a3bd59fe7129554171b5fd830ebefd724f6331e62fb4df06bd7d544b3bc5feaf92d2fdcb44d92e4a5241285c1740ef397f332c0437fc5e36071076470bf4c80d2f7319f442ca34c940f8e838504e728d2eadf95611d132d88dc4d9f58251283bed69af608b2c33ef55c84c65b1fccbf9199383b14db976481f3966e3fb30557c5b13e2a10f141c7ae34fdc5ebaf0e7346cf1d43ecc8ad384c8d358d0c4fe42c68e17db6bc1333e0deb4ae2ba9611b30a725e7885969a6dc8c2004d988ea5f461a2e505cb6b8e6bf16f4cc728f89512aa942f5da28bd641d9517cb1f476b4b049f09e3dd755842b2f31b1c4cd9b52ec5ff0bfb01fc4103cfe2afab22cff16b71e630863bb2cc207280a44f4b8e7702d2367ae2bd2a00d193501588024ab735462df3ae9fa58f1ecf3f41f5362db7bf31e901ee436609049b07d96166a087b570c435c2def9d69b504ecdd8e60d0635d44f57b0fa811ae987dd8bf2bb47d9ff737210629d587c2bd299bcbcf5776c0f0a699fe973e8ab43a82951ada89869f3bf1c17a2bba9782ecea5c3208bf613f0a560cffa5e5eeadf9f17d65975e07be1c6a1851265662293dbaef0ec3b5a798e7e6c8245162f58218ca54c1543f488665a7bbfba3cd338dce3ba48a96aca9e164721fff0ff23450a0866f1010e9b21f624260cb8f5ce3b8bab1ede929a8fcd83c42c6522e8328b781fc117da2f8ffdb18e33e8e7d33dacea14c24bfab28eb8506238f9ff8ff19abd63b366d3b9eef20f98b8649c9e2db3b230c68704bc368d6f931d56887faae79b1b7365e20c0b483b1f4b38394b3213212e0ed1c3667b91debf335fcc137ddcf90dfc29cca5770f54e33be757910b62a1dfa4694a45493e816292e0c88e6ad840874d8a94062675a60833819683fd16a7474767b103a83b5f6c26123f987ec232674ae4079275fc5f610fa116e19e5b63a4efa4a59031c12f45830472e0514ae0addc62fd6c313b13b2019941b085853d7b10885fbea61fab899fc67cd6c335f04e4cb00ea2d653c25353ecf545992761df5f1b4fa95c2d13e7dc20af15643e637454769d8a2747639334bd700c9e4c9a16176c775397c20fc21144e3a652ac6e253f8df687080a8ba746b861b65817d3eb37f4dcd2c11a8cc80abe18176a5dcdf43dd20bbd8e19f591ade07d98df266b4d97019b40f72ec9c0a503ae1471409094dcb4f0161f238db08c9f1f556bda88128b83dfcc18dd7ca5238739e33fcaa2f035cbb0f3d03500d7c4b7f21508abffe053270b44fbb492ccfbc591b291a78d2f9868e0490509d4ab2ff6f2cfac3790c1cf9c20028904fbd3726c834310222b55c99afe016ea8d5d5ac77a1f3ba62b5e7dbb5799d8a7f4808dd7bc3175fafb2b26d32f7b9f76663168e927ea1c1e45e359d656f8dc1fb5be963783dbee2738a6441bcfb2e192e7af47304158201d745ee293937d60c70f95d5b4d869ccda57a508d741a7a5c7ae64779441b12528e95838c18baaf77a6226bd54d5951319f5d24841abe8b8fdadf7d8d954e562e41e4233ab0ccddb492745ee3d21d9c4e70c4472939f2a17972ff2c430f817afa54d18581514872a6bb183c68f9c3cda04c8b29a6d66530aab996e3a81c5e9d450660b5e51ec3dc2418848d3cabf7a76f1baa43de7db292c2b79d9c4dd64fa43d816d2066ebdbcceb8147092643db6a7ab117601ddee6295c3520d37818925c7d82ba812d6177b130a6ab1edc508153435b49f2b3cfb172129e037c5ad52208704ce92e5cdae61989851e7222cd35ecc1137cedc61c9742d784a7a618ff5eea2262b5450a61bd1825ff5f2d0fb0e1cc59707dbc8c273bac17cc010c2c88a52effc67aac5b6c9e0dd5f5b6ae6a68767e154b1a72200092c839ef34320df9a89aecb3f2eea5c82244acfccd2b8ed581ce755c03f61c2c73ad5f1ac3161161dfddc96a616b1153fd4aeb14a1cc5510408d467994d031d37d3de5c8f921e7746a5d972480e9a82694d0485c19b8e716f8f8118eb29613ac2cf84db0c0a8964a16610fc2c69b520061ae77b0cf31c627d0bb71713c45e35a56235a64194606a6431be64b633b84a6c7bdb49ed6813a36ef1f9b79e271f33d410ca9afab20446311f3d566d2be1f607c9708b4fe984faa39e701ce684902d914adc9cfce81318bb8b986eaceb5c62d44f13d1475c8caac6e0e145bee21f23db40002609a8cabf9c755e4136c9f0be1302cd2f92ce3dcece5bcd186c94caeed103e73c64225d3650db3dba868d86c8c85f19d1580c4c7d644f1984a72c40e917e09ccde8a492c6cf8402e37a4dadae7a763e289bd4764665b860ff10afe6102b2648e12bbd3d3f51fe0479235a64085419bbc38813d0bbd8d9786eb0a5c542658946037394ca71d06ad8da92577184ca568ff35ffcb1cc52b4f10cacffc34ff73c4adf46347f573271b3a2450530e90230368529a5f5e3bea4935608b0012a1c482ff74d87f5842f7ec2ab9425b8e6f21407fc8fa923a8f869d7fcbbae2fbcee490202a482224fd2296f210399a1d0fcb782d3c4b79b2121bc94f2764ef9d5fd14fa1c385b4ba61056fd1f92881362494a64719975b587d83ffa0a64885752f11fbf253e6a6b33b57ec9d236c92cae8d9cd29fbb976990327e2a1c9d5201941f6c01966ee2ab6bfb338cf3092bd8ad4c4f2db4659891d36b2061db545eb9fc2293ca33b4e5f12f341f4750b379f6e78586241adcec26e56e99bd2a8ad41d8447d1371b452dd115a913da2db8564d39024fc402f05fb75878560c88fe59577092a12c849165865a52a9d8704d11b83284f0ae53f38d0741fb1d4f2d5e8119dedc7b1ccd0082df2fea3369077c600c701dcb87753628bc13189e6b82cc2b2022de4ec3ce9119022939c52b3850775cb75acc21117d74a8820f4cb30c910d5ac9a3e00dd6e1f7bc1472bd6698c83616c7ae8a555d4e6212cde88cc39d642acc645eb9deff5247128799589db63ebb31b54333634ad3b5d8cdf13207cda4f6652030fb46b0e626c0d035a7d8b7e00e492533bd007f3f2ebc7ede03de93d43eb963a9acb812ca21959fb6d90095a3076941824ca50a65cbd38eb2160972a45af782a665b2abb3671eed4e262d8bc853d7b65001d5471dc9535d0000e03ffd3e3ae02562e6f87616ed587d8ce9a391567dd553cae8e85209b9cbffa0eceebf97d6ae423591c133ae21f6bcb74a31c0083361f1545c9769c5c10295eba0c0b6e0239f893d902bb8681e1f0b1b7210fa80cf7ad8becce205534663f857490564f2b2f868ac4a7d0619c150cf67385132e5870e91205b0bfc05c22156907f3460164316fec91f0886db44d1e4fe6a5250d2a4e11ba7275ca9eb931879ec9a07fad53ee976b590581f97ee5f69cd4a6c9d7bb53b30598f2f62bebcb32ed39cd5225400258da0f23a773cb511a3eb5175ca8de2539447ac398ec526e5c166f011fc9697dbc31bfc139d36f8165a4dbba1d723f8af8956ee8656fc9431fc500a6ffbfbe601251bf45de08c3872e17ab58e7f5db8bd133f288516220aa1fe8991bf514ab0331fb834c1a512c67c5a3d0e8c5df0e5741c73afa9cb77611452888dc4a679f023aac032fc6ff33096e2eacc37419e74bdc169a2d099456f7639cd2ceba71403aefbd724f775c4260ed1a3518d66da826731058d2ddfce2fc934c9b8a94d861b4735031870bd950edc5c94358c88c6b8afde71ee605aac162ed42ed50027242772059bb016801344e4520ac5c9fac8f72611210048c4264ed020a39288e46c5c657b6bb237cda0f1bc9d210fc36e0d6a9c92685f3f3170e67b5a49577f086b1f387c53d5bc1bfcc16b1e9b2a9d876b28c4789f9913a7082fd1fe009e81d95d08ef5ed44206e70e15a1406086784cc5ed0fcbd837dabddc6e20f9c70e79072ea0011a89f567ee518b991c3b8929621d901c03a901664768e32725653352d6a5e88dd7436d55c7a76ae5d649c4550670f71d0b1da5976afd843980b6cd18a1eb0068ba6cb2626951568235c394d98290ad696703ad10eedc5b80aaf53502ff9410dd0e25c7f6aefbc3a279467f289b2534434670ee27b646529f74e11a42e0d1cafd4f8ed45878b9321c1bb7482701051b32846c96669f5369bb39d46231581c90673f3507328fc0041228eade1fc39f5ab3c650561f1f5d31d9890d0545908c57f77395ed49715af813289c5b465ca43c0c2a6bfd440dd96d7d7c67619e57370e1e79a0afe48c4a83d912eb9e44a702347859114be584b5428f9b4a6fa1d5369c61319f3d1ae850e053b994e643e2eaf7f5bc63f4c662a8baf471eb588afd954dce1a090317b5c4fb218a6bbc2b0af0f592e7f0bb25833b3450def0febb4f0d78d43231cb5786d42d2260499a6a423a1a8d3fed6c1a325e461bb20c895117d910cf2c87e5a4b89d079b1cd34ed8d894791cc86ba494cbb37a4c684701d83588c2da6b73554a4f41a82a72929710295c317500122484a7d55cea592a108a510847bf2e07b5eb826c5f94d1d386a02310d904ad9d28b8069423ba07464215f7e5939cfdec9f81d8cbb931c61ff498d1693ef25a12d5a29bd3828a3aa04fce52b980b4af78f005c5ebcc29bc0ec3a52002df824d0af2881000793400863eba0637916356ed5f4a14312f2d684c807cf715fcc1599988e610986e1243c75b48f011f2ebe8f14677567c4fd432fa25f4b773438c8ab17ac8269a48dcb4ec5a71d4f9bef33e84672bfc397f12d495f1a3d7cef5758b813abeb4118545c0f896b729dca158b86eba0de3d12b8a654ee349eef3874fc290dfe1d711de413fc2e0e6d77aa46c7467e92d8ab0df17d37315c61234e57bfbf5efe23abc46081414c0a590087d0f9109bf7c126234c7fc446251f336f5c142207ceeb90619e21d5c54dd7e9ce1fe058610e869c18c733350281da5bc1a05643f97a435ae44e7ef4ba5732ab2a16de40ddb53fb7415ccf6bcb77ab66d26cc6b9b66928adc7bbf1c979cf15d2c7b3905b4b069ab50b60b121d74456a35e740724f184ad1a695983cc9bc0ab8f0af474bb068b185c937b44b25f7a46a862f6f25b058852f396eb9de0abc047a980aacc7e63fc57106e9079202e465dfac19ec9245c668d070ed43ccd13dc176643911938fa3c8d8e17f270e2e78a331072777f537dde2d83254705f720ba6f3e3dd6c194e0d56f70b41428a94f4fbfaf537409491483c621724ecadbe71a08ecab9a3560c9e32aa9d24831102326ec3f53c70b11107f3a9d60edc42d2f1a23ad982a8e2d337c41507c272687cc96f01fb67bb1eb2dd281466f67807bc347af570fabd1745b0b448545e71a4eb833add397e231e55a843d8a71e5f8c118387ecea85296580e1b537f4515085bcb35006384dd28329af432425e70eac6bf2906aa29f1a9a510aee42cff0110234dc191e413f0f77e81e83d72f119c9f5972270d0567a969ddb8bac1e6e0ebebfcb2da1d47741b458f773de2da31dc91f1020e8fe4ff34db2f560499eb722a6a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
