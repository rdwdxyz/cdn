<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76dee41608771646817b9851512c07c4fa39fadf363b88e111614d965ce639f9a96f4557687fdb17ce92a24cf229aef7dcc4fb7cadee5e79ebeab1cc4f0f6b21c3bafbebf67780c34f61d0d811d903bd1e7e060ae25fc46a1a3d55113025a0f348ff71559c804df2ad133f56ad109be95162ece9dbf4f42462c5ba371173d7374a5491bee4a24fe9fc4676dd07003de9ec8bd125ccfb8740769999fa6ddae6d298b1c30d376c885b9670e16daf4e8188a3de5085c1bcda8f84474d3d5449ddbece8d3cc81d41a8bf8b0c9e97555eb7481b88d7ba5e2b037d8564b898ae40e8c5332c2fea7f0836de474e2e60bce48f5ae3b1620b6122137af4dcb01ea67826e045e63f56ae5e57c9bfe76d5eb1faec57e8947950eded69dd77e739c1e59e6a4b9e17024add7e455214fa9f72370ebf339da5e4ea0d101f90a28c496ee8c1435a0f3b4c31d0f5ef451b01ac5eb1c66fbf6060e2fb1a6a5c4de07bab4e3d918bb6283a1c1e4bd2abd2b87188fcffd5eaf3a809b9483d6835970b90fb0bb3bf9487c775e441e22a826da7854c857e37993af343d9bcb4421584b2a509d928142723de011f3f722f316be2f0c62f93b32839bf9732a0076a5b5eb8e3ea25831a51844d48514748a9c56ca329c8f52b007bb95e7d0fb3420d5aac44e9dd1c25c96d0915b1334929e8211b92853364bc1a45620e13dee9265886bee74cdac445f72ad881f03b26b1178215ffafeae86affbc2e8013205f083291a6470f8fd190a5467664eb14bd24dcaa8e90ade55aa779835416491bd05f8e09abae1f93e06be964153134ace177a2fc51a72b889745a808914d57a7965c172fc171eca289731097457a0ae1fb2011e68cac0caacce12906a417ba0e4e69a5aa617845d2f04deb9dccc470953f5d65531d21c676330f07b5b20392db5be7e1f83b7f67655c5ede810a8e5e71a2ed8b0b26c916b75c0f32d44f3d42844e6a9491cecf318688b1c1b7ed09a6a4b3fd9e2538349e05ed24f889b00ecdc6301546229dcc9425f8327d372bafdecc2b318f9ef33866a11d1fb2b64e0eef7edf8a81a771ebc570554137c818dca36aab6d8aad165792e92c9ef0eb6ab81207a4f7ffab2609e490038081751727cb4c887bd0dd02c7157f962a8d149036e0bc1a02b0e60d35999d025803f5b9ed4dd0d6772f747c65236d01f93ab6086c8d5c818fdf050e292db80b47f8e51771bfffae4400f3d18e642e16762cc50ca889936035865cec3cff742a86cbe5baef3b2770b942a21cf5bf827ddbbb4bf5cd66c0e83c7e107ce9c4244e3047d9676dcd9af0940a29f6685a9acd27e46f1b8c0b2404b6f12a964eb3b9ae0f190248617b0854f6c5f68c91814899eebcc7e143e0c1858ae142c62998c679034daaef78840bcc012c8908d9d1c469081fdca057a25f4829787527ecc9f07003d2a059ece1fc15e691350d5cbe2fea9497c1bf2c9e8b42f0bd6607bc57e619cf7b70512e5bcc26b94e7222f0aebfeecea515e7b74c4381a56386e784987b7d313637e91ac6caf870b16adfdaf482e1862c97c18932b904802f90867920265f668cf1253b3ded62aa0573010e585c8055efac7fbd057c2349505558447f2354c7b1cac74d14d551c875b2828850786666768cfda488417d16f92440a019e53377851e94179f6becc60bd8afb0f36833c222cb2df12c39b9623c8aafdda3532ccb9b12a4d5288f0910a306ffc8c3b70a4bb2f4fb7d1448c3714c7e846a3833735f8211a6ee7f5132baa27fa58f69bbbad87a9034e48ad6b8b47917b50c7f35cb1d56778eeffcd99e10b5d8ad2540489f84bdddb9843646e7ebb15c12841c1a277229572734431e438227273e09224aac58c331fe8e2672e9698015a492e8542daa02104139bc1ee69dcd67b8627feb82f203c5b41bbca6e8c392df2a22e6ccf3029659de5485a90a471f88ce49f0f3a4ef5c8b4615057f15df8d5c8b2c0805464e634f340e745a0d1398582a2b61bb5a214882d77a84501cec0ef72633339ffe5d9e38fb888d36c60726b163f55741567669f871605c4b1e00ff9cfa3d0c1290e07ab5ded07c92a06559f24290b70d25f73b9513b7ae98473377fb1f18d5006b655fd5b0d892a532e938b7cbb2ab3de09730a8f39d92ea34be3535b0dd0156a3abd2fda6acd8f7278c3534c8b63ea70fa699bd8cedebcf05087796c28cf1b2992ea47cb27684799ef547ed07f7dde893d00f26e8a0ecacf45da1c9ec53e9301c09cdbaf740c0c661ea296aa9cafdd456d767c772a75aa49973e867567c5da9a3e0ae4a121b0a3762230ecbbc6a3197e7afb05e9534072cfbc66ce6b56711a980ba6195e62699f25f0e73b2de43ccfd8a2a6c970a622c5ea12b582c22990c6c9a43897662f57a90ff188137f235ba9d918c7cfef565daef2208ede340adce2128633a01709840cc145dfceef00d90ecf146cb59b7734b35c742715ae2ca120345e621aec5509bc69e203630d87e2e7991b77c8b32109a728d260c2fab071150da5cc545c078fb4b993a0dfba04eec08b15ef6f2279220c5fcdacc378db905d721186054c8f48f9740a572b5f02d6c031075fbc63ba82c6d3aa8cf44a7cabdbf427c5306fa6c3364b35b811d028bba58e076677511aff412a006c2821b583c0ec83519ffa852ca466f6258eddef70c035c8f71bf59b68c1f3b27fbf6f0a4c501fb436b276f0d365ff166dcf2b16eb03fea2c3894d14ae50fb11ec50344ecc66a22c754feb4a175d0f31f62fe02a34bd1364c5ee96945652f8d9006906004ef582502b38862bf3b467e6d363b9098bb11ccc55ae11e3ac9b4c71883c8b1ecd67ae8988bc48efb4282d5f9ba9722cd10d9e211623f58ad2aff9f6c0721485a7de65e5c55e504fc9527252d73e37422a40b5c3a0a1ff1ff9a080170c2cf5750c1e34134b2d00ffe5d02c8452931681649b077ac2400b6bb20fa40669c99b6b4f99ade701b12f8329499c83e32116e0ec6342b240f542cf4e39dd66f59521e465866fac3c9fec477777aaae563d20e2b9b0af8825c1bcc24398a793ca3cb1e9c9e182f285d2a11959a5c7f783af1a129e4f0cb3160ba4555b405cad6d65ddd9c046deb2b39d00f2d2f68cbeb20d5f2923a910fce56c7ae509f1c0050c66176e820c59835d81e6898dc67d48af6f052dabb2690a58e5e17b6be8ec5a74a8c14c88c28f2ceadbff54452823ba66f823fba555e72a5798feee72615c0585a2551e3b2b878734f6b48074dcb291cc8ad212adb7f645a931e940b17c335c0ff18c7e357470e5ef6fa43826cafd325f6c43768ae3c9fd532244ad9b8b825052b756f5744098d0d7ce5eb2f96d5b6dd3ff5c1b20b027023bdbb0c8376bebff8bb3980bd93222ebcea1c1128500d516d8059dccebb7b99dcac8e28459fe7992626886e7446bede12fc3e0f765855927830ca4e00f17517d4cb33581328bae13876b99f8cae276c001e16cf9c202b0b8d3c201a8c50e12a9f11d5ac2c11569f8878fbd237b5f3d59160dfb46bd817f7f3c40ed6800e25d70ae1654054e8142821ab1e67def1a2add31447f5744027b0ca33296a23a20600fcb8c25d446b870b1c300ded87261c042ca66bfccf6d1907fdeac3d72ce3ee497d7a7875f312f35183e77bd0548db1c5f7709240b5cedf4e64dbed410f85eef5d838e51ff3a8aecff38b8c925a4e4be020b2ba298e94b89b7a6f61f7998a934765ea3e3b8667a2a547a9bfb77f910018fcb2fe7385d9ee3c6a3c1e8527d395bb8194348b6bf97b4fdabfed7c9c1fd30307ecb54ae22d908f1810136f99629ab67fceda80f85363855f924d9174c390bfe9dcf98fad3540f7ff4b990ff763005dbd80f0df702b818eb3c77d16a8e5cc14d2e6480cc6d71248e985f190272afbf1084e26c3b41b8cd293b1c9727d53d0730ccb33d527eb58773a37998373246c9d0e2b90eb889133a5e88e79bce7192b13657e87789f2ff4657f2c4b52782710263f15556c73238a8726fd3e14677adadc2b0c5054422ae994e7f2179fa59c898d7e6104743345ee36dc6507061da526b596adb9281bff223a65f9ee6b2cbf8c02853ce3baa0788bb1d5afb34d707309f1eb423569cff74a73783d5237b7f370cfe6df7c87dd6075268e7fa0e3b010a65d4236d2751706eed8069e085127529d436ef778956872bfca7035accfda0cab6fa31ef249f5dc85b6cbd3619a6d0398fe2482c5afbf7c9553207f49ebb4e6b22ede2e872d2f0bb2cffbf0ab17e5f56b86c5859b6aa59d87f7d69ad05e0905ed6ba5586272dd1219ae228071375df82a5198daaa3d85012d3fff6672c913c8993b21bfa117398a336634a65eb789c2144211d22f8e7c15a134d729f2e083c9aa869501d640ba6fc1fc6a71055c585c02999dca9bb8a32d2d1f6d7682598590b2ab2f7f9246fe50632a329a2d90eda851164a33601f35af7520eb129e4256f9862463c93a4dc0d1b81890d84f30d694e19eb1502997bcd37cdc46c4fbf7a611ccee3d5b41e78338a240a9eb7643b3fd1bc4795d7840644e5df3e4267020b285383e3e66a1d5e2afceb5fa745df5cd5a59d7c685ef01527dfccfe4ac544869516ed40de3c04889f7d8c7487d96991a55126bc116a492a9e6810d03b491ac100a3edd9f48e2e7ce0ef80ac04bb811c11c50dc5df1a100b5627d5b221a0e9088257eb99d1c9e79aca79a4377ec09295badbc84cd8afdec55955d6637eb1e39e334e2ebe069aafb6edecc7821d440073dfd08dfe2cb482c24e4e06a139f097d7119cfed6226828a972ac1852d0200cd215054b8d638cac750ef0c50269e3ff69aff7c390fd1c731a3edc889d38d041eb1a21343ef5a320acd0390b361700cfc2c8794cf479b72187ef5587d040638e9f3990b6839e766c750bba4de756b3f2a77b2f4ca0c6d2d96789081fc163e666501fae1d53fcf2bef3cd279491f59ca79609e9152fc43ccbf75b7673e8fb1d93132cce2e4a2f238d507336e976dabda149ae8d116ee98a9174ef2d0cc3d52280469f14c3ea4df83fe3ed1b64c7cffc9a41c5f715a25f817d47b511a3daeb3364c48d4e70d417fb213232944d5faf75011d565bfa2436f9f24ba392ca25364dc4b12b2b7ef88b34fc29cc8041c91bc6a155de32d9b4719c3126b76978a8b6c4be5e2fd565beedcc8a1bcd020ede0eedf6b5a471de0f1f939654105f1879009b2c5faf18b6104414169344cfaf7cd0f956cee7db68f4df51b2c4608f0ce0219b0a8f9feb7774289e47daa3b104498e22a0258c6389a624f899b0348a93d4b5e01e3802c30b1c8d221440496c71ec8b40743795ee1499cec9fe25f945fedcb8711ef57c2793be27edf16f1af0349a86a08a22ad5947a458917f1cc79bb1af625966440ba908ef905ec6a3c95c502dabf85d4f32ec9e35b41c18f8088c5d9e45e0476a9e3d00381bcb8b46650d5f4a3de23c46baa2f60278d1b2a79b8321671028a69f974b215945beea87af9bb7c233bc4d5c319badc0a06f42c0a40e9b23af4ee16472d9b7a6e5c77c5645055b740654a74c3bc18e9e3c76285a8fd97263382a928dde4849c712a9f31a558f454046f888955b74b2966a9067109addf9475054cd37d9741949796a46166f7e47a828f1ec2a50b53d2b52852b3648ff861cfdc7f0416d1ecd3de0cabf68c7b3530028346defa3a1db6a5e77de625f16b20e4053f4d012d0deb96946548aaf2393cd1a7a0ee6d9c873a5c5c48bfca077ca45f7b1530108c024a6a81c963aa6e1b8f3bc6928bb12e0acd6adc09eeb8f3c049dac051bc0b7b5eb15c7649513d0e60523bd59bd1a90d33456ce6494a5e3f019de96d924ba072b94ff3c49f9de6f5b6b171287d6b94cc6abdf5a11dbdd0a86fb1b1e623f8264f354375aa0ab5affc14eb8312cf8a17636f56e23c12712b88543ce206e9fd5f5cb12b4aa6c1c965649e1bb312c9a433c3158d544853591f34e594790df0fd2a63a5b8278787016c4098d86a6bbe4ef314e5e7142a5b181c153bfe1e282618a9763521a17e7c28ec4b2bec6d0c52a5d7ce22b69fd6bf1657a8bb6665887288f9aa51b3b9b61392a186dd3320b0d4809cf98ca010c8a02c4da6b21b6cee7c363cde9146056cc946ac45bfdf19353c20dabdada9b9211b8f0eb89382887c3805b1d8e3ecb04cce4b1fff3368873127c1405ba4e691481728dce6a818ac8adab8913f0386c529c1bcbb943af59a58512ae60aee467406dafc37f032b0e9cc7f2921325d4221dde3e72cc1c12d88445ba0a0bb09f689db5da99004762dfe927cb040ecd6941d53f6ed51891fd661f3d027822426447f10764fd41dd69a20062093d471d90b985db004131b35e0739b3e4a3ed2bd58abe2387280403d691b53248b1e0e9e3de117b469e56980f6d85a6914a9c7d6de5386df6ced330d1c1312804675466e6c1e67463cbb09bdb1091ef5170d887e94d5c1419ec29619c86a07bed1912f199a19ebcd63b292ed2b136ccc1c3bf150fceb303700d1b861e9a2610b1bd517b95b114a0a7529fdbd242ab16d8e387a513a54c56391c15f26f57f52b56bcede89517c6c90a079c2be5cbeeb161a956f81861258ae65010b91662172b6f725b6e3799d809f845336b009b6f83ad20f90661828b1447637f28d87c19f1d2f4831c233d5b460d6d6ca07cc466eaf7de1d50711a42856410919da4828d8ae29f7c56a03dfbad88ea811f0c94bd92a404ec95b08eae0e7c1bbbdecafa275e8e1f177468b6d3734af017f69095d1b67b6db5df2ba2b04499084711fe8674017140d6ba0c2b32e96e02cb6886dee20a6b50fdd3920220d8088e932270ea013515bfcd647ab0e3b244787b68eb4490854411ee923c0fb7dca1bc130120ed7d629368a95aed43179a2fdf3649916c412aa00bfe60c0c2ff8bc4ffc7171819560927de76fbba2e814f7cb735f993a0b6b4e10d48ee2521f15ef426b6b1fa9c276058fdf02d3074297ee63035a4e72630ad85785c1cfe8c6b7f13cf195955f7847391fa6c801c633d88fb932db745453d73b1f04f6d0380a252abd1a7e4f32e5f675d668ace7d0eb8ce5ff484e975c9c5841757abf7e74dd5b85daa72e8bf1b46445cfe1f31d396097382bbdfbbde4c5567386fc8663be469641856e5d72e910a0d90dd28f54091c8f3b26801608b37dc3887a62c46ec736e96f02637970bc9315c1309779df264c4e1ff7345f4e4edb555cd3e1962a8950ca0d0966695d20a6d2b901214f7bdb9cd809b79291d0606c96940996335a2a8d093e557550b27bd6401420d9bbb73648b8f27f5c65a920623234023d4bb71f764c61445265c5ab2e7c85af78ceb42af324940abd670d5e8415a5236ef93e9e6297ba13353449c4bb85d9ded86f2e270ef21f35734bd7fad815bd950667d27d6ca58b5dfbcdf663f895caae70376ea6bb94964aa8719736e0467bbae70653df87e91ce1f9b4e2d7ea7c8adc46ae347615bc19c096a5b4cd4d0f74b0b55bb37c1e151f1a699960eae6775cda444d81abcf3291bac7b02fd23d5344c4c11bebeec1cb9027a24068f03229215bc25cecbb45a4744b939d321c562df4ebdc7e3d5d4d7c8c19d780d960a62a44c5703a832a0529f4b7b3e1af7b2618a420f64c825e03100b5a9ef24799d075ea9ea77efb18dcca4c476b3d3781377c3a3a4c0213ed13c0c63a133ec8b65749f0cdac8baa1be2e262382d6294d5a11cb7d9932a457109655b406fb8ea2dfd8e9adf4cfae44a4f173ef33020891a20273f79bc47bc7ff35276fe7a71a25923e454e6b5ee258de99d344b0c6f577f8b4a44c47d6df8646d9689b1474f9a1df6911ad8e53cb3f24b4e44b86c54ac75b7b18bb2ae403d61286939f406052a2ca240581caa1c98c0b758498a3ab30e8afd0287645e86cf8033718e1c535424687fe22e5446064134f680b3671f7a27ff4666e1869468e1c8e9f71a2b45e3cdb2b2081170889eb3e91a2cdb26f7cab4662943ec9ddaa58af89c2115b2f2ad2aaa78e3b6d0e2cacc2371a9c11954d545cfb3c1d9f9ec783fcabf96f53f19a6f33dd2a866c3660e101f5786b968d2b4e7284ad61d2127bf558af5e51c488b9cb2087f6c2fc8f91dfe2d1c7d8a11ba6ea27121b66967bac5687aeab2c35548b90b45bab1cb6bd409cb9b9e6f4b565c5cc8ec9093543568de686431504576eaa8b34f7a50c33adcad5e943302aab62f93fa369359e376f92c84af29a2846329e04a92bbe7c31782a1df5299113c7d61050d02424d896e8533775b44e1132d12efb1511d033b013f9282bbd0dafbc57dad6d1b558d954e95b10dca5594d054bb338211c75b89c41b7d64b83f47e2dfaa8e10bd6045c425bc52f18bbe8bdb1a7e4dd594f22223992d591cfc40788e1a0bfdbe241417b1dfdcecc9ce971b171b976813d1b3a223407c4231433125fa86687bea244f7b2083bdb9435424e4b2d6aecd9ece660796e82d34ae5ae27f695ff2850adb7733fb5c13177e12d393e05dff62806702a320c4daeda1151c1c4c1019580e769a530ad02e0d86a41709e0f36e36d48f75d1b56368ba57c64cbf0788e0619b78bc0ecfee5ba76089c0303eb1485c7072c375c499277cf05a31872461087a11902f4e895ff2cac696824fac0814b0a99dfbdeecb3aea25cd7119dc3acaf70b20587a442f7b8b7d68ddb431d63931d8bdeb4ce36679c503edce0a9e59e84511ee404731f08f21e2058ba646f92477e1c190c3bb66abe3d79ec02e305e9f12489de3256d70693d2c7bd3c56bbcfa6db2026ecfcf9e18d3e0c25a83cbe34941441e3fe93e2e9c50b7ffa0f70ad8450f27ea095426e551cf7dcb7250a20a0a0de82976a0502fec7c46011ed62280cd1c472a4a3f61bb512853a5e86d0c4e151b2ce69dd695ad25d5763b53b896d20c287eef7eb6505b903a98f44ca78e2b1194b273d3e3a9efcf1f79ce376dcae4b566c9e2ac16be931cfb3eb01b7a364faf586246e9de280f7ccc8a9dbb149580a370b409df2686d472ad6a1a11e7a846a78a869ad086321128eeea102a6d6ca20e9475e959fc923643ceb04fc1a226b1da30d26bdbd794aee8ebb18d95b10f63ce3a4b1f3e7dbd3643387b82d043bc2a121948e0d25fa4636163f9bad2e7ac45cbc3620a5c4eb76ff2fcdb3acf08efd8358a326fd9cd3b597f6a6d5a0e19b62116090d3cc9b1946bb9f674f425e741c75c9e40a1447accbd0c43d642f1509f543bf2e1984aabc320e3a128f50e93dcc80709385d86fa9730450c30958ba5dc8a608f5dd961cdb9410c952e3194004548fcfd80c651a4600f58b12ed29e1cd2a2182b0dbf117bd96e6973dec228bfe43fce610e9defdb67a83e826b1b283493972d5ef5f448b8885ca76437b976e63df9e4162a1189fa420877f3e2abb9b61daaa0ac0d101584e3a96ed35e7acb54ed65ac63c7c326b1bb9351fa5fc12f24df93ef036be26f936e4044c0219de4a7a9079630a52315966bed5c67ba56b205f9b03445512ad86fd356d702c86c6d3ed3502a6340dd69424945ad99fe4edf54d5e2fc663eccffd1b8f19c0f70bdcb45fac58f497b53371b9f37c0dcbc5e37e8f10f929f4c5ebfbf48d607cb1efbfa74de07e94bb8c16a10b7288abcd7875e633d78be53c5f9aad8cdead19bc09979a85d7b79534eb8dcb98212f0af45523c3225e4e0a9d9318f631d8838481c92713ccf75bd26ed74715f0492961347929a72d2323a01b16dcd5efd3085ee17cc2d3e4cf45f42a995129a785e8a756d6c59c9da6b294759283e1de160cabf91d5eb9fb4ca081d0e32549061293303ac88589826519d4a0f84801ee61a0714f0c19433bb3b2956608b5078c4b7604f4760e0a9bfb7fb0efca5d0410064fe05c726fde7e46d91662fa19953e1b3a79481ab7c0fd9cf1ebb748781abd882de88c054234e9f1e7ba53c4441219ce6c1e452b03f4457c5338040df3fb7bf029869394d9f5fe0cb74295ce7ce2401e985202573d94e6664607d28dfdf9763a865d9092b1f0556a8439c48fbb6a61d36309a40b4b2c0946399c4810fee8be99914cc20d2164815f4a0787d5dea7856d4cd72c89005b0dbf5b229fd5df04c4872eee4e6884e8bd088cbbc2f9044dfcc3fd5d48a874358aa795add5a00d7ee67e473d3ba407dca7da69d38c3e6356b724aa7543f3fc055acc0798bd681d40037cd47baebaf94249011aac1362bdba0a6807938f5dc3eae76b7e5edbc0a304348b2abf7fcf43b5718d3dfd1e1c9c41d626d243e4f56a47f9e7ecc0898c37e17c57a80dc3ebde35bc8db38589a87949d9023ef100769380f15b4f37925fdd6f5222bca56a9684f3c5483eec5535e9c9f0844e4471443e60efaf478e2be312ca4ba6b59daccaa9189a4950c0a4b7ed24828bb04dfc1c2ca92e19ef786beadae363b93e0aea76ca27cac794646245ed60002b7d3a76b4b70bb3a3c7268d94f903a41bdfb9ae02860c14a1767902c2183a56b888eebc70b6833c8392e515f3e0fb8460cf71f3fe81117956434c6c48dfd315cd24a6a0535fe11250861637bf667c73fce899d87532e539d8f36dfdfed88a20a18f3cfdbb067a14e36efe4e169d71dcb987892faa31c5f68f9d7d7c272916820d8a19ffeee4991ddf19f90cf131b243146e851d81a90f64c46a28233fea96ba51d07d715186716d174afe3a2ba22cbfa64ebc4e41516a61382bf92f4f0aaff3719d4faa0b1b387a3426191da79f48a0d2a9008f3897e6e575fb5fd0573cda4b6bff32fe2ce6c3c51e893b057c47f080918aedd7e1328127545317e20ccb64b77f70cf2e5939c30ac8555674f79f4086bb54d384cc7988e976cafbbcd9583067cec96ce935914c7105a01b5332d450423104efd3cb0fdabae9b2f9dcbf2dee53286c017f928696c99eb7028ca1851f323468cf3a64ccf103d01a1253f30029fda78f077d2ed7a415c647e5c81ce67d238baf850d0fff4f4b4730afa6d1a57b746b36556e4df943af07ab2dc54983c7d941f8430a1404f0b9a3ca0b29ea08ee515637f396098034d0734824712f279015aa7b93616a24000926e9a44e8bb16a39a9e9a4653c729a0ce1c215f02aaf0a7c7060287bda50c093e5a9441bc35a62b67d318c3fa5671a6fa1a2c8e457d4ae836ed4ac8d68702ef4f89e433aed027f3a9c2c590afb9bd6dc05ae1e299f7c4b6bb52a41f57607748e3e93ba29ade668b700a4a3b735fa5c815a1b694546038216801def73e02cb4dbc7c2a8aa908513ade5031716c4dde9200064264ec151f454fe74a2f14944ab01f214224cea24143d090fd013e38167e53c347c6bde870ddc6c0e096c4bd71879bdf234b798b80921d7c58aca85be7c4dad1ef0e28cf9ac445d13fa09835c55b74dc3ad73a428dbfd8b0398d8ab8e41142ff2015183c2d8f4db95777eee9a1803e207c22ffde2863fbd35473f2568610d443cc62e70754a6a556fa288257387a23b6f59f41a448d8410ff1f63c9d81a8c8af80a152a2d4b0559a285818f8f9064cad9c0ab3f1a53ca569f1566c6316251c40343fe8cec8e2ac54c4dff6a00a76da5ff2f5f3142a62ca0dace536f9d1e7c1a4b65ee7fd02e2c32b69d58e3728d095a8c569307a3e546d727a25bd8d1328dd2aad07556694d02210239fb95ad2ac69e9f9830a4406a01e855332d851978f43b2f2a665d612e323a1cfa1afcf71ac10787e5ccbeb1a840d798de6f084df296e337ce674ee1f1108c7acf18bf7c53cdb9b1ee17f1a19b7f37b28bfaca28f4ec37ffa7de94dc989899c7df2c60ff41c41beebfa144ebf6d993a9c3a6da87ab9b85f6b8e2683d0e8a42660673d76f637f60db3099e29f858e72eb438ffa07218c6a148fa5f2f6ebaf22cdb254164993e85be0d5f78d883e8c8f5861388ca9c30d59f851dff5d4f98078d520fe7e0b9baab70fa2e7a0a2150858a6c690a01a1197f44c26d2fa3a49b24912801d674fe553b279862afe450ea765ffda03dade683b2dd1b60eb60bea27c4151aa125f81a63587a8cd9d02ae9e9ad794b600e8c7b01e0e7b02e9161f3b021d9d335de3eb69ce42ee6e4e8d4a37aa525087ed6d3faa12a46c26be83e9f1f3f8c74ccc89380b8c0f895c791e1a2abddaf6e52a0360cf6110860115abcec54fef6fb7ced1828f1fb20375ff3f4e913b43f46109cddbbdb4e29c8b01a41697078fe4fde4d478c6cd2fb5f117328c340c789aad40a4d11328889a6ce889b402eaf8e8a46d6f08ea14f8e6517a40e2d897df47873e20326aee1fbba40ee27287c54258934adbe943dc17fea2851be83e800b8ef675ac08764297dfa7a6c5ef6371f2007188058797eeb9e7b7fc7abb17cd29bbb1dea8e4e9d9b3a0785f1bff7044f4e83ba6758a340e29a9e604f12bd89fe54545abd683c2a61e98bc93d2380bf0f496b786165dc32cc280e2e36b3858d1f14068c182888ebf508d663c2e1a1b7004bfab96e7692e6c52f1d7c8f954218d656a4300e19178bc12ee52a2def611c729eb250f4c756b38e51e48acd303b37d17ac6f7fbdf9071ee63fe95456cdd0ba9828c37d7721271703741499c923d7fda219d02184458dc0c2811955cd4a2f45a22bef5cb90926217e4d4c9f235bc2cfd3ea485bcd14971050e409ec727aeafe83b8c42f99a0a7ac4da3839bbbd788f47ed35e7c327c5dfee7061632de2bcec22a1ff18386b8f1b7fce1c030c2adcc3b263d44b7ab0e44b1cdc40dec2c95ddd912736ddcea70555f651f53e4f901db072a32bd5a60c3e3942ba34865bd2698a709343aa7365c6bfff466c8e8cd74ab353f41fe8f1ee32fba6ca5c1774f340728240d5baed8a0ee41c9e7cc10e03028c4a0a0a2bb83b553e173034df573e525bceb745e028174cd0ea90b2eed7de626f6dc7920300a1742818eec58dc13dcbe2e0cada88d3bbb66f6e4e527baa73a35c8d1640471b6044a034495566c095ec7db9b2271cc73cd17342b5678268bc4cf727f75266983139ea6de4e00a4d8dcde44609974a73e85a0b1cbda36d2c5a8f8d368960da4bab728994749555bc1f151d6724291599c1ba289cca19f9103cbff5537975f3957e0d44deb17b2819e96a718d270b06631467afc6fc7a483a459e4a1038520f8eb00d1548955b5dca4f3b36dd8c2064cb21401c47dcfe53446aab312b7fdc9468466490c3a60569d9642995affdb4b4c0cc04418c8213c4fc3c6737a5fae9cb5ecfea2334aeed4022996ad53e071dc3f332bc23a3f534cd281766d2bc99b915a47c53cb761d34437592b41a9bea34e5267df760d47ad3da4dda5747054f5cd4d80e062c375b8b0f35dff4203a9ac1aad0c924ae6e7ca47137a61dfdc672b9bba405a9d38e5f7925dbafd6e6612f364ac94ed2fe9e491deb8a0bac29050a30adc3c352ff4967f42f6951725ae9e8603f7ebabc05ab18f9ba84442a65c050155c348e7ff457c7cfdb81690bc8ffd0785c54a86b5776d225f7d7ae745747791ba1cac0285c3907999a2efe2a27d62d206ccc59fec594b79d5fedabaad3cd4247c658ba5ad775c5c58f76252f3e47181cb516dca5497c0b570cf3fe978415567d9720fa9fd1c5bb3abb1dd2ea1426435cfb9dbafdf2ec262daf014adec7448f8e8b6247c3c487029f6cdb6a6d1ca3d6dc2b3e2e1f88486a815af36670cbde31bbf67e1f8eaf3426f17effd2406d8b00818e3c1841696785cba99eb05fb96f4873164bb1be1555fd9bdc9b2ad153fc1ea89b1cc381125bfd60494092475e8dfd6946596d6e7d362c54e9a6baa5edb5cd0de619d044ae5b9ca0cdb3a8a039d6e1bb3963fbd40d5eba2c7895055e71286187376cb91d17e2d454bddb0dbd53a8c202499b03705dcbfb37a811916eb5d1de2dee48e1cf9764928df923265d46bc04f9483bf7cb9bd14fc7127e51fd7d3d64a19d129be80e9cd026b101dc8b60612c8a206f09222e968c99f6a40adf02ba21e88c4b42ddeeb6f274f46f69cc7d3ddbbc3fa309edb6552d130c9a498ea1f5550dd535541a7f91b0e2dee69174e97f2e10395c2d355e5784940a644ebb379f5a209ef774dfd845c4869fecd190de77b1bd092ba1ae3eb71190a7e01307ebed64b8eb9edb70269e8aa0dbe34980a7afaf5f5d12a9d58dabe199fe1d6e966320f8f3b80afa1859fd9048f453b0d12f9133caf6eea3959eb459610b6466c90126cc6838ddedd5b90e564afb932ead51e899a825afa46b531312833afabead5307aeee5fcca1997cde5759ff73685fe88ab0d9085f9abe7f16f457cb04bc0a64d13baf88ea602f18136cadb7aca85479515e5f711dacff42c579c8fb43a8dafec5047cd9d73ebe44275accb64bb3af46046eb776407637f5e389f616a1736785c5374775dbae9052e478dbf177b983f9c839a4098302842550b84469673c337c78751d36b6e6cb9263d244262f030ec615c13599eaaf53390053437d23c32d699758e06bc849b89f148decb901828961dc0a7da9b518a2cd5919061fbeca6212f1515ddcaed8cbff19e23e20fc009490239e314f5335dad6885af5b92550e87183b9769fd55a6bcb7ff71ec0a143907f010558bc313ed60b36758291237d5b1d0e14b5d5a6f897ba3b0eaa7ed6e44f4728541f1a9345df21005a02dd7635435c2bafed0077fc46865ffb44e97546402f522f0e002f6b8f54e27d1aa7e990c14987ac64758f5bc7593db8906a904ac3f90a6201d6e203cb60faa81d0eb8d04aca8960756d48cc06921790d8255be4bc41e461b87bba0914877445fe78414c832dc0ac4883a9f32fdfa9c553fd086ab48398f6e82635133224fcb3ea2001bd464ea7a7f5ee5d769d0a876e078217d487bb220d2cbb3358c1e52692d025ab438c4348d12a9663fe41a1b16c00bb25234e6d964d762c3b82840cc8f6c608859496a5a89a0ac5ae43e031cc16d151a94cc2ecd0c46688bf01308bddae774bd566d3bc6595d12786ccb828c2a5d16be01f7b7dac4b0ee5c47169d2dccf3212aaf3339030abee67ffe3372f936327c953eac98bdd682adebfeb14ed975d77ac2e91e622ce92fa92bfd8d6d4ef968fd4712a52267fdc5e200e65dce51afd60be7b4a0cf9d28f33be0fae3a1f1cc441a715ee1afc715f31d8cdb8b4a378d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
